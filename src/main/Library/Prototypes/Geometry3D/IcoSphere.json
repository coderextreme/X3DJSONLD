{ "X3D": {
    "encoding":"UTF-8",
    "@profile":"Full",
    "@version":"3.3",
    "@xsd:noNamespaceSchemaLocation":"http://www.web3d.org/specifications/x3d-3.3.xsd",
    "JSON schema":"http://www.web3d.org/specifications/x3d-3.3-JSONSchema.json",
    "head": {
        "meta": [
          {
            "@name":"comment",
            "@content":"World of Titania"
          },
          {
            "@name":"created",
            "@content":"Sun, 20 Sep 2015 06:48:35 GMT"
          },
          {
            "@name":"creator",
            "@content":"Holger Seelig"
          },
          {
            "@name":"generator",
            "@content":"Titania V1.1.0, http://titania.create3000.de"
          },
          {
            "@name":"modified",
            "@content":"Sun, 20 Sep 2015 06:48:35 GMT"
          },
          {
            "@name":"translated",
            "@content":"25 May 2018"
          },
          {
            "@name":"generator",
            "@content":"X3dToJson.xslt, http://www.web3d.org/x3d/stylesheets/X3dToJson.html"
          },
          {
            "@name":"reference",
            "@content":"X3D JSON encoding: http://www.web3d.org/wiki/index.php/X3D_JSON_Encoding"
          }
        ]
    },
    "Scene": {
        "-children":[
          { "ProtoDeclare":
            {
              "@name":"IcoSphere",
              "ProtoInterface": {
                  "field": [
                    {
                      "@name":"type",
                      "@accessType":"inputOutput",
                      "@type":"SFString",
                      "@value":"ICOSAHEDRON"
                    },
                    {
                      "@name":"order",
                      "@accessType":"inputOutput",
                      "@type":"SFInt32",
                      "@value":2
                    },
                    {
                      "@name":"radius",
                      "@accessType":"inputOutput",
                      "@type":"SFFloat",
                      "@value":1
                    },
                    {
                      "@name":"solid",
                      "@accessType":"initializeOnly",
                      "@type":"SFBool",
                      "@value":true
                    }
                  ]
              },
              "ProtoBody": {
                  "-children":[
                    { "IndexedFaceSet":
                      {
                        "@DEF":"Geometry",
                        "@creaseAngle":3.14159,
                        "IS": {
                            "connect": [
                              {
                                "@nodeField":"solid",
                                "@protoField":"solid"
                              }
                            ]
                        },
                        "-texCoord":
                          { "TextureCoordinate":
                            {
                            }
                          },
                        "-coord":
                          { "Coordinate":
                            {
                            }
                          }
                      }
                    },
                    { "Script":
                      {
                        "@DEF":"IcoSphere",
                        "@directOutput":true,
                        "field": [
                          {
                            "@name":"type",
                            "@accessType":"inputOutput",
                            "@type":"SFString"
                          },
                          {
                            "@name":"order",
                            "@accessType":"inputOutput",
                            "@type":"SFInt32"
                          },
                          {
                            "@name":"radius",
                            "@accessType":"inputOutput",
                            "@type":"SFFloat"
                          },
                          {
                            "@name":"geometry",
                            "@accessType":"initializeOnly",
                            "@type":"SFNode",
                            "-children":[
                              { "IndexedFaceSet":
                                {
                                  "@USE":"Geometry"
                                }
                              }
                            ]
                          }
                        ],
                        "IS": {
                            "connect": [
                              {
                                "@nodeField":"type",
                                "@protoField":"type"
                              },
                              {
                                "@nodeField":"order",
                                "@protoField":"order"
                              },
                              {
                                "@nodeField":"radius",
                                "@protoField":"radius"
                              }
                            ]
                        },
                        "#sourceText":[
"",
"ecmascript:",
"",
"var p = (1 + Math .sqrt (5)) / 2; // Golden ratio",
"",
"IcoSphere = function (type, order, radius)",
"{",
"\tthis .type   = type;",
"\tthis .order  = order;",
"\tthis .radius = radius;",
"",
"\tthis .coord ();",
"\tthis .sphericalMapping (this .coordIndex, this .point);",
"\tthis .applyRadius ();",
"}",
"",
"IcoSphere .prototype .getCoordIndex = function ()",
"{",
"\treturn this .coordIndex;",
"}",
"",
"IcoSphere .prototype .getPoint = function ()",
"{",
"\treturn this .point;",
"}",
"",
"IcoSphere .prototype .getTexCoordIndex = function ()",
"{",
"\treturn this .texCoordIndex;",
"}",
"",
"IcoSphere .prototype .getTexPoint = function ()",
"{",
"\treturn this .texPoint;",
"}",
"",
"IcoSphere .prototype .coord = function ()",
"{",
"\tthis .point      = new MFVec3f ();",
"\tthis .coordIndex = MFInt32 ();",
"",
"\tthis .middlePointIndexCache = [ ];",
"",
"\tif (this .type == 'OCTAHEDRON')",
"\t\tthis .octahedron ();",
"",
"\telse",
"\t\tthis .icosahedron ();",
"",
"\tthis .refineTriangles ();",
"}",
"",
"IcoSphere .prototype .octahedron = function ()",
"{",
"\tvar coordIndex = this .coordIndex;",
"\t",
"\tthis .addPoint (0,  1,  0);",
"\t",
"\tthis .addPoint ( 0,  0,  1);",
"\tthis .addPoint ( 1,  0,  0);",
"\tthis .addPoint ( 0,  0, -1);",
"\tthis .addPoint (-1,  0,  0);",
"",
"\tthis .addPoint ( 0, -1,  0);",
"\t",
"\t// 8 faces",
"\tthis .addTriangle (coordIndex, 0, 1, 2);",
"\tthis .addTriangle (coordIndex, 0, 2, 3);",
"\tthis .addTriangle (coordIndex, 0, 3, 4);",
"\tthis .addTriangle (coordIndex, 0, 4, 1);",
"\t",
"\tthis .addTriangle (coordIndex, 5, 2, 1);",
"\tthis .addTriangle (coordIndex, 5, 3, 2);",
"\tthis .addTriangle (coordIndex, 5, 4, 3);",
"\tthis .addTriangle (coordIndex, 5, 1, 4);",
"}",
"",
"IcoSphere .prototype .icosahedron = function ()",
"{",
"\tvar coordIndex = this .coordIndex;",
"",
"\t// Create 12 vertices of a icosahedron",
"\tthis .addPoint (-1,  p,  0);",
"\tthis .addPoint ( 1,  p,  0);",
"\tthis .addPoint (-1, -p,  0);",
"\tthis .addPoint ( 1, -p,  0);",
"",
"\tthis .addPoint ( 0, -1,  p);",
"\tthis .addPoint ( 0,  1,  p);",
"\tthis .addPoint ( 0, -1, -p);",
"\tthis .addPoint ( 0,  1, -p);",
"",
"\tthis .addPoint ( p,  0, -1);",
"\tthis .addPoint ( p,  0,  1);",
"\tthis .addPoint (-p,  0, -1);",
"\tthis .addPoint (-p,  0,  1);",
"\t",
"\t// Rotate point thus a vertice is a pole",
"\tif (order % 2 == 0)",
"\t{",
"\t\tvar rotation = new SFRotation (0, 0, 1, Math .atan (1 / p))",
"\t\t               .multiply (new SFRotation (0, 1, 0, -Math .PI / 10));",
"",
"\t\tfor (var i = 0; i < this .point .length; ++ i)",
"\t\t\tthis .point [i] = rotation .multVec (this .point [i]);",
"\t}",
"",
"\t// 5 faces around point 0",
"\tthis .addTriangle (coordIndex, 0, 11,  5);",
"\tthis .addTriangle (coordIndex, 0,  5,  1);",
"\tthis .addTriangle (coordIndex, 0,  1,  7);",
"\tthis .addTriangle (coordIndex, 0,  7, 10);",
"\tthis .addTriangle (coordIndex, 0, 10, 11);",
"",
"\t// 5 adjacentcoordIndex,  faces",
"\tthis .addTriangle (coordIndex,  1,  5,  9);",
"\tthis .addTriangle (coordIndex,  5, 11,  4);",
"\tthis .addTriangle (coordIndex, 11, 10,  2);",
"\tthis .addTriangle (coordIndex, 10,  7,  6);",
"\tthis .addTriangle (coordIndex,  7,  1,  8);",
"",
"\t// 5 faces arcoordIndex, ound point 3",
"\tthis .addTriangle (coordIndex,  3,  9,  4);",
"\tthis .addTriangle (coordIndex,  3,  4,  2);",
"\tthis .addTriangle (coordIndex,  3,  2,  6);",
"\tthis .addTriangle (coordIndex,  3,  6,  8);",
"\tthis .addTriangle (coordIndex,  3,  8,  9);",
"",
"\t// 5 adjacentcoordIndex,  faces",
"\tthis .addTriangle (coordIndex,  4,  9,  5);",
"\tthis .addTriangle (coordIndex,  2,  4, 11);",
"\tthis .addTriangle (coordIndex,  6,  2, 10);",
"\tthis .addTriangle (coordIndex,  8,  6,  7);",
"\tthis .addTriangle (coordIndex,  9,  8,  1);",
"}",
"",
"IcoSphere .prototype .refineTriangles = function ()",
"{",
"\tvar coordIndex = this .coordIndex;",
"",
"\t// Refine triangles",
"\tfor (var o = 0; o < this .order; ++ o)",
"\t{",
"\t\tvar coordIndex2 = new MFInt32 ();",
"",
"\t\tfor (var i = 0; i < coordIndex .length; i += 4)",
"\t\t{",
"\t\t\t// Replace triangle by 4 triangles",
"\t\t\tvar a = this .getMiddlePoint (coordIndex [i],     coordIndex [i + 1]);",
"\t\t\tvar b = this .getMiddlePoint (coordIndex [i + 1], coordIndex [i + 2]);",
"\t\t\tvar c = this .getMiddlePoint (coordIndex [i + 2], coordIndex [i]);",
"",
"\t\t\tthis .addTriangle (coordIndex2, coordIndex [i],     a, c);",
"\t\t\tthis .addTriangle (coordIndex2, coordIndex [i + 1], b, a);",
"\t\t\tthis .addTriangle (coordIndex2, coordIndex [i + 2], c, b);",
"\t\t\tthis .addTriangle (coordIndex2, a, b, c);",
"\t\t}",
"",
"\t\tcoordIndex = coordIndex2;",
"\t}",
"\t",
"\tthis .coordIndex = coordIndex;",
"}",
"",
"IcoSphere .prototype .addPoint = function (x, y, z)",
"{",
"\tvar index = this .point .length;",
"\tthis .point [index] = new SFVec3f (x, y, z) .normalize ();",
"\treturn index;",
"}",
"",
"IcoSphere .prototype .addTriangle = function (coordIndex, i1, i2, i3)",
"{",
"\tcoordIndex [coordIndex .length] = i1;",
"\tcoordIndex [coordIndex .length] = i2;",
"\tcoordIndex [coordIndex .length] = i3;",
"\tcoordIndex [coordIndex .length] = -1;",
"}",
"",
"IcoSphere .prototype .getMiddlePoint = function (p1, p2)",
"{",
"\t// First check if we have it already",
"\tvar firstIsSmaller = p1 < p2;",
"\tvar smallerIndex   = firstIsSmaller ? p1 : p2;",
"\tvar greaterIndex   = firstIsSmaller ? p2 : p1;",
"\tvar key            = smallerIndex + '+' + greaterIndex;",
"",
"\tif (key in this .middlePointIndexCache)",
"\t\treturn this .middlePointIndexCache [key];",
"",
"\t// Not in cache, calculate it",
"\tvar point1 = this .point [p1];",
"\tvar point2 = this .point [p2];",
"\t",
"\t// Add middle point, makes sure point is on unit sphere",
"\tvar index = this .addPoint ((point1 .x + point2 .x) / 2,",
"\t                            (point1 .y + point2 .y) / 2,",
"\t                            (point1 .z + point2 .z) / 2);",
"",
"\t// Store it, return index",
"\tthis .middlePointIndexCache [key] = index;",
"",
"\treturn index;",
"}",
"",
"IcoSphere .prototype .sphericalMapping = function (coordIndex, point)",
"{",
"\tthis .poleThreshold    = 0.001;",
"\tthis .overlapThreshold = 0.5;",
"",
"\t//",
"\t// Create texture coordinates",
"\t//",
"",
"\t// Copy coordIndex",
"\tvar texCoordIndex = new MFInt32 ();",
"\t",
"\tfor (var i = 0; i < coordIndex .length; ++ i)",
"\t\ttexCoordIndex [i] = coordIndex [i];",
"",
"\t// Apply spherecical mapping",
"\tvar texPoint = new MFVec2f ();",
"\t",
"\tfor (var i = 0; i < point .length; ++ i)",
"\t{",
"\t\t// Always normalize to get rid of floating point errors.",
"\t\tvar normal   = point [i] .normalize ();",
"\t\ttexPoint [i] = new SFVec2f (Math .atan2 (normal .x, normal .z) / (2 * Math .PI) + 0.5,",
"\t\t                            Math .asin (normal .y) / Math .PI + 0.5);",
"\t}",
"",
"\tthis .texCoordIndex = texCoordIndex;",
"\tthis .texPoint      = texPoint;",
"",
"\t// Refine poles",
"\tvar northPoleThreshold = 1 - this .poleThreshold;",
"\tvar soutPoleThreshold  = this .poleThreshold;",
"\t",
"\tvar length = texCoordIndex .length;",
"\t",
"\tfor (var i = 0; i < length; i += 4)",
"\t{",
"\t\tvar i0 = -1, i1, i2;",
"\t\t",
"\t\t// Find north pole",
"\t\t",
"\t\tif (texPoint [texCoordIndex [i]] .y > northPoleThreshold)",
"\t\t{",
"\t\t\ti0 = i;",
"\t\t\ti1 = i + 1;",
"\t\t\ti2 = i + 2;",
"\t\t}",
"\t\t\t",
"\t\telse if (texPoint [texCoordIndex [i + 1]] .y > northPoleThreshold)",
"\t\t{",
"\t\t\ti0 = i + 1;",
"\t\t\ti1 = i;",
"\t\t\ti2 = i + 2;",
"\t\t}",
"\t\t",
"\t\telse if (texPoint [texCoordIndex [i + 2]] .y > northPoleThreshold)",
"\t\t{",
"\t\t\ti0 = i + 2;",
"\t\t\ti1 = i;",
"\t\t\ti2 = i + 1;",
"\t\t}",
"",
"\t\t// North pole found",
"\t\tif (i0 > -1)",
"\t\t{",
"\t\t\tvar index0 = texCoordIndex [i0]; // North pole",
"\t\t\tvar index1 = texCoordIndex [i1];",
"\t\t\tvar index2 = this. resolveOverlap (i1, i2);",
"\t\t",
"\t\t\ttexCoordIndex [i0]          = texPoint .length;",
"\t\t\ttexPoint [texPoint .length] = new SFVec2f ((texPoint [index1] .x + texPoint [index2] .x) / 2,",
"\t\t\t                                           texPoint [index0] .y);",
"\t\t\t",
"\t\t\tcontinue;",
"\t\t}",
"\t\t",
"\t\t// Find south pole",
"",
"\t\tif (texPoint [texCoordIndex [i]] .y < soutPoleThreshold)",
"\t\t{",
"\t\t\ti0 = i;",
"\t\t\ti1 = i + 1;",
"\t\t\ti2 = i + 2;",
"\t\t}",
"\t\t\t",
"\t\telse if (texPoint [texCoordIndex [i + 1]] .y < soutPoleThreshold)",
"\t\t{",
"\t\t\ti0 = i + 1;",
"\t\t\ti1 = i;",
"\t\t\ti2 = i + 2;",
"\t\t}",
"\t\t",
"\t\telse if (texPoint [texCoordIndex [i + 2]] .y < soutPoleThreshold)",
"\t\t{",
"\t\t\ti0 = i + 2;",
"\t\t\ti1 = i;",
"\t\t\ti2 = i + 1;",
"\t\t}",
"",
"\t\t// South pole found",
"\t\tif (i0 > -1)",
"\t\t{",
"\t\t\tvar index0 = texCoordIndex [i0]; // South pole",
"\t\t\tvar index1 = texCoordIndex [i1];",
"\t\t\tvar index2 = this. resolveOverlap (i1, i2);",
"",
"\t\t\ttexCoordIndex [i0]          = texPoint .length;",
"\t\t\ttexPoint [texPoint .length] = new SFVec2f ((texPoint [index1] .x + texPoint [index2] .x) / 2,",
"\t\t\t                                           texPoint [index0] .y);",
"\t\t\t",
"\t\t\tcontinue;",
"\t\t}",
"\t\t",
"\t\tthis. resolveOverlap (i, i + 1);",
"\t\tthis. resolveOverlap (i, i + 2);",
"\t}",
"}",
"",
"",
"IcoSphere .prototype .resolveOverlap = function (i0, i1)",
"{",
"\tvar texCoordIndex = this .texCoordIndex;",
"\tvar texPoint      = this .texPoint;",
"",
"\tvar index1   = texCoordIndex [i1];",
"\tvar distance = texPoint [texCoordIndex [i0]] .x - this .texPoint [index1] .x;",
"\t",
"\tif (distance > this .overlapThreshold)",
"\t{",
"\t\ttexCoordIndex [i1]          = texPoint .length;",
"\t\ttexPoint [texPoint .length] = new SFVec2f (texPoint [index1] .x + 1,",
"\t\t                                           texPoint [index1] .y);",
"\t}",
"\telse if (distance < -this .overlapThreshold)",
"\t{",
"\t\ttexCoordIndex [i1]          = texPoint .length;",
"\t\ttexPoint [texPoint .length] = new SFVec2f (texPoint [index1] .x - 1,",
"\t\t                                           texPoint [index1] .y);\t",
"\t}",
"",
"\treturn texCoordIndex [i1];",
"}",
"",
"IcoSphere .prototype .applyRadius = function ()",
"{",
"\tif (this .radius == 1)",
"\t\treturn;",
"",
"\tfor (var i = 0; i < this .point .length; ++ i)",
"\t\tthis .point [i] = this .point [i] .multiply (this .radius);",
"}",
"",
"function initialize ()",
"{",
"\teventsProcessed ();",
"}",
"",
"function eventsProcessed ()",
"{",
"\tvar icoSphere = new IcoSphere (type, order, radius);",
"",
"\tgeometry .texCoord .point = icoSphere .getTexPoint ();",
"\tgeometry .coord .point    = icoSphere .getPoint ();",
"",
"\tgeometry .set_texCoordIndex = icoSphere .getTexCoordIndex ();",
"\tgeometry .set_coordIndex    = icoSphere .getCoordIndex ();",
"}",
"",
""
]
                      }
                    }
                  ]
              }
            }
          }
        ]
    }
  }
}