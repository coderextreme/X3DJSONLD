<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "https://www.web3d.org/specifications/x3d-3.3.dtd">
<X3D profile='Full' version='3.3' xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.3.xsd'>
  <head>
    <meta content='World of Titania' name='comment'/>
    <meta content='Sun, 20 Sep 2015 06:48:36 GMT' name='created'/>
    <meta content='Holger Seelig' name='creator'/>
    <meta content='Titania V1.1.0, http://titania.create3000.de' name='generator'/>
    <meta content='Sun, 20 Sep 2015 06:48:36 GMT' name='modified'/>
  </head>
  <Scene>
    <ProtoDeclare name='QuadSphere'>
      <ProtoInterface>
        <field name='uDimension' accessType='inputOutput' type='SFInt32' value='21'/>
        <field name='vDimension' accessType='inputOutput' type='SFInt32' value='11'/>
        <field name='radius' accessType='inputOutput' type='SFFloat' value='1.0'/>
        <field name='solid' accessType='initializeOnly' type='SFBool' value='true'/>
      </ProtoInterface>
      <ProtoBody>
        <IndexedFaceSet DEF='Geometry' creaseAngle='3.14159'>
          <IS>
            <connect nodeField='solid' protoField='solid'/>
          </IS>
          <Coordinate/>
          <TextureCoordinate/>
        </IndexedFaceSet>
        <Script DEF='QuadSphere' directOutput='true'>
          <field name='uDimension' accessType='inputOutput' type='SFInt32'/>
          <field name='vDimension' accessType='inputOutput' type='SFInt32'/>
          <field name='radius' accessType='inputOutput' type='SFFloat'/>
          <field name='geometry' accessType='initializeOnly' type='SFNode'>
            <IndexedFaceSet USE='Geometry'/>
          </field>
          <IS>
            <connect nodeField='uDimension' protoField='uDimension'/>
            <connect nodeField='vDimension' protoField='vDimension'/>
            <connect nodeField='radius' protoField='radius'/>
          </IS>
<![CDATA[
ecmascript:

function initialize ()
{
	eventsProcessed ();
}

function eventsProcessed ()
{
	geometry .texCoord .point   = texCoord ();
	geometry .coord .point      = points ();

	geometry .set_texCoordIndex = texCoordIndex ();
	geometry .set_coordIndex    = coordIndex ();
}

function texCoordIndex ()
{
	var texIndices = new MFInt32 ();
	
	var i = 0;
	
	// North pole
	
	for (var u = 0; u < uDimension - 1; ++ u)
	{
		texIndices [i ++] = u;
		texIndices [i ++] = u + uDimension - 1;
		texIndices [i ++] = u + uDimension;
		texIndices [i ++] = -1;
	}

	// Sphere segments
	
	for (var p = uDimension - 1, v = 0; v < vDimension - 3; ++ v, ++ p)
	{
		for (var u = 0; u < uDimension - 1; ++ u, ++ p)
		{
			texIndices [i ++] = p;
			texIndices [i ++] = p + uDimension;
			texIndices [i ++] = p + uDimension + 1;
			texIndices [i ++] = p + 1;
			texIndices [i ++] = -1;
		}
	}
	
	// South pole

	var p = (vDimension - 2) * uDimension - 1;

	for (var u = 0; u < uDimension - 1; ++ u, ++ p)
	{
		texIndices [i ++] = p + uDimension;
		texIndices [i ++] = p + 1;
		texIndices [i ++] = p;
		texIndices [i ++] = -1;
	}

	return texIndices;
}

function texCoord ()
{
	var texCoord = new MFVec2f ();

	var poleOffset = -0.5 / (uDimension - 1);
	var i          = 0;

	// North pole
	
	for (var u = 1; u < uDimension; ++ u)
	{
		var x = u / (uDimension - 1) + poleOffset;
		
		texCoord [i ++] = new SFVec2f (x, 1);
	}

	// Sphere segments
	
	for (var v = 1; v < vDimension - 1; ++ v)
	{
		var y = 1 - v / (vDimension - 1);
		
		for (var u = 0; u < uDimension; ++ u)
		{
			var x = u / (uDimension - 1);
			
			texCoord [i ++] = new SFVec2f (x, y);
		}
	}

	// South pole
	
	for (var u = 1; u < uDimension; ++ u)
	{
		var x = u / (uDimension - 1) + poleOffset;
		
		texCoord [i ++] = new SFVec2f (x, 0);
	}

	return texCoord;
}

function coordIndex ()
{
	var index = new MFInt32 ();
	
	var i = 0;

	// North pole
	
	for (var u = 1; u < uDimension - 1; ++ u)
	{
		index [i ++] = 0;
		index [i ++] = u;
		index [i ++] = u + 1;
		index [i ++] = -1;
	}
	index [i ++] = 0;
	index [i ++] = u;
	index [i ++] = 1;
	index [i ++] = -1;

	// Sphere segments
	
	var p = 1;
	for (var v = 0; v < vDimension - 3; ++ v, ++ p)
	{
		for (var u = 0; u < uDimension - 2; ++ u, ++ p)
		{
			index [i ++] = p;
			index [i ++] = p + uDimension - 1;
			index [i ++] = p + uDimension;
			index [i ++] = p + 1;
			index [i ++] = -1;
		}
		index [i ++] = p;
		index [i ++] = p + uDimension - 1;
		index [i ++] = p + 1;
		index [i ++] = p - uDimension + 2;
		index [i ++] = -1;
	}

	// South pole
	
	var last = p + uDimension - 1;
	for (var u = 0; u < uDimension - 2; ++ u, ++ p)
	{
		index [i ++] = last;
		index [i ++] = p + 1;
		index [i ++] = p;
		index [i ++] = -1;
	}
	index [i ++] = last;
	index [i ++] = last - uDimension + 1;
	index [i ++] = p;
	index [i ++] = -1;

	return index;
}

function points ()
{
	var point = new MFVec3f ();
	
	// North pole
	
	point [0] = new SFVec3f (0, 1, 0) .multiply (radius);

	// Sphere segments
	
	var i = point .length;

	for (var v = 1; v < vDimension - 1; ++ v)
	{
		var p = Math .PI * (v / (vDimension - 1));
		var y = Math .cos (p);
		var r = Math .sin (p);

		for (u = 0; u < uDimension - 1; ++ u)
		{
			var t = 2 * Math .PI * (u / (uDimension - 1) + 0.5);
			var x = Math .sin (t) * r;
			var z = Math .cos (t) * r;

			point [i ++] = new SFVec3f (x, y, z) .multiply (radius);
		}
	}
		
	// South pole

	point [point .length] = new SFVec3f (0, -1, 0) .multiply (radius);

	return point;
}
]]>
        </Script>
      </ProtoBody>
    </ProtoDeclare>
  </Scene>
</X3D>
