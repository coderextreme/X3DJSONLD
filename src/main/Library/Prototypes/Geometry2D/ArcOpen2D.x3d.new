<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "https://www.web3d.org/specifications/x3d-3.3.dtd">
<X3D xmlns:xsd="http://www.w3.org/2001/XMLSchema-instance" profile="Full" version="3.3" xsd:noNamespaceSchemaLocation="http://www.web3d.org/specifications/x3d-3.3.xsd" ><head><meta name="comment" content="World of Titania"></meta>
<meta name="created" content="Fri, 21 Dec 2018 02:11:05 GMT"></meta>
<meta name="creator" content="Holger Seelig"></meta>
<meta name="generator" content="Titania V4.3.9, http://titania.create3000.de"></meta>
<meta name="identifier" content="file:///home/holger/Projekte/Library/Prototypes/Geometry2D/ArcOpen2D.x3d"></meta>
<meta name="modified" content="Mon, 07 Jan 2019 04:03:57 GMT"></meta>
</head>
<Scene><ProtoDeclare name="ArcOpen2D"><ProtoInterface><field name="dimension" accessType="inputOutput" type="SFInt32" value="16"></field>
<field name="startAngle" accessType="inputOutput" type="SFFloat"></field>
<field name="endAngle" accessType="inputOutput" type="SFFloat" value="1.5708"></field>
<field name="innerRadius" accessType="inputOutput" type="SFFloat" value="0.5"></field>
<field name="outerRadius" accessType="inputOutput" type="SFFloat" value="1"></field>
<field name="solid" accessType="initializeOnly" type="SFBool"></field>
</ProtoInterface>
<ProtoBody><IndexedFaceSet DEF="_1" normalPerVertex="false" coordIndex="0 1 3 2 -1 2 3 5 4 -1 4 5 7 6 -1 6 7 9 8 -1 8 9 7 6 -1 6 7 5 4 -1 4 5 3 2 -1 2 3 1 0 -1"><TextureCoordinate containerField="texCoord" point="0.75 0.5 1 0.5 0.73097 0.595671 0.96194 0.691342 0.676776 0.676777 0.853553 0.853554 0.59567 0.73097 0.69134 0.96194 0.499999 0.75 0.499998 1"></TextureCoordinate>
<Coordinate containerField="coord" point="0.5 0 0 1 0 0 0.46194 0.191342 0 0.923879 0.382684 0 0.353553 0.353554 0 0.707106 0.707108 0 0.19134 0.46194 0 0.382681 0.923881 0 -0.00000181 0.5 0 -0.00000361999 1 0"></Coordinate>
</IndexedFaceSet>
<Script DEF="ArcOpen2DScript" directOutput="true"><field name="dimension" accessType="inputOutput" type="SFInt32"></field>
<field name="startAngle" accessType="inputOutput" type="SFFloat"></field>
<field name="endAngle" accessType="inputOutput" type="SFFloat"></field>
<field name="innerRadius" accessType="inputOutput" type="SFFloat"></field>
<field name="outerRadius" accessType="inputOutput" type="SFFloat"></field>
<field name="solid" accessType="inputOutput" type="SFBool"></field>
<field name="geometry" accessType="initializeOnly" type="SFNode"><IndexedFaceSet USE="_1"></IndexedFaceSet>
</field>
<IS><connect nodeField="dimension" protoField="dimension"></connect>
<connect nodeField="startAngle" protoField="startAngle"></connect>
<connect nodeField="endAngle" protoField="endAngle"></connect>
<connect nodeField="innerRadius" protoField="innerRadius"></connect>
<connect nodeField="outerRadius" protoField="outerRadius"></connect>
<connect nodeField="solid" protoField="solid"></connect>
</IS>
<![CDATA[ecmascript:

function initialize ()
{
	eventsProcessed ();
}

function eventsProcessed ()
{
	var
		texCoord   = geometry .texCoord,
		coord      = geometry .coord,
		r1         = Math .min (Math .abs (innerRadius), Math .abs (outerRadius)),
		r2         = Math .max (Math .abs (innerRadius), Math .abs (outerRadius)),
		sweepAngle = getSweepAngle (),
		circle     = sweepAngle === Math .PI * 2,
		disk       = r1 === 0,
		steps      = Math .floor (sweepAngle * dimension / (Math .PI * 2));

	steps = Math .max (3, steps);

	if (! circle)
		++ steps;

	var steps_1 = circle ? steps : steps - 1;
	
	coord .point .length         = 0;
	texCoord .point .length      = 0;

	if (r1 === r2)
		return;
		
	var
		coordIndex = new MFInt32 (),
		texOffset  = new SFVec3f (r2, r2, 0);

	for (var n = 0; n < steps; ++ n)
	{
		var
			t     = n / steps_1,
			theta = startAngle + (sweepAngle * t),
			x     = Math .cos (theta),
			y     = Math .sin (theta),
			point = new SFVec3f (x, y, 0);

		if (! disk)
		{
			var
				point1 = point .multiply (r1),
				tex1   = point1 .add (texOffset) .divide (r2 * 2);
				
			coord .point .push (point1);
			texCoord .point .push (new SFVec2f (tex1 .x, tex1 .y));
		}

		var
			point2 = point .multiply (r2),
			tex2   = point2 .add (texOffset) .divide (r2 * 2);

		coord .point .push (point2);
		texCoord .point .push (new SFVec2f (tex2 .x, tex2 .y));
	}

	if (disk)
	{
		if (circle)
		{
			for (var n = 0; n < steps; ++ n)
				coordIndex .push (n);

			coordIndex .push (-1);
		}
		else
		{
			var l = coord .point .length;
			
			coord .point .push (new SFVec3f ());
			texCoord .point .push (new SFVec2f (0.5, 0.5));
		
			for (var n = 0; n < steps - 1; ++ n)
			{
				coordIndex .push (n);
				coordIndex .push (n + 1);
				coordIndex .push (l);
				coordIndex .push (-1);
			}
		}
	}
	else
	{
		for (var n = 0; n < steps - 1; ++ n)
		{
			var i = n * 2;

			coordIndex .push (i);
			coordIndex .push (i + 1);
			coordIndex .push (i + 3);
			coordIndex .push (i + 2);
			coordIndex .push (-1);
		}
	}
		
	if (circle)
	{
		var
			l1 = coordIndex [coordIndex .length - 2],
			l2 = coordIndex [coordIndex .length - 3];
	
		coordIndex .push (l1);
		coordIndex .push (l2);
		coordIndex .push (coordIndex [1]);
		coordIndex .push (coordIndex [0]);
		coordIndex .push (-1);
	}

	if (! solid)
	{
		for (var i = 1, length = coordIndex .length; i < length; ++ i)
			coordIndex .push (coordIndex [length - 1 - i]);

		coordIndex .push (-1);
	}
	
	geometry .set_coordIndex = coordIndex;
}

function getSweepAngle ()
{
	var
		start = interval (startAngle, 0, Math .PI * 2),
		end   = interval (endAngle,   0, Math .PI * 2);

	if (start === end)
		return Math .PI * 2;

	var sweepAngle = Math .abs (end - start);

	if (start > end)
		return Math .PI * 2 - sweepAngle;

	if (! isNaN (sweepAngle))
		return sweepAngle;
	
	// We must test for NAN, as NAN to int32_t is undefined.
	return 0;
}

function interval (value, low, high)
{
	if (value >= high)
		return (value - low) % (high - low) + low;

	if (value < low)
		return (value - high) % (high - low) + high;

	return value;
}]]></Script>
</ProtoBody>
</ProtoDeclare>
<WorldInfo title="ArcOpen2D"><MetadataSet containerField="metadata" name="Titania" DEF="Titania" reference="http://titania.create3000.de"><MetadataSet name="Page" DEF="Page" reference="http://titania.create3000.de" containerField="value"><MetadataInteger name="activeView" DEF="activeView" reference="http://titania.create3000.de" value="1" containerField="value"></MetadataInteger>
<MetadataInteger name="multiView" DEF="multiView" reference="http://titania.create3000.de" value="0"></MetadataInteger>
</MetadataSet>
<MetadataSet name="Selection" DEF="Selection" reference="http://titania.create3000.de"><MetadataBoolean name="selectGeometry" DEF="selectGeometry" reference="http://titania.create3000.de" value="false" containerField="value"></MetadataBoolean>
</MetadataSet>
</MetadataSet>
</WorldInfo>
</Scene>
</X3D>