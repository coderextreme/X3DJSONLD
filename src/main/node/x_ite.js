(function () {

var x_iteNoConfict = {
	sprintf:  window .sprintf,
	vsprintf: window .vsprintf,
};

var module = { };
/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.6 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.6',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttps://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));

define("../node_modules/requirejs/require.js", function(){});

/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.


var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.5.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
					dataPriv.get( this, "events" ) || Object.create( null )
				)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

define("jquery/dist/jquery", function(){});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Error',[
	"jquery",
],
function ($)
{
"use strict";

	// Everything went wrong when the Error function is called.

	function Error (error, fallbacks)
	{
		$(function ()
		{
		   var elements = $("X3DCanvas");

			Error .fallback (elements, error);

			for (var i = 0; i < fallbacks .length; ++ i)
			{
			   var fallback = fallbacks [i];

				if (typeof fallback === "function")
				   fallback (elements, error);
			}
		});
	}

	// In some browser went something wrong when the fallback function is called.

	function fallback (elements, error)
	{
		console .log (error);

		var consoleElement = $(".x_ite-console");

		if (consoleElement .length)
			consoleElement .append (document .createTextNode (error));

		elements .addClass ("x_ite-browser-fallback");
		elements .children (".x_ite-private-browser") .hide ();
		elements .children (":not(.x_ite-private-browser)") .addClass ("x_ite-fallback");
		elements .children (":not(.x_ite-private-browser)") .show ();
	}

	Error .fallback = fallback;

	return Error;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Basic/X3DFieldDefinition',[],function ()
{
"use strict";

	function X3DFieldDefinition (accessType, name, value)
	{
		this .accessType  = accessType;
		this .dataType    = value .getType ();
		this .name        = name;
		this .value       = value;

		Object .preventExtensions (this);
		Object .freeze (this);
		Object .seal (this);
	}

	X3DFieldDefinition .prototype .constructor = X3DFieldDefinition;

	return X3DFieldDefinition;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Basic/FieldDefinitionArray',[],function ()
{
"use strict";

	var handler =
	{
		get: function (target, key)
		{
			var value = target [key];

			if (value !== undefined)
				return value;

			return target .array [key];
		},
		set: function (target, key, value)
		{
			return false;
		},
		has: function (target, key)
		{
			if (Number .isInteger (+key))
				return key < target .array .length;

			return key in target;
		},
		enumerate: function (target)
		{
			var indices = [ ];

			for (var i = 0, length = target .array .length; i < length; ++ i)
				array .push (i);

			return indices [Symbol .iterator] ();
		},
	};

	function FieldDefinitionArray (value)
	{
		this .array = value;
		this .index = { };

		for (var i = 0, length = value .length; i < length; ++ i)
			this .index [value [i] .name] = value [i];

		return new Proxy (this, handler);
	}

	Object .assign (FieldDefinitionArray .prototype,
	{
		constructor: FieldDefinitionArray,
		add: function (fieldDefinition)
		{
			this .array .push (fieldDefinition);
			this .index [fieldDefinition .name] = fieldDefinition;
		},
		get: function (key)
		{
			return this .index [key];
		},
		getValue: function ()
		{
			return this .array;
		},
	});

	Object .defineProperty (FieldDefinitionArray .prototype, "length",
	{
		get: function () { return this .array .length; },
		enumerable: false,
		configurable: false
	});

	return FieldDefinitionArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Bits/X3DConstants',[],function ()
{
"use strict";

	var
		browserEvent = 0,
		loadState    = 0,
		fieldType    = 0;

	var X3DConstants =
	{
		// Browser event

		CONNECTION_ERROR:  browserEvent ++,
		BROWSER_EVENT:     browserEvent ++,
		INITIALIZED_EVENT: browserEvent ++,
		SHUTDOWN_EVENT:    browserEvent ++,
		INITIALIZED_ERROR: browserEvent ++,

		// Load state

		NOT_STARTED_STATE: loadState ++,
		IN_PROGRESS_STATE: loadState ++,
		COMPLETE_STATE:    loadState ++,
		FAILED_STATE:      loadState ++,

		// Access type

		initializeOnly: parseInt ('001', 2),
		inputOnly:      parseInt ('010', 2),
		outputOnly:     parseInt ('100', 2),
		inputOutput:    parseInt ('111', 2),

		// X3DField

		SFBool:      fieldType ++,
		SFColor:     fieldType ++,
		SFColorRGBA: fieldType ++,
		SFDouble:    fieldType ++,
		SFFloat:     fieldType ++,
		SFImage:     fieldType ++,
		SFInt32:     fieldType ++,
		SFMatrix3d:  fieldType ++,
		SFMatrix3f:  fieldType ++,
		SFMatrix4d:  fieldType ++,
		SFMatrix4f:  fieldType ++,
		SFNode:      fieldType ++,
		SFRotation:  fieldType ++,
		SFString:    fieldType ++,
		SFTime:      fieldType ++,
		SFVec2d:     fieldType ++,
		SFVec2f:     fieldType ++,
		SFVec3d:     fieldType ++,
		SFVec3f:     fieldType ++,
		SFVec4d:     fieldType ++,
		SFVec4f:     fieldType ++,

		VrmlMatrix:  fieldType ++,

		// X3DArrayField

		MFBool:      fieldType ++,
		MFColor:     fieldType ++,
		MFColorRGBA: fieldType ++,
		MFDouble:    fieldType ++,
		MFFloat:     fieldType ++,
		MFImage:     fieldType ++,
		MFInt32:     fieldType ++,
		MFMatrix3d:  fieldType ++,
		MFMatrix3f:  fieldType ++,
		MFMatrix4d:  fieldType ++,
		MFMatrix4f:  fieldType ++,
		MFNode:      fieldType ++,
		MFRotation:  fieldType ++,
		MFString:    fieldType ++,
		MFTime:      fieldType ++,
		MFVec2d:     fieldType ++,
		MFVec2f:     fieldType ++,
		MFVec3d:     fieldType ++,
		MFVec3f:     fieldType ++,
		MFVec4d:     fieldType ++,
		MFVec4f:     fieldType ++,

		// Abstract node

		X3DBaseNode: 0,
	};

	return X3DConstants;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/



define ('x_ite/InputOutput/Generator',[
	"x_ite/Bits/X3DConstants",
],
function (X3DConstants)
{
"use strict";

	function Generator ()
	{
		this .indent                = "";
		this .indentChar            = "  ";
		this .executionContextStack = [ null ];
		this .importedNodesIndex    = new Map ();
		this .exportedNodesIndex    = new Map ();
		this .nodes                 = new Set ();
		this .names                 = new Map ();
		this .namesByNode           = new Map ();
		this .importedNames         = new Map ();
		this .routeNodes            = new Set ();
		this .level                 = 0;
		this .newName               = 0;
		this .containerFields       = [ ];
		this .units                 = true;
		this .unitCategories        = [ ];

		this .names .set (null, new Map ());
	}

	Generator .prototype =
	{
		constructor: Generator,
		Indent: function ()
		{
			return this .indent;
		},
		IncIndent: function ()
		{
			this .indent += this .indentChar;
		},
		DecIndent: function ()
		{
			this .indent = this .indent .substr (0, this .indent .length - this .indentChar .length);
		},
		PadRight: function (string, pad)
		{
			for (var i = 0, length = pad - string .length; i < length; ++ i)
				string += " ";

			return string;
		},
		PushExecutionContext: function (executionContext)
		{
			this .executionContextStack .push (executionContext);

			if (! this .names .has (executionContext))
				this .names .set (executionContext, new Map ());

			if (! this .importedNodesIndex .has (executionContext))
				this .importedNodesIndex .set (executionContext, new Set ());

			if (! this .exportedNodesIndex .has (executionContext))
				this .exportedNodesIndex .set (executionContext, new Set ());
		},
		PopExecutionContext: function ()
		{
			this .executionContextStack .pop ();

			if (this .ExecutionContext ())
				return;

			this .importedNodesIndex .clear ();
			this .exportedNodesIndex .clear ();
		},
		ExecutionContext: function ()
		{
			return this .executionContextStack [this .executionContextStack .length - 1];
		},
		EnterScope: function ()
		{
			if (this .level === 0)
				this .newName = 0;

			++ this .level;
		},
		LeaveScope: function ()
		{
			-- this .level;

			if (this .level === 0)
			{
				this .nodes         .clear ();
				this .namesByNode   .clear ();
				this .importedNames .clear ();
			}
		},
		ExportedNodes: function (exportedNodes)
		{
			var index = this .exportedNodesIndex .get (this .ExecutionContext ());

			exportedNodes .forEach (function (exportedNode)
			{
				try
				{
					index .add (exportedNode .getLocalNode ())
				}
				catch (error)
				{ }
			});
		},
		ImportedNodes: function (importedNodes)
		{
			var index = this .importedNodesIndex .get (this .ExecutionContext ());

			importedNodes .forEach (function (importedNode)
			{
				try
				{
					index .add (importedNode .getInlineNode ());
				}
				catch (error)
				{ }
			});
		},
		AddImportedNode: function (exportedNode, importedName)
		{
			this .importedNames .set (exportedNode, importedName);
		},
		AddRouteNode: function (routeNode)
		{
			this .routeNodes .add (routeNode);
		},
		ExistsRouteNode: function (routeNode)
		{
			return this .routeNodes .has (routeNode);
		},
		IsSharedNode: function (baseNode)
		{
			return false;
		},
		AddNode: function (baseNode)
		{
			this .nodes .add (baseNode);

			this .AddRouteNode (baseNode);
		},
		ExistsNode: function (baseNode)
		{
			return this .nodes .has (baseNode);
		},
		Name: function (baseNode)
		{
			// Is the node already in index

			var name = this .namesByNode .get (baseNode);

			if (name !== undefined)
				return name;

			var names = this .names .get (this .ExecutionContext ());

			// The node has no name

			if (baseNode .getName () .length === 0)
			{
				if (this .NeedsName (baseNode))
				{
					var name = this .UniqueName ();

					names .set (name, baseNode);
					this .namesByNode .set (baseNode, name);

					return name;
				}

				// The node doesn't need a name

				return baseNode .getName ();
			}

			// The node has a name

			var _TrailingNumbers = /(_\d+$)/;

			var name      = baseNode .getName ();
			var hasNumber = name .match (_TrailingNumbers) !== null;

			name = name .replace (_TrailingNumbers, "");

			if (name .length === 0)
			{
				if (this .NeedsName (baseNode))
					name = this .UniqueName ();

				else
					return "";
			}
			else
			{
				var
					i       = 0,
					newName = hasNumber ? name + '_' + (++ i) : name;

				while (names .has (newName))
				{
					newName = name + '_' + (++ i);
				}

				name = newName;
			}

			names .set (name, baseNode);
			this .namesByNode .set (baseNode, name);

			return name;
		},
		NeedsName: function (baseNode)
		{
			if (baseNode .getCloneCount () > 1)
				return true;

			if (baseNode .hasRoutes ())
				return true;

			var
				executionContext = baseNode .getExecutionContext (),
				index            = this .importedNodesIndex .get (executionContext);

			if (index)
			{
				if (index .has (baseNode))
					return true;
			}

			var index = this .exportedNodesIndex .get (executionContext);

			if (index)
			{
				if (index .has (baseNode))
					return true;
			}

			return false;
		},
		UniqueName: function ()
		{
			var names = this .names .get (this .ExecutionContext ());

			for (; ;)
			{
				var name = '_' + (++ this .newName);

				if (names .has (name))
					continue;

				return name;
			}
		},
		LocalName: function (baseNode)
		{
			var importedName = this .importedNames .get (baseNode);

			if (importedName !== undefined)
				return importedName;

			if (this .ExistsNode (baseNode))
				return this .Name (baseNode);

			throw new Error ("Couldn't get local name for node '" + baseNode .getTypeName () + "'.");
		},
		PushContainerField: function (field)
		{
			this .containerFields .push (field);
		},
		PopContainerField: function ()
		{
			this .containerFields .pop ();
		},
		ContainerField: function ()
		{
			if (this .containerFields .length)
				return this .containerFields [this .containerFields .length - 1];

			return null;
		},
		AccessType: function (accessType)
		{
			switch (accessType)
			{
				case X3DConstants .initializeOnly:
					return "initializeOnly";
				case X3DConstants .inputOnly:
					return "inputOnly";
				case X3DConstants .outputOnly:
					return "outputOnly";
				case X3DConstants .inputOutput:
					return "inputOutput";
			}
		},
		SetUnits: function (value)
		{
			this .units = value;
		},
		GetUnits: function ()
		{
			return this .units;
		},
		PushUnitCategory: function (category)
		{
			this .unitCategories .push (category);
		},
		PopUnitCategory: function ()
		{
			this .unitCategories .pop ();
		},
		Unit: function (category)
		{
			var length = this .unitCategories .length;

			if (length == 0)
				return category;

			return this .unitCategories [length - 1];
		},
		ToUnit: function (category, value)
		{
			if (this .units)
			{
				var executionContext = this .ExecutionContext ();

				if (executionContext)
					return executionContext .toUnit (category, value);
			}

			return value;
		},
		XMLEncode: function (string)
		{
			return string
				.replace (/&/g, "&amp;")
				.replace (/\\/g, "&#92;")
				.replace (/\t/g, "&#x9;")
				.replace (/\n/g, "&#xA;")
				.replace (/\r/g, "&#xD;")
				.replace (/</g, "&lt;")
				.replace (/>/g, "&gt;")
				.replace (/'/g, "&apos;")
				.replace (/"/g, "\\\"");
		},
		escapeCDATA: function (string)
		{
			return string .replace (/\]\]\>/g, "\\]\\]\\>");
		},
	};

	Generator .Get = function (stream)
	{
		if (! stream .generator)
			stream .generator = new Generator ();

		return stream .generator;
	};

	return Generator;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DObject',[
	"x_ite/InputOutput/Generator",
],
function (Generator)
{
"use strict";

	function X3DObject () { }

	X3DObject .prototype =
	{
		constructor: X3DObject,
		_id: 0,
		_name: "",
		_interests: new Map (),
		getId: (function ()
		{
			var id = 0;
			
			function getId () { return this ._id; }

			return function ()
			{
				this .getId = getId;
	
				return this ._id = ++ id;
			};
		})(),
		setName: function (value)
		{
			this ._name = value;
		},
		getName: function ()
		{
			return this ._name;
		},
		hasInterest: function (callbackName, object)
		{
			return this ._interests .has (object .getId () + callbackName);
		},
		addInterest: function (callbackName, object)
		{
			if (! this .hasOwnProperty ("_interests"))
				this ._interests = new Map ();

			var callback = object [callbackName];

			if (arguments .length > 2)
			{
				var args = Array .prototype .slice .call (arguments, 0);
	
				args [0] = object;
				args [1] = this;
	
				this ._interests .set (object .getId () + callbackName, Function .prototype .bind .apply (callback, args));
			}
			else
			{
				var self = this;

				this ._interests .set (object .getId () + callbackName, function () { callback .call (object, self); });
			}
		},
		removeInterest: function (callbackName, object)
		{
			this ._interests .delete (object .getId () + callbackName);
		},
		getInterests: function ()
		{
			return this ._interests;
		},
		processInterests: function ()
		{
			this ._interests .forEach (function (interest)
			{
				interest ();
			});
		},
		toString: function (scene)
		{
			var stream = { string: "" };

			if (scene)
				Generator .Get (stream) .PushExecutionContext (scene);

			this .toStream (stream);

			return stream .string;
		},
		toVRMLString: function ()
		{
			var stream = { string: "" };

			this .toVRMLStream (stream);

			return stream .string;
		},
		toXMLString: function ()
		{
			var stream = { string: "" };

			this .toXMLStream (stream);

			return stream .string;
		},
		dispose: function () { },
	};

	return X3DObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DChildObject',[
	"x_ite/Base/X3DObject",
],
function (X3DObject)
{
"use strict";

	function X3DChildObject ()
	{
		X3DObject .call (this);
	}

	X3DChildObject .prototype = Object .assign (Object .create (X3DObject .prototype),
	{
		constructor: X3DChildObject,
		_tainted: false,
		_parents: new Set (),
		setTainted: function (value)
		{
			this ._tainted = value;
		},
		getTainted: function ()
		{
			return this ._tainted;
		},
		addEvent: function ()
		{
			if (this ._tainted)
				return;

			this ._parents .forEach (function (parent)
			{
				parent .addEvent (this);
			},
			this);
		},
		addEventObject: function (field, event)
		{
			this ._parents .forEach (function (parent)
			{
				parent .addEventObject (this, event);
			},
			this);
		},
		addParent: function (parent)
		{
			if (! this .hasOwnProperty ("_parents"))
				this ._parents = new Set ();

			this ._parents .add (parent);
		},
		removeParent: function (parent)
		{
			this ._parents .delete (parent);
		},
		getParents: function ()
		{
			return this ._parents;
		},
		addCloneCount: Function .prototype,
		removeCloneCount: Function .prototype,
		dispose: function ()
		{
			this ._parents .clear ();

			X3DObject .prototype .dispose .call (this);
		},
	});

	return X3DChildObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/Events',[],function ()
{
"use strict";

	var Events =
	{
		stack: [ ],
		create: function (field)
		{
			if (this .stack .length)
			{
				var event = this .stack .pop ();

				event .field = field;
				event .clear ();

				return event;
			}
 
			var event = new Set ();

			event .field = field;

			return event;
		},
		copy: function (event)
	   {
			if (this .stack .length)
			{
				var copy = this .stack .pop ();

				copy .field = event .field;
				copy .clear ();

				event .forEach (function (source)
				{
					this .add (source);
				},
				copy);

				return copy;
	      }

			var copy = new Set (event);

			copy .field = event .field;

			return copy;
	   },
		push: function (event)
		{
		   this .stack .push (event);
		},
		clear: function ()
		{
			this .stack .length = 0;
		}
	};

	return Events;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Utility/MapUtilities',['require'],function ($)
{
"use strict";

   var MapUtilities = {
      assign: function (m1, m2)
      {
         m1 .clear ();

         m2 .forEach (function (value, key)
         {
            m1 .set (key, value);
         });

         return m1;
      },
   };

	return MapUtilities;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Basic/X3DField',[
	"jquery",
	"x_ite/Base/X3DChildObject",
	"x_ite/Bits/X3DConstants",
	"x_ite/Base/Events",
	"standard/Utility/MapUtilities",
],
function ($,
	       X3DChildObject,
	       X3DConstants,
			 Events,
			 MapUtilities)
{
"use strict";

	function X3DField (value)
	{
		X3DChildObject .call (this);

		this ._value = value;

		return this;
	}

	X3DField .prototype = Object .assign (Object .create (X3DChildObject .prototype),
	{
		constructor: X3DField,
		_value: null,
		_accessType: X3DConstants .initializeOnly,
		_unit: null,
		_set: false,
		_uniformLocation: null,
		_references: new Map (),
		_fieldInterests: new Map (),
		_fieldCallbacks: new Map (),
		_inputRoutes: new Map (),
		_outputRoutes: new Map (),
		_routeCallbacks: new Map (),
		clone: function ()
		{
			return this .copy ();
		},
		equals: function (value)
		{
			return this ._value === value .valueOf ();
		},
		assign: function (field)
		{
			// Assigns field to this field.
			this .set (field .getValue ());
			this .addEvent ();
		},
		set: function (value)
		{
			// Sets internal value without generating event.
			this ._value = value;
		},
		setValue: function (value)
		{
			// Sets internal value and generates event.
			this .set (value instanceof this .constructor ? value .getValue () : value);
			this .addEvent ();
		},
		getValue: function ()
		{
			return this ._value;
		},
		setAccessType: function (value)
		{
			this ._accessType = value;
		},
		getAccessType: function ()
		{
			return this ._accessType;
		},
		isInitializable: function ()
		{
			return this .getAccessType () & X3DConstants .initializeOnly;
		},
		isInput: function ()
		{
			return this .getAccessType () & X3DConstants .inputOnly;
		},
		isOutput: function ()
		{
			return this .getAccessType () & X3DConstants .outputOnly;
		},
		isReadable: function ()
		{
			return this .getAccessType () !== X3DConstants .inputOnly;
		},
		isWritable: function ()
		{
			return this .getAccessType () !== X3DConstants .initializeOnly;
		},
		setUnit: function (value)
		{
			return this ._unit = value;
		},
		getUnit: function ()
		{
			return this ._unit;
		},
		setSet: function (value)
		{
			// Boolean indication whether the value is set during parse, or undefined.
			return this ._set = value;
		},
		getSet: function ()
		{
			return this ._set;
		},
		hasReferences: function ()
		{
			if (this .hasOwnProperty ("_references"))
				return this ._references .size !== 0;

			return false;
		},
		isReference: function (accessType)
		{
			return accessType === this .getAccessType () || accessType === X3DConstants .inputOutput;
		},
		addReference: function (reference)
		{
			var references = this .getReferences ();

			if (references .has (reference .getId ()))
				return; // throw ???

			references .set (reference .getId (), reference);

			// Create IS relationship

			switch (this .getAccessType () & reference .getAccessType ())
			{
				case X3DConstants .initializeOnly:
					reference .addFieldInterest (this);
					this .set (reference .getValue (), reference .length);
					return;
				case X3DConstants .inputOnly:
					reference .addFieldInterest (this);
					return;
				case X3DConstants .outputOnly:
					this .addFieldInterest (reference);
					return;
				case X3DConstants .inputOutput:
					reference .addFieldInterest (this);
					this .addFieldInterest (reference);
					this .set (reference .getValue (), reference .length);
					return;
			}
		},
		getReferences: function ()
		{
			if (! this .hasOwnProperty ("_references"))
				this ._references = new Map ();

			return this ._references;
		},
		updateReferences: function ()
		{
			if (this .hasOwnProperty ("_references"))
			{
				this ._references .forEach (function (reference)
				{
					switch (this .getAccessType () & reference .getAccessType ())
					{
						case X3DConstants .inputOnly:
						case X3DConstants .outputOnly:
							break;
						case X3DConstants .initializeOnly:
						case X3DConstants .inputOutput:
							this .set (reference .getValue (), reference .length);
							break;
					}
				},
				this);
			}
		},
		addFieldInterest: function (field)
		{
			if (! this .hasOwnProperty ("_fieldInterests"))
				this ._fieldInterests = new Map ();

			this ._fieldInterests .set (field .getId (), field);
		},
		removeFieldInterest: function (field)
		{
			this ._fieldInterests .delete (field .getId ());
		},
		getFieldInterests: function ()
		{
			return this ._fieldInterests;
		},
		addFieldCallback: function (string, object)
		{
			if (! this .hasOwnProperty ("_fieldCallbacks"))
				this ._fieldCallbacks = new Map ();

			this ._fieldCallbacks .set (string, object);
		},
		removeFieldCallback: function (string)
		{
			this ._fieldCallbacks .delete (string);
		},
		getFieldCallbacks: function ()
		{
			return this ._fieldCallbacks;
		},
		addInputRoute: function (route)
		{
			if (! this .hasOwnProperty ("_inputRoutes"))
				this ._inputRoutes = new Map ();

			this ._inputRoutes .set (route .getId (), route);

			this .processRouteCallbacks ();
		},
		removeInputRoute: function (route)
		{
			this ._inputRoutes .delete (route .getId ());

			this .processRouteCallbacks ();
		},
		getInputRoutes: function ()
		{
			return this ._inputRoutes;
		},
		addOutputRoute: function (route)
		{
			if (! this .hasOwnProperty ("_outputRoutes"))
				this ._outputRoutes = new Map ();

			this ._outputRoutes .set (route .getId (), route);

			this .processRouteCallbacks ();
		},
		removeOutputRoute: function (route)
		{
			this ._outputRoutes .delete (route .getId ());

			this .processRouteCallbacks ();
		},
		getOutputRoutes: function ()
		{
			return this ._outputRoutes;
		},
		addRouteCallback: function (string, object)
		{
			if (! this .hasOwnProperty ("_routeCallbacks"))
				this ._routeCallbacks = new Map ();

			this ._routeCallbacks .set (string, object);
		},
		removeRouteCallback: function (string)
		{
			this ._routeCallbacks .delete (string);
		},
		getRouteCallbacks: function ()
		{
			return this ._routeCallbacks;
		},
		processRouteCallbacks: function ()
		{
			if (this ._routeCallbacks .size)
			{
				this ._routeCallbacks .forEach (function (routeCallback)
				{
					routeCallback ();
				});
			}
		},
		processEvent: (function ()
		{
			var fieldCallbacks = new Map ();

			return function (event)
			{
				if (event .has (this .getId ()))
					return;

				event .add (this .getId ());

				this .setTainted (false);

				var field = event .field;

				if (field !== this)
					this .set (field .getValue (), field .length);

				// Process interests

				this .processInterests ();

				// Process routes

				var first = true;

				this ._fieldInterests .forEach (function (fieldInterest)
				{
					if (first)
					{
						first = false;
						fieldInterest .addEventObject (this, event);
					}
					else
						fieldInterest .addEventObject (this, Events .copy (event));
				},
				this);

				if (first)
					Events .push (event);

				// Process field callbacks

				if (this ._fieldCallbacks .size)
				{
					MapUtilities .assign (fieldCallbacks, this ._fieldCallbacks) .forEach (function (fieldCallback)
					{
						fieldCallback (this .valueOf ());
					},
					this);
				}
			};
		})(),
		valueOf: function ()
		{
			return this;
		},
		fromString: function (string, scene)
		{
			var
				Parser = require ("x_ite/Parser/Parser"),
				parser = new Parser (scene);

			parser .setUnits (!! scene);
			parser .setInput (string);
			parser .fieldValue (this);
			this .addEvent ();
		},
	});

	return X3DField;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Basic/X3DArrayField',[
	"x_ite/Basic/X3DField",
],
function (X3DField)
{
"use strict";

	function X3DArrayField (value)
	{
		X3DField .call (this, value);
	}

	X3DArrayField .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: X3DArrayField,
	});

	return X3DArrayField;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFBool',[
	"x_ite/Basic/X3DField",
	"x_ite/Bits/X3DConstants",
],
function (X3DField,
          X3DConstants)
{
"use strict";

	function SFBool (value)
	{
		return X3DField .call (this, !! value);
	}

	SFBool .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFBool,
		copy: function ()
		{
			return new SFBool (this .getValue ());
		},
		isDefaultValue: function ()
		{
			return this .getValue () === false;
		},
		set: function (value)
		{
			X3DField .prototype .set .call (this, !! value);
		},
		getTypeName: function ()
		{
			return "SFBool";
		},
		getType: function ()
		{
			return X3DConstants .SFBool;
		},
		valueOf: function ()
		{
			return this .getValue ();
		},
		toStream: function (stream)
		{
			stream .string += this .getValue () ? "TRUE" : "FALSE";
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			stream .string += this .getValue () ? "true" : "false";
		},
	});

	return SFBool;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithm',[],function ()
{
"use strict";

	var Algorithm =
	{
		signum: function (value)
		{
			return (0 < value) - (value < 0);
		},
		radians: function (value)
		{
			return value * (Math .PI / 180);
		},
		degrees: function (value)
		{
			return value * (180 / Math .PI);
		},
		random: function (min, max)
		{
			return min + Math .random () * (max - min);
		},
		fract: function (value)
		{
			return value > 0 ? value - Math .floor (value) : value - Math .ceil (value);
		},
		clamp: function (value, min, max)
		{
			// http://jsperf.com/math-clamp
			// http://jsperf.com/clamping-methods/2
			return Math .min (Math .max (value, min), max);
		},
		interval: function (value, low, high)
		{
			if (value >= high)
				return ((value - low) % (high - low)) + low;

			if (value < low)
				return ((value - high) % (high - low)) + high;

			return value;
		},
		lerp: function (source, destination, t)
		{
			return source + t * (destination - source);
		},
		slerp: function (source, destination, t)
		{
			var cosom = source .dot (destination);

			if (cosom <= -1)
				throw new Error ("slerp is not possible: vectors are inverse collinear.");

			if (cosom >= 1) // both normal vectors are equal
				return source;

			if (cosom < 0)
			{
				// Reverse signs so we travel the short way round
				cosom = -cosom;
				destination .negate ();
			}

			var
				omega = Math .acos (cosom),
				sinom = Math .sin  (omega),

				scale0 = Math .sin ((1 - t) * omega) / sinom,
				scale1 = Math .sin (t * omega) / sinom;

			source .x = source .x * scale0 + destination .x * scale1;
			source .y = source .y * scale0 + destination .y * scale1;
			source .z = source .z * scale0 + destination .z * scale1;
			source .w = source .w * scale0 + destination .w * scale1;

			return source;
		},
		simpleSlerp: function (source, destination, t)
		{
			var cosom = source .dot (destination);

			if (cosom <= -1)
				throw new Error ("slerp is not possible: vectors are inverse collinear.");

			if (cosom >= 1) // both normal vectors are equal
				return source;

			var
				omega = Math .acos (cosom),
				sinom = Math .sin  (omega),

				scale0 = Math .sin ((1 - t) * omega) / sinom,
				scale1 = Math .sin (t * omega) / sinom;

			source .x = source .x * scale0 + destination .x * scale1;
			source .y = source .y * scale0 + destination .y * scale1;
			source .z = source .z * scale0 + destination .z * scale1;
			source .w = source .w * scale0 + destination .w * scale1;

			return source;
		},
		isPowerOfTwo: function (n)
		{
			return ((n - 1) & n) === 0;
		},
		nextPowerOfTwo: function (n)
		{
			///  Returns the next power of two of @a n. If n is a power of two, n is returned.

			-- n;

			for (var k = 1; ! (k & (1 << (4 + 1))); k <<= 1)
				n |= n >> k;

			return ++ n;
		},
		/*
		isInt: function(n)
		{
			return typeof n === 'number' &&
			       parseFloat (n) == parseInt (n, 10) && ! isNaN (n);
		},
		decimalPlaces: function (n)
		{
			var
				a = Math.abs(n),
				c = a, count = 1;

			while(! Algorithm .isInt (c) && isFinite (c))
				c = a * Math .pow (10, count ++);

			return count-1;
		},
		*/
		cmp: function (lhs, rhs)
		{
			return lhs > rhs ? 1 : lhs < rhs ? -1 : 0;
		},
		less: function (lhs, rhs)
		{
			return lhs < rhs;
		},
		greater: function (lhs, rhs)
		{
			return lhs > rhs;
		},
		lowerBound: function (array, first, last, value, comp)
		{
		   // http://en.cppreference.com/w/cpp/algorithm/lower_bound

			var
				index = 0,
				step  = 0,
				count = last - first;

			while (count > 0)
			{
				step  = count >>> 1;
				index = first + step;

				if (comp (array [index], value))
				{
					first  = ++ index;
					count -= step + 1;
				}
				else
					count = step;
			}

			return first;
		},
		upperBound: function (array, first, last, value, comp)
		{
		   // http://en.cppreference.com/w/cpp/algorithm/upper_bound

			var
				index = 0,
				step  = 0,
				count = last - first;

			while (count > 0)
			{
				step  = count >>> 1;
				index = first + step;

				if (comp (value, array [index]))
					count = step;

				else
				{
					first  = ++ index;
					count -= step + 1;
				}
			}

			return first;
		},
		set_difference: function (lhs, rhs, result)
		{
			for (var key in lhs)
			{
				if (key in rhs)
					continue;

				result [key] = lhs [key];
			}

			return result;
		},
	};

	Object .preventExtensions (Algorithm);
	Object .freeze (Algorithm);
	Object .seal (Algorithm);

	return Algorithm;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Color3',[
	"standard/Math/Algorithm",
],
function (Algorithm)
{
"use strict";

	var clamp = Algorithm .clamp;

	function Color3 (r, g, b)
	{
		if (arguments .length)
		{
			this .r_ = clamp (r, 0, 1);
			this .g_ = clamp (g, 0, 1);
			this .b_ = clamp (b, 0, 1);
		}
		else
		{
			this .r_ = 0;
			this .g_ = 0;
			this .b_ = 0;
		}
	}

	Color3 .prototype =
	{
		constructor: Color3,
		length: 3,
		copy: function ()
		{
			var copy = Object .create (Color3 .prototype);
			copy .r_ = this .r_;
			copy .g_ = this .g_;
			copy .b_ = this .b_;
			return copy;
		},
		assign: function (color)
		{
			this .r_ = color .r_;
			this .g_ = color .g_;
			this .b_ = color .b_;
		},
		set: function (r, g, b)
		{
			this .r_ = clamp (r, 0, 1);
			this .g_ = clamp (g, 0, 1);
			this .b_ = clamp (b, 0, 1);
		},
		equals: function (color)
		{
			return this .r_ === color .r_ &&
			       this .g_ === color .g_ &&
			       this .b_ === color .b_;
		},
		getHSV: function (result)
		{
			var h, s, v;

			var min = Math .min (this .r_, this .g_, this .b_);
			var max = Math .max (this .r_, this .g_, this .b_);
			v = max; // value

			var delta = max - min;

			if (max !== 0 && delta !== 0)
			{
				s = delta / max; // s

				if (this .r_ === max)
					h =     (this .g_ - this .b_) / delta;  // between yellow & magenta
				else if (this .g_ === max)
					h = 2 + (this .b_ - this .r_) / delta;  // between cyan & yellow
				else
					h = 4 + (this .r_ - this .g_) / delta;  // between magenta & cyan

				h *= Math .PI / 3;  // radiants
				if (h < 0)
					h += Math .PI * 2;
			}
			else
				s = h = 0;         // s = 0, h is undefined

			result [0] = h;
			result [1] = s;
			result [2] = v;

			return result;
		},
		setHSV: function (h, s, v)
		{
			s = clamp (s, 0, 1),
			v = clamp (v, 0, 1);

			// H is given on [0, 2 * Pi]. S and V are given on [0, 1].
			// RGB are each returned on [0, 1].

			if (s === 0)
			{
				// achromatic (grey)
				this .r_ = this .g_ = this .b_ = v;
			}
			else
			{
				var w = Algorithm .degrees (Algorithm .interval (h, 0, Math .PI * 2)) / 60;     // sector 0 to 5

				var i = Math .floor (w);
				var f = w - i;                      // factorial part of h
				var p = v * ( 1 - s );
				var q = v * ( 1 - s * f );
				var t = v * ( 1 - s * ( 1 - f ) );

				switch (i % 6)
				{
					case 0:  this .r_ = v; this .g_ = t; this .b_ = p; break;
					case 1:  this .r_ = q; this .g_ = v; this .b_ = p; break;
					case 2:  this .r_ = p; this .g_ = v; this .b_ = t; break;
					case 3:  this .r_ = p; this .g_ = q; this .b_ = v; break;
					case 4:  this .r_ = t; this .g_ = p; this .b_ = v; break;
					default: this .r_ = v; this .g_ = p; this .b_ = q; break;
				}
			}
		},
		toString: function ()
		{
			return this .r_ + " " +
			       this .g_ + " " +
			       this .b_;
		},
	};

	var r = {
		get: function () { return this .r_; },
		set: function (value) { this .r_ = clamp (value, 0, 1); },
		enumerable: true,
		configurable: false
	};
	
	var g = {
		get: function () { return this .g_; },
		set: function (value) { this .g_ = clamp (value, 0, 1); },
		enumerable: true,
		configurable: false
	};

	var b = {
		get: function () { return this .b_; },
		set: function (value) { this .b_ = clamp (value, 0, 1); },
		enumerable: true,
		configurable: false
	};

	Object .defineProperty (Color3 .prototype, "r", r);
	Object .defineProperty (Color3 .prototype, "g", g);
	Object .defineProperty (Color3 .prototype, "b", b);

	r .enumerable = false;
	g .enumerable = false;
	b .enumerable = false;

	Object .defineProperty (Color3 .prototype, "0", r);
	Object .defineProperty (Color3 .prototype, "1", g);
	Object .defineProperty (Color3 .prototype, "2", b);

	Object .assign (Color3,
	{
		HSV: function (h, s, v)
		{
			var color = Object .create (this .prototype);
			color .setHSV (h, s, v);
			return color;
		},
		lerp: function (a, b, t, r)
		{
			// Linearely interpolate in HSV space between source color @a a and destination color @a b by an amount of @a t.
			// Source and destination color must be in HSV space. The resulting HSV color is stored in @a r.

			var
				ha = a [0], hb = b [0],
				sa = a [1], sb = b [1],
				va = a [2], vb = b [2];

			if (sa === 0)
				ha = hb;

			if (sb === 0)
				hb = ha;

			var range = Math .abs (hb - ha);

			if (range <= Math .PI)
			{
				r [0] = ha + t * (hb - ha);
				r [1] = sa + t * (sb - sa);
				r [2] = va + t * (vb - va);
				return r;
			}

			var
				PI2  = Math .PI * 2,
				step = (PI2 - range) * t,
				h    = ha < hb ? ha - step : ha + step;

			if (h < 0)
				h += PI2;

			else if (h > PI2)
				h -= PI2;

			r [0] = h;
			r [1] = sa + t * (sb - sa);
			r [2] = va + t * (vb - va);
			return r;
		},
	});

	return Color3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFColor',[
	"standard/Math/Numbers/Color3",
	"x_ite/Basic/X3DField",
	"x_ite/Bits/X3DConstants",
],
function (Color3,
          X3DField,
          X3DConstants)
{
"use strict";

	function SFColor (r, g, b)
	{
		switch (arguments .length)
		{
			case 0:
				return X3DField .call (this, new Color3 ());

			case 1:
				return X3DField .call (this, arguments [0]);

			case 3:
				return X3DField .call (this, new Color3 (r * 1, g * 1, b * 1));
		}

		throw new Error ("Invalid arguments.");
	}

	SFColor .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFColor,
		copy: function ()
		{
			return new SFColor (this .getValue () .copy ());
		},
		getTypeName: function ()
		{
			return "SFColor";
		},
		getType: function ()
		{
			return X3DConstants .SFColor;
		},
		equals: function (color)
		{
			return this .getValue () .equals (color .getValue ());
		},
		isDefaultValue: function ()
		{
			return (
				this .getValue () .r === 0 &&
				this .getValue () .g === 0 &&
				this .getValue () .b === 0);
		},
		set: function (value)
		{
			this .getValue () .assign (value);
		},
		getHSV: function ()
		{
			return this .getValue () .getHSV ([ ]);
		},
		setHSV: function (h, s, v)
		{
			this .getValue () .setHSV (h, s, v);
			this .addEvent ();
		},
		lerp: (function ()
		{
			var
				s = [ ],
				d = [ ],
				r = [ ];

			return function (destination, t)
			{
				var result = new SFColor ();

				this .getValue () .getHSV (s),
				destination .getValue () .getHSV (d),
				Color3 .lerp (s, d, t, r),

				result .setHSV (r [0], r [1], r [2], r [3]);

				return result;
			};
		})(),
		toStream: function (stream)
		{
			stream .string += this .getValue () .toString ();
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			this .toStream (stream);
		},
	});

	var r = {
		get: function ()
		{
			return this .getValue () .r;
		},
		set: function (value)
		{
			this .getValue () .r = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var g = {
		get: function ()
		{
			return this .getValue () .g;
		},
		set: function (value)
		{
			this .getValue () .g = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var b = {
		get: function ()
		{
			return this .getValue () .b;
		},
		set: function (value)
		{
			this .getValue () .b = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	Object .defineProperty (SFColor .prototype, "r", r);
	Object .defineProperty (SFColor .prototype, "g", g);
	Object .defineProperty (SFColor .prototype, "b", b);

	r .enumerable = false;
	g .enumerable = false;
	b .enumerable = false;

	Object .defineProperty (SFColor .prototype, "0", r);
	Object .defineProperty (SFColor .prototype, "1", g);
	Object .defineProperty (SFColor .prototype, "2", b);

	return SFColor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Color4',[
	"standard/Math/Numbers/Color3",
	"standard/Math/Algorithm",
],
function (Color3, Algorithm)
{
"use strict";

	var clamp = Algorithm .clamp;

	function Color4 (r, g, b, a)
	{
		if (arguments .length)
		{
			this .r_ = clamp (r, 0, 1);
			this .g_ = clamp (g, 0, 1);
			this .b_ = clamp (b, 0, 1);
			this .a_ = clamp (a, 0, 1);
		}
		else
		{
			this .r_ = 0;
			this .g_ = 0;
			this .b_ = 0;
			this .a_ = 0;
		}
	}

	Color4 .prototype =
	{
		constructor: Color4,
		length: 4,
		copy: function ()
		{
			var copy = Object .create (Color4 .prototype);
			copy .r_ = this .r_;
			copy .g_ = this .g_;
			copy .b_ = this .b_;
			copy .a_ = this .a_;
			return copy;
		},
		assign: function (color)
		{
			this .r_ = color .r_;
			this .g_ = color .g_;
			this .b_ = color .b_;
			this .a_ = color .a_;
		},
		set: function (r, g, b, a)
		{
			this .r_ = clamp (r, 0, 1);
			this .g_ = clamp (g, 0, 1);
			this .b_ = clamp (b, 0, 1);
			this .a_ = clamp (a, 0, 1);
		},
		equals: function (color)
		{
			return this .r_ === color .r_ &&
			       this .g_ === color .g_ &&
			       this .b_ === color .b_ &&
			       this .a_ === color .a_;
		},
		getHSVA: function (result)
		{
			Color3 .prototype .getHSV .call (this, result);

			result [3] = this .a_;

			return result;
		},
		setHSVA: function (h, s, v, a)
		{
			Color3 .prototype .setHSV .call (this, h, s, v);

			this .a_ = clamp (a, 0, 1);
		},
		toString: function ()
		{
			return this .r_ + " " +
			       this .g_ + " " +
			       this .b_ + " " +
			       this .a_;
		},
	};

	var r = {
		get: function () { return this .r_; },
		set: function (value) { this .r_ = clamp (value, 0, 1); },
		enumerable: true,
		configurable: false
	};
	
	var g = {
		get: function () { return this .g_; },
		set: function (value) { this .g_ = clamp (value, 0, 1); },
		enumerable: true,
		configurable: false
	};

	var b = {
		get: function () { return this .b_; },
		set: function (value) { this .b_ = clamp (value, 0, 1); },
		enumerable: true,
		configurable: false
	};

	var a = {
		get: function () { return this .a_; },
		set: function (value) { this .a_ = clamp (value, 0, 1); },
		enumerable: true,
		configurable: false
	};

	Object .defineProperty (Color4 .prototype, "r", r);
	Object .defineProperty (Color4 .prototype, "g", g);
	Object .defineProperty (Color4 .prototype, "b", b);
	Object .defineProperty (Color4 .prototype, "a", a);

	r .enumerable = false;
	g .enumerable = false;
	b .enumerable = false;
	a .enumerable = false;

	Object .defineProperty (Color4 .prototype, "0", r);
	Object .defineProperty (Color4 .prototype, "1", g);
	Object .defineProperty (Color4 .prototype, "2", b);
	Object .defineProperty (Color4 .prototype, "3", a);

	Object .assign (Color4,
	{
		HSVA: function (h, s, v, a)
		{
			var color = Object .create (this .prototype);
			color .setHSVA (h, s, v, a);
			return color;
		},
		lerp: function (a, b, t, r)
		{
			// Linearely interpolate in HSVA space between source color @a a and destination color @a b by an amount of @a t.
			// Source and destination color must be in HSVA space. The resulting HSVA color is stored in @a r.
			var aa = a [3];
			Color3 .lerp (a, b, t, r);
			r [3] = aa + t * (b [3] - aa);
			return r;
		},
	});

	return Color4;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFColorRGBA',[
	"x_ite/Basic/X3DField",
	"x_ite/Fields/SFColor",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Color4",
],
function (X3DField,
          SFColor,
          X3DConstants,
          Color4)
{
"use strict";

	function SFColorRGBA (r, g, b, a)
	{
		switch (arguments .length)
		{
			case 0:
				return X3DField .call (this, new Color4 ());

			case 1:
				return X3DField .call (this, arguments [0]);

			case 4:
				return X3DField .call (this, new Color4 (r * 1, g * 1, b * 1, a * 1));
		}

		throw new Error ("Invalid arguments.");
	}

	SFColorRGBA .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFColorRGBA,
		copy: function ()
		{
			return new SFColorRGBA (this .getValue () .copy ());
		},
		getTypeName: function ()
		{
			return "SFColorRGBA";
		},
		getType: function ()
		{
			return X3DConstants .SFColorRGBA;
		},
		equals: SFColor .prototype .equals,
		isDefaultValue: function ()
		{
			return (
				this .getValue () .r === 0 &&
				this .getValue () .g === 0 &&
				this .getValue () .b === 0 &&
				this .getValue () .a === 0);
		},
		set: SFColor .prototype .set,
		getHSVA: function ()
		{
			return this .getValue () .getHSVA ([ ]);
		},
		setHSVA: function (h, s, v, a)
		{
			this .getValue () .setHSVA (h, s, v, a);
			this .addEvent ();
		},
		lerp: (function ()
		{
			var
				s = [ ],
				d = [ ],
				r = [ ];

			return function (destination, t)
			{
				var result = new SFColorRGBA ();

				this .getValue () .getHSVA (s),
				destination .getValue () .getHSVA (d),
				Color4 .lerp (s, d, t, r),

				result .setHSVA (r [0], r [1], r [2], r [3]);

				return result;
			};
		})(),
		toStream: SFColor .prototype .toStream,
		toVRMLStream: SFColor .prototype .toVRMLStream,
		toXMLStream: SFColor .prototype .toXMLStream,
	});

	var r = {
		get: function ()
		{
			return this .getValue () .r;
		},
		set: function (value)
		{
			this .getValue () .r = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var g = {
		get: function ()
		{
			return this .getValue () .g;
		},
		set: function (value)
		{
			this .getValue () .g = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var b = {
		get: function ()
		{
			return this .getValue () .b;
		},
		set: function (value)
		{
			this .getValue () .b = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var a = {
		get: function ()
		{
			return this .getValue () .a;
		},
		set: function (value)
		{
			this .getValue () .a = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	Object .defineProperty (SFColorRGBA .prototype, "r", r);
	Object .defineProperty (SFColorRGBA .prototype, "g", g);
	Object .defineProperty (SFColorRGBA .prototype, "b", b);
	Object .defineProperty (SFColorRGBA .prototype, "a", a);

	r .enumerable = false;
	g .enumerable = false;
	b .enumerable = false;
	a .enumerable = false;

	Object .defineProperty (SFColorRGBA .prototype, "0", r);
	Object .defineProperty (SFColorRGBA .prototype, "1", g);
	Object .defineProperty (SFColorRGBA .prototype, "2", b);
	Object .defineProperty (SFColorRGBA .prototype, "3", a);

	return SFColorRGBA;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFDouble',[
	"x_ite/Basic/X3DField",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function (X3DField,
          X3DConstants,
          Generator)
{
"use strict";

	function SFDouble (value)
	{
		return X3DField .call (this, arguments .length ? value * 1 : 0);
	}

	SFDouble .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFDouble,
		copy: function ()
		{
			return new SFDouble (this .getValue ());
		},
		getTypeName: function ()
		{
			return "SFDouble";
		},
		getType: function ()
		{
			return X3DConstants .SFDouble;
		},
		isDefaultValue: function ()
		{
			return this .getValue () === 0;
		},
		set: function (value)
		{
			X3DField .prototype .set .call (this, +value);
		},
		valueOf: X3DField .prototype .getValue,
		toStream: function (stream)
		{
			var
				generator = Generator .Get (stream),
				category  = generator .Unit (this .getUnit ());

			stream .string += String (generator .ToUnit (category, this .getValue ()));
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			this .toStream (stream);
		},
	});

	return SFDouble;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFFloat',[
	"x_ite/Basic/X3DField",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function (X3DField,
          X3DConstants,
          Generator)
{
"use strict";

	function SFFloat (value)
	{
		return X3DField .call (this, arguments .length ? value * 1 : 0);
	}

	SFFloat .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFFloat,
		copy: function ()
		{
			return new SFFloat (this .getValue ());
		},
		getTypeName: function ()
		{
			return "SFFloat";
		},
		getType: function ()
		{
			return X3DConstants .SFFloat;
		},
		isDefaultValue: function ()
		{
			return this .getValue () === 0;
		},
		set: function (value)
		{
			X3DField .prototype .set .call (this, value * 1);
		},
		valueOf: X3DField .prototype .getValue,
		toStream: function (stream)
		{
			var
				generator = Generator .Get (stream),
				category  = generator .Unit (this .getUnit ());

			stream .string += String (generator .ToUnit (category, this .getValue ()));
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			this .toStream (stream);
		},
	});

	return SFFloat;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFInt32',[
	"x_ite/Basic/X3DField",
	"x_ite/Bits/X3DConstants",
],
function (X3DField,
          X3DConstants)
{
"use strict";

	function SFInt32 (value)
	{
		return X3DField .call (this, ~~value);
	}

	SFInt32 .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFInt32,
		copy: function ()
		{
			return new SFInt32 (this .getValue ());
		},
		getTypeName: function ()
		{
			return "SFInt32";
		},
		getType: function ()
		{
			return X3DConstants .SFInt32;
		},
		isDefaultValue: function ()
		{
			return this .getValue () === 0;
		},
		set: function (value)
		{
			X3DField .prototype .set .call (this, ~~value);
		},
		valueOf: X3DField .prototype .getValue,
		toStream: function (stream, base)
		{
			stream .string += this .getValue () .toString (base);
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			stream .string += this .getValue () .toString ();
		},
	});

	return SFInt32;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFImage',[
	"x_ite/Basic/X3DField",
	"x_ite/Fields/SFInt32",
	"x_ite/Bits/X3DConstants",
],
function (X3DField,
          SFInt32,
          X3DConstants)
{
"use strict";

	/*
	 *  Image
	 */

	function Image (width, height, comp, array)
	{
	   var MFInt32 = require ("x_ite/Fields/ArrayFields") .MFInt32;

		this .width  = ~~width;
		this .height = ~~height;
		this .comp   = ~~comp;
		this .array  = new MFInt32 ();
		this .array .setValue (array);
		this .array .length = this .width * this .height;
	}
	
	Image .prototype =
	{
		constructor: Image,
		copy: function ()
		{
			return new Image (this .width, this .height, this .comp, this .array);
		},
		equals: function (image)
		{
			return this .width  === image .width &&
			       this .height === image .height &&
			       this .comp   === image .comp &&
			       this .array .equals (image .array);
		},
		assign: function (image)
		{
			this .width  = image .width;
			this .height = image .height;
			this .comp   = image .comp;
			this .array .assign (image .array);
		},
		set: function (width, height, comp, array)
		{
			this .width  = ~~width;
			this .height = ~~height;
			this .comp   = ~~comp;
			this .array .assign (array);
		},
		setWidth: function (value)
		{
			this .width = ~~value;
			this .array .length = this .width  * this .height;	
		},
		getWidth: function ()
		{
			return this .width;
		},
		setHeight: function (value)
		{
			this .height = ~~value;
			this .array .length = this .width  * this .height;	
		},
		getHeight: function ()
		{
			return this .height;
		},
		setComp: function (value)
		{
			this .comp = ~~value;
		},
		getComp: function ()
		{
			return this .comp;
		},
		setArray: function (value)
		{
			this .array .assign (value);
			this .array .length = this .width  * this .height;	
		},
		getArray: function ()
		{
			return this .array;
		},
	};

	/*
	 *  SFImage
	 */

	function SFImage (width, height, comp, array)
	{
		var MFInt32 = require ("x_ite/Fields/ArrayFields") .MFInt32;
   
		if (arguments [0] instanceof Image)
			X3DField .call (this, arguments [0]);
		else if (arguments .length === 4)
			X3DField .call (this, new Image (width, height, comp, array));
		else
			X3DField .call (this, new Image (0, 0, 0, new MFInt32 ()));

		this .getValue () .getArray () .addParent (this);
		this .addInterest ("set_size__", this);
		return this;
	}

	SFImage .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFImage,
		set_size__: function ()
		{
			this .getValue () .getArray () .length = this .width * this .height;
		},
		copy: function ()
		{
			return new SFImage (this .getValue () .copy ());
		},
		equals: function (image)
		{
			return this .getValue () .equals (image .getValue ());
		},
		isDefaultValue: function ()
		{
			return (
				this .width  === 0 &&
				this .height === 0 &&
				this .comp   === 0);
		},
		set: function (image)
		{
			this .getValue () .assign (image);
		},
		getTypeName: function ()
		{
			return "SFImage";
		},
		getType: function ()
		{
			return X3DConstants .SFImage;
		},
		toStream: function (stream)
		{
		   var
				array = this .array,
				int   = new SFInt32 ();

			stream .string += this .width + " " + this .height + " " + this .comp;

			for (var i = 0, length = this .width * this .height; i < length; ++ i)
			{
				stream .string += " 0x";

				int .set (array [i]);
				int .toXMLStream (stream);
			}
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			this .toStream (stream);
		},
	});

	var width = {
		get: function ()
		{
			return this .getValue () .getWidth ();
		},
		set: function (value)
		{
			this .getValue () .setWidth (value);
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var height = {
		get: function ()
		{
			return this .getValue () .getHeight ();
		},
		set: function (value)
		{
			this .getValue () .setHeight (value);
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var comp = {
		get: function ()
		{
			return this .getValue () .getComp ();
		},
		set: function (value)
		{
			this .getValue () .setComp (value);
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var array = {
		get: function ()
		{
			return this .getValue () .getArray ();
		},
		set: function (value)
		{
			this .getValue () .setArray (value);
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	Object .defineProperty (SFImage .prototype, "width",  width);
	Object .defineProperty (SFImage .prototype, "height", height);
	Object .defineProperty (SFImage .prototype, "comp",   comp);
	Object .defineProperty (SFImage .prototype, "array",  array);

	width  .enumerable = false;
	height .enumerable = false;

	Object .defineProperty (SFImage .prototype, "x", width);
	Object .defineProperty (SFImage .prototype, "y", height);

	return SFImage;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFMatrixPrototypeTemplate',[
	"x_ite/Basic/X3DField",
],
function (X3DField)
{
"use strict";

	return function (Matrix, SFVec)
	{
		return Object .assign (Object .create (X3DField .prototype),
		{
			copy: function ()
			{
				return new (this .constructor) (this .getValue () .copy ());
			},
			equals: function (matrix)
			{
				return this .getValue () .equals (matrix .getValue ());
			},
			isDefaultValue: function ()
			{
				return this .getValue () .equals (Matrix .Identity);
			},
			set: function (value)
			{
				this .getValue () .assign (value);
			},
			setTransform: function (translation, rotation, scale, scaleOrientation, center)
			{
				translation      = translation      ? translation      .getValue () : null;
				rotation         = rotation         ? rotation         .getValue () : null;
				scale            = scale            ? scale            .getValue () : null;
				scaleOrientation = scaleOrientation ? scaleOrientation .getValue () : null;
				center           = center           ? center           .getValue () : null;
	
				this .getValue () .set (translation, rotation, scale, scaleOrientation, center);
			},
			getTransform: function (translation, rotation, scale, scaleOrientation, center)
			{
				translation      = translation      ? translation      .getValue () : null;
				rotation         = rotation         ? rotation         .getValue () : null;
				scale            = scale            ? scale            .getValue () : null;
				scaleOrientation = scaleOrientation ? scaleOrientation .getValue () : null;
				center           = center           ? center           .getValue () : null;
	
				this .getValue () .get (translation, rotation, scale, scaleOrientation, center);
			},
			transpose: function ()
			{
				return new (this .constructor) (Matrix .transpose (this .getValue ()));
			},
			inverse: function ()
			{
				return new (this .constructor) (Matrix .inverse (this .getValue ()));
			},
			multLeft: function (matrix)
			{
				return new (this .constructor) (Matrix .multLeft (this .getValue (), matrix .getValue ()));
			},
			multRight: function (matrix)
			{
				return new (this .constructor) (Matrix .multRight (this .getValue (), matrix .getValue ()));
			},
			multVecMatrix: function (vector)
			{
				return new SFVec (this .getValue () .multVecMatrix (vector .getValue () .copy ()));
			},
			multMatrixVec: function (vector)
			{
				return new SFVec (this .getValue () .multMatrixVec (vector .getValue () .copy ()));
			},
			multDirMatrix: function (vector)
			{
				return new SFVec (this .getValue () .multDirMatrix (vector .getValue () .copy ()));
			},
			multMatrixDir: function (vector)
			{
				return new SFVec (this .getValue () .multMatrixDir (vector .getValue () .copy ()));
			},
			toStream: function (stream)
			{
				stream .string += this .getValue () .toString ();
			},
			toVRMLStream: function (stream)
			{
				this .toStream (stream);
			},
			toXMLStream: function (stream)
			{
				this .toStream (stream);
			},
		});
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFVecPrototypeTemplate',[
	"x_ite/Basic/X3DField",
	"x_ite/InputOutput/Generator",
],
function (X3DField,
          Generator)
{
"use strict";

	return function (Type)
	{
		return Object .assign (Object .create (X3DField .prototype),
		{
			copy: function ()
			{
				return new (this .constructor) (this .getValue () .copy ());
			},
			equals: function (vector)
			{
				return this .getValue () .equals (vector .getValue ());
			},
			isDefaultValue: function ()
			{
				return this .getValue () .equals (Type .Zero);
			},
			set: function (value)
			{
				this .getValue () .assign (value);
			},
			add: function (vector)
			{
				return new (this .constructor) (Type .add (this .getValue (), vector .getValue ()));
			},
			distance: function (vector)
			{
				return this .getValue () .distance (vector .getValue ());
			},
			divide: function (value)
			{
				return new (this .constructor) (Type .divide (this .getValue (), value));
			},
			divVec: function (vector)
			{
				return new (this .constructor) (Type .divVec (this .getValue (), vector .getValue ()));
			},
			dot: function (vector)
			{
				return this .getValue () .dot (vector .getValue ());
			},
			length: function ()
			{
				return this .getValue () .abs ();
			},
			lerp: function (destination, t)
			{
				return new (this .constructor) (Type .lerp (this .getValue (), destination, t));
			},
			multiply: function (value)
			{
				return new (this .constructor) (Type .multiply (this .getValue (), value));
			},
			multVec: function (vector)
			{
				return new (this .constructor) (Type .multVec (this .getValue (), vector .getValue ()));
			},
			negate: function ()
			{
				return new (this .constructor) (Type .negate (this .getValue () .copy ()));
			},
			normalize: function (vector)
			{
				return new (this .constructor) (Type .normalize (this .getValue ()));
			},
			subtract: function (vector)
			{
				return new (this .constructor) (Type .subtract (this .getValue (), vector .getValue ()));
			},
			toStream: function (stream)
			{
				var
					generator = Generator .Get (stream),
					value     = this .getValue (),
					category  = generator .Unit (this .getUnit ());

				for (var i = 0, l = value .length - 1; i < l; ++ i)
				{
					stream .string += String (generator .ToUnit (category, value [i]));
					stream .string += " ";
				}

				stream .string += String (generator .ToUnit (category, value [i]));
			},
			toVRMLStream: function (stream)
			{
				this .toStream (stream);
			},
			toXMLStream: function (stream)
			{
				this .toStream (stream);
			},
		});
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Vector2',[
	"standard/Math/Algorithm",
],
function (Algorithm)
{
"use strict";

	function Vector2 (x, y)
	{		
		this .x = x;
		this .y = y;
	}

	Vector2 .prototype =
	{
		constructor: Vector2,
		length: 2,
		copy: function ()
		{
			var copy = Object .create (Vector2 .prototype);
			copy .x = this .x;
			copy .y = this .y;
			return copy;
		},
		assign: function (vector)
		{
			this .x = vector .x;
			this .y = vector .y;
			return this;
		},
		set: function (x, y)
		{
			this .x = x;
			this .y = y;
			return this;
		},
		equals: function (vector)
		{
			return this .x === vector .x &&
			       this .y === vector .y;
		},
		negate: function ()
		{
			this .x = -this .x;
			this .y = -this .y;
			return this;
		},
		add: function (vector)
		{
			this .x += vector .x;
			this .y += vector .y;
			return this;
		},
		subtract: function (vector)
		{
			this .x -= vector .x;
			this .y -= vector .y;
			return this;
		},
		multiply: function (value)
		{
			this .x *= value;
			this .y *= value;
			return this;
		},
		multVec: function (vector)
		{
			this .x *= vector .x;
			this .y *= vector .y;
			return this;
		},
		divide: function (value)
		{
			this .x /= value;
			this .y /= value;
			return this;
		},
		divVec: function (vector)
		{
			this .x /= vector .x;
			this .y /= vector .y;
			return this;
		},
		normalize: function ()
		{
			var
				x = this .x,
				y = this .y;

			var length = Math .sqrt (x * x +
			                         y * y);

			if (length)
			{
				this .x = x / length;
				this .y = y / length;
			}

			return this;
		},
		dot: function (vector)
		{
			return this .x * vector .x +
			       this .y * vector .y;
		},
		norm: function ()
		{
			var
				x = this .x,
				y = this .y;

			return x * x +
			       y * y;
		},
		abs: function ()
		{
			var
				x = this .x,
				y = this .y;

			return Math .sqrt (x * x +
			                   y * y);
		},
		distance: function (vector)
		{
			var
				x = this .x - vector .x,
				y = this .y - vector .y;

			return Math .sqrt (x * x +
			                   y * y);
		},
		lerp: function (dest, t)
		{
			var
				x = this .x,
				y = this .y;

			this .x = x + t * (dest .x - x);
			this .y = y + t * (dest .y - y);
			return this;
		},
		min: function (vector)
		{
			var
				x = this .x,
				y = this .y;

			for (var i = 0, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .min (x, vector .x);
				y = Math .min (y, vector .y);
			}

			this .x = x;
			this .y = y;
			return this;
		},
		max: function (vector)
		{
			var
				x = this .x,
				y = this .y;

			for (var i = 0, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .max (x, vector .x);
				y = Math .max (y, vector .y);
			}

			this .x = x;
			this .y = y;
			return this;
		},
		toString: function ()
		{
			return this .x + " " +
			       this .y;
		}
	};

	Object .defineProperty (Vector2 .prototype, "0",
	{
		get: function () { return this .x; },
		set: function (value) { this .x = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Vector2 .prototype, "1",
	{
		get: function () { return this .y; },
		set: function (value) { this .y = value; },
		enumerable: false,
		configurable: false
	});

	Object .assign (Vector2,
	{
		Zero: new Vector2 (0, 0),
		One: new Vector2 (1, 1),
		negate: function (vector)
		{
			var copy = Object .create (this .prototype);
			copy .x = -vector .x;
			copy .y = -vector .y;
			return copy;
		},
		add: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x + rhs .x;
			copy .y = lhs .y + rhs .y;
			return copy;
		},
		subtract: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x - rhs .x;
			copy .y = lhs .y - rhs .y;
			return copy;
		},
		multiply: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x * rhs;
			copy .y = lhs .y * rhs;
			return copy;
		},
		multVec: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x * rhs .x;
			copy .y = lhs .y * rhs .y;
			return copy;
		},
		divide: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x / rhs;
			copy .y = lhs .y / rhs;
			return copy;
		},
		divVec: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x / rhs .x;
			copy .y = lhs .y / rhs .y;
			return copy;
		},
		normalize: function (vector)
		{
			var
				copy   = Object .create (this .prototype),
				x      = vector .x,
				y      = vector .y,
				length = Math .sqrt (x * x + y * y);

			if (length)
			{
				copy .x = x / length;
				copy .y = y / length;
			}
			else
			{
				copy .x = 0;
				copy .y = 0;
			}

			return copy;
		},
		dot: function (lhs, rhs)
		{
			return lhs .dot (rhs);
		},
		lerp: function (source, dest, t)
		{
			var
				x = source .x,
				y = source .y;

			return new Vector2 (x + t * (dest .x - x),
			                    y + t * (dest .y - y));
		},
		min: function (lhs, rhs)
		{
			var
				x = lhs .x,
				y = lhs .y;

			for (var i = 1, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .min (x, vector .x);
				y = Math .min (y, vector .y);
			}

			return new Vector2 (x, y);
		},
		max: function (lhs, rhs)
		{
			var
				x = lhs .x,
				y = lhs .y;

			for (var i = 1, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .max (x, vector .x);
				y = Math .max (y, vector .y);
			}

			return new Vector2 (x, y);
		},
	});

	return Vector2;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFVec2',[
	"x_ite/Basic/X3DField",
	"x_ite/Fields/SFVecPrototypeTemplate",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector2",
],
function (X3DField, SFVecPrototypeTemplate, X3DConstants, Vector2)
{
"use strict";

	function SFVec2Template (TypeName, Type)
	{
		function SFVec2 (x, y)
		{
			switch (arguments .length)
			{
				case 0:
					return X3DField .call (this, new Vector2 (0, 0));

				case 1:
					return X3DField .call (this, arguments [0]);

				case 2:
					return X3DField .call (this, new Vector2 (x * 1, y * 1));
			}

			throw new Error ("Invalid arguments.");
		}

		SFVec2 .prototype = Object .assign (Object .create (X3DField .prototype),
			SFVecPrototypeTemplate (Vector2),
		{
			constructor: SFVec2,
			getTypeName: function ()
			{
				return TypeName;
			},
			getType: function ()
			{
				return Type;
			},
		});

		var x = {
			get: function ()
			{
				return this .getValue () .x;
			},
			set: function (value)
			{
				this .getValue () .x = value * 1;
				this .addEvent ();
			},
			enumerable: true,
			configurable: false
		};

		var y = {
			get: function ()
			{
				return this .getValue () .y;
			},
			set: function (value)
			{
				this .getValue () .y = value * 1;
				this .addEvent ();
			},
			enumerable: true,
			configurable: false
		};

		Object .defineProperty (SFVec2 .prototype, "x", x);
		Object .defineProperty (SFVec2 .prototype, "y", y);

		x .enumerable = false;
		y .enumerable = false;

		Object .defineProperty (SFVec2 .prototype, "0", x);
		Object .defineProperty (SFVec2 .prototype, "1", y);

		return SFVec2;
	}

	return {
		SFVec2d: SFVec2Template ("SFVec2d", X3DConstants .SFVec2d),
		SFVec2f: SFVec2Template ("SFVec2f", X3DConstants .SFVec2f),
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Vector3',[
	"standard/Math/Algorithm",
],
function (Algorithm)
{
"use strict";

	function Vector3 (x, y, z)
	{		
		this .x = x;
		this .y = y;
		this .z = z;
	}

	Vector3 .prototype =
	{
		constructor: Vector3,
		length: 3,
		copy: function ()
		{
			var copy = Object .create (Vector3 .prototype);
			copy .x = this .x;
			copy .y = this .y;
			copy .z = this .z;
			return copy;
		},
		assign: function (vector)
		{
			this .x = vector .x;
			this .y = vector .y;
			this .z = vector .z;
			return this;
		},
		set: function (x, y, z)
		{
			this .x = x;
			this .y = y;
			this .z = z;
			return this;
		},
		equals: function (vector)
		{
			return this .x === vector .x &&
			       this .y === vector .y &&
			       this .z === vector .z;
		},
		negate: function ()
		{
			this .x = -this .x;
			this .y = -this .y;
			this .z = -this .z;
			return this;
		},
		add: function (vector)
		{
			this .x += vector .x;
			this .y += vector .y;
			this .z += vector .z;
			return this;
		},
		subtract: function (vector)
		{
			this .x -= vector .x;
			this .y -= vector .y;
			this .z -= vector .z;
			return this;
		},
		multiply: function (value)
		{
			this .x *= value;
			this .y *= value;
			this .z *= value;
			return this;
		},
		multVec: function (vector)
		{
			this .x *= vector .x;
			this .y *= vector .y;
			this .z *= vector .z;
			return this;
		},
		divide: function (value)
		{
			this .x /= value;
			this .y /= value;
			this .z /= value;
			return this;
		},
		divVec: function (vector)
		{
			this .x /= vector .x;
			this .y /= vector .y;
			this .z /= vector .z;
			return this;
		},
		cross: function (vector)
		{
			var x = this .x, y = this .y, z = this .z;

			this .x = y * vector .z - z * vector .y;
			this .y = z * vector .x - x * vector .z;
			this .z = x * vector .y - y * vector .x;

			return this;
		},
		normalize: function ()
		{
			var
				x = this .x,
				y = this .y,
				z = this .z;

			var length = Math .sqrt (x * x +
			                         y * y +
			                         z * z);

			if (length)
			{
				this .x = x / length;
				this .y = y / length;
				this .z = z / length;
			}

			return this;
		},
		dot: function (vector)
		{
			return this .x * vector .x +
			       this .y * vector .y +
			       this .z * vector .z;
		},
		norm: function ()
		{
			var
				x = this .x,
				y = this .y,
				z = this .z;

			return x * x +
			       y * y +
			       z * z;
		},
		abs: function ()
		{
			var
				x = this .x,
				y = this .y,
				z = this .z;

			return Math .sqrt (x * x +
			                   y * y +
			                   z * z);
		},
		distance: function (vector)
		{
			var
				x = this .x - vector .x,
				y = this .y - vector .y,
				z = this .z - vector .z;

			return Math .sqrt (x * x +
			                   y * y +
			                   z * z);
		},
		lerp: function (dest, t)
		{
			var
				x = this .x,
				y = this .y,
				z = this .z;

			this .x = x + t * (dest .x - x);
			this .y = y + t * (dest .y - y);
			this .z = z + t * (dest .z - z);
			return this;
		},
		slerp: function (destination, t)
		{
			return Algorithm .simpleSlerp (this, tmp .assign (destination), t);
		},
		min: function (vector)
		{
			var
				x = this .x,
				y = this .y,
				z = this .z;

			for (var i = 0, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .min (x, vector .x);
				y = Math .min (y, vector .y);
				z = Math .min (z, vector .z);
			}

			this .x = x;
			this .y = y;
			this .z = z;
			return this;
		},
		max: function (vector)
		{
			var
				x = this .x,
				y = this .y,
				z = this .z;

			for (var i = 0, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .max (x, vector .x);
				y = Math .max (y, vector .y);
				z = Math .max (z, vector .z);
			}

			this .x = x;
			this .y = y;
			this .z = z;
			return this;
		},
		toString: function ()
		{
			return this .x + " " +
			       this .y + " " +
			       this .z;
		}
	};

	Object .defineProperty (Vector3 .prototype, "0",
	{
		get: function () { return this .x; },
		set: function (value) { this .x = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Vector3 .prototype, "1",
	{
		get: function () { return this .y; },
		set: function (value) { this .y = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Vector3 .prototype, "2",
	{
		get: function () { return this .z; },
		set: function (value) { this .z = value; },
		enumerable: false,
		configurable: false
	});

	Object .assign (Vector3,
	{
		Zero: new Vector3 (0, 0, 0),
		One: new Vector3 (1, 1, 1),
		xAxis: new Vector3 (1, 0, 0),
		yAxis: new Vector3 (0, 1, 0),
		zAxis: new Vector3 (0, 0, 1),
		negate: function (vector)
		{
			var copy = Object .create (this .prototype);
			copy .x = -vector .x;
			copy .y = -vector .y;
			copy .z = -vector .z;
			return copy;
		},
		add: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x + rhs .x;
			copy .y = lhs .y + rhs .y;
			copy .z = lhs .z + rhs .z;
			return copy;
		},
		subtract: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x - rhs .x;
			copy .y = lhs .y - rhs .y;
			copy .z = lhs .z - rhs .z;
			return copy;
		},
		multiply: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x * rhs;
			copy .y = lhs .y * rhs;
			copy .z = lhs .z * rhs;
			return copy;
		},
		multVec: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x * rhs .x;
			copy .y = lhs .y * rhs .y;
			copy .z = lhs .z * rhs .z;
			return copy;
		},
		divide: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x / rhs;
			copy .y = lhs .y / rhs;
			copy .z = lhs .z / rhs;
			return copy;
		},
		divVec: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x / rhs .x;
			copy .y = lhs .y / rhs .y;
			copy .z = lhs .z / rhs .z;
			return copy;
		},
		cross: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .y * rhs .z - lhs .z * rhs .y;
			copy .y = lhs .z * rhs .x - lhs .x * rhs .z;
			copy .z = lhs .x * rhs .y - lhs .y * rhs .x;
			return copy;
		},
		normalize: function (vector)
		{
			var
				copy   = Object .create (this .prototype),
				x      = vector .x,
				y      = vector .y,
				z      = vector .z,
				length = Math .sqrt (x * x + y * y + z * z);

			if (length)
			{
				copy .x = x / length;
				copy .y = y / length;
				copy .z = z / length;
			}
			else
			{
				copy .x = 0;
				copy .y = 0;
				copy .z = 0;
			}

			return copy;
		},
		dot: function (lhs, rhs)
		{
			return lhs .dot (rhs);
		},
		lerp: function (source, dest, t)
		{
			var
				x = source .x,
				y = source .y,
				z = source .z;

			return new Vector3 (x + t * (dest .x - x),
			                    y + t * (dest .y - y),
			                    z + t * (dest .z - z));
		},
		slerp: function (source, destination, t)
		{
			return Algorithm .simpleSlerp (source .copy (), tmp .assign (destination), t);
		},
		min: function (lhs, rhs)
		{
			var
				x = lhs .x,
				y = lhs .y,
				z = lhs .z;

			for (var i = 1, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .min (x, vector .x);
				y = Math .min (y, vector .y);
				z = Math .min (z, vector .z);
			}

			return new Vector3 (x, y, z);
		},
		max: function (lhs, rhs)
		{
			var
				x = lhs .x,
				y = lhs .y,
				z = lhs .z;

			for (var i = 1, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .max (x, vector .x);
				y = Math .max (y, vector .y);
				z = Math .max (z, vector .z);
			}

			return new Vector3 (x, y, z);
		},
	});

	var tmp = new Vector3 (0, 0, 0);

	return Vector3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Matrix2',[
	"standard/Math/Numbers/Vector2",
	"standard/Math/Algorithm"
],
function (Vector2,
          Algorithm)
{
"use strict";

	function Matrix2 ()
	{
		if (arguments .length)
		{
			this [0] = arguments [0];
			this [1] = arguments [1];
			this [2] = arguments [2];
			this [3] = arguments [3];
		}
		else
		{
			this .identity ();
		}
	}

	Matrix2 .prototype =
	{
		constructor: Matrix2,
		order: 2,
		length: 4,
		copy: function ()
		{
			var copy = Object .create (Matrix2 .prototype);
			copy [0] = this [0];
			copy [1] = this [1];
			copy [2] = this [2];
			copy [3] = this [3];
			return copy;
		},
		assign: function (matrix)
		{
			this [0] = matrix [0];
			this [1] = matrix [1];
			this [2] = matrix [2];
			this [3] = matrix [3];
			return this;
		},
		equals: function (matrix)
		{
			return this [0] === matrix [0] &&
			       this [1] === matrix [1] &&
			       this [2] === matrix [2] &&
			       this [3] === matrix [3];
		},
		set1: function (r, c, value)
		{
			this [r * this .order + c] = value;
		},
		get1: function (r, c)
		{
			return this [r * this .order + c];
		},
		set: function ()
		{
			switch (arguments .length)
			{
				case 0:
				{
					this .identity ();
					break;
				}
				case 4:
				{
					this [0] = arguments [0];
					this [1] = arguments [1];
					this [2] = arguments [2];
					this [3] = arguments [3];	
					break;
				}
			}
		},
		determinant1: function ()
		{
			return this [0];
		},
		determinant: function ()
		{
			return this [0] * this [3] -
			       this [1] * this [2];
		},
		transpose: function ()
		{
			var tmp = this [1];

			this [1] = this [2];
			this [2] = tmp;

			return this;
		},
		inverse: function ()
		{
			var d = this .determinant ();
		
			if (d === 0)
				throw new Error ("Matrix2 .inverse: determinant is 0.");

			this [0] =  array [0] / d;
			this [1] = -array [1] / d;
			this [2] = -array [2] / d;
			this [3] =  array [3] / d;

			return this;
		},
		multLeft: function (matrix)
		{
			var
				a0 = this [0], a1 = this [1],
				a2 = this [2], a3 = this [3],
				b0 = matrix [0], b1 = matrix [1],
				b2 = matrix [2], b3 = matrix [3];

	      this [0] = a0 * b0 + a2 * b1;
	      this [1] = a1 * b0 + a3 * b1;
	      this [2] = a0 * b2 + a2 * b3;
	      this [3] = a1 * b2 + a3 * b3;

			return this;
		},
		multRight: function (matrix)
		{
			var
				a0 = this [0], a1 = this [1],
				a2 = this [2], a3 = this [3],
				b0 = matrix [0], b1 = matrix [1],
				b2 = matrix [2], b3 = matrix [3];

	      this [0] = b0 * a0 + b2 * a1;
	      this [1] = b1 * a0 + b3 * a1;
	      this [2] = b0 * a2 + b2 * a3;
	      this [3] = b1 * a2 + b3 * a3;

			return this;
		},
		identity: function ()
		{
			this [0] = 1;
			this [1] = 0;
			this [2] = 0;
			this [3] = 1;	
		},
		toString: function ()
		{
			return this [0] + " " + this [1] + " " +
			       this [2] + " " + this [3]
		},
	};

	Object .defineProperty (Matrix2 .prototype, "x",
	{
		get: (function ()
		{
			var vector = new Vector2 (0, 0);

			return function () { return vector .set (this [0], this [1]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix2 .prototype, "xAxis",
	{
		get: function () { return this [0]; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix2 .prototype, "origin",
	{
		get: function () { return this [2]; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix2 .prototype, "submatrix",
	{
		get: function () { return this [0]; },
		enumerable: false,
		configurable: false
	});

	Object .assign (Matrix2,
	{
		Identity: new Matrix2 (),
	});

	return Matrix2;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithms/eigendecomposition',[],function ()
{
"use strict";

	var a = [ ]; // more scratch
	var b = [ ]; // more scratch
	var z = [ ]; // more scratch

	// Calculate eigenvalues and eigenvectors.
	// This is from SGI Inventor Matrix.cpp.
	return function (matrix, result)
	{
		var
			ORDER   = matrix .order,
			values  = result .values,
			vectors = result .vectors;

		var
			sm,                // smallest entry
			theta,             // angle for Jacobi rotation
			c, s, t,           // cosine, sine, tangent of theta
			tau,               // sine / (1 + cos)
			h, g,              // two scrap values
			thresh,            // threshold below which no rotation done
			p, q, i, j,
			SIZE = matrix .length;

		// initializations
		for (i = 0; i < ORDER; ++ i)
		{
			a [i] = a [i] || new Array (ORDER);
			b [i] = values [i] = matrix .get1 (i, i);
			z [i] = 0;

			for (j = 0; j < ORDER; ++ j)
			{
				vectors [i] [j] = (i === j) ? 1 : 0;
				a [i] [j] = matrix .get1 (j, i);
			}
		}

		// Why 50? I don't know--it's the way the folks who wrote the
		// algorithm did it:
		for (i = 0; i < 50; ++ i)
		{
			sm = 0;

			for (p = 0; p < ORDER - 1; ++ p)
			{
				for (q = p + 1; q < ORDER; ++ q)
					sm += Math .abs (a [p] [q]);
			}

			if (sm === 0)
				break;

			thresh = i < 3 ?
				0.2 * sm / SIZE :
				0;

			for (p = 0; p < ORDER - 1; ++ p)
			{
				for (q = p + 1; q < ORDER; ++ q)
				{
					g = 100 * Math .abs (a [p] [q]);

					if (i > 3
						 && (Math .abs (values [p]) + g === Math .abs (values [p]))
						 && (Math .abs (values [q]) + g === Math .abs (values [q]))
					)
					{
						a [p] [q] = 0;
					}

					else if (Math .abs (a [p] [q]) > thresh)
					{
						h = values [q] - values [p];

						if (Math .abs (h) + g === Math .abs (h))
						{
							t = a [p] [q] / h;
						}
						else
						{
							theta = 0.5 * h / a [p] [q];
							t     = 1 / (Math .abs (theta) + Math .sqrt (1 + theta * theta));

							if (theta < 0)  t = -t;
						}
						// End of computing tangent of rotation angle

						c           = 1 / Math .sqrt (1 + t * t);
						s           = t * c;
						tau         = s / (1 + c);
						h           = t * a [p] [q];
						z [p]      -= h;
						z [q]      += h;
						values [p] -= h;
						values [q] += h;
						a [p] [q]   = 0;

						for (j = 0; j < p; ++ j)
						{
							g = a [j] [p];
							h = a [j] [q];
							a [j] [p] = g - s * (h + g * tau);
							a [j] [q] = h + s * (g - h * tau);
						}

						for (j = p + 1; j < q; ++ j)
						{
							g = a [p] [j];
							h = a [j] [q];
							a [p] [j] = g - s * (h + g * tau);
							a [j] [q] = h + s * (g - h * tau);
						}

						for (j = q + 1; j < ORDER; ++ j)
						{
							g = a [p] [j];
							h = a [q] [j];
							a [p] [j] = g - s * (h + g * tau);
							a [q] [j] = h + s * (g - h * tau);
						}

						for (j = 0; j < ORDER; ++ j)
						{
							g = vectors [j] [p];
							h = vectors [j] [q];
							vectors [j] [p] = g - s * (h + g * tau);
							vectors [j] [q] = h + s * (g - h * tau);
						}
					}
				}
			}

			for (p = 0; p < ORDER; ++ p)
			{
				values [p] = b [p] += z [p];
				z [p] = 0;
			}
		}

		return result;
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Matrix3',[
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix2",
	"standard/Math/Algorithms/eigendecomposition",
],
function (Vector2,
          Vector3,
          Matrix2,
          eigendecomposition)
{
"use strict";
								
	function Matrix3 ()
	{
		if (arguments .length)
		{
			this [0] = arguments [0];
			this [1] = arguments [1];
			this [2] = arguments [2];
			this [3] = arguments [3];
			this [4] = arguments [4];
			this [5] = arguments [5];
			this [6] = arguments [6];
			this [7] = arguments [7];
			this [8] = arguments [8];
		}
		else
		{
			this .identity ();
		}
	}

	Matrix3 .prototype =
	{
		constructor: Matrix3,
		order: 3,
		length: 9,
		copy: function ()
		{
			var copy = Object .create (Matrix3 .prototype);
			copy [0] = this [0];
			copy [1] = this [1];
			copy [2] = this [2];
			copy [3] = this [3];
			copy [4] = this [4];
			copy [5] = this [5];
			copy [6] = this [6];
			copy [7] = this [7];
			copy [8] = this [8];
			return copy;
		},
		assign: function (matrix)
		{
			this [0] = matrix [0];
			this [1] = matrix [1];
			this [2] = matrix [2];
			this [3] = matrix [3];
			this [4] = matrix [4];
			this [5] = matrix [5];
			this [6] = matrix [6];
			this [7] = matrix [7];
			this [8] = matrix [8];
			return this;
		},
		equals: function (matrix)
		{
			return this [0] === matrix [0] &&
			       this [1] === matrix [1] &&
			       this [2] === matrix [2] &&
			       this [3] === matrix [3] &&
			       this [4] === matrix [4] &&
			       this [5] === matrix [5] &&
			       this [6] === matrix [6] &&
			       this [7] === matrix [7] &&
			       this [8] === matrix [8];
		},
		rotation: function ()
		{
			return math .atan2 (this [1], this [0]);
		},
		set1: function (r, c, value)
		{
			this [r * this .order + c] = value;

			return this;
		},
		get1: function (r, c)
		{
			return this [r * this .order + c];
		},
		set: function (translation, rotation, scale, scaleOrientation, center)
		{
			switch (arguments .length)
			{
				case 0:
				{
					this .identity ();
					break;
				}
				case 1:
				{
					if (translation === null) translation = Vector2 .Zero;

					this .identity ();
					this .translate (translation);
					break;
				}
				case 2:
				{
					if (translation === null) translation = Vector2 .Zero;
					if (rotation    === null) rotation    = 0;

					this .identity ();
					this .translate (translation);

					if (rotation !== 0)
						this .rotate (rotation);

					break;
				}
				case 3:
				{
					if (translation === null) translation = Vector2 .Zero;
					if (rotation    === null) rotation    = 0;
					if (scale       === null) scale       = Vector2 .One;

					this .identity ();
					this .translate (translation);

					if (rotation !== 0)
						this .rotate (rotation);

					if (! scale .equals (Vector2 .One))
						this .scale  (scale);

					break;
				}
				case 4:
				{
					if (translation      === null) translation      = Vector2 .Zero;
					if (rotation         === null) rotation         = 0;
					if (scale            === null) scale            = Vector2 .One;
					if (scaleOrientation === null) scaleOrientation = 0;

					this .identity ();
					this .translate (translation);

					if (rotation !== 0)
						this .rotate (rotation);

					if (! scale .equals (Vector2 .One))
					{
						var hasScaleOrientation = scaleOrientation !== 0;

						if (hasScaleOrientation)
						{
							this .rotate (scaleOrientation);
							this .scale (scale);
							this .rotate (-scaleOrientation);
						}
						else
							this .scale (scale);
					}

					break;
				}
				case 5:
				{
					if (translation      === null) translation      = Vector2 .Zero;
					if (rotation         === null) rotation         = 0;
					if (scale            === null) scale            = Vector2 .One;
					if (scaleOrientation === null) scaleOrientation = 0;
					if (center           === null) center           = Vector2 .Zero;

					// P' = T * C * R * SR * S * -SR * -C * P
					this .identity ();
					this .translate (translation);

					var hasCenter = ! center .equals (Vector2 .Zero);

					if (hasCenter)
						this .translate (center);

					if (rotation !== 0)
						this .rotate (rotation);

					if (! scale .equals (Vector2 .One))
					{
						if (scaleOrientation !== 0)
						{
							this .rotate (scaleOrientation);
							this .scale (scale);
							this .rotate (-scaleOrientation);
						}
						else
							this .scale (scale);
					}

					if (hasCenter)
						this .translate (Vector2 .negate (center));

					break;
				}
				case 9:
				{
					this [0] = arguments [0];
					this [1] = arguments [1];
					this [2] = arguments [2];
					this [3] = arguments [3];
					this [4] = arguments [4];
					this [5] = arguments [5];
					this [6] = arguments [6];
					this [7] = arguments [7];
					this [8] = arguments [8];
					break;
				}
			}

			return this;
		},
		get: (function ()
		{
			var
				dummyTranslation      = new Vector2 (0, 0),
				dummyRotation         = new Vector3 (0, 0, 0),
				dummyScale            = new Vector2 (0, 0),
				dummyScaleOrientation = new Vector3 (0, 0, 0),
				dummyCenter           = new Vector2 (0, 0),
				rotMatrix             = new Matrix2 (),
				soMatrix              = new Matrix2 (),
				c                     = new Vector2 (0, 0);

			return function (translation, rotation, scale, scaleOrientation, center)
			{
				if (translation      === null) translation      = dummyTranslation;
				if (rotation         === null) rotation         = dummyRotation;
				if (scale            === null) scale            = dummyScale;
				if (scaleOrientation === null) scaleOrientation = dummyScaleOrientation;
				if (center           === null) center           = dummyCenter;
	
				switch (arguments .length)
				{
					case 1:
					{
						translation .set (this [6], this [7]);
						break;
					}
					case 2:
					{
						this .factor (translation, rotMatrix, dummyScale, soMatrix);
	
						rotation [0] = rotMatrix [0];
						rotation [1] = rotMatrix [1];
						rotation [2] = Math .atan2 (rotMatrix [1], rotMatrix [0]);
						break;
					}
					case 3:
					{
						this .factor (translation, rotMatrix, scale, soMatrix);
	
						rotation [0] = rotMatrix [0];
						rotation [1] = rotMatrix [1];
						rotation [2] = Math .atan2 (rotMatrix [1], rotMatrix [0]);
						break;
					}
					case 4:
					{
						this .factor (translation, rotMatrix, scale, soMatrix);
	
						rotation [0] = rotMatrix [0];
						rotation [1] = rotMatrix [1];
						rotation [2] = Math .atan2 (rotMatrix [1], rotMatrix [0]);
	
						scaleOrientation [0] = soMatrix [0];
						scaleOrientation [1] = soMatrix [1];
						scaleOrientation [2] = Math .atan2 (soMatrix [1], soMatrix [0]);
						break;
					}
					case 5:
					{
						var m = new Matrix3 ();
	
						m .set (c .assign (center) .negate ());
						m .multLeft (this);
						m .translate (center);
	
						m .get (translation, rotation, scale, scaleOrientation);
						break;
					}
				}
			};
		})(),
		factor: (function ()
		{
			var
				si   = new Matrix2 (),
				sosi = new Matrix2 (),
				b    = new Matrix2 ();

			var eigen = { values: [ ], vectors: [[ ], [ ]] };

			return function (translation, rotation, scale, scaleOrientation)
			{
				// (1) Get translation.
				translation .set (this [6], this [7]);
	
				// (2) Create 3x3 matrix.
				var a = this .submatrix;
	
				// (3) Compute det A. If negative, set sign = -1, else sign = 1
				var det      = a .determinant ();
				var det_sign = det < 0 ? -1 : 1;
	
				if (det === 0)
					throw new Error ("Matrix3 .factor: determinant is 0.");
	
				// (4) B = A * !A  (here !A means A transpose)
				b .assign (a) .transpose () .multLeft (a);
				var e = eigendecomposition (b, eigen);
	
				// Find min / max eigenvalues and do ratio test to determine singularity.
	
				scaleOrientation .set (e .vectors [0] [0], e .vectors [0] [1],
				                       e .vectors [1] [0], e .vectors [1] [1]);
	
				// Compute s = sqrt(evalues), with sign. Set si = s-inverse
	
				scale .x = det_sign * Math .sqrt (e .values [0]);
				scale .y = det_sign * Math .sqrt (e .values [1]);
	
				si [0] = 1 / scale .x;
				si [3] = 1 / scale .y;
	
				// (5) Compute U = !R ~S R A.
				rotation .assign (sosi .assign (scaleOrientation) .multRight (si) .transpose () .multLeft (scaleOrientation) .multRight (a));
	
				scaleOrientation .transpose ();
			};
		})(),
		determinant2: function ()
		{
			return this [0] * this [4] -
			       this [1] * this [3];
		},
		determinant: function ()
		{
			var
				m0 = this [0], m1 = this [1], m2 = this [2],
				m3 = this [3], m4 = this [4], m5 = this [5],
				m6 = this [6], m7 = this [7], m8 = this [8];

			return m0 * (m4 * m8 - m5 * m7) -
			       m1 * (m3 * m8 - m5 * m6) +
			       m2 * (m3 * m7 - m4 * m6);
		},
		transpose: function ()
		{
			var tmp;

			tmp = this [1]; this [1] = this [3]; this [3] = tmp;
			tmp = this [2]; this [2] = this [6]; this [6] = tmp;
			tmp = this [5]; this [5] = this [7]; this [7] = tmp;

			return this;
		},
		inverse: function ()
		{
			var
				m0  = this [0],
				m1  = this [1],
				m2  = this [2],
				m3  = this [3],
				m4  = this [4],
				m5  = this [5],
				m6  = this [6],
				m7  = this [7],
				m8  = this [8],
				t4  = m0 * m4,
				t6  = m0 * m7,
				t8  = m3 * m1,
				t10 = m3 * m7,
				t12 = m6 * m1,
				t14 = m6 * m4;

			var d = (t4 * m8 - t6 * m5 - t8 * m8 + t10 * m2 + t12 * m5 - t14 * m2);

			if (d === 0)
				throw new Error ("Matrix3 .inverse: determinant is 0.");

			d = 1 / d;

			var
				b0 =  (m4 * m8 - m7 * m5) * d,
				b1 = -(m1 * m8 - m7 * m2) * d,
				b2 =  (m1 * m5 - m4 * m2) * d,
				b3 = -(m3 * m8 - m6 * m5) * d,
				b4 =  (m0 * m8 - m6 * m2) * d,
				b5 = -(m0 * m5 - m3 * m2) * d;
	
			this [0] = b0;
			this [1] = b1;
			this [2] = b2;
			this [3] = b3;
			this [4] = b4;
			this [5] = b5;
			this [6] =  (t10 - t14) * d;
			this [7] = -(t6 - t12) * d;
			this [8] =  (t4 - t8) * d;

			return this;
		},
		multLeft: function (matrix)
		{
			var
				a0 = this [0], a1 = this [1], a2 = this [2],
				a3 = this [3], a4 = this [4], a5 = this [5],
				a6 = this [6], a7 = this [7], a8 = this [8],
				b0 = matrix [0], b1 = matrix [1], b2 = matrix [2],
				b3 = matrix [3], b4 = matrix [4], b5 = matrix [5],
				b6 = matrix [6], b7 = matrix [7], b8 = matrix [8];

			this [0] = a0 * b0 + a3 * b1 + a6 * b2;
			this [1] = a1 * b0 + a4 * b1 + a7 * b2;
			this [2] = a2 * b0 + a5 * b1 + a8 * b2;
			this [3] = a0 * b3 + a3 * b4 + a6 * b5;
			this [4] = a1 * b3 + a4 * b4 + a7 * b5;
			this [5] = a2 * b3 + a5 * b4 + a8 * b5;
			this [6] = a0 * b6 + a3 * b7 + a6 * b8;
			this [7] = a1 * b6 + a4 * b7 + a7 * b8;
			this [8] = a2 * b6 + a5 * b7 + a8 * b8;

			return this;
		},
		multRight: function (matrix)
		{
			var
				a0 = this [0], a1 = this [1], a2 = this [2],
				a3 = this [3], a4 = this [4], a5 = this [5],
				a6 = this [6], a7 = this [7], a8 = this [8],
				b0 = matrix [0], b1 = matrix [1], b2 = matrix [2],
				b3 = matrix [3], b4 = matrix [4], b5 = matrix [5],
				b6 = matrix [6], b7 = matrix [7], b8 = matrix [8];

			this [0] = a0 * b0 + a1 * b3 + a2 * b6;
			this [1] = a0 * b1 + a1 * b4 + a2 * b7;
			this [2] = a0 * b2 + a1 * b5 + a2 * b8;
			this [3] = a3 * b0 + a4 * b3 + a5 * b6;
			this [4] = a3 * b1 + a4 * b4 + a5 * b7;
			this [5] = a3 * b2 + a4 * b5 + a5 * b8;
			this [6] = a6 * b0 + a7 * b3 + a8 * b6;
			this [7] = a6 * b1 + a7 * b4 + a8 * b7;
			this [8] = a6 * b2 + a7 * b5 + a8 * b8;

			return this;
		},
		multVecMatrix: function (vector)
		{
			if (vector .length === 2)
			{
				var
					x = vector .x,
					y = vector .y,
					w = x * this [2] + y * this [5] + this [8];

				vector .x = (x * this [0] + y * this [3] + this [6]) / w;
				vector .y = (x * this [1] + y * this [4] + this [7]) / w;
				
				return vector;
			}

			var
				x = vector .x,
				y = vector .y,
				z = vector .z;

			vector .x = x * this [0] + y * this [3] + z * this [6];
			vector .y = x * this [1] + y * this [4] + z * this [7];
			vector .z = x * this [2] + y * this [5] + z * this [8];

			return vector;
		},
		multMatrixVec: function (vector)
		{
			if (vector .length === 2)
			{
				var
					x = vector .x,
					y = vector .y,
					w = x * this [6] + y * this [7] + this [8];

				vector .x = (x * this [0] + y * this [1] + this [2]) / w;
				vector .y = (x * this [3] + y * this [4] + this [5]) / w;
				
				return vector;
			}

			var
				x = vector .x,
				y = vector .y,
				z = vector .z;

			vector .x = x * this [0] + y * this [1] + z * this [2];
			vector .y = x * this [3] + y * this [4] + z * this [5];
			vector .z = x * this [6] + y * this [7] + z * this [8];

			return vector;
		},
		multDirMatrix: function (vector)
		{
			var
				x = vector .x,
				y = vector .y;

			vector .x = x * this [0] + y * this [3];
			vector .y = x * this [1] + y * this [4];

			return vector;
		},
		multMatrixDir: function (vector)
		{
			var
				x = vector .x,
				y = vector .y;

			vector .x = x * this [0] + y * this [1];
			vector .y = x * this [3] + y * this [4];

			return vector;
		},
		identity: function ()
		{
			this [0] = 1; this [1] = 0; this [2] = 0;
			this [3] = 0; this [4] = 1; this [5] = 0;
			this [6] = 0; this [7] = 0; this [8] = 1;
		},
		translate: function (translation)
		{
			var
				x = translation .x,
				y = translation .y;

			this [6] += this [0] * x + this [3] * y;
			this [7] += this [1] * x + this [4] * y;

			return this;
		},
		rotate: function (rotation)
		{
			this .multLeft (Matrix3 .Rotation (rotation));

			return this;
		},
		scale: function (scale)
		{
			var
				x = scale .x,
				y = scale .y;

			this [0] *= x;
			this [3] *= y;

			this [1] *= x;
			this [4] *= y;

			return this;
		},
		toString: function ()
		{
			return this [0] + " " + this [1] + " " + this [2] + " " +
			       this [3] + " " + this [4] + " " + this [5] + " " +
			       this [6] + " " + this [7] + " " + this [8]
		},
	};

	Object .defineProperty (Matrix3 .prototype, "x",
	{
		get: (function ()
		{
			var vector = new Vector3 (0, 0, 0);

			return function () { return vector .set (this [0], this [1], this [2]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix3 .prototype, "y",
	{
		get: (function ()
		{
			var vector = new Vector3 (0, 0, 0);

			return function () { return vector .set (this [3], this [4], this [5]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix3 .prototype, "xAxis",
	{
		get: (function ()
		{
			var vector = new Vector2 (0, 0);

			return function () { return vector .set (this [0], this [1]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix3 .prototype, "yAxis",
	{
		get: (function ()
		{
			var vector = new Vector2 (0, 0);

			return function () { return vector .set (this [3], this [4]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix3 .prototype, "origin",
	{
		get: (function ()
		{
			var vector = new Vector2 (0, 0);

			return function () { return vector .set (this [6], this [7]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix3 .prototype, "submatrix",
	{
		get: (function ()
		{
			var matrix = new Matrix2 ();

			return function ()
			{
				matrix [0] = this [0]; matrix [1] = this [1];
				matrix [2] = this [3]; matrix [3] = this [4];
				return matrix;
			};
		})(),
		enumerable: false,
		configurable: false
	});

	Object .assign (Matrix3,
	{
		Identity: new Matrix3 (),
		Rotation: function (rotation)
		{
			var
				sinAngle = Math .sin (rotation),
				cosAngle = Math .cos (rotation);

			return new Matrix3 ( cosAngle, sinAngle, 0,
			                    -sinAngle, cosAngle, 0,
			                     0, 0, 1);
		},
		Matrix2: function (matrix)
		{
			return new Matrix3 (matrix [0], matrix [1], 0,
			                    matrix [2], matrix [3], 0,
			                    0, 0, 1);
		},
		transpose: function (matrix)
		{
			var copy = Object .create (this .prototype);
			copy [0] = matrix [0]; copy [1] = matrix [3]; copy [2] = matrix [6];
			copy [3] = matrix [1]; copy [4] = matrix [4]; copy [5] = matrix [7];
			copy [6] = matrix [2]; copy [7] = matrix [5]; copy [8] = matrix [8];
			return copy;
		},
		inverse: function (matrix)
		{
			var
				copy = Object .create (this .prototype),
				m0  = matrix [0],
				m1  = matrix [1],
				m2  = matrix [2],
				m3  = matrix [3],
				m4  = matrix [4],
				m5  = matrix [5],
				m6  = matrix [6],
				m7  = matrix [7],
				m8  = matrix [8],
				t4  = m0 * m4,
				t6  = m0 * m7,
				t8  = m3 * m1,
				t10 = m3 * m7,
				t12 = m6 * m1,
				t14 = m6 * m4;

			var d = (t4 * m8 - t6 * m5 - t8 * m8 + t10 * m2 + t12 * m5 - t14 * m2);

			if (d === 0)
				throw new Error ("Matrix3 .inverse: determinant is 0.");

			d = 1 / d;

			var
				b0 =  (m4 * m8 - m7 * m5) * d,
				b1 = -(m1 * m8 - m7 * m2) * d,
				b2 =  (m1 * m5 - m4 * m2) * d,
				b3 = -(m3 * m8 - m6 * m5) * d,
				b4 =  (m0 * m8 - m6 * m2) * d,
				b5 = -(m0 * m5 - m3 * m2) * d;
	
			copy [0] = b0;
			copy [1] = b1;
			copy [2] = b2;
			copy [3] = b3;
			copy [4] = b4;
			copy [5] = b5;
			copy [6] =  (t10 - t14) * d;
			copy [7] = -(t6 - t12) * d;
			copy [8] =  (t4 - t8) * d;

			return copy;
		},
		multLeft: function (lhs, rhs)
		{
			var
				copy = Object .create (this .prototype),
				a0 = lhs [0], a1 = lhs [1], a2 = lhs [2],
				a3 = lhs [3], a4 = lhs [4], a5 = lhs [5],
				a6 = lhs [6], a7 = lhs [7], a8 = lhs [8],
				b0 = rhs [0], b1 = rhs [1], b2 = rhs [2],
				b3 = rhs [3], b4 = rhs [4], b5 = rhs [5],
				b6 = rhs [6], b7 = rhs [7], b8 = rhs [8];

			copy [0] = a0 * b0 + a3 * b1 + a6 * b2;
			copy [1] = a1 * b0 + a4 * b1 + a7 * b2;
			copy [2] = a2 * b0 + a5 * b1 + a8 * b2;
			copy [3] = a0 * b3 + a3 * b4 + a6 * b5;
			copy [4] = a1 * b3 + a4 * b4 + a7 * b5;
			copy [5] = a2 * b3 + a5 * b4 + a8 * b5;
			copy [6] = a0 * b6 + a3 * b7 + a6 * b8;
			copy [7] = a1 * b6 + a4 * b7 + a7 * b8;
			copy [8] = a2 * b6 + a5 * b7 + a8 * b8;

			return copy;
		},
		multRight: function (lhs, rhs)
		{
			var
				copy = Object .create (this .prototype),
				a0 = lhs [0], a1 = lhs [1], a2 = lhs [2],
				a3 = lhs [3], a4 = lhs [4], a5 = lhs [5],
				a6 = lhs [6], a7 = lhs [7], a8 = lhs [8],
				b0 = rhs [0], b1 = rhs [1], b2 = rhs [2],
				b3 = rhs [3], b4 = rhs [4], b5 = rhs [5],
				b6 = rhs [6], b7 = rhs [7], b8 = rhs [8];

			copy [0] = a0 * b0 + a1 * b3 + a2 * b6;
			copy [1] = a0 * b1 + a1 * b4 + a2 * b7;
			copy [2] = a0 * b2 + a1 * b5 + a2 * b8;
			copy [3] = a3 * b0 + a4 * b3 + a5 * b6;
			copy [4] = a3 * b1 + a4 * b4 + a5 * b7;
			copy [5] = a3 * b2 + a4 * b5 + a5 * b8;
			copy [6] = a6 * b0 + a7 * b3 + a8 * b6;
			copy [7] = a6 * b1 + a7 * b4 + a8 * b7;
			copy [8] = a6 * b2 + a7 * b5 + a8 * b8;

			return copy;
		},
	});

	return Matrix3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/



define ('x_ite/Fields/SFMatrix3',[
	"x_ite/Basic/X3DField",
	"x_ite/Fields/SFMatrixPrototypeTemplate",
	"x_ite/Fields/SFVec2",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix3",
],
function (X3DField,
          SFMatrixPrototypeTemplate,
          SFVec2,
          X3DConstants,
          Matrix3)
{
"use strict";

	function SFMatrix3Template (TypeName, Type, SFVec2)
	{
		function SFMatrix3 (m00, m01, m02,
		                    m10, m11, m12,
		                    m20, m21, m22)
		{
			switch (arguments .length)
			{
				case 0:
					return X3DField .call (this, new Matrix3 ());

				case 1:
					return X3DField .call (this, arguments [0]);

				case 9:
					return X3DField .call (this, new Matrix3 (m00 * 1, m01 * 1, m02 * 1,
					                                          m10 * 1, m11 * 1, m12 * 1,
					                                          m20 * 1, m21 * 1, m22 * 1));
			}

			throw new Error ("Invalid arguments.");
		}

		SFMatrix3 .prototype = Object .assign (Object .create (X3DField .prototype),
			SFMatrixPrototypeTemplate (Matrix3, SFVec2),
		{
			constructor: SFMatrix3,
			getTypeName: function ()
			{
				return TypeName;
			},
			getType: function ()
			{
				return Type;
			},
			setTransform: function (translation, rotation, scale, scaleOrientation, center)
			{
				translation      = translation      ? translation      .getValue () : null;
				rotation         = rotation         ? rotation                      : 0;
				scale            = scale            ? scale            .getValue () : null;
				scaleOrientation = scaleOrientation ? scaleOrientation              : 0;
				center           = center           ? center           .getValue () : null;

				this .getValue () .set (translation, rotation, scale, scaleOrientation, center);
			},
		});

		function defineProperty (i)
		{
			Object .defineProperty (SFMatrix3 .prototype, i,
			{
				get: function ()
				{
					return this .getValue () [i];
				},
				set: function (value)
				{
					this .getValue () [i] = value * 1;
					this .addEvent ();
				},
				enumerable: false,
				configurable: false
			});
		}

		for (var i = 0; i < Matrix3 .prototype .length; ++ i)
			defineProperty (i);

		return SFMatrix3;
	}

	return {
		SFMatrix3d: SFMatrix3Template ("SFMatrix3d", X3DConstants .SFMatrix3d, SFVec2 .SFVec2d),
		SFMatrix3f: SFMatrix3Template ("SFMatrix3f", X3DConstants .SFMatrix3f, SFVec2 .SFVec2f),
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFVec3',[
	"x_ite/Basic/X3DField",
	"x_ite/Fields/SFVecPrototypeTemplate",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (X3DField,
          SFVecPrototypeTemplate,
          X3DConstants,
          Vector3)
{
"use strict";

	function SFVec3Template (TypeName, Type)
	{
		function SFVec3 (x, y, z)
		{
			switch (arguments .length)
			{
				case 0:
					return X3DField .call (this, new Vector3 (0, 0, 0));

				case 1:
					return X3DField .call (this, arguments [0]);

				case 3:
					return X3DField .call (this, new Vector3 (x * 1, y * 1, z * 1));
			}

			throw new Error ("Invalid arguments.");
		}

		SFVec3 .prototype = Object .assign (Object .create (X3DField .prototype),
			SFVecPrototypeTemplate (Vector3),
		{
			constructor: SFVec3,
			getTypeName: function ()
			{
				return TypeName;
			},
			getType: function ()
			{
				return Type;
			},
			cross: function (vector)
			{
				return new (this .constructor) (Vector3 .cross (this .getValue (), vector .getValue ()));
			},
		});

		var x = {
			get: function ()
			{
				return this .getValue () .x;
			},
			set: function (value)
			{
				this .getValue () .x = value * 1;
				this .addEvent ();
			},
			enumerable: true,
			configurable: false
		};

		var y = {
			get: function ()
			{
				return this .getValue () .y;
			},
			set: function (value)
			{
				this .getValue () .y = value * 1;
				this .addEvent ();
			},
			enumerable: true,
			configurable: false
		};

		var z = {
			get: function ()
			{
				return this .getValue () .z;
			},
			set: function (value)
			{
				this .getValue () .z = value * 1;
				this .addEvent ();
			},
			enumerable: true,
			configurable: false
		};

		Object .defineProperty (SFVec3 .prototype, "x", x);
		Object .defineProperty (SFVec3 .prototype, "y", y);
		Object .defineProperty (SFVec3 .prototype, "z", z);

		x .enumerable = false;
		y .enumerable = false;
		z .enumerable = false;

		Object .defineProperty (SFVec3 .prototype, "0", x);
		Object .defineProperty (SFVec3 .prototype, "1", y);
		Object .defineProperty (SFVec3 .prototype, "2", z);

		return SFVec3;
	}

	return {
		SFVec3d: SFVec3Template ("SFVec3d", X3DConstants .SFVec3d),
		SFVec3f: SFVec3Template ("SFVec3f", X3DConstants .SFVec3f),
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Vector4',[
	"standard/Math/Algorithm",
],
function (Algorithm)
{
"use strict";

	function Vector4 (x, y, z, w)
	{
		this .x = x;
		this .y = y;
		this .z = z;
		this .w = w;
	}

	Vector4 .prototype =
	{
		constructor: Vector4,
		length: 4,
		copy: function ()
		{
			var copy = Object .create (Vector4 .prototype);
			copy .x = this .x;
			copy .y = this .y;
			copy .z = this .z;
			copy .w = this .w;
			return copy;
		},
		assign: function (vector)
		{
			this .x = vector .x;
			this .y = vector .y;
			this .z = vector .z;
			this .w = vector .w;
			return this;
		},
		set: function (x, y, z, w)
		{
			this .x = x;
			this .y = y;
			this .z = z;
			this .w = w;
			return this;
		},
		equals: function (vector)
		{
			return this .x === vector .x &&
			       this .y === vector .y &&
			       this .z === vector .z &&
			       this .w === vector .w;
		},
		getReal: function (vector)
		{
			vector .x = this .x / this .w;
			vector .y = this .y / this .w;
			vector .z = this .z / this .w;
		},
		negate: function ()
		{
			this .x = -this .x;
			this .y = -this .y;
			this .z = -this .z;
			this .w = -this .w;
			return this;
		},
		add: function (vector)
		{
			this .x += vector .x;
			this .y += vector .y;
			this .z += vector .z;
			this .w += vector .w;
			return this;
		},
		subtract: function (vector)
		{
			this .x -= vector .x;
			this .y -= vector .y;
			this .z -= vector .z;
			this .w -= vector .w;
			return this;
		},
		multiply: function (value)
		{
			this .x *= value;
			this .y *= value;
			this .z *= value;
			this .w *= value;
			return this;
		},
		multVec: function (vector)
		{
			this .x *= vector .x;
			this .y *= vector .y;
			this .z *= vector .z;
			this .w *= vector .w;
			return this;
		},
		divide: function (value)
		{
			this .x /= value;
			this .y /= value;
			this .z /= value;
			this .w /= value;
			return this;
		},
		divVec: function (vector)
		{
			this .x /= vector .x;
			this .y /= vector .y;
			this .z /= vector .z;
			this .w /= vector .w;
			return this;
		},
		normalize: function ()
		{
			var
				x = this .x,
				y = this .y,
				z = this .z,
				w = this .w;

			var length = Math .sqrt (x * x +
			                         y * y +
			                         z * z +
			                         w * w);

			if (length)
			{
				this .x = x / length;
				this .y = y / length;
				this .z = z / length;
				this .w = w / length;
			}

			return this;
		},
		dot: function (vector)
		{
			return this .x * vector .x +
			       this .y * vector .y +
			       this .z * vector .z +
			       this .w * vector .w;
		},
		norm: function ()
		{
			var
				x = this .x,
				y = this .y,
				z = this .z,
				w = this .w;

			return x * x +
			       y * y +
			       z * z +
			       w * w;
		},
		abs: function ()
		{
			var
				x = this .x,
				y = this .y,
				z = this .z,
				w = this .w;

			return Math .sqrt (x * x +
			                   y * y +
			                   z * z +
			                   w * w);
		},
		distance: function (vector)
		{
			var
				x = this .x - vector .x,
				y = this .y - vector .y,
				z = this .z - vector .z,
				w = this .w - vector .w;

			return Math .sqrt (x * x +
			                   y * y +
			                   z * z +
			                   w * w);
		},
		lerp: function (dest, t)
		{
			var
				x = this .x,
				y = this .y,
				z = this .z,
				w = this .w;

			this .x = x + t * (dest .x - x);
			this .y = y + t * (dest .y - y);
			this .z = z + t * (dest .z - z);
			this .w = w + t * (dest .w - w);
			return this;
		},
		min: function (vector)
		{
			var
				x = this .x,
				y = this .y,
				z = this .z,
				w = this .w;

			for (var i = 0, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .min (x, vector .x);
				y = Math .min (y, vector .y);
				z = Math .min (z, vector .z);
				w = Math .min (w, vector .w);
			}

			this .x = x;
			this .y = y;
			this .z = z;
			this .w = w;
			return this;
		},
		max: function (vector)
		{
			var
				x = this .x,
				y = this .y,
				z = this .z,
				w = this .w;

			for (var i = 0, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .max (x, vector .x);
				y = Math .max (y, vector .y);
				z = Math .max (z, vector .z);
				w = Math .max (w, vector .w);
			}

			this .x = x;
			this .y = y;
			this .z = z;
			this .w = w;
			return this;
		},
		toString: function ()
		{
			return this .x + " " +
			       this .y + " " +
			       this .z + " " +
			       this .w;
		},
	};

	Object .defineProperty (Vector4 .prototype, "0",
	{
		get: function () { return this .x; },
		set: function (value) { this .x = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Vector4 .prototype, "1",
	{
		get: function () { return this .y; },
		set: function (value) { this .y = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Vector4 .prototype, "2",
	{
		get: function () { return this .z; },
		set: function (value) { this .z = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Vector4 .prototype, "3",
	{
		get: function () { return this .w; },
		set: function (value) { this .w = value; },
		enumerable: false,
		configurable: false
	});

	Object .assign (Vector4,
	{
		Zero: new Vector4 (0, 0, 0, 0),
		One: new Vector4 (1, 1, 1, 1),
		xAxis: new Vector4 (1, 0, 0, 0),
		yAxis: new Vector4 (0, 1, 0, 0),
		zAxis: new Vector4 (0, 0, 1, 0),
		wAxis: new Vector4 (0, 0, 0, 1),
		negate: function (vector)
		{
			var copy = Object .create (this .prototype);
			copy .x = -vector .x;
			copy .y = -vector .y;
			copy .z = -vector .z;
			copy .w = -vector .w;
			return copy;
		},
		add: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x + rhs .x;
			copy .y = lhs .y + rhs .y;
			copy .z = lhs .z + rhs .z;
			copy .w = lhs .w + rhs .w;
			return copy;
		},
		subtract: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x - rhs .x;
			copy .y = lhs .y - rhs .y;
			copy .z = lhs .z - rhs .z;
			copy .w = lhs .w - rhs .w;
			return copy;
		},
		multiply: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x * rhs;
			copy .y = lhs .y * rhs;
			copy .z = lhs .z * rhs;
			copy .w = lhs .w * rhs;
			return copy;
		},
		multVec: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x * rhs .x;
			copy .y = lhs .y * rhs .y;
			copy .z = lhs .z * rhs .z;
			copy .w = lhs .w * rhs .w;
			return copy;
		},
		divide: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x / rhs;
			copy .y = lhs .y / rhs;
			copy .z = lhs .z / rhs;
			copy .w = lhs .w / rhs;
			return copy;
		},
		divVec: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x / rhs .x;
			copy .y = lhs .y / rhs .y;
			copy .z = lhs .z / rhs .z;
			copy .w = lhs .w / rhs .w;
			return copy;
		},
		normalize: function (vector)
		{
			var
				copy   = Object .create (this .prototype),
				x      = vector .x,
				y      = vector .y,
				z      = vector .z,
				w      = vector .w,
				length = Math .sqrt (x * x + y * y + z * z + w * w);

			if (length)
			{
				copy .x = x / length;
				copy .y = y / length;
				copy .z = z / length;
				copy .w = w / length;
			}
			else
			{
				copy .x = 0;
				copy .y = 0;
				copy .z = 0;
				copy .w = 0;
			}

			return copy;
		},
		dot: function (lhs, rhs)
		{
			return lhs .dot (rhs);
		},
		lerp: function (source, dest, t)
		{
			var
				x = source .x,
				y = source .y,
				z = source .z,
				w = source .w;

			return new Vector4 (x + t * (dest .x - x),
			                    y + t * (dest .y - y),
			                    z + t * (dest .z - z),
			                    w + t * (dest .w - w));
		},
		min: function (lhs, rhs)
		{
			var
				x = lhs .x,
				y = lhs .y,
				z = lhs .z,
				w = lhs .w;

			for (var i = 1, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .min (x, vector .x);
				y = Math .min (y, vector .y);
				z = Math .min (z, vector .z);
				w = Math .min (w, vector .w);
			}

			return new Vector4 (x, y, z, w);
		},
		max: function (lhs, rhs)
		{
			var
				x = lhs .x,
				y = lhs .y,
				z = lhs .z,
				w = lhs .w;

			for (var i = 1, length = arguments .length; i < length; ++ i)
			{
				var vector = arguments [i];

				x = Math .max (x, vector .x);
				y = Math .max (y, vector .y);
				z = Math .max (z, vector .z);
				w = Math .max (w, vector .w);
			}

			return new Vector4 (x, y, z, w);
		},
	});

	return Vector4;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Quaternion',[
	"standard/Math/Numbers/Vector3",
	"standard/Math/Algorithm",
],
function (Vector3, Algorithm)
{
"use strict";

	function Quaternion (x, y, z, w)
	{
		this .x = x;
		this .y = y;
		this .z = z;
		this .w = w;
	}

	Quaternion .prototype =
	{
		constructor: Quaternion,
		length: 4,
		copy: function ()
		{
			var copy = Object .create (Quaternion .prototype);
			copy .x = this .x;
			copy .y = this .y;
			copy .z = this .z;
			copy .w = this .w;
			return copy;
		},
		assign: function (quat)
		{
			this .x = quat .x;
			this .y = quat .y;
			this .z = quat .z;
			this .w = quat .w;
			return this;
		},
		set: function (x, y, z, w)
		{
			this .x = x;
			this .y = y;
			this .z = z;
			this .w = w;
			return this;
		},
		setMatrix: function (matrix)
		{
			var i;

			// First, find largest diagonal in matrix:
			if (matrix [0] > matrix [4])
			{
				i = matrix [0] > matrix [8] ? 0 : 2;
			}
			else
			{
				i = matrix [4] > matrix [8] ? 1 : 2;
			}

			var scalerow = matrix [0] + matrix [4] + matrix [8];

			if (scalerow > matrix [i * 3 + i])
			{
				// Compute w first:
				this [3] = Math .sqrt (scalerow + 1) / 2;

				// And compute other values:
				var d = 4 * this [3];
				this [0] = (matrix [5] - matrix [7]) / d;
				this [1] = (matrix [6] - matrix [2]) / d;
				this [2] = (matrix [1] - matrix [3]) / d;
			}
			else
			{
				// Compute x, y, or z first:
				var j = (i + 1) % 3;
				var k = (i + 2) % 3;

				// Compute first value:
				this [i] = Math .sqrt (matrix [i * 3 + i] - matrix [j * 3 + j] - matrix [k * 3 + k] + 1) / 2;

				// And the others:
				var d = 4 * this [i];
				this [j] = (matrix [i * 3 + j] + matrix [j * 3 + i]) / d;
				this [k] = (matrix [i * 3 + k] + matrix [k * 3 + i]) / d;
				this [3] = (matrix [j * 3 + k] - matrix [k * 3 + j]) / d;
			}

			return this;
		},
		getMatrix: function (matrix)
		{
			var
				x = this .x,
				y = this .y,
				z = this .z,
				w = this .w;

			var
				a = x * x,
				b = x * y,
				c = y * y,
				d = y * z,
				e = z * x,
				f = z * z,
				g = w * x,
				h = w * y,
				i = w * z;
		
			matrix [0] = 1 - 2 * (c + f);
			matrix [1] =     2 * (b + i);
			matrix [2] =     2 * (e - h);

			matrix [3] =     2 * (b - i);
			matrix [4] = 1 - 2 * (f + a);
			matrix [5] =     2 * (d + g);

			matrix [6] =     2 * (e + h);
			matrix [7] =     2 * (d - g);
			matrix [8] = 1 - 2 * (c + a);

			return matrix;
		},
		isReal: function ()
		{
			return ! (this .x || this .y || this .z);
		},
		isImag: function ()
		{
			return ! this .w;
		},
		equals: function (quat)
		{
			return this .x === quat .x &&
			       this .y === quat .y &&
			       this .z === quat .z &&
			       this .w === quat .w;
		},
		negate: function ()
		{
			this .x = -this .x;
			this .y = -this .y;
			this .z = -this .z;
			this .w = -this .w;
			return this;
		},
		inverse: function ()
		{
			this .x = -this .x;
			this .y = -this .y;
			this .z = -this .z;
			return this;
		},
		add: function (quat)
		{
			this .x += quat .x;
			this .y += quat .y;
			this .z += quat .z;
			this .w += quat .w;
			return this;
		},
		subtract: function (quat)
		{
			this .x -= quat .x;
			this .y -= quat .y;
			this .z -= quat .z;
			this .w -= quat .w;
			return this;
		},
		multiply: function (value)
		{
			this .x *= value;
			this .y *= value;
			this .z *= value;
			this .w *= value;
			return this;
		},
		multLeft: function (quat)
		{
			var
				ax = this .x, ay = this .y, az = this .z, aw = this .w,
				bx = quat .x, by = quat .y, bz = quat .z, bw = quat .w;

			this .x = aw * bx + ax * bw + ay * bz - az * by;
			this .y = aw * by + ay * bw + az * bx - ax * bz;
			this .z = aw * bz + az * bw + ax * by - ay * bx;
			this .w = aw * bw - ax * bx - ay * by - az * bz;

			return this;
		},
		multRight: function (quat)
		{
			var
				ax = this .x, ay = this .y, az = this .z, aw = this .w,
				bx = quat .x, by = quat .y, bz = quat .z, bw = quat .w;

			this .x = bw * ax + bx * aw + by * az - bz * ay;
			this .y = bw * ay + by * aw + bz * ax - bx * az;
			this .z = bw * az + bz * aw + bx * ay - by * ax;
			this .w = bw * aw - bx * ax - by * ay - bz * az;

			return this;
		},
		divide: function (value)
		{
			this .x /= value;
			this .y /= value;
			this .z /= value;
			this .w /= value;
			return this;
		},
		multVecQuat: function (vector)
		{
			var
				qx = this .x, qy = this .y, qz = this .z, qw = this .w,
				vx = vector .x, vy = vector .y, vz = vector .z,
				a  = qw * qw - qx * qx - qy * qy - qz * qz,                   
				b  = 2 * (vx * qx + vy * qy + vz * qz), 
				c  = 2 * qw;                                       

			vector .x = a * vx + b * qx + c * (qy * vz - qz * vy);
			vector .y = a * vy + b * qy + c * (qz * vx - qx * vz);
			vector .z = a * vz + b * qz + c * (qx * vy - qy * vx);
			
			return vector;
		},
		multQuatVec: function (vector)
		{
			var
				qx = this .x, qy = this .y, qz = this .z, qw = this .w,
				vx = vector .x, vy = vector .y, vz = vector .z,
				a  = qw * qw - qx * qx - qy * qy - qz * qz,                    
				b  = 2 * (vx * qx + vy * qy + vz * qz), 
				c  = 2 * qw;                                       

			vector .x = a * vx + b * qx - c * (qy * vz - qz * vy);
			vector .y = a * vy + b * qy - c * (qz * vx - qx * vz);
			vector .z = a * vz + b * qz - c * (qx * vy - qy * vx);

			return vector;
		},
		normalize: function ()
		{
			var length = Math .sqrt (this .x * this .x +
			                         this .y * this .y +
			                         this .z * this .z +
			                         this .w * this .w);
			
			if (length)
			{
				length = 1 / length;

				this .x *= length;
				this .y *= length;
				this .z *= length;
				this .w *= length;
			}

			return this;
		},
		dot: function (quat)
		{
			return this .x * quat .x +
			       this .y * quat .y +
			       this .z * quat .z +
			       this .w * quat .w;
		},
		norm: function ()
		{
			return this .x * this .x +
			       this .y * this .y +
			       this .z * this .z +
			       this .w * this .w;
		},
		abs: function ()
		{
			return Math .sqrt (this .x * this .x +
			                   this .y * this .y +
			                   this .z * this .z +
			                   this .w * this .w);
		},
		pow: function (exponent)
		{
			if (exponent instanceof Quaternion)
				return this .assign (e .assign (exponent) .multRight (this .log ()) .exp ());

			if (this .isReal ())
				return this .set (0, 0, 0, Math .pow (this .w, exponent));

			var
				l     = this .abs (),
				theta = Math .acos (this .w / l),
				li    = this .imag .abs (),
				ltoe  = Math .pow (l, exponent),
				et    = exponent * theta,
				scale = ltoe / li * Math .sin (et);

			this .x *= scale;
			this .y *= scale;
			this .z *= scale;
			this .w  = ltoe * Math .cos (et);
			return this;
		},
		log: function ()
		{
			if (this .isReal ())
			{
				if (this .w > 0)
					return this .set (0, 0, 0, Math .log (this .w));

				else
					return this .set (Math .PI, 0, 0, Math .log (-this .w));
			}

			var
				l = this .abs (),
				v = this .imag .normalize () .multiply (Math .acos (this .w / l)),
				w = Math .log (l);

			this .x = v .x;
			this .y = v .y;
			this .z = v .z;
			this .w = w;
			return this;
		},
		exp: function ()
		{	
			if (this .isReal ())
				return this .set (0, 0, 0, Math .exp (this .w));

			var
				i  = this .imag,
				li = i .abs (),
				ew = Math .exp (this .w),
				w  = ew * Math .cos (li),
				v  = i .multiply (ew * Math .sin (li) / li);

			this .x = v .x;
			this .y = v .y;
			this .z = v .z;
			this .w = w;
			return this;
		},
		slerp: function (dest, t)
		{
			return Algorithm .slerp (this, t1 .assign (dest), t);
		},
		squad: function (a, b, destination, t)
		{
			// We must use shortest path slerp to prevent flipping.  Also see spline.

			return Algorithm .slerp (Algorithm .slerp (this, t1 .assign (destination), t),
                                  Algorithm .slerp (t2 .assign (a), t3 .assign (b), t),
                                  2 * t * (1 - t));
		},
		toString: function ()
		{
			return this .x + " " +
			       this .y + " " +
			       this .z + " " +
			       this .w;
		},
	};

	Object .defineProperty (Quaternion .prototype, "0",
	{
		get: function () { return this .x; },
		set: function (value) { this .x = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Quaternion .prototype, "1",
	{
		get: function () { return this .y; },
		set: function (value) { this .y = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Quaternion .prototype, "2",
	{
		get: function () { return this .z; },
		set: function (value) { this .z = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Quaternion .prototype, "3",
	{
		get: function () { return this .w; },
		set: function (value) { this .w = value; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Quaternion .prototype, "real",
	{
		get: function () { return this .w; },
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Quaternion .prototype, "imag",
	{
		get: (function ()
		{
			var result = new Vector3 (0, 0, 0);

			return function ()
			{
				return result .set (this .x,
				                    this .y,
				                    this .z);
			};
		})(),
		enumerable: false,
		configurable: false
	});

	Object .assign (Quaternion,
	{
		negate: function (vector)
		{
			var copy = Object .create (this .prototype);
			copy .x = -this .x;
			copy .y = -this .y;
			copy .z = -this .z;
			copy .w = -this .w;
			return copy;
		},
		inverse: function (vector)
		{
			var copy = Object .create (this .prototype);
			copy .x = -vector .x;
			copy .y = -vector .y;
			copy .z = -vector .z;
			copy .w =  vector .w;
			return copy;
		},
		add: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x + rhs .x;
			copy .y = lhs .y + rhs .y;
			copy .z = lhs .z + rhs .z;
			copy .w = lhs .w + rhs .w;
			return copy;
		},
		subtract: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x - rhs .x;
			copy .y = lhs .y - rhs .y;
			copy .z = lhs .z - rhs .z;
			copy .w = lhs .w - rhs .w;
			return copy;
		},
		multiply: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x * rhs;
			copy .y = lhs .y * rhs;
			copy .z = lhs .z * rhs;
			copy .w = lhs .w * rhs;
			return copy;
		},
		multLeft: function (lhs, rhs)
		{
			var
				copy = Object .create (this .prototype),
				ax = lhs .x, ay = lhs .y, az = lhs .z, aw = lhs .w,
				bx = rhs .x, by = rhs .y, bz = rhs .z, bw = rhs .w;

			copy .x = aw * bx + ax * bw + ay * bz - az * by;
			copy .y = aw * by + ay * bw + az * bx - ax * bz;
			copy .z = aw * bz + az * bw + ax * by - ay * bx;
			copy .w = aw * bw - ax * bx - ay * by - az * bz;

			return copy;
		},
		multRight: function (lhs, rhs)
		{
			var
				copy = Object .create (this .prototype),
				ax = lhs .x, ay = lhs .y, az = lhs .z, aw = lhs .w,
				bx = rhs .x, by = rhs .y, bz = rhs .z, bw = rhs .w;

			copy .x = bw * ax + bx * aw + by * az - bz * ay;
			copy .y = bw * ay + by * aw + bz * ax - bx * az;
			copy .z = bw * az + bz * aw + bx * ay - by * ax;
			copy .w = bw * aw - bx * ax - by * ay - bz * az;

			return copy;
		},
		divide: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .x = lhs .x / rhs;
			copy .y = lhs .y / rhs;
			copy .z = lhs .z / rhs;
			copy .w = lhs .w / rhs;
			return copy;
		},
		normalize: function (quat)
		{
			var
				copy   = Object .create (this .prototype),
				x      = quat .x,
				y      = quat .y,
				z      = quat .z,
				w      = quat .w,
				length = Math .sqrt (x * x + y * y + z * z + w * w);

			if (length)
			{
				length = 1 / length;

				copy .x = x * length;
				copy .y = y * length;
				copy .z = z * length;
				copy .w = w * length;
			}
			else
			{
				copy .x = 0;
				copy .y = 0;
				copy .z = 0;
				copy .w = 0;
			}

			return copy;
		},
		slerp: function (source, dest, t)
		{
			return Algorithm .slerp (source .copy (), t2 .assign (dest), t);
		},
		squad: function (source, a, b, destination, t)
		{
			// We must use shortest path slerp to prevent flipping.  Also see spline.

			return Algorithm .slerp (Algorithm .slerp (source .copy (), t1 .assign (destination), t),
                                  Algorithm .slerp (t2 .assign (a), t3 .assign (b), t),
                                  2 * t * (1 - t));
		},
		/*
		bezier: function (q0, a, b, q1, t)
		{
			var q11 = Algorithm .slerp (q0,  a, t);
			var q12 = Algorithm .slerp ( a,  b, t);
			var q13 = Algorithm .slerp ( b, q1, t);

			return Algorithm .slerp (Algorithm .slerp (q11, q12, t), Algorithm .slerp (q12, q13, t), t);
		},
		*/
		spline: function (Q0, Q1, Q2)
		{
			q0 .assign (Q0);
			q1 .assign (Q1);
			q2 .assign (Q2);

			// If the dot product is smaller than 0 we must negate the quaternion to prevent flipping. If we negate all
			// the terms we get a different quaternion but it represents the same rotation.

			if (q0 .dot (q1) < 0)
				q0 .negate ();

			if (q2 .dot (q1) < 0)
				q2 .negate ();

			q1_i .assign (q1) .inverse ();

			// The result must be normalized as it will be used in slerp and we can only slerp normalized vectors.

			return q1 .multRight (
				t1 .assign (q1_i) .multRight (q0) .log () .add (t2 .assign (q1_i) .multRight (q2) .log ()) .divide (-4) .exp ()
			)
			.normalize () .copy ();
		},
	});

	var
		t1 = new Quaternion (0, 0, 0, 1),
		t2 = new Quaternion (0, 0, 0, 1),
		t3 = new Quaternion (0, 0, 0, 1);
	
	var
		q0   = new Quaternion (0, 0, 0, 1),
		q1   = new Quaternion (0, 0, 0, 1),
		q2   = new Quaternion (0, 0, 0, 1),
		q1_i = new Quaternion (0, 0, 0, 1);

	return Quaternion;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Rotation4',[
	"standard/Math/Numbers/Quaternion",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Algorithm",
],
function (Quaternion,
          Vector3,
          Vector4,
          Algorithm)
{
"use strict";

	function Rotation4 (x, y, z, angle)
	{
		this .x_     = 0;
		this .y_     = 0;
		this .z_     = 1;
		this .angle_ = 0;

		switch (arguments .length)
		{
			case 0:
			{
				this .value = new Quaternion (0, 0, 0, 1);
				return;
			}
			case 1:
			{
				this .value = arguments [0];
				this .update ();
				return;
			}
			case 2:
			{
				var
					arg0 = arguments [0],
					arg1 = arguments [1];

				this .value = new Quaternion (0, 0, 0, 1);

				if (arg1 instanceof Vector3)
				   return this .setFromToVec (arg0, arg1);

				this .set (arg0 .x,
				           arg0 .y,
				           arg0 .z,
				           arg1);

			   return;
			}
			case 4:
			{
				this .value = new Quaternion (0, 0, 0, 1);
				this .set (x, y, z, angle);
				return;
			}
		}
	}

	Rotation4 .prototype =
	{
		constructor: Rotation4,
		length: 4,
		update: function ()
		{
			var rotation = this .get ();

			this .x_     = rotation .x;
			this .y_     = rotation .y;
			this .z_     = rotation .z;
			this .angle_ = rotation .w;

			return this;
		},
		copy: function ()
		{
			var copy = Object .create (Rotation4 .prototype);

			copy .x_     = this .x_;
			copy .y_     = this .y_;
			copy .z_     = this .z_;
			copy .angle_ = this .angle_;

			copy .value  = this .value .copy ();

			return copy;
		},
		assign: function (rotation)
		{
			this .x_     = rotation .x_;
			this .y_     = rotation .y_;
			this .z_     = rotation .z_;
			this .angle_ = rotation .angle_;

			this .value .assign (rotation .value);

			return this;
		},
		set: function (x, y, z, angle)
		{
			this .x_     = x;
			this .y_     = y;
			this .z_     = z;
			this .angle_ = angle;

			var scale = Math .sqrt (x * x + y * y + z * z);

			if (scale === 0)
			{
				this .value .set (0, 0, 0, 1);
				return this;
			}

			// Calculate quaternion

			var
				halfTheta = Algorithm .interval (angle / 2, 0, Math .PI),
				scale     = Math .sin (halfTheta) / scale;

			this .value .set (x * scale,
			                  y * scale,
			                  z * scale,
			                  Math .cos (halfTheta));
			return this;
		},
		get: (function ()
		{
			var result = new Vector4 (0, 0, 0, 0);

			return function ()
			{
				var value = this .value;

				if (Math .abs (value .w) > 1)
				{
					return Vector4 .zAxis;
				}
				else
				{
					var
						angle = Math .acos (value .w) * 2,
						scale = Math .sin (angle / 2);

					if (scale === 0)
					{
						return Vector4 .zAxis;
					}
					else
					{
						var axis = value .imag .divide (scale);

						return result .set (axis .x,
						                    axis .y,
						                    axis .z,
						                    angle);
					}
				}
			};
		})(),
		setAxisAngle: function (axis, angle)
		{
			return this .set (axis .x, axis .y, axis .z, angle);
		},
		setFromToVec: (function ()
		{
			var
				from = new Vector3 (0, 0, 0),
				to   = new Vector3 (0, 0, 0),
				cv   = new Vector3 (0, 0, 0),
				t    = new Vector3 (0, 0, 0);

			return function (fromVec, toVec)
			{
				// https://bitbucket.org/Coin3D/coin/src/abc9f50968c9/src/base/SbRotation.cpp

				from .assign (fromVec) .normalize ();
				to   .assign (toVec)   .normalize ();

				var
					cos_angle = Algorithm .clamp (from .dot (to), -1, 1),
					crossvec  = cv .assign (from) .cross (to) .normalize (),
					crosslen  = crossvec .abs ();

				if (crosslen === 0)
				{
					// Parallel vectors
					// Check if they are pointing in the same direction.
					if (cos_angle > 0)
						this .value .set (0, 0, 0, 1); // standard rotation

					// Ok, so they are parallel and pointing in the opposite direction
					// of each other.
					else
					{
						// Try crossing with x axis.
						t .assign (from) .cross (Vector3 .xAxis);

						// If not ok, cross with y axis.
						if (t .norm () === 0)
							t .assign (from) .cross (Vector3 .yAxis);

						t .normalize ();

						this .value .set (t .x, t .y, t .z, 0);
					}
				}
				else
				{
					// Vectors are not parallel
					// The abs () wrapping is to avoid problems when `dot' "overflows" a tiny wee bit,
					// which can lead to sqrt () returning NaN.
					crossvec .multiply (Math .sqrt (Math .abs (1 - cos_angle) / 2));

					this .value .set (crossvec .x,
					                  crossvec .y,
					                  crossvec .z,
					                  Math .sqrt (Math .abs (1 + cos_angle) / 2));
				}

				this .update ();

				return this;
			};
		})(),
		setAxis: function (vector)
		{
			this .set (vector .x, vector .y, vector .z, this .angle_);
		},
		getAxis: (function ()
		{
			var axis = new Vector3 (0, 0, 0);

			return function ()
			{
				return axis .set (this .x_, this .y_, this .z_);
			};
		})(),
		setMatrix: function (matrix)
		{
			this .value .setMatrix (matrix) .normalize ();
			this .update ();
			return this;
		},
		getMatrix: function (matrix)
		{
			return this .value .getMatrix (matrix);
		},
		equals: function (rot)
		{
			return this .value .equals (rot .value);
		},
		inverse: function ()
		{
			this .value .inverse ();
			this .update ();
			return this;
		},
		multLeft: function (rotation)
		{
			this .value .multLeft (rotation .value) .normalize ();
			this .update ();
			return this;
		},
		multRight: function (rotation)
		{
			this .value .multRight (rotation .value) .normalize ();
			this .update ();
			return this;
		},
		multVecRot: function (vector)
		{
			return this .value .multVecQuat (vector);
		},
		multRotVec: function (vector)
		{
			return this .value .multQuatVec (vector);
		},
		normalize: function ()
		{
			this .value .normalize ();
			this .update ();
			return this;
		},
		pow: function (exponent)
		{
			this .value .pow (exponent);
			this .update ();
			return this;
		},
		slerp: function (dest, t)
		{
			this .value .slerp (dest .value, t);
			this .update ();
			return this;
		},
		squad: function (a ,b, dest, t)
		{
			this .value .squad (a .value, b .value, dest .value, t);
			this .update ();
			return this;
		},
		toString: function ()
		{
			return this .x_ + " " +
			       this .y_ + " " +
			       this .z_ + " " +
			       this .angle_;
		}
	};

	var x = {
		get: function ()
		{
			return this .x_;
		},
		set: function (value)
		{
			this .x_ = value;
			this .set (value, this .y_, this .z_, this .angle_);
		},
		enumerable: true,
		configurable: false
	};

	var y = {
		get: function ()
		{
			return this .y_;
		},
		set: function (value)
		{
			this .y_ = value;
			this .set (this .x_, value, this .z_, this .angle_);
		},
		enumerable: true,
		configurable: false
	};

	var z = {
		get: function ()
		{
			return this .z_;
		},
		set: function (value)
		{
			this .z_ = value;
			this .set (this .x_, this .y_, value, this .angle_);
		},
		enumerable: true,
		configurable: false
	};

	var angle = {
		get: function ()
		{
			return this .angle_;
		},
		set: function (value)
		{
			this .angle_ = value;
			this .set (this .x_, this .y_, this .z_, value);
		},
		enumerable: true,
		configurable: false
	};

	Object .defineProperty (Rotation4 .prototype, "x", x);
	Object .defineProperty (Rotation4 .prototype, "y", y);
	Object .defineProperty (Rotation4 .prototype, "z", z);
	Object .defineProperty (Rotation4 .prototype, "angle", angle);

	x     .enumerable = false;
	y     .enumerable = false;
	z     .enumerable = false;
	angle .enumerable = false;

	Object .defineProperty (Rotation4 .prototype, "0", x);
	Object .defineProperty (Rotation4 .prototype, "1", y);
	Object .defineProperty (Rotation4 .prototype, "2", z);
	Object .defineProperty (Rotation4 .prototype, "3", angle);

	Object .assign (Rotation4,
	{
		Identity: new Rotation4 (),
		inverse: function (rotation)
		{
			var copy = Object .create (this .prototype);
			copy .value = Quaternion .inverse (rotation .value);
			copy .update ();
			return copy;
		},
		multRight: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .value = Quaternion .multRight (lhs .value, rhs .value);
			copy .update ();
			return copy;
		},
		normalize: function ()
		{
			var copy = Object .create (this .prototype);
			copy .value = rotation .value .copy ();
			copy .update ();
			return copy;
		},
		slerp: function (source, destination, t)
		{
			var copy = Object .create (this .prototype);
			copy .value = Quaternion .slerp (source .value, destination .value, t);
			copy .update ();
			return copy;
		},
		squad: function (source, a, b, destination, t)
		{
			var copy = Object .create (this .prototype);
			copy .value = Quaternion .squad (source .value, a, b, destination .value, t);
			copy .update ();
			return copy;
		},
		bezier: function (source, a, b, destination, t)
		{
			var copy = Object .create (this .prototype);
			copy .value = Quaternion .bezier (source .value, a, b, destination .value, t);
			copy .update ();
			return copy;
		},
		spline: function (q0, q1, q2)
		{
			var copy = Object .create (this .prototype);
			copy .value = Quaternion .spline (q0 .value, q1 .value, q2 .value);
			copy .update ();
			return copy;
		},
	});

	return Rotation4;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Matrix4',[
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix3",
	"standard/Math/Algorithms/eigendecomposition",
],
function (Vector3,
          Vector4,
          Rotation4,
          Matrix3,
          eigendecomposition)
{
"use strict";

	function Matrix4 ()
	{
		if (arguments .length)
		{
			this [ 0] = arguments [ 0];
			this [ 1] = arguments [ 1];
			this [ 2] = arguments [ 2];
			this [ 3] = arguments [ 3];
			this [ 4] = arguments [ 4];
			this [ 5] = arguments [ 5];
			this [ 6] = arguments [ 6];
			this [ 7] = arguments [ 7];
			this [ 8] = arguments [ 8];
			this [ 9] = arguments [ 9];
			this [10] = arguments [10];
			this [11] = arguments [11];
			this [12] = arguments [12];
			this [13] = arguments [13];
			this [14] = arguments [14];
			this [15] = arguments [15];
		}
		else
		{
			this .identity ();
		}
	}

	Matrix4 .prototype =
	{
		constructor: Matrix4,
		order: 4,
		length: 16,
		copy: function ()
		{
			var copy = Object .create (Matrix4 .prototype);
			copy [ 0] = this [ 0];
			copy [ 1] = this [ 1];
			copy [ 2] = this [ 2];
			copy [ 3] = this [ 3];
			copy [ 4] = this [ 4];
			copy [ 5] = this [ 5];
			copy [ 6] = this [ 6];
			copy [ 7] = this [ 7];
			copy [ 8] = this [ 8];
			copy [ 9] = this [ 9];
			copy [10] = this [10];
			copy [11] = this [11];
			copy [12] = this [12];
			copy [13] = this [13];
			copy [14] = this [14];
			copy [15] = this [15];
			return copy;
		},
		assign: function (matrix)
		{
			this [ 0] = matrix [ 0];
			this [ 1] = matrix [ 1];
			this [ 2] = matrix [ 2];
			this [ 3] = matrix [ 3];
			this [ 4] = matrix [ 4];
			this [ 5] = matrix [ 5];
			this [ 6] = matrix [ 6];
			this [ 7] = matrix [ 7];
			this [ 8] = matrix [ 8];
			this [ 9] = matrix [ 9];
			this [10] = matrix [10];
			this [11] = matrix [11];
			this [12] = matrix [12];
			this [13] = matrix [13];
			this [14] = matrix [14];
			this [15] = matrix [15];
			return this;
		},
		equals: function (matrix)
		{
			return this [ 0] === matrix [ 0] &&
			       this [ 1] === matrix [ 1] &&
			       this [ 2] === matrix [ 2] &&
			       this [ 3] === matrix [ 3] &&
			       this [ 4] === matrix [ 4] &&
			       this [ 5] === matrix [ 5] &&
			       this [ 6] === matrix [ 6] &&
			       this [ 7] === matrix [ 7] &&
			       this [ 8] === matrix [ 8] &&
			       this [ 9] === matrix [ 9] &&
			       this [10] === matrix [10] &&
			       this [11] === matrix [11] &&
			       this [12] === matrix [12] &&
			       this [13] === matrix [13] &&
			       this [14] === matrix [14] &&
			       this [15] === matrix [15];
		},
		set1: function (r, c, value)
		{
			this [r * this .order + c] = value;

			return this;
		},
		get1: function (r, c)
		{
			return this [r * this .order + c];
		},
		set: function (translation, rotation, scale, scaleOrientation, center)
		{
			switch (arguments .length)
			{
				case 0:
				{
					this .identity ();
					break;
				}
				case 1:
				{
					if (translation === null) translation = Vector3 .Zero;

					this .identity ();
					this .translate (translation);
					break;
				}
				case 2:
				{
					if (translation === null) translation = Vector3 .Zero;
					if (rotation    === null) rotation    = Rotation4 .Identity;

					this .identity ();
					this .translate (translation);

					if (! rotation .equals (Rotation4 .Identity))
						this .rotate (rotation);

					break;
				}
				case 3:
				{
					if (translation === null) translation = Vector3 .Zero;
					if (rotation    === null) rotation    = Rotation4 .Identity;
					if (scale       === null) scale       = Vector3 .One;

					this .identity ();
					this .translate (translation);

					if (! rotation .equals (Rotation4 .Identity))
						this .rotate (rotation);

					if (! scale .equals (Vector3 .One))
						this .scale  (scale);

					break;
				}
				case 4:
				{
					if (translation      === null) translation      = Vector3 .Zero;
					if (rotation         === null) rotation         = Rotation4 .Identity;
					if (scale            === null) scale            = Vector3 .One;
					if (scaleOrientation === null) scaleOrientation = Rotation4 .Identity;

					this .identity ();
					this .translate (translation);

					if (! rotation .equals (Rotation4 .Identity))
						this .rotate (rotation);

					if (! scale .equals (Vector3 .One))
					{
						var hasScaleOrientation = ! scaleOrientation .equals (Rotation4 .Identity);

						if (hasScaleOrientation)
						{
							this .rotate (scaleOrientation);
							this .scale (scale);
							this .rotate (Rotation4 .inverse (scaleOrientation));
						}
						else
							this .scale (scale);
					}

					break;
				}
				case 5:
				{
					if (translation      === null) translation      = Vector3 .Zero;
					if (rotation         === null) rotation         = Rotation4 .Identity;
					if (scale            === null) scale            = Vector3 .One;
					if (scaleOrientation === null) scaleOrientation = Rotation4 .Identity;
					if (center           === null) center           = Vector3 .Zero;

					// P' = T * C * R * SR * S * -SR * -C * P
					this .identity ();
					this .translate (translation);

					var hasCenter = ! center .equals (Vector3 .Zero);

					if (hasCenter)
						this .translate (center);

					if (! rotation .equals (Rotation4 .Identity))
						this .rotate (rotation);

					if (! scale .equals (Vector3 .One))
					{
						if (! scaleOrientation .equals (Rotation4 .Identity))
						{
							this .rotate (scaleOrientation);
							this .scale (scale);
							this .rotate (Rotation4 .inverse (scaleOrientation));
						}
						else
							this .scale (scale);
					}

					if (hasCenter)
						this .translate (Vector3 .negate (center));

					break;
				}
				case 16:
				{
					this [ 0] = arguments [ 0];
					this [ 1] = arguments [ 1];
					this [ 2] = arguments [ 2];
					this [ 3] = arguments [ 3];
					this [ 4] = arguments [ 4];
					this [ 5] = arguments [ 5];
					this [ 6] = arguments [ 6];
					this [ 7] = arguments [ 7];
					this [ 8] = arguments [ 8];
					this [ 9] = arguments [ 9];
					this [10] = arguments [10];
					this [11] = arguments [11];
					this [12] = arguments [12];
					this [13] = arguments [13];
					this [14] = arguments [14];
					this [15] = arguments [15];
					break;
				}
			}

			return this;
		},
		get: (function ()
		{
			var
				dummyTranslation      = new Vector3 (0, 0, 0),
				dummyRotation         = new Rotation4 (),
				dummyScale            = new Vector3 (0, 0, 0),
				dummyScaleOrientation = new Rotation4 (),
				dummyCenter           = new Vector3 (0, 0, 0),
				rot                   = new Matrix3 (),
				so                    = new Matrix3 (),
				c                     = new Vector3 (0, 0, 0);

			return function (translation, rotation, scale, scaleOrientation, center)
			{
				if (translation      === null) translation      = dummyTranslation;
				if (rotation         === null) rotation         = dummyRotation;
				if (scale            === null) scale            = dummyScale;
				if (scaleOrientation === null) scaleOrientation = dummyScaleOrientation;
				if (center           === null) center           = dummyCenter;

				switch (arguments .length)
				{
					case 1:
					{
						translation .set (this [12], this [13], this [14]);
						break;
					}
					case 2:
					{
						this .factor (translation, rot, dummyScale, so);
						rotation .setMatrix (rot);
						break;
					}
					case 3:
					{
						this .factor (translation, rot, scale, so);
						rotation .setMatrix (rot);
						break;
					}
					case 4:
					{
						this .factor (translation, rot, scale, so);
						rotation         .setMatrix (rot);
						scaleOrientation .setMatrix (so);
						break;
					}
					case 5:
					{
						var m = new Matrix4 ();

						m .set (c .assign (center) .negate ());
						m .multLeft (this);
						m .translate (center);

						m .get (translation, rotation, scale, scaleOrientation);
						break;
					}
				}
			};
		})(),
		setRotation: function (rotation)
		{
			return this .setQuaternion (rotation .value);
		},
		setQuaternion: function (quaternion)
		{
			var
				x = quaternion .x,
				y = quaternion .y,
				z = quaternion .z,
				w = quaternion .w,
				A = y * y,
				B = z * z,
				C = x * y,
				D = z * w,
				E = z * x,
				F = y * w,
				G = x * x,
				H = y * z,
				I = x * w;

			this [0]  = 1 - 2 * (A + B);
			this [1]  = 2 * (C + D);
			this [2]  = 2 * (E - F);
			this [3]  = 0;
			this [4]  = 2 * (C - D);
			this [5]  = 1 - 2 * (B + G);
			this [6]  = 2 * (H + I);
			this [7]  = 0;
			this [8]  = 2 * (E + F);
			this [9]  = 2 * (H - I);
			this [10] = 1 - 2 * (A + G);
			this [11] = 0;
			this [12] = 0;
			this [13] = 0;
			this [14] = 0;
			this [15] = 1;

			return this;
		},
		factor: (function ()
		{
			var
				si   = new Matrix3 (),
				sosi = new Matrix3 (),
				b    = new Matrix3 ();

			var eigen = { values: [ ], vectors: [[ ], [ ], [ ]] };

			return function (translation, rotation, scale, scaleOrientation)
			{
				// (1) Get translation.
				translation .set (this [12], this [13], this [14]);

				// (2) Create 3x3 matrix.
				var a = this .submatrix;

				// (3) Compute det A. If negative, set sign = -1, else sign = 1
				var det      = a .determinant ();
				var det_sign = det < 0 ? -1 : 1;

				if (det === 0)
					throw new Error ("Matrix4 .factor: determinant is 0.");

				// (4) B = A * !A  (here !A means A transpose)
				b .assign (a) .transpose () .multLeft (a);
				var e = eigendecomposition (b, eigen);

				// Find min / max eigenvalues and do ratio test to determine singularity.

				scaleOrientation .set (e .vectors [0] [0], e .vectors [0] [1], e .vectors [0] [2],
				                       e .vectors [1] [0], e .vectors [1] [1], e .vectors [1] [2],
				                       e .vectors [2] [0], e .vectors [2] [1], e .vectors [2] [2]);

				// Compute s = sqrt(evalues), with sign. Set si = s-inverse

				scale .x = det_sign * Math .sqrt (e .values [0]);
				scale .y = det_sign * Math .sqrt (e .values [1]);
				scale .z = det_sign * Math .sqrt (e .values [2]);

				si [0] = 1 / scale .x;
				si [4] = 1 / scale .y;
				si [8] = 1 / scale .z;

				// (5) Compute U = !R ~S R A.
				rotation .assign (sosi .assign (scaleOrientation) .multRight (si) .transpose () .multLeft (scaleOrientation) .multRight (a));

				scaleOrientation .transpose ();
				return true;
			};
		})(),
		determinant3: function ()
		{
			var
				m00 = this [0], m01 = this [1], m02 = this [ 2],
				m04 = this [4], m05 = this [5], m06 = this [ 6],
				m08 = this [8], m09 = this [9], m10 = this [10];

			return m00 * (m05 * m10 - m06 * m09) -
			       m01 * (m04 * m10 - m06 * m08) +
			       m02 * (m04 * m09 - m05 * m08);
		},
		determinant: function ()
		{
			var
				m00 = this [ 0],
				m01 = this [ 1],
				m02 = this [ 2],
				m03 = this [ 3],
				m04 = this [ 4],
				m05 = this [ 5],
				m06 = this [ 6],
				m07 = this [ 7],
				m08 = this [ 8],
				m09 = this [ 9],
				m10 = this [10],
				m11 = this [11],
				m12 = this [12],
				m13 = this [13],
				m14 = this [14],
				m15 = this [15],
				b = m10 * m15,
				c = m14 * m11,
				d = m06 * m15,
				e = m14 * m07,
				f = m06 * m11,
				g = m10 * m07,
				h = m02 * m15,
				i = m14 * m03,
				j = m02 * m11,
				o = m10 * m03,
				r = m02 * m07,
				x = m06 * m03,
				H = b * m05 + e * m09 + f * m13 - (c * m05) - (d * m09) - (g * m13),
				I = c * m01 + h * m09 + o * m13 - (b * m01) - (i * m09) - (j * m13),
				J = d * m01 + i * m05 + r * m13 - (e * m01) - (h * m05) - (x * m13),
				K = g * m01 + j * m05 + x * m09 - (f * m01) - (o * m05) - (r * m09);

			return m00 * H + m04 * I + m08 * J + m12 * K;
		},
		transpose: function ()
		{
			var tmp;

			tmp = this [ 1]; this [ 1] = this [ 4]; this [ 4] = tmp;
			tmp = this [ 2]; this [ 2] = this [ 8]; this [ 8] = tmp;
			tmp = this [ 3]; this [ 3] = this [12]; this [12] = tmp;
			tmp = this [ 6]; this [ 6] = this [ 9]; this [ 9] = tmp;
			tmp = this [ 7]; this [ 7] = this [13]; this [13] = tmp;
			tmp = this [11]; this [11] = this [14]; this [14] = tmp;

			return this;
		},
		inverse: function ()
		{
			var
				m00 = this [ 0],
				m01 = this [ 1],
				m02 = this [ 2],
				m03 = this [ 3],
				m04 = this [ 4],
				m05 = this [ 5],
				m06 = this [ 6],
				m07 = this [ 7],
				m08 = this [ 8],
				m09 = this [ 9],
				m10 = this [10],
				m11 = this [11],
				m12 = this [12],
				m13 = this [13],
				m14 = this [14],
				m15 = this [15],
				b = m10 * m15,
				c = m14 * m11,
				d = m06 * m15,
				e = m14 * m07,
				f = m06 * m11,
				g = m10 * m07,
				h = m02 * m15,
				i = m14 * m03,
				j = m02 * m11,
				o = m10 * m03,
				r = m02 * m07,
				x = m06 * m03,
				t = m08 * m13,
				p = m12 * m09,
				v = m04 * m13,
				s = m12 * m05,
				y = m04 * m09,
				z = m08 * m05,
				A = m00 * m13,
				C = m12 * m01,
				D = m00 * m09,
				E = m08 * m01,
				F = m00 * m05,
				G = m04 * m01,
				H = b * m05 + e * m09 + f * m13 - ((c * m05) + (d * m09) + (g * m13)),
				I = c * m01 + h * m09 + o * m13 - ((b * m01) + (i * m09) + (j * m13)),
				J = d * m01 + i * m05 + r * m13 - ((e * m01) + (h * m05) + (x * m13)),
				K = g * m01 + j * m05 + x * m09 - ((f * m01) + (o * m05) + (r * m09)),
				B = m00 * H + m04 * I + m08 * J + m12 * K;

			if (B === 0)
				throw new Error ("Matrix4 .inverse: determinant is 0.");

			B = 1 / B;

			this [ 0] = B * H;
			this [ 1] = B * I;
			this [ 2] = B * J;
			this [ 3] = B * K;
			this [ 4] = B * (c * m04 + d * m08 + g * m12 - (b * m04) - (e * m08) - (f * m12));
			this [ 5] = B * (b * m00 + i * m08 + j * m12 - (c * m00) - (h * m08) - (o * m12));
			this [ 6] = B * (e * m00 + h * m04 + x * m12 - (d * m00) - (i * m04) - (r * m12));
			this [ 7] = B * (f * m00 + o * m04 + r * m08 - (g * m00) - (j * m04) - (x * m08));
			this [ 8] = B * (t * m07 + s * m11 + y * m15 - (p * m07) - (v * m11) - (z * m15));
			this [ 9] = B * (p * m03 + A * m11 + E * m15 - (t * m03) - (C * m11) - (D * m15));
			this [10] = B * (v * m03 + C * m07 + F * m15 - (s * m03) - (A * m07) - (G * m15));
			this [11] = B * (z * m03 + D * m07 + G * m11 - (y * m03) - (E * m07) - (F * m11));
			this [12] = B * (v * m10 + z * m14 + p * m06 - (y * m14) - (t * m06) - (s * m10));
			this [13] = B * (D * m14 + t * m02 + C * m10 - (A * m10) - (E * m14) - (p * m02));
			this [14] = B * (A * m06 + G * m14 + s * m02 - (F * m14) - (v * m02) - (C * m06));
			this [15] = B * (F * m10 + y * m02 + E * m06 - (D * m06) - (G * m10) - (z * m02));

			return this;
		},
		multLeft: function (matrix)
		{
			var
				a00 = this [ 0], a01 = this [ 1], a02 = this [ 2], a03 = this [ 3],
				a04 = this [ 4], a05 = this [ 5], a06 = this [ 6], a07 = this [ 7],
				a08 = this [ 8], a09 = this [ 9], a10 = this [10], a11 = this [11],
				a12 = this [12], a13 = this [13], a14 = this [14], a15 = this [15],
				b00 = matrix [ 0], b01 = matrix [ 1], b02 = matrix [ 2], b03 = matrix [ 3],
				b04 = matrix [ 4], b05 = matrix [ 5], b06 = matrix [ 6], b07 = matrix [ 7],
				b08 = matrix [ 8], b09 = matrix [ 9], b10 = matrix [10], b11 = matrix [11],
				b12 = matrix [12], b13 = matrix [13], b14 = matrix [14], b15 = matrix [15];

			this [ 0] = a00 * b00 + a04 * b01 + a08 * b02 + a12 * b03;
			this [ 1] = a01 * b00 + a05 * b01 + a09 * b02 + a13 * b03;
			this [ 2] = a02 * b00 + a06 * b01 + a10 * b02 + a14 * b03;
			this [ 3] = a03 * b00 + a07 * b01 + a11 * b02 + a15 * b03;
			this [ 4] = a00 * b04 + a04 * b05 + a08 * b06 + a12 * b07;
			this [ 5] = a01 * b04 + a05 * b05 + a09 * b06 + a13 * b07;
			this [ 6] = a02 * b04 + a06 * b05 + a10 * b06 + a14 * b07;
			this [ 7] = a03 * b04 + a07 * b05 + a11 * b06 + a15 * b07;
			this [ 8] = a00 * b08 + a04 * b09 + a08 * b10 + a12 * b11;
			this [ 9] = a01 * b08 + a05 * b09 + a09 * b10 + a13 * b11;
			this [10] = a02 * b08 + a06 * b09 + a10 * b10 + a14 * b11;
			this [11] = a03 * b08 + a07 * b09 + a11 * b10 + a15 * b11;
			this [12] = a00 * b12 + a04 * b13 + a08 * b14 + a12 * b15;
			this [13] = a01 * b12 + a05 * b13 + a09 * b14 + a13 * b15;
			this [14] = a02 * b12 + a06 * b13 + a10 * b14 + a14 * b15;
			this [15] = a03 * b12 + a07 * b13 + a11 * b14 + a15 * b15;

			return this;
		},
		multRight: function (matrix)
		{
			var
				a00 = this [ 0], a01 = this [ 1], a02 = this [ 2], a03 = this [ 3],
				a04 = this [ 4], a05 = this [ 5], a06 = this [ 6], a07 = this [ 7],
				a08 = this [ 8], a09 = this [ 9], a10 = this [10], a11 = this [11],
				a12 = this [12], a13 = this [13], a14 = this [14], a15 = this [15],
				b00 = matrix [ 0], b01 = matrix [ 1], b02 = matrix [ 2], b03 = matrix [ 3],
				b04 = matrix [ 4], b05 = matrix [ 5], b06 = matrix [ 6], b07 = matrix [ 7],
				b08 = matrix [ 8], b09 = matrix [ 9], b10 = matrix [10], b11 = matrix [11],
				b12 = matrix [12], b13 = matrix [13], b14 = matrix [14], b15 = matrix [15];

			this [ 0] = a00 * b00 + a01 * b04 + a02 * b08 + a03 * b12;
			this [ 1] = a00 * b01 + a01 * b05 + a02 * b09 + a03 * b13;
			this [ 2] = a00 * b02 + a01 * b06 + a02 * b10 + a03 * b14;
			this [ 3] = a00 * b03 + a01 * b07 + a02 * b11 + a03 * b15;
			this [ 4] = a04 * b00 + a05 * b04 + a06 * b08 + a07 * b12;
			this [ 5] = a04 * b01 + a05 * b05 + a06 * b09 + a07 * b13;
			this [ 6] = a04 * b02 + a05 * b06 + a06 * b10 + a07 * b14;
			this [ 7] = a04 * b03 + a05 * b07 + a06 * b11 + a07 * b15;
			this [ 8] = a08 * b00 + a09 * b04 + a10 * b08 + a11 * b12;
			this [ 9] = a08 * b01 + a09 * b05 + a10 * b09 + a11 * b13;
			this [10] = a08 * b02 + a09 * b06 + a10 * b10 + a11 * b14;
			this [11] = a08 * b03 + a09 * b07 + a10 * b11 + a11 * b15;
			this [12] = a12 * b00 + a13 * b04 + a14 * b08 + a15 * b12;
			this [13] = a12 * b01 + a13 * b05 + a14 * b09 + a15 * b13;
			this [14] = a12 * b02 + a13 * b06 + a14 * b10 + a15 * b14;
			this [15] = a12 * b03 + a13 * b07 + a14 * b11 + a15 * b15;

			return this;
		},
		multVecMatrix: function (vector)
		{
			if (vector .length === 3)
			{
				var
					x = vector .x,
					y = vector .y,
					z = vector .z,
					w = 1 / (x * this [3] + y * this [7] + z * this [11] + this [15]);

				vector .x = (x * this [0] + y * this [4] + z * this [ 8] + this [12]) * w;
				vector .y = (x * this [1] + y * this [5] + z * this [ 9] + this [13]) * w;
				vector .z = (x * this [2] + y * this [6] + z * this [10] + this [14]) * w;

				return vector;
			}

			var
				x = vector .x,
				y = vector .y,
				z = vector .z,
				w = vector .w;

			vector .x = x * this [0] + y * this [4] + z * this [ 8] + w * this [12];
			vector .y = x * this [1] + y * this [5] + z * this [ 9] + w * this [13];
			vector .z = x * this [2] + y * this [6] + z * this [10] + w * this [14];
			vector .w = x * this [3] + y * this [7] + z * this [11] + w * this [15];

			return vector;
		},
		multMatrixVec: function (vector)
		{
			if (vector .length === 3)
			{
				var
					x = vector .x,
					y = vector .y,
					z = vector .z,
					w = 1 / (x * this [12] + y * this [13] + z * this [14] + this [15]);

				vector .x = (x * this [0] + y * this [1] + z * this [ 2] + this [ 3]) * w;
				vector .y = (x * this [4] + y * this [5] + z * this [ 6] + this [ 7]) * w;
				vector .z = (x * this [8] + y * this [9] + z * this [10] + this [11]) * w;

				return vector;
			}

			var
				x = vector .x,
				y = vector .y,
				z = vector .z,
				w = vector .w;

			vector .x = x * this [ 0] + y * this [ 1] + z * this [ 2] + w * this [ 3];
			vector .y = x * this [ 4] + y * this [ 5] + z * this [ 6] + w * this [ 7];
			vector .z = x * this [ 8] + y * this [ 9] + z * this [10] + w * this [11];
			vector .w = x * this [12] + y * this [13] + z * this [14] + w * this [15];

			return vector;
		},
		multDirMatrix: function (vector)
		{
			var
				x = vector .x,
				y = vector .y,
				z = vector .z;

			vector .x = x * this [0] + y * this [4] + z * this [ 8];
			vector .y = x * this [1] + y * this [5] + z * this [ 9];
			vector .z = x * this [2] + y * this [6] + z * this [10];

			return vector;
		},
		multMatrixDir: function (vector)
		{
			var
				x = vector .x,
				y = vector .y,
				z = vector .z;

			vector .x = x * this [0] + y * this [1] + z * this [ 2];
			vector .y = x * this [4] + y * this [5] + z * this [ 6];
			vector .z = x * this [8] + y * this [9] + z * this [10];

			return vector;
		},
		identity: function ()
		{
			this [ 0] = 1; this [ 1] = 0; this [ 2] = 0; this [ 3] = 0;
			this [ 4] = 0; this [ 5] = 1; this [ 6] = 0; this [ 7] = 0;
			this [ 8] = 0; this [ 9] = 0; this [10] = 1; this [11] = 0;
			this [12] = 0; this [13] = 0; this [14] = 0; this [15] = 1;
		},
		translate: function (translation)
		{
			var
				x = translation .x,
				y = translation .y,
				z = translation .z;

			this [12] += this [ 0] * x + this [ 4] * y + this [ 8] * z;
			this [13] += this [ 1] * x + this [ 5] * y + this [ 9] * z;
			this [14] += this [ 2] * x + this [ 6] * y + this [10] * z;

			return this;
		},
		rotate: function (rotation)
		{
			this .multLeft (rotateMatrix .setQuaternion (rotation .value));

			return this;
		},
		scale: function (scale)
		{
			var
				x = scale .x,
				y = scale .y,
				z = scale .z;

			this [ 0] *= x;
			this [ 4] *= y;
			this [ 8] *= z;

			this [ 1] *= x;
			this [ 5] *= y;
			this [ 9] *= z;

			this [ 2] *= x;
			this [ 6] *= y;
			this [10] *= z;

			return this;
		},
		getDepth: function (vector)
		{
			var
				x = vector .x,
				y = vector .y,
				z = vector .z,
				w = 1 / (x * this [3] + y * this [7] + z * this [11] + this [15]);

			return (x * this [2] + y * this [6] + z * this [10] + this [14]) * w;
		},
		toString: function ()
		{
			return this [ 0] + " " + this [ 1] + " " + this [ 2] + " " + this [ 3] + " " +
			       this [ 4] + " " + this [ 5] + " " + this [ 6] + " " + this [ 7] + " " +
			       this [ 8] + " " + this [ 9] + " " + this [10] + " " + this [11] + " " +
			       this [12] + " " + this [13] + " " + this [14] + " " + this [15]
		},
	};

	Object .defineProperty (Matrix4 .prototype, "x",
	{
		get: (function ()
		{
			var vector = new Vector4 (0, 0, 0, 0);

			return function () { return vector .set (this [0], this [1], this [2], this [3]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix4 .prototype, "y",
	{
		get: (function ()
		{
			var vector = new Vector4 (0, 0, 0, 0);

			return function () { return vector .set (this [4], this [5], this [6], this [7]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix4 .prototype, "z",
	{
		get: (function ()
		{
			var vector = new Vector4 (0, 0, 0, 0);

			return function () { return vector .set (this [8], this [9], this [10], this [11]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix4 .prototype, "xAxis",
	{
		get: (function ()
		{
			var vector = new Vector3 (0, 0, 0);

			return function () { return vector .set (this [0], this [1], this [2]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix4 .prototype, "yAxis",
	{
		get: (function ()
		{
			var vector = new Vector3 (0, 0, 0);

			return function () { return vector .set (this [4], this [5], this [6]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix4 .prototype, "zAxis",
	{
		get: (function ()
		{
			var vector = new Vector3 (0, 0, 0);

			return function () { return vector .set (this [8], this [9], this [10]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix4 .prototype, "origin",
	{
		get: (function ()
		{
			var vector = new Vector3 (0, 0, 0);

			return function () { return vector .set (this [12], this [13], this [14]); };
		})(),
		enumerable: false,
		configurable: false
	});

	Object .defineProperty (Matrix4 .prototype, "submatrix",
	{
		get: (function ()
		{
			var matrix = new Matrix3 ();

			return function ()
			{
				matrix [0] = this [0]; matrix [1] = this [1]; matrix [2] = this [ 2];
				matrix [3] = this [4]; matrix [4] = this [5]; matrix [5] = this [ 6];
				matrix [6] = this [8]; matrix [7] = this [9]; matrix [8] = this [10];
				return matrix;
			};
		})(),
		enumerable: false,
		configurable: false
	});

	Object .assign (Matrix4,
	{
		Identity: new Matrix4 (),
		Rotation: function (rotation)
		{
			return Object .create (this .prototype) .setQuaternion (rotation .value);
		},
		Quaternion: function (quaternion)
		{
			return Object .create (this .prototype) .setQuaternion (quaternion);
		},
		Matrix3: function (matrix)
		{
			return new Matrix4 (matrix [0], matrix [1], matrix [2], 0,
			                    matrix [3], matrix [4], matrix [5], 0,
			                    matrix [6], matrix [7], matrix [8], 0,
			                    0, 0, 0, 1);
		},
		transpose: function (matrix)
		{
			var copy = Object .create (this .prototype);
			copy [ 0] = matrix [ 0]; copy [ 1] = matrix [ 4]; copy [ 2] = matrix [ 8]; copy [ 3] = matrix [12];
			copy [ 4] = matrix [ 1]; copy [ 5] = matrix [ 5]; copy [ 6] = matrix [ 9]; copy [ 7] = matrix [13];
			copy [ 8] = matrix [ 2]; copy [ 9] = matrix [ 6]; copy [10] = matrix [10]; copy [11] = matrix [14];
			copy [12] = matrix [ 3]; copy [13] = matrix [ 7]; copy [14] = matrix [11]; copy [15] = matrix [15];
			return copy;
		},
		inverse: function (matrix)
		{
			var
				copy = Object .create (this .prototype),
				m00 = matrix [ 0],
				m01 = matrix [ 1],
				m02 = matrix [ 2],
				m03 = matrix [ 3],
				m04 = matrix [ 4],
				m05 = matrix [ 5],
				m06 = matrix [ 6],
				m07 = matrix [ 7],
				m08 = matrix [ 8],
				m09 = matrix [ 9],
				m10 = matrix [10],
				m11 = matrix [11],
				m12 = matrix [12],
				m13 = matrix [13],
				m14 = matrix [14],
				m15 = matrix [15],
				b = m10 * m15,
				c = m14 * m11,
				d = m06 * m15,
				e = m14 * m07,
				f = m06 * m11,
				g = m10 * m07,
				h = m02 * m15,
				i = m14 * m03,
				j = m02 * m11,
				o = m10 * m03,
				r = m02 * m07,
				x = m06 * m03,
				t = m08 * m13,
				p = m12 * m09,
				v = m04 * m13,
				s = m12 * m05,
				y = m04 * m09,
				z = m08 * m05,
				A = m00 * m13,
				C = m12 * m01,
				D = m00 * m09,
				E = m08 * m01,
				F = m00 * m05,
				G = m04 * m01,
				H = b * m05 + e * m09 + f * m13 - ((c * m05) + (d * m09) + (g * m13)),
				I = c * m01 + h * m09 + o * m13 - ((b * m01) + (i * m09) + (j * m13)),
				J = d * m01 + i * m05 + r * m13 - ((e * m01) + (h * m05) + (x * m13)),
				K = g * m01 + j * m05 + x * m09 - ((f * m01) + (o * m05) + (r * m09)),
				B = m00 * H + m04 * I + m08 * J + m12 * K;

			if (B == 0)
				throw new Error ("Matrix4 .inverse: determinant is 0.");

			B = 1 / B;

			copy [ 0] = B * H;
			copy [ 1] = B * I;
			copy [ 2] = B * J;
			copy [ 3] = B * K;
			copy [ 4] = B * (c * m04 + d * m08 + g * m12 - (b * m04) - (e * m08) - (f * m12));
			copy [ 5] = B * (b * m00 + i * m08 + j * m12 - (c * m00) - (h * m08) - (o * m12));
			copy [ 6] = B * (e * m00 + h * m04 + x * m12 - (d * m00) - (i * m04) - (r * m12));
			copy [ 7] = B * (f * m00 + o * m04 + r * m08 - (g * m00) - (j * m04) - (x * m08));
			copy [ 8] = B * (t * m07 + s * m11 + y * m15 - (p * m07) - (v * m11) - (z * m15));
			copy [ 9] = B * (p * m03 + A * m11 + E * m15 - (t * m03) - (C * m11) - (D * m15));
			copy [10] = B * (v * m03 + C * m07 + F * m15 - (s * m03) - (A * m07) - (G * m15));
			copy [11] = B * (z * m03 + D * m07 + G * m11 - (y * m03) - (E * m07) - (F * m11));
			copy [12] = B * (v * m10 + z * m14 + p * m06 - (y * m14) - (t * m06) - (s * m10));
			copy [13] = B * (D * m14 + t * m02 + C * m10 - (A * m10) - (E * m14) - (p * m02));
			copy [14] = B * (A * m06 + G * m14 + s * m02 - (F * m14) - (v * m02) - (C * m06));
			copy [15] = B * (F * m10 + y * m02 + E * m06 - (D * m06) - (G * m10) - (z * m02));

			return copy;
		},
		multLeft: function (lhs, rhs)
		{
			var
				copy = Object .create (this .prototype),
				a00 = lhs [ 0], a01 = lhs [ 1], a02 = lhs [ 2], a03 = lhs [ 3],
				a04 = lhs [ 4], a05 = lhs [ 5], a06 = lhs [ 6], a07 = lhs [ 7],
				a08 = lhs [ 8], a09 = lhs [ 9], a10 = lhs [10], a11 = lhs [11],
				a12 = lhs [12], a13 = lhs [13], a14 = lhs [14], a15 = lhs [15],
				b00 = rhs [ 0], b01 = rhs [ 1], b02 = rhs [ 2], b03 = rhs [ 3],
				b04 = rhs [ 4], b05 = rhs [ 5], b06 = rhs [ 6], b07 = rhs [ 7],
				b08 = rhs [ 8], b09 = rhs [ 9], b10 = rhs [10], b11 = rhs [11],
				b12 = rhs [12], b13 = rhs [13], b14 = rhs [14], b15 = rhs [15];

			copy [ 0] = a00 * b00 + a04 * b01 + a08 * b02 + a12 * b03;
			copy [ 1] = a01 * b00 + a05 * b01 + a09 * b02 + a13 * b03;
			copy [ 2] = a02 * b00 + a06 * b01 + a10 * b02 + a14 * b03;
			copy [ 3] = a03 * b00 + a07 * b01 + a11 * b02 + a15 * b03;
			copy [ 4] = a00 * b04 + a04 * b05 + a08 * b06 + a12 * b07;
			copy [ 5] = a01 * b04 + a05 * b05 + a09 * b06 + a13 * b07;
			copy [ 6] = a02 * b04 + a06 * b05 + a10 * b06 + a14 * b07;
			copy [ 7] = a03 * b04 + a07 * b05 + a11 * b06 + a15 * b07;
			copy [ 8] = a00 * b08 + a04 * b09 + a08 * b10 + a12 * b11;
			copy [ 9] = a01 * b08 + a05 * b09 + a09 * b10 + a13 * b11;
			copy [10] = a02 * b08 + a06 * b09 + a10 * b10 + a14 * b11;
			copy [11] = a03 * b08 + a07 * b09 + a11 * b10 + a15 * b11;
			copy [12] = a00 * b12 + a04 * b13 + a08 * b14 + a12 * b15;
			copy [13] = a01 * b12 + a05 * b13 + a09 * b14 + a13 * b15;
			copy [14] = a02 * b12 + a06 * b13 + a10 * b14 + a14 * b15;
			copy [15] = a03 * b12 + a07 * b13 + a11 * b14 + a15 * b15;

			return copy;
		},
		multRight: function (lhs, rhs)
		{
			var
				copy = Object .create (this .prototype),
				a00 = lhs [ 0], a01 = lhs [ 1], a02 = lhs [ 2], a03 = lhs [ 3],
				a04 = lhs [ 4], a05 = lhs [ 5], a06 = lhs [ 6], a07 = lhs [ 7],
				a08 = lhs [ 8], a09 = lhs [ 9], a10 = lhs [10], a11 = lhs [11],
				a12 = lhs [12], a13 = lhs [13], a14 = lhs [14], a15 = lhs [15],
				b00 = rhs [ 0], b01 = rhs [ 1], b02 = rhs [ 2], b03 = rhs [ 3],
				b04 = rhs [ 4], b05 = rhs [ 5], b06 = rhs [ 6], b07 = rhs [ 7],
				b08 = rhs [ 8], b09 = rhs [ 9], b10 = rhs [10], b11 = rhs [11],
				b12 = rhs [12], b13 = rhs [13], b14 = rhs [14], b15 = rhs [15];

			copy [ 0] = a00 * b00 + a01 * b04 + a02 * b08 + a03 * b12;
			copy [ 1] = a00 * b01 + a01 * b05 + a02 * b09 + a03 * b13;
			copy [ 2] = a00 * b02 + a01 * b06 + a02 * b10 + a03 * b14;
			copy [ 3] = a00 * b03 + a01 * b07 + a02 * b11 + a03 * b15;
			copy [ 4] = a04 * b00 + a05 * b04 + a06 * b08 + a07 * b12;
			copy [ 5] = a04 * b01 + a05 * b05 + a06 * b09 + a07 * b13;
			copy [ 6] = a04 * b02 + a05 * b06 + a06 * b10 + a07 * b14;
			copy [ 7] = a04 * b03 + a05 * b07 + a06 * b11 + a07 * b15;
			copy [ 8] = a08 * b00 + a09 * b04 + a10 * b08 + a11 * b12;
			copy [ 9] = a08 * b01 + a09 * b05 + a10 * b09 + a11 * b13;
			copy [10] = a08 * b02 + a09 * b06 + a10 * b10 + a11 * b14;
			copy [11] = a08 * b03 + a09 * b07 + a10 * b11 + a11 * b15;
			copy [12] = a12 * b00 + a13 * b04 + a14 * b08 + a15 * b12;
			copy [13] = a12 * b01 + a13 * b05 + a14 * b09 + a15 * b13;
			copy [14] = a12 * b02 + a13 * b06 + a14 * b10 + a15 * b14;
			copy [15] = a12 * b03 + a13 * b07 + a14 * b11 + a15 * b15;

			return copy;
		},
	});

	var rotateMatrix = new Matrix4 ();

	return Matrix4;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFMatrix4',[
	"x_ite/Basic/X3DField",
	"x_ite/Fields/SFMatrixPrototypeTemplate",
	"x_ite/Fields/SFVec3",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix4",
],
function (X3DField,
          SFMatrixPrototypeTemplate,
          SFVec3,
          X3DConstants,
          Matrix4)
{
"use strict";

	function SFMatrix4Template (TypeName, Type, SFVec3)
	{
		function SFMatrix4 (m00, m01, m02, m03,
		                    m10, m11, m12, m13,
		                    m20, m21, m22, m23,
		                    m30, m31, m32, m33)
		{
			switch (arguments .length)
			{
				case 0:
					return X3DField .call (this, new Matrix4 ());

				case 1:
					return X3DField .call (this, arguments [0]);

				case 16:
					return X3DField .call (this, new Matrix4 (m00 * 1, m01 * 1, m02 * 1, m03 * 1,
					                                          m10 * 1, m11 * 1, m12 * 1, m13 * 1,
					                                          m20 * 1, m21 * 1, m22 * 1, m23 * 1,
					                                          m30 * 1, m31 * 1, m32 * 1, m33 * 1));
			}

			throw new Error ("Invalid arguments.");
		}

		SFMatrix4 .prototype = Object .assign (Object .create (X3DField .prototype),
			SFMatrixPrototypeTemplate (Matrix4, SFVec3),
		{
			constructor: SFMatrix4,
			getTypeName: function ()
			{
				return TypeName;
			},
			getType: function ()
			{
				return Type;
			},
		});

		function defineProperty (i)
		{
			Object .defineProperty (SFMatrix4 .prototype, i,
			{
				get: function ()
				{
					return this .getValue () [i];
				},
				set: function (value)
				{
					this .getValue () [i] = value;
					this .addEvent ();
				},
				enumerable: false,
				configurable: false
			});
		}

		for (var i = 0; i < Matrix4 .prototype .length; ++ i)
			defineProperty (i);

		return SFMatrix4;
	}

	return {
		SFMatrix4d: SFMatrix4Template ("SFMatrix4d", X3DConstants .SFMatrix4d, SFVec3 .SFVec3d),
		SFMatrix4f: SFMatrix4Template ("SFMatrix4f", X3DConstants .SFMatrix4f, SFVec3 .SFVec3f),
		VrmlMatrix: SFMatrix4Template ("VrmlMatrix", X3DConstants .VrmlMatrix, SFVec3 .SFVec3f),
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFNodeCache',['x_ite/Fields/SFNode','x_ite/Fields/SFNode'],function ()
{
"use strict";

	var cache = new WeakMap ();

	function SFNodeCache () { }

	SFNodeCache .prototype =
	{
		add: function (baseNode, node)
		{
			var SFNode = require ("x_ite/Fields/SFNode");

			var node = node ? SFNode .call (node, baseNode) : new SFNode (baseNode);

			cache .set (baseNode, node);

			return node;
		},
		get: function (baseNode)
		{
			var node = cache .get (baseNode);

			if (node)
				return node;

			var SFNode = require ("x_ite/Fields/SFNode");

			// Always create new instance!
			node = new SFNode (baseNode);

			cache .set (baseNode, node);

			return node;
		},
	};

	return new SFNodeCache ();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFNode',[
	"x_ite/Basic/X3DField",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
	"x_ite/Fields/SFNodeCache",
],
function (X3DField,
          X3DConstants,
          Generator,
          SFNodeCache)
{
"use strict";

	var handler =
	{
		get: function (target, key)
		{
			try
			{
				var value = target [key];

				if (value !== undefined)
					return value;

				var
					field      = target .getValue () .getField (key),
					accessType = field .getAccessType ();

				// Specification conform would be: accessType & X3DConstants .outputOnly.
				// But we allow read access to plain fields, too.
				if (accessType === X3DConstants .inputOnly)
					return undefined;

				return field .valueOf ();
			}
			catch (error)
			{
				return undefined;
			}
 		},
		set: function (target, key, value)
		{
			if (key in target)
			{
				target [key] = value;
				return true;
			}

			try
			{
				var
					field      = target .getValue () .getField (key),
					accessType = field .getAccessType ();

				if (accessType !== X3DConstants .outputOnly)
					field .setValue (value);

	 			return true;
			}
			catch (error)
			{
				console .error (target, key, error);
				return false;
			}
		},
		has: function (target, key)
		{
			try
			{
				return Boolean (target .getValue () .getField (key));
			}
			catch (error)
			{
				return key in target;
			}
		},
		enumerate: function (target)
		{
			if (! target .getValue ())
				return [ ] [Symbol .iterator] ();

			var
				indices          = [ ],
				fieldDefinitions = target .getValue () .getFieldDefinitions ();

			for (var i = 0, length = fieldDefinitions .length; i < length; ++ i)
				array .push (fieldDefinitions [i] .name);

			return indices [Symbol .iterator] ();
		},
	};

	function SFNode (value)
	{
		if (value)
		{
			value .addParent (this);

			X3DField .call (this, value);
		}
		else
		{
			X3DField .call (this, null);
		}

		return new Proxy (this, handler);
	}

	SFNode .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFNode,
		_cloneCount: 0,
		clone: function ()
		{
			return new SFNode (this .getValue ());
		},
		copy: function (executionContext)
		{
			var value = this .getValue ();

			if (value)
				return new SFNode (value .copy (executionContext));

			return new SFNode ();
		},
		getTypeName: function ()
		{
			return "SFNode";
		},
		getType: function ()
		{
			return X3DConstants .SFNode;
		},
		equals: function (node)
		{
			if (node)
				return this .getValue () === node .getValue ();

			return this .getValue () === null;
		},
		isDefaultValue: function ()
		{
			return this .getValue () === null;
		},
		set: function (value)
		{
			var current = this .getValue ();

			if (current)
			{
				current .removeCloneCount (this ._cloneCount);
				current .removeParent (this);
			}

			if (value)
			{
				value .addParent (this);
				value .addCloneCount (this ._cloneCount);

				X3DField .prototype .set .call (this, value);
			}
			else
			{
				X3DField .prototype .set .call (this, null);
			}
		},
		getNodeTypeName: function ()
		{
			var value = this .getValue ();

			if (value)
				return value .getTypeName ();

			throw new Error ("SFNode.getNodeTypeName: node is null.");
		},
		getNodeName: function ()
		{
			var value = this .getValue ();

			if (value)
				return value .getName ();

			throw new Error ("SFNode.getNodeName: node is null.");
		},
		getNodeType: function ()
		{
			var value = this .getValue ();

			if (value)
				return value .getType () .slice ();

			throw new Error ("SFNode.getNodeType: node is null.");
		},
		getFieldDefinitions: function ()
		{
			var value = this .getValue ();

			if (value)
				return value .getFieldDefinitions ();

			throw new Error ("SFNode.getFieldDefinitions: node is null.");
		},
		addFieldCallback: function (name, string, object)
		{
			switch (arguments .length)
			{
				case 2:
				{
					return X3DField .prototype .addFieldCallback .apply (this, arguments);
				}
				case 3:
				{
					var value = this .getValue ();

					if (value)
						return value .getField (name) .addFieldCallback (string, object);

					throw new Error ("SFNode.addFieldCallback: node is null.");
				}
			}
		},
		removeFieldCallback: function (name, string)
		{
			switch (arguments .length)
			{
				case 1:
				{
					return X3DField .prototype .removeFieldCallback .apply (this, arguments);
				}
				case 2:
				{
					var value = this .getValue ();

					if (value)
						return value .getField (name) .removeFieldCallback (string);

					throw new Error ("SFNode.removeFieldCallback: node is null.");
				}
			}
		},
		addCloneCount: function (count)
		{
			var value = this .getValue ();

			this ._cloneCount += count;

			if (value)
				value .addCloneCount (count);
		},
		removeCloneCount: function (count)
		{
			var value = this .getValue ();

			this ._cloneCount -= count;

			if (value)
				value .removeCloneCount (count);
		},
		valueOf: function ()
		{
			var value = this .getValue ();

			if (value)
				return SFNodeCache .get (value);

			return null;
		},
		toStream: function (stream)
		{
			var value = this .getValue ();

			if (value)
				value .toStream (stream);
			else
				stream .string += "NULL";
		},
		toVRMLStream: function (stream)
		{
			var value = this .getValue ();

			if (value)
				value .toVRMLStream (stream);
			else
				stream .string += "NULL";
		},
		toXMLString: function ()
		{
			var
				stream    = { string: "" },
				generator = Generator .Get (stream),
				value     = this .getValue ();

			generator .PushExecutionContext (value .getExecutionContext ());

			this .toXMLStream (stream);

			generator .PopExecutionContext ();

			return stream .string;
		},
		toXMLStream: function (stream)
		{
			var value = this .getValue ();

			if (value)
				value .toXMLStream (stream);
			else
				stream .string += "<!-- NULL -->";
		},
		dispose: function ()
		{
			this .set (null);

			X3DField .prototype .dispose .call (this);
		},
	});

	return SFNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFRotation',[
	"x_ite/Fields/SFVec3",
	"x_ite/Basic/X3DField",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
	"standard/Math/Numbers/Rotation4",
],
function (SFVec3,
          X3DField,
          X3DConstants,
          Generator,
          Rotation4)
{
"use strict";

	var SFVec3f = SFVec3 .SFVec3f;

	function SFRotation (x, y, z, angle)
	{
		switch (arguments .length)
		{
			case 0:
				return X3DField .call (this, new Rotation4 ());

			case 1:
				return X3DField .call (this, arguments [0]);

			case 2:
				if (arguments [1] instanceof SFVec3f)
					return X3DField .call (this, new Rotation4 (arguments [0] .getValue (), arguments [1] .getValue ()));

				return X3DField .call (this, new Rotation4 (arguments [0] .getValue (), arguments [1] * 1));

			case 4:
				return X3DField .call (this, new Rotation4 (x * 1, y * 1, z * 1, angle * 1));
		}

		throw new Error ("Invalid arguments.");
	}

	SFRotation .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFRotation,
		copy: function ()
		{
			return new SFRotation (this .getValue () .copy ());
		},
		equals: function (rotation)
		{
			return this .getValue () .equals (rotation .getValue ());
		},
		isDefaultValue: function ()
		{
			return this .getValue () .equals (Rotation4 .Identity);
		},
		getTypeName: function ()
		{
			return "SFRotation";
		},
		getType: function ()
		{
			return X3DConstants .SFRotation;
		},
		set: function (value)
		{
			this .getValue () .assign (value);
		},
		setAxis: function (vector)
		{
			this .getValue () .setAxis (vector .getValue ());
			this .addEvent ();
		},
		getAxis: function ()
		{
			return new SFVec3f (this .getValue () .getAxis () .copy ());
		},
		inverse: function ()
		{
			return new SFRotation (Rotation4 .inverse (this .getValue ()));
		},
		multiply: function (rotation)
		{
			return new SFRotation (Rotation4 .multRight (this .getValue (), rotation .getValue ()));
		},
		multVec: function (vector)
		{
			return new SFVec3f (this .getValue () .multVecRot (vector .getValue () .copy ()));
		},
		slerp: function (rotation, t)
		{
			return new SFRotation (Rotation4 .slerp (this .getValue (), rotation .getValue (), t));
		},
		toStream: function (stream)
		{
			var
				generator = Generator .Get (stream),
				rotation  = this .getValue ();

			stream .string +=  rotation .x + " " +
			                   rotation .y + " " +
			                   rotation .z + " " +
			                   generator .ToUnit ("angle", rotation .angle);
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			this .toStream (stream);
		},
	});

	var x = {
		get: function ()
		{
			return this .getValue () .x;
		},
		set: function (value)
		{
			this .getValue () .x = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var y = {
		get: function ()
		{
			return this .getValue () .y;
		},
		set: function (value)
		{
			this .getValue () .y = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var z = {
		get: function ()
		{
			return this .getValue () .z;
		},
		set: function (value)
		{
			this .getValue () .z = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	var angle = {
		get: function ()
		{
			return this .getValue () .angle;
		},
		set: function (value)
		{
			this .getValue () .angle = value * 1;
			this .addEvent ();
		},
		enumerable: true,
		configurable: false
	};

	Object .defineProperty (SFRotation .prototype, "x",     x);
	Object .defineProperty (SFRotation .prototype, "y",     y);
	Object .defineProperty (SFRotation .prototype, "z",     z);
	Object .defineProperty (SFRotation .prototype, "angle", angle);

	x     .enumerable = false;
	y     .enumerable = false;
	z     .enumerable = false;
	angle .enumerable = false;

	Object .defineProperty (SFRotation .prototype, "0", x);
	Object .defineProperty (SFRotation .prototype, "1", y);
	Object .defineProperty (SFRotation .prototype, "2", z);
	Object .defineProperty (SFRotation .prototype, "3", angle);

	return SFRotation;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFString',[
	"x_ite/Basic/X3DField",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function (X3DField,
          X3DConstants,
          Generator)
{
"use strict";

	var
		unescape = /\\(.)/g,
		escape   = /([\\"])/g;

	function SFString (value)
	{
		return X3DField .call (this, arguments .length ? "" + value : "");
	}

	Object .assign (SFString,
	{
		unescape: function (string)
		{
			return string .replace (unescape, "$1");
		},
		escape: function (string)
		{
			return string .replace (escape, "\\$1");
		},
	});

	SFString .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFString,
		copy: function ()
		{
			return new SFString (this .getValue ());
		},
		getTypeName: function ()
		{
			return "SFString";
		},
		getType: function ()
		{
			return X3DConstants .SFString;
		},
		isDefaultValue: function ()
		{
			return this .getValue () === "";
		},
		set: function (value)
		{
			X3DField .prototype .set .call (this, "" + value);
		},
		valueOf: X3DField .prototype .getValue,
		toStream: function (stream)
		{
			stream .string += '"'+ SFString .escape (this .getValue ()) + '"';
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			stream .string += Generator .Get (stream) .XMLEncode (this .getValue ());
		},
	});

	Object .defineProperty (SFString .prototype, "length",
	{
		get: function ()
		{
			return this .getValue () .length;
		},
		enumerable: true,
		configurable: false
	});

	return SFString;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFTime',[
	"x_ite/Basic/X3DField",
	"x_ite/Bits/X3DConstants",
],
function (X3DField,
          X3DConstants)
{
"use strict";

	function SFTime (value)
	{
		return X3DField .call (this, arguments .length ? value * 1 : 0);
	}

	SFTime .prototype = Object .assign (Object .create (X3DField .prototype),
	{
		constructor: SFTime,
		copy: function ()
		{
			return new SFTime (this .getValue ());
		},
		getTypeName: function ()
		{
			return "SFTime";
		},
		getType: function ()
		{
			return X3DConstants .SFTime;
		},
		isDefaultValue: function ()
		{
			return this .getValue () === 0;
		},
		set: function (value)
		{
			X3DField .prototype .set .call (this, value * 1);
		},
		valueOf: X3DField .prototype .getValue,
		toStream: function (stream)
		{
			stream .string += String (this .getValue ());
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			this .toStream (stream);
		},
	});

	return SFTime;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/SFVec4',[
	"x_ite/Basic/X3DField",
	"x_ite/Fields/SFVecPrototypeTemplate",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector4",
],
function (X3DField,
          SFVecPrototypeTemplate,
          X3DConstants,
          Vector4)
{
"use strict";

	function SFVec4Template (TypeName, Type)
	{
		function SFVec4 (x, y, z, w)
		{
			switch (arguments .length)
			{
				case 0:
					return X3DField .call (this, new Vector4 (0, 0, 0, 0));

				case 1:
					return X3DField .call (this, arguments [0]);

				case 4:
					return X3DField .call (this, new Vector4 (x * 1, y * 1, z * 1, w * 1));
			}

			throw new Error ("Invalid arguments.");
		}

		SFVec4 .prototype = Object .assign (Object .create (X3DField .prototype),
			SFVecPrototypeTemplate (Vector4),
		{
			constructor: SFVec4,
			getTypeName: function ()
			{
				return TypeName;
			},
			getType: function ()
			{
				return Type;
			},
		});

		var x = {
			get: function ()
			{
				return this .getValue () .x;
			},
			set: function (value)
			{
				this .getValue () .x = value * 1;
				this .addEvent ();
			},
			enumerable: true,
			configurable: false
		};

		var y = {
			get: function ()
			{
				return this .getValue () .y;
			},
			set: function (value)
			{
				this .getValue () .y = value * 1;
				this .addEvent ();
			},
			enumerable: true,
			configurable: false
		};

		var z = {
			get: function ()
			{
				return this .getValue () .z;
			},
			set: function (value)
			{
				this .getValue () .z = value * 1;
				this .addEvent ();
			},
			enumerable: true,
			configurable: false
		};

		var w = {
			get: function ()
			{
				return this .getValue () .w;
			},
			set: function (value)
			{
				this .getValue () .w = value * 1;
				this .addEvent ();
			},
			enumerable: true,
			configurable: false
		};

		Object .defineProperty (SFVec4 .prototype, "x", x);
		Object .defineProperty (SFVec4 .prototype, "y", y);
		Object .defineProperty (SFVec4 .prototype, "z", z);
		Object .defineProperty (SFVec4 .prototype, "w", w);

		x .enumerable = false;
		y .enumerable = false;
		z .enumerable = false;
		w .enumerable = false;

		Object .defineProperty (SFVec4 .prototype, "0", x);
		Object .defineProperty (SFVec4 .prototype, "1", y);
		Object .defineProperty (SFVec4 .prototype, "2", z);
		Object .defineProperty (SFVec4 .prototype, "3", w);

		return SFVec4;
	}

	return {
		SFVec4d: SFVec4Template ("SFVec4d", X3DConstants .SFVec4d),
		SFVec4f: SFVec4Template ("SFVec4f", X3DConstants .SFVec4f),
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Basic/X3DObjectArrayField',[
	"jquery",
	"x_ite/Basic/X3DField",
	"x_ite/Basic/X3DArrayField",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function ($,
          X3DField,
          X3DArrayField,
          X3DConstants, 
          Generator)
{
"use strict";

	var handler =
	{
		get: function (target, key)
		{
			try
			{
				var index = key * 1;

				if (Number .isInteger (index))
				{
					var array = target .getValue ();
	
					if (index >= array .length)
						target .resize (index + 1);
	
					return array [index] .valueOf ();
				}
				else
				{
					return target [key];
				}
			}
			catch (error)
			{
				// Don't know what to do with symbols, but it seem not to affect anything.
				if ((typeof key) === "symbol")
					return;

				// if target not instance of X3DObjectArrayField, then the constuctor is called as function.
				console .log (target, typeof key, key, error);
			}
		},
		set: function (target, key, value)
		{
			try
			{
				if (key in target)
				{
					target [key] = value;
					return true;
				}

				var
					array = target .getValue (),
					index = parseInt (key);

				if (index >= array .length)
					target .resize (index + 1);

				array [index] .setValue (value);
				return true;
			}
			catch (error)
			{
				// if target not instance of X3DObjectArrayField, then the constuctor is called as function.
				console .log (target, key, error);
				return false;
			}
		},
		has: function (target, key)
		{
			if (Number .isInteger (+key))
				return key < target .getValue () .length;

			return key in target;
		},
		enumerate: function (target)
		{
			var
				indices = [ ],
				array   = target .getValue ();

			for (var i = 0, length = array .length; i < length; ++ i)
				array .push (i);

			return indices [Symbol .iterator] ();
		},
	};

	function X3DObjectArrayField (value)
	{
		X3DArrayField .call (this, [ ]);
		
		this ._target = this;

		if (value [0] instanceof Array)
			value = value [0];

		X3DObjectArrayField .prototype .push .apply (this, value);

		return new Proxy (this, handler);
	}

	X3DObjectArrayField .prototype = Object .assign (Object .create (X3DArrayField .prototype),
	{
		constructor: X3DObjectArrayField,
		getTarget: function ()
		{
			return this ._target;
		},
		copy: function ()
		{
			var
				target = this ._target,
				copy   = new (target .constructor) (),
				array  = target .getValue ();

			X3DObjectArrayField .prototype .push .apply (copy, array);

			return copy;
		},
		equals: function (array)
		{
			var
				target = this ._target,
				a      = target .getValue (),
				b      = array .getValue (),
				length = a .length;

			if (a === b)
				return true;

			if (length !== b .length)
				return false;

			for (var i = 0; i < length; ++ i)
			{
				if (! a [i] .equals (b [i]))
					return false;
			}

			return true;
		},
		set: function (value)
		{
			var target = this ._target;

			target .resize (value .length, undefined, true);

			var array = target .getValue ();

			for (var i = 0, length = value .length; i < length; ++ i)
				array [i] .set (value [i] instanceof X3DField ? value [i] .getValue () : value [i]);
		},
		isDefaultValue: function ()
		{
			return this .length === 0;
		},
		setValue: function (value)
		{
			var target = this ._target;

			target .set (value instanceof X3DObjectArrayField ? value .getValue () : value);
			target .addEvent ();
		},
		unshift: function (value)
		{
			var
				target = this ._target,
				array  = target .getValue ();

			for (var i = arguments .length - 1; i >= 0; -- i)
			{
				var field = new (target .getSingleType ()) ();

				field .setValue (arguments [i]);
				target .addChildObject (field);
				array .unshift (field);
			}

			target .addEvent ();

			return array .length;
		},
		shift: function ()
		{
			var
				target = this ._target,
				array  = target .getValue ();

			if (array .length)
			{
				var field = array .shift ();
				target .removeChildObject (field);
				target .addEvent ();
				return field .valueOf ();
			}
		},
		push: function (value)
		{
			var
				target = this ._target,
				array  = target .getValue ();

			for (var i = 0, length = arguments .length; i < length; ++ i)
			{
				var field = new (target .getSingleType ()) ();

				field .setValue (arguments [i]);
				target .addChildObject (field);
				array .push (field);
			}

			target .addEvent ();

			return array .length;
		},
		pop: function ()
		{
			var
				target = this ._target,
				array  = target .getValue ();

			if (array .length)
			{
				var field = array .pop ();
				target .removeChildObject (field);
				target .addEvent ();
				return field .valueOf ();
			}
		},
		splice: function (index, deleteCount)
		{
			var
				target = this ._target,
				array  = target .getValue ();

			if (index > array .length)
				index = array .length;

			if (index + deleteCount > array .length)
				deleteCount = array .length - index;

			var result = target .erase (index, index + deleteCount);

			if (arguments .length > 2)
				target .insert (index, arguments, 2, arguments .length);

			return result;
		},
		insert: function (index, array, first, last)
		{
			var
				target = this ._target,
				args   = [index, 0];

			for (var i = first; i < last; ++ i)
			{
				var field = new (target .getSingleType ()) ();

				field .setValue (array [i]);
				target .addChildObject (field);
				args .push (field);
			}

			Array .prototype .splice .apply (target .getValue (), args);

			target .addEvent ();
		},
		find: function (first, last, value)
		{
			var target = this ._target;

			if ($.isFunction (value))
			{
				var values = target .getValue ();
	
				for (var i = first; i < last; ++ i)
				{
					if (value (values [i] .valueOf ()))
						return i;
				}
	
				return last;
			}

			var values = target .getValue ();

			for (var i = first; i < last; ++ i)
			{
				if (values [i] .equals (value))
					return i;
			}

			return last;
		},
		remove: function (first, last, value)
		{
			var target = this ._target;

			if ($.isFunction (value))
			{
				var values = target .getValue ();
	
				first = target .find (first, last, value);
	
				if (first !== last)
				{
					for (var i = first; ++ i < last; )
					{
						var current = values [i];

						if (! value (current .valueOf ()))
						{
							var tmp = values [first];
	
							values [first ++] = current;
							values [i]        = tmp;
						}
					}
				}
		
				if (first !== last)
					target .addEvent ();

				return first;
			}

			var values = target .getValue ();

			first = target .find (first, last, value);

			if (first !== last)
			{
				for (var i = first; ++ i < last; )
				{
					var current = values [i];

					if (! current .equals (value))
					{
						var tmp = values [first];

						values [first ++] = current;
						values [i]        = tmp;
					}
				}
			}

			if (first !== last)
				target .addEvent ();

			return first;
		},
		erase: function (first, last)
		{
			var
				target = this ._target,
				values = target .getValue () .splice (first, last - first);
				
			for (var i = 0, length = values .length; i < length; ++ i)
				target .removeChildObject (values [i]);
			
			target .addEvent ();

			return new (target .constructor) (values);
		},
		resize: function (size, value, silent)
		{
			var
				target = this ._target,
				array  = target .getValue ();
		
			if (size < array .length)
			{
				for (var i = size, length = array .length; i < length; ++ i)
					target .removeChildObject (array [i]);

				array .length = size;

				if (! silent)
					target .addEvent ();
			}
			else if (size > array .length)
			{
				for (var i = array .length; i < size; ++ i)
				{
					var field = new (target .getSingleType ()) ();

					if (value !== undefined)
						field .setValue (value);

					target .addChildObject (field);
					array .push (field);
				}

				if (! silent)
					target .addEvent ();
			}
		},
		addChildObject: function (value)
		{
			value .addParent (this ._target);
		},
		removeChildObject: function (value)
		{
			value .removeParent (this ._target);
		},
		toStream: function (stream)
		{
			var
				target    = this ._target,
				array     = target .getValue (),
				generator = Generator .Get (stream);

			switch (array .length)
			{
				case 0:
				{
					stream .string += "[ ]";
					break;
				}
				case 1:
				{
					generator .PushUnitCategory (target .getUnit ());

					array [0] .toStream (stream);

					generator .PopUnitCategory ();
					break;
				}
				default:
				{
					generator .PushUnitCategory (target .getUnit ());

					stream .string += "[\n";
					generator .IncIndent ();
				
					for (var i = 0, length = array .length - 1; i < length; ++ i)
					{
						stream .string += generator .Indent ();
						array [i] .toStream (stream);
						stream .string += ",\n";
					}

					stream .string += generator .Indent ();
					array [length] .toStream (stream);
					stream .string += "\n";

					generator .DecIndent ();
					stream .string += generator .Indent ();
					stream .string += "]";

					generator .PopUnitCategory ();
					break;
				}
			}
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			var
				target = this ._target,
				length = target .length;

			if (length)
			{
				var
					generator = Generator .Get (stream),
					array     = target .getValue ();

				generator .PushUnitCategory (target .getUnit ());

				for (var i = 0, n = length - 1; i < n; ++ i)
				{
					array [i] .toXMLStream (stream);
					stream .string += ", ";
				}

				array [n] .toXMLStream (stream);

				generator .PopUnitCategory ();
			}
		},
		dispose: function ()
		{
			var
				target = this ._target,
				array  = target .getValue ();

			for (var i = 0, length = target .length; i < length; ++ i)
				target .removeChildObject (array [i]);

			array .length = 0;

			X3DArrayField .prototype .dispose .call (target);
		},
	});

	Object .defineProperty (X3DObjectArrayField .prototype, "length",
	{
		get: function () { return this ._target .getValue () .length; },
		set: function (value) { this ._target .resize (value); },
		enumerable: false,
		configurable: false,
	});

	return X3DObjectArrayField;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Basic/X3DTypedArrayField',[
	"x_ite/Basic/X3DArrayField",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
	"standard/Math/Algorithm",
],
function (X3DArrayField,
          X3DConstants, 
          Generator,
          Algorithm)
{
"use strict";

	var handler =
	{
		get: function (target, key)
		{
			try
			{
				var index = key * 1;

				if (Number .isInteger (index))
				{
					var
						array      = target .getValue (),
						components = target .getComponents (),
						valueType  = target .getValueType ();
	
					if (index >= target ._length)
						array = target .resize (index + 1);

					if (components === 1)
					{
						// Return native JavaScript value.
						return valueType (array [index]);
					}
					else
					{
						// Return reference to index.
	
						var
							value         = new (valueType) (),
							internalValue = value .getValue (),
							i             = index * components;
	
						value .addEvent = function () { return addEvent (target, i, internalValue, components); };
						value .getValue = function () { return getValue (target, i, internalValue, components); };
	
						return value;
					}
				}
				else
				{
					return target [key];
				}
			}
			catch (error)
			{
				// Don't know what to do with symbols, but it seem not to affect anything.
				if ((typeof key) === "symbol")
					return;

				// if target not instance of X3DTypedArrayField, then the constuctor is called as function.
				console .log (target, typeof key, key, error);
			}
		},
		set: function (target, key, value)
		{
			try
			{
				if (key in target)
				{
					target [key] = value;
					return true;
				}

				var
					index      = parseInt (key),
					array      = target .getValue (),
					components = target .getComponents ();

				if (index >= target ._length)
					array = target .resize (index + 1);

				if (components === 1)
				{
					array [index] = value;
				}
				else
				{
					index *= components;

					for (var c = 0; c < components; ++ c, ++ index)
						array [index] = value [c];
				}

				target .addEvent ();

				return true;
			}
			catch (error)
			{
				// if target not instance of X3DTypedArrayField, then the constuctor is called as function.
				console .log (target, key, error);
				return false;
			}
		},
		has: function (target, key)
		{
			if (Number .isInteger (+key))
				return key < target ._length;

			return key in target;
		},
		enumerate: function (target)
		{
			var indices = [ ];

			for (var i = 0, length = target ._length; i < length; ++ i)
				array .push (i);

			return indices [Symbol .iterator] ();
		},
	};

	function X3DTypedArrayField (value)
	{
		X3DArrayField .call (this, new (this .getArrayType ()) (2));

		this ._target = this;
		this ._tmp    = [ ];  // Array with components size.

		if (value [0] instanceof Array)
			value = value [0];

		X3DTypedArrayField .prototype .push .apply (this, value);

		return new Proxy (this, handler);
	}

	X3DTypedArrayField .prototype = Object .assign (Object .create (X3DArrayField .prototype),
	{
		constructor: X3DTypedArrayField,
		_length: 0,
		getTarget: function ()
		{
			return this ._target;
		},
		copy: function ()
		{
			var
				target     = this ._target,
				array      = target .getValue (),
				copy       = new (target .constructor) (),
				copyArray  = new (target .getArrayType ()) (array);

			copy ._length = target ._length;

			X3DArrayField .prototype .set .call (copy, copyArray, target ._length);

			return copy;
		},
		equals: function (other)
		{
			if (this === other)
				return true;

			var
				target = this ._target,
				length = target ._length;

			if (length !== other ._length)
				return false;

			var
				a = target  .getValue (),
				b = other .getValue ();

			for (var i = 0, l = length * target .getComponents (); i < l; ++ i)
			{
				if (a [i] !== b [i])
					return false;
			}

			return true;
		},
		assign: function (value)
		{
			var target = this ._target;

			target .set (value .getValue (), value .length);
			target .addEvent ();
		},
		set: function (otherArray /* value of field */, l /* length of field */)
		{
			var
				target      = this ._target,
				components  = target .getComponents (),
				array       = target .getValue (),
				length      = target ._length,
				otherLength = l !== undefined ? l * components : otherArray .length,
				rest        = otherLength % components;

			if (rest)
			{
				otherLength -= rest;

				console .warn ("Array length must be multiple of components size, which is " + components + ".");
			}

			otherLength /= components;

			if (array .length < otherArray .length)
			{
				array = target .grow (otherArray .length);
				array .set (otherArray);

				if (rest)
					array .fill (0, otherLength * components, otherLength * components + rest);
			}
			else
			{
				array .set (otherArray);

				if (otherLength < length)
					array .fill (0, otherLength * components, length * components);
			}

			target ._length = otherLength;
		},
		isDefaultValue: function ()
		{
			return this ._length === 0;
		},
		setValue: function (value)
		{
			var target = this ._target;

			if (value instanceof target .constructor)
			{
				target .assign (value);
			}
			else
			{
				target .set (value);
				target .addEvent ();
			}
		},
		unshift: function (value)
		{
			var
				target          = this ._target,
				components      = target .getComponents (),
				length          = target ._length,
				argumentsLength = arguments .length;

			var array = target .grow ((length + argumentsLength) * components);

			array .copyWithin (argumentsLength * components, 0, length * components);

			if (components === 1)
			{
				array .set (arguments, 0);
			}
			else
			{
				for (var i = 0, a = 0; a < argumentsLength; ++ a)
				{
					var argument = arguments [a];

					for (var c = 0; c < components; ++ c, ++ i)
					{
						array [i] = argument [c];
					}
				}
			}

			target ._length += argumentsLength;

			target .addEvent ();

			return array .length;
		},
		shift: function ()
		{
			var
				target = this ._target,
				length = target ._length;

			if (length)
			{
				var
					array      = target .getValue (),
					components = target .getComponents (),
					valueType  = target .getValueType (),
					newLength  = length - 1;

				if (components === 1)
				{
					var value = valueType (array [0]);
				}
				else
				{
					var tmp = target ._tmp;

					for (var c = 0; c < components; ++ c)
						tmp [c] = array [c];

					var value = Object .create (valueType .prototype);

					valueType .apply (value, tmp);
				}

				array .copyWithin (0, components, length * components);
				array .fill (0, components * newLength, length * components);

				target ._length = newLength;

				target .addEvent ();
				return value;
			}
		},
		push: function (value)
		{
			var
				target          = this ._target,
				components      = target .getComponents (),
				length          = target ._length,
				argumentsLength = arguments .length;

			var array = target .grow ((length + argumentsLength) * components);

			if (components === 1)
			{
				array .set (arguments, length);
			}
			else
			{
				for (var i = length * components, a = 0; a < argumentsLength; ++ a)
				{
					var argument = arguments [a];

					for (var c = 0; c < components; ++ c,  ++ i)
					{
						array [i] = argument [c];
					}
				}
			}

			target ._length += argumentsLength;

			target .addEvent ();

			return target ._length;
		},
		pop: function ()
		{
			var
				target = this ._target,
				length = target ._length;

			if (length)
			{
				var
					array      = target .getValue (),
					components = target .getComponents (),
					valueType  = target .getValueType (),
					newLength  = length - 1;

				if (components === 1)
				{
					var value = valueType (array [length - 1]);
				}
				else
				{
					var tmp = target ._tmp;

					for (var c = 0, a = newLength * components; c < components; ++ c, ++ a)
						tmp [c] = array [a];

					var value = Object .create (valueType .prototype);

					valueType .apply (value, tmp);
				}

				array .fill (0, newLength * components, length * components);

				target ._length = newLength;

				target .addEvent ();

				return value;
			}
		},
		splice: function (index, deleteCount)
		{
			var
				target = this ._target,
				length = target ._length;

			if (index > length)
				index = length;

			if (index + deleteCount > length)
				deleteCount = length - index;

			var result = target .erase (index, index + deleteCount);

			if (arguments .length > 2)
				target .spliceInsert (index, Array .prototype .splice .call (arguments, 2));

			target .addEvent ();

			return result;
		},
		spliceInsert: function (index, other)
		{
			var
				target      = this ._target,
				components  = target .getComponents (),
				length      = target ._length,
				otherLength = other .length;

			index *= components;

			var array = target .grow ((length + otherLength) * components);

			array .copyWithin (index + otherLength * components, index, length * components);

			if (components === 1)
			{
				array .set (other, index);
			}
			else
			{
				for (var i = 0, a = index; i < otherLength; ++ i)
				{
					var value = other [i];

					for (var c = 0; c < components; ++ c, ++ a)
						array [a] = value [c];
				}
			}

			target ._length += otherLength;
		},
		insert: function (index, other, first, last)
		{
			var
				target     = this ._target,
				length     = target ._length,
				otherArray = other .getValue (),
				components = target .getComponents (),
				difference = last - first;

			index *= components;
			first *= components;
			last  *= components;

			var array = target .grow ((length + difference) * components);

			array .copyWithin (index + difference * components, index, length * components);

			for (; first < last; ++ index, ++ first)
				array [index] = otherArray [first];

			target ._length += difference;

			target .addEvent ();
		},
		erase: function (first, last)
		{
			var
				target     = this ._target,
				array      = target .getValue (),
				components = target .getComponents (),
				difference = last - first,
				length     = target ._length,
				newLength  = length - difference,
				values     = new (target .constructor) ();

			first *= components;
			last  *= components;

			var valuesArray = values .grow (difference * components);

			for (var v = 0, f = first; f < last; ++ v, ++ f)
				valuesArray [v] = array [f];

			array .copyWithin (first, last, length * components);
			array .fill (0, newLength * components, length * components);

			target ._length = newLength;
			values ._length = difference;

			target .addEvent ();

			return values;
		},
		resize: function (newLength, value, silent)
		{
			var
				target     = this ._target,
				length     = target ._length,
				array      = target .getValue (),
				components = target .getComponents ();

			if (newLength < length)
			{
				array .fill (0, newLength * components, length * components);

				if (! silent)
					target .addEvent ();
			}
			else if (newLength > length)
			{
				array = target .grow (newLength * components);

				if (value !== undefined)
				{
					if (components === 1)
					{
						array .fill (value, length * components, newLength * components);
					}
					else
					{
						for (var i = length * components, il = newLength * components; i < il; )
						{
							for (var c = 0; c < components; ++ c, ++ i)
							{
								array [i] = value [c];
							}
						}
					}
				}
	
				if (! silent)
					target .addEvent ();
			}

			target ._length = newLength;

			return array;
		},
		grow: function (length)
		{
			var
				target = this ._target,
				array  = target .getValue ();

			if (length < array .length)
				return array;

			var
				maxLength = Algorithm .nextPowerOfTwo (length),
				newArray  = new (target .getArrayType ()) (maxLength);

			newArray .set (array);

			X3DArrayField .prototype .set .call (target, newArray);

			return newArray;
		},
		shrinkToFit: function ()
		{
			var
				target = this ._target,
				array  = target .getValue (),
				length = target ._length * target .getComponents ();

			if (array .length == length)
				return array;

			var newArray = array .subarray (0, length);

			X3DArrayField .prototype .set .call (target, newArray);

			return newArray;
		},
		toStream: function (stream)
		{
			var
				target     = this ._target,
				generator  = Generator .Get (stream),
				array      = target .getValue (),
				length     = target ._length,
				components = target .getComponents (),
				value      = new (target .getSingleType ()) ();

			switch (length)
			{
				case 0:
				{
					stream .string += "[ ]";
					break;
				}
				case 1:
				{
					generator .PushUnitCategory (target .getUnit ());

					if (components === 1)
					{
						value .set (array [0]);

						value .toStream (stream);
					}
					else
					{
						for (var c = 0, first = 0; c < components; ++ c, ++ first)
							value [c] = array [first]; 

						value .toStream (stream);
					}

					generator .PopUnitCategory ();
					break;
				}
				default:
				{
					generator .PushUnitCategory (target .getUnit ());

					stream .string += "[\n";
					generator .IncIndent ();

					if (components === 1)
					{
						for (var i = 0, n = length - 1; i < n; ++ i)
						{
							stream .string += generator .Indent ();

							value .set (array [i * components]);
							value .toStream (stream);
	
							stream .string += ",\n";
						}
	
						stream .string += generator .Indent ();
						value .set (array [n * components]);
						value .toStream (stream);

						stream .string += "\n";
					}
					else
					{
						for (var i = 0, n = length - 1; i < n; ++ i)
						{
							stream .string += generator .Indent ();

							for (var c = 0, first = i * components; c < components; ++ c, ++ first)
								value [c] = array [first]; 
		
							value .toStream (stream);
		
							stream .string += ",\n";
						}

						stream .string += generator .Indent ();

						for (var c = 0, first = n * components; c < components; ++ c, ++ first)
							value [c] = array [first]; 
		
						value .toStream (stream);
						stream .string += "\n";
					}

					generator .DecIndent ();
					stream .string += generator .Indent ();
					stream .string += "]";

					generator .PopUnitCategory ();
					break;
				}
			}
		},
		toVRMLStream: function (stream)
		{
			this .toStream (stream);
		},
		toXMLStream: function (stream)
		{
			var
				target = this ._target,
				length = target ._length;

			if (length)
			{
				var
					generator  = Generator .Get (stream),
					array      = target .getValue (),
					components = target .getComponents (),
					value      = new (target .getSingleType ()) ();
	
				generator .PushUnitCategory (target .getUnit ());

				if (components === 1)
				{
					for (var i = 0, n = length - 1; i < n; ++ i)
					{
						value .set (array [i * components]);
						value .toXMLStream (stream);

						stream .string += ", ";
					}

					value .set (array [n * components]);

					value .toXMLStream (stream);
				}
				else
				{
					for (var i = 0, n = length - 1; i < n; ++ i)
					{
						for (var c = 0, first = i * components; c < components; ++ c, ++ first)
							value [c] = array [first]; 
	
						value .toXMLStream (stream);
	
						stream .string += ", ";
					}

					for (var c = 0, first = n * components; c < components; ++ c, ++ first)
						value [c] = array [first]; 
	
					value .toXMLStream (stream);
				}

				generator .PopUnitCategory ();
			}
		},
		dispose: function ()
		{
			X3DArrayField .prototype .dispose .call (this ._target);
		},
	});

	Object .defineProperty (X3DTypedArrayField .prototype, "length",
	{
		get: function () { return this ._length; },
		set: function (value) { this ._target .resize (value); },
		enumerable: false,
		configurable: false,
	});

	// Getter/Setter functions to reference a value for a given index.

	function getValue (target, index, value, components)
	{
		var
			array = target .getValue (),
			tmp   = target ._tmp;

		for (var c = 0; c < components; ++ c, ++ index)
			tmp [c] = array [index];

		value .set .apply (value, tmp);

		return value;
	}

	function addEvent (target, index, value, components)
	{
		var array = target .getValue ();

		for (var c = 0; c < components; ++ c, ++ index)
			array [index] = value [c];

		target .addEvent ();
	}

	return X3DTypedArrayField;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields/ArrayFields',[
	"x_ite/Fields/SFBool",
	"x_ite/Fields/SFColor",
	"x_ite/Fields/SFColorRGBA",
	"x_ite/Fields/SFDouble",
	"x_ite/Fields/SFFloat",
	"x_ite/Fields/SFImage",
	"x_ite/Fields/SFInt32",
	"x_ite/Fields/SFMatrix3",
	"x_ite/Fields/SFMatrix4",
	"x_ite/Fields/SFNode",
	"x_ite/Fields/SFRotation",
	"x_ite/Fields/SFString",
	"x_ite/Fields/SFTime",
	"x_ite/Fields/SFVec2",
	"x_ite/Fields/SFVec3",
	"x_ite/Fields/SFVec4",
	"x_ite/Basic/X3DObjectArrayField",
	"x_ite/Basic/X3DTypedArrayField",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function (SFBool,
          SFColor,
          SFColorRGBA,
          SFDouble,
          SFFloat,
          SFImage,
          SFInt32,
          SFMatrix3,
          SFMatrix4,
          SFNode,
          SFRotation,
          SFString,
          SFTime,
          SFVec2,
          SFVec3,
          SFVec4,
          X3DObjectArrayField,
          X3DTypedArrayField,
          X3DConstants,
          Generator)
{
"use strict";

	var
		SFMatrix3d = SFMatrix3 .SFMatrix3d,
		SFMatrix3f = SFMatrix3 .SFMatrix3f,
		SFMatrix4d = SFMatrix4 .SFMatrix4d,
		SFMatrix4f = SFMatrix4 .SFMatrix4f,
		SFVec2d    = SFVec2 .SFVec2d,
		SFVec2f    = SFVec2 .SFVec2f,
		SFVec3d    = SFVec3 .SFVec3d,
		SFVec3f    = SFVec3 .SFVec3f,
		SFVec4d    = SFVec4 .SFVec4d,
		SFVec4f    = SFVec4 .SFVec4f;

	/*
	 *  MFNode
	 */

	function MFNode (value)
	{
		return X3DObjectArrayField .call (this, arguments);
	}

	MFNode .prototype = Object .assign (Object .create (X3DObjectArrayField .prototype),
	{
		constructor: MFNode,
		_cloneCount: 0,
		getSingleType: function ()
		{
			return SFNode;
		},
		getValueType: function ()
		{
			return SFNode;
		},
		getArrayType: function ()
		{
			return Array;
		},
		getComponents: function ()
		{
			return 1;
		},
		getTypeName: function ()
		{
			return "MFNode";
		},
		getType: function ()
		{
			return X3DConstants .MFNode;
		},
		clone: function ()
		{
			var clone = new MFNode ();
			clone .setValue (this);
			return clone;
		},
		copy: function (executionContext)
		{
			var
				copy  = new MFNode (),
				array = this .getValue ();

			for (var i = 0, length = array .length; i < length; ++ i)
				copy .push (array [i] .copy (executionContext));

			return copy;
		},
		addCloneCount: function (count)
		{
			var array = this .getValue ();

			this ._cloneCount += count;

			for (var i = 0, length = array .length; i < length; ++ i)
				array [i] .addCloneCount (count);
		},
		removeCloneCount: function (count)
		{
			var array = this .getValue ();

			this ._cloneCount += count;

			for (var i = 0, length = array .length; i < length; ++ i)
				array [i] .removeCloneCount (count);
		},
		addChildObject: function (value)
		{
			X3DObjectArrayField .prototype .addChildObject .call (this, value);

			value .addCloneCount (this ._cloneCount);
		},
		removeChildObject: function (value)
		{
			X3DObjectArrayField .prototype .removeChildObject .call (this, value);

			value .removeCloneCount (this ._cloneCount);
		},
		toStream: function (stream)
		{
			var
				target    = this ._target,
				array     = target .getValue (),
				generator = Generator .Get (stream);

			switch (array .length)
			{
				case 0:
				{
					stream .string += "[ ]";
					break;
				}
				case 1:
				{
					generator .PushUnitCategory (target .getUnit ());

					array [0] .toStream (stream);

					generator .PopUnitCategory ();
					break;
				}
				default:
				{
					generator .PushUnitCategory (target .getUnit ());

					stream .string += "[\n";
					generator .IncIndent ();

					for (var i = 0, length = array .length; i < length; ++ i)
					{
						stream .string += generator .Indent ();
						array [i] .toStream (stream);
						stream .string += "\n";
					}

					generator .DecIndent ();
					stream .string += generator .Indent ();
					stream .string += "]";

					generator .PopUnitCategory ();
					break;
				}
			}
		},
		toVRMLString: function ()
		{
			this .addCloneCount (1);

			var string = X3DObjectArrayField .prototype .toVRMLString .call (this);

			this .removeCloneCount (1);

			return string;
		},
		toVRMLStream: function (stream)
		{
			var
				target    = this ._target,
				array     = target .getValue (),
				generator = Generator .Get (stream);

			switch (array .length)
			{
				case 0:
				{
					stream .string += "[ ]";
					break;
				}
				case 1:
				{
					generator .EnterScope ();

					array [0] .toVRMLStream (stream);

					generator .LeaveScope ();
					break;
				}
				default:
				{
					generator .EnterScope ();

					stream .string += "[\n";
					generator .IncIndent ();

					for (var i = 0, length = array .length; i < length; ++ i)
					{
						stream .string += generator .Indent ();
						array [i] .toVRMLStream (stream);
						stream .string += "\n";
					}

					generator .DecIndent ();
					stream .string += generator .Indent ();
					stream .string += "]";

					generator .LeaveScope ();
					break;
				}
			}
		},
		toXMLString: function ()
		{
			this .addCloneCount (1);

			var string = X3DObjectArrayField .prototype .toXMLString .call (this);

			this .removeCloneCount (1);

			return string;
		},
		toXMLStream: function (stream)
		{
			var
				generator = Generator .Get (stream),
				length    = this .length;

			if (length)
			{
				generator .EnterScope ();

				var value = this .getValue ();

				for (var i = 0, n = length - 1; i < n; ++ i)
				{
					var node = value [i] .getValue ();

					if (node)
					{
						node .toXMLStream (stream);
						stream .string += "\n";
					}
					else
					{
						stream .string += generator .Indent ();
						stream .string += "<!-- NULL -->\n";
					}
				}

				var node = value [n] .getValue ();

				if (node)
				{
					node .toXMLStream (stream);
				}
				else
				{
					stream .string += generator .Indent ();
					stream .string += "<!-- NULL -->";
				}

				generator .LeaveScope ();
			}
		},
	});

	function MFString (value)
	{
		return X3DObjectArrayField .call (this, arguments);
	}

	MFString .prototype = Object .assign (Object .create (X3DObjectArrayField .prototype),
	{
		constructor: MFString,
		getValueType: function ()
		{
			return String;
		},
		getSingleType: function ()
		{
			return SFString;
		},
		getArrayType: function ()
		{
			return Array;
		},
		getComponents: function ()
		{
			return 1;
		},
		getTypeName: function ()
		{
			return "MFString";
		},
		getType: function ()
		{
			return X3DConstants .MFString;
		},
		toXMLStream: function (stream)
		{
			var length = this .length;

			if (length)
			{
				var value = this .getValue ();

				for (var i = 0, n = length - 1; i < n; ++ i)
				{
					stream .string += "\"";
					value [i] .toXMLStream (stream);
					stream .string += "\"";
					stream .string += ", ";
				}

				stream .string += "\"";
				value [n] .toXMLStream (stream);
				stream .string += "\"";
			}
		},
	});

	function ArrayTemplate (TypeName, Type, SingleType, ValueType, ArrayType, Components)
	{
		function ArrayField (value)
		{
			return X3DObjectArrayField .call (this, arguments);
		}

		ArrayField .prototype = Object .assign (Object .create (X3DObjectArrayField .prototype),
		{
			constructor: ArrayField,
			getSingleType: function ()
			{
				return SingleType;
			},
			getValueType: function ()
			{
				return ValueType;
			},
			getArrayType: function ()
			{
				return ArrayType;
			},
			getComponents: function ()
			{
				return Components;
			},
			getTypeName: function ()
			{
				return TypeName;
			},
			getType: function ()
			{
				return Type;
			},
		});

		return ArrayField;
	}

	function TypedArrayTemplate (TypeName, Type, SingleType, ValueType, ArrayType, Components)
	{
		function ArrayField (value)
		{
			return X3DTypedArrayField .call (this, arguments);
		}

		ArrayField .prototype = Object .assign (Object .create (X3DTypedArrayField .prototype),
		{
			constructor: ArrayField,
			getSingleType: function ()
			{
				return SingleType;
			},
			getValueType: function ()
			{
				return ValueType;
			},
			getArrayType: function ()
			{
				return ArrayType;
			},
			getComponents: function ()
			{
				return Components;
			},
			getTypeName: function ()
			{
				return TypeName;
			},
			getType: function ()
			{
				return Type;
			},
		});

		return ArrayField;
	}

	function Value (value) { return value; }

	var ArrayFields =
	{
		MFBool:      TypedArrayTemplate ("MFBool",      X3DConstants .MFBool,      SFBool,      Boolean,     Uint8Array,   1),
		MFColor:     TypedArrayTemplate ("MFColor",     X3DConstants .MFColor,     SFColor,     SFColor,     Float32Array, 3),
		MFColorRGBA: TypedArrayTemplate ("MFColorRGBA", X3DConstants .MFColorRGBA, SFColorRGBA, SFColorRGBA, Float32Array, 4),
		MFDouble:    TypedArrayTemplate ("MFDouble",    X3DConstants .MFDouble,    SFDouble,    Value,       Float64Array, 1),
		MFFloat:     TypedArrayTemplate ("MFFloat",     X3DConstants .MFFloat,     SFFloat,     Value,       Float32Array, 1),
		MFImage:     ArrayTemplate      ("MFImage",     X3DConstants .MFImage,     SFImage,     SFImage,     Array,        1),
		MFInt32:     TypedArrayTemplate ("MFInt32",     X3DConstants .MFInt32,     SFInt32,     Value,       Int32Array,   1),
		MFMatrix3d:  TypedArrayTemplate ("MFMatrix3d",  X3DConstants .MFMatrix3d,  SFMatrix3d,  SFMatrix3d,  Float64Array, 9),
		MFMatrix3f:  TypedArrayTemplate ("MFMatrix3f",  X3DConstants .MFMatrix3f,  SFMatrix3f,  SFMatrix3f,  Float32Array, 9),
		MFMatrix4d:  TypedArrayTemplate ("MFMatrix4d",  X3DConstants .MFMatrix4d,  SFMatrix4d,  SFMatrix4d,  Float64Array, 16),
		MFMatrix4f:  TypedArrayTemplate ("MFMatrix4f",  X3DConstants .MFMatrix4f,  SFMatrix4f,  SFMatrix4f,  Float32Array, 16),
		MFNode:      MFNode,
		MFRotation:  TypedArrayTemplate ("MFRotation",  X3DConstants .MFRotation,  SFRotation,  SFRotation,  Float64Array, 4),
		MFString:    MFString,
		MFTime:      TypedArrayTemplate ("MFTime",      X3DConstants .MFTime,      SFTime,      Value,       Float64Array, 1),
		MFVec2d:     TypedArrayTemplate ("MFVec2d",     X3DConstants .MFVec2d,     SFVec2d,     SFVec2d,     Float64Array, 2),
		MFVec2f:     TypedArrayTemplate ("MFVec2f",     X3DConstants .MFVec2f,     SFVec2f,     SFVec2f,     Float32Array, 2),
		MFVec3d:     TypedArrayTemplate ("MFVec3d",     X3DConstants .MFVec3d,     SFVec3d,     SFVec3d,     Float64Array, 3),
		MFVec3f:     TypedArrayTemplate ("MFVec3f",     X3DConstants .MFVec3f,     SFVec3f,     SFVec3f,     Float32Array, 3),
		MFVec4d:     TypedArrayTemplate ("MFVec4d",     X3DConstants .MFVec4d,     SFVec4d,     SFVec4d,     Float64Array, 4),
		MFVec4f:     TypedArrayTemplate ("MFVec4f",     X3DConstants .MFVec4f,     SFVec4f,     SFVec4f,     Float32Array, 4),
	};

	Object .preventExtensions (ArrayFields);
	Object .freeze (ArrayFields);
	Object .seal (ArrayFields);

	return ArrayFields;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Fields',[
	"x_ite/Fields/SFBool",
	"x_ite/Fields/SFColor",
	"x_ite/Fields/SFColorRGBA",
	"x_ite/Fields/SFDouble",
	"x_ite/Fields/SFFloat",
	"x_ite/Fields/SFImage",
	"x_ite/Fields/SFInt32",
	"x_ite/Fields/SFMatrix3",
	"x_ite/Fields/SFMatrix4",
	"x_ite/Fields/SFNode",
	"x_ite/Fields/SFRotation",
	"x_ite/Fields/SFString",
	"x_ite/Fields/SFTime",
	"x_ite/Fields/SFVec2",
	"x_ite/Fields/SFVec3",
	"x_ite/Fields/SFVec4",
	"x_ite/Fields/ArrayFields",
],
function (SFBool,
          SFColor,
          SFColorRGBA,
          SFDouble,
          SFFloat,
          SFImage,
          SFInt32,
          SFMatrix3,
          SFMatrix4,
          SFNode,
          SFRotation,
          SFString,
          SFTime,
          SFVec2,
          SFVec3,
          SFVec4,
          ArrayFields)
{
"use strict";

	var Fields = Object .assign (
	{
		SFBool:      SFBool,
		SFColor:     SFColor,
		SFColorRGBA: SFColorRGBA,
		SFDouble:    SFDouble,
		SFFloat:     SFFloat,
		SFImage:     SFImage,
		SFInt32:     SFInt32,
		SFMatrix3d:  SFMatrix3 .SFMatrix3d,
		SFMatrix3f:  SFMatrix3 .SFMatrix3f,
		SFMatrix4d:  SFMatrix4 .SFMatrix4d,
		SFMatrix4f:  SFMatrix4 .SFMatrix4f,
		SFNode:      SFNode,
		SFRotation:  SFRotation,
		SFString:    SFString,
		SFTime:      SFTime,
		SFVec2d:     SFVec2 .SFVec2d,
		SFVec2f:     SFVec2 .SFVec2f,
		SFVec3d:     SFVec3 .SFVec3d,
		SFVec3f:     SFVec3 .SFVec3f,
		SFVec4d:     SFVec4 .SFVec4d,
		SFVec4f:     SFVec4 .SFVec4f,
		VrmlMatrix:  SFMatrix4 .VrmlMatrix,
	},
	ArrayFields);

	Object .preventExtensions (Fields);
	Object .freeze (Fields);
	Object .seal (Fields);

	return Fields;
});
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/VERSION',[],function ()
{
	return "4.6.15";
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/DEBUG',[],function ()
{
"use strict";

	// Modified during dist build.

	return false;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Base/X3DEventObject',[
	"x_ite/Base/X3DChildObject",
	"x_ite/Base/Events",
],
function (X3DChildObject,
	       Events)
{
"use strict";

	function X3DEventObject (browser)
	{
		X3DChildObject .call (this);

		this ._browser = browser;
	}

	X3DEventObject .prototype = Object .assign (Object .create (X3DChildObject .prototype),
	{
		constructor: X3DEventObject,
		getBrowser: function ()
		{
			return this ._browser;
		},
		getExtendedEventHandling: function ()
		{
			return true;
		},
		addEvent: function (field)
		{
			field .setSet (true);

			if (field .getTainted ())
				return;

			field .setTainted (true);

			this .addEventObject (field, Events .create (field));
		},
		addEventObject: function (field, event)
		{
			var browser = this .getBrowser ();

			field .setSet (true);
			browser .addBrowserEvent ();

			// Register for processEvent

			browser .addTaintedField (field, event);

			// Register for eventsProcessed

			if (this .getTainted ())
			   return;

			if (field .isInput () || (this .getExtendedEventHandling () && ! field .isOutput ()))
			{
				this .addNodeEvent ();
			}
		},
		addNodeEvent: function ()
		{
			if (this .getTainted ())
			   return;

			var browser = this .getBrowser ();

			this .setTainted (true);
			browser .addTaintedNode (this);
			browser .addBrowserEvent ();
		},
		processEvents: function ()
		{
			this .setTainted (false);
			this .processInterests ();
		},
	});

	return X3DEventObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Basic/X3DBaseNode',[
	"x_ite/Base/X3DEventObject",
	"x_ite/Base/Events",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Fields",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function (X3DEventObject,
          Events,
          X3DFieldDefinition,
          FieldDefinitionArray,
          Fields,
          X3DConstants,
          Generator)
{
"use strict";

	function X3DBaseNode (executionContext)
	{
		if (this .hasOwnProperty ("_executionContext"))
			return;

		X3DEventObject .call (this, executionContext .getBrowser ());

		this ._executionContext  = executionContext;
		this ._type              = [ X3DConstants .X3DBaseNode ];
		this ._fields            = new Map ();
		this ._predefinedFields  = new Map ();
		this ._userDefinedFields = new Map ();
		this ._cloneCount        = 0;

		// Setup fields.

		if (this .hasUserDefinedFields ())
			this .fieldDefinitions = new FieldDefinitionArray (this .fieldDefinitions .getValue () .slice ());

		var fieldDefinitions = this .fieldDefinitions .getValue ();

		for (var i = 0, length = fieldDefinitions .length; i < length; ++ i)
			this .addField (fieldDefinitions [i]);
	}

	X3DBaseNode .prototype = Object .assign (Object .create (X3DEventObject .prototype),
	{
		constructor: X3DBaseNode,
		fieldDefinitions: new FieldDefinitionArray ([ ]),
		_private: false,
		_live: true,
		_initialized: false,
		setExecutionContext: function (value)
		{
			// Currently only usefull for Sene.

			this ._executionContext = value;
		},
		getExecutionContext: function ()
		{
			return this ._executionContext;
		},
		getScene: function ()
		{
			var executionContext = this ._executionContext;

			while (! executionContext .isRootContext ())
				executionContext = executionContext .getExecutionContext ();

			return executionContext;
		},
		getMasterScene: function ()
		{
			var scene = this ._executionContext .getScene ();

			while (! scene .isMasterContext ())
				scene = scene .getScene ();

			return scene;
		},
		addType: function (value)
		{
			this ._type .push (value);
		},
		getType: function ()
		{
			return this ._type;
		},
		isType: function (types)
		{
			var type = this ._type;

			for (var i = type .length - 1; i >= 0; -- i)
			{
				if (types .has (type [i]))
					return true;
			}

			return false;
		},
		getInnerNode: function ()
		{
			return this;
		},
		isLive: (function ()
		{
			function isLive ()
			{
			   return this .isLive_;
			}

			return function ()
			{
				///  Returns the live event of this node.

				// Change function.

				this .isLive = isLive;

				// Add isLive event.

				this .addChildObjects ("isLive", new Fields .SFBool (this .getLiveState ()));

				// Event processing is done manually and immediately, so:
				this .isLive_ .removeParent (this);

				// Connect to execution context.

				if (this ._executionContext !== this)
					this ._executionContext .isLive () .addInterest ("_set_live__", this);

				// Return field

				return this .isLive ();
			};
		})(),
		setLive: function (value)
		{
			///  Sets the own live state of this node.  Setting the live state to false
			///  temporarily disables this node completely.

			this ._live = value .valueOf ();

			this ._set_live__ ();
		},
		getLive: function ()
		{
			///  Returns the own live state of this node.

			return this ._live;
		},
		getLiveState: function ()
		{
			///  Determines the live state of this node.

			if (this !== this ._executionContext)
				return this .getLive () && this ._executionContext .isLive () .getValue ();

			return this .getLive ();
		},
		_set_live__: function ()
		{
			var
				live   = this .getLiveState (),
				isLive = this .isLive ();

			if (live)
			{
				if (isLive .getValue ())
					return;

				isLive .setValue (true);
				isLive .processEvent (Events .create (isLive));
			}
			else
			{
				if (isLive .getValue ())
				{
					isLive .setValue (false);
					isLive .processEvent (Events .create (isLive));
				}
			}
		},
		setInitialized: function (value)
		{
			this ._initialized = value;
		},
		isInitialized: function ()
		{
			return this ._initialized;
		},
		setup: function ()
		{
			if (this ._initialized)
				return;

			this ._initialized = true;

			this ._fields .forEach (function (field)
			{
				field .updateReferences ();
				field .setTainted (false);
			});

			this .initialize ();
		},
		initialize: function () { },
		create: function (executionContext)
		{
			return new (this .constructor) (executionContext);
		},
		copy: (function ()
		{
			function needsName (baseNode)
			{
				if (baseNode .getCloneCount () > 1)
					return true;

				if (baseNode .hasRoutes ())
					return true;

				return false;
			}

			return function (executionContext)
			{
				// First try to get a named node with the node's name.

				var name = this .getName ();

				if (name .length)
				{
					var namedNode = executionContext .getNamedNodes () .get (name);

					if (namedNode)
						return namedNode;
				}
				else
				{
					if (needsName (this))
						this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (name), this);
				}

				// Create copy.

				var copy = this .create (executionContext);

				if (name .length)
					executionContext .updateNamedNode (name, copy);

				// Default fields

				var predefinedFields = this .getPredefinedFields ();

				predefinedFields .forEach (function (sourceField)
				{
					try
					{
						var destfield = copy .getField (sourceField .getName ());

						destfield .setSet (sourceField .getSet ());

						if (sourceField .hasReferences ())
						{
							var references = sourceField .getReferences ();

							// IS relationship
							references .forEach (function (originalReference)
							{
								try
								{
									destfield .addReference (executionContext .getField (originalReference .getName ()));
								}
								catch (error)
								{
									console .error (error .message);
								}
							});
						}
						else
						{
							if (sourceField .getAccessType () & X3DConstants .initializeOnly)
							{
								switch (sourceField .getType ())
								{
									case X3DConstants .SFNode:
									case X3DConstants .MFNode:
										destfield .setValue (sourceField .copy (executionContext));
										break;
									default:
										destfield .setValue (sourceField);
										break;
								}
							}
						}
					}
					catch (error)
					{
						console .log (error .message);
					}
				});

				// User-defined fields

				var userDefinedFields = this .getUserDefinedFields ();

				userDefinedFields .forEach (function (sourceField)
				{
					var destfield = sourceField .copy (executionContext);

					copy .addUserDefinedField (sourceField .getAccessType (),
					                           sourceField .getName (),
					                           destfield);

					destfield .setSet (sourceField .getSet ());

					if (sourceField .hasReferences ())
					{
						// IS relationship

						var references = sourceField .getReferences ();

						references .forEach (function (originalReference)
						{
							try
							{
								destfield .addReference (executionContext .getField (originalReference .getName ()));
							}
							catch (error)
							{
								console .error ("No reference '" + originalReference .getName () + "' inside execution context " + executionContext .getTypeName () + " '" + executionContext .getName () + "'.");
							}
						});
					}
				});

				executionContext .addUninitializedNode (copy);
				return copy;
			};
		})(),
		flatCopy: function (executionContext)
		{
			var copy = this .create (executionContext || this .getExecutionContext ());

			this ._fields .forEach (function (field)
			{
				copy ._fields .get (field .getName ()) .assign (field);
			});

			copy .setup ();

			return copy;
		},
		addChildObjects: function (name, field)
		{
			for (var i = 0, length = arguments .length; i < length; i += 2)
				this .addChildObject (arguments [i], arguments [i + 1]);
		},
		addChildObject: function (name, field)
		{
			field .addParent (this);
			field .setName (name);

			Object .defineProperty (this, name + "_",
			{
				get: function () { return field; },
				set: function (value) { field .setValue (value); },
				enumerable: true,
				configurable: false,
			});
		},
		addField: function (fieldDefinition)
		{
			var
				accessType = fieldDefinition .accessType,
				name       = fieldDefinition .name,
				field      = fieldDefinition .value .clone ();

			field .setTainted (true);
			field .addParent (this);
			field .setName (name);
			field .setAccessType (accessType);

			this .setField (name, field);
		},
		setField: function (name, field, userDefined)
		{
			this ._fields .set (name, field);

			if (! this .getPrivate ())
				field .addCloneCount (1);

			if (userDefined)
			{
				this ._userDefinedFields .set (name, field);
			}
			else
			{
				this ._predefinedFields .set (name, field);

				Object .defineProperty (this, name + "_",
				{
					get: function () { return field; },
					set: function (value) { field .setValue (value); },
					enumerable: true,
					configurable: true, // false : non deleteable
				});
			}
		},
		removeField: function (name)
		{
			var field = this ._fields .get (name);

			if (field)
			{
				this ._fields            .delete (name);
				this ._userDefinedFields .delete (name);

				var fieldDefinitions = this .fieldDefinitions .getValue ();

				for (var i = 0, length = fieldDefinitions .length; i < length; ++ i)
				{
					if (fieldDefinitions [i] .name === name)
					{
						fieldDefinitions .splice (i, 1);
						break;
					}
				}

				if (! this .getPrivate ())
					field .removeCloneCount (1);
			}
		},
		getField: (function ()
		{
			var
				set_re     = /^set_(.*?)$/,
				changed_re = /^(.*?)_changed$/;

			return function (name)
			{
				var field = this ._fields .get (name);

				if (field)
					return field;

				var match = name .match (set_re);

				if (match)
				{
					field = this ._fields .get (match [1]);

					if (field && field .getAccessType () === X3DConstants .inputOutput)
						return field;
				}

				var match = name .match (changed_re);

				if (match)
				{
					field = this ._fields .get (match [1]);

					if (field && field .getAccessType () === X3DConstants .inputOutput)
						return field;
				}

				throw new Error ("Unkown field '" + name + "' in node class " + this .getTypeName () + ".");
			};
		})(),
		getFieldDefinitions: function ()
		{
			return this .fieldDefinitions;
		},
		hasUserDefinedFields: function ()
		{
			return false;
		},
		addUserDefinedField: function (accessType, name, field)
		{
			if (this ._fields .has (name))
				this .removeField (name);

			field .setTainted (true);
			field .addParent (this);
			field .setName (name);
			field .setAccessType (accessType);

			this .fieldDefinitions .add (new X3DFieldDefinition (accessType, name, field));

			this .setField (name, field, true);
		},
		getUserDefinedFields: function ()
		{
			return this ._userDefinedFields;
		},
		getPredefinedFields: function ()
		{
			return this ._predefinedFields;
		},
		getChangedFields: function (extented)
		{
			/* param routes: also returen fields with routes */

			var
				changedFields    = [ ],
				predefinedFields = this .getPredefinedFields ();

			if (extented)
			{
				var userDefinedFields = this .getUserDefinedFields ();

				userDefinedFields .forEach (function (field)
				{
					changedFields .push (field);
				});
			}

			predefinedFields .forEach (function (field)
			{
				if (extented)
				{
					if (field .getInputRoutes () .size || field .getOutputRoutes () .size)
					{
						changedFields .push (field);
						return;
					}
				}

				if (field .getReferences () .size === 0)
				{
					if (! field .isInitializable ())
						return;

					if (this .isDefaultValue (field))
						return;
				}

				changedFields .push (field);
			},
			this);

			return changedFields;
		},
		isDefaultValue: function (field)
		{
			var fieldDefinition = this .getFieldDefinitions () .get (field .getName ());

			if (fieldDefinition)
				return fieldDefinition .value .equals (field);

			return ! field .getSet ();
		},
		getFields: function ()
		{
			return this ._fields;
		},
		getSourceText: function ()
		{
			return null;
		},
		hasRoutes: function ()
		{
			///  Returns true if there are any routes from or to fields of this node otherwise false.

			for (var field of this ._fields .values ())
			{
				if (field .getInputRoutes () .size)
					return true;

				if (field .getOutputRoutes () .size)
					return true;
			}

			return false;
		},
		getPrivate: function ()
		{
			return this ._private;
		},
		setPrivate: function (value)
		{
			this ._private = value;

			if (value)
			{
				this ._fields .forEach (function (field)
				{
					field .removeCloneCount (1);
				});
			}
			else
			{
				this ._fields .forEach (function (field)
				{
					field .addCloneCount (1);
				});
			}
		},
		getCloneCount: function ()
		{
			return this ._cloneCount;
		},
		addCloneCount: function (count)
		{
			if (count === 0)
				return;

			this ._cloneCount += count;
		},
		removeCloneCount: function (count)
		{
			if (count === 0)
				return;

			this ._cloneCount -= count;
		},
		traverse: function () { },
		toStream: function (stream)
		{
			stream .string += this .getTypeName () + " { }";
		},
		toVRMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			if (generator .IsSharedNode (this))
			{
				stream .string += "NULL";
				return;
			}

			generator .EnterScope ();

			var name = generator .Name (this);

			if (name .length)
			{
				if (generator .ExistsNode (this))
				{
					stream .string += "USE";
					stream .string += " ";
					stream .string += name;

					generator .LeaveScope ();
					return;
				}
			}

			if (name .length)
			{
				generator .AddNode (this);

				stream .string += "DEF";
				stream .string += " ";
				stream .string += name;
				stream .string += " ";
			}

			stream .string += this .getTypeName ();
			stream .string += " ";
			stream .string += "{";

			var
				fieldTypeLength   = 0,
				accessTypeLength  = 0,
				userDefinedFields = this .getUserDefinedFields ();

			if (this .hasUserDefinedFields ())
			{
				userDefinedFields .forEach (function (field)
				{
					fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
					accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
				});

				if (userDefinedFields .size)
				{
					stream .string += "\n";
					generator .IncIndent ();

					userDefinedFields .forEach (function (field)
					{
						this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);

						stream .string += "\n";
					},
					this);

					generator .DecIndent ();
					stream .string += "\n";
				}
			}

			var fields = this .getChangedFields ();

			if (fields .length === 0)
			{
				if (userDefinedFields .size)
					stream .string += generator .Indent ();
				else
					stream .string += " ";
			}
			else
			{
				if (userDefinedFields .size === 0)
					stream .string += "\n";

				generator .IncIndent ();

				fields .forEach (function (field)
				{
					this .toVRMLStreamField (stream, field, fieldTypeLength, accessTypeLength);

					stream .string += "\n";
				},
				this);

				generator .DecIndent ();
				stream .string += generator .Indent ();
			}

			stream .string += "}";

			generator .LeaveScope ();
		},
		toVRMLStreamField: function (stream, field, fieldTypeLength, accessTypeLength)
		{
			var generator = Generator .Get (stream);

			if (field .getReferences () .size === 0 || ! generator .ExecutionContext ())
			{
				if (field .isInitializable ())
				{
					stream .string += generator .Indent ();
					stream .string += field .getName ();
					stream .string += " ";

					field .toVRMLStream (stream);
				}
			}
			else
			{
				var
					index                  = 0,
					initializableReference = false;

				field .getReferences () .forEach (function (reference)
				{
					initializableReference |= reference .isInitializable ();

					// Output build in reference field

					stream .string += generator .Indent ();
					stream .string += field .getName ();
					stream .string += " ";
					stream .string += "IS";
					stream .string += " ";
					stream .string += reference .getName ();

					++ index;

					if (index !== field .getReferences () .size)
						stream .string += "\n";
				});

				if (field .getAccessType () === X3DConstants .inputOutput && ! initializableReference && ! field .isDefaultValue ())
				{
					// Output build in field

					stream .string += "\n";
					stream .string += generator .Indent ();
					stream .string += field .getName ();
					stream .string += " ";

					field .toVRMLStream (stream);
				}
			}
		},
		toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
		{
			var generator = Generator .Get (stream);

			if (field .getReferences () .size === 0 || ! generator .ExecutionContext ())
			{
				stream .string += generator .Indent ();
				stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
				stream .string += " ";
				stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
				stream .string += " ";
				stream .string += field .getName ();

				if (field .isInitializable ())
				{
					stream .string += " ";

					field .toVRMLStream (stream);
				}
			}
			else
			{
				var
					index                  = 0,
					initializableReference = false;

				field .getReferences () .forEach (function (reference)
				{
					initializableReference |= reference .isInitializable ();

					// Output user defined reference field

					stream .string += generator .Indent ();
					stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
					stream .string += " ";
					stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
					stream .string += " ";
					stream .string += field .getName ();
					stream .string += " ";
					stream .string += "IS";
					stream .string += " ";
					stream .string += reference .getName ();

					++ index;

					if (index !== field .getReferences () .size)
						stream .string += "\n";
				});

				if (field .getAccessType () === X3DConstants .inputOutput && ! initializableReference && ! field .isDefaultValue ())
				{
					stream .string += "\n";
					stream .string += generator .Indent ();
					stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
					stream .string += " ";
					stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
					stream .string += " ";
					stream .string += field .getName ();

					if (field .isInitializable ())
					{
						stream .string += " ";

						field .toVRMLStream (stream);
					}
				}
			}
		},
		toXMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			if (generator .IsSharedNode (this))
			{
				stream .string += generator .Indent ();
				stream .string += "<!-- NULL -->";
				return;
			}

			generator .EnterScope ();

			var name = generator .Name (this);

			if (name .length)
			{
				if (generator .ExistsNode (this))
				{
					stream .string += generator .Indent ();
					stream .string += "<";
					stream .string += this .getTypeName ();
					stream .string += " ";
					stream .string += "USE='";
					stream .string += generator .XMLEncode (name);
					stream .string += "'";

					var containerField = generator .ContainerField ();

					if (containerField)
					{
						if (containerField .getName () !== this .getContainerField ())
						{
							stream .string += " ";
							stream .string += "containerField='";
							stream .string += generator .XMLEncode (containerField .getName ());
							stream .string += "'";
						}
					}

					stream .string += "/>";

					generator .LeaveScope ();
					return;
				}
			}

			stream .string += generator .Indent ();
			stream .string += "<";
			stream .string += this .getTypeName ();

			if (name .length)
			{
				generator .AddNode (this);

				stream .string += " ";
				stream .string += "DEF='";
				stream .string += generator .XMLEncode (name);
				stream .string += "'";
			}

			var containerField = generator .ContainerField ();

			if (containerField)
			{
				if (containerField .getName () !== this .getContainerField ())
				{
					stream .string += " ";
					stream .string += "containerField='";
					stream .string += generator .XMLEncode (containerField .getName ());
					stream .string += "'";
				}
			}

			var
				fields            = this .getChangedFields (),
				userDefinedFields = this .getUserDefinedFields ();

			var
				references = [ ],
				childNodes = [ ];

			var cdata = this .getSourceText ();

			if (cdata && cdata .length === 0)
				cdata = null;

			generator .IncIndent ();
			generator .IncIndent ();

			for (var i = 0, length = fields .length; i < length; ++ i)
			{
				var field = fields [i];

				// If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
				// for this field.

				var mustOutputValue = false;

				if (generator .ExecutionContext ())
				{
					if (field .getAccessType () === X3DConstants .inputOutput && field .getReferences () .size !== 0)
					{
						var
							initializableReference = false,
							fieldReferences        = field .getReferences ();

						fieldReferences .forEach (function (fieldReference)
						{
							initializableReference |= fieldReference .isInitializable ();
						});

						if (! initializableReference)
							mustOutputValue = true;
					}
				}

				// If we have no execution context we are not in a proto and must not generate IS references the same is true
				// if the node is a shared node as the node does not belong to the execution context.

				if (field .getReferences () .size === 0 || ! generator .ExecutionContext () || mustOutputValue)
				{
					if (mustOutputValue)
						references .push (field);

					if (field .isInitializable ())
					{
						switch (field .getType ())
						{
							case X3DConstants .SFNode:
							case X3DConstants .MFNode:
							{
								childNodes .push (field);
								break;
							}
							default:
							{
								if (field === cdata)
									break;

								stream .string += "\n";
								stream .string += generator .Indent ();
								stream .string += field .getName ();
								stream .string += "='";

								field .toXMLStream (stream);

								stream .string += "'";
								break;
							}
						}
					}
				}
				else
				{
					references .push (field);
				}
			}

			generator .DecIndent ();
			generator .DecIndent ();

			if ((! this .hasUserDefinedFields () || userDefinedFields .size === 0) && references .length === 0 && childNodes .length === 0 && ! cdata)
			{
				stream .string += "/>";
			}
			else
			{
				stream .string += ">\n";

				generator .IncIndent ();

				if (this .hasUserDefinedFields ())
				{
					userDefinedFields .forEach (function (field)
					{
						stream .string += generator .Indent ();
						stream .string += "<field";
						stream .string += " ";
						stream .string += "accessType='";
						stream .string += generator .AccessType (field .getAccessType ());
						stream .string += "'";
						stream .string += " ";
						stream .string += "type='";
						stream .string += field .getTypeName ();
						stream .string += "'";
						stream .string += " ";
						stream .string += "name='";
						stream .string += generator .XMLEncode (field .getName ());
						stream .string += "'";

						// If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
						// for this field.

						var mustOutputValue = false;

						if (field .getAccessType () === X3DConstants .inputOutput && field .getReferences () .size !== 0)
						{
							var
								initializableReference = false,
								fieldReferences        = field .getReferences ();

							fieldReferences .forEach (function (fieldReference)
							{
								initializableReference |= fieldReference .isInitializable ();
							});

							if (! initializableReference)
								mustOutputValue = true;
						}

						if ((field .getReferences () .size === 0 || ! generator .ExecutionContext ()) || mustOutputValue)
						{
							if (mustOutputValue && generator .ExecutionContext ())
								references .push (field);

							if (! field .isInitializable () || field .isDefaultValue ())
							{
								stream .string += "/>\n";
							}
							else
							{
								// Output value

								switch (field .getType ())
								{
									case X3DConstants .SFNode:
									case X3DConstants .MFNode:
									{
										generator .PushContainerField (field);

										stream .string += ">\n";

										generator .IncIndent ();

										field .toXMLStream (stream);

										stream .string += "\n";

										generator .DecIndent ();

										stream .string += generator .Indent ();
										stream .string += "</field>\n";

										generator .PopContainerField ();
										break;
									}
									default:
									{
										stream .string += " ";
										stream .string += "value='";

										field .toXMLStream (stream);

										stream .string += "'";
										stream .string += "/>\n";
										break;
									}
								}
							}
						}
						else
						{
							if (generator .ExecutionContext ())
								references .push (field);

							stream .string += "/>\n";
						}
					});
				}

				if (references .length)
				{
					stream .string += generator .Indent ();
					stream .string += "<IS>";
					stream .string += "\n";

					generator .IncIndent ();

					for (var i = 0, length = references .length; i < length; ++ i)
					{
						var
							field       = references [i],
							protoFields = field .getReferences ();

						protoFields .forEach (function (protoField)
						{
							stream .string += generator .Indent ();
							stream .string += "<connect";
							stream .string += " ";
							stream .string += "nodeField='";
							stream .string += generator .XMLEncode (field .getName ());
							stream .string += "'";
							stream .string += " ";
							stream .string += "protoField='";
							stream .string += generator .XMLEncode (protoField .getName ());
							stream .string += "'";
							stream .string += "/>\n";
						});
					}

					generator .DecIndent ();

					stream .string += generator .Indent ();
					stream .string += "</IS>\n";
				}

				for (var i = 0, length = childNodes .length; i < length; ++ i)
				{
					var field = childNodes [i];

					generator .PushContainerField (field);

					field .toXMLStream (stream);

					stream .string += "\n";

					generator .PopContainerField ();
				}

				if (cdata)
				{
					for (var i = 0, length = cdata .length; i < length; ++ i)
					{
						var value = cdata [i];

						stream .string += "<![CDATA[";
						stream .string += generator .escapeCDATA (value);
						stream .string += "]]>\n";
					}
				}

				generator .DecIndent ();

				stream .string += generator .Indent ();
				stream .string += "</";
				stream .string += this .getTypeName ();
				stream .string += ">";
			}

			generator .LeaveScope ();
		},
		dispose: function ()
		{
			// TODO: remove named node if any. (do this in NamedNode)
			// TODO: remove improted node if any. (do this in ImportedNode)
			// TODO: remove exported node if any. (do this in ExportedNode)
			// TODO: remove routes from and to node if any. (do this in Route)

			var
				predefinedFields  = this .getPredefinedFields (),
				userDefinedFields = this .getUserDefinedFields ();

			predefinedFields .forEach (function (predefinedField)
			{
				predefinedField .dispose ();
			});

			userDefinedFields .forEach (function (userDefinedField)
			{
				userDefinedField .dispose ();
			});

			// Remove node from entire scene graph.

			var firstParents = new Set (this .getParents ());

			firstParents .forEach (function (firstParent)
			{
				if (firstParent instanceof Fields .SFNode)
				{
					var secondParents = new Set (firstParent .getParents ());

					secondParents .forEach (function (secondParent)
					{
						if (secondParent instanceof Fields .MFNode)
						{
							var length = secondParent .length;

							secondParent .erase (secondParent .remove (0, length, firstParent), length);
						}
					});

					firstParent .setValue (null);
				}
			});
		},
	});

	X3DBaseNode .prototype .addAlias = X3DBaseNode .prototype .setField;

	return X3DBaseNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/PrimitiveQuality',[],function ()
{
"use strict";
	
	var i = 0;

	var PrimitiveQuality =
	{
		LOW:    i ++,
		MEDIUM: i ++,
		HIGH:   i ++,
	};

	Object .preventExtensions (PrimitiveQuality);
	Object .freeze (PrimitiveQuality);
	Object .seal (PrimitiveQuality);

	return PrimitiveQuality;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/Shading',[],function ()
{
"use strict";
	
	var i = 0;

	var Shading =
	{
		POINT:     i ++,
		WIREFRAME: i ++,
		FLAT:      i ++,
		GOURAUD:   i ++,
		PHONG:     i ++,
	};

	Object .preventExtensions (Shading);
	Object .freeze (Shading);
	Object .seal (Shading);

	return Shading;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/TextureQuality',[],function ()
{
"use strict";
	
	var i = 0;

	var TextureQuality =
	{
		LOW:    i ++,
		MEDIUM: i ++,
		HIGH:   i ++,
	};

	Object .preventExtensions (TextureQuality);
	Object .freeze (TextureQuality);
	Object .seal (TextureQuality);

	return TextureQuality;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/BrowserOptions',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Core/PrimitiveQuality",
	"x_ite/Browser/Core/Shading",
	"x_ite/Browser/Core/TextureQuality",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBaseNode,
          X3DConstants,
          PrimitiveQuality,
          Shading,
          TextureQuality)
{
"use strict";
	
	function toBoolean (value, defaultValue)
	{
		if (value === "true" || value === "TRUE")
			return true;

		if (value === "false" || value === "FALSE")
			return false;

		return defaultValue;
	}

	function BrowserOptions (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .addAlias ("AntiAliased", this .Antialiased_);

		this .textureQuality   = TextureQuality .MEDIUM
		this .primitiveQuality = PrimitiveQuality .MEDIUM;
		this .shading          = Shading .GOURAUD;

		this .setAttributeSplashScreen ();
	}

	BrowserOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: BrowserOptions,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "SplashScreen",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "Dashboard",              new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "Rubberband",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "EnableInlineViewpoints", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "Antialiased",            new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "TextureQuality",         new Fields .SFString ("MEDIUM")),
			new X3DFieldDefinition (X3DConstants .inputOutput, "PrimitiveQuality",       new Fields .SFString ("MEDIUM")),
			new X3DFieldDefinition (X3DConstants .inputOutput, "QualityWhenMoving",      new Fields .SFString ("MEDIUM")),
			new X3DFieldDefinition (X3DConstants .inputOutput, "Shading",                new Fields .SFString ("GOURAUD")),
			new X3DFieldDefinition (X3DConstants .inputOutput, "MotionBlur",             new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "Gravity",                new Fields .SFFloat (9.80665)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "StraightenHorizon",      new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "LogarithmicDepthBuffer", new Fields .SFBool (false)),
		]),
		getTypeName: function ()
		{
			return "BrowserOptions";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "browserOptions";
		},
		initialize: function ()
		{
			X3DBaseNode .prototype .initialize .call (this);
			
			this .SplashScreen_              .addInterest ("set_splashScreen__",           this);
			this .Rubberband_                .addInterest ("set_rubberband__",             this);
			this .PrimitiveQuality_          .addInterest ("set_primitiveQuality__",       this);
			this .TextureQuality_            .addInterest ("set_textureQuality__",         this);
			this .Shading_                   .addInterest ("set_shading__",                this);
			this .StraightenHorizon_         .addInterest ("set_straightenHorizon__",      this);
			this .LogarithmicDepthBuffer_    .addInterest ("set_logarithmicDepthBuffer__", this);

			this .configure ();
		},
		configure: function ()
		{
			if (! this .isInitialized ())
				return;

			var fieldDefinitions = this .getFieldDefinitions ();

			for (var i = 0; i < fieldDefinitions .length; ++ i)
			{
				var
					fieldDefinition = fieldDefinitions [i],
					field           = this .getField (fieldDefinition .name);

				if (this .getBrowser () .getLocalStorage () ["BrowserOptions." + fieldDefinition .name] !== undefined)
					continue;

				if (! field .equals (fieldDefinition .value))
					field .setValue (fieldDefinition .value);
			}

			var
				rubberband        = this .getBrowser () .getLocalStorage () ["BrowserOptions.Rubberband"],
				primitiveQuality  = this .getBrowser () .getLocalStorage () ["BrowserOptions.PrimitiveQuality"],
				textureQuality    = this .getBrowser () .getLocalStorage () ["BrowserOptions.TextureQuality"],
				straightenHorizon = this .getBrowser () .getLocalStorage () ["BrowserOptions.StraightenHorizon"];

			this .setAttributeSplashScreen ();

			if (rubberband !== undefined && rubberband !== this .Rubberband_ .getValue ())
				this .Rubberband_ = rubberband;

			if (primitiveQuality !== undefined && primitiveQuality !== this .PrimitiveQuality_ .getValue () .toUpperCase ())
				this .PrimitiveQuality_ = primitiveQuality;

			if (textureQuality !== undefined && textureQuality !== this .TextureQuality_ .getValue () .toUpperCase ())
				this .TextureQuality_ = textureQuality;

			if (straightenHorizon !== undefined && straightenHorizon !== this .StraightenHorizon_ .getValue ())
				this .StraightenHorizon_ = straightenHorizon;
		},
		setAttributeSplashScreen: function ()
		{
			this .SplashScreen_ .set (this .getSplashScreen ());
		},
		getCache: function ()
		{
			return toBoolean (this .getBrowser () .getElement () .attr ("cache"), true);
		},
		getContextMenu: function ()
		{
			return toBoolean (this .getBrowser () .getElement () .attr ("contextMenu"), true);
		},
		getDebug: function ()
		{
			return toBoolean (this .getBrowser () .getElement () .attr ("debug"), false);
		},
		getNotifications: function ()
		{
			return toBoolean (this .getBrowser () .getElement () .attr ("notifications"), true);
		},
		getSplashScreen: function ()
		{
			return toBoolean (this .getBrowser () .getElement () .attr ("splashScreen"), true);
		},
		getTimings: function ()
		{
			return toBoolean (this .getBrowser () .getElement () .attr ("timings"), true);
		},
		getPrimitiveQuality: function ()
		{
			return this .primitiveQuality;
		},
		getShading: function ()
		{
			return this .shading;
		},
		getTextureQuality: function ()
		{
			return this .textureQuality;
		},
		set_splashScreen__: function (splashScreen)
		{
			this .getBrowser () .getElement () .attr ("splashScreen", splashScreen .getValue () ? "true" : "false");
		},
		set_rubberband__: function (rubberband)
		{
			this .getBrowser () .getLocalStorage () ["BrowserOptions.Rubberband"] = rubberband .getValue ();
		},
		set_primitiveQuality__: function (value)
		{
			var
				browser          = this .getBrowser (),
				primitiveQuality = value .getValue () .toUpperCase ();

			browser .getLocalStorage () ["BrowserOptions.PrimitiveQuality"] = primitiveQuality;

			var
				cone     = browser .getConeOptions (),
				cylinder = browser .getCylinderOptions (),
				sphere   = browser .getSphereOptions ();

			switch (primitiveQuality)
			{
				case "LOW":
				{
					if (this .primitiveQuality === PrimitiveQuality .LOW)
						break;

					this .primitiveQuality = PrimitiveQuality .LOW;

					if (browser .setGeometry2DPrimitiveQuality)
						browser .setGeometry2DPrimitiveQuality (this .primitiveQuality);

					cone     .xDimension_ = 16;
					cylinder .xDimension_ = 16;
					sphere   .xDimension_ = 20;
					sphere   .yDimension_ = 9;
					break;
				}
				case "HIGH":
				{
					if (this .primitiveQuality === PrimitiveQuality .HIGH)
						break;

					this .primitiveQuality = PrimitiveQuality .HIGH;

					if (browser .setGeometry2DPrimitiveQuality)
						browser .setGeometry2DPrimitiveQuality (this .primitiveQuality);

					cone     .xDimension_ = 32;
					cylinder .xDimension_ = 32;
					sphere   .xDimension_ = 64;
					sphere   .yDimension_ = 31;
					break;
				}
				default:
				{
					if (this .primitiveQuality === PrimitiveQuality .MEDIUM)
						break;

					this .primitiveQuality = PrimitiveQuality .MEDIUM;

					if (browser .setGeometry2DPrimitiveQuality)
						browser .setGeometry2DPrimitiveQuality (this .primitiveQuality);

					cone     .xDimension_ = 20;
					cylinder .xDimension_ = 20;
					sphere   .xDimension_ = 32;
					sphere   .yDimension_ = 15;
					break;
				}
			}
		},
		set_textureQuality__: function (value)
		{
			var textureQuality = value .getValue () .toUpperCase ();

			this .getBrowser () .getLocalStorage () ["BrowserOptions.TextureQuality"] = textureQuality;

			var textureProperties = this .getBrowser () .getDefaultTextureProperties ();

			switch (textureQuality)
			{
				case "LOW":
				{
					if (this .textureQuality === TextureQuality .LOW)
						break;

					this .textureQuality = TextureQuality .LOW;

					textureProperties .magnificationFilter_ = "AVG_PIXEL";
					textureProperties .minificationFilter_  = "AVG_PIXEL";
					textureProperties .textureCompression_  = "FASTEST";
					textureProperties .generateMipMaps_     = true;

					//glHint (GL_GENERATE_MIPMAP_HINT,        GL_FASTEST);
					//glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);
					break;
				}
				case "HIGH":
				{
					if (this .textureQuality === TextureQuality .HIGH)
						break;

					this .textureQuality = TextureQuality .HIGH;

					textureProperties .magnificationFilter_ = "NICEST";
					textureProperties .minificationFilter_  = "NICEST";
					textureProperties .textureCompression_  = "NICEST";
					textureProperties .generateMipMaps_     = true;
			
					//glHint (GL_GENERATE_MIPMAP_HINT,        GL_NICEST);
					//glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
					break;
				}
				default:
				{
					if (this .textureQuality === TextureQuality .MEDIUM)
						break;

					this .textureQuality = TextureQuality .MEDIUM;

					textureProperties .magnificationFilter_ = "NICEST";
					textureProperties .minificationFilter_  = "AVG_PIXEL_AVG_MIPMAP";
					textureProperties .textureCompression_  = "NICEST";
					textureProperties .generateMipMaps_     = true;

					//glHint (GL_GENERATE_MIPMAP_HINT,        GL_FASTEST);
					//glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);
					break;
				}
			}
		},
		set_shading__: function (value)
		{
			var shading = value .getValue () .toUpperCase ();

			switch (shading)
			{
				case "POINT":
				case "POINTSET":
				{
					this .shading = Shading .POINT;
					break;
				}
				case "WIREFRAME":
				{
					this .shading = Shading .WIREFRAME;
					break;
				}
				case "FLAT":
				{
					this .shading = Shading .FLAT;
					break;
				}
				case "PHONG":
				{
					this .shading = Shading .PHONG;
					break;
				}
				default:
				{
					this .shading = Shading .GOURAUD;
					break;
				}
			}

			this .getBrowser () .setShading (this .shading);
		},
		set_straightenHorizon__: function (straightenHorizon)
		{
			this .getBrowser () .getLocalStorage () ["BrowserOptions.StraightenHorizon"] = straightenHorizon .getValue ();
		},
		set_logarithmicDepthBuffer__: function (logarithmicDepthBuffer)
		{
			var
				browser = this .getBrowser (),
				gl      = browser .getContext ();

			logarithmicDepthBuffer = logarithmicDepthBuffer .getValue () && (gl .getVersion () >= 2 || Boolean (browser .getExtension ("EXT_frag_depth")));

			if (logarithmicDepthBuffer === browser .getRenderingProperties () .LogarithmicDepthBuffer_ .getValue ())
				return;

			browser .getRenderingProperties () .LogarithmicDepthBuffer_ = logarithmicDepthBuffer;

			// Recompile shaders.

			// There's no need to update background shader.

			if (browser .hasPointShader ())
			{
				browser .getPointShader () .parts_ [0] .getValue () .url_ .addEvent ();
				browser .getPointShader () .parts_ [1] .getValue () .url_ .addEvent ();
			}

			if (browser .hasLineShader ())
			{
				browser .getLineShader () .parts_ [0] .getValue () .url_ .addEvent ();
				browser .getLineShader () .parts_ [1] .getValue () .url_ .addEvent ();
			}

			if (browser .hasGouraudShader ())
			{
				browser .getGouraudShader () .parts_ [0] .getValue () .url_ .addEvent ();
				browser .getGouraudShader () .parts_ [1] .getValue () .url_ .addEvent ();
			}
	
			if (browser .hasPhongShader ())
			{
				browser .getPhongShader () .parts_ [0] .getValue () .url_ .addEvent ();
				browser .getPhongShader () .parts_ [1] .getValue () .url_ .addEvent ();
			}
	
			if (browser .hasShadowShader ())
			{
				browser .getShadowShader () .parts_ [0] .getValue () .url_ .addEvent ();
				browser .getShadowShader () .parts_ [1] .getValue () .url_ .addEvent ();
			}
		},
	});

	return BrowserOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/BrowserProperties',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBaseNode, 
          X3DConstants)
{
"use strict";
	
	function BrowserProperties (executionContext)
	{
		X3DBaseNode .call (this, executionContext);
	}

	BrowserProperties .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: BrowserProperties,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ABSTRACT_NODES",        new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "CONCRETE_NODES",        new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "EXTERNAL_INTERACTIONS", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "PROTOTYPE_CREATE",      new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "DOM_IMPORT",            new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "XML_ENCODING",          new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "CLASSIC_VRML_ENCODING", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "BINARY_ENCODING",       new Fields .SFBool ()),
		]),
		getTypeName: function ()
		{
			return "BrowserProperties";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "browserProperties";
		},
	});

	return BrowserProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/RenderingProperties',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBaseNode, 
          X3DConstants)
{
"use strict";
	
	function RenderingProperties (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .addAlias ("AntiAliased", this .Antialiased_);
	}

	RenderingProperties .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: RenderingProperties,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .outputOnly, "Shading",                new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .outputOnly, "MaxTextureSize",         new Fields .SFInt32 ()),
			new X3DFieldDefinition (X3DConstants .outputOnly, "TextureUnits",           new Fields .SFInt32 ()),
			new X3DFieldDefinition (X3DConstants .outputOnly, "MaxLights",              new Fields .SFInt32 ()),
			new X3DFieldDefinition (X3DConstants .outputOnly, "Antialiased",            new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .outputOnly, "ColorDepth",             new Fields .SFInt32 ()),
			new X3DFieldDefinition (X3DConstants .outputOnly, "TextureMemory",          new Fields .SFDouble ()),
			new X3DFieldDefinition (X3DConstants .outputOnly, "LogarithmicDepthBuffer", new Fields .SFBool (false)),
		]),
		getTypeName: function ()
		{
			return "RenderingProperties";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "renderingProperties";
		},
		initialize: function ()
		{
			X3DBaseNode .prototype .initialize .call (this);

			var browser = this .getBrowser ();

			this .MaxTextureSize_ = browser .getMaxTextureSize ();
			this .TextureUnits_   = browser .getCombinedTextureUnits ();
			this .MaxLights_      = browser .getMaxLights ();
			this .ColorDepth_     = browser .getColorDepth ();
			this .TextureMemory_  = browser .getTextureMemory ();

			browser .getBrowserOptions () .Shading_ .addInterest ("set_shading__", this);

			this .set_shading__ (browser .getBrowserOptions () .Shading_);
		},
		set_shading__: function (shading)
		{
			this .Shading_ = shading;
		},
	});

	return RenderingProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/Notification',[
	"jquery",
	"x_ite/Fields/SFString",
	"x_ite/Basic/X3DBaseNode",
],
function ($,
          SFString,
          X3DBaseNode)
{
"use strict";
	
	$.fn.textWidth = function (string)
	{
		var children = $(this) .children ();
		var html     = $(this) .html ();
		var span     = '<span>' + html + '</span>';
		$(this) .html (span);
		var width = $(this) .find ('span:first') .width ();
		$(this) .empty ();
		$(this) .append (children);
		return width;
	};

   function Notification (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .addChildObjects ("string", new SFString ());
	}

	Notification .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: Notification,
		getTypeName: function ()
		{
			return "Notification";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		initialize: function ()
		{
			X3DBaseNode .prototype .initialize .call (this);

			this .element = $("<div></div>")
				.addClass ("x_ite-private-notification")
				.appendTo (this .getBrowser () .getElement () .find (".x_ite-private-surface"))
				.animate ({ width: 0 });

			$("<span></span>") .appendTo (this .element);

			this .string_ .addInterest ("set_string__", this);
		},
		set_string__: function ()
		{
			if (! this .getBrowser () .getBrowserOptions () .getNotifications ())
				return;

			if (this .string_ .length === 0)
				return;

			this .element .children () .text (this .string_ .getValue ());

			this .element 
				.stop (true, true)
				.fadeIn (0)
				.animate ({ width: this .element .textWidth () })
				.animate ({ "delay": 1 }, 5000)
				.animate ({ width: 0 })
				.fadeOut (0);
		},
	});

	return Notification;
});

/**
 * @license text 2.0.15 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/text/LICENSE
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text/text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    function useDefault(value, defaultValue) {
        return value === undefined || value === '' ? defaultValue : value;
    }

    //Allow for default ports for http and https.
    function isSamePort(protocol1, port1, protocol2, port2) {
        if (port1 === port2) {
            return true;
        } else if (protocol1 === protocol2) {
            if (protocol1 === 'http') {
                return useDefault(port1, '80') === useDefault(port2, '80');
            } else if (protocol1 === 'https') {
                return useDefault(port1, '443') === useDefault(port2, '443');
            }
        }
        return false;
    }

    text = {
        version: '2.0.15',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || isSamePort(uProtocol, uPort, protocol, port));
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

define('text', ['text/text'], function (main) { return main; });


define('text/text!locale/de.po',[],function () { return 'msgid ""\nmsgstr ""\n"Project-Id-Version: X_ITE\\n"\n"POT-Creation-Date: 2015-12-23 04:56+0100\\n"\n"PO-Revision-Date: 2015-12-23 04:57+0100\\n"\n"Last-Translator: Holger Seelig <holger.seelig@yahoo.de>\\n"\n"Language-Team: \\n"\n"Language: de\\n"\n"MIME-Version: 1.0\\n"\n"Content-Type: text/plain; charset=UTF-8\\n"\n"Content-Transfer-Encoding: 8bit\\n"\n"X-Generator: Poedit 1.8.4\\n"\n"X-Poedit-Basepath: ../x_ite\\n"\n"Plural-Forms: nplurals=2; plural=(n != 1);\\n"\n"X-Poedit-SourceCharset: UTF-8\\n"\n"X-Poedit-SearchPath-0: .\\n"\n\n#: Browser/Core/BrowserTimings.js:96\nmsgid "Less Properties"\nmsgstr "Weniger Eigenschaften"\n\n#: Browser/Core/BrowserTimings.js:98\nmsgid "More Properties"\nmsgstr "Mehr Eigenschaften"\n\n#: Browser/Core/BrowserTimings.js:124\nmsgid "Frame rate"\nmsgstr "Bildrate"\n\n#: Browser/Core/BrowserTimings.js:124\nmsgid "fps"\nmsgstr "BpS"\n\n#: Browser/Core/BrowserTimings.js:125\nmsgid "Speed"\nmsgstr "Geschwindigkeit"\n\n#: Browser/Core/BrowserTimings.js:125\nmsgid "m/s"\nmsgstr ""\n\n#: Browser/Core/BrowserTimings.js:125\nmsgid "km/h"\nmsgstr ""\n\n#: Browser/Core/BrowserTimings.js:150\nmsgid "Browser"\nmsgstr ""\n\n#: Browser/Core/BrowserTimings.js:150 Browser/Core/BrowserTimings.js:151\n#: Browser/Core/BrowserTimings.js:152 Browser/Core/BrowserTimings.js:153\n#: Browser/Core/BrowserTimings.js:154 Browser/Core/BrowserTimings.js:155\n#: Browser/Core/BrowserTimings.js:156\nmsgid "ms"\nmsgstr ""\n\n#: Browser/Core/BrowserTimings.js:151\nmsgid "X3D"\nmsgstr ""\n\n#: Browser/Core/BrowserTimings.js:152\nmsgid "Routing"\nmsgstr "Routen"\n\n#: Browser/Core/BrowserTimings.js:153\nmsgid "Pointer"\nmsgstr "Zeigegerät"\n\n#: Browser/Core/BrowserTimings.js:154\nmsgid "Camera"\nmsgstr "Kamera"\n\n#: Browser/Core/BrowserTimings.js:155\nmsgid "Collision"\nmsgstr "Kollision"\n\n#: Browser/Core/BrowserTimings.js:156\nmsgid "Display"\nmsgstr "Anzeige"\n\n#: Browser/Core/BrowserTimings.js:157\nmsgid "Shapes"\nmsgstr "Formen"\n\n#: Browser/Core/BrowserTimings.js:158\nmsgid "Sensors"\nmsgstr "Sensoren"\n\n#: Browser/Core/BrowserTimings.js:163 Browser/Core/ContextMenu.js:210\nmsgid "Browser Timings"\nmsgstr "Zeitberechnung"\n\n#: Browser/Core/ContextMenu.js:19\nmsgid "X_ITE Browser"\nmsgstr ""\n\n#: Browser/Core/ContextMenu.js:59\nmsgid "Viewpoints"\nmsgstr "Ansichtspunkte"\n\n#: Browser/Core/ContextMenu.js:87\nmsgid "Available Viewers"\nmsgstr "Verfügbare Betrachter"\n\n#: Browser/Core/ContextMenu.js:145\nmsgid "Straighten Horizon"\nmsgstr "Horizont gerade richten"\n\n#: Browser/Core/ContextMenu.js:95 Browser/Core/ContextMenu.js:107\n#: Browser/Core/ContextMenu.js:121 Browser/Core/ContextMenu.js:135\nmsgid "Primitive Quality"\nmsgstr "Qualität der Grundobjekte"\n\n#: Browser/Core/ContextMenu.js:99 Browser/Core/ContextMenu.js:147\nmsgid "High"\nmsgstr "Hoch"\n\n#: Browser/Core/ContextMenu.js:107 Browser/Core/ContextMenu.js:155\nmsgid "high"\nmsgstr "hoch"\n\n#: Browser/Core/ContextMenu.js:113 Browser/Core/ContextMenu.js:161\nmsgid "Medium"\nmsgstr "Mittel"\n\n#: Browser/Core/ContextMenu.js:121 Browser/Core/ContextMenu.js:169\nmsgid "medium"\nmsgstr "mittel"\n\n#: Browser/Core/ContextMenu.js:127 Browser/Core/ContextMenu.js:175\nmsgid "Low"\nmsgstr "Niedrig"\n\n#: Browser/Core/ContextMenu.js:135 Browser/Core/ContextMenu.js:183\nmsgid "low"\nmsgstr "niedrig"\n\n#: Browser/Core/ContextMenu.js:143 Browser/Core/ContextMenu.js:155\n#: Browser/Core/ContextMenu.js:169 Browser/Core/ContextMenu.js:183\nmsgid "Texture Quality"\nmsgstr "Textur Qualität"\n\n#: Browser/Core/ContextMenu.js:191\nmsgid "Display Rubberband"\nmsgstr "Gummiband anzeigen"\n\n#: Browser/Core/ContextMenu.js:202 Browser/Core/ContextMenu.js:204\nmsgid "Rubberband"\nmsgstr "Gummiband"\n\n#: Browser/Core/ContextMenu.js:202\nmsgid "on"\nmsgstr "an"\n\n#: Browser/Core/ContextMenu.js:204\nmsgid "off"\nmsgstr "aus"\n\n#: Browser/Core/ContextMenu.js:225\nmsgid "Mute Browser"\nmsgstr "Browser stumm schalten"\n\n#: Browser/Core/ContextMenu.js:233\nmsgid "Browser muted"\nmsgstr "Browser stumm geschalten"\n\n#: Browser/Core/ContextMenu.js:233\nmsgid "Browser unmuted"\nmsgstr "Browser Ton an"\n\n#: Browser/Core/ContextMenu.js:239\nmsgid "Leave Fullscreen"\nmsgstr "Vollbild verlassen"\n\n#: Browser/Core/ContextMenu.js:239\nmsgid "Fullscreen"\nmsgstr "Vollbild"\n\n#: Browser/Core/ContextMenu.js:249\nmsgid "About X_ITE"\nmsgstr "Über X_ITE"\n\n#: Browser/Core/ContextMenu.js:342\nmsgid "Examine Viewer"\nmsgstr "Untersuchen"\n\n#: Browser/Core/ContextMenu.js:344\nmsgid "Walk Viewer"\nmsgstr "Laufen"\n\n#: Browser/Core/ContextMenu.js:346\nmsgid "Fly Viewer"\nmsgstr "Fliegen"\n\n#: Browser/Core/ContextMenu.js:348\nmsgid "Plane Viewer"\nmsgstr "Ebenen Betrachter"\n\n#: Browser/Core/ContextMenu.js:350\n#, fuzzy\nmsgid "Look At Viewer"\nmsgstr "Auf Objekte zielen"\n\n#: Browser/Core/ContextMenu.js:352\nmsgid "None Viewer"\nmsgstr "Kein Betrachter"\n\n#: Browser/Networking/X3DNetworkingContext.js:101\n#, javascript-format\nmsgid "Loading %d file"\nmsgstr "Lade %d Datei"\n\n#: Browser/Networking/X3DNetworkingContext.js:101\n#, javascript-format\nmsgid "Loading %d files"\nmsgstr "Lade %d Dateien"\n\n#: Browser/Networking/X3DNetworkingContext.js:104\nmsgid "Loading done"\nmsgstr "Fertig mit Laden"\n\n#: Browser/X3DBrowser.js:313\nmsgid "Failed loading world."\nmsgstr "Laden der Dateien fehlgeschlagen."\n\n#~ msgid "Look At"\n#~ msgstr "Auf Objekte zielen"\n';});


define('text/text!locale/fr.po',[],function () { return 'msgid ""\nmsgstr ""\n"Project-Id-Version: X_ITE\\n"\n"POT-Creation-Date: 2015-12-23 04:58+0100\\n"\n"PO-Revision-Date: 2015-12-23 05:07+0100\\n"\n"Last-Translator: Holger Seelig <holger.seelig@yahoo.de>\\n"\n"Language-Team: \\n"\n"Language: fr\\n"\n"MIME-Version: 1.0\\n"\n"Content-Type: text/plain; charset=UTF-8\\n"\n"Content-Transfer-Encoding: 8bit\\n"\n"X-Generator: Poedit 1.8.4\\n"\n"X-Poedit-Basepath: ../x_ite\\n"\n"Plural-Forms: nplurals=2; plural=(n != 1);\\n"\n"X-Poedit-SourceCharset: UTF-8\\n"\n"X-Poedit-SearchPath-0: .\\n"\n\n#: Browser/Core/BrowserTimings.js:96\nmsgid "Less Properties"\nmsgstr "Moins de propriétés"\n\n#: Browser/Core/BrowserTimings.js:98\nmsgid "More Properties"\nmsgstr "Plus de propriétés"\n\n#: Browser/Core/BrowserTimings.js:124\nmsgid "Frame rate"\nmsgstr "Fréquence"\n\n#: Browser/Core/BrowserTimings.js:124\nmsgid "fps"\nmsgstr "fps"\n\n#: Browser/Core/BrowserTimings.js:125\nmsgid "Speed"\nmsgstr "Vélocité"\n\n#: Browser/Core/BrowserTimings.js:125\nmsgid "m/s"\nmsgstr ""\n\n#: Browser/Core/BrowserTimings.js:125\nmsgid "km/h"\nmsgstr ""\n\n#: Browser/Core/BrowserTimings.js:150\n#, fuzzy\nmsgid "Browser"\nmsgstr "X_ITE Navigateur"\n\n#: Browser/Core/BrowserTimings.js:150 Browser/Core/BrowserTimings.js:151\n#: Browser/Core/BrowserTimings.js:152 Browser/Core/BrowserTimings.js:153\n#: Browser/Core/BrowserTimings.js:154 Browser/Core/BrowserTimings.js:155\n#: Browser/Core/BrowserTimings.js:156\nmsgid "ms"\nmsgstr ""\n\n#: Browser/Core/BrowserTimings.js:151\nmsgid "X3D"\nmsgstr ""\n\n#: Browser/Core/BrowserTimings.js:152\nmsgid "Routing"\nmsgstr "Routes"\n\n#: Browser/Core/BrowserTimings.js:153\nmsgid "Pointer"\nmsgstr "Pointeur"\n\n#: Browser/Core/BrowserTimings.js:154\nmsgid "Camera"\nmsgstr "Caméra"\n\n#: Browser/Core/BrowserTimings.js:155\nmsgid "Collision"\nmsgstr "Collision"\n\n#: Browser/Core/BrowserTimings.js:156\nmsgid "Display"\nmsgstr "Visualisation"\n\n#: Browser/Core/BrowserTimings.js:157\nmsgid "Shapes"\nmsgstr "Formes"\n\n#: Browser/Core/BrowserTimings.js:158\nmsgid "Sensors"\nmsgstr "Senseurs"\n\n#: Browser/Core/BrowserTimings.js:163 Browser/Core/ContextMenu.js:210\nmsgid "Browser Timings"\nmsgstr "Calcul du temps"\n\n#: Browser/Core/ContextMenu.js:19\nmsgid "X_ITE Browser"\nmsgstr "X_ITE Navigateur"\n\n#: Browser/Core/ContextMenu.js:59\nmsgid "Viewpoints"\nmsgstr "Points de vue"\n\n#: Browser/Core/ContextMenu.js:87\nmsgid "Available Viewers"\nmsgstr "Visionneurs disponibles"\n\n#: Browser/Core/ContextMenu.js:145\nmsgid "Straighten Horizon"\nmsgstr "Redresser l\'horizon"\n\n#: Browser/Core/ContextMenu.js:95 Browser/Core/ContextMenu.js:107\n#: Browser/Core/ContextMenu.js:121 Browser/Core/ContextMenu.js:135\nmsgid "Primitive Quality"\nmsgstr "Qualité des objets simples"\n\n#: Browser/Core/ContextMenu.js:99 Browser/Core/ContextMenu.js:147\nmsgid "High"\nmsgstr "Haut"\n\n#: Browser/Core/ContextMenu.js:107 Browser/Core/ContextMenu.js:155\nmsgid "high"\nmsgstr "haut"\n\n#: Browser/Core/ContextMenu.js:113 Browser/Core/ContextMenu.js:161\nmsgid "Medium"\nmsgstr "Moyenne"\n\n#: Browser/Core/ContextMenu.js:121 Browser/Core/ContextMenu.js:169\nmsgid "medium"\nmsgstr "moyenne"\n\n#: Browser/Core/ContextMenu.js:127 Browser/Core/ContextMenu.js:175\nmsgid "Low"\nmsgstr "Faible"\n\n#: Browser/Core/ContextMenu.js:135 Browser/Core/ContextMenu.js:183\nmsgid "low"\nmsgstr "faible"\n\n#: Browser/Core/ContextMenu.js:143 Browser/Core/ContextMenu.js:155\n#: Browser/Core/ContextMenu.js:169 Browser/Core/ContextMenu.js:183\nmsgid "Texture Quality"\nmsgstr "Qualité des textures"\n\n#: Browser/Core/ContextMenu.js:191\nmsgid "Display Rubberband"\nmsgstr "Présenter le bande élastique"\n\n#: Browser/Core/ContextMenu.js:202 Browser/Core/ContextMenu.js:204\nmsgid "Rubberband"\nmsgstr "Bande élastique"\n\n#: Browser/Core/ContextMenu.js:202\nmsgid "on"\nmsgstr "marche"\n\n#: Browser/Core/ContextMenu.js:204\nmsgid "off"\nmsgstr "arrêt"\n\n#: Browser/Core/ContextMenu.js:225\nmsgid "Mute Browser"\nmsgstr "Rendre navigateur muet"\n\n#: Browser/Core/ContextMenu.js:233\nmsgid "Browser muted"\nmsgstr "Navigateur muet"\n\n#: Browser/Core/ContextMenu.js:233\nmsgid "Browser unmuted"\nmsgstr "Son de navigateur réactivé"\n\n#: Browser/Core/ContextMenu.js:239\nmsgid "Leave Fullscreen"\nmsgstr "Sortie en plein écran"\n\n#: Browser/Core/ContextMenu.js:239\nmsgid "Fullscreen"\nmsgstr "Plein écran"\n\n#: Browser/Core/ContextMenu.js:249\nmsgid "About X_ITE"\nmsgstr "À propos de X_ITE"\n\n#: Browser/Core/ContextMenu.js:342\nmsgid "Examine Viewer"\nmsgstr "Examiner"\n\n#: Browser/Core/ContextMenu.js:344\nmsgid "Walk Viewer"\nmsgstr "Aller"\n\n#: Browser/Core/ContextMenu.js:346\nmsgid "Fly Viewer"\nmsgstr "Voler"\n\n#: Browser/Core/ContextMenu.js:348\nmsgid "Plane Viewer"\nmsgstr "Visionneur de la plaine"\n\n#: Browser/Core/ContextMenu.js:350\n#, fuzzy\nmsgid "Look At Viewer"\nmsgstr "Regarder un objet de près"\n\n#: Browser/Core/ContextMenu.js:352\nmsgid "None Viewer"\nmsgstr "Pas de visionneur"\n\n#: Browser/Networking/X3DNetworkingContext.js:101\n#, javascript-format\nmsgid "Loading %d file"\nmsgstr "Télécharger %d fichier"\n\n#: Browser/Networking/X3DNetworkingContext.js:101\n#, javascript-format\nmsgid "Loading %d files"\nmsgstr "Télécharger %d fichiers"\n\n#: Browser/Networking/X3DNetworkingContext.js:104\nmsgid "Loading done"\nmsgstr "Téléchargement fini"\n\n#: Browser/X3DBrowser.js:313\nmsgid "Failed loading world."\nmsgstr "Le chargement des fichiers ayant échoué."\n\n#~ msgid "Look At"\n#~ msgstr "Regarder un objet de près"\n';});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('locale/gettext',[
	"text!locale/de.po",
	"text!locale/fr.po",
],
function (de, fr)
{
"use strict";

	function execAll (regex, string)
	{
		var
			match   = null,
			matches = [ ];

		while (match = regex .exec (string))
			matches .push (match);
	
		return matches;
	}

	function getLanguage ()
	{
		for (var i = 0; i < navigator .languages; ++ i)
		{
			var language = navigator .languages [i] .split ("-") [0];
	
			if (locales [language])
				return language;
		}

		return (navigator .language || navigator .userLanguage) .split ("-") [0];
	}

	function setLocale (language)
	{
		if (locales [language])
		{
			var
				matches = execAll (msg, locales [language]),
				locale  = locales [language] = { };
	
			for (var i = 0, length = matches .length; i < length; ++ i)
			{
				if (matches [i] [2] .length)
					locale [matches [i] [1]] = matches [i] [2];
			}
		}
	}

	var locales =
	{
		en: "C",
		de: de,
		fr: fr,
	};

	var
		msg      = /msgid\s+"(.*?)"\nmsgstr\s+"(.*?)"\n/g,
		language = getLanguage ();

	setLocale (language);

	function gettext (string)
	{
		var locale = locales [language];

		if (locale === undefined)
			return string;

		var translation = locale [string];

		if (translation === undefined)
			return string;

		return translation;
	}

	return gettext;
});
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/BrowserTimings',[
	"jquery",
	"x_ite/Fields/SFBool",
	"x_ite/Basic/X3DBaseNode",
	"locale/gettext",
],
function ($,
          SFBool,
          X3DBaseNode,
          _)
{
"use strict";

   function f2 (n) { return Math .floor (n * 100) / 100; }

	function BrowserTimings (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .addChildObjects ("enabled", new SFBool ());
	}

	BrowserTimings .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: BrowserTimings,
		getTypeName: function ()
		{
			return "BrowserTimings";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "browserTimings";
		},
		initialize: function ()
		{
			X3DBaseNode .prototype .initialize .call (this);

			this .enabled_ .addInterest ("set_enabled__", this);

			this .localeOptions = { minimumFractionDigits: 2, maximumFractionDigits: 2 };
			this .type          = this .getBrowser () .getLocalStorage () ["BrowserTimings.type"] || "LESS";
			this .startTime     = 0;
			this .frames        = 0;

			this .element = $("<div></div>") .addClass ("x_ite-private-browser-timings") .appendTo (this .getBrowser () .getElement () .find (".x_ite-private-surface"));
			this .table   = $("<table></table>") .appendTo (this .element);
			this .header  = $("<thead></thead>") .append ($("<tr></tr>") .append ($("<th colspan='2'></th>"))) .appendTo (this .table);
			this .body    = $("<tbody></tbody>") .appendTo (this .table);
			this .footer  = $("<tfoot></tfoot>") .append ($("<tr></tr>") .append ($("<td colspan='2'></td>"))) .appendTo (this .table);
			this .button  = $("<button></button>") .attr ("type", "button") .click (this .set_type__ .bind (this)) .appendTo (this .footer .find ("td"));
			this .rows    = [ ];

			this .set_button__ ();

			if (this .getBrowser () .getLocalStorage () ["BrowserTimings.enabled"])
				this .enabled_ = true;
		},
		setEnabled: function (value)
		{
			this .enabled_ = value;
		},
		getEnabled: function ()
		{
			return this .enabled_ .getValue ();
		},
		set_enabled__: function (enabled)
		{
			if (! this .getBrowser () .getBrowserOptions () .getTimings ())
				return;

			this .getBrowser () .getLocalStorage () ["BrowserTimings.enabled"] = enabled .getValue ();

			if (enabled .getValue ())
			{
				this .element .fadeIn ();
				this .getBrowser () .prepareEvents () .addInterest ("update", this);
				this .update ();
			}
			else
			{
				this .element .fadeOut ();
				this .getBrowser () .prepareEvents () .removeInterest ("update", this);
			}
		},
		set_type__: function ()
		{
			if (this .type === "MORE")
				this .type = "LESS";
			else
				this .type = "MORE";

			this .getBrowser () .getLocalStorage () ["BrowserTimings.type"] = this .type;

			this .set_button__ ();
			this .build ();
		},
		set_button__: function ()
		{
			if (this .type === "MORE")
				this .button .text (_("Less Properties"));
			else
				this .button .text (_("More Properties"));
		},
		update: function ()
		{
			var currentTime = this .getBrowser () .getCurrentTime ();

			if (currentTime - this .startTime > 1)
			{
			   this .build ();

				this .frames    = 0;
				this .startTime = currentTime;
			}
			else
				++ this .frames;
		},
		build: function ()
		{
			var
				browser     = this .getBrowser (),
				currentTime = browser .getCurrentTime (),
				language    = navigator .language || navigator .userLanguage,
				fixed       = this .localeOptions,
				rows        = this .rows,
				r           = 0;

			rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Frame rate") + ":")) .append ($("<td></td>") .text (f2(this .frames / (currentTime - this .startTime)) .toLocaleString (language, fixed) + " " + _("fps")));
			rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Speed")      + ":")) .append ($("<td></td>") .text (f2(this .getSpeed (browser .currentSpeed))         .toLocaleString (language, fixed) + " " + this .getSpeedUnit (browser .currentSpeed)));

			if (this .type === "MORE")
			{
				var
					layers            = browser .getWorld () .getLayerSet () .getLayers (),
					activeLayer       = browser .getActiveLayer (),
					systemTime        = browser .systemTime,
					navigationTime    = activeLayer && browser .getCollisionCount () ? activeLayer .collisionTime : 0,
					collisionTime     = browser .collisionTime + navigationTime,
					routingTime       = browser .browserTime - (browser .cameraTime + browser .collisionTime + browser .displayTime + navigationTime),
					prepareEvents     = browser .prepareEvents () .getInterests () .size - 1,
					sensors           = browser .sensorEvents () .getInterests () .size,
					opaqueShapes      = 0,
					transparentShapes = 0;

				for (var l = 0; l < layers .length; ++ l)
				{
					var layer = layers [l];
					opaqueShapes      += layer .numOpaqueShapes;
					transparentShapes += layer .numTransparentShapes;
				}

			   rows [1] .addClass ("x_ite-private-more");

				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Browser")   + ":")) .append ($("<td></td>") .text (f2(systemTime)           .toLocaleString (language, fixed) + " " + _("ms")));
				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("X3D")       + ":")) .append ($("<td></td>") .text (f2(browser .browserTime) .toLocaleString (language, fixed) + " " + _("ms")));
				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Routing")   + ":")) .append ($("<td></td>") .text (f2(routingTime)          .toLocaleString (language, fixed) + " " + _("ms")));
				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Pointer")   + ":")) .append ($("<td></td>") .text (f2(browser .pointerTime) .toLocaleString (language, fixed) + " " + _("ms")));
				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Camera")    + ":")) .append ($("<td></td>") .text (f2(browser .cameraTime)  .toLocaleString (language, fixed) + " " + _("ms")));
				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Picking")   + ":")) .append ($("<td></td>") .text (f2(browser .pickingTime) .toLocaleString (language, fixed) + " " + _("ms")));
				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Collision") + ":")) .append ($("<td></td>") .text (f2(collisionTime)        .toLocaleString (language, fixed) + " " + _("ms")));
				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Display")   + ":")) .append ($("<td></td>") .text (f2(browser .displayTime) .toLocaleString (language, fixed) + " " + _("ms")));
				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Shapes")    + ":")) .append ($("<td></td>") .text (opaqueShapes + " + " + transparentShapes));
				rows [r++] = $("<tr></tr>") .append ($("<td></td>") .text (_("Sensors")   + ":")) .append ($("<td></td>") .text (prepareEvents + sensors));
			}

			rows .length = r;

			this .header .find ("th") .text (_("Browser Timings"));
			this .body .empty ();
			this .body .append (rows);
		},
		getSpeed: function (speed)
		{
			if (speed < 15)
				return speed;

			return speed * 3.6;
		},
		getSpeedUnit: function (speed)
		{
			if (speed < 15)
				return _("m/s");

			return _("km/h");
		},
	});

	return BrowserTimings;
});

/**
 * jQuery contextMenu v2.9.2 - Plugin for simple contextMenu handling
 *
 * Version: v2.9.2
 *
 * Authors: Björn Brala (SWIS.nl), Rodney Rehm, Addy Osmani (patches for FF)
 * Web: http://swisnl.github.io/jQuery-contextMenu/
 *
 * Copyright (c) 2011-2020 SWIS BV and contributors
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 * Date: 2020-05-13T13:55:36.983Z
 */

// jscs:disable
/* jshint ignore:start */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as anonymous module.
        define('contextMenu/dist/jquery.contextMenu',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node / CommonJS
        factory(require('jquery'));
    } else {
        // Browser globals.
        factory(jQuery);
    }
})(function ($) {

    'use strict';

    // TODO: -
    // ARIA stuff: menuitem, menuitemcheckbox und menuitemradio
    // create <menu> structure if $.support[htmlCommand || htmlMenuitem] and !opt.disableNative

    // determine html5 compatibility
    $.support.htmlMenuitem = ('HTMLMenuItemElement' in window);
    $.support.htmlCommand = ('HTMLCommandElement' in window);
    $.support.eventSelectstart = ('onselectstart' in document.documentElement);
    /* // should the need arise, test for css user-select
     $.support.cssUserSelect = (function(){
     var t = false,
     e = document.createElement('div');

     $.each('Moz|Webkit|Khtml|O|ms|Icab|'.split('|'), function(i, prefix) {
     var propCC = prefix + (prefix ? 'U' : 'u') + 'serSelect',
     prop = (prefix ? ('-' + prefix.toLowerCase() + '-') : '') + 'user-select';

     e.style.cssText = prop + ': text;';
     if (e.style[propCC] == 'text') {
     t = true;
     return false;
     }

     return true;
     });

     return t;
     })();
     */


    if (!$.ui || !$.widget) {
        // duck punch $.cleanData like jQueryUI does to get that remove event
        $.cleanData = (function (orig) {
            return function (elems) {
                var events, elem, i;
                for (i = 0; elems[i] != null; i++) {
                    elem = elems[i];
                    try {
                        // Only trigger remove when necessary to save time
                        events = $._data(elem, 'events');
                        if (events && events.remove) {
                            $(elem).triggerHandler('remove');
                        }

                        // Http://bugs.jquery.com/ticket/8235
                    } catch (e) {
                    }
                }
                orig(elems);
            };
        })($.cleanData);
    }
    /* jshint ignore:end */
    // jscs:enable

    var // currently active contextMenu trigger
        $currentTrigger = null,
        // is contextMenu initialized with at least one menu?
        initialized = false,
        // window handle
        $win = $(window),
        // number of registered menus
        counter = 0,
        // mapping selector to namespace
        namespaces = {},
        // mapping namespace to options
        menus = {},
        // custom command type handlers
        types = {},
        // default values
        defaults = {
            // selector of contextMenu trigger
            selector: null,
            // where to append the menu to
            appendTo: null,
            // method to trigger context menu ["right", "left", "hover"]
            trigger: 'right',
            // hide menu when mouse leaves trigger / menu elements
            autoHide: false,
            // ms to wait before showing a hover-triggered context menu
            delay: 200,
            // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu
            // as long as the trigger happened on one of the trigger-element's child nodes
            reposition: true,
            // Flag denoting if a second trigger should close the menu, as long as
            // the trigger happened on one of the trigger-element's child nodes.
            // This overrides the reposition option.
            hideOnSecondTrigger: false,

            //ability to select submenu
            selectableSubMenu: false,

            // Default classname configuration to be able avoid conflicts in frameworks
            classNames: {
                hover: 'context-menu-hover', // Item hover
                disabled: 'context-menu-disabled', // Item disabled
                visible: 'context-menu-visible', // Item visible
                notSelectable: 'context-menu-not-selectable', // Item not selectable

                icon: 'context-menu-icon',
                iconEdit: 'context-menu-icon-edit',
                iconCut: 'context-menu-icon-cut',
                iconCopy: 'context-menu-icon-copy',
                iconPaste: 'context-menu-icon-paste',
                iconDelete: 'context-menu-icon-delete',
                iconAdd: 'context-menu-icon-add',
                iconQuit: 'context-menu-icon-quit',
                iconLoadingClass: 'context-menu-icon-loading'
            },

            // determine position to show menu at
            determinePosition: function ($menu) {
                // position to the lower middle of the trigger element
                if ($.ui && $.ui.position) {
                    // .position() is provided as a jQuery UI utility
                    // (...and it won't work on hidden elements)
                    $menu.css('display', 'block').position({
                        my: 'center top',
                        at: 'center bottom',
                        of: this,
                        offset: '0 5',
                        collision: 'fit'
                    }).css('display', 'none');
                } else {
                    // determine contextMenu position
                    var offset = this.offset();
                    offset.top += this.outerHeight();
                    offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;
                    $menu.css(offset);
                }
            },
            // position menu
            position: function (opt, x, y) {
                var offset;
                // determine contextMenu position
                if (!x && !y) {
                    opt.determinePosition.call(this, opt.$menu);
                    return;
                } else if (x === 'maintain' && y === 'maintain') {
                    // x and y must not be changed (after re-show on command click)
                    offset = opt.$menu.position();
                } else {
                    // x and y are given (by mouse event)
                    var offsetParentOffset = opt.$menu.offsetParent().offset();
                    offset = {top: y - offsetParentOffset.top, left: x -offsetParentOffset.left};
                }

                // correct offset if viewport demands it
                var bottom = $win.scrollTop() + $win.height(),
                    right = $win.scrollLeft() + $win.width(),
                    height = opt.$menu.outerHeight(),
                    width = opt.$menu.outerWidth();

                if (offset.top + height > bottom) {
                    offset.top -= height;
                }

                if (offset.top < 0) {
                    offset.top = 0;
                }

                if (offset.left + width > right) {
                    offset.left -= width;
                }

                if (offset.left < 0) {
                    offset.left = 0;
                }

                opt.$menu.css(offset);
            },
            // position the sub-menu
            positionSubmenu: function ($menu) {
                if (typeof $menu === 'undefined') {
                    // When user hovers over item (which has sub items) handle.focusItem will call this.
                    // but the submenu does not exist yet if opt.items is a promise. just return, will
                    // call positionSubmenu after promise is completed.
                    return;
                }
                if ($.ui && $.ui.position) {
                    // .position() is provided as a jQuery UI utility
                    // (...and it won't work on hidden elements)
                    $menu.css('display', 'block').position({
                        my: 'left top-5',
                        at: 'right top',
                        of: this,
                        collision: 'flipfit fit'
                    }).css('display', '');
                } else {
                    // determine contextMenu position
                    var offset = {
                        top: -9,
                        left: this.outerWidth() - 5
                    };
                    $menu.css(offset);
                }
            },
            // offset to add to zIndex
            zIndex: 1,
            // show hide animation settings
            animation: {
                duration: 50,
                show: 'slideDown',
                hide: 'slideUp'
            },
            // events
            events: {
                preShow: $.noop,
                show: $.noop,
                hide: $.noop,
                activated: $.noop
            },
            // default callback
            callback: null,
            // list of contextMenu items
            items: {}
        },
        // mouse position for hover activation
        hoveract = {
            timer: null,
            pageX: null,
            pageY: null
        },
        // determine zIndex
        zindex = function ($t) {
            var zin = 0,
                $tt = $t;

            while (true) {
                zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0);
                $tt = $tt.parent();
                if (!$tt || !$tt.length || 'html body'.indexOf($tt.prop('nodeName').toLowerCase()) > -1) {
                    break;
                }
            }
            return zin;
        },
        // event handlers
        handle = {
            // abort anything
            abortevent: function (e) {
                e.preventDefault();
                e.stopImmediatePropagation();
            },
            // contextmenu show dispatcher
            contextmenu: function (e) {
                var $this = $(this);

                //Show browser context-menu when preShow returns false
                if (e.data.events.preShow($this,e) === false) {
                    return;
                }

                // disable actual context-menu if we are using the right mouse button as the trigger
                if (e.data.trigger === 'right') {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }

                // abort native-triggered events unless we're triggering on right click
                if ((e.data.trigger !== 'right' && e.data.trigger !== 'demand') && e.originalEvent) {
                    return;
                }

                // Let the current contextmenu decide if it should show or not based on its own trigger settings
                if (typeof e.mouseButton !== 'undefined' && e.data) {
                    if (!(e.data.trigger === 'left' && e.mouseButton === 0) && !(e.data.trigger === 'right' && e.mouseButton === 2)) {
                        // Mouse click is not valid.
                        return;
                    }
                }

                // abort event if menu is visible for this trigger
                if ($this.hasClass('context-menu-active')) {
                    return;
                }

                if (!$this.hasClass('context-menu-disabled')) {
                    // theoretically need to fire a show event at <menu>
                    // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus
                    // var evt = jQuery.Event("show", { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this });
                    // e.data.$menu.trigger(evt);

                    $currentTrigger = $this;
                    if (e.data.build) {
                        var built = e.data.build($currentTrigger, e);
                        // abort if build() returned false
                        if (built === false) {
                            return;
                        }

                        // dynamically build menu on invocation
                        e.data = $.extend(true, {}, defaults, e.data, built || {});

                        // abort if there are no items to display
                        if (!e.data.items || $.isEmptyObject(e.data.items)) {
                            // Note: jQuery captures and ignores errors from event handlers
                            if (window.console) {
                                (console.error || console.log).call(console, 'No items specified to show in contextMenu');
                            }

                            throw new Error('No Items specified');
                        }

                        // backreference for custom command type creation
                        e.data.$trigger = $currentTrigger;

                        op.create(e.data);
                    }
                    op.show.call($this, e.data, e.pageX, e.pageY);
                }
            },
            // contextMenu left-click trigger
            click: function (e) {
                e.preventDefault();
                e.stopImmediatePropagation();
                $(this).trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY}));
            },
            // contextMenu right-click trigger
            mousedown: function (e) {
                // register mouse down
                var $this = $(this);

                // hide any previous menus
                if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {
                    $currentTrigger.data('contextMenu').$menu.trigger('contextmenu:hide');
                }

                // activate on right click
                if (e.button === 2) {
                    $currentTrigger = $this.data('contextMenuActive', true);
                }
            },
            // contextMenu right-click trigger
            mouseup: function (e) {
                // show menu
                var $this = $(this);
                if ($this.data('contextMenuActive') && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass('context-menu-disabled')) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    $currentTrigger = $this;
                    $this.trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY}));
                }

                $this.removeData('contextMenuActive');
            },
            // contextMenu hover trigger
            mouseenter: function (e) {
                var $this = $(this),
                    $related = $(e.relatedTarget),
                    $document = $(document);

                // abort if we're coming from a menu
                if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                    return;
                }

                // abort if a menu is shown
                if ($currentTrigger && $currentTrigger.length) {
                    return;
                }

                hoveract.pageX = e.pageX;
                hoveract.pageY = e.pageY;
                hoveract.data = e.data;
                $document.on('mousemove.contextMenuShow', handle.mousemove);
                hoveract.timer = setTimeout(function () {
                    hoveract.timer = null;
                    $document.off('mousemove.contextMenuShow');
                    $currentTrigger = $this;
                    $this.trigger($.Event('contextmenu', {
                        data: hoveract.data,
                        pageX: hoveract.pageX,
                        pageY: hoveract.pageY
                    }));
                }, e.data.delay);
            },
            // contextMenu hover trigger
            mousemove: function (e) {
                hoveract.pageX = e.pageX;
                hoveract.pageY = e.pageY;
            },
            // contextMenu hover trigger
            mouseleave: function (e) {
                // abort if we're leaving for a menu
                var $related = $(e.relatedTarget);
                if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                    return;
                }

                try {
                    clearTimeout(hoveract.timer);
                } catch (e) {
                }

                hoveract.timer = null;
            },
            // click on layer to hide contextMenu
            layerClick: function (e) {
                var $this = $(this),
                    root = $this.data('contextMenuRoot'),
                    button = e.button,
                    x = e.pageX,
                    y = e.pageY,
                    fakeClick = x === undefined,
                    target,
                    offset;

                e.preventDefault();

                setTimeout(function () {
                    // If the click is not real, things break: https://github.com/swisnl/jQuery-contextMenu/issues/132
                    if(fakeClick){
                        if (root !== null && typeof root !== 'undefined' && root.$menu !== null  && typeof root.$menu !== 'undefined') {
                            root.$menu.trigger('contextmenu:hide');
                        }
                        return;
                    }

                    var $window;
                    var triggerAction = ((root.trigger === 'left' && button === 0) || (root.trigger === 'right' && button === 2));

                    // find the element that would've been clicked, wasn't the layer in the way
                    if (document.elementFromPoint && root.$layer) {
                        root.$layer.hide();
                        target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());

                        // also need to try and focus this element if we're in a contenteditable area,
                        // as the layer will prevent the browser mouse action we want
                        if (target !== null && target.isContentEditable) {
                            var range = document.createRange(),
                                sel = window.getSelection();
                            range.selectNode(target);
                            range.collapse(true);
                            sel.removeAllRanges();
                            sel.addRange(range);
                        }
                        $(target).trigger(e);
                        root.$layer.show();
                    }

                    if (root.hideOnSecondTrigger && triggerAction && root.$menu !== null && typeof root.$menu !== 'undefined') {
                      root.$menu.trigger('contextmenu:hide');
                      return;
                    }

                    if (root.reposition && triggerAction) {
                        if (document.elementFromPoint) {
                            if (root.$trigger.is(target)) {
                                root.position.call(root.$trigger, root, x, y);
                                return;
                            }
                        } else {
                            offset = root.$trigger.offset();
                            $window = $(window);
                            // while this looks kinda awful, it's the best way to avoid
                            // unnecessarily calculating any positions
                            offset.top += $window.scrollTop();
                            if (offset.top <= e.pageY) {
                                offset.left += $window.scrollLeft();
                                if (offset.left <= e.pageX) {
                                    offset.bottom = offset.top + root.$trigger.outerHeight();
                                    if (offset.bottom >= e.pageY) {
                                        offset.right = offset.left + root.$trigger.outerWidth();
                                        if (offset.right >= e.pageX) {
                                            // reposition
                                            root.position.call(root.$trigger, root, x, y);
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (target && triggerAction) {
                        root.$trigger.one('contextmenu:hidden', function () {
                            $(target).contextMenu({x: x, y: y, button: button});
                        });
                    }

                    if (root !== null && typeof root !== 'undefined' && root.$menu !== null  && typeof root.$menu !== 'undefined') {
                        root.$menu.trigger('contextmenu:hide');
                    }
                }, 50);
            },
            // key handled :hover
            keyStop: function (e, opt) {
                if (!opt.isInput) {
                    e.preventDefault();
                }

                e.stopPropagation();
            },
            key: function (e) {

                var opt = {};

                // Only get the data from $currentTrigger if it exists
                if ($currentTrigger) {
                    opt = $currentTrigger.data('contextMenu') || {};
                }
                // If the trigger happen on a element that are above the contextmenu do this
                if (typeof opt.zIndex === 'undefined') {
                    opt.zIndex = 0;
                }
                var targetZIndex = 0;
                var getZIndexOfTriggerTarget = function (target) {
                    if (target.style.zIndex !== '') {
                        targetZIndex = target.style.zIndex;
                    } else {
                        if (target.offsetParent !== null && typeof target.offsetParent !== 'undefined') {
                            getZIndexOfTriggerTarget(target.offsetParent);
                        }
                        else if (target.parentElement !== null && typeof target.parentElement !== 'undefined') {
                            getZIndexOfTriggerTarget(target.parentElement);
                        }
                    }
                };
                getZIndexOfTriggerTarget(e.target);
                // If targetZIndex is heigher then opt.zIndex dont progress any futher.
                // This is used to make sure that if you are using a dialog with a input / textarea / contenteditable div
                // and its above the contextmenu it wont steal keys events
                if (opt.$menu && parseInt(targetZIndex,10) > parseInt(opt.$menu.css("zIndex"),10)) {
                    return;
                }
                switch (e.keyCode) {
                    case 9:
                    case 38: // up
                        handle.keyStop(e, opt);
                        // if keyCode is [38 (up)] or [9 (tab) with shift]
                        if (opt.isInput) {
                            if (e.keyCode === 9 && e.shiftKey) {
                                e.preventDefault();
                                if (opt.$selected) {
                                    opt.$selected.find('input, textarea, select').blur();
                                }
                                if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                    opt.$menu.trigger('prevcommand');
                                }
                                return;
                            } else if (e.keyCode === 38 && opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') {
                                // checkboxes don't capture this key
                                e.preventDefault();
                                return;
                            }
                        } else if (e.keyCode !== 9 || e.shiftKey) {
                            if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                opt.$menu.trigger('prevcommand');
                            }
                            return;
                        }
                        break;
                    // omitting break;
                    // case 9: // tab - reached through omitted break;
                    case 40: // down
                        handle.keyStop(e, opt);
                        if (opt.isInput) {
                            if (e.keyCode === 9) {
                                e.preventDefault();
                                if (opt.$selected) {
                                    opt.$selected.find('input, textarea, select').blur();
                                }
                                if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                    opt.$menu.trigger('nextcommand');
                                }
                                return;
                            } else if (e.keyCode === 40 && opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') {
                                // checkboxes don't capture this key
                                e.preventDefault();
                                return;
                            }
                        } else {
                            if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                opt.$menu.trigger('nextcommand');
                            }
                            return;
                        }
                        break;

                    case 37: // left
                        handle.keyStop(e, opt);
                        if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                            break;
                        }

                        if (!opt.$selected.parent().hasClass('context-menu-root')) {
                            var $parent = opt.$selected.parent().parent();
                            opt.$selected.trigger('contextmenu:blur');
                            opt.$selected = $parent;
                            return;
                        }
                        break;

                    case 39: // right
                        handle.keyStop(e, opt);
                        if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                            break;
                        }

                        var itemdata = opt.$selected.data('contextMenu') || {};
                        if (itemdata.$menu && opt.$selected.hasClass('context-menu-submenu')) {
                            opt.$selected = null;
                            itemdata.$selected = null;
                            itemdata.$menu.trigger('nextcommand');
                            return;
                        }
                        break;

                    case 35: // end
                    case 36: // home
                        if (opt.$selected && opt.$selected.find('input, textarea, select').length) {
                            return;
                        } else {
                            (opt.$selected && opt.$selected.parent() || opt.$menu)
                                .children(':not(.' + opt.classNames.disabled + ', .' + opt.classNames.notSelectable + ')')[e.keyCode === 36 ? 'first' : 'last']()
                                .trigger('contextmenu:focus');
                            e.preventDefault();
                            return;
                        }
                        break;

                    case 13: // enter
                        handle.keyStop(e, opt);
                        if (opt.isInput) {
                            if (opt.$selected && !opt.$selected.is('textarea, select')) {
                                e.preventDefault();
                                return;
                            }
                            break;
                        }
                        if (typeof opt.$selected !== 'undefined' && opt.$selected !== null) {
                            opt.$selected.trigger('mouseup');
                        }
                        return;

                    case 32: // space
                    case 33: // page up
                    case 34: // page down
                        // prevent browser from scrolling down while menu is visible
                        handle.keyStop(e, opt);
                        return;

                    case 27: // esc
                        handle.keyStop(e, opt);
                        if (opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                            opt.$menu.trigger('contextmenu:hide');
                        }
                        return;

                    default: // 0-9, a-z
                        var k = (String.fromCharCode(e.keyCode)).toUpperCase();
                        if (opt.accesskeys && opt.accesskeys[k]) {
                            // according to the specs accesskeys must be invoked immediately
                            opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu ? 'contextmenu:focus' : 'mouseup');
                            return;
                        }
                        break;
                }
                // pass event to selected item,
                // stop propagation to avoid endless recursion
                e.stopPropagation();
                if (typeof opt.$selected !== 'undefined' && opt.$selected !== null) {
                    opt.$selected.trigger(e);
                }
            },
            // select previous possible command in menu
            prevItem: function (e) {
                e.stopPropagation();
                var opt = $(this).data('contextMenu') || {};
                var root = $(this).data('contextMenuRoot') || {};

                // obtain currently selected menu
                if (opt.$selected) {
                    var $s = opt.$selected;
                    opt = opt.$selected.parent().data('contextMenu') || {};
                    opt.$selected = $s;
                }

                var $children = opt.$menu.children(),
                    $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(),
                    $round = $prev;

                // skip disabled or hidden elements
                while ($prev.hasClass(root.classNames.disabled) || $prev.hasClass(root.classNames.notSelectable) || $prev.is(':hidden')) {
                    if ($prev.prev().length) {
                        $prev = $prev.prev();
                    } else {
                        $prev = $children.last();
                    }
                    if ($prev.is($round)) {
                        // break endless loop
                        return;
                    }
                }

                // leave current
                if (opt.$selected) {
                    handle.itemMouseleave.call(opt.$selected.get(0), e);
                }

                // activate next
                handle.itemMouseenter.call($prev.get(0), e);

                // focus input
                var $input = $prev.find('input, textarea, select');
                if ($input.length) {
                    $input.focus();
                }
            },
            // select next possible command in menu
            nextItem: function (e) {
                e.stopPropagation();
                var opt = $(this).data('contextMenu') || {};
                var root = $(this).data('contextMenuRoot') || {};

                // obtain currently selected menu
                if (opt.$selected) {
                    var $s = opt.$selected;
                    opt = opt.$selected.parent().data('contextMenu') || {};
                    opt.$selected = $s;
                }

                var $children = opt.$menu.children(),
                    $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(),
                    $round = $next;

                // skip disabled
                while ($next.hasClass(root.classNames.disabled) || $next.hasClass(root.classNames.notSelectable) || $next.is(':hidden')) {
                    if ($next.next().length) {
                        $next = $next.next();
                    } else {
                        $next = $children.first();
                    }
                    if ($next.is($round)) {
                        // break endless loop
                        return;
                    }
                }

                // leave current
                if (opt.$selected) {
                    handle.itemMouseleave.call(opt.$selected.get(0), e);
                }

                // activate next
                handle.itemMouseenter.call($next.get(0), e);

                // focus input
                var $input = $next.find('input, textarea, select');
                if ($input.length) {
                    $input.focus();
                }
            },
            // flag that we're inside an input so the key handler can act accordingly
            focusInput: function () {
                var $this = $(this).closest('.context-menu-item'),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                root.$selected = opt.$selected = $this;
                root.isInput = opt.isInput = true;
            },
            // flag that we're inside an input so the key handler can act accordingly
            blurInput: function () {
                var $this = $(this).closest('.context-menu-item'),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                root.isInput = opt.isInput = false;
            },
            // :hover on menu
            menuMouseenter: function () {
                var root = $(this).data().contextMenuRoot;
                root.hovering = true;
            },
            // :hover on menu
            menuMouseleave: function (e) {
                var root = $(this).data().contextMenuRoot;
                if (root.$layer && root.$layer.is(e.relatedTarget)) {
                    root.hovering = false;
                }
            },
            // :hover done manually so key handling is possible
            itemMouseenter: function (e) {
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                root.hovering = true;

                // abort if we're re-entering
                if (e && root.$layer && root.$layer.is(e.relatedTarget)) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }

                // make sure only one item is selected
                (opt.$menu ? opt : root).$menu
                    .children('.' + root.classNames.hover).trigger('contextmenu:blur')
                    .children('.hover').trigger('contextmenu:blur');

                if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) {
                    opt.$selected = null;
                    return;
                }


                $this.trigger('contextmenu:focus');
            },
            // :hover done manually so key handling is possible
            itemMouseleave: function (e) {
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                if (root !== opt && root.$layer && root.$layer.is(e.relatedTarget)) {
                    if (typeof root.$selected !== 'undefined' && root.$selected !== null) {
                        root.$selected.trigger('contextmenu:blur');
                    }
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    root.$selected = opt.$selected = opt.$node;
                    return;
                }

                if(opt && opt.$menu && opt.$menu.hasClass('context-menu-visible')){
                    return;
                }

                $this.trigger('contextmenu:blur');
            },
            // contextMenu item click
            itemClick: function (e) {
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot,
                    key = data.contextMenuKey,
                    callback;

                // abort if the key is unknown or disabled or is a menu
                if (!opt.items[key] || $this.is('.' + root.classNames.disabled + ', .context-menu-separator, .' + root.classNames.notSelectable) || ($this.is('.context-menu-submenu') && root.selectableSubMenu === false )) {
                    return;
                }

                e.preventDefault();
                e.stopImmediatePropagation();

                if ($.isFunction(opt.callbacks[key]) && Object.prototype.hasOwnProperty.call(opt.callbacks, key)) {
                    // item-specific callback
                    callback = opt.callbacks[key];
                } else if ($.isFunction(root.callback)) {
                    // default callback
                    callback = root.callback;
                } else {
                    // no callback, no action
                    return;
                }

                // hide menu if callback doesn't stop that
                if (callback.call(root.$trigger, key, root, e) !== false) {
                    root.$menu.trigger('contextmenu:hide');
                } else if (root.$menu.parent().length) {
                    op.update.call(root.$trigger, root);
                }
            },
            // ignore click events on input elements
            inputClick: function (e) {
                e.stopImmediatePropagation();
            },
            // hide <menu>
            hideMenu: function (e, data) {
                var root = $(this).data('contextMenuRoot');
                op.hide.call(root.$trigger, root, data && data.force);
            },
            // focus <command>
            focusItem: function (e) {
                e.stopPropagation();
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) {
                    return;
                }

                $this
                    .addClass([root.classNames.hover, root.classNames.visible].join(' '))
                    // select other items and included items
                    .parent().find('.context-menu-item').not($this)
                    .removeClass(root.classNames.visible)
                    .filter('.' + root.classNames.hover)
                    .trigger('contextmenu:blur');

                // remember selected
                opt.$selected = root.$selected = $this;


                if(opt && opt.$node && opt.$node.hasClass('context-menu-submenu')){
                    opt.$node.addClass(root.classNames.hover);
                }

                // position sub-menu - do after show so dumb $.ui.position can keep up
                if (opt.$node) {
                    root.positionSubmenu.call(opt.$node, opt.$menu);
                }
            },
            // blur <command>
            blurItem: function (e) {
                e.stopPropagation();
                var $this = $(this),
                    data = $this.data(),
                    opt = data.contextMenu,
                    root = data.contextMenuRoot;

                if (opt.autoHide) { // for tablets and touch screens this needs to remain
                    $this.removeClass(root.classNames.visible);
                }
                $this.removeClass(root.classNames.hover);
                opt.$selected = null;
            }
        },
        // operations
        op = {
            show: function (opt, x, y) {
                var $trigger = $(this),
                    css = {};

                // hide any open menus
                $('#context-menu-layer').trigger('mousedown');

                // backreference for callbacks
                opt.$trigger = $trigger;

                // show event
                if (opt.events.show.call($trigger, opt) === false) {
                    $currentTrigger = null;
                    return;
                }

                // create or update context menu
                var hasVisibleItems = op.update.call($trigger, opt);
                if (hasVisibleItems === false) {
                    $currentTrigger = null;
                    return;
                }

                // position menu
                opt.position.call($trigger, opt, x, y);

                // make sure we're in front
                if (opt.zIndex) {
                    var additionalZValue = opt.zIndex;
                    // If opt.zIndex is a function, call the function to get the right zIndex.
                    if (typeof opt.zIndex === 'function') {
                        additionalZValue = opt.zIndex.call($trigger, opt);
                    }
                    css.zIndex = zindex($trigger) + additionalZValue;
                }

                // add layer
                op.layer.call(opt.$menu, opt, css.zIndex);

                // adjust sub-menu zIndexes
                opt.$menu.find('ul').css('zIndex', css.zIndex + 1);

                // position and show context menu
                opt.$menu.css(css)[opt.animation.show](opt.animation.duration, function () {
                    $trigger.trigger('contextmenu:visible');

                    op.activated(opt);
                    opt.events.activated(opt);
                });
                // make options available and set state
                $trigger
                    .data('contextMenu', opt)
                    .addClass('context-menu-active');

                // register key handler
                $(document).off('keydown.contextMenu').on('keydown.contextMenu', handle.key);
                // register autoHide handler
                if (opt.autoHide) {
                    // mouse position handler
                    $(document).on('mousemove.contextMenuAutoHide', function (e) {
                        // need to capture the offset on mousemove,
                        // since the page might've been scrolled since activation
                        var pos = $trigger.offset();
                        pos.right = pos.left + $trigger.outerWidth();
                        pos.bottom = pos.top + $trigger.outerHeight();

                        if (opt.$layer && !opt.hovering && (!(e.pageX >= pos.left && e.pageX <= pos.right) || !(e.pageY >= pos.top && e.pageY <= pos.bottom))) {
                            /* Additional hover check after short time, you might just miss the edge of the menu */
                            setTimeout(function () {
                                if (!opt.hovering && opt.$menu !== null && typeof opt.$menu !== 'undefined') {
                                    opt.$menu.trigger('contextmenu:hide');
                                }
                            }, 50);
                        }
                    });
                }
            },
            hide: function (opt, force) {
                var $trigger = $(this);
                if (!opt) {
                    opt = $trigger.data('contextMenu') || {};
                }

                // hide event
                if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {
                    return;
                }

                // remove options and revert state
                $trigger
                    .removeData('contextMenu')
                    .removeClass('context-menu-active');

                if (opt.$layer) {
                    // keep layer for a bit so the contextmenu event can be aborted properly by opera
                    setTimeout((function ($layer) {
                        return function () {
                            $layer.remove();
                        };
                    })(opt.$layer), 10);

                    try {
                        delete opt.$layer;
                    } catch (e) {
                        opt.$layer = null;
                    }
                }

                // remove handle
                $currentTrigger = null;
                // remove selected
                opt.$menu.find('.' + opt.classNames.hover).trigger('contextmenu:blur');
                opt.$selected = null;
                // collapse all submenus
                opt.$menu.find('.' + opt.classNames.visible).removeClass(opt.classNames.visible);
                // unregister key and mouse handlers
                // $(document).off('.contextMenuAutoHide keydown.contextMenu'); // http://bugs.jquery.com/ticket/10705
                $(document).off('.contextMenuAutoHide').off('keydown.contextMenu');
                // hide menu
                if (opt.$menu) {
                    opt.$menu[opt.animation.hide](opt.animation.duration, function () {
                        // tear down dynamically built menu after animation is completed.
                        if (opt.build) {
                            opt.$menu.remove();
                            $.each(opt, function (key) {
                                switch (key) {
                                    case 'ns':
                                    case 'selector':
                                    case 'build':
                                    case 'trigger':
                                        return true;

                                    default:
                                        opt[key] = undefined;
                                        try {
                                            delete opt[key];
                                        } catch (e) {
                                        }
                                        return true;
                                }
                            });
                        }

                        setTimeout(function () {
                            $trigger.trigger('contextmenu:hidden');
                        }, 10);
                    });
                }
            },
            create: function (opt, root) {
                if (typeof root === 'undefined') {
                    root = opt;
                }

                // create contextMenu
                opt.$menu = $('<ul class="context-menu-list"></ul>').addClass(opt.className || '').data({
                    'contextMenu': opt,
                    'contextMenuRoot': root
                });
                if(opt.dataAttr){
                    $.each(opt.dataAttr, function (key, item) {
                        opt.$menu.attr('data-' + opt.key, item);
                    });
                }

                $.each(['callbacks', 'commands', 'inputs'], function (i, k) {
                    opt[k] = {};
                    if (!root[k]) {
                        root[k] = {};
                    }
                });

                if (!root.accesskeys) {
                    root.accesskeys = {};
                }

                function createNameNode(item) {
                    var $name = $('<span></span>');
                    if (item._accesskey) {
                        if (item._beforeAccesskey) {
                            $name.append(document.createTextNode(item._beforeAccesskey));
                        }
                        $('<span></span>')
                            .addClass('context-menu-accesskey')
                            .text(item._accesskey)
                            .appendTo($name);
                        if (item._afterAccesskey) {
                            $name.append(document.createTextNode(item._afterAccesskey));
                        }
                    } else {
                        if (item.isHtmlName) {
                            // restrict use with access keys
                            if (typeof item.accesskey !== 'undefined') {
                                throw new Error('accesskeys are not compatible with HTML names and cannot be used together in the same item');
                            }
                            $name.html(item.name);
                        } else {
                            $name.text(item.name);
                        }
                    }
                    return $name;
                }

                // create contextMenu items
                $.each(opt.items, function (key, item) {
                    var $t = $('<li class="context-menu-item"></li>').addClass(item.className || ''),
                        $label = null,
                        $input = null;

                    // iOS needs to see a click-event bound to an element to actually
                    // have the TouchEvents infrastructure trigger the click event
                    $t.on('click', $.noop);

                    // Make old school string seperator a real item so checks wont be
                    // akward later.
                    // And normalize 'cm_separator' into 'cm_seperator'.
                    if (typeof item === 'string' || item.type === 'cm_separator') {
                        item = {type: 'cm_seperator'};
                    }

                    item.$node = $t.data({
                        'contextMenu': opt,
                        'contextMenuRoot': root,
                        'contextMenuKey': key
                    });

                    // register accesskey
                    // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that
                    if (typeof item.accesskey !== 'undefined') {
                        var aks = splitAccesskey(item.accesskey);
                        for (var i = 0, ak; ak = aks[i]; i++) {
                            if (!root.accesskeys[ak]) {
                                root.accesskeys[ak] = item;
                                var matched = item.name.match(new RegExp('^(.*?)(' + ak + ')(.*)$', 'i'));
                                if (matched) {
                                    item._beforeAccesskey = matched[1];
                                    item._accesskey = matched[2];
                                    item._afterAccesskey = matched[3];
                                }
                                break;
                            }
                        }
                    }

                    if (item.type && types[item.type]) {
                        // run custom type handler
                        types[item.type].call($t, item, opt, root);
                        // register commands
                        $.each([opt, root], function (i, k) {
                            k.commands[key] = item;
                            // Overwrite only if undefined or the item is appended to the root. This so it
                            // doesn't overwrite callbacks of root elements if the name is the same.
                            if ($.isFunction(item.callback) && (typeof k.callbacks[key] === 'undefined' || typeof opt.type === 'undefined')) {
                                k.callbacks[key] = item.callback;
                            }
                        });
                    } else {
                        // add label for input
                        if (item.type === 'cm_seperator') {
                            $t.addClass('context-menu-separator ' + root.classNames.notSelectable);
                        } else if (item.type === 'html') {
                            $t.addClass('context-menu-html ' + root.classNames.notSelectable);
                        } else if (item.type !== 'sub' && item.type) {
                            $label = $('<label></label>').appendTo($t);
                            createNameNode(item).appendTo($label);

                            $t.addClass('context-menu-input');
                            opt.hasTypes = true;
                            $.each([opt, root], function (i, k) {
                                k.commands[key] = item;
                                k.inputs[key] = item;
                            });
                        } else if (item.items) {
                            item.type = 'sub';
                        }

                        switch (item.type) {
                            case 'cm_seperator':
                                break;

                            case 'text':
                                $input = $('<input type="text" value="1" name="" />')
                                    .attr('name', 'context-menu-input-' + key)
                                    .val(item.value || '')
                                    .appendTo($label);
                                break;

                            case 'textarea':
                                $input = $('<textarea name=""></textarea>')
                                    .attr('name', 'context-menu-input-' + key)
                                    .val(item.value || '')
                                    .appendTo($label);

                                if (item.height) {
                                    $input.height(item.height);
                                }
                                break;

                            case 'checkbox':
                                $input = $('<input type="checkbox" value="1" name="" />')
                                    .attr('name', 'context-menu-input-' + key)
                                    .val(item.value || '')
                                    .prop('checked', !!item.selected)
                                    .prependTo($label);
                                break;

                            case 'radio':
                                $input = $('<input type="radio" value="1" name="" />')
                                    .attr('name', 'context-menu-input-' + item.radio)
                                    .val(item.value || '')
                                    .prop('checked', !!item.selected)
                                    .prependTo($label);
                                break;

                            case 'select':
                                $input = $('<select name=""></select>')
                                    .attr('name', 'context-menu-input-' + key)
                                    .appendTo($label);
                                if (item.options) {
                                    $.each(item.options, function (value, text) {
                                        $('<option></option>').val(value).text(text).appendTo($input);
                                    });
                                    $input.val(item.selected);
                                }
                                break;

                            case 'sub':
                                createNameNode(item).appendTo($t);
                                item.appendTo = item.$node;
                                $t.data('contextMenu', item).addClass('context-menu-submenu');
                                item.callback = null;

                                // If item contains items, and this is a promise, we should create it later
                                // check if subitems is of type promise. If it is a promise we need to create
                                // it later, after promise has been resolved.
                                if ('function' === typeof item.items.then) {
                                    // probably a promise, process it, when completed it will create the sub menu's.
                                    op.processPromises(item, root, item.items);
                                } else {
                                    // normal submenu.
                                    op.create(item, root);
                                }
                                break;

                            case 'html':
                                $(item.html).appendTo($t);
                                break;

                            default:
                                $.each([opt, root], function (i, k) {
                                    k.commands[key] = item;
                                    // Overwrite only if undefined or the item is appended to the root. This so it
                                    // doesn't overwrite callbacks of root elements if the name is the same.
                                    if ($.isFunction(item.callback) && (typeof k.callbacks[key] === 'undefined' || typeof opt.type === 'undefined')) {
                                        k.callbacks[key] = item.callback;
                                    }
                                });
                                createNameNode(item).appendTo($t);
                                break;
                        }

                        // disable key listener in <input>
                        if (item.type && item.type !== 'sub' && item.type !== 'html' && item.type !== 'cm_seperator') {
                            $input
                                .on('focus', handle.focusInput)
                                .on('blur', handle.blurInput);

                            if (item.events) {
                                $input.on(item.events, opt);
                            }
                        }

                        // add icons
                        if (item.icon) {
                            if ($.isFunction(item.icon)) {
                                item._icon = item.icon.call(this, this, $t, key, item);
                            } else {
                                if (typeof(item.icon) === 'string' && (
                                    item.icon.substring(0, 4) === 'fab '
                                    || item.icon.substring(0, 4) === 'fas '
                                    || item.icon.substring(0, 4) === 'fad '
                                    || item.icon.substring(0, 4) === 'far '
                                    || item.icon.substring(0, 4) === 'fal ')
                                ) {
                                    // to enable font awesome
                                    $t.addClass(root.classNames.icon + ' ' + root.classNames.icon + '--fa5');
                                    item._icon = $('<i class="' + item.icon + '"></i>');
                                } else if (typeof(item.icon) === 'string' && item.icon.substring(0, 3) === 'fa-') {
                                    item._icon = root.classNames.icon + ' ' + root.classNames.icon + '--fa fa ' + item.icon;
                                } else {
                                    item._icon = root.classNames.icon + ' ' + root.classNames.icon + '-' + item.icon;
                                }
                            }

                            if(typeof(item._icon) === "string"){
                                $t.addClass(item._icon);
                            } else {
                                $t.prepend(item._icon);
                            }
                        }
                    }

                    // cache contained elements
                    item.$input = $input;
                    item.$label = $label;

                    // attach item to menu
                    $t.appendTo(opt.$menu);

                    // Disable text selection
                    if (!opt.hasTypes && $.support.eventSelectstart) {
                        // browsers support user-select: none,
                        // IE has a special event for text-selection
                        // browsers supporting neither will not be preventing text-selection
                        $t.on('selectstart.disableTextSelect', handle.abortevent);
                    }
                });
                // attach contextMenu to <body> (to bypass any possible overflow:hidden issues on parents of the trigger element)
                if (!opt.$node) {
                    opt.$menu.css('display', 'none').addClass('context-menu-root');
                }
                opt.$menu.appendTo(opt.appendTo || document.body);
            },
            resize: function ($menu, nested) {
                var domMenu;
                // determine widths of submenus, as CSS won't grow them automatically
                // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100;
                // kinda sucks hard...

                // determine width of absolutely positioned element
                $menu.css({position: 'absolute', display: 'block'});
                // don't apply yet, because that would break nested elements' widths
                $menu.data('width',
                    (domMenu = $menu.get(0)).getBoundingClientRect ?
                        Math.ceil(domMenu.getBoundingClientRect().width) :
                        $menu.outerWidth() + 1); // outerWidth() returns rounded pixels
                // reset styles so they allow nested elements to grow/shrink naturally
                $menu.css({
                    position: 'static',
                    minWidth: '0px',
                    maxWidth: '100000px'
                });
                // identify width of nested menus
                $menu.find('> li > ul').each(function () {
                    op.resize($(this), true);
                });
                // reset and apply changes in the end because nested
                // elements' widths wouldn't be calculatable otherwise
                if (!nested) {
                    $menu.find('ul').addBack().css({
                        position: '',
                        display: '',
                        minWidth: '',
                        maxWidth: ''
                    }).outerWidth(function () {
                        return $(this).data('width');
                    });
                }
            },
            update: function (opt, root) {
                var $trigger = this;
                if (typeof root === 'undefined') {
                    root = opt;
                    op.resize(opt.$menu);
                }

                var hasVisibleItems = false;

                // re-check disabled for each item
                opt.$menu.children().each(function () {
                    var $item = $(this),
                        key = $item.data('contextMenuKey'),
                        item = opt.items[key],
                        disabled = ($.isFunction(item.disabled) && item.disabled.call($trigger, key, root)) || item.disabled === true,
                        visible;
                    if ($.isFunction(item.visible)) {
                        visible = item.visible.call($trigger, key, root);
                    } else if (typeof item.visible !== 'undefined') {
                        visible = item.visible === true;
                    } else {
                        visible = true;
                    }

                    if (visible) {
                        hasVisibleItems = true;
                    }

                    $item[visible ? 'show' : 'hide']();

                    // dis- / enable item
                    $item[disabled ? 'addClass' : 'removeClass'](root.classNames.disabled);

                    if ($.isFunction(item.icon)) {
                        $item.removeClass(item._icon);
                        var iconResult = item.icon.call(this, $trigger, $item, key, item);
                        if(typeof(iconResult) === "string"){
                            $item.addClass(iconResult);
                        } else {
                            $item.prepend(iconResult);
                        }
                    }

                    if (item.type) {
                        // dis- / enable input elements
                        $item.find('input, select, textarea').prop('disabled', disabled);

                        // update input states
                        switch (item.type) {
                            case 'text':
                            case 'textarea':
                                item.$input.val(item.value || '');
                                break;

                            case 'checkbox':
                            case 'radio':
                                item.$input.val(item.value || '').prop('checked', !!item.selected);
                                break;

                            case 'select':
                                item.$input.val((item.selected === 0 ? "0" : item.selected) || '');
                                break;
                        }
                    }

                    if (item.$menu) {
                        // update sub-menu
                        var subMenuHasVisibleItems = op.update.call($trigger, item, root);
                        if (subMenuHasVisibleItems) {
                            hasVisibleItems = true;
                        }
                    }
                });
                return hasVisibleItems;
            },
            layer: function (opt, zIndex) {
                // add transparent layer for click area
                // filter and background for Internet Explorer, Issue #23
                var $layer = opt.$layer = $('<div id="context-menu-layer"></div>')
                    .css({
                        height: $win.height(),
                        width: $win.width(),
                        display: 'block',
                        position: 'fixed',
                        'z-index': zIndex - 1,
                        top: 0,
                        left: 0,
                        opacity: 0,
                        filter: 'alpha(opacity=0)',
                        'background-color': '#000'
                    })
                    .data('contextMenuRoot', opt)
                    .appendTo(document.body)
                    .on('contextmenu', handle.abortevent)
                    .on('mousedown', handle.layerClick);

                // IE6 doesn't know position:fixed;
                if (typeof document.body.style.maxWidth === 'undefined') { // IE6 doesn't support maxWidth
                    $layer.css({
                        'position': 'absolute',
                        'height': $(document).height()
                    });
                }

                return $layer;
            },
            processPromises: function (opt, root, promise) {
                // Start
                opt.$node.addClass(root.classNames.iconLoadingClass);

                function completedPromise(opt, root, items) {
                    // Completed promise (dev called promise.resolve). We now have a list of items which can
                    // be used to create the rest of the context menu.
                    if (typeof items === 'undefined') {
                        // Null result, dev should have checked
                        errorPromise(undefined);//own error object
                    }
                    finishPromiseProcess(opt, root, items);
                }

                function errorPromise(opt, root, errorItem) {
                    // User called promise.reject() with an error item, if not, provide own error item.
                    if (typeof errorItem === 'undefined') {
                        errorItem = {
                            "error": {
                                name: "No items and no error item",
                                icon: "context-menu-icon context-menu-icon-quit"
                            }
                        };
                        if (window.console) {
                            (console.error || console.log).call(console, 'When you reject a promise, provide an "items" object, equal to normal sub-menu items');
                        }
                    } else if (typeof errorItem === 'string') {
                        errorItem = {"error": {name: errorItem}};
                    }
                    finishPromiseProcess(opt, root, errorItem);
                }

                function finishPromiseProcess(opt, root, items) {
                    if (typeof root.$menu === 'undefined' || !root.$menu.is(':visible')) {
                        return;
                    }
                    opt.$node.removeClass(root.classNames.iconLoadingClass);
                    opt.items = items;
                    op.create(opt, root, true); // Create submenu
                    op.update(opt, root); // Correctly update position if user is already hovered over menu item
                    root.positionSubmenu.call(opt.$node, opt.$menu); // positionSubmenu, will only do anything if user already hovered over menu item that just got new subitems.
                }

                // Wait for promise completion. .then(success, error, notify) (we don't track notify). Bind the opt
                // and root to avoid scope problems
                promise.then(completedPromise.bind(this, opt, root), errorPromise.bind(this, opt, root));
            },
            // operation that will run after contextMenu showed on screen
            activated: function(opt){
                var $menu = opt.$menu;
                var $menuOffset = $menu.offset();
                var winHeight = $(window).height();
                var winScrollTop = $(window).scrollTop();
                var menuHeight = $menu.height();
                if(menuHeight > winHeight){
                    $menu.css({
                        'height' : winHeight + 'px',
                        'overflow-x': 'hidden',
                        'overflow-y': 'auto',
                        'top': winScrollTop + 'px'
                    });
                } else if(($menuOffset.top < winScrollTop) || ($menuOffset.top + menuHeight > winScrollTop + winHeight)){
                    $menu.css({
                        'top': winScrollTop + 'px'
                    });
                }
            }
        };

    // split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key
    function splitAccesskey(val) {
        var t = val.split(/\s+/);
        var keys = [];

        for (var i = 0, k; k = t[i]; i++) {
            k = k.charAt(0).toUpperCase(); // first character only
            // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it.
            // a map to look up already used access keys would be nice
            keys.push(k);
        }

        return keys;
    }

// handle contextMenu triggers
    $.fn.contextMenu = function (operation) {
        var $t = this, $o = operation;
        if (this.length > 0) {  // this is not a build on demand menu
            if (typeof operation === 'undefined') {
                this.first().trigger('contextmenu');
            } else if (typeof operation.x !== 'undefined' && typeof operation.y !== 'undefined') {
                this.first().trigger($.Event('contextmenu', {
                    pageX: operation.x,
                    pageY: operation.y,
                    mouseButton: operation.button
                }));
            } else if (operation === 'hide') {
                var $menu = this.first().data('contextMenu') ? this.first().data('contextMenu').$menu : null;
                if ($menu) {
                    $menu.trigger('contextmenu:hide');
                }
            } else if (operation === 'destroy') {
                $.contextMenu('destroy', {context: this});
            } else if ($.isPlainObject(operation)) {
                operation.context = this;
                $.contextMenu('create', operation);
            } else if (operation) {
                this.removeClass('context-menu-disabled');
            } else if (!operation) {
                this.addClass('context-menu-disabled');
            }
        } else {
            $.each(menus, function () {
                if (this.selector === $t.selector) {
                    $o.data = this;

                    $.extend($o.data, {trigger: 'demand'});
                }
            });

            handle.contextmenu.call($o.target, $o);
        }

        return this;
    };

    // manage contextMenu instances
    $.contextMenu = function (operation, options) {
        if (typeof operation !== 'string') {
            options = operation;
            operation = 'create';
        }

        if (typeof options === 'string') {
            options = {selector: options};
        } else if (typeof options === 'undefined') {
            options = {};
        }

        // merge with default options
        var o = $.extend(true, {}, defaults, options || {});
        var $document = $(document);
        var $context = $document;
        var _hasContext = false;

        if (!o.context || !o.context.length) {
            o.context = document;
        } else {
            // you never know what they throw at you...
            $context = $(o.context).first();
            o.context = $context.get(0);
            _hasContext = !$(o.context).is(document);
        }

        switch (operation) {

            case 'update':
                // Updates visibility and such
                if(_hasContext){
                    op.update($context);
                } else {
                    for(var menu in menus){
                        if(menus.hasOwnProperty(menu)){
                            op.update(menus[menu]);
                        }
                    }
                }
                break;

            case 'create':
                // no selector no joy
                if (!o.selector) {
                    throw new Error('No selector specified');
                }
                // make sure internal classes are not bound to
                if (o.selector.match(/.context-menu-(list|item|input)($|\s)/)) {
                    throw new Error('Cannot bind to selector "' + o.selector + '" as it contains a reserved className');
                }
                if (!o.build && (!o.items || $.isEmptyObject(o.items))) {
                    throw new Error('No Items specified');
                }
                counter++;
                o.ns = '.contextMenu' + counter;
                if (!_hasContext) {
                    namespaces[o.selector] = o.ns;
                }
                menus[o.ns] = o;

                // default to right click
                if (!o.trigger) {
                    o.trigger = 'right';
                }

                if (!initialized) {
                    var itemClick = o.itemClickEvent === 'click' ? 'click.contextMenu' : 'mouseup.contextMenu';
                    var contextMenuItemObj = {
                        // 'mouseup.contextMenu': handle.itemClick,
                        // 'click.contextMenu': handle.itemClick,
                        'contextmenu:focus.contextMenu': handle.focusItem,
                        'contextmenu:blur.contextMenu': handle.blurItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.itemMouseenter,
                        'mouseleave.contextMenu': handle.itemMouseleave
                    };
                    contextMenuItemObj[itemClick] = handle.itemClick;
                    // make sure item click is registered first
                    $document
                        .on({
                            'contextmenu:hide.contextMenu': handle.hideMenu,
                            'prevcommand.contextMenu': handle.prevItem,
                            'nextcommand.contextMenu': handle.nextItem,
                            'contextmenu.contextMenu': handle.abortevent,
                            'mouseenter.contextMenu': handle.menuMouseenter,
                            'mouseleave.contextMenu': handle.menuMouseleave
                        }, '.context-menu-list')
                        .on('mouseup.contextMenu', '.context-menu-input', handle.inputClick)
                        .on(contextMenuItemObj, '.context-menu-item');

                    initialized = true;
                }

                // engage native contextmenu event
                $context
                    .on('contextmenu' + o.ns, o.selector, o, handle.contextmenu);

                if (_hasContext) {
                    // add remove hook, just in case
                    $context.on('remove' + o.ns, function () {
                        $(this).contextMenu('destroy');
                    });
                }

                switch (o.trigger) {
                    case 'hover':
                        $context
                            .on('mouseenter' + o.ns, o.selector, o, handle.mouseenter)
                            .on('mouseleave' + o.ns, o.selector, o, handle.mouseleave);
                        break;

                    case 'left':
                        $context.on('click' + o.ns, o.selector, o, handle.click);
                        break;
				    case 'touchstart':
                        $context.on('touchstart' + o.ns, o.selector, o, handle.click);
                        break;
                    /*
                     default:
                     // http://www.quirksmode.org/dom/events/contextmenu.html
                     $document
                     .on('mousedown' + o.ns, o.selector, o, handle.mousedown)
                     .on('mouseup' + o.ns, o.selector, o, handle.mouseup);
                     break;
                     */
                }

                // create menu
                if (!o.build) {
                    op.create(o);
                }
                break;

            case 'destroy':
                var $visibleMenu;
                if (_hasContext) {
                    // get proper options
                    var context = o.context;
                    $.each(menus, function (ns, o) {

                        if (!o) {
                            return true;
                        }

                        // Is this menu equest to the context called from
                        if (!$(context).is(o.selector)) {
                            return true;
                        }

                        $visibleMenu = $('.context-menu-list').filter(':visible');
                        if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) {
                            $visibleMenu.trigger('contextmenu:hide', {force: true});
                        }

                        try {
                            if (menus[o.ns].$menu) {
                                menus[o.ns].$menu.remove();
                            }

                            delete menus[o.ns];
                        } catch (e) {
                            menus[o.ns] = null;
                        }

                        $(o.context).off(o.ns);

                        return true;
                    });
                } else if (!o.selector) {
                    $document.off('.contextMenu .contextMenuAutoHide');
                    $.each(menus, function (ns, o) {
                        $(o.context).off(o.ns);
                    });

                    namespaces = {};
                    menus = {};
                    counter = 0;
                    initialized = false;

                    $('#context-menu-layer, .context-menu-list').remove();
                } else if (namespaces[o.selector]) {
                    $visibleMenu = $('.context-menu-list').filter(':visible');
                    if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) {
                        $visibleMenu.trigger('contextmenu:hide', {force: true});
                    }

                    try {
                        if (menus[namespaces[o.selector]].$menu) {
                            menus[namespaces[o.selector]].$menu.remove();
                        }

                        delete menus[namespaces[o.selector]];
                    } catch (e) {
                        menus[namespaces[o.selector]] = null;
                    }

                    $document.off(namespaces[o.selector]);
                }
                break;

            case 'html5':
                // if <command> and <menuitem> are not handled by the browser,
                // or options was a bool true,
                // initialize $.contextMenu for them
                if ((!$.support.htmlCommand && !$.support.htmlMenuitem) || (typeof options === 'boolean' && options)) {
                    $('menu[type="context"]').each(function () {
                        if (this.id) {
                            $.contextMenu({
                                selector: '[contextmenu=' + this.id + ']',
                                items: $.contextMenu.fromMenu(this)
                            });
                        }
                    }).css('display', 'none');
                }
                break;

            default:
                throw new Error('Unknown operation "' + operation + '"');
        }

        return this;
    };

// import values into <input> commands
    $.contextMenu.setInputValues = function (opt, data) {
        if (typeof data === 'undefined') {
            data = {};
        }

        $.each(opt.inputs, function (key, item) {
            switch (item.type) {
                case 'text':
                case 'textarea':
                    item.value = data[key] || '';
                    break;

                case 'checkbox':
                    item.selected = data[key] ? true : false;
                    break;

                case 'radio':
                    item.selected = (data[item.radio] || '') === item.value;
                    break;

                case 'select':
                    item.selected = data[key] || '';
                    break;
            }
        });
    };

// export values from <input> commands
    $.contextMenu.getInputValues = function (opt, data) {
        if (typeof data === 'undefined') {
            data = {};
        }

        $.each(opt.inputs, function (key, item) {
            switch (item.type) {
                case 'text':
                case 'textarea':
                case 'select':
                    data[key] = item.$input.val();
                    break;

                case 'checkbox':
                    data[key] = item.$input.prop('checked');
                    break;

                case 'radio':
                    if (item.$input.prop('checked')) {
                        data[item.radio] = item.value;
                    }
                    break;
            }
        });

        return data;
    };

// find <label for="xyz">
    function inputLabel(node) {
        return (node.id && $('label[for="' + node.id + '"]').val()) || node.name;
    }

// convert <menu> to items object
    function menuChildren(items, $children, counter) {
        if (!counter) {
            counter = 0;
        }

        $children.each(function () {
            var $node = $(this),
                node = this,
                nodeName = this.nodeName.toLowerCase(),
                label,
                item;

            // extract <label><input>
            if (nodeName === 'label' && $node.find('input, textarea, select').length) {
                label = $node.text();
                $node = $node.children().first();
                node = $node.get(0);
                nodeName = node.nodeName.toLowerCase();
            }

            /*
             * <menu> accepts flow-content as children. that means <embed>, <canvas> and such are valid menu items.
             * Not being the sadistic kind, $.contextMenu only accepts:
             * <command>, <menuitem>, <hr>, <span>, <p> <input [text, radio, checkbox]>, <textarea>, <select> and of course <menu>.
             * Everything else will be imported as an html node, which is not interfaced with contextMenu.
             */

            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command
            switch (nodeName) {
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element
                case 'menu':
                    item = {name: $node.attr('label'), items: {}};
                    counter = menuChildren(item.items, $node.children(), counter);
                    break;

                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command
                case 'a':
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command
                case 'button':
                    item = {
                        name: $node.text(),
                        disabled: !!$node.attr('disabled'),
                        callback: (function () {
                            return function () {
                                $node.get(0).click();
                            };
                        })()
                    };
                    break;

                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command
                case 'menuitem':
                case 'command':
                    switch ($node.attr('type')) {
                        case undefined:
                        case 'command':
                        case 'menuitem':
                            item = {
                                name: $node.attr('label'),
                                disabled: !!$node.attr('disabled'),
                                icon: $node.attr('icon'),
                                callback: (function () {
                                    return function () {
                                        $node.get(0).click();
                                    };
                                })()
                            };
                            break;

                        case 'checkbox':
                            item = {
                                type: 'checkbox',
                                disabled: !!$node.attr('disabled'),
                                name: $node.attr('label'),
                                selected: !!$node.attr('checked')
                            };
                            break;
                        case 'radio':
                            item = {
                                type: 'radio',
                                disabled: !!$node.attr('disabled'),
                                name: $node.attr('label'),
                                radio: $node.attr('radiogroup'),
                                value: $node.attr('id'),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        default:
                            item = undefined;
                    }
                    break;

                case 'hr':
                    item = '-------';
                    break;

                case 'input':
                    switch ($node.attr('type')) {
                        case 'text':
                            item = {
                                type: 'text',
                                name: label || inputLabel(node),
                                disabled: !!$node.attr('disabled'),
                                value: $node.val()
                            };
                            break;

                        case 'checkbox':
                            item = {
                                type: 'checkbox',
                                name: label || inputLabel(node),
                                disabled: !!$node.attr('disabled'),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        case 'radio':
                            item = {
                                type: 'radio',
                                name: label || inputLabel(node),
                                disabled: !!$node.attr('disabled'),
                                radio: !!$node.attr('name'),
                                value: $node.val(),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        default:
                            item = undefined;
                            break;
                    }
                    break;

                case 'select':
                    item = {
                        type: 'select',
                        name: label || inputLabel(node),
                        disabled: !!$node.attr('disabled'),
                        selected: $node.val(),
                        options: {}
                    };
                    $node.children().each(function () {
                        item.options[this.value] = $(this).text();
                    });
                    break;

                case 'textarea':
                    item = {
                        type: 'textarea',
                        name: label || inputLabel(node),
                        disabled: !!$node.attr('disabled'),
                        value: $node.val()
                    };
                    break;

                case 'label':
                    break;

                default:
                    item = {type: 'html', html: $node.clone(true)};
                    break;
            }

            if (item) {
                counter++;
                items['key' + counter] = item;
            }
        });

        return counter;
    }

// convert html5 menu
    $.contextMenu.fromMenu = function (element) {
        var $this = $(element),
            items = {};

        menuChildren(items, $this.children());

        return items;
    };

// make defaults accessible
    $.contextMenu.defaults = defaults;
    $.contextMenu.types = types;
// export internal functions - undocumented, for hacking only!
    $.contextMenu.handle = handle;
    $.contextMenu.op = op;
    $.contextMenu.menus = menus;
});

define('contextMenu', ['contextMenu/dist/jquery.contextMenu'], function (main) { return main; });

define ('lib/jquery.fullscreen-min',[
	"jquery",
],
function (jQuery)
{
/*
 jquery.fullscreen 1.1.5
 https://github.com/kayahr/jquery-fullscreen-plugin
 Copyright (C) 2012-2013 Klaus Reimer <k@ailis.de>
 Licensed under the MIT license
 (See http://www.opensource.org/licenses/mit-license)
*/
function d(c){var b,a;if(!this.length)return this;b=this[0];b.ownerDocument?a=b.ownerDocument:(a=b,b=a.documentElement);if(null==c){if(!a.exitFullscreen&&!a.webkitExitFullscreen&&!a.webkitCancelFullScreen&&!a.msExitFullscreen&&!a.mozCancelFullScreen)return null;c=!!a.fullscreenElement||!!a.msFullscreenElement||!!a.webkitIsFullScreen||!!a.mozFullScreen;return!c?c:a.fullscreenElement||a.webkitFullscreenElement||a.webkitCurrentFullScreenElement||a.msFullscreenElement||a.mozFullScreenElement||c}c?(c=
b.requestFullscreen||b.webkitRequestFullscreen||b.webkitRequestFullScreen||b.msRequestFullscreen||b.mozRequestFullScreen)&&c.call(b):(c=a.exitFullscreen||a.webkitExitFullscreen||a.webkitCancelFullScreen||a.msExitFullscreen||a.mozCancelFullScreen)&&c.call(a);return this}jQuery.fn.fullScreen=d;jQuery.fn.toggleFullScreen=function(){return d.call(this,!d.call(this))};var e,f,g;e=document;
e.webkitCancelFullScreen?(f="webkitfullscreenchange",g="webkitfullscreenerror"):e.msExitFullscreen?(f="MSFullscreenChange",g="MSFullscreenError"):e.mozCancelFullScreen?(f="mozfullscreenchange",g="mozfullscreenerror"):(f="fullscreenchange",g="fullscreenerror");jQuery(document).bind(f,function(){jQuery(document).trigger(new jQuery.Event("fullscreenchange"))});jQuery(document).bind(g,function(){jQuery(document).trigger(new jQuery.Event("fullscreenerror"))});

});
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/ContextMenu',[
	"jquery",
	"contextMenu",
	"x_ite/Basic/X3DBaseNode",
	"locale/gettext",
	"lib/jquery.fullscreen-min",
],
function ($,
          contextMenu,
          X3DBaseNode,
          _)
{
"use strict";

	$("head") .append ('<style>.x_ite-private-menu-title:before { content: "' + _("X_ITE Browser") + '" }</style>');

	function ContextMenu (executionContext)
	{
		X3DBaseNode .call (this, executionContext);
	}

	ContextMenu .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: ContextMenu,
		getTypeName: function ()
		{
			return "ContextMenu";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "contextMenu";
		},
		initialize: function ()
		{
			X3DBaseNode .prototype .initialize .call (this);

			var browser = this .getBrowser ();

			if (! browser .getBrowserOptions () .getContextMenu ())
				return;

			$.contextMenu ({
				selector: ".x_ite-private-surface-" + browser .getId (),
				build: this .build .bind (this),
			});
		},
		build: function (trigger, event)
		{
			var
				browser          = this .getBrowser (),
				activeLayer      = browser .getActiveLayer (),
				currentViewpoint = activeLayer ? activeLayer .getViewpoint () : null,
				currentViewer    = browser .viewer_ .getValue (),
				fullscreen       = browser .getElement () .fullScreen ();

			var menu = {
				className: "x_ite-private-menu x_ite-private-menu-title",
				items: {
					"separator0": "--------",
					"viewpoints": {
						name: _("Viewpoints"),
						className: "context-menu-icon x_ite-private-icon-viewpoint",
						items: this .getViewpoints (),
						callback: function (viewpoint)
						{
							$("body > ul.context-menu-list") .fadeOut (500);

							if (! viewpoint)
								return;

							browser .bindViewpoint (viewpoint);
							browser .getElement () .focus ();
						}
						.bind (this, currentViewpoint),
					},
					"separator1": "--------",
					"viewer": {
						name: _(this .getViewerName (currentViewer)),
						className: "context-menu-icon x_ite-private-icon-" + currentViewer .toLowerCase () + "-viewer",
						callback: function (viewer)
						{
							$("body > ul.context-menu-list") .fadeOut (500);

							browser .viewer_ = viewer;
							browser .getNotification () .string_ = _(this .getViewerName (viewer));
							browser .getElement () .focus ();
						}
						.bind (this, currentViewer),
					},
					"available-viewers": {
						name: _("Available Viewers"),
						items: this .getAvailableViewers (),
					},
					"straighten-horizon": {
						name: _("Straighten Horizon"),
						type: "checkbox",
						selected: browser .getBrowserOption ("StraightenHorizon"),
						events: {
							click: function ()
							{
								$("body > ul.context-menu-list") .fadeOut (500);

								var straightenHorizon = ! browser .getBrowserOption ("StraightenHorizon");

								browser .setBrowserOption ("StraightenHorizon", straightenHorizon);

								if (straightenHorizon)
								{
									browser .getNotification () .string_ = _("Straighten Horizon") + ": " + _("on");

									var activeViewpoint = browser .getActiveViewpoint ();

									if (activeViewpoint)
										activeViewpoint .straighten (true);
								}
								else
								{
									browser .getNotification () .string_ = _("Straighten Horizon") + ": " + _("off");
								}
							}
							.bind (this),
						},
					},
					"separator2": "--------",
					"primitive-quality": {
						name: _("Primitive Quality"),
						className: "context-menu-icon x_ite-private-icon-primitive-quality",
						items: {
							"high": {
								name: _("High"),
								type: "radio",
								radio: "primitive-quality",
								selected: browser .getBrowserOption ("PrimitiveQuality") === "HIGH",
								events: {
									click: function ()
									{
										$("body > ul.context-menu-list") .fadeOut (500);

										browser .setBrowserOption ("PrimitiveQuality", "HIGH");
										browser .getNotification () .string_ = _("Primitive Quality") + ": " + _("high");
									}
									.bind (this),
								},
							},
							"medium": {
								name: _("Medium"),
								type: "radio",
								radio: "primitive-quality",
								selected: browser .getBrowserOption ("PrimitiveQuality") === "MEDIUM",
								events: {
									click: function ()
									{
										$("body > ul.context-menu-list") .fadeOut (500);

										browser .setBrowserOption ("PrimitiveQuality", "MEDIUM");
										browser .getNotification () .string_ = _("Primitive Quality") + ": " + _("medium");
									}
									.bind (this),
								},
							},
							"low": {
								name: _("Low"),
								type: "radio",
								radio: "primitive-quality",
								selected: browser .getBrowserOption ("PrimitiveQuality") === "LOW",
								events: {
									click: function ()
									{
										$("body > ul.context-menu-list") .fadeOut (500);

										browser .setBrowserOption ("PrimitiveQuality", "LOW");
										browser .getNotification () .string_ = _("Primitive Quality") + ": " + _("low");
									}
									.bind (this),
								},
							},
						},
					},
					"texture-quality": {
						name: _("Texture Quality"),
						className: "context-menu-icon x_ite-private-icon-texture-quality",
						items: {
							"high": {
								name: _("High"),
								type: "radio",
								radio: "texture-quality",
								selected: browser .getBrowserOption ("TextureQuality") === "HIGH",
								events: {
									click: function ()
									{
										$("body > ul.context-menu-list") .fadeOut (500);

										browser .setBrowserOption ("TextureQuality", "HIGH");
										browser .getNotification () .string_ = _("Texture Quality") + ": " + _("high");
									}
									.bind (this),
								},
							},
							"medium": {
								name: _("Medium"),
								type: "radio",
								radio: "texture-quality",
								selected: browser .getBrowserOption ("TextureQuality") === "MEDIUM",
								events: {
									click: function ()
									{
										$("body > ul.context-menu-list") .fadeOut (500);

										browser .setBrowserOption ("TextureQuality", "MEDIUM");
										browser .getNotification () .string_ = _("Texture Quality") + ": " + _("medium");
									}
									.bind (this),
								},
							},
							"low": {
								name: _("Low"),
								type: "radio",
								radio: "texture-quality",
								selected: browser .getBrowserOption ("TextureQuality") === "LOW",
								events: {
									click: function ()
									{
										$("body > ul.context-menu-list") .fadeOut (500);

										browser .setBrowserOption ("TextureQuality", "LOW");
										browser .getNotification () .string_ = _("Texture Quality") + ": " + _("low");
									}
									.bind (this),
								},
							},
						},
					},
					"display-rubberband": {
						name: _("Display Rubberband"),
						type: "checkbox",
						selected: browser .getBrowserOption ("Rubberband"),
						events: {
							click: function ()
							{
								$("body > ul.context-menu-list") .fadeOut (500);

								var rubberband = ! browser .getBrowserOption ("Rubberband");

								browser .setBrowserOption ("Rubberband", rubberband);

								if (rubberband)
									browser .getNotification () .string_ = _("Rubberband") + ": " + _("on");
								else
									browser .getNotification () .string_ = _("Rubberband") + ": " + _("off");
							}
							.bind (this),
						},
					},
					"browser-timings": browser .getBrowserOptions () .getTimings () ? {
						name: _("Browser Timings"),
						type: "checkbox",
						selected: browser .getBrowserTimings () .getEnabled (),
						events: {
							click: function ()
							{
								$("body > ul.context-menu-list") .fadeOut (500);

								browser .getBrowserTimings () .setEnabled (! browser .getBrowserTimings () .getEnabled ());
								browser .getElement () .focus ();
							}
							.bind (this),
						},
					} : undefined,
					"fullscreen": {
						name: fullscreen ? _("Leave Fullscreen") : _("Fullscreen"),
						className: "context-menu-icon " + (fullscreen ? "x_ite-private-icon-leave-fullscreen" : "x_ite-private-icon-fullscreen"),
						callback: function ()
						{
							$("body > ul.context-menu-list") .fadeOut (500);

							browser .getElement () .toggleFullScreen ();
						}
						.bind (this),
					},
					"separator3": "--------",
					"about": {
						name: _("About X_ITE"),
						className: "context-menu-icon x_ite-private-icon-help-about",
						callback: function ()
						{
							$("body > ul.context-menu-list") .fadeOut (500);

							window .open (browser .getProviderUrl ());
						},
					},
				}
			};

			if ($.isEmptyObject (menu .items .viewpoints .items))
			{
				delete menu .items ["separator0"];
				delete menu .items ["viewpoints"];
			}

			if (Object .keys (menu .items ["available-viewers"] .items) .length < 2)
			{
				delete menu .items ["available-viewers"];
			}

			if (!(browser .getCurrentViewer () == "EXAMINE" && browser .getActiveViewpoint () .getTypeName () !== "GeoViewpoint"))
			{
				delete menu .items ["straighten-horizon"];
			}

			return menu;
		},
		getViewpoints: function ()
		{
			var
				browser     = this .getBrowser (),
				activeLayer = browser .getActiveLayer ();

			if (! activeLayer)
				return { };

			var
				enableInlineViewpoints = browser .getBrowserOption ("EnableInlineViewpoints"),
				currentScene           = browser .currentScene,
				viewpoints             = activeLayer .getViewpoints () .get (),
				currentViewpoint       = activeLayer .getViewpoint (),
				menu                   = { };

			for (var i = 0; i < viewpoints .length; ++ i)
			{
				var
					viewpoint   = viewpoints [i],
					description = viewpoint .description_ .getValue ();

				if (description === "")
					continue;

				if (! enableInlineViewpoints && viewpoint .getScene () !== currentScene)
					continue;

				var item = {
					name: description,
					callback: function (viewpoint)
					{
						$("body > ul.context-menu-list") .fadeOut (500);

						browser .bindViewpoint (viewpoint);
						browser .getElement () .focus ();
					}
					.bind (this, viewpoint),
				};

				if (viewpoint === currentViewpoint)
					item .className = "context-menu-selected";

				menu ["Viewpoint" + viewpoint .getId ()] = item;
			}

			return menu;
		},
		getAvailableViewers: function ()
		{
			var
				browser          = this .getBrowser (),
				currentViewer    = browser .viewer_ .getValue (),
				availableViewers = browser .availableViewers_,
				menu             = { };

			for (var i = 0; i < availableViewers .length; ++ i)
			{
				var viewer = availableViewers [i];

				menu [viewer] = {
					name: _(this .getViewerName (viewer)),
					className: "context-menu-icon x_ite-private-icon-" + viewer .toLowerCase () + "-viewer",
					callback: function (viewer)
					{
						$("body > ul.context-menu-list") .fadeOut (500);

						browser .viewer_ = viewer;
						browser .getNotification () .string_ = _(this .getViewerName (viewer));
						browser .getElement () .focus ();
					}
					.bind (this, viewer),
				};

				if (viewer === currentViewer)
				   menu [viewer] .className += " context-menu-selected";
			}

		   return menu;
		},
		getViewerName: function (viewer)
		{
			switch (viewer)
			{
				case "EXAMINE":
					return _("Examine Viewer");
				case "WALK":
					return _("Walk Viewer");
				case "FLY":
					return _("Fly Viewer");
				case "PLANE":
					return _("Plane Viewer");
				case "LOOKAT":
					return _("Look At Viewer");
				case "NONE":
					return _("None Viewer");
			}
		},
	});

	return ContextMenu;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/ImportedNode',[
	"x_ite/Fields",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function (Fields,
          X3DBaseNode,
          X3DConstants,
          Generator)
{
"use strict";

	function ImportedNode (executionContext, inlineNode, exportedName, importedName)
	{
		X3DBaseNode .call (this, executionContext);

		this .inlineNode   = inlineNode;
		this .exportedName = exportedName;
		this .importedName = importedName;
		this .routes       = new Map ();

		this .inlineNode .loadState_ .addInterest ("set_loadState__", this);
	}

	ImportedNode .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: ImportedNode,
		getTypeName: function ()
		{
			return "ImportedNode";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "importedNodes";
		},
		getInlineNode: function ()
		{
			return this .inlineNode;
		},
		getExportedName: function ()
		{
			return this .exportedName;
		},
		getExportedNode: function ()
		{
			return this .inlineNode .getInternalScene () .getExportedNode (this .exportedName);
		},
		setImportedName: function (value)
		{
			this .importedName = value;
		},
		getImportedName: function ()
		{
			return this .importedName;
		},
		addRoute: function (sourceNode, sourceField, destinationNode, destinationField)
		{
			// Add route.

			var id = sourceNode .getId () + "." + sourceField + " " + destinationNode .getId () + "." + destinationField;

			this .routes .set (id,
			{
				sourceNode:       sourceNode,
				sourceField:      sourceField,
				destinationNode:  destinationNode,
				destinationField: destinationField,
			});

			// Try to resolve source or destination node routes.

			if (this .inlineNode .checkLoadState () === X3DConstants .COMPLETE_STATE)
				this .resolveRoute (id);
		},
		resolveRoute: function (id)
		{
			try
			{
				var
					route            = this .routes .get (id),
					sourceNode       = route .sourceNode,
					sourceField      = route .sourceField,
					destinationNode  = route .destinationNode,
					destinationField = route .destinationField;

				if (route ._route)
					route ._route .dispose ();

				if (sourceNode instanceof ImportedNode)
					sourceNode = sourceNode .getExportedNode () .getValue ();

				if (destinationNode instanceof ImportedNode)
					destinationNode = destinationNode .getExportedNode () .getValue ();

				route ._route = this .getExecutionContext () .addSimpleRoute (sourceNode, sourceField, destinationNode, destinationField);
			}
			catch (error)
			{
				console .error (error .message);
			}
		},
		deleteRoutes: function ()
		{
			this .routes .forEach (function (route)
			{
				if (route ._route)
				{
					this .getExecutionContext () .deleteRoute (route ._route);
					delete route ._route;
				}
			},
			this);
		},
		set_loadState__: function ()
		{
			switch (this .inlineNode .checkLoadState ())
			{
				case X3DConstants .NOT_STARTED_STATE:
				case X3DConstants .FAILED_STATE:
				{
					this .deleteRoutes ();
					break;
				}
				case X3DConstants .COMPLETE_STATE:
				{
					this .deleteRoutes ();

					this .routes .forEach (function (route, id)
					{
						this .resolveRoute (id);
					},
					this);

					break;
				}
			}
		},
		toVRMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			if (generator .ExistsNode (this .getInlineNode ()))
			{
				stream .string += generator .Indent ();
				stream .string += "IMPORT";
				stream .string += " ";
				stream .string += generator .Name (this .getInlineNode ());
				stream .string += ".";
				stream .string += this .getExportedName ();

				if (this .getImportedName () !== this .getExportedName ())
				{
					stream .string += " ";
					stream .string += "AS";
					stream .string += " ";
					stream .string += this .getImportedName ();
				}

				try
				{
					generator .AddRouteNode (this);
					generator .AddImportedNode (this .getExportedNode () .getValue  (), this .getImportedName ());
				}
				catch (error)
				{
					// Output unresolved routes.

					this .routes .forEach (function (route)
					{
						var
							sourceNode       = route .sourceNode,
							sourceField      = route .sourceField,
							destinationNode  = route .destinationNode,
							destinationField = route .destinationField;

						if (generator .ExistsRouteNode (sourceNode) && generator .ExistsRouteNode (destinationNode))
						{
							if (sourceNode instanceof ImportedNode)
								var sourceNodeName = sourceNode .getImportedName ();
							else
								var sourceNodeName = generator .Name (sourceNode);
	
							if (destinationNode instanceof ImportedNode)
								var destinationNodeName = destinationNode .getImportedName ();
							else
								var destinationNodeName = generator .Name (destinationNode);
	
							stream .string += "\n";
							stream .string += "\n";
							stream .string += generator .Indent ();
							stream .string += "ROUTE";
							stream .string += " ";
							stream .string += sourceNodeName;
							stream .string += ".";
							stream .string += sourceField;
							stream .string += " ";
							stream .string += "TO";
							stream .string += " ";
							stream .string += destinationNodeName;
							stream .string += ".";
							stream .string += destinationField;
						}
					});
				}
			}
			else
				throw new Error ("ImportedNode.toXMLStream: Inline node does not exist.");
		},
		toXMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			if (generator .ExistsNode (this .getInlineNode ()))
			{
				stream .string += generator .Indent ();
				stream .string += "<IMPORT";
				stream .string += " ";
				stream .string += "inlineDEF='";
				stream .string += generator .XMLEncode (generator .Name (this .getInlineNode ()));
				stream .string += "'";
				stream .string += " ";
				stream .string += "importedDEF='";
				stream .string += generator .XMLEncode (this .getExportedName ());
				stream .string += "'";

				if (this .getImportedName () !== this .getExportedName ())
				{
					stream .string += " ";
					stream .string += "AS='";
					stream .string += generator .XMLEncode (this .getImportedName ());
					stream .string += "'";
				}

				stream .string += "/>";

				try
				{
					generator .AddRouteNode (this);
					generator .AddImportedNode (this .getExportedNode () .getValue (), this .getImportedName ());
				}
				catch (error)
				{
					// Output unresolved routes.

					this .routes .forEach (function (route)
					{
						var
							sourceNode       = route .sourceNode,
							sourceField      = route .sourceField,
							destinationNode  = route .destinationNode,
							destinationField = route .destinationField;

						if (generator .ExistsRouteNode (sourceNode) && generator .ExistsRouteNode (destinationNode))
						{
							if (sourceNode instanceof ImportedNode)
								var sourceNodeName = sourceNode .getImportedName ();
							else
								var sourceNodeName = generator .Name (sourceNode);
	
							if (destinationNode instanceof ImportedNode)
								var destinationNodeName = destinationNode .getImportedName ();
							else
								var destinationNodeName = generator .Name (destinationNode);
	
							stream .string += "\n";
							stream .string += "\n";
							stream .string += generator .Indent ();
							stream .string += "<ROUTE";
							stream .string += " ";
							stream .string += "fromNode='";
							stream .string += generator .XMLEncode (sourceNodeName);
							stream .string += "'";
							stream .string += " ";
							stream .string += "fromField='";
							stream .string += generator .XMLEncode (sourceField);
							stream .string += "'";
							stream .string += " ";
							stream .string += "toNode='";
							stream .string += generator .XMLEncode (destinationNodeName);
							stream .string += "'";
							stream .string += " ";
							stream .string += "toField='";
							stream .string += generator .XMLEncode (destinationField);
							stream .string += "'";
							stream .string += "/>";
						}
					});
				}
			}
			else
				throw new Error ("ImportedNode.toXMLStream: Inline node does not exist.");
		},
		dispose: function ()
		{
			this .inlineNode .loadState_ .removeInterest ("set_loadState__", this);

			this .deleteRoutes ();

			X3DBaseNode .prototype .dispose .call (this);
		},
	});

	return ImportedNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/X3DInfoArray',[],function ()
{
"use strict";

	var handler =
	{
		get: function (target, key)
		{
			var value = target [key];

			if (value !== undefined)
				return value;

			value = target .array [key];

			if (value !== undefined)
				return value;

			return target .index .get (key);
		},
		set: function (target, key, value)
		{
			return false;
		},
		has: function (target, key)
		{
			if (Number .isInteger (+key))
				return key < target .array .length;

			return key in target;
		},
		enumerate: function (target)
		{
			var indices = [ ];

			for (var i = 0, length = target .array .length; i < length; ++ i)
				array .push (i);

			return indices [Symbol .iterator] ();
		},
	};

	function X3DInfoArray ()
	{
		this .array = [ ];
		this .index = new Map ();

		return new Proxy (this, handler);
	}

	Object .assign (X3DInfoArray .prototype,
	{
		constructor: X3DInfoArray,
		add: function (key, value)
		{
			this .array .push (value);
			this .index .set (key, value);
		},
		addAlias: function (key, value)
		{
			this .index .set (key, this .index .get (value));
		},
		get: function (key)
		{
			return this .index .get (key);
		},
		getValue: function ()
		{
			return this .array;
		},
		toVRMLStream: function (stream)
		{
			this .array .forEach (function (value)
			{
				try
				{
					value .toVRMLStream (stream);

					stream .string += "\n";
				}
				catch (error)
				{
					console .log (error);
				}
			});
		},
		toXMLStream: function (stream)
		{
			this .array .forEach (function (value)
			{
				try
				{
					value .toXMLStream (stream);

					stream .string += "\n";
				}
				catch (error)
				{
					console .log (error);
				}
			});
		},
	});

	return X3DInfoArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/ExternProtoDeclarationArray',[
	"x_ite/Configuration/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

	function ExternProtoDeclarationArray (array)
	{
		return X3DInfoArray .call (this);
	}

	ExternProtoDeclarationArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
	{
		constructor: ExternProtoDeclarationArray,
		toVRMLStream: function (stream)
		{
			this .array .forEach (function (value)
			{
				try
				{
					value .toVRMLStream (stream);
	
					stream .string += "\n";
					stream .string += "\n";
				}
				catch (error)
				{
					console .log (error);
				}
			});
		},
	});

	return ExternProtoDeclarationArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/ProtoDeclarationArray',[
	"x_ite/Configuration/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

	function ProtoDeclarationArray (array)
	{
		return X3DInfoArray .call (this);
	}

	ProtoDeclarationArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
	{
		constructor: ProtoDeclarationArray,
		toVRMLStream: function (stream)
		{
			this .array .forEach (function (value)
			{
				try
				{
					value .toVRMLStream (stream);
	
					stream .string += "\n";
					stream .string += "\n";
				}
				catch (error)
				{
					console .log (error);
				}
			});
		},
	});

	return ProtoDeclarationArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Routing/RouteArray',[],function ()
{
"use strict";

	var handler =
	{
		get: function (target, key)
		{
			var value = target [key];
	
			if (value !== undefined)
				return value;

			return target .array [key];
		},
		set: function (target, key, value)
		{
			return false;
		},
		has: function (target, key)
		{
			if (Number .isInteger (+key))
				return key < target .array .length;

			return key in target;
		},
		enumerate: function (target)
		{
			var indices = [ ];

			for (var i = 0, length = target .array .length; i < length; ++ i)
				array .push (i);

			return indices [Symbol .iterator] ();
		},
	};

	function RouteArray ()
	{
		this .array = [ ];
		
		return new Proxy (this, handler);
	}

	Object .assign (RouteArray .prototype,
	{
		constructor: RouteArray,
		getValue: function ()
		{
			return this .array;
		},
		toVRMLStream: function (stream)
		{
			this .array .forEach (function (route)
			{
				try
				{
					route .toVRMLStream (stream);
	
					stream .string += "\n";
				}
				catch (error)
				{
					console .log (error);
				}
			});
		},
		toXMLStream: function (stream)
		{
			this .array .forEach (function (route)
			{
				try
				{
					route .toXMLStream (stream);
	
					stream .string += "\n";
				}
				catch (error)
				{
					console .log (error);
				}
			});
		},
	});

	return RouteArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Routing/X3DRoute',[
	"x_ite/Fields",
	"x_ite/Base/X3DObject",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function (Fields,
          X3DObject,
          X3DConstants,
          Generator)
{
"use strict";

	function X3DRoute (executionContext, sourceNode, sourceField, destinationNode, destinationField)
	{
		X3DObject .call (this, executionContext);

		this ._executionContext = executionContext;
		this ._sourceNode       = new Fields .SFNode (sourceNode);
		this ._sourceField      = sourceField;
		this ._destinationNode  = new Fields .SFNode (destinationNode);
		this ._destinationField = destinationField;

		// Must connect in every context, to make X3DBaseNode.hasRoutes work.

		sourceField .addFieldInterest (destinationField);

		sourceField      .addOutputRoute (this);
		destinationField .addInputRoute (this);
	}

	X3DRoute .prototype = Object .assign (Object .create (X3DObject .prototype),
	{
		getTypeName: function ()
		{
			return "X3DRoute";
		},
		getExecutionContext: function ()
		{
			return this ._executionContext;
		},
		getSourceNode: function ()
		{
			///  SAI
			return this ._sourceNode .valueOf ();
		},
		getSourceField: function ()
		{
			///  SAI
			return this ._sourceField .getName ();
		},
		getDestinationNode: function ()
		{
			///  SAI
			return this ._destinationNode .valueOf ();
		},
		getDestinationField: function ()
		{
			///  SAI
			return this ._destinationField .getName ();
		},
		disconnect: function ()
		{
			this ._sourceField .removeFieldInterest (this ._destinationField);

			this ._sourceField      .removeOutputRoute (this);
			this ._destinationField .removeInputRoute (this);
		},
		toStream: function (stream)
		{
			stream .string += Object .prototype .toString .call (this);
		},
		toVRMLStream: function (stream)
		{
			var
				generator           = Generator .Get (stream),
				sourceNodeName      = generator .LocalName (this ._sourceNode .getValue ()),
				destinationNodeName = generator .LocalName (this ._destinationNode .getValue ());

			stream .string += generator .Indent ();
			stream .string += "ROUTE";
			stream .string += " ";
			stream .string += sourceNodeName;
			stream .string += ".";
			stream .string += this ._sourceField .getName ();

			if (this ._sourceField .getAccessType () === X3DConstants .inputOutput)
				stream .string += "_changed";

			stream .string += " ";
			stream .string += "TO";
			stream .string += " ";
			stream .string += destinationNodeName;
			stream .string += ".";

			if (this ._destinationField .getAccessType () === X3DConstants .inputOutput)
				stream .string += "set_";

			stream .string += this ._destinationField .getName ();
		},
		toXMLStream: function (stream)
		{
			var
				generator           = Generator .Get (stream),
				sourceNodeName      = generator .LocalName (this ._sourceNode .getValue ()),
				destinationNodeName = generator .LocalName (this ._destinationNode .getValue ());

			stream .string += generator .Indent ();
			stream .string += "<ROUTE";
			stream .string += " ";
			stream .string += "fromNode='";
			stream .string += generator .XMLEncode (sourceNodeName);
			stream .string += "'";
			stream .string += " ";
			stream .string += "fromField='";
			stream .string += generator .XMLEncode (this ._sourceField .getName ());

			if (this ._sourceField .getAccessType () === X3DConstants .inputOutput)
				stream .string += "_changed";

			stream .string += "'";
			stream .string += " ";
			stream .string += "toNode='";
			stream .string += generator .XMLEncode (destinationNodeName);
			stream .string += "'";
			stream .string += " ";
			stream .string += "toField='";

			if (this ._destinationField .getAccessType () === X3DConstants .inputOutput)
				stream .string += "set_";

			stream .string += generator .XMLEncode (this ._destinationField .getName ());
			stream .string += "'";
			stream .string += "/>";
		},
		dispose: function ()
		{
			this .disconnect ();

			this ._executionContext .deleteRoute (this);

			X3DObject .prototype .dispose .call (this);
		}
	});

	Object .defineProperty (X3DRoute .prototype, "sourceNode",
	{
		get: function ()
		{
			return this ._sourceNode .valueOf ();
		},
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DRoute .prototype, "sourceField",
	{
		get: function ()
		{
			return this ._sourceField .getName ();
		},
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DRoute .prototype, "destinationNode",
	{
		get: function ()
		{
			return this ._destinationNode .valueOf ();
		},
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DRoute .prototype, "destinationField",
	{
		get: function ()
		{
			return this ._destinationField .getName ();
		},
		enumerable: true,
		configurable: false
	});

	return X3DRoute;
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Bits/X3DCast',[
	"x_ite/Fields",
],
function (Fields)
{
"use strict";

	return function (type, node)
	{
		try
		{
			if (node)
			{
				if (node instanceof Fields .SFNode)
					node = node .getValue ();

				if (node)
				{
					node = node .getInnerNode ();
				
					if (node .getType () .indexOf (type) !== -1)
						return node;
				}
			}
		}
		catch (error)
		{ }

		return null;
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/X3DExecutionContext',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Execution/ImportedNode",
	"x_ite/Prototype/ExternProtoDeclarationArray",
	"x_ite/Prototype/ProtoDeclarationArray",
	"x_ite/Routing/RouteArray",
	"x_ite/Routing/X3DRoute",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
	"x_ite/Fields/SFNodeCache",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBaseNode,
          ImportedNode,
          ExternProtoDeclarationArray,
          ProtoDeclarationArray,
          RouteArray,
          X3DRoute,
          X3DCast,
          X3DConstants,
          Generator,
          SFNodeCache,
          Algorithm)
{
"use strict";

	function X3DExecutionContext (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .addChildObjects ("rootNodes", new Fields .MFNode ());

		this .rootNodes_ .addCloneCount (1);

		this ._uninitializedNodes   = [ ];
		this ._uninitializedNodes2  = [ ];
		this ._namedNodes           = new Map ();
		this ._importedNodes        = new Map ();
		this ._protos               = new ProtoDeclarationArray ();
		this ._externprotos         = new ExternProtoDeclarationArray ();
		this ._routes               = new RouteArray ();
		this ._routeIndex           = new Map ();
	}

	X3DExecutionContext .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: X3DExecutionContext,
		setup: function ()
		{
			X3DBaseNode .prototype .setup .call (this);

			var X3DProtoDeclaration = require ("x_ite/Prototype/X3DProtoDeclaration");

			if (this .constructor !== X3DProtoDeclaration)
			{
				// Setup nodes.

				while (this ._uninitializedNodes .length)
				{
					var uninitializedNodes = this ._uninitializedNodes;

					this ._uninitializedNodes  = this ._uninitializedNodes2;
					this ._uninitializedNodes2 = uninitializedNodes;

					for (var i = 0, length = uninitializedNodes .length; i < length; ++ i)
						uninitializedNodes [i] .setup ();

					uninitializedNodes .length = 0;
				}
			}
		},
		isMasterContext: function ()
		{
			return false;
		},
		isRootContext: function ()
		{
			return false;
		},
		getSpecificationVersion: function ()
		{
			return this .getExecutionContext () .getSpecificationVersion ();
		},
		getEncoding: function ()
		{
			return this .getExecutionContext () .getEncoding ();
		},
		getWorldURL: function ()
		{
			return this .getURL () .location;
		},
		getURL: function ()
		{
			return this .getExecutionContext () .getURL ();
		},
		getProfile: function ()
		{
			return this .getExecutionContext () .getProfile ();
		},
		getComponents: function ()
		{
			return this .getExecutionContext () .getComponents ();
		},
		fromUnit: function (category, value)
		{
			return this .getExecutionContext () .fromUnit (category, value);
		},
		toUnit: function (category, value)
		{
			return this .getExecutionContext () .toUnit (category, value);
		},
		getUnits: function ()
		{
			return this .getExecutionContext () .getUnits ();
		},
		createNode: function (typeName, setup)
		{
			if (setup === false)
			{
				var Type = this .getBrowser () .getSupportedNode (typeName);

				if (! Type)
					return null;

				var baseNode = new Type (this);

				return baseNode;
			}
			else
			{
				var Type = this .getBrowser () .getSupportedNode (typeName);

				if (! Type)
					throw new Error ("Unknown node type '" + typeName + "'.");

				var baseNode = new Type (this);

				baseNode .setup ();

				return SFNodeCache .add (baseNode);
			}
		},
		createProto: function (name, setup)
		{
			var executionContext = this;

			for (;;)
			{
				var proto = executionContext .protos .get (name);

				if (proto)
					return proto .createInstance (this, setup);

				var externproto = executionContext .externprotos .get (name);

				if (externproto)
					return externproto .createInstance (this, setup);

				if (executionContext .isRootContext ())
					break;

				executionContext = executionContext .getExecutionContext ();
			}

			if (setup === false)
				return null;
			else
				throw new Error ("Unknown proto or externproto type '" + name + "'.");
		},
		addUninitializedNode: function (node)
		{
			this ._uninitializedNodes .push (node);
		},
		addNamedNode: function (name, node)
		{
			if (this ._namedNodes .has (name))
				throw new Error ("Couldn't add named node: node named '" + name + "' is already in use.");

			this .updateNamedNode (name, node);
		},
		updateNamedNode: function (name, node)
		{
			if (! (node instanceof Fields .SFNode || node instanceof X3DBaseNode))
				throw new Error ("Couldn't update named node: node must be of type SFNode.");

			name = String (name);

			var baseNode = node instanceof Fields .SFNode ? node .getValue () : node;

			if (! baseNode)
				throw new Error ("Couldn't update named node: node IS NULL.");

			if (baseNode .getExecutionContext () !== this)
				throw new Error ("Couldn't update named node: node does not belong to this execution context.");

			if (name .length === 0)
				throw new Error ("Couldn't update named node: node name is empty.");

			// Remove named node.

			this .removeNamedNode (baseNode .getName ());
			this .removeNamedNode (name);

			// Update named node.

			baseNode .setName (name);

			this ._namedNodes .set (name, baseNode);
		},
		removeNamedNode: function (name)
		{
			this ._namedNodes .delete (name);
		},
		getNamedNode: function (name)
		{
			var baseNode = this ._namedNodes .get (name);

			if (baseNode)
				return SFNodeCache .get (baseNode);

			throw new Error ("Named node '" + name + "' not found.");
		},
		getNamedNodes: function ()
		{
			return this ._namedNodes;
		},
		getUniqueName: function (name)
		{
			var _TrailingNumbers = /(_\d+$)/;

			name = name .replace (_TrailingNumbers, "");

			var
				newName = name,
				i       = 64;

			for (; i;)
			{
				if (this ._namedNodes .has (newName) || newName .length === 0)
				{
					var
						min = i,
						max = i <<= 1;

					newName  = name;
					newName += '_';
					newName += Math .round (Algorithm .random (min, max));
				}
				else
					break;
			}

			return newName;
		},
		addImportedNode: function (inlineNode, exportedName, importedName)
		{
			if (importedName === undefined)
				importedName = exportedName;

			if (this ._importedNodes .has (importedName))
				throw new Error ("Couldn't add imported node: imported name '" + importedName + "' already in use.");

			this .updateImportedNode (inlineNode, exportedName, importedName);
		},
		updateImportedNode: function (inlineNode, exportedName, importedName)
		{
			inlineNode   = X3DCast (X3DConstants .Inline, inlineNode);
			exportedName = String (exportedName);
			importedName = importedName === undefined ? exportedName : String (importedName);

			if (! inlineNode)
				throw new Error ("Node named is not an Inline node.");

			if (inlineNode .getExecutionContext () !== this)
				throw new Error ("Couldn't update imported node: Inline node does not belong to this execution context.");

			if (exportedName .length === 0)
				throw new Error ("Couldn't update imported node: exported name is empty.");

			if (importedName .length === 0)
				throw new Error ("Couldn't update imported node: imported name is empty.");

			// Update existing imported node.

			for (var item of this ._importedNodes)
			{
				var
					key          = item [0],
					importedNode = item [1];

				if (importedNode .getInlineNode () === inlineNode && importedNode .getExportedName () === exportedName)
				{
					this ._importedNodes .delete (key);

					this ._importedNodes .set (importedName, importedNode);

					importedNode .setImportedName (importedName);
					return;
				}
			}

			// Add new imported node.

			this .removeImportedNode (importedName);

			var importedNode = new ImportedNode (this, inlineNode, exportedName, importedName);

			this ._importedNodes .set (importedName, importedNode);

			importedNode .setup ();
		},
		removeImportedNode: function (importedName)
		{
			var importedNode = this ._importedNodes .get (importedName);

			if (! importedNode)
				return;

			importedNode .dispose ();

			this ._importedNodes .delete (importedName);
		},
		getImportedNode: function (importedName)
		{
			var importedNode = this ._importedNodes .get (importedName);

			if (importedNode)
				return importedNode .getExportedNode () .valueOf ();

			throw new Error ("Imported node '" + importedName + "' not found.");
		},
		getImportedNodes: function ()
		{
			return this ._importedNodes;
		},
		getLocalNode: function (name)
		{
			try
			{
				return this .getNamedNode (name);
			}
			catch (error)
			{
				var importedNode = this ._importedNodes .get (name);

				if (importedNode)
					return SFNodeCache .get (importedNode);

				throw new Error ("Unknown named or imported node '" + name + "'.");
			}
		},
		getLocalName: function (node)
		{
			if (! (node instanceof Fields .SFNode))
				throw new Error ("Couldn't get local name: node is NULL.");

			if (node .getValue () .getExecutionContext () === this)
				return node .getValue () .getName ();

			for (var importedNode of this ._importedNodes .values ())
			{
				try
				{
					if (importedNode .getExportedNode () === node)
						return key;
				}
				catch (error)
				{ }
			}

			throw new Error ("Couldn't get local name: node is shared.");
		},
		setRootNodes: function () { },
		getRootNodes: function ()
		{
			return this .rootNodes_;
		},
		getProtoDeclaration: function (name)
		{
			var proto = this ._protos .get (name);

			if (proto)
				return proto;

			throw new Error ("Proto declaration '" + name + "' not found.");
		},
		getProtoDeclarations: function ()
		{
			return this ._protos;
		},
		getExternProtoDeclaration: function (name)
		{
			var externproto = this ._externprotos .get (name);

			if (externproto)
				return externproto;

			throw new Error ("Extern proto declaration '" + name + "' not found.");
		},
		getExternProtoDeclarations: function ()
		{
			return this ._externprotos;
		},
		addRoute: function (sourceNode, sourceField, destinationNode, destinationField)
		{
			sourceField      = String (sourceField);
			destinationField = String (destinationField);

			if (! (sourceNode instanceof Fields .SFNode))
				throw new Error ("Bad ROUTE specification: source node must be of type SFNode.");

			if (! (destinationNode instanceof Fields .SFNode))
				throw new Error ("Bad ROUTE specification: destination node must be of type SFNode.");

			sourceNode      = sourceNode      .getValue ();
			destinationNode = destinationNode .getValue ();

			if (! sourceNode)
				throw new Error ("Bad ROUTE specification: source node is NULL.");

			if (! destinationNode)
				throw new Error ("Bad ROUTE specification: destination node is NULL.");

			// Imported nodes handling.

			var
				importedSourceNode      = sourceNode      instanceof ImportedNode ? sourceNode      : null,
				importedDestinationNode = destinationNode instanceof ImportedNode ? destinationNode : null;

			try
			{
				// If sourceNode is shared node try to find the corresponding ImportedNode.
				if (sourceNode .getExecutionContext () !== this)
					importedSourceNode = this .getLocalNode (this .getLocalName (sourceNode));
			}
			catch (error)
			{
				// Source node is shared but not imported.
			}

			try
			{
				// If destinationNode is shared node try to find the corresponding ImportedNode.
				if (destinationNode .getExecutionContext () !== this)
					importedDestinationNode = this .getLocalNode (this .getLocalName (destinationNode));
			}
			catch (error)
			{
				// Destination node is shared but not imported.
			}

			if (importedSourceNode instanceof ImportedNode)
				importedSourceNode .addRoute (importedSourceNode, sourceField, destinationNode, destinationField);

			if (importedDestinationNode instanceof ImportedNode)
				importedDestinationNode .addRoute (sourceNode, sourceField, importedDestinationNode, destinationField);

			// If either sourceNode or destinationNode is an ImportedNode return here without value.
			if (importedSourceNode === sourceNode || importedDestinationNode === destinationNode)
				return;

			// Create route and return.

			return this .addSimpleRoute (sourceNode, sourceField, destinationNode, destinationField);
		},
		addSimpleRoute: function (sourceNode, sourceField, destinationNode, destinationField)
		{
			try
			{
				// Private function.
				// Create route and return.

				sourceField      = sourceNode      .getField (sourceField),
				destinationField = destinationNode .getField (destinationField);

				if (! sourceField .isOutput ())
					throw new Error ("Field named '" + sourceField .getName () + "' in node named '" + sourceNode .getName () + "' of type " + sourceNode .getTypeName () + " is not an output field.");

				if (! destinationField .isInput ())
					throw new Error ("Field named '" + destinationField .getName () + "' in node named '" + destinationNode .getName () + "' of type " + destinationNode .getTypeName () + " is not an input field.");

				if (sourceField .getType () !== destinationField .getType ())
					throw new Error ("ROUTE types " + sourceField .getTypeName () + " and " + destinationField .getTypeName () + " do not match.");

				var
					id    = sourceField .getId () + "." + destinationField .getId (),
					route = this ._routeIndex .get (id);

				if (route)
					return route;

				var route = new X3DRoute (this, sourceNode, sourceField, destinationNode, destinationField);

				this ._routes .getValue () .push (route);
				this ._routeIndex .set (id, route);

				return route;
			}
			catch (error)
			{
				throw new Error ("Bad ROUTE specification: " + error .message);
			}
		},
		deleteRoute: function (route)
		{
			try
			{
				// sourceNode, sourceField, destinationNode, destinationField
				if (arguments .length === 4)
				{
					route = this .getRoute .apply (this, arguments);

					if (! route)
						return;
				}

				var
					sourceField      = route ._sourceField,
					destinationField = route ._destinationField,
					id               = sourceField .getId () + "." + destinationField .getId (),
					index            = this ._routes .getValue () .indexOf (route);

				route .disconnect ();

				if (index !== -1)
					this ._routes .getValue () .splice (index, 1);

				this ._routeIndex .delete (id);
			}
			catch (error)
			{
				console .log (error);
			}
		},
		getRoute: function (sourceNode, sourceField, destinationNode, destinationField)
		{
			if (! sourceNode .getValue ())
				throw new Error ("Bad ROUTE specification: sourceNode is NULL.");

			if (! destinationNode .getValue ())
				throw new Error ("Bad ROUTE specification: destinationNode is NULL.");

			var
				sourceField      = sourceNode .getValue () .getField (sourceField),
				destinationField = destinationNode .getValue () .getField (destinationField),
				id               = sourceField .getId () + "." + destinationField .getId ();

			return this ._routeIndex .get (id);
		},
		getRoutes: function ()
		{
			return this ._routes;
		},
		changeViewpoint: function (name)
		{
			try
			{
				var
					namedNode = this .getNamedNode (name),
					viewpoint = X3DCast (X3DConstants .X3DViewpointNode, namedNode);

				if (! viewpoint)
					throw 1;

				viewpoint .setAnimate (true); // VRML

				if (viewpoint .isBound_ .getValue ())
					viewpoint .transitionStart (viewpoint);

				else
					viewpoint .set_bind_ = true;
			}
			catch (error)
			{
				if (! this .isRootContext ())
					this .getExecutionContext () .changeViewpoint (name);
				else
					throw new Error ("Viewpoint named '" + name + "' not found.");
			}
		},
		toVRMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			generator .PushExecutionContext (this);
			generator .EnterScope ();
			generator .ImportedNodes (this .getImportedNodes ());

			// Output extern protos

			this .getExternProtoDeclarations () .toVRMLStream (stream);

			// Output protos

			this .getProtoDeclarations () .toVRMLStream (stream);

			// Output root nodes

			var rootNodes = this .getRootNodes ();

			for (var i = 0, length = rootNodes .length; i < length; ++ i)
			{
				stream .string += generator .Indent ();

				rootNodes [i] .toVRMLStream (stream);

				stream .string += "\n";

				if (i !== length - 1)
					stream .string += "\n";
			}

			// Output imported nodes

			var importedNodes = this .getImportedNodes ();

			if (importedNodes .size)
			{
				stream .string += "\n";

				importedNodes .forEach (function (importedNode)
				{
					try
					{
						importedNode .toVRMLStream (stream);

						stream .string += "\n";
					}
					catch (error)
					{ }
				});
			}

			// Output routes

			var routes = this .getRoutes ();

			if (routes .length)
			{
				stream .string += "\n";

				routes .toVRMLStream (stream);
			}

			generator .LeaveScope ();
			generator .PopExecutionContext ();
		},
		toXMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			generator .PushExecutionContext (this);
			generator .EnterScope ();
			generator .ImportedNodes (this .getImportedNodes ());

			// Output extern protos

			this .getExternProtoDeclarations () .toXMLStream (stream);

			// Output protos

			this .getProtoDeclarations () .toXMLStream (stream);

			// Output root nodes

			var rootNodes = this .getRootNodes ();

			if (rootNodes .length)
			{
				rootNodes .toXMLStream (stream);

				stream .string += "\n";
			}

			// Output imported nodes

			var importedNodes = this .getImportedNodes ();

			importedNodes .forEach (function (importedNode)
			{
				try
				{
					importedNode .toXMLStream (stream);

					stream .string += "\n";
				}
				catch (error)
				{ }
			});

			// Output routes

			this .getRoutes () .toXMLStream (stream);

			generator .LeaveScope ();
			generator .PopExecutionContext ();
		},
	});

	Object .defineProperty (X3DExecutionContext .prototype, "specificationVersion",
	{
		get: function () { return this .getSpecificationVersion (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExecutionContext .prototype, "encoding",
	{
		get: function () { return this .getEncoding (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExecutionContext .prototype, "profile",
	{
		get: function () { return this .getProfile (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExecutionContext .prototype, "components",
	{
		get: function () { return this .getComponents (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExecutionContext .prototype, "worldURL",
	{
		get: function () { return this .getWorldURL (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExecutionContext .prototype, "units",
	{
		get: function () { return this .getUnits (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExecutionContext .prototype, "rootNodes",
	{
		get: function () { return this .getRootNodes (); },
		set: function (value) { this .setRootNodes (value); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExecutionContext .prototype, "protos",
	{
		get: function () { return this .getProtoDeclarations (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExecutionContext .prototype, "externprotos",
	{
		get: function () { return this .getExternProtoDeclarations (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExecutionContext .prototype, "routes",
	{
		get: function () { return this .getRoutes (); },
		enumerable: true,
		configurable: false
	});

	return X3DExecutionContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/ComponentInfo',[
	"x_ite/Fields",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function (Fields,
          X3DConstants,
          Generator)
{
"use strict";

	function ComponentInfo (name, level, title, providerUrl)
	{
		this .name        = name;
		this .level       = level;
		this .title       = title;
		this .providerUrl = providerUrl;

		Object .preventExtensions (this);
		Object .freeze (this);
		Object .seal (this);
	}

	Object .assign (ComponentInfo .prototype,
	{
		constructor: ComponentInfo,
		toVRMLStream: function (stream)
		{
			stream .string += "COMPONENT";
			stream .string += " ";
			stream .string += this .name;
			stream .string += " ";
			stream .string += ":";
			stream .string += " ";
			stream .string += this .level;
		},
		toXMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			stream .string += generator .Indent ();
			stream .string += "<component";
			stream .string += " ";
			stream .string += "name='";
			stream .string += this .name;
			stream .string += "'";
			stream .string += " ";
			stream .string += "level='";
			stream .string += this .level;
			stream .string += "'";
			stream .string += "/>";
		},
	});

	return ComponentInfo;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/ComponentInfoArray',[
	"x_ite/Configuration/ComponentInfo",
	"x_ite/Configuration/X3DInfoArray",
],
function (ComponentInfo,
          X3DInfoArray)
{
"use strict";

	function ComponentInfoArray (array)
	{
		var proxy = X3DInfoArray .call (this);

		if (array)
		{
			for (var i = 0, length = array .length; i < length; ++ i)
				this .add (array [i] .name, array [i]);
		}

		return proxy;
	}

	ComponentInfoArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
	{
		constructor: ComponentInfoArray,
		addBaseComponent: function (value)
		{
			this .add (value .name, new ComponentInfo (value .name, value .level, value .title, value .providerUrl));
		},
	});

	return ComponentInfoArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/UnitInfo',[
	"x_ite/InputOutput/Generator",
],
function (Generator)
{
"use strict";

	function UnitInfo (category, name, conversionFactor)
	{
		Object .defineProperty (this, "category", {
		    value: category,
		    writable: false,
		});

		this .name             = name;
		this .conversionFactor = conversionFactor;
	}

	Object .assign (UnitInfo .prototype,
	{
		constructor: UnitInfo,
		toVRMLStream: function (stream)
		{
			stream .string += "UNIT";
			stream .string += " ";
			stream .string += this .category;
			stream .string += " ";
			stream .string += this .name;
			stream .string += " ";
			stream .string += this .conversionFactor;
		},
		toXMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			stream .string += generator .Indent ();
			stream .string += "<unit";
			stream .string += " ";
			stream .string += "category='";
			stream .string += this .category;
			stream .string += "'";
			stream .string += " ";
			stream .string += "name='";
			stream .string += generator .XMLEncode (this .name);
			stream .string += "'";
			stream .string += " ";
			stream .string += "conversionFactor='";
			stream .string += this .conversionFactor;
			stream .string += "'";
			stream .string += "/>";
		},
	});

	Object .defineProperty (UnitInfo .prototype, "conversion_factor",
	{
		get: function () { return this .conversionFactor; },
		enumerable: true,
		configurable: false
	});

	return UnitInfo;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/UnitInfoArray',[
	"x_ite/Configuration/X3DInfoArray",
],
function (X3DInfoArray)
{
"use strict";

	function UnitInfoArray ()
	{
		return X3DInfoArray .call (this);
	}

	UnitInfoArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
	{
		constructor: UnitInfoArray,
	});

	return UnitInfoArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/ExportedNode',[
	"x_ite/Fields",
	"x_ite/Base/X3DObject",
	"x_ite/InputOutput/Generator",
],
function (Fields,
          X3DObject,
          Generator)
{
"use strict";

	function ExportedNode (exportedName, localNode)
	{
		X3DObject .call (this);

		this .exportedName = exportedName;
		this .localNode    = localNode;
	}

	ExportedNode .prototype = Object .assign (Object .create (X3DObject .prototype),
	{
		constructor: ExportedNode,
		getTypeName: function ()
		{
			return "ExportedNode";
		},
		getExportedName: function ()
		{
			return this .exportedName;
		},
		getLocalNode: function ()
		{
			return this .localNode;
		},
		toVRMLStream: function (stream)
		{
			var
				generator = Generator .Get (stream),
				localName = generator .LocalName (this .localNode);

			stream .string += generator .Indent ();
			stream .string += "EXPORT";
			stream .string += " ";
			stream .string += localName;

			if (this .exportedName !== localName)
			{
				stream .string += " ";
				stream .string += "AS";
				stream .string += " ";
				stream .string += this .exportedName;
			}
		},
		toXMLStream: function (stream)
		{
			var
				generator = Generator .Get (stream),
				localName = generator .LocalName (this .localNode);

			stream .string += generator .Indent ();
			stream .string += "<EXPORT";
			stream .string += " ";
			stream .string += "localDEF='";
			stream .string += generator .XMLEncode (localName);
			stream .string += "'";

			if (this .exportedName !== localName)
			{
				stream .string += " ";
				stream .string += "AS='";
				stream .string += generator .XMLEncode (this .exportedName);
				stream .string += "'";
			}

			stream .string += "/>";
		},
	});

	return ExportedNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Networking/URI',[],function ()
{
"use strict";

	/*
	 *  Path
	 */

	function Path (path, separator)
	{
		switch (arguments .length)
		{
			case 2:
			{
				var value = this .value = path ? path .split (separator) : [];

				value .separator         = separator;
				value .leadingSeparator  = false;
				value .trailingSeparator = false;

				if (value .length)
				{
					if (value [0] .length === 0)
					{
						value .shift ();
						value .leadingSeparator = true;
					}
				}

				if (value .length)
				{
					if (value [value .length - 1] .length === 0)
					{
						value .pop ();
						value .trailingSeparator = true;
					}
				}

				break;
			}
			case 4:
			{
				var value = this .value = arguments [0];

				value .separator         = arguments [1];
				value .leadingSeparator  = arguments [2];
				value .trailingSeparator = arguments [3];
				break;
			}
		}
	}

	Path .prototype =
	{
		copy: function ()
		{
			var value = this .value;

			return new Path (value .slice (0, value .length),
			                 value .separator,
			                 value .leadingSeparator,
			                 value .trailingSeparator);
		},
		get length ()
		{
			return this .value .length;
		},
		get leadingSeparator ()
		{
			return this .value .leadingSeparator;
		},
		get trailingSeparator ()
		{
			return this .value .trailingSeparator;
		},
		get root ()
		{
			return new Path ([ ],
			                this .value .separator,
			                true,
			                true);
		},
		get base ()
		{
			if (this .value .trailingSeparator)
				return this .copy ();

			return this .parent;
		},
		get parent ()
		{
			var value = this .value;

			switch (value .length)
			{
				case 0:
				case 1:
				{
					if (value .leadingSeparator)
						return this .root;

					return new Path ([ ".." ], value .separator, false, false);
				}
				default:
				{
					return new Path (value .slice (0, value .length - 1),
				                     value .separator,
				                     value .leadingSeparator,
				                     true);
				}
			}

		},
		get basename ()
		{
			var
				value  = this .value,
				length = value .length;

			if (length)
				return value [length - 1];

			return "";
		},
		get stem ()
		{
			var basename = this .basename;

			if (this .trailingSeparator && basename .length)
			{
				var extension = this .extension;

				if (extension .length)
					return basename .substr (0, basename .length - extension .length);
			}

			return basename;
		},
		get extension ()
		{
			var
				basename = this .basename,
				dot      = basename .lastIndexOf (".");

			if (dot > 0)
				return basename .substr (dot);

			return "";
		},
		getRelativePath: function (descendant)
		{
			if (! descendant .leadingSeparator)
				return descendant;

			var
				path           = new Path ([ ], "/", false, descendant .value .trailingSeparator),
				basePath       = this .removeDotSegments () .base,
				descendantPath = descendant .removeDotSegments ();

			var i, j, l;

			for (i = 0, l = Math .min (basePath .value .length, descendantPath .value .length); i < l ; ++ i)
			{
				if (basePath .value [i] !== descendantPath .value [i])
					break;
			}

			for (j = i, l = basePath .value .length; j < l; ++ j)
				path .value .push ("..");

			for (j = i, l = descendantPath .value .length; j < l; ++ j)
				path .value .push (descendantPath .value [j]);

			if (path .value .length === 0)
				path .value .push (".");

			return path;
		},
		removeDotSegments: function ()
		{
			var
				value = this .value,
				path  = new Path ([ ], value .separator, value .leadingSeparator, value .trailingSeparator);

			if (value .length)
			{
				for (var i = 0; i < value .length; ++ i)
				{
					var segment = value [i];

					switch (segment)
					{
						case "":
						{
							break;
						}
						case ".":
						{
							path .value .trailingSeparator = true;
							break;
						}
						case "..":
						{
							path .value .trailingSeparator = true;

							if (path .value .length)
								path .value .pop ();

							break;
						}
						default:
						{
							path .value .trailingSeparator = false;
							path .value .push (segment);
						}
					}
				}

				path .value .trailingSeparator = path .value .trailingSeparator || value .trailingSeparator;
			}

			return path;
		},
		escape: function ()
		{
			var
				copy  = this .copy (),
				value = copy .value;

			for (var i = 0, length = value .length; i < length; ++ i)
				value [i] = encodeURI (value [i]);

			return copy;
		},
		unescape: function ()
		{
			var
				copy  = this .copy (),
				value = copy .value;

			for (var i = 0, length = value .length; i < length; ++ i)
				value [i] = unescape (value [i]);

			return copy;
		},
		toString: function ()
		{
			var
				value  = this .value,
				string = "";

			if (value .leadingSeparator)
				string += value .separator;

			string += value .join (value .separator);

			if (value .leadingSeparator && value .length === 0)
				return string;

			if (value .trailingSeparator)
				string += value .separator;

			return string;
		},
	};

	/*
	 *  URI
	 *  https://tools.ietf.org/html/rfc3986
	 */

	var wellKnownPorts =
	{
		ftp:   21,
		http:  80,
		https: 443,
		ftps:  990,
	};

	var
		address   = /^(?:([^:\/?#]*?):)?(?:(\/\/)([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?$/,
		authority = /^(.*?)(?:\:([^:]*))?$/;

	function parse (uri, string)
	{
		var result = address .exec (string);

		if (result)
		{
			uri .scheme    = result [1] || "";
			uri .slashs    = result [2] || "";
			uri .path      = new Path (unescape (result [4] || ""), "/");
			uri .query     = result [5] || "";
			uri .fragment  = unescape (result [6] || "");

			var result = authority .exec (result [3] || "");

			if (result)
			{
				uri .host = unescape (result [1] || "");
				uri .port = result [2] ? parseInt (result [2]) : 0;
			}

			uri .absolute = !! uri .slashs .length || uri .path [0] === "/";
			uri .local    = /^(?:file|data)$/ .test (uri .scheme) || (! uri .scheme && ! (uri .host || uri .port));
		}
		else
			uri .path = new Path ("", "/");

		uri .string = string;
	}

	function removeDotSegments (path)
	{
		return new Path (path, "/") .removeDotSegments ();
	}

	function URI (uri)
	{
		var value = this .value =
		{
			local:     true,
			absolute:  true,
			scheme:    "",
			slashs:    "",
			host:      "",
			port:      0,
			path:      null,
			query:     "",
			fragment:  "",
			string:    "",
		};

		switch (arguments .length)
		{
			case 0:
				value .path = new Path ("", "/");
				break;
			case 1:
			{
				parse (value, uri);
				break;
			}
			case 9:
			{
				value .local     = arguments [0];
				value .absolute  = arguments [1];
				value .scheme    = arguments [2];
				value .slashs    = arguments [3];
				value .host      = arguments [4];
				value .port      = arguments [5];
				value .path      = arguments [6];
				value .query     = arguments [7];
				value .fragment  = arguments [8];
				value .string    = this .createString ();
				break;
			}
		}
	};

	URI .prototype =
	{
		copy: function ()
		{
			var value = this .value;

			return new URI (value .local,
			                value .absolute,
			                value .scheme,
			                value .slashs,
			                value .host,
			                value .port,
			                value .path .copy (),
			                value .query,
			                value .fragment);
		},
		get length ()
		{
			return this .value .string .length;
		},
		isRelative: function ()
		{
			return ! this .value .absolute;
		},
		isAbsolute: function ()
		{
			return ! this .value .absolute;
		},
		isLocal: function ()
		{
			return this .value .local;
		},
		isNetwork: function ()
		{
			return ! this .value .local;
		},
		isDirectory: function ()
		{
			var value = this .value;

			if (value .path .length)
				return value .path .trailingSeparator;

			return this .isNetwork ();
		},
		isFile: function ()
		{
			return ! this .isDirectory ();
		},
		get hierarchy ()
		{
			var
				value     = this .value,
				hierarchy = "";

			hierarchy += value .slashs;
			hierarchy += this .authority;
			hierarchy += this .path;

			return hierarchy;
		},
		get authority ()
		{
			var
				value     = this .value,
				authority = value .host;

			if (value .port)
			{
				authority += ":";
				authority += value .port;
			}

			return authority;
		},
		get scheme ()
		{
			return this .value .scheme;
		},
		get host ()
		{
			return this .value .host;
		},
		get port ()
		{
			return this .value .port;
		},
		get wellKnownPort ()
		{
			var wellKnownPort = wellKnownPorts [this .value .scheme];

			if (wellKnownPort !== undefined)
				return wellKnownPort;

			return 0;
		},
		get path ()
		{
			return this .value .path .toString ();
		},
		set query (value)
		{
			this .value .query = value;
		},
		get query ()
		{
			return this .value .query;
		},
		set fragment (value)
		{
			this .value .fragment = value;
		},
		get fragment ()
		{
			return this .value .fragment;
		},
		get location ()
		{
			return this .toString ();
		},
		get root ()
		{
			var value = this .value;

			return new URI (value .local,
			                value .absolute,
			                value .scheme,
			                value .slashs,
			                value .host,
			                value .port,
			                new Path ("/", "/"),
			                "",
			                "");
		},
		get base ()
		{
			var value = this .value;

			if (this .isDirectory ())
			{
				return new URI (value .local,
				                value .absolute,
				                value .scheme,
				                value .slashs,
				                value .host,
				                value .port,
				                value .path .copy (),
				                "",
				                "");
			}

			return this .parent;
		},
		get parent ()
		{
			var value = this .value;

			return new URI (value .local,
			                value .absolute,
			                value .scheme,
			                value .slashs,
			                value .host,
			                value .port,
			                value .path .parent,
			                "",
			                "");
		},
		get filename ()
		{
			var value = this .value;

			return new URI (value .local,
			                value .absolute,
			                value .scheme,
			                value .slashs,
			                value .host,
			                value .port,
			                value .path .copy (),
			                "",
			                "");
		},
		get basename ()
		{
			return this .value .path .basename;
		},
		get stem ()
		{
			return this .value .path .stem;
		},
		get extension ()
		{
			return this .value .path .extension;
		},
		transform: function (reference)
		{
			if (! (reference instanceof URI))
				reference = new URI (reference .toString ());

			if (reference .scheme == "data")
				return new URI (reference .toString ());

			var
				value       = this .value,
				T_local     = false,
				T_absolute  = false,
				T_scheme    = "",
				T_slashs    = "",
				T_host      = "",
				T_port      = 0,
				T_path      = "",
				T_query     = "",
				T_fragment  = "";

			if (reference .scheme)
			{
				T_local    = reference .isLocal ();
				T_absolute = reference .isAbsolute ();
				T_scheme   = reference .scheme;
				T_slashs   = reference .value .slashs;
				T_host     = reference .host;
				T_port     = reference .port;
				T_path     = reference .path;
				T_query    = reference .query;
			}
			else
			{
				if (reference .authority)
				{
					T_local    = reference .isLocal ();
					T_absolute = reference .isAbsolute ();
					T_host     = reference .host;
					T_port     = reference .port;
					T_path     = reference .path;
					T_query    = reference .query;
				}
				else
				{
					if (reference .path .length === 0)
					{
						T_path = this .path;

						if (reference .query)
							T_query = reference .query;
						else
							T_query = value .query;
					}
					else
					{
						if (reference .path [0] === "/")
						{
							T_path = reference .path;
						}
						else
						{
							// merge (Base .path (), reference .path ());

							var base = this .base;

							if (base .path)
								T_path += base .path;
							else
								T_path = "/";

							T_path += reference .path;
						}

						T_query = reference .query;
					}

					T_local    = this .isLocal ();
					T_absolute = this .isAbsolute () || reference .isAbsolute ();
					T_host     = value .host;
					T_port     = value .port;
				}

				T_scheme = value .scheme;
				T_slashs = value .slashs;
			}

			T_fragment = reference .fragment;

			return new URI (T_local,
			                T_absolute,
			                T_scheme,
			                T_slashs,
			                T_host,
			                T_port,
			                removeDotSegments (T_path),
			                T_query,
			                T_fragment);
		},
		removeDotSegments: function ()
		{
			var value = this .value;

			return new URI (value .local,
			                value .absolute,
			                value .scheme,
			                value .slashs,
			                value .host,
			                value .port,
			                value .path .removeDotSegments (),
			                value .query,
			                value .fragment);
		},
		getRelativePath: function (descendant)
		{
			if (! (descendant instanceof URI))
				descendant = new URI (descendant .toString ());

			var value = this .value;

			if (value .scheme !== descendant .scheme)
				return descendant;

			if (this .authority !== descendant .authority)
				return descendant;

			return new URI (true,
			                false,
			                "",
			                "",
			                "",
			                0,
			                value .path .getRelativePath (descendant .value .path),
			                descendant .query,
			                descendant .fragment);
		},
		escape: function ()
		{
			var value = this .value;

			if (value .scheme === "data")
				return new URI (value .string);

			return new URI (value .local,
			                value .absolute,
			                value .scheme,
			                value .slashs,
			                value .host,
			                value .port,
			                value .path .escape (),
			                value .query,
			                escape (value .fragment));
		},
		unescape: function ()
		{
			var value = this .value;

			if (value .scheme === "data")
				return new URI (value .string);

			return new URI (value .local,
			                value .absolute,
			                value .scheme,
			                value .slashs,
			                value .host,
			                value .port,
			                value .path .unescape (),
			                value .query,
			                unescape (value .fragment));
		},
		toString: function ()
		{
			return this .value .string;
		},
		createString: function ()
		{
			var
				value  = this .value,
				string = this .value .scheme;

			if (value .scheme)
				string += ":";

			string += this .hierarchy;

			if (value .query)
				string += "?" + value .query;

			if (value .fragment)
				string += "#" + value .fragment;

			return string;
		},
	};

	return URI;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/X3DScene',[
	"x_ite/Fields",
	"x_ite/Execution/X3DExecutionContext",
	"x_ite/Configuration/ComponentInfoArray",
	"x_ite/Configuration/UnitInfo",
	"x_ite/Configuration/UnitInfoArray",
	"x_ite/Execution/ExportedNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
	"x_ite/Fields/SFNodeCache",
	"standard/Networking/URI",
],
function (Fields,
          X3DExecutionContext,
          ComponentInfoArray,
          UnitInfo,
          UnitInfoArray,
          ExportedNode,
          X3DConstants,
          Generator,
          SFNodeCache,
          URI)
{
"use strict";

	function X3DScene (executionContext)
	{
		X3DExecutionContext .call (this, executionContext);

		this .getRootNodes () .setAccessType (X3DConstants .inputOutput);

		this ._specificationVersion = "3.3";
		this ._encoding             = "SCRIPTED";
		this ._profile              = null;
		this ._components           = new ComponentInfoArray (this .getBrowser ());
		this ._url                  = new URI (window .location);
		this ._units                = new UnitInfoArray ();

		this ._units .add ("angle",  new UnitInfo ("angle",  "radian",   1));
		this ._units .add ("force",  new UnitInfo ("force",  "newton",   1));
		this ._units .add ("length", new UnitInfo ("length", "metre",    1));
		this ._units .add ("mass",   new UnitInfo ("mass",   "kilogram", 1));

		this ._metadata      = new Map ();
		this ._exportedNodes = new Map ();

		this .setLive (false);
	}

	X3DScene .prototype = Object .assign (Object .create (X3DExecutionContext .prototype),
	{
		constructor: X3DScene,
		isMasterContext: function ()
		{
			return this === this .getExecutionContext ();
		},
		isRootContext: function ()
		{
			return true;
		},
		getScene: function ()
		{
			if (this .isMasterContext ())
				return this;

			return this .getExecutionContext () .getScene ();
		},
		setSpecificationVersion: function (specificationVersion)
		{
			this ._specificationVersion = specificationVersion;
		},
		getSpecificationVersion: function ()
		{
			return this ._specificationVersion;
		},
		setEncoding: function (encoding)
		{
			this ._encoding = encoding;
		},
		getEncoding: function ()
		{
			return this ._encoding;
		},
		setURL: function (url)
		{
			this ._url = url;
		},
		getURL: function ()
		{
			return this ._url;
		},
		setProfile: function (profile)
		{
			this ._profile = profile;
		},
		getProfile: function ()
		{
			return this ._profile;
		},
		addComponent: function (component)
		{
			this ._components .add (component .name, component);
		},
		getComponents: function ()
		{
			return this ._components;
		},
		updateUnit: function (category, name, conversionFactor)
		{
			// Private function.

			var unit = this ._units .get (category);

			if (! unit)
				return;

			unit .name             = name;
			unit .conversionFactor = conversionFactor;
		},
		getUnits: function ()
		{
			return this ._units;
		},
		fromUnit: function (category, value)
		{
			switch (category)
			{
				// Base units

			   case "angle":
			   case "force":
			   case "length":
			   case "mass":
					return value * this .getUnits () .get (category) .conversionFactor;

				// Derived units

				case "acceleration:":
					return value * this .getUnits () .get ("length") .conversionFactor;
				case "angularRate":
					return value * this .getUnits () .get ("angle") .conversionFactor;
				case "area":
					return value * Math .pow (this .getUnits () .get ("length") .conversionFactor, 2);
				case "speed":
					return value * this .getUnits () .get ("length") .conversionFactor;
				case "volume":
					return value * Math .pow (this .getUnits () .get ("length") .conversionFactor, 3);
			}

			return value;
		},
		toUnit: function (category, value)
		{
			switch (category)
			{
				// Base units

			   case "angle":
			   case "force":
			   case "length":
			   case "mass":
					return value / this .getUnits () .get (category) .conversionFactor;

				// Derived units

				case "acceleration:":
					return value / this .getUnits () .get ("length") .conversionFactor;
				case "angularRate":
					return value / this .getUnits () .get ("angle") .conversionFactor;
				case "area":
					return value / Math .pow (this .getUnits () .get ("length") .conversionFactor, 2);
				case "speed":
					return value / this .getUnits () .get ("length") .conversionFactor;
				case "volume":
					return value / Math .pow (this .getUnits () .get ("length") .conversionFactor, 3);
			}

			return value;
		},
		setMetaData: function (name, value)
		{
			if (! name .length)
				return;

			this ._metadata .set (name, String (value));
		},
		removeMetaData: function (name)
		{
			this ._metadata .delete (name);
		},
		getMetaData: function (name)
		{
			return this ._metadata .get (name);
		},
		getMetaDatas: function ()
		{
			return this ._metadata;
		},
		addExportedNode: function (exportedName, node)
		{
			if (this ._exportedNodes .has (exportedName))
				throw new Error ("Couldn't add exported node: exported name '" + exportedName + "' already in use.");

			this .updateExportedNode (exportedName, node);
		},
		updateExportedNode: function (exportedName, node)
		{
			exportedName = String (exportedName);

			if (exportedName .length === 0)
				throw new Error ("Couldn't update exported node: node exported name is empty.");

			if (! (node instanceof Fields .SFNode))
				throw new Error ("Couldn't update exported node: node must be of type SFNode.");

			if (! node .getValue ())
				throw new Error ("Couldn't update exported node: node IS NULL.");

			//if (node .getValue () .getExecutionContext () !== this)
			//	throw new Error ("Couldn't update exported node: node does not belong to this execution context.");

			var exportedNode = new ExportedNode (exportedName, node .getValue ());

			this ._exportedNodes .set (exportedName, exportedNode);
		},
		removeExportedNode: function (exportedName)
		{
			this ._exportedNodes .delete (exportedName);
		},
		getExportedNode: function (exportedName)
		{
			var exportedNode = this ._exportedNodes .get (exportedName);

			if (exportedNode)
				return SFNodeCache .get (exportedNode .getLocalNode ());

			throw new Error ("Exported node '" + exportedName + "' not found.");
		},
		getExportedNodes: function ()
		{
			return this ._exportedNodes;
		},
		addRootNode: function (node)
		{
			if (node === null)
				node = new Fields .SFNode ();

			if (! (node instanceof Fields .SFNode))
				throw new Error ("Couldn't add root node: node must be of type SFNode.");

			var rootNodes = this .getRootNodes ();

			for (var i = 0, length = rootNodes .length; i < length; ++ i)
			{
				if (rootNodes [i] .equals (node))
					return;
			}

			rootNodes .push (node);
		},
		removeRootNode: function (node)
		{
			if (node === null)
				node = new Fields .SFNode ();

			if (! (node instanceof Fields .SFNode))
				throw new Error ("Couldn't remove root node: node must be of type SFNode.");

			var
				rootNodes = this .getRootNodes (),
				length    = rootNodes .length;

			rootNodes .erase (rootNodes .remove (0, length, node), length);
		},
		setRootNodes: function (value)
		{
			this .getRootNodes () .setValue (value);
		},
		toStream: function (stream)
		{
			stream .string += Object .prototype .toString .call (this);
		},
		toVRMLStream: function (stream)
		{
			var
				generator            = Generator .Get (stream),
				specificationVersion = this .getSpecificationVersion ();

			if (specificationVersion === "2.0")
				specificationVersion = "3.3";

			stream .string += "#X3D V";
			stream .string += specificationVersion;
			stream .string += " ";
			stream .string += "utf8";
			stream .string += " ";
			stream .string += this .getBrowser () .name;
			stream .string += " ";
			stream .string += "V";
			stream .string += this .getBrowser () .version;
			stream .string += "\n";
			stream .string += "\n";

			var profile = this .getProfile ();

			if (profile)
			{
				profile .toVRMLStream (stream);

				stream .string += "\n";
				stream .string += "\n";
			}

			var components = this .getComponents ();

			if (components .length)
			{
				components .toVRMLStream (stream);

				stream .string += "\n";
			}

			// Units
			{
				var
					empty = true,
					units = this .getUnits ();

				for (var i = 0, length = units .length; i < length; ++ i)
				{
					var unit = units [i];

					if (unit .conversionFactor !== 1)
					{
						empty = false;

						unit .toVRMLStream (stream);

						stream .string += "\n";
					}
				}

				if (! empty)
					stream .string += "\n";
			}

			var metadata = this .getMetaDatas ();

			if (metadata .size)
			{
				metadata .forEach (function (value, key)
				{
					stream .string += "META";
					stream .string += " ";
					stream .string += new Fields .SFString (key) .toString ();
					stream .string += " ";
					stream .string += new Fields .SFString (value) .toString ();
					stream .string += "\n";
				});

				stream .string += "\n";
			}

			var exportedNodes = this .getExportedNodes ();

			generator .PushExecutionContext (this);
			generator .EnterScope ();
			generator .ExportedNodes (exportedNodes);

			X3DExecutionContext .prototype .toVRMLStream .call (this, stream);

			if (exportedNodes .size)
			{
				stream .string += "\n";

				exportedNodes .forEach (function (exportedNode)
				{
					try
					{
						exportedNode .toVRMLStream (stream);

						stream .string += "\n";
					}
					catch (error)
					{
						console .log (error);
					}
				});
			}

			generator .LeaveScope ();
			generator .PopExecutionContext ();
		},
		toXMLStream: function (stream)
		{
			var
				generator            = Generator .Get (stream),
				specificationVersion = this .getSpecificationVersion ();

			if (specificationVersion === "2.0")
				specificationVersion = "3.3";

			stream .string += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
			stream .string += "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D ";
			stream .string += specificationVersion;
			stream .string += "//EN\" \"http://www.web3d.org/specifications/x3d-";
			stream .string += specificationVersion;
			stream .string += ".dtd\">\n";

			stream .string += "<X3D";
			stream .string += " ";
			stream .string += "profile='";
			stream .string += this .getProfile () ? this .getProfile () .name : "Full";
			stream .string += "'";
			stream .string += " ";
			stream .string += "version='";
			stream .string += specificationVersion;
			stream .string += "'";
			stream .string += " ";
			stream .string += "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance'";
			stream .string += " ";
			stream .string += "xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-";
			stream .string += specificationVersion;
			stream .string += ".xsd'>\n";

			generator .IncIndent ();

			stream .string += generator .Indent ();
			stream .string += "<head>\n";

			generator .IncIndent ();

			// <head>

			this .getComponents () .toXMLStream (stream);

			var units = this .getUnits ();

			for (var i = 0, length = units .length; i < length; ++ i)
			{
				var unit = units [i];

				if (unit .conversionFactor !== 1)
				{
					unit .toXMLStream (stream);

					stream .string += "\n";
				}
			}

			this .getMetaDatas () .forEach (function (value, key)
			{
				stream .string += generator .Indent ();
				stream .string += "<meta";
				stream .string += " ";
				stream .string += "name='";
				stream .string += generator .XMLEncode (key);
				stream .string += "'";
				stream .string += " ";
				stream .string += "content='";
				stream .string += generator .XMLEncode (value);
				stream .string += "'";
				stream .string += "/>\n";
			});

			// </head>

			generator .DecIndent ();

			stream .string += generator .Indent ();
			stream .string += "</head>\n";
			stream .string += generator .Indent ();
			stream .string += "<Scene>\n";

			generator .IncIndent ();

			// <Scene>

			var exportedNodes = this .getExportedNodes ();

			generator .PushExecutionContext (this);
			generator .EnterScope ();
			generator .ExportedNodes (exportedNodes);

			X3DExecutionContext .prototype .toXMLStream .call (this, stream);

			exportedNodes .forEach (function (exportedNode)
			{
				try
				{
					exportedNode .toXMLStream (stream);

					stream .string += "\n";
				}
				catch (error)
				{
					console .log (error);
				}
			});

			generator .LeaveScope ();
			generator .PopExecutionContext ();

			// </Scene>

			generator .DecIndent ();

			stream .string += generator .Indent ();
			stream .string += "</Scene>\n";

			generator .DecIndent ();

			stream .string += "</X3D>\n";
		},
	});

	return X3DScene;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/Scene',[
	"x_ite/Fields",
	"x_ite/Execution/X3DScene",
],
function (Fields,
          X3DScene)
{
"use strict";

	function Scene (browser)
	{
		this ._browser = browser;

		X3DScene .call (this, this);

		this .addChildObjects ("initLoadCount", new Fields .SFInt32 (),  // Pre load count, must be zero before the scene can be passed to the requester.
                             "loadCount",     new Fields .SFInt32 ()); // Load count of all X3DUrlObjects.

		this .loadingObjects = new Set ();
	}

	Scene .prototype = Object .assign (Object .create (X3DScene .prototype),
	{
		constructor: Scene,
		getTypeName: function ()
		{
			return "Scene";
		},
		setExecutionContext: function (value)
		{
			if (! this .isMasterContext ())
			{
				var scene = this .getScene ();

				this .loadingObjects .forEach (function (object)
				{
					scene .removeLoadCount (object);
				});
			}

			X3DScene .prototype .setExecutionContext .call (this, value);

			if (! this .isMasterContext ())
			{
				var scene = this .getScene ();

				for (var object in this .loadingObjects)
					scene .addLoadCount (object);
			}
		},
		addInitLoadCount: function (node)
		{
			this .initLoadCount_ = this .initLoadCount_ .getValue () + 1;
		},
		removeInitLoadCount: function (node)
		{
			this .initLoadCount_ = this .initLoadCount_ .getValue () - 1;
		},
		addLoadCount: function (node)
		{
			if (this .loadingObjects .has (node))
				return;

			this .loadingObjects .add (node);

			this .loadCount_ = this .loadingObjects .size;

			if (this === this .getBrowser () .getExecutionContext ())
				this .getBrowser () .addLoadCount (node);

			if (! this .isMasterContext ())
				this .getScene () .addLoadCount (node);
		},
		removeLoadCount: function (node)
		{
			if (! this .loadingObjects .has (node))
				return;

			this .loadingObjects .delete (node);

			this .loadCount_ = this .loadingObjects .size;

			if (this === this .getBrowser () .getExecutionContext ())
				this .getBrowser () .removeLoadCount (node);

			if (! this .isMasterContext ())
				this .getScene () .removeLoadCount (node);
		},
		getLoadingObjects: function ()
		{
			return this .loadingObjects;
		},
	});

	return Scene;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/X3DParser',[],function ()
{
"use strict";

	function X3DParser (scene)
	{
		this .scene             = scene;
		this .executionContexts = [ scene ];
		this .units             = true;
	}

	X3DParser .prototype = {
		constructor: X3DParser,
		getScene: function ()
		{
			return this .scene;
		},
		getBrowser: function ()
		{
			return this .scene .getBrowser ();
		},
		getExecutionContext: function ()
		{
			return this .executionContexts [this .executionContexts .length - 1];
		},
		pushExecutionContext: function (executionContext)
		{
			return this .executionContexts .push (executionContext);
		},
		popExecutionContext: function ()
		{
			this .executionContexts .pop ();
		},
		isInsideProtoDefinition: function ()
		{
			return this .executionContexts .length > 1;
		},
		addRootNode: function (node)
		{
			this .getExecutionContext () .rootNodes .push (node);
		},
		getProviderUrls: (function ()
		{
			var componentsUrl = /\.js$/;

			return function ()
			{
				var
					scene             = this .getScene (),
					profile           = scene .getProfile () ? scene .getProfile () : scene .getBrowser () .getProfile ("Full"),
					profileComponents = profile .components,
					components        = scene .getComponents (),
					providerUrls      = new Set ();

				for (var i = 0, length = profileComponents .length; i < length; ++ i)
				{
					var providerUrl = profileComponents [i] .providerUrl;
	
					if (providerUrl .match (componentsUrl))
						providerUrls .add (providerUrl);
				}

				for (var i = 0, length = components .length; i < length; ++ i)
				{
					var providerUrl = components [i] .providerUrl;
	
					if (providerUrl .match (componentsUrl))
						providerUrls .add (providerUrl);
				}

				return Array .from (providerUrls);
			};
		})(),
		setUnits: function (generator)
		{
			if ((typeof arguments [0]) == "boolean")
			{
				this .units = arguments [0];
				return;
			}

			var
				version = /Titania\s+V(\d+).*/,
				match   = generator .match (version);

			if (match)
			{
				var major = parseInt (match [1]);

				// Before version 4 units are wrongly implemented.
				if (major < 4)
				{
					this .units = false;
					return;
				}
			}
		
			this .units = true;
		},
		getUnits: function ()
		{
			return this .units;
		},
		fromUnit: function (category, value)
		{
			if (this .units)
				return this .getExecutionContext () .fromUnit (category, value);

			return value;
		},
	};

	return X3DParser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/X3DUrlObject',[
	"x_ite/Fields",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DConstants)
{
"use strict";

	function X3DUrlObject (executionContext)
	{
		this .addType (X3DConstants .X3DUrlObject);
		
		this .addChildObjects ("loadState", new Fields .SFInt32 (X3DConstants .NOT_STARTED_STATE));
	}

	X3DUrlObject .prototype =
	{
		constructor: X3DUrlObject,
		initialize: function ()
		{ },
		setLoadState: function (value, notify)
		{
			this .loadState_ = value;

			this .getScene () .removeLoadCount (this);

			if (notify !== false && value === X3DConstants .IN_PROGRESS_STATE)
				this .getScene () .addLoadCount (this);
		},
		checkLoadState: function ()
		{
			return this .loadState_ .getValue ();
		},
		getLoadState: function ()
		{
			return this .loadState_;
		},
	};

	return X3DUrlObject;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DNode',[
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DBaseNode,
          X3DConstants)
{
"use strict";

	function X3DNode (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .addType (X3DConstants .X3DNode);
	}

	X3DNode .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: X3DNode,
		getLayers: function ()
		{
			return this .findParents (X3DConstants .X3DLayerNode, this);
		},
		findParents: function (type, object)
		{
			var
				array = [ ],
				seen  = new Set ();

			object .getParents () .forEach (function (parent)
			{
				this .findParentsImpl (type, parent, array, seen);
			},
			this);
	
			return array;
		},
		findParentsImpl: function (type, object, array, seen)
		{
			if (seen .has (object .getId ()))
				return;

			seen .add (object .getId ());

			if (object instanceof X3DBaseNode)
			{
				var types = object .getType ();

				for (var t = types .length - 1; t >= 0; -- t)
				{
					switch (types [t])
					{
						case X3DConstants .X3DProtoDeclarationNode:
						case X3DConstants .X3DNode:
							break;
						case X3DConstants .LayerSet:
						case X3DConstants .X3DBaseNode:
						case X3DConstants .X3DMetadataObject:
						case X3DConstants .X3DProgrammableShaderObject:
						case X3DConstants .X3DScriptNode:
							return;
						default:
							continue;
					}
		
					break;
				}

				if (object .getType () .indexOf (type) !== -1)
				{
					array .push (object);
					return;
				}
			}

			object .getParents () .forEach (function (parent)
			{
				this .findParentsImpl (type, parent, array, seen);
			},
			this);
		},
	});

	return X3DNode;
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DPrototypeInstance',[
	"x_ite/Fields",
	"x_ite/Base/X3DChildObject",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Execution/X3DExecutionContext",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function (Fields,
          X3DChildObject,
          X3DNode,
          X3DExecutionContext,
          X3DConstants,
          Generator)
{
"use strict";

	function X3DPrototypeInstance (executionContext, protoNode)
	{
		this .protoNode        = protoNode;
		this .fieldDefinitions = protoNode .getFieldDefinitions ();

		X3DNode             .call (this, executionContext);
		X3DExecutionContext .call (this, executionContext);

		this .addType (X3DConstants .X3DPrototypeInstance);
		this .getRootNodes () .setAccessType (X3DConstants .initializeOnly);

		var X3DProtoDeclaration = require ("x_ite/Prototype/X3DProtoDeclaration");

		if (this .getExecutionContext () .constructor !== X3DProtoDeclaration)
		{
			this .getScene () .addInitLoadCount (this);
	
			if (protoNode .isExternProto)
				protoNode .requestAsyncLoad (this .construct .bind (this));
	
			else
				this .construct ();
		}
	}

	X3DPrototypeInstance .prototype = Object .assign (Object .create (X3DExecutionContext .prototype),
		X3DNode .prototype,
	{
		constructor: X3DPrototypeInstance,
		create: function (executionContext)
		{
			return new X3DPrototypeInstance (executionContext, this .protoNode);
		},
		getTypeName: function ()
		{
			return this .protoNode .getName ();
		},
		getComponentName: function ()
		{
			return "Core";
		},
		getContainerField: function ()
		{
			return "children";
		},
		construct: function ()
		{
			this .getScene () .removeInitLoadCount (this);

			var proto = this .protoNode .getProtoDeclaration ();

			if (proto)
			{
				// If there is a proto the externproto is completely loaded.
			
				if (! this .metadata_ .getSet ())
					this .metadata_ = proto .metadata_;

				if (this .protoNode .isExternProto)
				{
					var fieldDefinitions = proto .getFieldDefinitions ();

					for (var i = 0, length = fieldDefinitions .length; i < length; ++ i)
					{
						try
						{
							var
								fieldDefinition = fieldDefinitions [i],
                        field           = this .getField (fieldDefinition .name),
								protoField      = proto .getField (fieldDefinition .name);

							// Continue if something is wrong.
							if (field .getAccessType () !== protoField .getAccessType ())
								continue;

							// Continue if something is wrong.
							if (field .getType () !== protoField .getType ())
								continue;

							// Continue if field is eventIn or eventOut.
							if (! (field .getAccessType () & X3DConstants .initializeOnly))
								continue;

							// Is set during parse.	
							if (field .getSet ())
								continue;

							// Has IS references.
							if (field .hasReferences ())
								continue;

							if (field .equals (protoField))
								continue;

							// If default value of protoField is different from field update default value for field.
							field .setValue (protoField);
						}
						catch (error)
						{
							// Definition exists in proto but does not exist in extern proto.
							this .addField (fieldDefinition);
						}
					}
				}

				// Assign metadata.

				this .importExternProtos (proto .externprotos);
				this .importProtos       (proto .protos);
				this .copyRootNodes      (proto .rootNodes);

				if (this .isInitialized ())
				{
					this .setInitialized (false);
					this .setup ();
					this .setTainted (false);
					X3DChildObject .prototype .addEvent .call (this);
				}
			}
		},
		setup: function ()
		{
			X3DNode             .prototype .setup .call (this);
			X3DExecutionContext .prototype .setup .call (this);
		},
		initialize: function ()
		{
			try
			{
				var proto = this .protoNode .getProtoDeclaration ();

				if (proto)
				{
					this .copyImportedNodes (proto, proto .getImportedNodes ());
					this .copyRoutes (proto, proto .routes);
				}

				// TODO: connect getRootNodes () to X3DChildObject .prototype .addEvent .call (this);

				// Now initialize bases.
	
				X3DNode             .prototype .initialize .call (this);
				X3DExecutionContext .prototype .initialize .call (this);
			}
			catch (error)
			{
				console .error (error .message);
			}
		},
		getExtendedEventHandling: function ()
		{
			return false;
		},
		getSpecificationVersion: function ()
		{
			return this .protoNode .getProtoDeclaration () .getSpecificationVersion ();
		},
		getEncoding: function ()
		{
			return this .protoNode .getProtoDeclaration () .getEncoding ();
		},
		getURL: function ()
		{
			return this .protoNode .getProtoDeclaration () .getURL ();
		},
		getProfile: function ()
		{
			return this .protoNode .getProtoDeclaration () .getProfile ();
		},
		getComponents: function ()
		{
			return this .protoNode .getProtoDeclaration () .getComponents ();
		},
		fromUnit: function (category, value)
		{
			return this .protoNode .getProtoDeclaration () .fromUnit (category, value);
		},
		toUnit: function (category, value)
		{
			return this .protoNode .getProtoDeclaration () .toUnit (category, value);
		},
		getUnits: function ()
		{
			return this .protoNode .getProtoDeclaration () .getUnits ();
		},
		getInnerNode: function ()
		{
			var rootNodes = this .getRootNodes () .getValue ();
			
			if (rootNodes .length)
			{
				var rootNode = rootNodes [0];
				
				if (rootNode)
					return rootNode .getValue () .getInnerNode ();
			}

			throw new Error ("Root node not available.");
		},
		importExternProtos: function (externprotos)
		{
			for (var i = 0, length = externprotos .length; i < length; ++ i)
				this .externprotos .add (externprotos [i] .getName (), externprotos [i]);
		},
		importProtos: function (protos)
		{
			for (var i = 0, length = protos .length; i < length; ++ i)
				this .protos .add (protos [i] .getName (), protos [i]);
		},
		copyRootNodes: function (rootNodes1)
		{
			var rootNodes2 = this .getRootNodes ();

			for (var i = 0, length = rootNodes1 .length; i < length; ++ i)
			{
				rootNodes2 .push (rootNodes1 [i] .copy (this));
			}
		},
		copyImportedNodes: function (executionContext, importedNodes)
		{
			importedNodes .forEach (function (importedNode, importedName)
			{
				try
				{
					var
						inlineNode   = this .getNamedNode (importedNode .getInlineNode () .getName ()),
						exportedName = importedNode .getExportedName ();

					this .addImportedNode (inlineNode, exportedName, importedName);
				}
				catch (error)
				{
					console .error ("Bad IMPORT specification in copy: ", error);
				}
			},
			this);
		},
		copyRoutes: function (executionContext, routes)
		{
			for (var i = 0, length = routes .length; i < length; ++ i)
			{
				try
				{
					var
						route           = routes [i],
						sourceNode      = this .getLocalNode (executionContext .getLocalName (route .sourceNode)),
						destinationNode = this .getLocalNode (executionContext .getLocalName (route .destinationNode));

					// new Route ... addUninitializedNode ...
					this .addRoute (sourceNode, route .sourceField, destinationNode, route .destinationField);
				}
				catch (error)
				{
					console .log (error);
				}
			}
		},
		toVRMLStream: function (stream)
		{
			X3DNode .prototype .toVRMLStream .call (this, stream);
		},
		toXMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			if (generator .IsSharedNode (this))
			{
				stream .string += generator .Indent ();
				stream .string += "<!-- NULL -->";		
				return;
			}

			generator .EnterScope ();

			var name = generator .Name (this);

			if (name .length)
			{
				if (generator .ExistsNode (this))
				{
					stream .string += generator .Indent ();
					stream .string += "<ProtoInstance";
					stream .string += " ";
					stream .string += "name='";
					stream .string += generator .XMLEncode (this .getTypeName ());
					stream .string += "'";
					stream .string += " ";
					stream .string += "USE='";
					stream .string += generator .XMLEncode (name);
					stream .string += "'";

					var containerField = generator .ContainerField ();

					if (containerField)
					{
						if (containerField .getName () !== this .getContainerField ())
						{
							stream .string += " ";
							stream .string += "containerField='";
							stream .string += generator .XMLEncode (containerField .getName ());
							stream .string += "'";
						}
					}

					stream .string += "/>";

					generator .LeaveScope ();
					return;
				}
			}

			stream .string += generator .Indent ();
			stream .string += "<ProtoInstance";
			stream .string += " ";
			stream .string += "name='";
			stream .string += generator .XMLEncode (this .getTypeName ());
			stream .string += "'";

			if (name .length)
			{
				generator .AddNode (this);

				stream .string += " ";
				stream .string += "DEF='";
				stream .string += generator .XMLEncode (name);
				stream .string += "'";
			}

			var containerField = generator .ContainerField ();

			if (containerField)
			{
				if (containerField .getName () !== this .getContainerField ())
				{
					stream .string += " ";
					stream .string += "containerField='";
					stream .string += generator .XMLEncode (containerField .getName ());
					stream .string += "'";
				}
			}
		
			var fields = this .getChangedFields ();

			if (fields .length === 0)
			{
				stream .string += "/>";
			}
			else
			{
				stream .string += ">\n";

				generator .IncIndent ();

				var references = [ ];

				for (var i = 0, length = fields .length; i < length; ++ i)
				{
					var field = fields [i];

					// If the field is a inputOutput and we have as reference only inputOnly or outputOnly we must output the value
					// for this field.

					var mustOutputValue = false;

					if (generator .ExecutionContext ())
					{
						if (field .getAccessType () === X3DConstants .inputOutput && field .getReferences () .size !== 0)
						{
							var
								initializableReference = false,
								fieldReferences        = field .getReferences ();

							fieldReferences .forEach (function (fieldReference)
							{
								initializableReference |= fieldReference .isInitializable ();
							});

							if (! initializableReference)
								mustOutputValue = true;
						}
					}

					// If we have no execution context we are not in a proto and must not generate IS references the same is true
					// if the node is a shared node as the node does not belong to the execution context.

					if (field .getReferences () .size === 0 || ! generator .ExecutionContext () || mustOutputValue)
					{
						if (mustOutputValue)
							references .push (field);

						switch (field .getType ())
						{
							case X3DConstants .MFNode:
							{
								stream .string += generator .Indent ();
								stream .string += "<fieldValue";
								stream .string += " ";
								stream .string += "name='";
								stream .string += generator .XMLEncode (field .getName ());
								stream .string += "'";

								if (field .length === 0)
								{
									stream .string += "/>\n";
								}
								else
								{
									generator .PushContainerField (field);

									stream .string += ">\n";

									generator .IncIndent ();

									field .toXMLStream (stream);

									stream .string += "\n";

									generator .DecIndent ();

									stream .string += generator .Indent ();
									stream .string += "</fieldValue>\n";

									generator .PopContainerField ();
								}

								break;
							}
							case X3DConstants .SFNode:
							{
								if (field .getValue () !== null)
								{
									generator .PushContainerField (field);

									stream .string += generator .Indent ();
									stream .string += "<fieldValue";
									stream .string += " ";
									stream .string += "name='";
									stream .string += generator .XMLEncode (field .getName ());
									stream .string += "'";
									stream .string += ">\n";
									
									generator .IncIndent ();

									field .toXMLStream (stream);

									stream .string += "\n";

									generator .DecIndent ();

									stream .string += generator .Indent ();
									stream .string += "</fieldValue>\n";	
	
									generator .PopContainerField ();
									break;
								}
		
								// Proceed with next case.
							}
							default:
							{
								stream .string += generator .Indent ();
								stream .string += "<fieldValue";
								stream .string += " ";
								stream .string += "name='";
								stream .string += generator .XMLEncode (field .getName ());
								stream .string += "'";
								stream .string += " ";
								stream .string += "value='";

								field .toXMLStream (stream);

								stream .string += "'";
								stream .string += "/>\n";
								break;
							}
						}
					}
					else
					{
						references .push (field);
					}
				}

				if (references .length)
				{
					stream .string += generator .Indent ();
					stream .string += "<IS>";
					stream .string += "\n";

					generator .IncIndent ();
		
					for (var i = 0, length = references .length; i < length; ++ i)
					{
						var
							field       = references [i],
							protoFields = field .getReferences ();

						protoFields .forEach (function (protoField)
						{
							stream .string += generator .Indent ();
							stream .string += "<connect";
							stream .string += " ";
							stream .string += "nodeField='";
							stream .string += generator .XMLEncode (field .getName ());
							stream .string += "'";
							stream .string += " ";
							stream .string += "protoField='";
							stream .string += generator .XMLEncode (protoField .getName ());
							stream .string += "'";
							stream .string += "/>\n";
						});
					}

					generator .DecIndent ();

					stream .string += generator .Indent ();
					stream .string += "</IS>\n";
				}

				generator .DecIndent ();

				stream .string += generator .Indent ();
				stream .string += "</ProtoInstance>";
			}

			generator .LeaveScope ();
		},
	});

	return X3DPrototypeInstance;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/X3DProtoDeclarationNode',[
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Core/X3DPrototypeInstance",
	"x_ite/Bits/X3DConstants",
	"x_ite/Fields/SFNodeCache",
],
function (X3DNode,
          X3DPrototypeInstance,
          X3DConstants,
          SFNodeCache)
{
"use strict";

	function X3DProtoDeclarationNode (executionContext)
	{
		X3DNode .call (this, executionContext);
	}

	X3DProtoDeclarationNode .prototype = Object .assign (Object .create (X3DNode .prototype),
	{
		constructor: X3DProtoDeclarationNode,
		hasUserDefinedFields: function ()
		{
			return true;
		},
		createInstance: function (executionContext, setup)
		{
			if (setup === false)
			{
				return new X3DPrototypeInstance (executionContext, this);
			}
			else
			{
				var instance = new X3DPrototypeInstance (executionContext, this);
	
				instance .setup ();
	
				return SFNodeCache .add (instance);
			}
		},
		newInstance: function ()
		{
			return this .createInstance (this .getExecutionContext ());
		},
	});

	return X3DProtoDeclarationNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/X3DExternProtoDeclaration',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Networking/X3DUrlObject",
	"x_ite/Prototype/X3DProtoDeclarationNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DUrlObject,
          X3DProtoDeclarationNode, 
          X3DConstants,
          Generator)
{
"use strict";

	// Dummy callback function
	function loadNowCallback () { }

	function X3DExternProtoDeclaration (executionContext)
	{
		X3DProtoDeclarationNode .call (this, executionContext);
		X3DUrlObject            .call (this, executionContext);

		this .addChildObjects ("url", new Fields .MFString ());

		this .deferred = $.Deferred ();
	}

	X3DExternProtoDeclaration .prototype = Object .assign (Object .create (X3DProtoDeclarationNode .prototype),
		X3DUrlObject .prototype,
	{
		constructor: X3DExternProtoDeclaration,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "EXTERNPROTO";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "externprotos";
		},
		initialize: function ()
		{
			X3DProtoDeclarationNode .prototype .initialize .call (this);
			X3DUrlObject            .prototype .initialize .call (this);
				
			this .isLive () .addInterest ("set_live__", this);
		},
		set_live__: function ()
		{
			if (this .checkLoadState () === X3DConstants .COMPLETE_STATE)
			{
				this .scene .setLive (this .isLive () .getValue ());
			}
		},
		hasUserDefinedFields: function ()
		{
			return true;
		},
		setProtoDeclaration: function (proto)
		{
			this .proto = proto;

			if (this .proto)
			{
				var
					fieldDefinitions      = this .getFieldDefinitions (),
					protoFieldDefinitions = proto .getFieldDefinitions ();
	
				for (var i = 0, length = protoFieldDefinitions .length; i < length; ++ i)
				{
					var
						protoFieldDefinition = protoFieldDefinitions [i],
						fieldDefinition      = fieldDefinitions .get (protoFieldDefinition .name);
	
					if (fieldDefinition)
						fieldDefinition .value .setValue (protoFieldDefinition .value);
				}
			}
		},
		getProtoDeclaration: function ()
		{
			return this .proto;
		},
		loadNow: function (callback)
		{
			// 7.73 — ExternProtoDeclaration function, added callback argument.
			this .requestAsyncLoad (callback || loadNowCallback);
		},
		requestAsyncLoad: function (callback)
		{
			this .deferred .done (callback);

			if (this .checkLoadState () === X3DConstants .COMPLETE_STATE || this .checkLoadState () === X3DConstants .IN_PROGRESS_STATE)
				return;

			this .setLoadState (X3DConstants .IN_PROGRESS_STATE);

			// Don't create scene cache, due to possible default nodes in proto SFNode fields and complete scenes.

			var FileLoader = require ("x_ite/InputOutput/FileLoader");

			new FileLoader (this) .createX3DFromURL (this .url_, null, this .setInternalSceneAsync .bind (this));
		},
		setInternalSceneAsync: function (value)
		{
			if (value)
				this .setInternalScene (value);

			else
				this .setError ();
		},
		setInternalScene: function (value)
		{
			this .scene = value;

			var
				protoName = this .scene .getURL () .fragment || 0,
				proto     = this .scene .protos [protoName];

			if (! proto)
				throw new Error ("PROTO not found");

			this .scene .setLive (this .isLive () .getValue ());
			this .scene .setPrivate (this .getScene () .getPrivate ());
			this .scene .setExecutionContext (this .getExecutionContext ());
			this .scene .setup ();

			this .setLoadState (X3DConstants .COMPLETE_STATE);

			this .setProtoDeclaration (proto);

			this .deferred .resolve ();
		},
		getInternalScene: function ()
		{
			///  Returns the internal X3DScene of this extern proto, that is loaded from the url given.

			return this .scene;
		},
		setError: function (error)
		{
			console .error ("Error loading extern prototype:", error);

			this .setLoadState (X3DConstants .FAILED_STATE);

			this .scene = this .getBrowser () .getPrivateScene ();

			this .setProtoDeclaration (null);

			this .deferred .resolve ();
			this .deferred = $.Deferred ();
		},
		toStream: function (stream)
		{
			stream .string += Object .prototype .toString .call (this);
		},
		toVRMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			stream .string += generator .Indent ();
			stream .string += "EXTERNPROTO";
			stream .string += " ";
			stream .string += this .getName ();
			stream .string += " ";
			stream .string += "[";

			var
				fieldTypeLength   = 0,
				accessTypeLength  = 0,
				userDefinedFields = this .getUserDefinedFields ();

			if (userDefinedFields .size === 0)
			{
				stream .string += " ";
			}
			else
			{
				userDefinedFields .forEach (function (field)
				{
					fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
					accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
				});

				stream .string += "\n";

				generator .IncIndent ();

				userDefinedFields .forEach (function (field)
				{
					this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);
					stream .string += "\n";
				},
				this);

				generator .DecIndent ();

				stream .string += generator .Indent ();
			}

			stream .string += "]";
			stream .string += "\n";

			stream .string += generator .Indent ();

			this .url_ .toVRMLStream (stream);
		},
		toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
		{
			var generator = Generator .Get (stream);

			stream .string += generator .Indent ();
			stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
			stream .string += " ";
			stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
			stream .string += " ";
			stream .string += field .getName ();
		},
		toXMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			stream .string += generator .Indent ();
			stream .string += "<ExternProtoDeclare";
			stream .string += " ";
			stream .string += "name='";
			stream .string += generator .XMLEncode (this .getName ());
			stream .string += "'";
			stream .string += " ";
			stream .string += "url='";

			this .url_ .toXMLStream (stream);

			stream .string += "'";
			stream .string += ">\n";

			generator .IncIndent ();

			var userDefinedFields = this .getUserDefinedFields ();

			userDefinedFields .forEach (function (field)
			{
				stream .string += generator .Indent ();
				stream .string += "<field";
				stream .string += " ";
				stream .string += "accessType='";
				stream .string += generator .AccessType (field .getAccessType ());
				stream .string += "'";
				stream .string += " ";
				stream .string += "type='";
				stream .string += field .getTypeName ();
				stream .string += "'";
				stream .string += " ";
				stream .string += "name='";
				stream .string += generator .XMLEncode (field .getName ());
				stream .string += "'";
				stream .string += "/>\n";
			});

			generator .DecIndent ();

			stream .string += generator .Indent ();
			stream .string += "</ExternProtoDeclare>";
		},
	});

	Object .defineProperty (X3DExternProtoDeclaration .prototype, "name",
	{
		get: function () { return this .getName (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExternProtoDeclaration .prototype, "fields",
	{
		get: function () { return this .getFieldDefinitions (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExternProtoDeclaration .prototype, "isExternProto",
	{
		get: function () { return true; },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExternProtoDeclaration .prototype, "urls",
	{
		get: function () { return this .url_ .copy (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DExternProtoDeclaration .prototype, "loadState",
	{
		get: function () { return this .checkLoadState (); },
		enumerable: true,
		configurable: false
	});

	return X3DExternProtoDeclaration;
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Prototype/X3DProtoDeclaration',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Execution/X3DExecutionContext",
	"x_ite/Prototype/X3DProtoDeclarationNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/Generator",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DExecutionContext,
          X3DProtoDeclarationNode, 
          X3DConstants,
          Generator)
{
"use strict";

	function X3DProtoDeclaration (executionContext)
	{
		X3DProtoDeclarationNode .call (this, executionContext);
		X3DExecutionContext     .call (this, executionContext);

		this .addChildObjects ("loadState", new Fields .SFInt32 (X3DConstants .NOT_STARTED_STATE));

		this .setLive (false);
	}

	X3DProtoDeclaration .prototype = Object .assign (Object .create (X3DExecutionContext .prototype),
		X3DProtoDeclarationNode .prototype,
	{
		constructor: X3DProtoDeclaration,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "PROTO";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "protos";
		},
		initialize: function ()
		{
			X3DProtoDeclarationNode .prototype .initialize .call (this);

			this .loadState_ = X3DConstants .COMPLETE_STATE;
		},
		getProtoDeclaration: function ()
		{
			if (arguments .length)
				return X3DExecutionContext .prototype .getProtoDeclaration .apply (this, arguments);

			return this;
		},
		checkLoadState: function ()
		{
			return this .loadState_ .getValue ();
		},
		hasUserDefinedFields: function ()
		{
			return true;
		},
		toStream: function (stream)
		{
			stream .string += Object .prototype .toString .call (this);
		},
		toVRMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			stream .string += generator .Indent ();
			stream .string += "PROTO";
			stream .string += " ";
			stream .string += this .getName ();
			stream .string += " ";
			stream .string += "[";

			generator .EnterScope ();

			var
				fieldTypeLength   = 0,
				accessTypeLength  = 0,
				userDefinedFields = this .getUserDefinedFields ();

			if (userDefinedFields .size === 0)
			{
				stream .string += " ";
			}
			else
			{
				userDefinedFields .forEach (function (field)
				{
					fieldTypeLength  = Math .max (fieldTypeLength, field .getTypeName () .length);
					accessTypeLength = Math .max (accessTypeLength, generator .AccessType (field .getAccessType ()) .length);
				});

				stream .string += "\n";

				generator .IncIndent ();

				userDefinedFields .forEach (function (field)
				{
					this .toVRMLStreamUserDefinedField (stream, field, fieldTypeLength, accessTypeLength);
					stream .string += "\n";
				},
				this);

				generator .DecIndent ();

				stream .string += generator .Indent ();
			}

			generator .LeaveScope ();

			stream .string += "]";
			stream .string += "\n";

			stream .string += generator .Indent ();
			stream .string += "{";
			stream .string += "\n";

			generator .IncIndent ();

			X3DExecutionContext .prototype .toVRMLStream .call (this, stream);

			generator .DecIndent ();

			stream .string += generator .Indent ();
			stream .string += "}";
		},
		toVRMLStreamUserDefinedField: function (stream, field, fieldTypeLength, accessTypeLength)
		{
			var generator = Generator .Get (stream);

			stream .string += generator .Indent ();
			stream .string += generator .PadRight (generator .AccessType (field .getAccessType ()), accessTypeLength);
			stream .string += " ";
			stream .string += generator .PadRight (field .getTypeName (), fieldTypeLength);
			stream .string += " ";
			stream .string += field .getName ();

			if (field .isInitializable ())
			{
				stream .string += " ";

				field .toVRMLStream (stream);
			}
		},
		toXMLStream: function (stream)
		{
			var generator = Generator .Get (stream);

			stream .string += generator .Indent ();
			stream .string += "<ProtoDeclare";
			stream .string += " ";
			stream .string += "name='";
			stream .string += generator .XMLEncode (this .getName ());
			stream .string += "'";
			stream .string += ">";
			stream .string += "\n";
		
			// <ProtoInterface>

			generator .EnterScope ();
		
			var userDefinedFields = this .getUserDefinedFields ();

			if (userDefinedFields .size !== 0)
			{
				generator .IncIndent ();

				stream .string += generator .Indent ();
				stream .string += "<ProtoInterface>\n";

				generator .IncIndent ();

				userDefinedFields .forEach (function (field)
				{
					stream .string += generator .Indent ();
					stream .string += "<field";
					stream .string += " ";
					stream .string += "accessType='";
					stream .string += generator .AccessType (field .getAccessType ());
					stream .string += "'";
					stream .string += " ";
					stream .string += "type='";
					stream .string += field .getTypeName ();
					stream .string += "'";
					stream .string += " ";
					stream .string += "name='";
					stream .string += generator .XMLEncode (field .getName ());
					stream .string += "'";

					if (field .isDefaultValue ())
					{
						stream .string += "/>\n";
					}
					else
					{
						switch (field .getType ())
						{
							case X3DConstants .SFNode:
							case X3DConstants .MFNode:
							{
								generator .PushContainerField (field);
		
								stream .string += ">\n";

								generator .IncIndent ();

								field .toXMLStream (stream);

								stream .string += "\n";

								generator .DecIndent ();

								stream .string += generator .Indent ();
								stream .string += "</field>\n";

								generator .PopContainerField ();
								break;
							}
							default:
							{
								stream .string += " ";
								stream .string += "value='";

								field .toXMLStream (stream);

								stream .string += "'";
								stream .string += "/>\n";
								break;
							}
						}
					}
				});
		
				generator .DecIndent ();

				stream .string += generator .Indent ();
				stream .string += "</ProtoInterface>\n";

				generator .DecIndent ();
			}
		
			generator .LeaveScope ();
		
			// </ProtoInterface>

			// <ProtoBody>
		
			generator .IncIndent ();

			stream .string += generator .Indent ();
			stream .string += "<ProtoBody>\n";

			generator .IncIndent ();

			X3DExecutionContext .prototype .toXMLStream .call (this, stream);

			generator .DecIndent ();

			stream .string += generator .Indent ();
			stream .string += "</ProtoBody>\n";

			generator .DecIndent ();
		
			// </ProtoBody>

			stream .string += generator .Indent ();
			stream .string += "</ProtoDeclare>";
		},
	});

	Object .defineProperty (X3DProtoDeclaration .prototype, "name",
	{
		get: function () { return this .getName (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DProtoDeclaration .prototype, "fields",
	{
		get: function () { return this .getFieldDefinitions (); },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DProtoDeclaration .prototype, "isExternProto",
	{
		get: function () { return false; },
		enumerable: true,
		configurable: false
	});

	return X3DProtoDeclaration;
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/Parser',[
	"x_ite/Fields",
	"x_ite/Parser/X3DParser",
	"x_ite/Prototype/X3DExternProtoDeclaration",
	"x_ite/Prototype/X3DProtoDeclaration",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DParser,
          X3DExternProtoDeclaration,
          X3DProtoDeclaration,
          X3DConstants)
{
"use strict";

	function accessTypeToString (accessType)
	{
		switch (accessType)
		{
			case X3DConstants .inializeOnly:
				return "initializeOnly";
			case X3DConstants .inputOnly:
				return "inputOnly";
			case X3DConstants .outputOnly:
				return "outputOnly";
			case X3DConstants .inputOutput:
				return "inputOutput";
		}
	}

	/*
	 *  Grammar
	 */


//	Comment out scriptBody function fragments
//
//	// VRML lexical elements
//	var Grammar =
//	{
//		// General
//		Whitespaces: /^([\x20\n,\t\r]+)/,
//		Comment:     /^#(.*?)(?=[\n\r])/,
//
//		// Header
//		Header:	    /^#(VRML|X3D) V(.*?) (utf8)(?: (.*?))?[\n\r]/,
//
//		// Keywords
//		AS:          /^AS/,
//		COMPONENT:   /^COMPONENT/,
//		DEF:         /^DEF/,
//		EXPORT:      /^EXPORT/,
//		EXTERNPROTO: /^EXTERNPROTO/,
//		FALSE:       /^FALSE/,
//		false:       /^false/,
//		IMPORT:      /^IMPORT/,
//		IS:          /^IS/,
//		META:        /^META/,
//		NULL:        /^NULL/,
//		TRUE:        /^TRUE/,
//		true:        /^true/,
//		PROFILE:     /^PROFILE/,
//		PROTO:       /^PROTO/,
//		ROUTE:       /^ROUTE/,
//		TO:          /^TO/,
//		UNIT:        /^UNIT/,
//		USE:         /^USE/,
//
//		// Terminal symbols
//		OpenBrace:    /^\{/,
//		CloseBrace:   /^\}/,
//		OpenBracket:  /^\[/,
//		CloseBracket: /^\]/,
//		Period:       /^\./,
//		Colon:        /^\:/,
//
//		Id: /^([^\x30-\x39\x00-\x20\x22\x23\x27\x2b\x2c\x2d\x2e\x5b\x5c\x5d\x7b\x7d\x7f]{1}[^\x00-\x20\x22\x23\x27\x2c\x2e\x5b\x5c\x5d\x7b\x7d\x7f]*)/,
//		ComponentNameId: /^([^\x30-\x39\x00-\x20\x22\x23\x27\x2b\x2c\x2d\x2e\x5b\x5c\x5d\x7b\x7d\x7f\x3a]{1}[^\x00-\x20\x22\x23\x27\x2c\x2e\x5b\x5c\x5d\x7b\x7d\x7f\x3a]*)/,
//
//		initializeOnly: /^initializeOnly/,
//		inputOnly:      /^inputOnly/,
//		outputOnly:     /^outputOnly/,
//		inputOutput:    /^inputOutput/,
//
//		field:        /^field/,
//		eventIn:      /^eventIn/,
//		eventOut:     /^eventOut/,
//		exposedField: /^exposedField/,
//
//		FieldType: /^(MFBool|MFColorRGBA|MFColor|MFDouble|MFFloat|MFImage|MFInt32|MFMatrix3d|MFMatrix3f|MFMatrix4d|MFMatrix4f|MFNode|MFRotation|MFString|MFTime|MFVec2d|MFVec2f|MFVec3d|MFVec3f|MFVec4d|MFVec4f|SFBool|SFColorRGBA|SFColor|SFDouble|SFFloat|SFImage|SFInt32|SFMatrix3d|SFMatrix3f|SFMatrix4d|SFMatrix4f|SFNode|SFRotation|SFString|SFTime|SFVec2d|SFVec2f|SFVec3d|SFVec3f|SFVec4d|SFVec4f)/,
//
//		// Values
//		int32:  /^((?:0[xX][\da-fA-F]+)|(?:[+-]?\d+))/,
//		double: /^([+-]?(?:(?:(?:\d*\.\d+)|(?:\d+(?:\.)?))(?:[eE][+-]?\d+)?))/,
//		string: /^"((?:[^"\\]|\\\\|\\")*)"/,
//
//		Inf:         /^[+]?inf/i,
//		NegativeInf: /^-inf/i,
//		NaN:         /^[+-]?nan/i,
//
//		// Misc
//		Break: /\r?\n/g,
//	};
//
//	function parse (parser)
//	{
//		this .lastIndex = 0;
//		parser .result  = this .exec (parser .input);
//
//		if (parser .result)
//		{
//			parser .input = parser .input .slice (parser .result [0] .length);
//			return true;
//		}
//
//		return false;
//	}


	// Comment out scriptBody function fragments
	//
	// VRML lexical elements
	var Grammar =
	{
		// General
		Whitespaces: new RegExp ('([\\x20\\n,\\t\\r]+)', 'gy'),
		Comment:     new RegExp ('#(.*?)(?=[\\n\\r])',   'gy'),

		// Header
		Header:	    new RegExp ("^#(VRML|X3D) V(.*?) (utf8)(?:[ \\t]+(.*?))?[ \\t]*[\\n\\r]", 'gy'),

		// Keywords
		AS:          new RegExp ('AS',          'gy'),
		COMPONENT:   new RegExp ('COMPONENT',   'gy'),
		DEF:         new RegExp ('DEF',         'gy'),
		EXPORT:      new RegExp ('EXPORT',      'gy'),
		EXTERNPROTO: new RegExp ('EXTERNPROTO', 'gy'),
		FALSE:       new RegExp ('FALSE|false', 'gy'),
		IMPORT:      new RegExp ('IMPORT',      'gy'),
		IS:          new RegExp ('IS',          'gy'),
		META:        new RegExp ('META',        'gy'),
		NULL:        new RegExp ('NULL',        'gy'),
		TRUE:        new RegExp ('TRUE|true',   'gy'),
		PROFILE:     new RegExp ('PROFILE',     'gy'),
		PROTO:       new RegExp ('PROTO',       'gy'),
		ROUTE:       new RegExp ('ROUTE',       'gy'),
		TO:          new RegExp ('TO',          'gy'),
		UNIT:        new RegExp ('UNIT',        'gy'),
		USE:         new RegExp ('USE',         'gy'),

		// Terminal symbols
		OpenBrace:    new RegExp ('\\{', 'gy'),
		CloseBrace:   new RegExp ('\\}', 'gy'),
		OpenBracket:  new RegExp ('\\[', 'gy'),
		CloseBracket: new RegExp ('\\]', 'gy'),
		Period:       new RegExp ('\\.', 'gy'),
		Colon:        new RegExp ('\\:', 'gy'),

		Id: new RegExp ('([^\\x30-\\x39\\x00-\\x20\\x22\\x23\\x27\\x2b\\x2c\\x2d\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f]{1}[^\\x00-\\x20\\x22\\x23\\x27\\x2c\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f]*)', 'gy'),
		ComponentNameId: new RegExp ('([^\\x30-\\x39\\x00-\\x20\\x22\\x23\\x27\\x2b\\x2c\\x2d\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f\\x3a]{1}[^\\x00-\\x20\\x22\\x23\\x27\\x2c\\x2e\\x5b\\x5c\\x5d\\x7b\\x7d\\x7f\\x3a]*)', 'gy'),

		initializeOnly: new RegExp ('initializeOnly', 'gy'),
		inputOnly:      new RegExp ('inputOnly',      'gy'),
		outputOnly:     new RegExp ('outputOnly',     'gy'),
		inputOutput:    new RegExp ('inputOutput',    'gy'),

		field:        new RegExp ('field', 'gy'),
		eventIn:      new RegExp ('eventIn', 'gy'),
		eventOut:     new RegExp ('eventOut', 'gy'),
		exposedField: new RegExp ('exposedField', 'gy'),

		FieldType: new RegExp ('(MFBool|MFColorRGBA|MFColor|MFDouble|MFFloat|MFImage|MFInt32|MFMatrix3d|MFMatrix3f|MFMatrix4d|MFMatrix4f|MFNode|MFRotation|MFString|MFTime|MFVec2d|MFVec2f|MFVec3d|MFVec3f|MFVec4d|MFVec4f|SFBool|SFColorRGBA|SFColor|SFDouble|SFFloat|SFImage|SFInt32|SFMatrix3d|SFMatrix3f|SFMatrix4d|SFMatrix4f|SFNode|SFRotation|SFString|SFTime|SFVec2d|SFVec2f|SFVec3d|SFVec3f|SFVec4d|SFVec4f)', 'gy'),

		// Values
		int32:  new RegExp ('((?:0[xX][\\da-fA-F]+)|(?:[+-]?\\d+))', 'gy'),
		double: new RegExp ('([+-]?(?:(?:(?:\\d*\\.\\d+)|(?:\\d+(?:\\.)?))(?:[eE][+-]?\\d+)?))', 'gy'),
		string: new RegExp ('"((?:[^\\\\"]|\\\\\\\\|\\\\\\")*)"', 'gy'),

		Inf:         new RegExp ('[+]?(?:inf|Infinity)', 'gy'),
		NegativeInf: new RegExp ('-(?:inf|Infinity)',    'gy'),
		NaN:         new RegExp ('[+-]?(nan|NaN)',       'gy'),

		// Misc
		Break: new RegExp ('\\r?\\n', 'g'),
	};

	function parse (parser)
	{
		this .lastIndex = parser .lastIndex;

		parser .result = this .exec (parser .input);

		if (parser .result)
		{
			parser .lastIndex = this .lastIndex;
			return true;
		}

		return false;
	}

	for (var key in Grammar)
		Grammar [key] .parse = parse;

	Object .preventExtensions (Grammar);
	Object .freeze (Grammar);
	Object .seal (Grammar);

	/*
	 *  Parser
	 */

	function Parser (scene)
	{
		X3DParser .call (this, scene);
	}

	Parser .prototype = Object .assign (Object .create (X3DParser .prototype),
	{
		accessTypes:
		{
			field:          X3DConstants .initializeOnly,
			eventIn:        X3DConstants .inputOnly,
			eventOut:       X3DConstants .outputOnly,
			exposedField:   X3DConstants .inputOutput,
			initializeOnly: X3DConstants .initializeOnly,
			inputOnly:      X3DConstants .inputOnly,
			outputOnly:     X3DConstants .outputOnly,
			inputOutput:    X3DConstants .inputOutput,
		},
		SFBool: new Fields .SFBool (),
		SFColor: new Fields .SFColor (),
		SFColorRGBA: new Fields .SFColorRGBA (),
		SFDouble: new Fields .SFDouble (),
		SFFloat: new Fields .SFFloat (),
		SFImage: new Fields .SFImage (),
		SFInt32: new Fields .SFInt32 (),
		SFMatrix3f: new Fields .SFMatrix3f (),
		SFMatrix3d: new Fields .SFMatrix3d (),
		SFMatrix4f: new Fields .SFMatrix4f (),
		SFMatrix4d: new Fields .SFMatrix4d (),
		SFNode: new Fields .SFNode (),
		SFRotation: new Fields .SFRotation (),
		SFString: new Fields .SFString (),
		SFTime: new Fields .SFTime (),
		SFVec2d: new Fields .SFVec2d (),
		SFVec2f: new Fields .SFVec2f (),
		SFVec3d: new Fields .SFVec3d (),
		SFVec3f: new Fields .SFVec3f (),
		SFVec4d: new Fields .SFVec4d (),
		SFVec4f: new Fields .SFVec4f (),
		MFBool: new Fields .MFBool (),
		MFColor: new Fields .MFColor (),
		MFColorRGBA: new Fields .MFColorRGBA (),
		MFDouble: new Fields .MFDouble (),
		MFFloat: new Fields .MFFloat (),
		MFImage: new Fields .MFImage (),
		MFInt32: new Fields .MFInt32 (),
		MFMatrix3d: new Fields .MFMatrix3d (),
		MFMatrix3f: new Fields .MFMatrix3f (),
		MFMatrix4d: new Fields .MFMatrix4d (),
		MFMatrix4f: new Fields .MFMatrix4f  (),
		MFNode: new Fields .MFNode (),
		MFRotation: new Fields .MFRotation (),
		MFString: new Fields .MFString (),
		MFTime: new Fields .MFTime (),
		MFVec2d: new Fields .MFVec2d (),
		MFVec2f: new Fields .MFVec2f (),
		MFVec3d: new Fields .MFVec3d (),
		MFVec3f: new Fields .MFVec3f (),
		MFVec4d: new Fields .MFVec4d (),
		MFVec4f: new Fields .MFVec4f (),
		setInput: function (value)
		{
			this .input      = value;
			this .lineNumber = 1;
			this .lastIndex  = 0;
		},
		getInput: function ()
		{
			return this .input;
		},
		exception: function (string)
		{
			if (this .getBrowser () .isStrict ())
				throw new Error (string);

			this .getBrowser () .println (string);
		},
		parseIntoScene: function (input, success, error)
		{
			try
			{
				this .success = success;
				this .error   = error;

				this .getScene () .setEncoding ("VRML");
				this .getScene () .setProfile (this .getBrowser () .getProfile ("Full"));

				this .setInput (input);
				this .x3dScene ();
				return;
			}
			catch (error)
			{
				//console .log (error);
				throw new Error (this .getError (error));
			}
		},
		getError: function (error)
		{
			//console .log (error);

			var string = error .message;

			var
				rest     = this .getLine (),
				line     = this .getLastLine (),
				lastLine = this .getLastLine (),
				linePos  = line .length - rest .length + 1;

			if (line .length > 80)
			{
				line     = line .substr (linePos - 40, 80);
				lastLine = "";
				linePos  = 40;
			}

			// Format error

			var message = "\n"
				+ "********************************************************************************" + "\n"
				+ "Parser error at line " + this .lineNumber + ":" + linePos  + "\n"
				+ "in '" + this .getScene () .getURL () + "'" + "\n"
				+ "\n"
				+ lastLine + "\n"
				+ line + "\n"
				+ Array (linePos) .join (" ") + "^" + "\n"
				+ string + "\n"
				+ "********************************************************************************"
				+ "\n"
			;

			return message;
		},
		getLine: function ()
		{
			var
				input     = this .input,
				lastIndex = this .lastIndex,
				line      = "";

			while (lastIndex < input .length && input [lastIndex] !== "\n" && input [lastIndex] !== "\r")
				line += input [lastIndex ++];

			this .lastIndex = lastIndex;

			return line;
		},
		getLastLine: function ()
		{
			var
				input     = this .input,
				lastIndex = this .lastIndex,
				line      = "";

			if (lastIndex < input .length && (input [lastIndex] !== "\n" || input [lastIndex] !== "\r"))
				-- lastIndex;

			while (lastIndex >= 0 && input [lastIndex] !== "\n" && input [lastIndex] !== "\r")
				line = input [lastIndex --] + line;

			this .lastIndex = lastIndex;

			return line;
		},
		comments: function ()
		{
			while (this .comment ())
				;
		},
		comment: function ()
		{
			if (this .whitespaces ())
				return true;

			return Grammar .Comment .parse (this);
		},
		whitespaces: function ()
		{
			if (Grammar .Whitespaces .parse (this))
			{
				if (!this .xml)
					this .lines (this .result [1]);

				return true;
			}

			return false;
		},
		lines: function (string)
		{
			var match = string .match (Grammar .Break);

			if (match)
				this .lineNumber += match .length;
		},
		x3dScene: function ()
		{
			this .pushExecutionContext (this .getScene ());

			this .headerStatement ();
			this .profileStatement ();
			this .componentStatements ();
			this .unitStatements ();
			this .metaStatements ();

			try
			{
				this .setUnits (this .getScene () .getMetaData ("generator"));
			}
			catch (error)
			{ }

			if (this .success)
			{
				require (this .getProviderUrls (),
				function ()
				{
					try
					{
						this .statements ();
						this .popExecutionContext ();

						if (this .lastIndex < this .input .length)
							throw new Error ("Unknown statement.");

						this .success (this);
					}
					catch (error)
					{
						this .error (new Error (this .getError (error)));
					}
				}
				.bind (this),
				function (error)
				{
					this .error (error);
				}
				.bind (this));
			}
			else
			{
				this .statements ();
				this .popExecutionContext ();

				if (this .lastIndex < this .input .length)
					throw new Error ("Unknown statement.");
			}
		},
		headerStatement: function ()
		{
			Grammar .Header .lastIndex = 0;

			var result = Grammar .Header .exec (this .input);

			if (result)
			{
				this .getScene () .setSpecificationVersion (result [2]);
				this .getScene () .setEncoding             ("VRML");
				return true;
			}

			return false;
		},
		profileStatement: function ()
		{
			this .comments ();

			if (Grammar .PROFILE .parse (this))
			{
				if (this .profileNameId ())
				{
					var profile = this .getBrowser () .getProfile (this .result [1]);

					this .getScene () .setProfile (profile);
					return;
				}

				throw new Error ("Expected a profile name.");
			}
		},
		componentStatements: function ()
		{
			var component = this .componentStatement ();

			while (component)
			{
				this .getScene () .addComponent (component);

				component = this .componentStatement ();
			}
		},
		componentStatement: function ()
		{
			this .comments ();

			if (Grammar .COMPONENT .parse (this))
			{
				if (this .componentNameId ())
				{
					var componentNameIdCharacters = this .result [1];

					this .comments ();

					if (Grammar .Colon .parse (this))
					{
						if (this .componentSupportLevel ())
						{
							var componentSupportLevel = this .value;

							return this .getBrowser () .getComponent (componentNameIdCharacters, componentSupportLevel);
						}

						throw new Error ("Expected a component support level.");
					}

					throw new Error ("Expected a ':' after component name.");
				}

				throw new Error ("Expected a component name.");
			}

			return null;
		},
		componentSupportLevel: function ()
		{
			return this .int32 ();
		},
		unitStatements: function ()
		{
			while (this .unitStatement ())
				;
		},
		unitStatement: function ()
		{
			this .comments ();

			if (Grammar .UNIT .parse (this))
			{
				if (this .categoryNameId ())
				{
					var categoryNameId = this .result [1];

					if (this .unitNameId ())
					{
						var unitNameId = this .result [1];

						if (this .unitConversionFactor ())
						{
							var unitConversionFactor = this .value;

						   try
						   {
								this .getScene () .updateUnit (categoryNameId, unitNameId, unitConversionFactor);
								return true;
							}
							catch (error)
							{
							   console .log (error .message);
							   return true;
							}
						}

						throw new Error ("Expected unit conversion factor.");
					}

					throw new Error ("Expected unit name identificator.");
				}

				throw new Error ("Expected category name identificator after UNIT statement.");
			}

			return false;
		},
		unitConversionFactor: function ()
		{
			return this .double ();
		},
		metaStatements: function ()
		{
			while (this .metaStatement ())
				;
		},
		metaStatement: function ()
		{
			this .comments ();

			if (Grammar .META .parse (this))
			{
				if (this .metakey ())
				{
					var metakey = this .value;

					if (this .metavalue ())
					{
						var metavalue = this .value;

						this .getScene () .setMetaData (metakey, metavalue);
						return true;
					}

					throw new Error ("Expected metadata value.");
				}

				throw new Error ("Expected metadata key.");
			}

			return false;
		},
		metakey: function ()
		{
			return this .string ();
		},
		metavalue: function ()
		{
			return this .string ();
		},
		exportStatement: function ()
		{
			this .comments ();

			if (Grammar .EXPORT .parse (this))
			{
				if (this .nodeNameId ())
				{
					var
						localNodeNameId    = this .result [1],
						exportedNodeNameId = "";

					this .comments ();

					var node = this .getScene () .getLocalNode (localNodeNameId);

					if (Grammar .AS .parse (this))
					{
						if (this .exportedNodeNameId ())
							exportedNodeNameId = this .result [1];
						else
							throw new Error ("No name given after AS.");
					}
					else
						exportedNodeNameId = localNodeNameId;

					this .getScene () .updateExportedNode (exportedNodeNameId, node);
					return true;
				}

				throw new Error ("No name given after EXPORT.");
			}

			return false;
		},
		importStatement: function ()
		{
			this .comments ();

			if (Grammar .IMPORT .parse (this))
			{
				if (this .nodeNameId ())
				{
					var
						inlineNodeNameId = this .result [1],
						namedNode        = this .getExecutionContext () .getNamedNode (inlineNodeNameId);

					this .comments ();

					if (Grammar .Period .parse (this))
					{
						if (this .exportedNodeNameId ())
						{
							var
								exportedNodeNameId = this .result [1],
								nodeNameId         = exportedNodeNameId;

							this .comments ();

							if (Grammar .AS .parse (this))
							{
								if (this .nodeNameId ())
									nodeNameId = this .result [1];

								else
									throw new Error ("No name given after AS.");
							}

							this .getExecutionContext () .updateImportedNode (namedNode, exportedNodeNameId, nodeNameId);
							return true;
						}

						throw new Error ("Expected exported node name.");
					}

					throw new Error ("Expected a '.' after exported node name.");
				}

				throw new Error ("No name given after IMPORT statement.");
			}
			return false;
		},
		statements: function ()
		{
			while (this .statement ())
				;
		},
		statement: function ()
		{
			if (this .protoStatement ())
				return true;

			if (this .routeStatement ())
				return true;

			if (this .importStatement ())
				return true;

			if (this .exportStatement ())
				return true;

			var node = this .nodeStatement ();

			if (node !== false)
			{
				this .addRootNode (node);
				return true;
			}

			return false;
		},
		nodeStatement: function ()
		{
			this .comments ();

			if (Grammar .DEF .parse (this))
			{
				if (this .nodeNameId ())
					return this .node (this .result [1]);

				throw new Error ("No name given after DEF.");
			}

			if (Grammar .USE .parse (this))
			{
				if (this .nodeNameId ())
					return this .getExecutionContext () .getNamedNode (this .result [1]) .getValue ();

				throw new Error ("No name given after USE.");
			}

			if (Grammar .NULL .parse (this))
				return null;

			return this .node ("");
		},
		protoStatement: function ()
		{
			if (this .proto ())
				return true;

			if (this .externproto ())
				return true;

			return false;
		},
		protoStatements: function ()
		{
			while (this .protoStatement ())
				;
		},
		proto: function ()
		{
			this .comments ();

			if (Grammar .PROTO .parse (this))
			{
				if (this .nodeTypeId ())
				{
					var nodeTypeId = this .result [1];

					this .comments ();

					if (Grammar .OpenBracket .parse (this))
					{
						var interfaceDeclarations = this .interfaceDeclarations ();

						this .comments ();

						if (Grammar .CloseBracket .parse (this))
						{
							this .comments ();

							if (Grammar .OpenBrace .parse (this))
							{
								var proto = new X3DProtoDeclaration (this .getExecutionContext ());

								for (var i = 0, length = interfaceDeclarations .length; i < length; ++ i)
								{
									var field = interfaceDeclarations [i];

									proto .addUserDefinedField (field .getAccessType (), field .getName (), field);
								}

								this .pushExecutionContext (proto);

								this .protoBody ();

								this .popExecutionContext ();

								this .comments ();

								if (Grammar .CloseBrace .parse (this))
								{
									proto .setName (nodeTypeId);
									proto .setup ();

									this .getExecutionContext () .protos .add (nodeTypeId, proto);
									return true;
								}

								throw new Error ("Expected a '}' at the end of PROTO body.");
							}

							throw new Error ("Expected a '{' at the beginning of PROTO body.");
						}

						throw new Error ("Expected a ']' at the end of PROTO interface declaration.");
					}

					throw new Error ("Expected a '[' at the beginning of PROTO interface declaration.");
				}

				throw new Error ("Invalid PROTO definition name.");
			}

			return false;
		},
		protoBody: function ()
		{
			this .protoStatements ();

			var rootNodeStatement = this .rootNodeStatement ();

			if (rootNodeStatement !== false)
				this .addRootNode (rootNodeStatement);

			this .statements ();
		},
		rootNodeStatement: function ()
		{
			this .comments ();

			if (Grammar .DEF .parse (this))
			{
				if (this .nodeNameId ())
				{
					var
						nodeNameId = this .result [0],
						baseNode   = this .node (nodeNameId);

					if (baseNode !== false)
						return baseNode;

					throw new Error ("Expected node type name after DEF.");
				}

				throw new Error ("No name given after DEF.");
			}

			var baseNode = this .node ("");

			if (baseNode !== false)
				return baseNode;

			return false;
		},
		interfaceDeclarations: function ()
		{
			var
				interfaceDeclarations = [ ],
				field                 = this .interfaceDeclaration ();

			while (field)
			{
				interfaceDeclarations .push (field);

				field = this .interfaceDeclaration ();
			}

			return interfaceDeclarations;
		},
		restrictedInterfaceDeclaration: function ()
		{
			this .comments ();

			if (Grammar .inputOnly .parse (this) || Grammar .eventIn .parse (this))
			{
				if (this .fieldType ())
				{
					var fieldType = this .result [1];

					if (this .inputOnlyId ())
					{
						var
							fieldId = this .result [1],
							field = new (this [fieldType] .constructor) ();

						field .setAccessType (X3DConstants .inputOnly);
						field .setName (fieldId);
						return field;
					}

					throw new Error ("Expected a name for field.");
				}

				this .Id ()

				throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
			}

			if (Grammar .outputOnly .parse (this) || Grammar .eventOut .parse (this))
			{
				if (this .fieldType ())
				{
					var fieldType = this .result [1];

					if (this .outputOnlyId ())
					{
						var
							fieldId = this .result [1],
							field = new (this [fieldType] .constructor) ();

						field .setAccessType (X3DConstants .outputOnly);
						field .setName (fieldId);
						return field;
					}

					throw new Error ("Expected a name for field.");
				}

				this .Id ()

				throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
			}

			if (Grammar .initializeOnly .parse (this) || Grammar .field .parse (this))
			{
				if (this .fieldType ())
				{
					var fieldType = this .result [1];

					if (this .initializeOnlyId ())
					{
						var
							fieldId = this .result [1],
							field = new (this [fieldType] .constructor) ();

						if (this .fieldValue (field))
						{
							field .setAccessType (X3DConstants .initializeOnly);
							field .setName (fieldId);
							return field;
						}

						throw new Error ("Couldn't read value for field '" + fieldId + "'.");
					}

					throw new Error ("Expected a name for field.");
				}

				this .Id ()

				throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
			}

			return null;
		},
		interfaceDeclaration: function ()
		{
			var field = this .restrictedInterfaceDeclaration ();

			if (field)
				return field;

			this .comments ();

			if (Grammar .inputOutput .parse (this) || Grammar .exposedField .parse (this))
			{
				if (this .fieldType ())
				{
					var fieldType = this .result [1];

					if (this .inputOutputId ())
					{
						var
							fieldId = this .result [1],
							field   = new (this [fieldType] .constructor) ();

						if (this .fieldValue (field))
						{
							field .setAccessType (X3DConstants .inputOutput);
							field .setName (fieldId);
							return field;
						}

						throw new Error ("Couldn't read value for field '" + fieldId + "'.");
					}

					throw new Error ("Expected a name for field.");
				}

				this .Id ();

				throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
			}

			return null;
		},
		externproto: function ()
		{
			this .comments ();

			if (Grammar .EXTERNPROTO .parse (this))
			{
				if (this .nodeTypeId ())
				{
					var nodeTypeId = this .result [1];

					this .comments ();

					if (Grammar .OpenBracket .parse (this))
					{
						var externInterfaceDeclarations = this .externInterfaceDeclarations ();

						this .comments ();

						if (Grammar .CloseBracket .parse (this))
						{
							if (this .URLList (this .MFString))
							{
								var externproto = new X3DExternProtoDeclaration (this .getExecutionContext ());

								for (var i = 0, length = externInterfaceDeclarations .length; i < length; ++ i)
								{
									var field = externInterfaceDeclarations [i];

									externproto .addUserDefinedField (field .getAccessType (), field .getName (), field);
								}

								externproto .setName (nodeTypeId);
								externproto .url_ = this .MFString;
								externproto .setup ();

								this .getExecutionContext () .externprotos .add (nodeTypeId, externproto);
								return true;
							}

							throw new Error ("Expected a URL list after EXTERNPROTO interface declaration '" + nodeTypeId + "'.");
						}

						throw new Error ("Expected a ']' at the end of EXTERNPROTO interface declaration.");
					}

					throw new Error ("Expected a '[' at the beginning of EXTERNPROTO interface declaration.");
				}

				throw new Error ("Invalid EXTERNPROTO definition name.");
			}

			return false;
		},
		externInterfaceDeclarations: function ()
		{
			var
				externInterfaceDeclarations = [ ],
				field                       = this .externInterfaceDeclaration ();

			while (field)
			{
				externInterfaceDeclarations .push (field);

				field = this .externInterfaceDeclaration ();
			}

			return externInterfaceDeclarations;
		},
		externInterfaceDeclaration: function ()
		{
			this .comments ();

			if (Grammar .inputOnly .parse (this) || Grammar .eventIn .parse (this))
			{
				if (this .fieldType ())
				{
					var fieldType = this .result [1];

					if (this .inputOnlyId ())
					{
						var
							fieldId = this .result [1],
							field = new (this [fieldType] .constructor) ();

						field .setAccessType (X3DConstants .inputOnly);
						field .setName (fieldId);
						return field;
					}

					throw new Error ("Expected a name for field.");
				}

				this .Id ()

				throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
			}

			if (Grammar .outputOnly .parse (this) || Grammar .eventOut .parse (this))
			{
				if (this .fieldType ())
				{
					var fieldType = this .result [1];

					if (this .outputOnlyId ())
					{
						var
							fieldId = this .result [1],
							field = new (this [fieldType] .constructor) ();

						field .setAccessType (X3DConstants .outputOnly);
						field .setName (fieldId);
						return field;
					}

					throw new Error ("Expected a name for field.");
				}

				this .Id ()

				throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
			}

			if (Grammar .initializeOnly .parse (this) || Grammar .field .parse (this))
			{
				if (this .fieldType ())
				{
					var fieldType = this .result [1];

					if (this .initializeOnlyId ())
					{
						var
							fieldId = this .result [1],
							field = new (this [fieldType] .constructor) ();

						field .setAccessType (X3DConstants .initializeOnly);
						field .setName (fieldId);
						return field;
					}

					throw new Error ("Expected a name for field.");
				}

				this .Id ()

				throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
			}

			if (Grammar .inputOutput .parse (this) || Grammar .exposedField .parse (this))
			{
				if (this .fieldType ())
				{
					var fieldType = this .result [1];

					if (this .inputOutputId ())
					{
						var
							fieldId = this .result [1],
							field   = new (this [fieldType] .constructor) ();

						field .setAccessType (X3DConstants .inputOutput);
						field .setName (fieldId);
						return field;
					}

					throw new Error ("Expected a name for field.");
				}

				this .Id ()

				throw new Error ("Unknown event or field type: '" + this .result [1] + "'.");
			}

			return null;
		},
		URLList: function (field)
		{
			return this .mfstringValue (field);
		},
		routeStatement: function ()
		{
			this .comments ();

			if (Grammar .ROUTE .parse (this))
			{
				if (this .nodeNameId ())
				{
					var
						fromNodeId = this .result [1],
						fromNode   = this .getExecutionContext () .getLocalNode (fromNodeId);

					this .comments ();

					if (Grammar .Period .parse (this))
					{
						if (this .outputOnlyId ())
						{
							var eventOutId = this .result [1];

							this .comments ();

							if (Grammar .TO .parse (this))
							{
								if (this .nodeNameId ())
								{
									var
										toNodeId = this .result [1],
										toNode   = this .getExecutionContext () .getLocalNode (toNodeId);

									this .comments ();

									if (Grammar .Period .parse (this))
									{
										if (this .inputOnlyId ())
										{
											try
											{
												var eventInId = this .result [1];

												this .getExecutionContext () .addRoute (fromNode, eventOutId, toNode, eventInId);
												return true;
											}
											catch (error)
											{
												this .exception (error .message);

												return true;
											}
										}

										throw new Error ("Bad ROUTE specification: Expected a field name.");
									}

									throw new Error ("Bad ROUTE specification: Expected a '.' after node name.");
								}

								throw new Error ("Bad ROUTE specification: Expected a node name.");
							}

							throw new Error ("Bad ROUTE specification: Expected a 'TO'.");
						}

						throw new Error ("Bad ROUTE specification: Expected a field name.");
					}

					throw new Error ("Bad ROUTE specification: Expected a '.' after node name.");
				}

				throw new Error ("Bad ROUTE specification: Expected a node name.");
			}

			return false;
		},
		node: function (nodeNameId)
		{
			if (this .nodeTypeId ())
			{
				var
					nodeTypeId = this .result [1],
					baseNode   = this .getExecutionContext () .createNode (nodeTypeId, false);

				if (! baseNode)
				{
					baseNode = this .getExecutionContext () .createProto (nodeTypeId, false);

					if (! baseNode)
						throw new Error ("Unkown node type or proto '" + nodeTypeId + "', you probably have insufficient component/profile statements.");
				}

				if (nodeNameId .length)
				{
					try
					{
						var namedNode = this .getExecutionContext () .getNamedNode (nodeNameId);

						this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (nodeNameId), namedNode);
					}
					catch (error)
					{ }

					this .getExecutionContext () .updateNamedNode (nodeNameId, baseNode);
				}

				this .comments ();

				if (Grammar .OpenBrace .parse (this))
				{
					if (baseNode .hasUserDefinedFields ())
						this .scriptBody (baseNode);

					else
						this .nodeBody (baseNode);

					this .comments ();

					if (Grammar .CloseBrace .parse (this))
					{
						this .getExecutionContext () .addUninitializedNode (baseNode);
						return baseNode;
					}

					throw new Error ("Expected '}' at the end of node body.");
				}

				throw new Error ("Expected '{' at the beginning of node body.");
			}

			return false;
		},
		scriptBody: function (baseNode)
		{
			while (this .scriptBodyElement (baseNode))
				;
		},
		scriptBodyElement: function (baseNode)
		{
			var
				lastIndex  = this .lastIndex,
				lineNumber = this .lineNumber;

//			var
//				input      = this .input,
//				lineNumber = this .lineNumber;

			if (this .Id ())
			{
				var accessType = this .accessTypes [this .result [1]];

				if (accessType)
				{
					if (this .fieldType ())
					{
						var fieldType = this .result [1];

						if (this .Id ())
						{
							var fieldId = this .result [1];

							this .comments ();

							if (Grammar .IS .parse (this))
							{
								if (this .isInsideProtoDefinition ())
								{
									if (this .Id ())
									{
										var isId = this .result [1];

										try
										{
											var reference = this .getExecutionContext () .getField (isId);
										}
										catch (error)
										{
											this .exception ("No such event or field '" + isId + "' inside PROTO " + this .getExecutionContext () .getName () + " interface declaration.");

											return true;
										}

										var supportedField = this [fieldType];

										if (supportedField .getType () === reference .getType ())
										{
											if (reference .isReference (accessType))
											{
												try
												{
													var field = baseNode .getField (fieldId);

													if (! (accessType === field .getAccessType () && reference .getType () === field .getType ()))
													{
														field = this .createUserDefinedField (baseNode, accessType, fieldId, supportedField);
													}
												}
												catch (error)
												{
													var field = this .createUserDefinedField (baseNode, accessType, fieldId, supportedField);
												}

												field .addReference (reference);
												return true;
											}

											throw new Error ("Field '" + fieldId + "' and '" + reference .getName () + "' in PROTO '" + this .getExecutionContext () .getName () + "' are incompatible as an IS mapping.");
										}

										throw new Error ("Field '" + fieldId + "' and '" + reference .getName () + "' in PROTO '" + this .getExecutionContext () .getName () + "' have different types.");
									}

									throw new Error ("No name give after IS statement.");
								}

								throw new Error ("IS statement outside PROTO definition.");
							}
						}
					}
				}
			}

			this .lastIndex  = lastIndex;
			this .lineNumber = lineNumber;

//			this .input      = input;
//			this .lineNumber = lineNumber;

			var field = this .interfaceDeclaration ();

			if (field)
			{
				try
				{
					if (field .getAccessType () === X3DConstants .inputOutput)
					{
						var existingField = baseNode .getField (field .getName ());

						if (existingField .getAccessType () === X3DConstants .inputOutput)
						{
							if (field .getType () === existingField .getType ())
							{
								existingField .set (field .getValue ());
								existingField .setSet (true);
								return true;
							}
						}
					}
				}
				catch (error)
				{ }

				baseNode .addUserDefinedField (field .getAccessType (), field .getName (), field);
				return true;
			}

			return this .nodeBodyElement (baseNode);
		},
		createUserDefinedField: function (baseNode, accessType, fieldId, supportedField)
		{
			var field = new (supportedField .constructor) ();

			baseNode .addUserDefinedField (accessType, fieldId, field);

			return field;
		},
		nodeBody: function (baseNode)
		{
			while (this .nodeBodyElement (baseNode))
				;
		},
		nodeBodyElement: function (baseNode)
		{
			if (this .protoStatement ())
				return true;

			if (this .routeStatement ())
				return true;

			if (this .Id ())
			{
				var fieldId = this .result [1];

				try
				{
					var field = baseNode .getField (fieldId);
				}
				catch (error)
				{
					throw new Error ("Unknown field '" + fieldId + "' in class '" + baseNode .getTypeName () + "'.");
				}

				this .comments ();

				if (Grammar .IS .parse (this))
				{
					if (this .isInsideProtoDefinition ())
					{
						if (this .Id ())
						{
							var isId = this .result [1];

							try
							{
								var reference = this .getExecutionContext () .getField (isId);
							}
							catch (error)
							{
								this .exception ("No such event or field '" + isId + "' inside PROTO " + this .getExecutionContext () .getName ());

								return true;
							}

							if (field .getType () === reference .getType ())
							{
								if (reference .isReference (field .getAccessType ()))
								{
									field .addReference (reference);
									return true;
								}

								throw new Error ("Field '" + field .getName () + "' and '" + reference .getName () + "' in PROTO " + this .getExecutionContext () . getName () + " are incompatible as an IS mapping.");
							}

							throw new Error ("Field '" + field .getName () + "' and '" + reference .getName () + "' in PROTO " + this .getExecutionContext () .getName () + " have different types.");
						}

						throw new Error("No name give after IS statement.");
					}

					throw new Error ("IS statement outside PROTO definition.");
				}

				if (field .isInitializable ())
				{
					if (this .fieldValue (field))
						return true;

					throw new Error ("Couldn't read value for field '" + fieldId + "'.");
				}

				throw new Error ("Couldn't assign value to " + accessTypeToString (field .getAccessType ()) + " field '" + fieldId + "'.");
			}

			return false;
		},
		profileNameId: function () { return this .Id (); },
		componentNameId: function ()
		{
			this .comments ();

			return Grammar .ComponentNameId .parse (this);
		},
		categoryNameId: function () { return this .Id (); },
		unitNameId: function () { return this .Id (); },
		exportedNodeNameId: function () { return this .Id (); },
		nodeNameId: function () { return this .Id (); },
		nodeTypeId: function () { return this .Id (); },
		initializeOnlyId: function () { return this .Id (); },
		inputOnlyId: function () { return this .Id (); },
		outputOnlyId: function () { return this .Id (); },
		inputOutputId: function () { return this .Id (); },
		Id: function ()
		{
			this .comments ();

			return Grammar .Id .parse (this);
		},
		fieldType: function ()
		{
			this .comments ();

			return Grammar .FieldType .parse (this);
		},
		fieldValue: function (field)
		{
			field .setSet (true);

			return this .fieldTypes [field .getType ()] .call (this, field);
		},
		double: function ()
		{
			this .comments ();

			if (Grammar .double .parse (this))
			{
				this .value = parseFloat (this .result [1]);
				return true;
			}

			if (Grammar .Inf .parse (this))
			{
				this .value = Number .POSITIVE_INFINITY;
				return true;
			}

			if (Grammar .NegativeInf .parse (this))
			{
				this .value = Number .NEGATIVE_INFINITY;
				return true;
			}

			if (Grammar .NaN .parse (this))
			{
				this .value = Number .NaN;
				return true;
			}

			return false;
		},
		int32: function ()
		{
			this .comments ();

			if (Grammar .int32 .parse (this))
			{
				this .value = parseInt (this .result [1]);
				return true;
			}

			return false;
		},
		string: function ()
		{
			this .comments ();

			if (Grammar .string .parse (this))
			{
				this .value = Fields .SFString .unescape (this .result [1]);

				this .lines (this .value);

				return true;
			}

			return false;
		},
		sfboolValue: function (field)
		{
			this .comments ();

			if (Grammar .TRUE .parse (this))
			{
				field .set (true);
				return true;
			}

			if (Grammar .FALSE .parse (this))
			{
				field .set (false);
				return true;
			}

			return false;
		},
		mfboolValue: function (field)
		{
			field .length = 0;

			if (this .sfboolValue (this .SFBool))
			{
				field .push (this .SFBool);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfboolValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfboolValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfboolValue (this .SFBool))
			{
				field .push (this .SFBool);
			}
		},
		sfcolorValue: function (field)
		{
			if (this .double ())
			{
				var r = this .value;

				if (this .double ())
				{
					var g = this .value;

					if (this .double ())
					{
						var b = this .value;

						field .getValue () .set (r, g, b);
						return true;
					}
				}
			}

			return false;
		},
		mfcolorValue: function (field)
		{
			field .length = 0;

			if (this .sfcolorValue (this .SFColor))
			{
				field .push (this .SFColor);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfcolorValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfcolorValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfcolorValue (this .SFColor))
			{
				field .push (this .SFColor);
			}
		},
		sfcolorrgbaValue: function (field)
		{
			if (this .double ())
			{
				var r = this .value;

				if (this .double ())
				{
					var g = this .value;

					if (this .double ())
					{
						var b = this .value;

						if (this .double ())
						{
							var a = this .value;

							field .getValue () .set (r, g, b, a);
							return true;
						}
					}
				}
			}

			return false;
		},
		mfcolorrgbaValue: function (field)
		{
			field .length = 0;

			if (this .sfcolorrgbaValue (this .SFColorRGBA))
			{
				field .push (this .SFColorRGBA);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfcolorrgbaValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfcolorrgbaValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfcolorrgbaValue (this .SFColorRGBA))
			{
				field .push (this .SFColorRGBA);
			}
		},
		sfdoubleValue: function (field)
		{
			if (this .double ())
			{
				field .set (this .fromUnit (field .getUnit (), this .value));
				return true;
			}

			return false;
		},
		mfdoubleValue: function (field)
		{
			field .length = 0;

			this .SFDouble .setUnit (field .getUnit ());

			if (this .sfdoubleValue (this .SFDouble))
			{
				field .push (this .SFDouble);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfdoubleValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfdoubleValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			this .SFDouble .setUnit (field .getUnit ());

			while (this .sfdoubleValue (this .SFDouble))
			{
				field .push (this .SFDouble);
			}
		},
		sffloatValue: function (field)
		{
			return this .sfdoubleValue (field);
		},
		mffloatValue: function (field)
		{
			field .length = 0;

			this .SFFloat .setUnit (field .getUnit ());

			if (this .sffloatValue (this .SFFloat))
			{
				field .push (this .SFFloat);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sffloatValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sffloatValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			this .SFFloat .setUnit (field .getUnit ());

			while (this .sffloatValue (this .SFFloat))
			{
				field .push (this .SFFloat);
			}
		},
		sfimageValue: function (field)
		{
			if (this .int32 ())
			{
				var width = this .value;

				if (this .int32 ())
				{
					var height = this .value;

					if (this .int32 ())
					{
						var
							comp  = this .value,
							size  = width * height;

						field .width  = width;
						field .height = height;
						field .comp   = comp;

						var array = field .array;

						for (var i = 0; i < size; ++ i)
						{
							if (this .int32 ())
							{
								array [i] = this .value;
								continue;
							}

							return false;
						}

						return true;
					}
				}
			}

			return false;
		},
		mfimageValue: function (field)
		{
			field .length = 0;

			if (this .sfimageValue (this .SFImage))
			{
				field .push (this .SFImage);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfimageValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfimageValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfimageValue (this .SFImage))
			{
				field .push (this .SFImage);
			}
		},
		sfint32Value: function (field)
		{
			if (this .int32 ())
			{
				field .set (this .value);
				return true;
			}

			return false;
		},
		mfint32Value: function (field)
		{
			field .length = 0;

			if (this .sfint32Value (this .SFInt32))
			{
				field .push (this .SFInt32);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfint32Values (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfint32Values: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfint32Value (this .SFInt32))
			{
				field .push (this .SFInt32);
			}
		},
		sfmatrix3dValue: function (field)
		{
			if (this .double ())
			{
				var m00 = this .value;

				if (this .double ())
				{
					var m01 = this .value;

					if (this .double ())
					{
						var m02 = this .value;

							if (this .double ())
							{
								var m10 = this .value;

								if (this .double ())
								{
									var m11 = this .value;

									if (this .double ())
									{
										var m12 = this .value;

										if (this .double ())
										{
											var m20 = this .value;

											if (this .double ())
											{
												var m21 = this .value;

												if (this .double ())
												{
													var m22 = this .value;

													field .getValue () .set (m00, m01, m02,
													                         m10, m11, m12,
													                         m20, m21, m22);
													return true;
											}
										}
									}
								}
							}
						}
					}
				}
			}

			return false;
		},
		mfmatrix3dValue: function (field)
		{
			field .length = 0;

			if (this .sfmatrix3dValue (this .SFMatrix3d))
			{
				field .push (this .SFMatrix3d);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfmatrix3dValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfmatrix3dValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfmatrix3dValue (this .SFMatrix3d))
			{
				field .push (this .SFMatrix3d);
			}
		},
		sfmatrix3fValue: function (field)
		{
			return this .sfmatrix3dValue (field);
		},
		mfmatrix3fValue: function (field)
		{
			field .length = 0;

			if (this .sfmatrix3fValue (this .SFMatrix3f))
			{
				field .push (this .SFMatrix3f);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfmatrix3fValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfmatrix3fValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfmatrix3fValue (this .SFMatrix3f))
			{
				field .push (this .SFMatrix3f);
			}
		},
		sfmatrix4dValue: function (field)
		{
			if (this .double ())
			{
				var m00 = this .value;

				if (this .double ())
				{
					var m01 = this .value;

					if (this .double ())
					{
						var m02 = this .value;

						if (this .double ())
						{
							var m03 = this .value;

							if (this .double ())
							{
								var m10 = this .value;

								if (this .double ())
								{
									var m11 = this .value;

									if (this .double ())
									{
										var m12 = this .value;

										if (this .double ())
										{
											var m13 = this .value;

											if (this .double ())
											{
												var m20 = this .value;

												if (this .double ())
												{
													var m21 = this .value;

													if (this .double ())
													{
														var m22 = this .value;

														if (this .double ())
														{
															var m23 = this .value;

															if (this .double ())
															{
																var m30 = this .value;

																if (this .double ())
																{
																	var m31 = this .value;

																	if (this .double ())
																	{
																		var m32 = this .value;

																		if (this .double ())
																		{
																			var m33 = this .value;

																			field .getValue () .set (m00, m01, m02, m03,
																			                         m10, m11, m12, m13,
																			                         m20, m21, m22, m23,
																			                         m30, m31, m32, m33);
																			return true;
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}

			return false;
		},
		mfmatrix4dValue: function (field)
		{
			field .length = 0;

			if (this .sfmatrix4dValue (this .SFMatrix4d))
			{
				field .push (this .SFMatrix4d);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfmatrix4dValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfmatrix4dValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfmatrix4dValue (this .SFMatrix4d))
			{
				field .push (this .SFMatrix4d);
			}
		},
		sfmatrix4fValue: function (field)
		{
			return this .sfmatrix4dValue (field);
		},
		mfmatrix4fValue: function (field)
		{
			field .length = 0;

			if (this .sfmatrix4fValue (this .SFMatrix4f))
			{
				field .push (this .SFMatrix4f);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfmatrix4fValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfmatrix4fValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfmatrix4fValue (this .SFMatrix4f))
			{
				field .push (this .SFMatrix4f);
			}
		},
		sfnodeValue: function (field)
		{
			var baseNode = this .nodeStatement ();

			if (baseNode !== false)
			{
				field .setValue (baseNode);
				return true;
			}

			return false;
		},
		mfnodeValue: function (field)
		{
			field .length = 0;

			var node = this .nodeStatement ();

			if (node !== false)
			{
				field .push (node);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .nodeStatements (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		nodeStatements: function (field)
		{
			var node = this .nodeStatement ();

			while (node !== false)
			{
				field .push (node);

				node = this .nodeStatement ();
			}
		},
		sfrotationValue: function (field)
		{
			if (this .double ())
			{
				var x = this .value;

				if (this .double ())
				{
					var y = this .value;

					if (this .double ())
					{
						var z = this .value;

						if (this .double ())
						{
							var angle = this .value;

							field .getValue () .set (x, y, z, this .fromUnit ("angle", angle));
							return true;
						}
					}
				}
			}

			return false;
		},
		mfrotationValue: function (field)
		{
			field .length = 0;

			if (this .sfrotationValue (this .SFRotation))
			{
				field .push (this .SFRotation);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfrotationValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfrotationValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfrotationValue (this .SFRotation))
			{
				field .push (this .SFRotation);
			}
		},
		sfstringValue: function (field)
		{
			if (this .string ())
			{
				field .set (this .value);
				return true;
			}

			return false;
		},
		mfstringValue: function (field)
		{
			field .length = 0;

			if (this .sfstringValue (this .SFString))
			{
				field .push (this .SFString);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfstringValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfstringValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sfstringValue (this .SFString))
			{
				field .push (this .SFString);
			}
		},
		sftimeValue: function (field)
		{
			return this .sfdoubleValue (field);
		},
		mftimeValue: function (field)
		{
			field .length = 0;

			if (this .sftimeValue (this .SFTime))
			{
				field .push (this .SFTime);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sftimeValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sftimeValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			while (this .sftimeValue (this .SFTime))
			{
				field .push (this .SFTime);
			}
		},
		sfvec2dValue: function (field)
		{
			if (this .double ())
			{
				var x = this .value;

				if (this .double ())
				{
					var
						y        = this .value,
						category = field .getUnit ();

					field .getValue () .set (this .fromUnit (category, x),
					                         this .fromUnit (category, y));
					return true;
				}
			}

			return false;
		},
		mfvec2dValue: function (field)
		{
			field .length = 0;

			this .SFVec2d .setUnit (field .getUnit ());

			if (this .sfvec2dValue (this .SFVec2d))
			{
				field .push (this .SFVec2d);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfvec2dValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfvec2dValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			this .SFVec2d .setUnit (field .getUnit ());

			while (this .sfvec2dValue (this .SFVec2d))
			{
				field .push (this .SFVec2d);
			}
		},
		sfvec2fValue: function (field)
		{
			return this .sfvec2dValue (field);
		},
		mfvec2fValue: function (field)
		{
			field .length = 0;

			this .SFVec2f .setUnit (field .getUnit ());

			if (this .sfvec2fValue (this .SFVec2f))
			{
				field .push (this .SFVec2f);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfvec2fValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfvec2fValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			this .SFVec2f .setUnit (field .getUnit ());

			while (this .sfvec2fValue (this .SFVec2f))
			{
				field .push (this .SFVec2f);
			}
		},
		sfvec3dValue: function (field)
		{
			if (this .double ())
			{
				var x = this .value;

				if (this .double ())
				{
					var y = this .value;

					if (this .double ())
					{
						var
							z        = this .value,
							category = field .getUnit ();

						field .getValue () .set (this .fromUnit (category, x),
						                         this .fromUnit (category, y),
						                         this .fromUnit (category, z));
						return true;
					}
				}
			}

			return false;
		},
		mfvec3dValue: function (field)
		{
			field .length = 0;

			this .SFVec3d .setUnit (field .getUnit ());

			if (this .sfvec3dValue (this .SFVec3d))
			{
				field .push (this .SFVec3d);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfvec3dValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfvec3dValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			this .SFVec3d .setUnit (field .getUnit ());

			while (this .sfvec3dValue (this .SFVec3d))
			{
				field .push (this .SFVec3d);
			}
		},
		sfvec3fValue: function (field)
		{
			return this .sfvec3dValue (field);
		},
		mfvec3fValue: function (field)
		{
			field .length = 0;

			this .SFVec3f .setUnit (field .getUnit ());

			if (this .sfvec3fValue (this .SFVec3f))
			{
				field .push (this .SFVec3f);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfvec3fValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfvec3fValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			this .SFVec3f .setUnit (field .getUnit ());

			while (this .sfvec3fValue (this .SFVec3f))
			{
				field .push (this .SFVec3f);
			}
		},
		sfvec4dValue: function (field)
		{
			if (this .double ())
			{
				var x = this .value;

				if (this .double ())
				{
					var y = this .value;

					if (this .double ())
					{
						var z = this .value;

						if (this .double ())
						{
							var
								w        = this .value,
								category = field .getUnit ();

							field .getValue () .set (this .fromUnit (category, x),
							                         this .fromUnit (category, y),
							                         this .fromUnit (category, z),
							                         this .fromUnit (category, w));
							return true;
						}
					}
				}
			}

			return false;
		},
		mfvec4dValue: function (field)
		{
			field .length = 0;

			this .SFVec4d .setUnit (field .getUnit ());

			if (this .sfvec4dValue (this .SFVec4d))
			{
				field .push (this .SFVec4d);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfvec4dValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfvec4dValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			this .SFVec4d .setUnit (field .getUnit ());

			while (this .sfvec4dValue (this .SFVec4d))
			{
				field .push (this .SFVec4d);
			}
		},
		sfvec4fValue: function (field)
		{
			return this .sfvec4dValue (field);
		},
		mfvec4fValue: function (field)
		{
			field .length = 0;

			this .SFVec4f .setUnit (field .getUnit ());

			if (this .sfvec4fValue (this .SFVec4f))
			{
				field .push (this .SFVec4f);
				return true;
			}

			if (Grammar .OpenBracket .parse (this))
			{
				this .sfvec4fValues (field);

				this .comments ();

				if (Grammar .CloseBracket .parse (this))
					return true;

				throw new Error ("Expected ']'.");
			}

			return false;
		},
		sfvec4fValues: function (field)
		{
			field .length = 0;
			field         = field .getTarget ();

			this .SFVec4f .setUnit (field .getUnit ());

			while (this .sfvec4fValue (this .SFVec4f))
			{
				field .push (this .SFVec4f);
			}
		},
	});

	Parser .prototype .fieldTypes = [ ];
	Parser .prototype .fieldTypes [X3DConstants .SFBool]      = Parser .prototype .sfboolValue;
	Parser .prototype .fieldTypes [X3DConstants .SFColor]     = Parser .prototype .sfcolorValue;
	Parser .prototype .fieldTypes [X3DConstants .SFColorRGBA] = Parser .prototype .sfcolorrgbaValue;
	Parser .prototype .fieldTypes [X3DConstants .SFDouble]    = Parser .prototype .sfdoubleValue;
	Parser .prototype .fieldTypes [X3DConstants .SFFloat]     = Parser .prototype .sffloatValue;
	Parser .prototype .fieldTypes [X3DConstants .SFImage]     = Parser .prototype .sfimageValue;
	Parser .prototype .fieldTypes [X3DConstants .SFInt32]     = Parser .prototype .sfint32Value;
	Parser .prototype .fieldTypes [X3DConstants .SFMatrix3f]  = Parser .prototype .sfmatrix3dValue;
	Parser .prototype .fieldTypes [X3DConstants .SFMatrix3d]  = Parser .prototype .sfmatrix3fValue;
	Parser .prototype .fieldTypes [X3DConstants .SFMatrix4f]  = Parser .prototype .sfmatrix4dValue;
	Parser .prototype .fieldTypes [X3DConstants .SFMatrix4d]  = Parser .prototype .sfmatrix4fValue;
	Parser .prototype .fieldTypes [X3DConstants .SFNode]      = Parser .prototype .sfnodeValue;
	Parser .prototype .fieldTypes [X3DConstants .SFRotation]  = Parser .prototype .sfrotationValue;
	Parser .prototype .fieldTypes [X3DConstants .SFString]    = Parser .prototype .sfstringValue;
	Parser .prototype .fieldTypes [X3DConstants .SFTime]      = Parser .prototype .sftimeValue;
	Parser .prototype .fieldTypes [X3DConstants .SFVec2d]     = Parser .prototype .sfvec2dValue;
	Parser .prototype .fieldTypes [X3DConstants .SFVec2f]     = Parser .prototype .sfvec2fValue;
	Parser .prototype .fieldTypes [X3DConstants .SFVec3d]     = Parser .prototype .sfvec3dValue;
	Parser .prototype .fieldTypes [X3DConstants .SFVec3f]     = Parser .prototype .sfvec3fValue;
	Parser .prototype .fieldTypes [X3DConstants .SFVec4d]     = Parser .prototype .sfvec4dValue;
	Parser .prototype .fieldTypes [X3DConstants .SFVec4f]     = Parser .prototype .sfvec4fValue;

	Parser .prototype .fieldTypes [X3DConstants .MFBool]      = Parser .prototype .mfboolValue;
	Parser .prototype .fieldTypes [X3DConstants .MFColor]     = Parser .prototype .mfcolorValue;
	Parser .prototype .fieldTypes [X3DConstants .MFColorRGBA] = Parser .prototype .mfcolorrgbaValue;
	Parser .prototype .fieldTypes [X3DConstants .MFDouble]    = Parser .prototype .mfdoubleValue;
	Parser .prototype .fieldTypes [X3DConstants .MFFloat]     = Parser .prototype .mffloatValue;
	Parser .prototype .fieldTypes [X3DConstants .MFImage]     = Parser .prototype .mfimageValue;
	Parser .prototype .fieldTypes [X3DConstants .MFInt32]     = Parser .prototype .mfint32Value;
	Parser .prototype .fieldTypes [X3DConstants .MFMatrix3d]  = Parser .prototype .mfmatrix3dValue;
	Parser .prototype .fieldTypes [X3DConstants .MFMatrix3f]  = Parser .prototype .mfmatrix3fValue;
	Parser .prototype .fieldTypes [X3DConstants .MFMatrix4d]  = Parser .prototype .mfmatrix4dValue;
	Parser .prototype .fieldTypes [X3DConstants .MFMatrix4f]  = Parser .prototype .mfmatrix4fValue;
	Parser .prototype .fieldTypes [X3DConstants .MFNode]      = Parser .prototype .mfnodeValue;
	Parser .prototype .fieldTypes [X3DConstants .MFRotation]  = Parser .prototype .mfrotationValue;
	Parser .prototype .fieldTypes [X3DConstants .MFString]    = Parser .prototype .mfstringValue;
	Parser .prototype .fieldTypes [X3DConstants .MFTime]      = Parser .prototype .mftimeValue;
	Parser .prototype .fieldTypes [X3DConstants .MFVec2d]     = Parser .prototype .mfvec2dValue;
	Parser .prototype .fieldTypes [X3DConstants .MFVec2f]     = Parser .prototype .mfvec2fValue;
	Parser .prototype .fieldTypes [X3DConstants .MFVec3d]     = Parser .prototype .mfvec3dValue;
	Parser .prototype .fieldTypes [X3DConstants .MFVec3f]     = Parser .prototype .mfvec3fValue;
	Parser .prototype .fieldTypes [X3DConstants .MFVec4d]     = Parser .prototype .mfvec4dValue;
	Parser .prototype .fieldTypes [X3DConstants .MFVec4f]     = Parser .prototype .mfvec4fValue;

	return Parser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Utility/DataStorage',[
	"jquery",
],
function ($)
{
"use strict";

	var
		storages   = new WeakMap (),
		namespaces = new WeakMap ();

	var handler =
	{
		get: function (target, key)
		{
			var value = target [key];

			if (value !== undefined)
				return value;

			var value = target .getStorage () [target .getNameSpace () + key];

			if (value === undefined || value === "undefined")
			   return undefined;

			return $ .parseJSON (value);
		},
		set: function (target, key, value)
		{
			if (value === undefined)
				target .getStorage () .removeItem (target .getNameSpace () + key);

			else
				target .getStorage () [target .getNameSpace () + key] = JSON .stringify (value);

			return true;
		},
	};

	function DataStorage (storage, namespace)
	{
		this .target  = this;

		storages   .set (this, storage);
		namespaces .set (this, namespace);

		return new Proxy (this, handler);
	}

	DataStorage .prototype = {
		constructor: DataStorage,
		getStorage: function ()
		{
			return storages .get (this .target);
		},
		getNameSpace: function ()
		{
			return namespaces .get (this .target);
		},
		clear: function ()
		{
			var
				storage   = this .getStorage (),
				namespace = this .getNameSpace ();

			$.each (storage, function (key)
			{
				if (key .substr (0, namespace .length) === namespace)
					storage .removeItem (key);
			});
		},
	}

	return DataStorage;
});
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Core/X3DCoreContext',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Browser/Core/BrowserOptions",
	"x_ite/Browser/Core/BrowserProperties",
	"x_ite/Browser/Core/RenderingProperties",
	"x_ite/Browser/Core/Notification",
	"x_ite/Browser/Core/BrowserTimings",
	"x_ite/Browser/Core/ContextMenu",
	"x_ite/Execution/Scene",
	"x_ite/Parser/Parser",
	"standard/Utility/DataStorage",
	"x_ite/DEBUG",
],
function ($,
          Fields,
          BrowserOptions,
          BrowserProperties,
          RenderingProperties,
          Notification,
          BrowserTimings,
          ContextMenu,
          Scene,
          Parser,
          DataStorage,
          DEBUG)
{
"use strict";

	var WEBGL_LATEST_VERSION = 2;

	var browserNumber = 0;

	var extensions = [
		"ANGLE_instanced_arrays",
		"EXT_blend_minmax",
		"EXT_frag_depth",
		"EXT_shader_texture_lod",
		"EXT_texture_filter_anisotropic",
		"OES_element_index_uint",
		"OES_standard_derivatives",
		"OES_texture_float",
		"OES_texture_float_linear",
		"OES_texture_half_float",
		"OES_texture_half_float_linear",
		"OES_vertex_array_object",
		"WEBGL_compressed_texture_s3tc",
		"WEBGL_debug_renderer_info",
		"WEBGL_debug_shaders",
		"WEBGL_depth_texture",
		"WEBGL_draw_buffers",
		"WEBGL_lose_context",

		"EXT_color_buffer_float",
		"EXT_color_buffer_half_float",
		"EXT_disjoint_timer_query",
		"EXT_disjoint_timer_query_webgl2",
		"EXT_sRGB",
		"WEBGL_color_buffer_float",
		"WEBGL_compressed_texture_astc",
		"WEBGL_compressed_texture_atc",
		"WEBGL_compressed_texture_etc",
		"WEBGL_compressed_texture_etc1",
		"WEBGL_compressed_texture_pvrtc",
		"WEBGL_compressed_texture_s3tc",
		"WEBGL_compressed_texture_s3tc_srgb",

		"EXT_float_blend",
		"OES_fbo_render_mipmap",
		"WEBGL_get_buffer_sub_data_async",
		"WEBGL_multiview",
		"WEBGL_security_sensitive_resources",
		"WEBGL_shared_resources",

		"EXT_clip_cull_distance",
		"WEBGL_debug",
		"WEBGL_dynamic_texture",
		"WEBGL_subarray_uploads",
		"WEBGL_texture_multisample",
		"WEBGL_texture_source_iframe",
		"WEBGL_video_texture",

		"EXT_texture_storage",
		"OES_depth24",
		"WEBGL_debug_shader_precision",
		"WEBGL_draw_elements_no_range_check",
		"WEBGL_subscribe_uniform",
		"WEBGL_texture_from_depth_video",
	];

	function getContext (canvas, version, preserveDrawingBuffer)
	{
		var
			options = { preserveDrawingBuffer: preserveDrawingBuffer },
			gl      = null;

		if (version >= 2 && ! gl)
		{
			gl = canvas .getContext ("webgl2", options);

			if (gl)
				gl .getVersion = function () { return 2; };
		}

		if (version >= 1 && ! gl)
		{
			gl = canvas .getContext ("webgl",              options) ||
			     canvas .getContext ("experimental-webgl", options);

			if (gl)
				gl .getVersion = function () { return 1; };
		}

		if (! gl)
			throw new Error ("Couldn't create WebGL context.");

		// Feature detection:

		// If the aliased linewidth ranges are both 1, gl.lineWidth is probably not possible,
		// thus we disable it completely to prevent webgl errors.

		var aliasedLineWidthRange = gl .getParameter (gl .ALIASED_LINE_WIDTH_RANGE);

		if (aliasedLineWidthRange [0] === 1 && aliasedLineWidthRange [1] === 1)
		{
			gl .lineWidth = Function .prototype;
		}

		// Return context.

		return gl;
	}

	function X3DCoreContext (element)
	{
		this .number  = ++ browserNumber;
		this .element = element;

		// Get canvas & context.

		var browser      = $("<div></div>") .addClass ("x_ite-private-browser")  .prependTo (this .element);
		var splashScreen = $("<div></div>") .addClass ("x_ite-private-splash-screen") .appendTo (browser);
		var spinner      = $("<div></div>") .addClass ("x_ite-private-spinner")  .appendTo (splashScreen);
		var progress     = $("<div></div>") .addClass ("x_ite-private-progress") .appendTo (splashScreen);
		var surface      = $("<div></div>") .addClass ("x_ite-private-surface x_ite-private-surface-" + this .getId ()) .appendTo (browser);

		$("<div></div>") .addClass ("x_ite-private-x_ite") .html ("X_ITE<span class='x_ite-private-x3d'>X3D</span>") .appendTo (progress);
		$("<div></div>") .addClass ("x_ite-private-progressbar")  .appendTo (progress) .append ($("<div></div>"));
		$("<div></div>") .addClass ("x_ite-private-spinner-text") .appendTo (progress) .text ("Lade 0 Dateien");

		this .splashScreen = splashScreen;
		this .surface      = surface;
		this .canvas       = $("<canvas></canvas>") .addClass ("x_ite-private-canvas") .prependTo (surface);
		this .context      = getContext (this .canvas [0], WEBGL_LATEST_VERSION, element .attr ("preserveDrawingBuffer") === "true");
		this .extensions   = { };

		var gl = this .getContext ();

		extensions .forEach (function (name)
		{
			this .extensions [name] = gl .getExtension (name);
		},
		this);

		this .browserOptions      = new BrowserOptions      (this .getPrivateScene ());
		this .browserProperties   = new BrowserProperties   (this .getPrivateScene ());
		this .renderingProperties = new RenderingProperties (this .getPrivateScene ());
		this .notification        = new Notification        (this .getPrivateScene ());
		this .browserTimings      = new BrowserTimings      (this .getPrivateScene ());
		this .contextMenu         = new ContextMenu         (this .getPrivateScene ());

		this .localStorage = new DataStorage (localStorage, "X_ITE.X3DBrowser(" + this .number + ").");
		this .mobile       = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i .test (navigator .userAgent);

		$(".x_ite-console") .empty ();

		this .addChildObjects ("controlKey",  new Fields .SFBool (),
		                       "shiftKey",    new Fields .SFBool (),
		                       "altKey",      new Fields .SFBool (),
		                       "altGrKey",    new Fields .SFBool ());
	}

	X3DCoreContext .prototype =
	{
		initialize: function ()
		{
			// Setup browser nodes.

			this .browserOptions      .setup ()
			this .browserProperties   .setup ()
			this .renderingProperties .setup ();
			this .notification        .setup ();
			this .browserTimings      .setup ();
			this .contextMenu         .setup ();

			// Observe Element's attributes.

			this .observer = new MutationObserver (this .processMutations .bind (this));

			this .observer .observe (this .element [0], { attributes: true, childList: false, characterData: false, subtree: false });

			// Define src and url property.

			Object .defineProperty (this .getElement () .get (0), "src",
			{
				get: (function ()
				{
					return this .getExecutionContext () .getWorldURL ();
				})
				.bind (this),
				set: (function (value)
				{
					this .loadURL (new Fields .MFString (value), new Fields .MFString ());
				})
				.bind (this),
				enumerable: true,
				configurable: false
			});

			Object .defineProperty (this .getElement () .get (0), "url",
			{
				get: (function ()
				{
					var worldURL = this .getExecutionContext () .getWorldURL ();

					if (worldURL)
						return new Fields .MFString (worldURL);
					else
						return new Fields .MFString ();
				})
				.bind (this),
				set: (function (value)
				{
					this .loadURL (value, new Fields .MFString ());
				})
				.bind (this),
				enumerable: true,
				configurable: false
			});

			// Configure browser event handlers.

			this .setBrowserEventHandler ("onload");
			this .setBrowserEventHandler ("onshutdown");
			this .setBrowserEventHandler ("onerror");

			this .getElement () .bind ("keydown.X3DCoreContext", this .keydown_X3DCoreContext .bind (this));
			this .getElement () .bind ("keyup.X3DCoreContext",   this .keyup_X3DCoreContext   .bind (this));
		},
		getDebug: function ()
		{
			return this .getBrowserOptions () .getDebug ();
		},
		getNumber: function ()
		{
			return this .number;
		},
		isStrict: function ()
		{
			return false;
		},
		getElement: function ()
		{
			return this .element;
		},
		getSurface: function ()
		{
			return this .surface;
		},
		getSplashScreen: function ()
		{
			return this .splashScreen;
		},
		getCanvas: function ()
		{
			return this .canvas;
		},
		getContext: function ()
		{
			return this .context;
		},
		getExtension: function (name)
		{
			return this .extensions [name];
		},
		getBrowserOptions: function ()
		{
			return this .browserOptions;
		},
		getBrowserProperties: function ()
		{
			return this .browserProperties;
		},
		getRenderingProperties: function ()
		{
			return this .renderingProperties;
		},
		getNotification: function ()
		{
			return this .notification;
		},
		getBrowserTimings: function ()
		{
			return this .browserTimings;
		},
		getLocalStorage: function ()
		{
			return this .localStorage;
		},
		getMobile: function ()
		{
			return this .mobile;
		},
		getPrivateScene: function ()
		{
			if (this .privateScene)
				return this .privateScene;

			// Scene for default nodes.

			this .privateScene = new Scene (this);

			this .privateScene .setPrivate (true);
			this .privateScene .setLive (true);
			this .privateScene .setup ();

			return this .privateScene;
		},
		processMutations: function (mutations)
		{
			mutations .forEach (function (mutation)
			{
				this .processMutation (mutation);
			},
			this);
		},
		processMutation: function (mutation)
		{
			var element = mutation .target;

			switch (mutation .type)
			{
				case "attributes":
				{
					this .processAttribute (mutation, element);
					break;
				}
			}
		},
		processAttribute: function (mutation, element)
		{
			var attributeName = mutation .attributeName;

			switch (attributeName .toLowerCase ())
			{
				case "onerror":
				{
					this .setBrowserEventHandler ("onerror");
					break;
				}
				case "onload":
				{
					this .setBrowserEventHandler ("onload");
					break;
				}
				case "onshutdown":
				{
					this .setBrowserEventHandler ("onshutdown");
					break;
				}
				case "splashscreen":
				{
					this .getBrowserOptions () .setAttributeSplashScreen ();
					break;
				}
				case "src":
				{
					var urlCharacters = this .getElement () .attr ("src");

					this .load ('"' + urlCharacters + '"');
					break;
				}
				case "url":
				{
					this .load (this .getElement () .attr ("url"));
					break;
				}
			}
		},
		load: function (urlCharacters)
		{
			if (urlCharacters)
			{
			   var
					parser    = new Parser (this .getExecutionContext ()),
					url       = new Fields .MFString (),
					parameter = new Fields .MFString ();

				parser .setInput (urlCharacters);
				parser .sfstringValues (url);

				if (url .length)
					this .loadURL (url, parameter);
			}
			else
			{
				if (! this .getLoading ())
					this .getCanvas () .fadeIn (0);
			}
		},
		setBrowserEventHandler: function (name)
		{
			var
				element      = this .getElement () .get (0),
				browserEvent = this .getElement () .attr (name);

			if (browserEvent)
				element [name] = new Function (browserEvent);
			else
				element [name] = Function .prototype;
		},
		callBrowserEventHandler: function (name)
		{
			var
				element             = this .getElement () .get (0),
				browserEventHandler = element [name];

			if (window .jQuery)
				window .jQuery (element) .trigger (name .substr (2));

			else if (browserEventHandler)
				browserEventHandler .call (element);
		},
		getShiftKey: function ()
		{
			return this .shiftKey_ .getValue ();
		},
		getControlKey: function ()
		{
			return this .controlKey_ .getValue ();
		},
		getAltKey: function ()
		{
			return this .altKey_ .getValue ();
		},
		getAltGrKey: function ()
		{
			return this .altGrKey_ .getValue ();
		},
		keydown_X3DCoreContext: function (event)
		{
			//console .log (event .keyCode);

			switch (event .keyCode)
			{
				case 16: // Shift
				{
					this .shiftKey_ = true;
					break;
				}
				case 17: // Ctrl
				{
					this .controlKey_ = true;
					break;
				}
				case 18: // Alt
				{
					this .altKey_ = true;
					break;
				}
				case 49: // 1
				{
					if (this .getDebug ())
					{
						if (this .getControlKey ())
						{
							event .preventDefault ();
							this .setBrowserOption ("Shading", "POINT");
							this .getNotification () .string_ = "Shading: Pointset";
						}
					}

					break;
				}
				case 50: // 2
				{
					if (this .getDebug ())
					{
						if (this .getControlKey ())
						{
							event .preventDefault ();
							this .setBrowserOption ("Shading", "WIREFRAME");
							this .getNotification () .string_ = "Shading: Wireframe";
						}
					}

					break;
				}
				case 51: // 3
				{
					if (this .getDebug ())
					{
						if (this .getControlKey ())
						{
							event .preventDefault ();
							this .setBrowserOption ("Shading", "FLAT");
							this .getNotification () .string_ = "Shading: Flat";
						}
					}

					break;
				}
				case 52: // 4
				{
					if (this .getDebug ())
					{
						if (this .getControlKey ())
						{
							event .preventDefault ();
							this .setBrowserOption ("Shading", "GOURAUD");
							this .getNotification () .string_ = "Shading: Gouraud";
						}
					}

					break;
				}
				case 53: // 5
				{
					if (this .getDebug ())
					{
						if (this .getControlKey ())
						{
							event .preventDefault ();
							this .setBrowserOption ("Shading", "PHONG");
							this .getNotification () .string_ = "Shading: Phong";
						}
					}

					break;
				}
				case 83: // s
				{
					if (this .getDebug ())
					{
						if (this .getControlKey ())
						{
							event .preventDefault ();

							if (this .isLive () .getValue ())
								this .endUpdate ();
							else
								this .beginUpdate ();

							this .getNotification () .string_ = this .isLive () .getValue () ? "Begin Update" : "End Update";
						}
					}

					break;
				}
				case 225: // Alt Gr
				{
					this .altGrKey_ = true;
					break;
				}
				case 171: // Plus // Firefox
				case 187: // Plus // Opera
				{
					if (this .getControlKey ())
					{
						event .preventDefault ();
						this .getBrowserTimings () .setEnabled (! this .getBrowserTimings () .getEnabled ());
					}

					break;
				}
				case 36: // Pos 1
				{
					event .preventDefault ();
					this .firstViewpoint ();
					break;
				}
				case 35: // End
				{
					event .preventDefault ();
					this .lastViewpoint ();
					break;
				}
				case 33: // Page Up
				{
					event .preventDefault ();
					this .previousViewpoint ();
					break;
				}
				case 34: // Page Down
				{
					event .preventDefault ();
					this .nextViewpoint ();
					break;
				}
				case 119: // F8
				{
					if (this .getShiftKey ())
					{
						event .preventDefault ();

						var viewpoint = this .getActiveViewpoint ();

						if (! viewpoint)
							break;

						var text = "";

						text += "Viewpoint {\n";
						text += "  position " + viewpoint .getUserPosition () .toString () + "\n";
						text += "  orientation " + viewpoint .getUserOrientation () .toString () + "\n";
						text += "  centerOfRotation " + viewpoint .getUserCenterOfRotation () .toString () + "\n";
						text += "}\n";

						console .log (text);

						this .copyToClipboard (text);
						this .getNotification () .string_ = "Copied viewpoint to clipboard.";
					}

					break;
				}
			}
		},
		keyup_X3DCoreContext: function (event)
		{
			//console .log (event .which);

			switch (event .which)
			{
				case 16: // Shift
				{
					this .shiftKey_ = false;
					break;
				}
				case 17: // Ctrl
				{
					this .controlKey_ = false;
					break;
				}
				case 18: // Alt
				{
					this .altKey_ = false;
					break;
				}
				case 225: // Alt Gr
				{
					this .altGrKey_ = false;
					break;
				}
			}
		},
		copyToClipboard: function (text)
		{
			var $temp = $("<input>");

			$("body") .append($temp);
			$temp .val (text) .select ();
			document .execCommand ("copy");
			$temp .remove ();
		},
	};

	return X3DCoreContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Routing/X3DRoutingContext',[
],
function ()
{
"use strict";

	function X3DRoutingContext ()
	{
		this .taintedFields     = [ ];
		this .taintedFieldsTemp = [ ];
		this .taintedNodes      = [ ];
		this .taintedNodesTemp  = [ ];
	}

	X3DRoutingContext .prototype =
	{
		constructor: X3DRoutingContext,
		initialize: function () { },
		addTaintedField: function (field, event)
		{
			this .taintedFields .push (field, event);
		},
		addTaintedNode: function (node)
		{
			this .taintedNodes .push (node);
		},
		processEvents: function ()
		{
			do
			{
				// Process field events
				do
				{
					var taintedFields = this .taintedFields;

					// Swap tainted fields.
					this .taintedFields         = this .taintedFieldsTemp;
					this .taintedFields .length = 0;

					for (var i = 0, length = taintedFields .length; i < length; i += 2)
						taintedFields [i] .processEvent (taintedFields [i + 1]);

					// Don't know why this must be done after the for loop, otherwise a fatal error could be thrown.
					this .taintedFieldsTemp = taintedFields;
				}
				while (this .taintedFields .length);

				// Process node events
				do
				{
					var taintedNodes = this .taintedNodes;

					// Swap tainted nodes.
					this .taintedNodes         = this .taintedNodesTemp;
					this .taintedNodes .length = 0;

					for (var i = 0, length = taintedNodes .length; i < length; ++ i)
						taintedNodes [i] .processEvents ();
					
					// Don't know why this must be done after the for loop, otherwise a fatal error could be thrown.
					this .taintedNodesTemp = taintedNodes;
				}
				while (! this .taintedFields .length && this .taintedNodes .length);
			}
			while (this .taintedFields .length);
		},
	};

	return X3DRoutingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Scripting/X3DScriptingContext',[
],
function ()
{
"use strict";

	function X3DScriptingContext ()
	{
		this .scripts = [ this ];
	}

	X3DScriptingContext .prototype =
	{
		initialize: function ()
		{
		},
		isExternal: function ()
		{
		   return this .scripts .length === 1;
		},
		getScriptStack: function ()
		{
			return this .scripts;
		}
	};

	return X3DScriptingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/

define ('x_ite/Browser/Networking/urls',[
	"standard/Networking/URI",
	"x_ite/DEBUG",
],
function (URI,
          DEBUG)
{
"use strict";

	function URLs ()
	{
		this .scriptUrl          = new URI (getScriptURL ())
		this .fallbackExpression = new RegExp ("^http://cors.create3000.de/");
	}

	URLs .prototype =
	{
		getProviderUrl: function (file)
		{
			if (file)
			{
				if (getScriptURL () .match (/\.min\.js$/))
					file += ".min";

				return this .scriptUrl .transform ("assets/components/" + file + ".js") .toString ();
			}

			return "https://github.com/create3000/x_ite/wiki";
		},
		getShaderUrl: function (file)
		{
			return this .scriptUrl .transform ("assets/shaders/" + file) .toString ();
		},
		getFontsUrl: function (file)
		{
			return this .scriptUrl .transform ("assets/fonts/" + file) .toString ();
		},
		getLinetypeUrl: function (index)
		{
			return this .scriptUrl .transform ("assets/linetype/" + index + ".png") .toString ();
		},
		getHatchingUrl: function (index)
		{
			return this .scriptUrl .transform ("assets/hatching/" + index + ".png") .toString ();
		},
		getFallbackUrl: function (url)
		{
			return "http://cors.create3000.de/?url=" + url;
		},
		getFallbackExpression: function ()
		{
			return this .fallbackExpression;
		},
	};

	return new URLs ();
});

/*! sprintf-js v1.1.2 | Copyright (c) 2007-present, Alexandru Mărășteanu <hello@alexei.ro> | BSD-3-Clause */
!function(){"use strict";var g={not_string:/[^s]/,not_bool:/[^t]/,not_type:/[^T]/,not_primitive:/[^v]/,number:/[diefg]/,numeric_arg:/[bcdiefguxX]/,json:/[j]/,not_json:/[^j]/,text:/^[^\x25]+/,modulo:/^\x25{2}/,placeholder:/^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,key:/^([a-z_][a-z_\d]*)/i,key_access:/^\.([a-z_][a-z_\d]*)/i,index_access:/^\[(\d+)\]/,sign:/^[+-]/};function y(e){return function(e,t){var r,n,i,s,a,o,p,c,l,u=1,f=e.length,d="";for(n=0;n<f;n++)if("string"==typeof e[n])d+=e[n];else if("object"==typeof e[n]){if((s=e[n]).keys)for(r=t[u],i=0;i<s.keys.length;i++){if(null==r)throw new Error(y('[sprintf] Cannot access property "%s" of undefined value "%s"',s.keys[i],s.keys[i-1]));r=r[s.keys[i]]}else r=s.param_no?t[s.param_no]:t[u++];if(g.not_type.test(s.type)&&g.not_primitive.test(s.type)&&r instanceof Function&&(r=r()),g.numeric_arg.test(s.type)&&"number"!=typeof r&&isNaN(r))throw new TypeError(y("[sprintf] expecting number but found %T",r));switch(g.number.test(s.type)&&(c=0<=r),s.type){case"b":r=parseInt(r,10).toString(2);break;case"c":r=String.fromCharCode(parseInt(r,10));break;case"d":case"i":r=parseInt(r,10);break;case"j":r=JSON.stringify(r,null,s.width?parseInt(s.width):0);break;case"e":r=s.precision?parseFloat(r).toExponential(s.precision):parseFloat(r).toExponential();break;case"f":r=s.precision?parseFloat(r).toFixed(s.precision):parseFloat(r);break;case"g":r=s.precision?String(Number(r.toPrecision(s.precision))):parseFloat(r);break;case"o":r=(parseInt(r,10)>>>0).toString(8);break;case"s":r=String(r),r=s.precision?r.substring(0,s.precision):r;break;case"t":r=String(!!r),r=s.precision?r.substring(0,s.precision):r;break;case"T":r=Object.prototype.toString.call(r).slice(8,-1).toLowerCase(),r=s.precision?r.substring(0,s.precision):r;break;case"u":r=parseInt(r,10)>>>0;break;case"v":r=r.valueOf(),r=s.precision?r.substring(0,s.precision):r;break;case"x":r=(parseInt(r,10)>>>0).toString(16);break;case"X":r=(parseInt(r,10)>>>0).toString(16).toUpperCase()}g.json.test(s.type)?d+=r:(!g.number.test(s.type)||c&&!s.sign?l="":(l=c?"+":"-",r=r.toString().replace(g.sign,"")),o=s.pad_char?"0"===s.pad_char?"0":s.pad_char.charAt(1):" ",p=s.width-(l+r).length,a=s.width&&0<p?o.repeat(p):"",d+=s.align?l+r+a:"0"===o?l+a+r:a+l+r)}return d}(function(e){if(p[e])return p[e];var t,r=e,n=[],i=0;for(;r;){if(null!==(t=g.text.exec(r)))n.push(t[0]);else if(null!==(t=g.modulo.exec(r)))n.push("%");else{if(null===(t=g.placeholder.exec(r)))throw new SyntaxError("[sprintf] unexpected placeholder");if(t[2]){i|=1;var s=[],a=t[2],o=[];if(null===(o=g.key.exec(a)))throw new SyntaxError("[sprintf] failed to parse named argument key");for(s.push(o[1]);""!==(a=a.substring(o[0].length));)if(null!==(o=g.key_access.exec(a)))s.push(o[1]);else{if(null===(o=g.index_access.exec(a)))throw new SyntaxError("[sprintf] failed to parse named argument key");s.push(o[1])}t[2]=s}else i|=2;if(3===i)throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");n.push({placeholder:t[0],param_no:t[1],keys:t[2],sign:t[3],pad_char:t[4],align:t[5],width:t[6],precision:t[7],type:t[8]})}r=r.substring(t[0].length)}return p[e]=n}(e),arguments)}function e(e,t){return y.apply(null,[e].concat(t||[]))}var p=Object.create(null);"undefined"!=typeof exports&&(exports.sprintf=y,exports.vsprintf=e),"undefined"!=typeof window&&(window.sprintf=y,window.vsprintf=e,"function"==typeof define&&define.amd&&define('sprintf/dist/sprintf.min',[],function(){return{sprintf:y,vsprintf:e}}))}();
//# sourceMappingURL=sprintf.min.js.map
;
define('sprintf', ['sprintf/dist/sprintf.min'], function (main) { return main; });

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Networking/X3DNetworkingContext',[
	"x_ite/Fields",
	"x_ite/Browser/Networking/urls",
	"standard/Networking/URI",
	"sprintf",
	"locale/gettext",
],
function (Fields,
          urls,
          URI,
          sprintf,
          _)
{
"use strict";

	function getBaseURI (element)
	{
		var baseURI = element .baseURI;

		// Fix for Edge.
		if (baseURI .startsWith ("about:"))
			baseURI = document .baseURI;

		return new URI (baseURI);
	}

	function X3DNetworkingContext ()
	{
		this .addChildObjects ("loadCount", new Fields .SFInt32 ());

		this .loadingTotal   = 0;
		this .loadingObjects = new Set ();
		this .loading        = false;
		this .location       = getBaseURI (this .getElement () [0]);

		this .getCanvas () .fadeOut (0);

		if (this .getBrowserOptions () .getSplashScreen ())
			this .getSplashScreen () .fadeIn (0);
	}

	X3DNetworkingContext .prototype =
	{
		initialize: function ()
		{ },
		getProviderUrl: function ()
		{
			return urls .getProviderUrl ();
		},
		getLocation: function ()
		{
			return this .location;
		},
		getDefaultScene: function ()
		{
			// Inline node's empty scene.

			if (this .defaultScene)
				return this .defaultScene;

			this .defaultScene = this .createScene ();

			this .defaultScene .setPrivate (true);
			this .defaultScene .setLive (true);
			this .defaultScene .setup ();

			return this .defaultScene;
		},
		setBrowserLoading: function (value)
		{
			this .loading = value;

			if (value)
			{
				this .resetLoadCount ();

				if (this .getBrowserOptions () .getSplashScreen ())
				{
					this .getCanvas ()       .stop (true, true) .animate ({ "delay": 1 }, 1) .fadeOut (0);
					this .getSplashScreen () .stop (true, true) .animate ({ "delay": 1 }, 1) .fadeIn (0);
				}
				else
				{
					this .getCanvas () .fadeOut (0);
				}
			}
			else
			{
				if (this .getBrowserOptions () .getSplashScreen ())
				{
					this .getSplashScreen () .stop (true, true) .fadeIn  (0) .fadeOut (2000);
					this .getCanvas ()       .stop (true, true) .fadeOut (0) .fadeIn  (2000);
				}
				else
				{
					this .getCanvas () .fadeIn (0);
				}
			}
		},
		getLoading: function ()
		{
			return this .loading;
		},
		addLoadCount: function (object)
		{
			if (this .loadingObjects .has (object))
				return;

			++ this .loadingTotal;

			this .loadingObjects .add (object);

			this .setLoadCount (this .loadingObjects .size);
			this .setCursor ("DEFAULT");
		},
		removeLoadCount: function (object)
		{
			if (! this .loadingObjects .has (object))
				return;

			this .loadingObjects .delete (object);

			this .setLoadCount (this .loadingObjects .size);
		},
		setLoadCount: function (value)
		{
			this .loadCount_ = value;

			if (value)
			{
				var string = sprintf .sprintf (value == 1 ? _ ("Loading %d file") : _ ("Loading %d files"), value);
			}
			else
			{
				var string = _("Loading done");
				this .setCursor ("DEFAULT");
			}

			if (! this .loading)
				this .getNotification () .string_ = string;

			this .getSplashScreen () .find (".x_ite-private-spinner-text") .text (string);
			this .getSplashScreen () .find (".x_ite-private-progressbar div") .css ("width", ((this .loadingTotal - value) * 100 / this .loadingTotal) + "%");
		},
		resetLoadCount: function ()
		{
			this .loadCount_   = 0;
			this .loadingTotal = 0;

			this .loadingObjects .clear ();
		},
	};

	return X3DNetworkingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/X3DAppearanceChildNode',[
	"x_ite/Components/Core/X3DNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DNode, 
          X3DConstants)
{
"use strict";

	function X3DAppearanceChildNode (executionContext)
	{
		X3DNode .call (this, executionContext);

		this .addType (X3DConstants .X3DAppearanceChildNode);
	}

	X3DAppearanceChildNode .prototype = Object .assign (Object .create (X3DNode .prototype),
	{
		constructor: X3DAppearanceChildNode,
	});

	return X3DAppearanceChildNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Bits/TraverseType',[],function ()
{
"use strict";

	var i = 0;

	var TraverseType =
	{
		POINTER:   i ++,
		CAMERA:    i ++,
		PICKING:   i ++,
		COLLISION: i ++,
		DEPTH:     i ++,
		DISPLAY:   i ++,
	};

	Object .preventExtensions (TraverseType);
	Object .freeze (TraverseType);
	Object .seal (TraverseType);

	return TraverseType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/X3DShaderNode',[
	"x_ite/Fields",
	"x_ite/Browser/Core/Shading",
	"x_ite/Components/Shape/X3DAppearanceChildNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Bits/TraverseType",
],
function (Fields,
          Shading,
          X3DAppearanceChildNode,
          X3DConstants,
          TraverseType)
{
"use strict";

	function X3DShaderNode (executionContext)
	{
		X3DAppearanceChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DShaderNode);

		this .addChildObjects ("activationTime", new Fields .SFTime ());

		this .valid    = false;
		this .selected = 0;
	}

	X3DShaderNode .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
	{
		constructor: X3DShaderNode,
		initialize: function ()
		{
			X3DAppearanceChildNode .prototype .initialize .call (this);

			this .activate_ .addInterest ("set_activate__", this);
		},
		set_activate__: function ()
		{
			this .activationTime_ = this .getBrowser () .getCurrentTime ();
		},
		custom: true,
		setCustom: function (value)
		{
			this .custom = value;
		},
		getCustom: function ()
		{
			return this .custom;
		},
		setValid: function (value)
		{
			this .isValid_ = this .valid = value;
		},
		getValid: function ()
		{
			return this .valid;
		},
		setShading: function (shading)
		{
			var gl = this .getBrowser () .getContext ();

			switch (shading)
			{
				case Shading .POINT:
				{
					this .primitiveMode = gl .POINTS;
					this .wireframe     = true;
					break;
				}
				case Shading .WIREFRAME:
				{
					this .primitiveMode = gl .LINE_LOOP;
					this .wireframe     = true;
					break;
				}
				default:
				{
					// case Shading .FLAT:
					// case Shading .GOURAUD:
					// case Shading .PHONG:

					this .primitiveMode = gl .TRIANGLES;
					this .wireframe     = false;
					break;
				}
			}
		},
		select: function ()
		{
			++ this .selected;

			if (! this .isSelected_ .getValue ())
				this .isSelected_ = true;
		},
		deselect: function ()
		{
			-- this .selected;

			if (this .selected === 0)
			{
				if (this .isSelected_ .getValue ())
					this .isSelected_ = false;
			}
		},
		traverse: function (type, renderObject)
		{
			if (type !== TraverseType .DISPLAY)
				return;

			renderObject .getShaders () .add (this);
		},
	});

	return X3DShaderNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DChildNode',[
	"x_ite/Fields",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DNode, 
          X3DConstants)
{
"use strict";

	function X3DChildNode (executionContext)
	{
		if (this .getExecutionContext ())
			return;

		X3DNode .call (this, executionContext);

		this .addType (X3DConstants .X3DChildNode);

		this .addChildObjects ("isCameraObject",   new Fields .SFBool ());
		this .addChildObjects ("isPickableObject", new Fields .SFBool ());

		this .isCameraObject_   .setAccessType (X3DConstants .outputOnly);
		this .isPickableObject_ .setAccessType (X3DConstants .outputOnly);
	}

	X3DChildNode .prototype = Object .assign (Object .create (X3DNode .prototype),
	{
		constructor: X3DChildNode,
		setCameraObject: function (value)
		{
			if (value !== this .isCameraObject_ .getValue ())
				this .isCameraObject_ = value;
		},
		getCameraObject: function ()
		{
			return this .isCameraObject_ .getValue ();
		},
		setPickableObject: function (value)
		{
			if (value !== this .isPickableObject_ .getValue ())
				this .isPickableObject_ = value;
		},
		getPickableObject: function ()
		{
			return this .isPickableObject_ .getValue ();
		},
	});

	return X3DChildNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DBindableNode',[
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DChildNode,
          X3DConstants)
{
"use strict";

	function X3DBindableNode (executionContext)
	{
		X3DChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DBindableNode);

		this .updateTime = 0;
	}

	X3DBindableNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: X3DBindableNode,
		initialize: function ()
		{
			X3DChildNode .prototype .initialize .call (this);

			this .set_bind_ .addInterest ("set_bind__", this);
		},
		getCameraObject: function ()
		{
		   return true;
		},
		transitionStart: function ()
		{ },
		set_bind__: function ()
		{
			if (this .set_bind_ .getValue () != this .isBound_ .getValue)
			{
				this .updateTime = performance .now () / 1000;
			}
		},
	});

	return X3DBindableNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DSensorNode',[
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DChildNode, 
          X3DConstants)
{
"use strict";

	function X3DSensorNode (executionContext)
	{
		X3DChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DSensorNode);
	}

	X3DSensorNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: X3DSensorNode,
	});

	return X3DSensorNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Time/X3DTimeDependentNode',[
	"x_ite/Fields",
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DChildNode,
          X3DConstants)
{
"use strict";

	function X3DTimeDependentNode (executionContext)
	{
		this .addType (X3DConstants .X3DTimeDependentNode);

		this .addChildObjects ("initialized", new Fields .SFTime (),
		                       "isEvenLive",  new Fields .SFBool ());

		this .startTimeValue  = 0;
		this .pauseTimeValue  = 0;
		this .resumeTimeValue = 0;
		this .stopTimeValue   = 0;
		this .start           = 0;
		this .pause           = 0;
		this .pauseInterval   = 0;
		this .startTimeout    = null;
		this .pauseTimeout    = null;
		this .resumeTimeout   = null;
		this .stopTimeout     = null;
		this .disabled        = false;
	}

	X3DTimeDependentNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: X3DTimeDependentNode,
		initialize: function ()
		{
			X3DChildNode .prototype .initialize .call (this);

			this .isLive ()   .addInterest ("set_live__", this);
			this .isEvenLive_ .addInterest ("_set_live__", this); // to X3DBaseNode

			this .initialized_ .addInterest ("set_loop__",       this);
			this .enabled_     .addInterest ("set_enabled__",    this);
			this .loop_        .addInterest ("set_loop__",       this);
			this .startTime_   .addInterest ("set_startTime__",  this);
			this .pauseTime_   .addInterest ("set_pauseTime__",  this);
			this .resumeTime_  .addInterest ("set_resumeTime__", this);
			this .stopTime_    .addInterest ("set_stopTime__",   this);

			this .startTimeValue  = this .startTime_  .getValue ();
			this .pauseTimeValue  = this .pauseTime_  .getValue ();
			this .resumeTimeValue = this .resumeTime_ .getValue ();
			this .stopTimeValue   = this .stopTime_   .getValue ();

			this .initialized_ = this .getBrowser () .getCurrentTime ();
		},
		getDisabled: function ()
		{
			return this .disabled;
		},
		getLiveState: function ()
		{
			///  Determines the live state of this node.

			return this .getLive () && (this .getExecutionContext () .isLive () .getValue () || this .isEvenLive_ .getValue ());
		},
		getElapsedTime: function ()
		{
			return this .getBrowser () .getCurrentTime () - this .start - this .pauseInterval;
		},
		resetElapsedTime: function ()
		{
			this .start         = this .getBrowser () .getCurrentTime ();
			this .pause         = this .getBrowser () .getCurrentTime ();
			this .pauseInterval = 0;
		},
		set_live__: function ()
		{
			if (this .isLive () .getValue ())
			{
				if (this .disabled)
				{
					this .disabled = false;

					if (this .isActive_ .getValue () && ! this .isPaused_ .getValue ())
						this .real_resume ();
				}
			}
			else
			{
				if (! this .disabled && this .isActive_ .getValue () && ! this .isPaused_ .getValue ())
				{
					// Only disable if needed, ie. if running!
					this .disabled = true;
					this .real_pause ();
				}
			}
		},
		set_enabled__: function ()
		{
			if (this .enabled_ .getValue ())
				this .set_loop__ ();

			else
				this .stop ();
		},
		set_loop__: function ()
		{
			if (this .enabled_ .getValue ())
			{
				if (this .loop_ .getValue ())
				{
					if (this .stopTimeValue <= this .startTimeValue)
					{
						if (this .startTimeValue <= this .getBrowser () .getCurrentTime ())
							this .do_start ();
					}
				}
			}
		},
		set_startTime__: function ()
		{
			this .startTimeValue = this .startTime_ .getValue ();

			if (this .enabled_ .getValue ())
			{
				this .removeTimeout ("startTimeout");

				if (this .startTimeValue <= this .getBrowser () .getCurrentTime ())
					this .do_start ();

				else
					this .addTimeout ("startTimeout", "do_start", this .startTimeValue);
			}
		},
		set_pauseTime__: function ()
		{
			this .pauseTimeValue = this .pauseTime_ .getValue ();

			if (this .enabled_ .getValue ())
			{
				this .removeTimeout ("pauseTimeout");

				if (this .pauseTimeValue <= this .resumeTimeValue)
					return;

				if (this .pauseTimeValue <= this .getBrowser () .getCurrentTime ())
					this .do_pause ();

				else
					this .addTimeout ("pauseTimeout", "do_pause", this .pauseTimeValue);
			}
		},
		set_resumeTime__: function ()
		{
			this .resumeTimeValue = this .resumeTime_ .getValue ();

			if (this .enabled_ .getValue ())
			{
				this .removeTimeout ("resumeTimeout");

				if (this .resumeTimeValue <= this .pauseTimeValue)
					return;

				if (this .resumeTimeValue <= this .getBrowser () .getCurrentTime ())
					this .do_resume ();

				else
					this .addTimeout ("resumeTimeout", "do_resume", this .resumeTimeValue);
			}
		},
		set_stopTime__: function ()
		{
			this .stopTimeValue = this .stopTime_ .getValue ();

			if (this .enabled_ .getValue ())
			{
				this .removeTimeout ("stopTimeout");

				if (this .stopTimeValue <= this .startTimeValue)
					return;

				if (this .stopTimeValue <= this .getBrowser () .getCurrentTime ())
					this .do_stop ();

				else
					this .addTimeout ("stopTimeout","do_stop", this .stopTimeValue);
			}
		},
		do_start: function ()
		{
			if (! this .isActive_ .getValue ())
			{
				this .resetElapsedTime ();

				// The event order below is very important.

				this .isActive_ = true;

				this .set_start ();

				if (this .isLive () .getValue ())
				{
					this .getBrowser () .timeEvents () .addInterest ("set_time" ,this);
				}
				else
				{
					this .disabled = true;
					this .real_pause ();
				}

				this .elapsedTime_ = 0;
			}
		},
		do_pause: function ()
		{
			if (this .isActive_ .getValue () && ! this .isPaused_ .getValue ())
			{
				this .isPaused_ = true;

				if (this .pauseTimeValue !== this .getBrowser () .getCurrentTime ())
					this .pauseTimeValue = this .getBrowser () .getCurrentTime ();

				if (this .isLive () .getValue ())
					this .real_pause ();
			}
		},
		real_pause: function ()
		{
			this .pause = performance .now ();

			this .set_pause ();

			this .getBrowser () .timeEvents () .removeInterest ("set_time" ,this);
		},
		do_resume: function ()
		{
			if (this .isActive_ .getValue () && this .isPaused_ .getValue ())
			{
				this .isPaused_ = false;

				if (this .resumeTimeValue !== this .getBrowser () .getCurrentTime ())
					this .resumeTimeValue = this .getBrowser () .getCurrentTime ();

				if (this .isLive () .getValue ())
					this .real_resume ();
			}
		},
		real_resume: function ()
		{
			var interval = (performance .now () - this .pause) / 1000;

			this .pauseInterval += interval;

			this .set_resume (interval);

			this .getBrowser () .timeEvents () .addInterest ("set_time" ,this);
			this .getBrowser () .addBrowserEvent ();
		},
		do_stop: function ()
		{
			this .stop ();
		},
		stop: function ()
		{
			if (this .isActive_ .getValue ())
			{
				// The event order below is very important.

				this .set_stop ();

				this .elapsedTime_ = this .getElapsedTime ();

				if (this .isPaused_ .getValue ())
					this .isPaused_ = false;

				this .isActive_ = false;

				if (this .isLive () .getValue ())
					this .getBrowser () .timeEvents () .removeInterest ("set_time" ,this);
			}
		},
		timeout: function (callback)
		{
			if (this .enabled_ .getValue ())
			{
				this .getBrowser () .advanceTime (performance .now ());

				this [callback] ();
			}
		},
		addTimeout: function (name, callback, time)
		{
			this .removeTimeout (name);
			this [name] = setTimeout (this .timeout .bind (this, callback), (time - this .getBrowser () .getCurrentTime ()) * 1000);
		},
		removeTimeout: function (name)
		{
			clearTimeout (this [name]);
			this [name] = null;
		},
		set_start: function () { },
		set_pause: function () { },
		set_resume: function () { },
		set_stop: function () { },
		set_time: function () { },
	});

	return X3DTimeDependentNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Time/TimeSensor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DSensorNode",
	"x_ite/Components/Time/X3DTimeDependentNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DSensorNode,
          X3DTimeDependentNode,
			 X3DConstants,
			 Algorithm)
{
"use strict";

	function TimeSensor (executionContext)
	{
		X3DSensorNode        .call (this, executionContext);
		X3DTimeDependentNode .call (this, executionContext);

		this .addType (X3DConstants .TimeSensor);

		this .addChildObjects ("range", new Fields .MFFloat (0, 0, 1)); // current, first, last (in fractions) - play range starting at current

		this .cycle    = 0;
		this .interval = 0;
		this .fraction = 0;
		this .first    = 0;
		this .last     = 1;
		this .scale    = 1;
	}

	TimeSensor .prototype = Object .assign (Object .create (X3DSensorNode .prototype),
		X3DTimeDependentNode .prototype,
	{
		constructor: TimeSensor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",          new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "cycleInterval",    new Fields .SFTime (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "loop",             new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "startTime",        new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "resumeTime",       new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "pauseTime",        new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "stopTime",         new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isPaused",         new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",         new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "cycleTime",        new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "elapsedTime",      new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "fraction_changed", new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "time",             new Fields .SFTime ()),
		]),
		getTypeName: function ()
		{
			return "TimeSensor";
		},
		getComponentName: function ()
		{
			return "Time";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DSensorNode        .prototype .initialize .call (this);
			X3DTimeDependentNode .prototype .initialize .call (this);

			this .cycleInterval_ .addInterest ("set_cycleInterval__", this);
			this .range_         .addInterest ("set_range__",         this);
		},
		setRange: function (currentFraction, firstFraction, lastFraction)
		{
			var
				currentTime   = this .getBrowser () .getCurrentTime (),
				startTime     = this .startTime_ .getValue (),
				cycleInterval = this .cycleInterval_ .getValue ();

			this .first    = firstFraction;
			this .last     = lastFraction;
			this .scale    = this .last - this .first;
			this .interval = cycleInterval * this .scale;
			this .fraction = Algorithm .fract ((currentFraction >= 1 ? 0 : currentFraction) + (this .interval ? (currentTime - startTime) / this .interval : 0));
			this .cycle    = currentTime - (this .fraction -  this .first) * cycleInterval;
		},
		set_cycleInterval__: function ()
		{
			if (this .isActive_ .getValue ())
				this .setRange (this .fraction, this .range_ [1], this .range_ [2]);
		},
		set_range__: function ()
		{
			if (this .isActive_ .getValue ())
			{
				this .setRange (this .range_ [0], this .range_ [1], this .range_ [2]);

				if (! this .isPaused_ .getValue ())
					this .set_fraction (this .getBrowser () .getCurrentTime ());
			}
		},
		set_start: function ()
		{
			this .setRange (this .range_ [0], this .range_ [1], this .range_ [2]);

			this .fraction_changed_ = this .fraction;
			this .time_             = this .getBrowser () .getCurrentTime ();
		},
		set_resume: function (pauseInterval)
		{
			var
				currentTime   = this .getBrowser () .getCurrentTime (),
				startTime     = this .startTime_ .getValue ();

			this .setRange (Algorithm .fract (this .fraction - (currentTime - startTime) / this .interval), this .range_ [1], this .range_ [2]);
		},
		set_fraction: function (time)
		{
			this .fraction_changed_ = this .fraction = this .first + Algorithm .fract ((time - this .cycle) / this .interval) * this .scale;
		},
		set_time: function ()
		{
			// The event order below is very important.

			var time = this .getBrowser () .getCurrentTime ();

			if (time - this .cycle >= this .interval)
			{
				if (this .loop_ .getValue ())
				{
					if (this .interval)
					{
						this .cycle += this .interval * Math .floor ((time - this .cycle) / this .interval);

						this .elapsedTime_ = this .getElapsedTime ();
						this .cycleTime_   = time;

						this .set_fraction (time);
					}
				}
				else
				{
					this .fraction_changed_ = this .fraction = this .last;
					this .stop ();
				}
			}
			else
			{
				this .elapsedTime_ = this .getElapsedTime ();

				this .set_fraction (time);
			}

			this .time_ = time;
		},
	});

	return TimeSensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/X3DInterpolatorNode',[
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (X3DChildNode, 
          X3DConstants,
          Algorithm)
{
"use strict";

	function X3DInterpolatorNode (executionContext)
	{
		X3DChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DInterpolatorNode);
	}

	X3DInterpolatorNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: X3DInterpolatorNode,
		setup: function ()
		{
			// If an X3DInterpolatorNode value_changed outputOnly field is read before it receives any inputs,
			// keyValue[0] is returned if keyValue is not empty. If keyValue is empty (i.e., [ ]), the initial
			// value for the respective field type is returned (EXAMPLE  (0, 0, 0) for Fields .SFVec3f);

			this .set_key__ ();

			if (this .key_ .length)
				this .interpolate (0, 0, 0);

			X3DChildNode .prototype .setup .call (this);
		},
		initialize: function ()
		{
			X3DChildNode .prototype .initialize .call (this);
			
			this .set_fraction_ .addInterest ("set_fraction__", this);
			this .key_          .addInterest ("set_key__", this);
		},
		set_fraction__: function ()
		{
			var
				key      = this .key_,
				length   = key .length,
				fraction = this .set_fraction_ .getValue ();

			switch (length)
			{
				case 0:
					// Interpolator nodes containing no keys in the key field shall not produce any events.
					return;
				case 1:
					return this .interpolate (0, 0, 0);
				default:
				{
					if (fraction <= key [0])
						return this .interpolate (0, 1, 0);

					var index1 = Algorithm .upperBound (key, 0, length, fraction, Algorithm .less);

					if (index1 !== length)
					{
						var
							index0 = index1 - 1,
							weight = (fraction - key [index0]) / (key [index1] - key [index0]);

						this .interpolate (index0, index1, Algorithm .clamp (weight, 0, 1));
					}
					else
						this .interpolate (length - 2, length - 1, 1);
				}
			}
		},
		set_key__: function ()
		{
			this .set_keyValue__ ();
		},
		set_keyValue__: function () { },
		interpolate: function () { },
	});

	return X3DInterpolatorNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/EaseInEaseOut',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          X3DConstants)
{
"use strict";

	function EaseInEaseOut (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .EaseInEaseOut);
	}

	EaseInEaseOut .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: EaseInEaseOut,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",                 new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",             new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",                      new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "easeInEaseOut",            new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "modifiedFraction_changed", new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "EaseInEaseOut";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);

			this .easeInEaseOut_ .addInterest ("set_keyValue__", this);
		},
		set_keyValue__: function ()
		{
			if (this .easeInEaseOut_ .length < this .key_ .length)
				this .easeInEaseOut_ .resize (this .key_ .length, this .easeInEaseOut_ .length ? this .easeInEaseOut_ [this .easeInEaseOut_ .length - 1] : new Fields .SFVec2f ());
		},
		interpolate: function (index0, index1, weight)
		{
			var
				easeOut = this .easeInEaseOut_ [index0] .y,
				easeIn  = this .easeInEaseOut_ [index1] .x,
				sum     = easeOut + easeIn;

			if (sum < 0)
			{
				this .modifiedFraction_changed_ = weight;
			}
			else
			{
				if (sum > 1)
				{
					easeIn  /= sum;
					easeOut /= sum;
				}

				var t = 1 / (2 - easeOut - easeIn);

				if (weight < easeOut)
				{
					this .modifiedFraction_changed_ = (t / easeOut) * weight * weight;
				}
				else if (weight <= 1 - easeIn) // Spec says (weight < 1 - easeIn), but then we get a NaN below if easeIn == 0.
				{
					this .modifiedFraction_changed_ = t * (2 * weight - easeOut);
				}
				else
				{
					var w = 1 - weight;

					this .modifiedFraction_changed_ = 1 - ((t * w * w) / easeIn);
				}
			}
		},
	});

	return EaseInEaseOut;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/PositionInterpolator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          X3DConstants,
          Vector3)
{
"use strict";

	function PositionInterpolator (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .PositionInterpolator);
	}

	PositionInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: PositionInterpolator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "PositionInterpolator";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);

			this .keyValue_ .addInterest ("set_keyValue__", this);
		},
		set_keyValue__: function ()
		{
			var
				key      = this .key_,
				keyValue = this .keyValue_;

			if (keyValue .length < key .length)
				keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFVec3f ());
		},
		interpolate: (function ()
		{
			var keyValue = new Vector3 (0, 0, 0);

			return function (index0, index1, weight)
			{
				this .value_changed_ = keyValue .assign (this .keyValue_ [index0] .getValue ()) .lerp (this .keyValue_ [index1] .getValue (), weight);
			};
		})(),
	});

	return PositionInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/OrientationInterpolator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Rotation4"
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          X3DConstants,
          Rotation4)
{
"use strict";

	function OrientationInterpolator (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .OrientationInterpolator);
	}

	OrientationInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: OrientationInterpolator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFRotation ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFRotation ()),
		]),
		getTypeName: function ()
		{
			return "OrientationInterpolator";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);

			this .keyValue_ .addInterest ("set_keyValue__", this);
		},
		set_keyValue__: function ()
		{
			var
				key      = this .key_,
				keyValue = this .keyValue_;

			if (keyValue .length < key .length)
				keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFRotation ());
		},
		interpolate: (function ()
		{
			var
				keyValue0 = new Rotation4 (0, 0, 1, 0),
				keyValue1 = new Rotation4 (0, 0, 1, 0);

			return function (index0, index1, weight)
			{
				try
				{
					keyValue0 .assign (this .keyValue_ [index0] .getValue ());
					keyValue1 .assign (this .keyValue_ [index1] .getValue ());

					this .value_changed_ = keyValue0 .slerp (keyValue1, weight);

				}
				catch (error)
				{
					console .log (error);
				}
			};
		}) (),
	});

	return OrientationInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/X3DViewpointNode',[
	"x_ite/Fields",
	"x_ite/Components/Core/X3DBindableNode",
	"x_ite/Components/Time/TimeSensor",
	"x_ite/Components/Interpolation/EaseInEaseOut",
	"x_ite/Components/Interpolation/PositionInterpolator",
	"x_ite/Components/Interpolation/OrientationInterpolator",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DBindableNode,
          TimeSensor,
          EaseInEaseOut,
          PositionInterpolator,
          OrientationInterpolator,
          TraverseType,
          X3DConstants,
          Vector2,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

	function X3DViewpointNode (executionContext)
	{
		X3DBindableNode .call (this, executionContext);

		this .addType (X3DConstants .X3DViewpointNode);

		this .addChildObjects ("positionOffset",         new Fields .SFVec3f (),
		                       "orientationOffset",      new Fields .SFRotation (),
		                       "scaleOffset",            new Fields .SFVec3f (1, 1, 1),
		                       "scaleOrientationOffset", new Fields .SFRotation (),
		                       "centerOfRotationOffset", new Fields .SFVec3f (),
		                       "fieldOfViewScale",       new Fields .SFFloat (1));

	   this .userPosition         = new Vector3 (0, 1, 0);
	   this .userOrientation      = new Rotation4 (0, 0, 1, 0);
	   this .userCenterOfRotation = new Vector3 (0, 0, 0);
		this .modelMatrix          = new Matrix4 ();
		this .cameraSpaceMatrix    = new Matrix4 (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0,  10, 1);
		this .viewMatrix           = new Matrix4 (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -10, 1);

		var browser = this .getBrowser ();

		this .timeSensor                   = new TimeSensor              (browser .getPrivateScene ());
		this .easeInEaseOut                = new EaseInEaseOut           (browser .getPrivateScene ());
		this .positionInterpolator         = new PositionInterpolator    (browser .getPrivateScene ());
		this .orientationInterpolator      = new OrientationInterpolator (browser .getPrivateScene ());
		this .scaleInterpolator            = new PositionInterpolator    (browser .getPrivateScene ());
		this .scaleOrientationInterpolator = new OrientationInterpolator (browser .getPrivateScene ());
	}

	X3DViewpointNode .prototype = Object .assign (Object .create (X3DBindableNode .prototype),
	{
		constructor: X3DViewpointNode,
		initialize: function ()
		{
			X3DBindableNode .prototype .initialize .call (this);

			this .timeSensor .stopTime_ = 1;
			this .timeSensor .setup ();

			this .easeInEaseOut .key_           = new Fields .MFFloat (0, 1);
			this .easeInEaseOut .easeInEaseOut_ = new Fields .MFVec2f (new Fields .SFVec2f (0, 0), new Fields .SFVec2f (0, 0));
			this .easeInEaseOut .setup ();

			this .positionInterpolator         .key_ = new Fields .MFFloat (0, 1);
			this .orientationInterpolator      .key_ = new Fields .MFFloat (0, 1);
			this .scaleInterpolator            .key_ = new Fields .MFFloat (0, 1);
			this .scaleOrientationInterpolator .key_ = new Fields .MFFloat (0, 1);

			this .positionInterpolator         .setup ();
			this .orientationInterpolator      .setup ();
			this .scaleInterpolator            .setup ();
			this .scaleOrientationInterpolator .setup ();

			this .timeSensor .fraction_changed_ .addFieldInterest (this .easeInEaseOut .set_fraction_);

			this .easeInEaseOut .modifiedFraction_changed_ .addFieldInterest (this .positionInterpolator         .set_fraction_);
			this .easeInEaseOut .modifiedFraction_changed_ .addFieldInterest (this .orientationInterpolator      .set_fraction_);
			this .easeInEaseOut .modifiedFraction_changed_ .addFieldInterest (this .scaleInterpolator            .set_fraction_);
			this .easeInEaseOut .modifiedFraction_changed_ .addFieldInterest (this .scaleOrientationInterpolator .set_fraction_);

			this .positionInterpolator         .value_changed_ .addFieldInterest (this .positionOffset_);
			this .orientationInterpolator      .value_changed_ .addFieldInterest (this .orientationOffset_);
			this .scaleInterpolator            .value_changed_ .addFieldInterest (this .scaleOffset_);
			this .scaleOrientationInterpolator .value_changed_ .addFieldInterest (this .scaleOrientationOffset_);

			this .isBound_ .addInterest ("set_bound__", this);
		},
		getEaseInEaseOut: function ()
		{
			return this .easeInEaseOut;
		},
		setInterpolators: function () { },
		getPosition: function ()
		{
			return this .position_ .getValue ();
		},
		getUserPosition: function ()
		{
			return this .userPosition .assign (this .getPosition ()) .add (this .positionOffset_ .getValue ());
		},
		getOrientation: function ()
		{
			return this .orientation_ .getValue ();
		},
		getUserOrientation: function ()
		{
			return this .userOrientation .assign (this .getOrientation ()) .multRight (this .orientationOffset_ .getValue ());
		},
		getCenterOfRotation: function ()
		{
			return this .centerOfRotation_ .getValue ();
		},
		getUserCenterOfRotation: function ()
		{
			return this .userCenterOfRotation .assign (this .getCenterOfRotation ()) .add (this .centerOfRotationOffset_ .getValue ());
		},
		getProjectionMatrix: function (renderObject)
		{
			var navigationInfo = renderObject .getNavigationInfo ();

			return this .getProjectionMatrixWithLimits (navigationInfo .getNearValue (),
                                                     navigationInfo .getFarValue (this),
                                                     renderObject .getLayer () .getViewport () .getRectangle (renderObject .getBrowser ()));
		},
		getCameraSpaceMatrix: function ()
		{
			return this .cameraSpaceMatrix;
		},
		getViewMatrix: function ()
		{
			return this .viewMatrix;
		},
		getModelMatrix: function ()
		{
			return this .modelMatrix;
		},
		getMaxFarValue: function ()
		{
			return this .getBrowser () .getRenderingProperty ("LogarithmicDepthBuffer") ? 1e10 : 1e5;
		},
		getUpVector: function ()
		{
		   // Local y-axis,
		   // see http://www.web3d.org/documents/specifications/19775-1/V3.3/index.html#NavigationInfo.
		   return Vector3 .yAxis;
		},
		getSpeedFactor: function ()
		{
			return 1;
		},
		setAnimate: function (value)
		{
			// VRML behaviour support.
			this .animate = value;
		},
		getAnimate: function ()
		{
			// VRML behaviour support.
			return this .animate;
		},
		transitionStart: (function ()
		{
			var
				relativePosition         = new Vector3 (0, 0, 0),
				relativeOrientation      = new Rotation4 (0, 0, 1, 0),
				relativeScale            = new Vector3 (0, 0, 0),
				relativeScaleOrientation = new Rotation4 (0, 0, 1, 0);

			return function (layer, fromViewpoint)
			{
				try
				{
					if (this .jump_ .getValue ())
					{
						var layers = this .getLayers ();

						if (! this .retainUserOffsets_ .getValue ())
							this .resetUserOffsets ();

						for (var i = 0; i < layers .length; ++ i)
						{
							var navigationInfo = layers [i] .getNavigationInfo ();

							navigationInfo .transitionStart_ = true;

							var
								transitionType = navigationInfo .getTransitionType (),
								transitionTime = navigationInfo .transitionTime_ .getValue ();
						}

						// VRML behaviour

						if (this .getExecutionContext () .getSpecificationVersion () == "2.0")
						{
							if (this .getAnimate ())
								transitionType = "LINEAR";
							else
								transitionType = "TELEPORT";
						}

						this .setAnimate (false); // VRML

						// End VRML behaviour

						switch (transitionType)
						{
							case "TELEPORT":
							{
								for (var i = 0; i < layers .length; ++ i)
									layers [i] .getNavigationInfo () .transitionComplete_ = true;

								return;
							}
							case "ANIMATE":
							{
								this .easeInEaseOut .easeInEaseOut_ = new Fields .MFVec2f (new Fields .SFVec2f (0, 1), new Fields .SFVec2f (1, 0));
								break;
							}
							default:
							{
								// LINEAR
								this .easeInEaseOut .easeInEaseOut_ = new Fields .MFVec2f (new Fields .SFVec2f (0, 0), new Fields .SFVec2f (0, 0));
								break;
							}
						}

						this .timeSensor .cycleInterval_ = transitionTime;
						this .timeSensor .stopTime_      = this .getBrowser () .getCurrentTime ();
						this .timeSensor .startTime_     = this .getBrowser () .getCurrentTime ();
						this .timeSensor .isActive_ .addInterest ("set_active__", this);

						this .getRelativeTransformation (fromViewpoint, relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation);

						this .positionInterpolator         .keyValue_ = new Fields .MFVec3f    (relativePosition,         this .positionOffset_);
						this .orientationInterpolator      .keyValue_ = new Fields .MFRotation (relativeOrientation,      this .orientationOffset_);
						this .scaleInterpolator            .keyValue_ = new Fields .MFVec3f    (relativeScale,            this .scaleOffset_);
						this .scaleOrientationInterpolator .keyValue_ = new Fields .MFRotation (relativeScaleOrientation, this .scaleOrientationOffset_);

						this .positionOffset_         = relativePosition;
						this .orientationOffset_      = relativeOrientation;
						this .scaleOffset_            = relativeScale;
						this .scaleOrientationOffset_ = relativeScaleOrientation;

						this .setInterpolators (fromViewpoint);
					}
					else
					{
						this .getRelativeTransformation (fromViewpoint, relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation);

						this .positionOffset_         = relativePosition;
						this .orientationOffset_      = relativeOrientation;
						this .scaleOffset_            = relativeScale;
						this .scaleOrientationOffset_ = relativeScaleOrientation;

						this .setInterpolators (fromViewpoint);
					}
				}
				catch (error)
				{
					console .log (error);
				}
			};
		})(),
		transitionStop: function ()
		{
			this .timeSensor .stopTime_ = this .getBrowser () .getCurrentTime ();
			this .timeSensor .isActive_ .removeInterest ("set_active__", this);
		},
		resetUserOffsets: function ()
		{
			this .positionOffset_         = Vector3   .Zero;
			this .orientationOffset_      = Rotation4 .Identity;
			this .scaleOffset_            = Vector3   .One;
			this .scaleOrientationOffset_ = Rotation4 .Identity;
			this .centerOfRotationOffset_ = Vector3   .Zero;
			this .fieldOfViewScale_       = 1;
		},
		getRelativeTransformation: function (fromViewpoint, relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation)
		// throw
		{
			var differenceMatrix = this .modelMatrix .copy () .multRight (fromViewpoint .getViewMatrix ()) .inverse ();

			differenceMatrix .get (relativePosition, relativeOrientation, relativeScale, relativeScaleOrientation);

			relativePosition .subtract (this .getPosition ());
			relativeOrientation .assign (this .getOrientation () .copy () .inverse () .multRight (relativeOrientation));
		},
		lookAtPoint: function (point, factor, straighten)
		{
			try
			{
				if (! this .getBrowser () .getActiveLayer ())
					return;

				this .getCameraSpaceMatrix () .multVecMatrix (point);

				Matrix4 .inverse (this .getModelMatrix ()) .multVecMatrix (point);

				var minDistance = this .getBrowser () .getActiveLayer () .getNavigationInfo () .getNearValue () * 2;

				this .lookAt (point, minDistance, factor, straighten);
			}
			catch (error)
			{
				console .error (error);
			}
		},
		lookAtBBox: function (bbox, factor, straighten)
		{
			try
			{
				if (! this .getBrowser () .getActiveLayer ())
					return;

				bbox = bbox .copy () .multRight (Matrix4 .inverse (this .getModelMatrix ()));

				var minDistance = this .getBrowser () .getActiveLayer () .getNavigationInfo () .getNearValue () * 2;

				this .lookAt (bbox .center, minDistance, factor, straighten);
			}
			catch (error)
			{ }
		},
		lookAt: function (point, distance, factor, straighten)
		{
			var
				layers = this .getLayers (),
				offset = point .copy () .add (this .getUserOrientation () .multVecRot (new Vector3 (0, 0, distance))) .subtract (this .getPosition ());

			layers .forEach (function (layer)
			{
				layer .getNavigationInfo () .transitionStart_ = true;
			});

			this .timeSensor .cycleInterval_ = 0.2;
			this .timeSensor .stopTime_      = this .getBrowser () .getCurrentTime ();
			this .timeSensor .startTime_     = this .getBrowser () .getCurrentTime ();
			this .timeSensor .isActive_ .addInterest ("set_active__", this);

			this .easeInEaseOut .easeInEaseOut_ = new Fields .MFVec2f (new Fields .SFVec2f (0, 1), new Fields .SFVec2f (1, 0));

			var
				translation = Vector3 .lerp (this .positionOffset_ .getValue (), offset, factor),
				direction   = Vector3 .add (this .getPosition (), translation) .subtract (point),
				rotation    = Rotation4 .multRight (this .orientationOffset_ .getValue (), new Rotation4 (this .getUserOrientation () .multVecRot (new Vector3 (0, 0, 1)), direction));

			if (straighten)
				rotation = Rotation4 .inverse (this .getOrientation ()) .multRight (this .straightenHorizon (Rotation4 .multRight (this .getOrientation (), rotation)));

			this .positionInterpolator         .keyValue_ = new Fields .MFVec3f (this .positionOffset_, translation);
			this .orientationInterpolator      .keyValue_ = new Fields .MFRotation (this .orientationOffset_, rotation);
			this .scaleInterpolator            .keyValue_ = new Fields .MFVec3f (this .scaleOffset_, this .scaleOffset_);
			this .scaleOrientationInterpolator .keyValue_ = new Fields .MFRotation (this .scaleOrientationOffset_, this .scaleOrientationOffset_);

			this .setInterpolators (this);

			this .centerOfRotationOffset_ = Vector3 .subtract (point, this .getCenterOfRotation ());
			this .set_bind_               = true;
		},
		straighten: function (horizon)
		{
			var layers = this .getLayers ();

			layers .forEach (function (layer)
			{
				layer .getNavigationInfo () .transitionStart_ = true;
			});

			this .timeSensor .cycleInterval_ = 0.4;
			this .timeSensor .stopTime_      = this .getBrowser () .getCurrentTime ();
			this .timeSensor .startTime_     = this .getBrowser () .getCurrentTime ();
			this .timeSensor .isActive_ .addInterest ("set_active__", this);

			this .easeInEaseOut .easeInEaseOut_ = new Fields .MFVec2f (new Fields .SFVec2f (0, 1), new Fields .SFVec2f (1, 0));

			var rotation = Rotation4 .multRight (Rotation4 .inverse (this .getOrientation ()), this .straightenHorizon (this .getUserOrientation ()));

			this .positionInterpolator         .keyValue_ = new Fields .MFVec3f (this .positionOffset_, this .positionOffset_);
			this .orientationInterpolator      .keyValue_ = new Fields .MFRotation (this .orientationOffset_, rotation);
			this .scaleInterpolator            .keyValue_ = new Fields .MFVec3f (this .scaleOffset_, this .scaleOffset_);
			this .scaleOrientationInterpolator .keyValue_ = new Fields .MFRotation (this .scaleOrientationOffset_, this .scaleOrientationOffset_);

			this .setInterpolators (this);

			this .set_bind_ = true;
		},
		straightenHorizon: (function ()
		{
			var
				localXAxis  = new Vector3 (0, 0, 0),
				localZAxis  = new Vector3 (0, 0, 0),
				rotation    = new Rotation4 (0, 0, 1, 0);

			return function (orientation)
			{
				orientation .multVecRot (localXAxis .assign (Vector3 .xAxis) .negate ());
				orientation .multVecRot (localZAxis .assign (Vector3 .zAxis));

				var upVector = this .getUpVector ();
				var vector   = localZAxis .cross (upVector);

				// If viewer looks along the up vector.
				if (Math .abs (localZAxis .dot (upVector)) >= 1)
					return orientation;

				if (Math .abs (vector .dot (localXAxis)) >= 1)
					return orientation;

				rotation .setFromToVec (localXAxis, vector);

				return orientation .multRight (rotation);
			};
		})(),
		set_active__: function (active)
		{
			if (! active .getValue () && this .timeSensor .fraction_changed_ .getValue () === 1)
			{
				var layers = this .getLayers ();

				for (var i = 0; i < layers .length; ++ i)
				{
					layers [i] .getNavigationInfo () .transitionComplete_ = true;
				}

				this .easeInEaseOut .set_fraction_ = 1;
			}
		},
		set_bound__: function ()
		{
			if (this .isBound_ .getValue ())
				this .getBrowser () .getNotification () .string_ = this .description_;
			else
				this .timeSensor .stopTime_ = this .getBrowser () .getCurrentTime ();
		},
		traverse: function (type, renderObject)
		{
			renderObject .getLayer () .getViewpoints () .push (this);

			this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
		},
		update: function ()
		{
			try
			{
				this .cameraSpaceMatrix .set (this .getUserPosition (),
														this .getUserOrientation (),
														this .scaleOffset_ .getValue (),
														this .scaleOrientationOffset_ .getValue ());

				this .cameraSpaceMatrix .multRight (this .modelMatrix);

				this .viewMatrix .assign (this .cameraSpaceMatrix) .inverse ();
			}
			catch (error)
			{
				console .log (error);
			}
		}
	});

	return X3DViewpointNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/ScalarInterpolator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          X3DConstants,
          Algorithm)
{
"use strict";

	function ScalarInterpolator (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .ScalarInterpolator);
	}

	ScalarInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: ScalarInterpolator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "ScalarInterpolator";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);

			this .keyValue_ .addInterest ("set_keyValue__", this);
		},
		set_keyValue__: function ()
		{
			var
				key      = this .key_,
				keyValue = this .keyValue_;

			if (keyValue .length < key .length)
				keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : 0);
		},
		interpolate: function (index0, index1, weight)
		{
			this .value_changed_ = Algorithm .lerp (this .keyValue_ [index0], this .keyValue_ [index1], weight);
		},
	});

	return ScalarInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Camera',[
	"standard/Math/Numbers/Vector3",
],
function (Vector3)
{
"use strict";

	return {
		frustum: function (l, r, b, t, n, f, matrix)
		{
			var
				r_l = r - l,
				t_b = t - b,
				f_n = f - n,
				n_2 = 2 * n,

				A = (r + l) / r_l,
				B = (t + b) / t_b,
				C = -(f + n) / f_n,
				D = -(n_2 * f) / f_n,
				E = n_2 / r_l,
				F = n_2 / t_b;

			return matrix .set (E, 0, 0, 0,
			                    0, F, 0, 0,
			                    A, B, C, -1,
									  0, 0, D, 0);
		},
		perspective: function (fieldOfView, zNear, zFar, width, height, matrix)
		{
			var ratio = Math .tan (fieldOfView / 2) * zNear;

			if (width > height)
			{
				var aspect = width * ratio / height;
				return this .frustum (-aspect, aspect, -ratio, ratio, zNear, zFar, matrix);
			}
			else
			{
				var aspect = height * ratio / width;
				return this .frustum (-ratio, ratio, -aspect, aspect, zNear, zFar, matrix);
			}
		},
		perspective2: function (fieldOfView, zNear, zFar, width, height, matrix)
		{
			var ratio = Math .tan (fieldOfView / 2) * zNear;

			return this .frustum (-ratio, ratio, -ratio, ratio, zNear, zFar, matrix);
		},
		ortho: function (l, r, b, t, n, f, matrix)
		{
			var
				r_l = r - l,
				t_b = t - b,
				f_n = f - n,

				A =  2 / r_l,
				B =  2 / t_b,
				C = -2 / f_n,
				D = -(r + l) / r_l,
				E = -(t + b) / t_b,
				F = -(f + n) / f_n;

			return matrix .set (A, 0, 0, 0,
			                    0, B, 0, 0,
			                    0, 0, C, 0,
			                    D, E, F, 1);
		},
		orthoBox: (function ()
		{
			var
				min = new Vector3 (0, 0, 0),
				max = new Vector3 (0, 0, 0);

			return function (box, matrix)
			{
				box .getExtents (min, max);

				return this .ortho (min .x, max .x, min .y, max .y, -max .z, -min .z, matrix);
			};
		})(),
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/OrthoViewpoint',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Navigation/X3DViewpointNode",
	"x_ite/Components/Interpolation/ScalarInterpolator",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Camera",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DViewpointNode,
          ScalarInterpolator,
          X3DConstants,
          Camera,
          Vector2,
          Vector3,
          Matrix4)
{
"use strict";

	function OrthoViewpoint (executionContext)
	{
		X3DViewpointNode .call (this, executionContext);

		this .addType (X3DConstants .OrthoViewpoint);

		this .position_         .setUnit ("length");
		this .centerOfRotation_ .setUnit ("length");
		this .fieldOfView_      .setUnit ("length");

		this .projectionMatrix        = new Matrix4 ();
		this .fieldOfViewInterpolator = new ScalarInterpolator (this .getBrowser () .getPrivateScene ());
	}

	OrthoViewpoint .prototype = Object .assign (Object .create (X3DViewpointNode .prototype),
	{
		constructor: OrthoViewpoint,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",          new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "description",       new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "position",          new Fields .SFVec3f (0, 0, 10)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "orientation",       new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "centerOfRotation",  new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "fieldOfView",       new Fields .MFFloat (-1, -1, 1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "jump",              new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "retainUserOffsets", new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",          new Fields .SFTime ()),
		]),
		getTypeName: function ()
		{
			return "OrthoViewpoint";
		},
		getComponentName: function ()
		{
			return "Navigation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DViewpointNode .prototype .initialize .call (this);

			this .fieldOfView_      .addInterest ("set_fieldOfView___", this);
			this .fieldOfViewScale_ .addInterest ("set_fieldOfView___", this);

			this .fieldOfViewInterpolator .key_ = new Fields .MFFloat (0, 1);
			this .fieldOfViewInterpolator .setup ();

			this .getEaseInEaseOut () .modifiedFraction_changed_ .addFieldInterest (this .fieldOfViewInterpolator .set_fraction_);
			this .fieldOfViewInterpolator .value_changed_ .addFieldInterest (this .fieldOfViewScale_);

			this .set_fieldOfView___ ();
		},
		set_fieldOfView___: function ()
		{
			var
				length           = this .fieldOfView_ .length,
				fieldOfViewScale = this .fieldOfViewScale_ .getValue ();

			this .minimumX = (length > 0 ? this .fieldOfView_ [0] : -1) * fieldOfViewScale;
			this .minimumY = (length > 1 ? this .fieldOfView_ [1] : -1) * fieldOfViewScale;
			this .maximumX = (length > 2 ? this .fieldOfView_ [2] :  1) * fieldOfViewScale;
			this .maximumY = (length > 3 ? this .fieldOfView_ [3] :  1) * fieldOfViewScale;

			this .sizeX = this .maximumX - this .minimumX;
			this .sizeY = this .maximumY - this .minimumY;
		},
		transitionStart: function (fromViewpoint)
		{
			this .fromFieldOfViewScale = fromViewpoint .fieldOfViewScale_ .getValue ();

			X3DViewpointNode .prototype .transitionStart .call (this, fromViewpoint);
		},
		setInterpolators: function (fromViewpoint)
		{
			if (fromViewpoint .getType () .indexOf (X3DConstants .OrthoViewpoint) < 0)
			{
				this .fieldOfViewInterpolator .keyValue_ = new Fields .MFFloat (this .fieldOfViewScale_ .getValue (), this .fieldOfViewScale_ .getValue ());
			}
			else
			{
				this .fieldOfViewInterpolator .keyValue_ = new Fields .MFFloat (this .fromFieldOfViewScale, this .fieldOfViewScale_ .getValue ());

				this .fieldOfViewScale_ = this .fromFieldOfViewScale;
			}
		},
		getMinimumX: function ()
		{
			return this .minimumX;
		},
		getMinimumY: function ()
		{
			return this .minimumY;
		},
		getMaximumX: function ()
		{
			return this .maximumX;
		},
		getMaximumY: function ()
		{
			return this .maximumY;
		},
		getSizeX: function ()
		{
			return this .sizeX;
		},
		getSizeY: function ()
		{
			return this .sizeY;
		},
		getMaxFarValue: function ()
		{
			return 1e5;
		},
		getScreenScale: (function ()
		{
			var screenScale = new Vector3 (0, 0, 0);

			return function (point, viewport)
			{
				var
					width  = viewport [2],
					height = viewport [3],
					sizeX  = this .sizeX,
					sizeY  = this .sizeY,
					aspect = width / height;

				if (aspect > sizeX / sizeY)
				{
					var s = sizeY / height;

					return screenScale .set (s, s, s);
				}

				var s = sizeX / width;

				return screenScale .set (s, s, s);
			};
		})(),
		getViewportSize: (function ()
		{
			var viewportSize = new Vector2 (0, 0);

			return function (viewport, nearValue)
			{
				var
					width  = viewport [2],
					height = viewport [3],
					sizeX  = this .sizeX,
					sizeY  = this .sizeY,
					aspect = width / height;

				if (aspect > sizeX / sizeY)
					return viewportSize .set (sizeY * aspect, sizeY);

				return viewportSize .set (sizeX, sizeX / aspect);
			};
		})(),
		getLookAtDistance: function (bbox)
		{
			return bbox .size .abs () / 2 + 10;
		},
		getProjectionMatrixWithLimits: function (nearValue, farValue, viewport)
		{
			var
				width  = viewport [2],
				height = viewport [3],
				aspect = width / height,
				sizeX  = this .sizeX,
				sizeY  = this .sizeY;

			if (aspect > sizeX / sizeY)
			{
				var
					center  = (this .minimumX + this .maximumX) / 2,
					size1_2 = (sizeY * aspect) / 2;

				return Camera .ortho (center - size1_2, center + size1_2, this .minimumY, this .maximumY, nearValue, farValue, this .projectionMatrix);
			}

			var
				center  = (this .minimumY + this .maximumY) / 2,
				size1_2 = (sizeX / aspect) / 2;

			return Camera .ortho (this .minimumX, this .maximumX, center - size1_2, center + size1_2, nearValue, farValue, this .projectionMatrix);
		},
	});

	return OrthoViewpoint;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/X3DProgrammableShaderObject',[
	"x_ite/Fields",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
	"x_ite/Components/Navigation/OrthoViewpoint",
	"standard/Math/Numbers/Matrix3",
],
function (Fields,
          X3DCast,
          X3DConstants,
          OrthoViewpoint,
          Matrix3)
{
"use strict";

	function X3DProgrammableShaderObject (executionContext)
	{
		this .addType (X3DConstants .X3DProgrammableShaderObject);

		this .x3d_ClipPlane                           = [ ];
		this .x3d_LightType                           = [ ];
		this .x3d_LightOn                             = [ ];
		this .x3d_LightColor                          = [ ];
		this .x3d_LightIntensity                      = [ ];
		this .x3d_LightAmbientIntensity               = [ ];
		this .x3d_LightAttenuation                    = [ ];
		this .x3d_LightLocation                       = [ ];
		this .x3d_LightDirection                      = [ ];
		this .x3d_LightBeamWidth                      = [ ];
		this .x3d_LightCutOffAngle                    = [ ];
		this .x3d_LightRadius                         = [ ];
		this .x3d_LightMatrix                         = [ ];
		this .x3d_ShadowIntensity                     = [ ];
		this .x3d_ShadowColor                         = [ ];
		this .x3d_ShadowBias                          = [ ];
		this .x3d_ShadowMatrix                        = [ ];
		this .x3d_ShadowMapSize                       = [ ];
		this .x3d_ShadowMap                           = [ ];
		this .x3d_TextureType                         = [ ];
		this .x3d_Texture2D                           = [ ];
		this .x3d_Texture3D                           = [ ];
		this .x3d_CubeMapTexture                      = [ ];
		this .x3d_MultiTextureMode                    = [ ];
		this .x3d_MultiTextureAlphaMode               = [ ];
		this .x3d_MultiTextureSource                  = [ ];
		this .x3d_MultiTextureFunction                = [ ];
		this .x3d_TextureCoordinateGeneratorMode      = [ ];
		this .x3d_TextureCoordinateGeneratorParameter = [ ];
		this .x3d_ProjectiveTexture                   = [ ];
		this .x3d_ProjectiveTextureMatrix             = [ ];
		this .x3d_ProjectiveTextureLocation           = [ ];
		this .x3d_TexCoord                            = [ ];
		this .x3d_TextureMatrix                       = [ ];

		this .numClipPlanes               = 0;
		this .fogNode                     = null;
		this .numLights                   = 0;
		this .numGlobalLights             = 0;
		this .lightNodes                  = [ ];
		this .numProjectiveTextures       = 0;
		this .numGlobalProjectiveTextures = 0;
		this .projectiveTextureNodes      = [ ];
		this .textures                    = new Map ();
	}

	X3DProgrammableShaderObject .prototype =
	{
		constructor: X3DProgrammableShaderObject,
		initialize: function ()
		{
			var browser = this .getBrowser ();

			this .x3d_MaxClipPlanes = browser .getMaxClipPlanes ();
			this .x3d_MaxLights     = browser .getMaxLights ();
			this .x3d_MaxTextures   = browser .getMaxTextures ();
		},
		hasUserDefinedFields: function ()
		{
			return true;
		},
		bindAttributeLocations: function (gl, program)
		{
			gl .bindAttribLocation (program, 0, "x3d_Vertex");
		},
		getDefaultUniforms: function ()
		{
			// Get uniforms and attributes.

			var
				browser = this .getBrowser (),
				gl      = browser .getContext (),
				program = this .getProgram ();

			this .x3d_LogarithmicFarFactor1_2 = gl .getUniformLocation (program, "x3d_LogarithmicFarFactor1_2");

			this .x3d_GeometryType  = gl .getUniformLocation (program, "x3d_GeometryType");
			this .x3d_NumClipPlanes = gl .getUniformLocation (program, "x3d_NumClipPlanes");

			this .x3d_ClipPlanes = gl .getUniformLocation (program, "x3d_ClipPlane");

			for (var i = 0; i < this .x3d_MaxClipPlanes; ++ i)
				this .x3d_ClipPlane [i]  = gl .getUniformLocation (program, "x3d_ClipPlane[" + i + "]");

			this .x3d_FogType            = this .getUniformLocation (gl, program, "x3d_Fog.type",            "x3d_FogType");
			this .x3d_FogColor           = this .getUniformLocation (gl, program, "x3d_Fog.color",           "x3d_FogColor");
			this .x3d_FogVisibilityRange = this .getUniformLocation (gl, program, "x3d_Fog.visibilityRange", "x3d_FogVisibilityRange");
			this .x3d_FogMatrix          = this .getUniformLocation (gl, program, "x3d_Fog.matrix",          "x3d_FogMatrix");
			this .x3d_FogCoord           = this .getUniformLocation (gl, program, "x3d_Fog.fogCoord",        "x3d_FogCoord");

			this .x3d_PointPropertiesPointSizeScaleFactor = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeScaleFactor");
			this .x3d_PointPropertiesPointSizeMinValue    = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeMinValue");
			this .x3d_PointPropertiesPointSizeMaxValue    = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeMaxValue");
			this .x3d_PointPropertiesPointSizeAttenuation = gl .getUniformLocation (program, "x3d_PointProperties.pointSizeAttenuation");
			this .x3d_PointPropertiesColorMode            = gl .getUniformLocation (program, "x3d_PointProperties.colorMode");

			this .x3d_LinePropertiesApplied              = gl .getUniformLocation (program, "x3d_LineProperties.applied");
			this .x3d_LinePropertiesLinewidthScaleFactor = this .getUniformLocation (gl, program, "x3d_LineProperties.linewidthScaleFactor", "x3d_LinewidthScaleFactor");
			this .x3d_LinePropertiesLinetype             = gl .getUniformLocation (program, "x3d_LineProperties.linetype");

			this .x3d_FillPropertiesFilled     = gl .getUniformLocation (program, "x3d_FillProperties.filled");
			this .x3d_FillPropertiesHatched    = gl .getUniformLocation (program, "x3d_FillProperties.hatched");
			this .x3d_FillPropertiesHatchColor = gl .getUniformLocation (program, "x3d_FillProperties.hatchColor");
			this .x3d_FillPropertiesHatchStyle = gl .getUniformLocation (program, "x3d_FillProperties.hatchStyle");

			this .x3d_Lighting      = gl .getUniformLocation (program, "x3d_Lighting");
			this .x3d_ColorMaterial = gl .getUniformLocation (program, "x3d_ColorMaterial");
			this .x3d_NumLights     = gl .getUniformLocation (program, "x3d_NumLights");

			for (var i = 0; i < this .x3d_MaxLights; ++ i)
			{
				this .x3d_LightType [i]             = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].type",             "x3d_LightType[" + i + "]");
				this .x3d_LightColor [i]            = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].color",            "x3d_LightColor[" + i + "]");
				this .x3d_LightAmbientIntensity [i] = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].ambientIntensity", "x3d_LightAmbientIntensity[" + i + "]");
				this .x3d_LightIntensity [i]        = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].intensity",        "x3d_LightIntensity[" + i + "]");
				this .x3d_LightAttenuation [i]      = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].attenuation",      "x3d_LightAttenuation[" + i + "]");
				this .x3d_LightLocation [i]         = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].location",         "x3d_LightLocation[" + i + "]");
				this .x3d_LightDirection [i]        = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].direction",        "x3d_LightDirection[" + i + "]");
				this .x3d_LightBeamWidth [i]        = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].beamWidth",        "x3d_LightBeamWidth[" + i + "]");
				this .x3d_LightCutOffAngle [i]      = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].cutOffAngle",      "x3d_LightCutOffAngle[" + i + "]");
				this .x3d_LightRadius [i]           = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].radius",           "x3d_LightRadius[" + i + "]");
				this .x3d_LightMatrix [i]           = this .getUniformLocation (gl, program, "x3d_LightSource[" + i + "].matrix",           "x3d_LightMatrix[" + i + "]");

				this .x3d_ShadowIntensity [i] = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowIntensity");
				this .x3d_ShadowColor [i]     = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowColor");
				this .x3d_ShadowBias [i]      = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowBias");
				this .x3d_ShadowMatrix [i]    = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowMatrix");
				this .x3d_ShadowMapSize [i]   = gl .getUniformLocation (program, "x3d_LightSource[" + i + "].shadowMapSize");
				this .x3d_ShadowMap [i]       = gl .getUniformLocation (program, "x3d_ShadowMap[" + i + "]");
			}

			this .x3d_SeparateBackColor = gl .getUniformLocation (program, "x3d_SeparateBackColor");

			this .x3d_AmbientIntensity = this .getUniformLocation (gl, program, "x3d_FrontMaterial.ambientIntensity", "x3d_AmbientIntensity");
			this .x3d_DiffuseColor     = this .getUniformLocation (gl, program, "x3d_FrontMaterial.diffuseColor",     "x3d_DiffuseColor");
			this .x3d_SpecularColor    = this .getUniformLocation (gl, program, "x3d_FrontMaterial.specularColor",    "x3d_SpecularColor");
			this .x3d_EmissiveColor    = this .getUniformLocation (gl, program, "x3d_FrontMaterial.emissiveColor",    "x3d_EmissiveColor");
			this .x3d_Shininess        = this .getUniformLocation (gl, program, "x3d_FrontMaterial.shininess",        "x3d_Shininess");
			this .x3d_Transparency     = this .getUniformLocation (gl, program, "x3d_FrontMaterial.transparency",     "x3d_Transparency");

			this .x3d_BackAmbientIntensity = this .getUniformLocation (gl, program, "x3d_BackMaterial.ambientIntensity", "x3d_BackAmbientIntensity");
			this .x3d_BackDiffuseColor     = this .getUniformLocation (gl, program, "x3d_BackMaterial.diffuseColor",     "x3d_BackDiffuseColor");
			this .x3d_BackSpecularColor    = this .getUniformLocation (gl, program, "x3d_BackMaterial.specularColor",    "x3d_BackSpecularColor");
			this .x3d_BackEmissiveColor    = this .getUniformLocation (gl, program, "x3d_BackMaterial.emissiveColor",    "x3d_BackEmissiveColor");
			this .x3d_BackShininess        = this .getUniformLocation (gl, program, "x3d_BackMaterial.shininess",        "x3d_BackShininess");
			this .x3d_BackTransparency     = this .getUniformLocation (gl, program, "x3d_BackMaterial.transparency",     "x3d_BackTransparency");

			this .x3d_NumTextures           = gl .getUniformLocation (program, "x3d_NumTextures");
			this .x3d_NumProjectiveTextures = gl .getUniformLocation (program, "x3d_NumProjectiveTextures");
			this .x3d_MultiTextureColor     = gl .getUniformLocation (program, "x3d_MultiTextureColor");

			for (var i = 0; i < this .x3d_MaxTextures; ++ i)
			{
				this .x3d_TextureType [i]    = gl .getUniformLocation (program, "x3d_TextureType[" + i + "]");
				this .x3d_Texture2D [i]      = gl .getUniformLocation (program, "x3d_Texture2D[" + i + "]");
				this .x3d_Texture3D [i]      = gl .getUniformLocation (program, "x3d_Texture3D[" + i + "]");
				this .x3d_CubeMapTexture [i] = gl .getUniformLocation (program, "x3d_CubeMapTexture[" + i + "]");

				this .x3d_MultiTextureMode [i]      = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].mode");
				this .x3d_MultiTextureAlphaMode [i] = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].alphaMode");
				this .x3d_MultiTextureSource [i]    = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].source");
				this .x3d_MultiTextureFunction [i]  = gl .getUniformLocation (program, "x3d_MultiTexture[" + i + "].function");

				this .x3d_TextureCoordinateGeneratorMode [i]      = gl .getUniformLocation (program, "x3d_TextureCoordinateGenerator[" + i + "].mode");
				this .x3d_TextureCoordinateGeneratorParameter [i] = gl .getUniformLocation (program, "x3d_TextureCoordinateGenerator[" + i + "].parameter");

				this .x3d_ProjectiveTexture [i]         = gl .getUniformLocation (program, "x3d_ProjectiveTexture[" + i + "]");
				this .x3d_ProjectiveTextureMatrix [i]   = gl .getUniformLocation (program, "x3d_ProjectiveTextureMatrix[" + i + "]");
				this .x3d_ProjectiveTextureLocation [i] = gl .getUniformLocation (program, "x3d_ProjectiveTextureLocation[" + i + "]");

				this .x3d_TextureMatrix [i] = gl .getUniformLocation (program, "x3d_TextureMatrix[" + i + "]");
				this .x3d_TexCoord [i]      = this .getAttribLocation (gl, program, "x3d_TexCoord" + i, i ? "" : "x3d_TexCoord");
			}

			this .x3d_Viewport          = gl .getUniformLocation (program, "x3d_Viewport");
			this .x3d_ProjectionMatrix  = gl .getUniformLocation (program, "x3d_ProjectionMatrix");
			this .x3d_ModelViewMatrix   = gl .getUniformLocation (program, "x3d_ModelViewMatrix");
			this .x3d_NormalMatrix      = gl .getUniformLocation (program, "x3d_NormalMatrix");
			this .x3d_CameraSpaceMatrix = gl .getUniformLocation (program, "x3d_CameraSpaceMatrix");

			this .x3d_FogDepth = gl .getAttribLocation (program, "x3d_FogDepth");
			this .x3d_Color    = gl .getAttribLocation (program, "x3d_Color");
			this .x3d_Normal   = gl .getAttribLocation (program, "x3d_Normal");
			this .x3d_Vertex   = gl .getAttribLocation (program, "x3d_Vertex");

			this .x3d_ParticleId          = gl .getUniformLocation (program, "x3d_Particle.id");
			this .x3d_ParticleLife        = gl .getUniformLocation (program, "x3d_Particle.life");
			this .x3d_ParticleElapsedTime = gl .getUniformLocation (program, "x3d_Particle.elapsedTime");

			// Fill special uniforms with default values, textures for units are created in X3DTexturingContext.

			gl .uniform1i  (this .x3d_LinePropertiesLinetype,   browser .getLinetypeUnit ());
			gl .uniform1i  (this .x3d_FillPropertiesHatchStyle, browser .getHatchStyleUnit ());
			gl .uniform1i  (this .x3d_NumTextures,              0);
			gl .uniform1iv (this .x3d_Texture2D [0],            browser .getTexture2DUnits ());
			gl .uniform1iv (this .x3d_CubeMapTexture [0],       browser .getCubeMapTextureUnits ());
			gl .uniform1iv (this .x3d_ShadowMap [0],            new Int32Array (this .x3d_MaxLights) .fill (browser .getShadowTextureUnit ()));

			if (browser .getProjectiveTextureMapping ())
				gl .uniform1iv (this .x3d_ProjectiveTexture [0], browser .getProjectiveTextureUnits ());

			if (gl .getVersion () >= 2)
				gl .uniform1iv (this .x3d_Texture3D [0], browser .getTexture3DUnits ());

			// Return true if valid, otherwise false.

			if (this .x3d_FogDepth < 0)
			{
				this .enableFogDepthAttribute  = Function .prototype;
				this .disableFogDepthAttribute = Function .prototype;
			}
			else
			{
				delete this .enableFogDepthAttribute;
				delete this .disableFogDepthAttribute;
			}

			if (this .x3d_Color < 0)
			{
				this .enableColorAttribute  = Function .prototype;
				this .disableColorAttribute = Function .prototype;
			}
			else
			{
				delete this .enableColorAttribute;
				delete this .disableColorAttribute;
			}

			if (this .x3d_TexCoord .some (function (location) { return location >= 0; }))
			{
				delete this .enableTexCoordAttribute;
				delete this .disableTexCoordAttribute;
			}
			else
			{
				this .enableTexCoordAttribute  = Function .prototype;
				this .disableTexCoordAttribute = Function .prototype;
			}

			if (this .x3d_Normal < 0)
			{
				this .enableNormalAttribute  = Function .prototype;
				this .disableNormalAttribute = Function .prototype;
			}
			else
			{
				delete this .enableNormalAttribute;
				delete this .disableNormalAttribute;
			}

			if (this .x3d_Vertex < 0)
			{
				console .warn ("Missing »attribute vec4 x3d_Vertex;«.");
				return false;
			}

			return true;
		},
		getUniformLocation: function (gl, program, name, depreciated)
		{
			// Legacy function to get uniform location.

			var location = gl .getUniformLocation (program, name);

			if (location)
				return location;

			// Look for depreciated location.

			if (depreciated)
			{
				location = gl .getUniformLocation (program, depreciated);

				if (location)
					console .error (this .getTypeName (), this .getName (), "Using uniform location name »" + depreciated + "« is depreciated, use »" + name + "«. See http://create3000.de/x_ite/custom-shaders/.");

				return location;
			}

			return 0;
		},
		getAttribLocation: function (gl, program, name, depreciated)
		{
			// Legacy function to get uniform location.

			var location = gl .getAttribLocation (program, name);

			if (location >= 0)
				return location;

			// Look for depreciated location.

			if (depreciated)
			{
				location = gl .getAttribLocation (program, depreciated);

				if (location >= 0)
					console .error (this .getTypeName (), this .getName (), "Using attribute location name »" + depreciated + "« is depreciated, use »" + name + "«. See http://create3000.de/x_ite/custom-shaders/.");

				return location;
			}

			return -1;
		},
		addShaderFields: function ()
		{
			var
				gl                = this .getBrowser () .getContext (),
				program           = this .getProgram (),
				userDefinedFields = this .getUserDefinedFields ();

			this .textures .clear ();

			userDefinedFields .forEach (function (field)
			{
				var location = gl .getUniformLocation (program, field .getName ());

				if (location)
				{
					field ._uniformLocation = location;

					field .addInterest ("set_field__", this);

					switch (field .getType ())
					{
						case X3DConstants .SFImage:
						{
							location .array = new Int32Array (3 + field .array .length);
							break;
						}
						case X3DConstants .SFMatrix3d:
						case X3DConstants .SFMatrix3f:
						case X3DConstants .SFRotation:
						{
							location .array = new Float32Array (9);
							break;
						}
						case X3DConstants .SFMatrix4d:
						case X3DConstants .SFMatrix4f:
						{
							location .array = new Float32Array (16);
							break;
						}
						case X3DConstants .SFNode:
						{
							break;
						}
						case X3DConstants .MFBool:
						case X3DConstants .MFInt32:
						{
							location .array = new Int32Array (this .getLocationLength (gl, program, field));
							break;
						}
						case X3DConstants .MFFloat:
						case X3DConstants .MFDouble:
						case X3DConstants .MFTime:
						{
							location .array = new Float32Array (this .getLocationLength (gl, program, field));
							break;
						}
						case X3DConstants .MFImage:
						{
							location .array = new Int32Array (this .getImagesLength (field));
							break;
						}
						case X3DConstants .MFMatrix3d:
						case X3DConstants .MFMatrix3f:
						case X3DConstants .MFRotation:
						{
							location .array = new Float32Array (9 * this .getLocationLength (gl, program, field));
							break;
						}
						case X3DConstants .MFMatrix4d:
						case X3DConstants .MFMatrix4f:
						{
							location .array = new Float32Array (16 * this .getLocationLength (gl, program, field));
							break;
						}
						case X3DConstants .MFNode:
						{
							var locations = location .locations = [ ];

							for (var i = 0;; ++ i)
							{
								var l = gl .getUniformLocation (program, field .getName () + "[" + i + "]");

								if (! l)
									break;

								locations .push (l);
							}

							break;
						}
						case X3DConstants .MFVec2d:
						case X3DConstants .MFVec2f:
						{
							location .array = new Float32Array (2 * this .getLocationLength (gl, program, field));
							break;
						}
						case X3DConstants .MFVec3d:
						case X3DConstants .MFVec3f:
						case X3DConstants .MFColor:
						{
							location .array = new Float32Array (3 * this .getLocationLength (gl, program, field));
							break;
						}
						case X3DConstants .MFVec4d:
						case X3DConstants .MFVec4f:
						case X3DConstants .MFColorRGBA:
						{
							location .array = new Float32Array (4 * this .getLocationLength (gl, program, field));
							break;
						}
					}

					this .set_field__ (field);
				}
			},
			this);
		},
		removeShaderFields: function ()
		{
			var userDefinedFields = this .getUserDefinedFields ();

			userDefinedFields .forEach (function (field)
			{
				field .removeInterest ("set_field__", this);
			},
			this);
		},
		set_field__: (function ()
		{
			var matrix3 = new Matrix3 ();

			return function (field)
			{
				var
					gl       = this .getBrowser () .getContext (),
					location = field ._uniformLocation;

				if (location)
				{
					switch (field .getType ())
					{
						case X3DConstants .SFBool:
						case X3DConstants .SFInt32:
						{
							gl .uniform1i (location, field .getValue ());
							return;
						}
						case X3DConstants .SFColor:
						{
							var value = field .getValue ();
							gl .uniform3f (location, value .r, value .g, value .b);
							return;
						}
						case X3DConstants .SFColorRGBA:
						{
							var value = field .getValue ();
							gl .uniform4f (location, value .r, value .g, value .b, value .a);
							return;
						}
						case X3DConstants .SFDouble:
						case X3DConstants .SFFloat:
						case X3DConstants .SFTime:
						{
							gl .uniform1f (location, field .getValue ());
							return;
						}
						case X3DConstants .SFImage:
						{
							var
								array  = location .array,
								pixels = field .array,
								length = 3 + pixels .length;

							if (length !== array .length)
								array = location .array = new Int32Array (length);

							array [0] = field .width;
							array [1] = field .height;
							array [2] = field .comp;

							for (var a = 3, p = 0, length = pixels .length; p < length; ++ p, ++ a)
								array [a] = pixels [p];

							gl .uniform1iv (location, array);
							return;
						}
						case X3DConstants .SFMatrix3d:
						case X3DConstants .SFMatrix3f:
						{
							location .array .set (field .getValue ());

							gl .uniformMatrix3fv (location, false, location .array);
							return;
						}
						case X3DConstants .SFMatrix4d:
						case X3DConstants .SFMatrix4f:
						{
							location .array .set (field .getValue ());

							gl .uniformMatrix4fv (location, false, location .array);
							return;
						}
						case X3DConstants .SFNode:
						{
							var texture = X3DCast (X3DConstants .X3DTextureNode, field);

							if (texture)
							{
								this .textures .set (location, { name: field .getName (), texture: texture, textureUnit: undefined } );
								return;
							}

							this .textures .delete (location);
							return;
						}
						case X3DConstants .SFRotation:
						{
							field .getValue () .getMatrix (location .array);

							gl .uniformMatrix3fv (location, false, location .array);
							return;
						}
						case X3DConstants .SFString:
						{
							return;
						}
						case X3DConstants .SFVec2d:
						case X3DConstants .SFVec2f:
						{
							var value = field .getValue ();
							gl .uniform2f (location, value .x, value .y);
							return;
						}
						case X3DConstants .SFVec3d:
						case X3DConstants .SFVec3f:
						{
							var value = field .getValue ();
							gl .uniform3f (location, value .x, value .y, value .z);
							return;
						}
						case X3DConstants .SFVec4d:
						case X3DConstants .SFVec4f:
						{
							var value = field .getValue ();
							gl .uniform4f (location, value .x, value .y, value .z, value .w);
							return;
						}
						case X3DConstants .MFBool:
						case X3DConstants .MFInt32:
						{
							var array = location .array;

							for (var i = 0, length = field .length; i < length; ++ i)
								array [i] = field [i];

							for (var length = array .length; i < length; ++ i)
								array [i] = 0;

							gl .uniform1iv (location, array);
							return;
						}
						case X3DConstants .MFColor:
						{
							var array = location .array;

							for (var i = 0, k = 0, length = field .length; i < length; ++ i)
							{
								var color = field [i];

								array [k++] = color .r;
								array [k++] = color .g;
								array [k++] = color .b;
							}

							for (var length = array .length; k < length; ++ k)
								array [k] = 0;

							gl .uniform3fv (location, array);
							return;
						}
						case X3DConstants .MFColorRGBA:
						{
							var array = location .array;

							for (var i = 0, k = 0, length = field .length; i < length; ++ i)
							{
								var color = field [i];

								array [k++] = color .r;
								array [k++] = color .g;
								array [k++] = color .b;
								array [k++] = color .a;
							}

							for (var length = array .length; k < length; ++ k)
								array [k] = 0;

							gl .uniform4fv (location, array);
							return;
						}
						case X3DConstants .MFDouble:
						case X3DConstants .MFFloat:
						case X3DConstants .MFTime:
						{
							var array = location .array;

							for (var i = 0, length = field .length; i < length; ++ i)
								array [i] = field [i];

							for (var length = array .length; i < length; ++ i)
								array [i] = 0;

							gl .uniform1fv (location, array);
							return;
						}
						case X3DConstants .MFImage:
						{
							var
								array  = location .array,
								length = this .getImagesLength (field);

							if (length !== array .length)
								array = location .array = new Int32Array (length);

							for (var i = 0, a = 0, length = field .length; i < length; ++ i)
							{
								var
									value  = field [i],
									pixels = value .array;

								array [a ++] = value .width;
								array [a ++] = value .height;
								array [a ++] = value .comp;

								for (var p = 0, plength = pixels .length; p < plength; ++ p)
									array [a ++] = pixels [p];
							}

							gl .uniform1iv (location, array);
							return;
						}
						case X3DConstants .MFMatrix3d:
						case X3DConstants .MFMatrix3f:
						{
							var array = location .array;

							for (var i = 0, k = 0, length = field .length; i < length; ++ i)
							{
								var matrix = field [i];

								for (var m = 0; m < 9; ++ m)
									array [k++] = matrix [m];
							}

							for (var length = array .length; k < length; ++ k)
								array [k] = 0;

							gl .uniformMatrix3fv (location, false, array);
							return;
						}
						case X3DConstants .MFMatrix4d:
						case X3DConstants .MFMatrix4f:
						{
							var array = location .array;

							for (var i = 0, k = 0, length = field .length; i < length; ++ i)
							{
								var matrix = field [i];

								for (var m = 0; m < 16; ++ m)
									array [k++] = matrix [m];
							}

							for (var length = array .length; k < length; ++ k)
								array [k] = 0;

							gl .uniformMatrix4fv (location, false, array);
							return;
						}
						case X3DConstants .MFNode:
						{
							var locations = location .locations;

							for (var i = 0, length = field .length; i < length; ++ i)
							{
								var texture = X3DCast (X3DConstants .X3DTextureNode, field [i]);

								if (texture)
								{
									this .textures .set (locations [i], { name: field [i] .getName (), texture: texture, textureUnit: undefined } );
									continue;
								}
							}

							return;
						}
						case X3DConstants .MFRotation:
						{
							var array = location .array;

							for (var i = 0, k = 0, length = field .length; i < length; ++ i)
							{
								var matrix = field [i] .getValue () .getMatrix (matrix3);

								array [k++] = matrix [0];
								array [k++] = matrix [1];
								array [k++] = matrix [2];
								array [k++] = matrix [3];
								array [k++] = matrix [4];
								array [k++] = matrix [5];
								array [k++] = matrix [6];
								array [k++] = matrix [7];
								array [k++] = matrix [8];
							}

							for (var length = array .length; k < length; ++ k)
								array [k] = 0;

							gl .uniformMatrix3fv (location, false, array);
							return;
						}
						case X3DConstants .MFString:
						{
							return;
						}
						case X3DConstants .MFVec2d:
						case X3DConstants .MFVec2f:
						{
							var array = location .array;

							for (var i = 0, k = 0, length = field .length; i < length; ++ i)
							{
								var vector = field [i];

								array [k++] = vector .x;
								array [k++] = vector .y;
							}

							for (var length = array .length; k < length; ++ k)
								array [k] = 0;

							gl .uniform2fv (location, array);
							return;
						}
						case X3DConstants .MFVec3d:
						case X3DConstants .MFVec3f:
						{
							var array = location .array;

							for (var i = 0, k = 0, length = field .length; i < length; ++ i)
							{
								var vector = field [i];

								array [k++] = vector .x;
								array [k++] = vector .y;
								array [k++] = vector .z;
							}

							for (var length = array .length; k < length; ++ k)
								array [k] = 0;

							gl .uniform3fv (location, array);
							return;
						}
						case X3DConstants .MFVec4d:
						case X3DConstants .MFVec4f:
						{
							var array = location .array;

							for (var i = 0, k = 0, length = field .length; i < length; ++ i)
							{
								var vector = field [i];

								array [k++] = vector .x;
								array [k++] = vector .y;
								array [k++] = vector .z;
								array [k++] = vector .w;
							}

							for (var length = array .length; k < length; ++ k)
								array [k] = 0;

							gl .uniform4fv (location, array);
							return;
						}
					}
				}
			};
		})(),
		getImagesLength: function (field)
		{
			var
				images = field .getValue (),
				length = 3 * images .length;

			for (var i = 0, l = images .length; i < l; ++ i)
				length += images [i] .array .length;

			return length;
		},
		getLocationLength: function (gl, program, field)
		{
			var name = field .getName ();

			for (var i = 0; ; ++ i)
			{
				var location = gl .getUniformLocation (program, name + "[" + i + "]");

				if (! location)
					break;
			}

			return i;
		},
		hasFog: function (fogNode)
		{
			if (this .fogNode === fogNode)
				return true;

			this .fogNode = fogNode;

			return false;
		},
		hasLight: function (i, lightNode)
		{
			if (this .lightNodes [i] === lightNode)
				return true;

			this .lightNodes [i] = lightNode;

			return false;
		},
		hasTextureProjector: function (i, textureProjectorNode)
		{
			if (this .projectiveTextureNodes [i] === textureProjectorNode)
				return true;

			this .projectiveTextureNodes [i] = textureProjectorNode;

			return false;
		},
		setLocalObjects: function (gl, localObjects)
		{
			// Clip planes and local lights

			this .numClipPlanes                  = 0;
			this .numLights                      = 0;
			this .numProjectiveTextures          = 0;
			this .lightNodes .length             = 0;
			this .projectiveTextureNodes .length = 0;

			for (var i = 0, length = localObjects .length; i < length; ++ i)
				localObjects [i] .setShaderUniforms (gl, this);

			gl .uniform1i (this .x3d_NumClipPlanes,         Math .min (this .numClipPlanes,         this .x3d_MaxClipPlanes));
			gl .uniform1i (this .x3d_NumLights,             Math .min (this .numLights,             this .x3d_MaxLights));
			gl .uniform1i (this .x3d_NumProjectiveTextures, Math .min (this .numProjectiveTextures, this .x3d_MaxTextures));
		},
		setGlobalUniforms: function (gl, renderObject, cameraSpaceMatrixArray, projectionMatrixArray, viewportArray)
		{
			var globalObjects = renderObject .getGlobalObjects ();

			// Set viewport

			gl .uniform4iv (this .x3d_Viewport, viewportArray);

			// Set projection matrix

			gl .uniformMatrix4fv (this .x3d_ProjectionMatrix,  false, projectionMatrixArray);
			gl .uniformMatrix4fv (this .x3d_CameraSpaceMatrix, false, cameraSpaceMatrixArray);

			// Fog

			this .fogNode = null;

			// Set global lights and global texture projectors

			this .numLights                      = 0;
			this .numProjectiveTextures          = 0;
			this .lightNodes .length             = 0;
			this .projectiveTextureNodes .length = 0;

			for (var i = 0, length = globalObjects .length; i < length; ++ i)
				globalObjects [i] .setShaderUniforms (gl, this);

			this .numGlobalLights             = this .numLights;
			this .numGlobalProjectiveTextures = this .numProjectiveTextures;

			// Logarithmic depth buffer support.

			var
				viewpoint      = renderObject .getViewpoint (),
				navigationInfo = renderObject .getNavigationInfo ();

			if (viewpoint instanceof OrthoViewpoint)
				gl .uniform1f (this .x3d_LogarithmicFarFactor1_2, -1);
			else
				gl .uniform1f (this .x3d_LogarithmicFarFactor1_2, 1 / Math .log2 (navigationInfo .getFarValue (viewpoint) + 1));
		},
		setLocalUniforms: function (gl, context)
		{
			var
				stylePropertiesNode   = context .stylePropertiesNode,
				materialNode          = context .materialNode,
				textureNode           = context .textureNode,
				textureTransformNode  = context .textureTransformNode,
				textureCoordinateNode = context .textureCoordinateNode,
				modelViewMatrix       = context .modelViewMatrix,
				localObjects          = context .localObjects;

			// Geometry type

			gl .uniform1i (this .x3d_GeometryType, context .geometryType);

			// Clip planes and local lights

			this .numClipPlanes         = 0;
			this .numLights             = this .numGlobalLights;
			this .numProjectiveTextures = this .numGlobalProjectiveTextures;

			for (var i = 0, length = localObjects .length; i < length; ++ i)
				localObjects [i] .setShaderUniforms (gl, this);

			gl .uniform1i (this .x3d_NumClipPlanes,         Math .min (this .numClipPlanes,         this .x3d_MaxClipPlanes));
			gl .uniform1i (this .x3d_NumLights,             Math .min (this .numLights,             this .x3d_MaxLights));
			gl .uniform1i (this .x3d_NumProjectiveTextures, Math .min (this .numProjectiveTextures, this .x3d_MaxTextures));

			// Fog, there is always one

			context .fogNode .setShaderUniforms (gl, this);
			gl .uniform1i (this .x3d_FogCoord, context .fogCoords);

			stylePropertiesNode .setShaderUniforms (gl, this);

			// Material

			gl .uniform1i (this .x3d_ColorMaterial, context .colorMaterial);

			if (materialNode)
			{
				// Lights

				gl .uniform1i  (this .x3d_Lighting, true);

				// Material

				materialNode .setShaderUniforms (gl, this);

				// Normal matrix

				gl .uniformMatrix3fv (this .x3d_NormalMatrix, false, this .getNormalMatrix (modelViewMatrix));
			}
			else
			{
				gl .uniform1i (this .x3d_Lighting, false);

				if (this .getCustom ())
					gl .uniformMatrix3fv (this .x3d_NormalMatrix, false, this .getNormalMatrix (modelViewMatrix));
			}

			if (textureNode)
			{
				textureNode           .setShaderUniforms (gl, this);
				textureTransformNode  .setShaderUniforms (gl, this);
				textureCoordinateNode .setShaderUniforms (gl, this);
			}
			else
			{
				gl .uniform1i (this .x3d_NumTextures, 0);

				if (this .getCustom ())
				{
					textureTransformNode  .setShaderUniforms (gl, this);
					textureCoordinateNode .setShaderUniforms (gl, this);
				}
			}

			gl .uniformMatrix4fv (this .x3d_ModelViewMatrix, false, modelViewMatrix);
		},
		getNormalMatrix: (function ()
		{
			var normalMatrix = new Float32Array (9);

			return function (modelViewMatrix)
			{
				try
				{
					normalMatrix [0] = modelViewMatrix [0], normalMatrix [3] = modelViewMatrix [1], normalMatrix [6] = modelViewMatrix [ 2],
					normalMatrix [1] = modelViewMatrix [4], normalMatrix [4] = modelViewMatrix [5], normalMatrix [7] = modelViewMatrix [ 6],
					normalMatrix [2] = modelViewMatrix [8], normalMatrix [5] = modelViewMatrix [9], normalMatrix [8] = modelViewMatrix [10];

					Matrix3 .prototype .inverse .call (normalMatrix);

					return normalMatrix;
				}
				catch (error)
				{
					normalMatrix .set (Matrix3 .Identity);

					return normalMatrix;
				}
			};
		})(),
		enable: function (gl)
		{
			var browser = this .getBrowser ();

			//console .log (this .getName ());
			//console .log (browser .getCombinedTextureUnits () .length);

			this .textures .forEach (function (object, location)
			{
				var
					name    = object .name,
					texture = object .texture;

				if (! browser .getCombinedTextureUnits () .length)
				{
					console .warn ("Not enough combined texture units for uniform variable '" + name + "' available.");
					return;
				}

				var textureUnit = object .textureUnit = browser .getCombinedTextureUnits () .pop ();

				gl .uniform1i (location, textureUnit);
				gl .activeTexture (gl .TEXTURE0 + textureUnit);
				gl .bindTexture (texture .getTarget (), texture .getTexture ());
			});

			gl .activeTexture (gl .TEXTURE0);
		},
		disable: function (gl)
		{
			var browser = this .getBrowser ();

			this .textures .forEach (function (object)
			{
				var textureUnit = object .textureUnit;

				if (textureUnit !== undefined)
					browser .getCombinedTextureUnits () .push (textureUnit);

				object .textureUnit = undefined;
			});

			//console .log (browser .getCombinedTextureUnits () .length);
		},
		enableFloatAttrib: function (gl, name, buffer, components)
		{
			var location = gl. getAttribLocation (this .getProgram (), name);

			if (location === -1)
				return;

			gl .enableVertexAttribArray (location);

			gl .bindBuffer (gl .ARRAY_BUFFER, buffer);
			gl .vertexAttribPointer (location, components, gl .FLOAT, false, 0, 0);
		},
		disableFloatAttrib: function (gl, name)
		{
			var location = gl .getAttribLocation (this .getProgram (), name);

			if (location === -1)
				return;

			gl .disableVertexAttribArray (location);
		},
		enableMatrix3Attrib: function (gl, name, buffer)
		{
			var location = gl .getAttribLocation (this .getProgram (), name);

			if (location === -1)
				return;

			gl .enableVertexAttribArray (location);
			gl .enableVertexAttribArray (location + 1);
			gl .enableVertexAttribArray (location + 2);

			gl .bindBuffer (gl .ARRAY_BUFFER, buffer);

			gl .vertexAttribPointer (location,     3, gl .FLOAT, false, 9 * 4, 3 * 4 * 0);
			gl .vertexAttribPointer (location + 1, 3, gl .FLOAT, false, 9 * 4, 3 * 4 * 1);
			gl .vertexAttribPointer (location + 2, 3, gl .FLOAT, false, 9 * 4, 3 * 4 * 2);
		},
		disableMatrix3Attrib: function (gl, name)
		{
			var location = gl .getAttribLocation (this .getProgram (), name);

			if (location === -1)
				return;

			gl .disableVertexAttribArray (location);
			gl .disableVertexAttribArray (location + 1);
			gl .disableVertexAttribArray (location + 2);
		},
		enableMatrix4Attrib: function (gl, name, buffer)
		{
			var location = gl .getAttribLocation (this .getProgram (), name);

			if (location === -1)
				return;

			gl .enableVertexAttribArray (location);
			gl .enableVertexAttribArray (location + 1);
			gl .enableVertexAttribArray (location + 2);
			gl .enableVertexAttribArray (location + 3);

			gl .bindBuffer (gl .ARRAY_BUFFER, buffer);

			gl .vertexAttribPointer (location,     4, gl .FLOAT, false, 16 * 4, 4 * 4 * 0);
			gl .vertexAttribPointer (location + 1, 4, gl .FLOAT, false, 16 * 4, 4 * 4 * 1);
			gl .vertexAttribPointer (location + 2, 4, gl .FLOAT, false, 16 * 4, 4 * 4 * 2);
			gl .vertexAttribPointer (location + 3, 4, gl .FLOAT, false, 16 * 4, 4 * 4 * 3);
		},
		disableMatrix4Attrib: function (gl, name)
		{
			var location = gl .getAttribLocation (this .getProgram (), name);

			if (location === -1)
				return;

			gl .disableVertexAttribArray (location);
			gl .disableVertexAttribArray (location + 1);
			gl .disableVertexAttribArray (location + 2);
			gl .disableVertexAttribArray (location + 3);
		},
		enableFogDepthAttribute: function (gl, fogDepthBuffer)
		{
			gl .enableVertexAttribArray (this .x3d_FogDepth);
			gl .bindBuffer (gl .ARRAY_BUFFER, fogDepthBuffer);
			gl .vertexAttribPointer (this .x3d_FogDepth, 1, gl .FLOAT, false, 0, 0);
		},
		disableFogDepthAttribute: function (gl)
		{
			gl .disableVertexAttribArray (this .x3d_FogDepth);
		},
		enableColorAttribute: function (gl, colorBuffer)
		{
			gl .enableVertexAttribArray (this .x3d_Color);
			gl .bindBuffer (gl .ARRAY_BUFFER, colorBuffer);
			gl .vertexAttribPointer (this .x3d_Color, 4, gl .FLOAT, false, 0, 0);
		},
		disableColorAttribute: function (gl)
		{
			gl .disableVertexAttribArray (this .x3d_Color);
		},
		enableTexCoordAttribute: function (gl, texCoordBuffers, d)
		{
			var length = Math .min (this .x3d_MaxTextures, texCoordBuffers .length);

			for (var i = 0; i < length; ++ i)
			{
				var x3d_TexCoord = this .x3d_TexCoord [i];

				if (x3d_TexCoord === -1)
					continue;

				gl .enableVertexAttribArray (x3d_TexCoord);
				gl .bindBuffer (gl .ARRAY_BUFFER, texCoordBuffers [i]);
				gl .vertexAttribPointer (x3d_TexCoord, 4, gl .FLOAT, false, 0, 0);
			}
		},
		disableTexCoordAttribute: function (gl)
		{
			for (var i = 0, length = this .x3d_MaxTextures; i < length; ++ i)
			{
				var x3d_TexCoord = this .x3d_TexCoord [i];

				if (x3d_TexCoord === -1)
					continue;

				gl .disableVertexAttribArray (x3d_TexCoord);
			}
		},
		enableNormalAttribute: function (gl, normalBuffer)
		{
			gl .enableVertexAttribArray (this .x3d_Normal);
			gl .bindBuffer (gl .ARRAY_BUFFER, normalBuffer);
			gl .vertexAttribPointer (this .x3d_Normal, 3, gl .FLOAT, false, 0, 0);
		},
		disableNormalAttribute: function (gl)
		{
			gl .disableVertexAttribArray (this .x3d_Normal);
		},
		enableVertexAttribute: function (gl, vertexBuffer)
		{
			gl .enableVertexAttribArray (this .x3d_Vertex);
			gl .bindBuffer (gl .ARRAY_BUFFER, vertexBuffer);
			gl .vertexAttribPointer (this .x3d_Vertex, 4, gl .FLOAT, false, 0, 0);
		},
		disableVertexAttribute: function (gl)
		{
			gl .disableVertexAttribArray (this .x3d_Vertex);
		},
		setParticle: function (gl, id, particle, modelViewMatrix, normalMatrix)
		{
			if (normalMatrix)
				gl .uniformMatrix3fv (this .x3d_NormalMatrix, false, this .getNormalMatrix (modelViewMatrix));

			gl .uniformMatrix4fv (this .x3d_ModelViewMatrix, false, modelViewMatrix);

			gl .uniform1i (this .x3d_ParticleId,          id);
			gl .uniform1i (this .x3d_ParticleLife,        particle .life);
			gl .uniform1f (this .x3d_ParticleElapsedTime, particle .elapsedTime / particle .lifetime);
		},
		getProgramInfo: function ()
		{
			function cmp (lhs, rhs) { return lhs < rhs ? -1 : lhs > rhs ? 1 : 0; }

			var
				gl      = this .getBrowser () .getContext (),
				program = this .getProgram ();

			var
				result = {
					attributes: [ ],
					uniforms: [ ],
					attributeCount: 0,
					uniformCount: 0,
				},
				activeUniforms   = gl .getProgramParameter (program, gl.ACTIVE_UNIFORMS),
				activeAttributes = gl .getProgramParameter (program, gl.ACTIVE_ATTRIBUTES);

			// Taken from the WebGl spec:
			// http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14
			var enums = {
				0x8B50: 'vec2',
				0x8B51: 'vec3',
				0x8B52: 'vec4',
				0x8B53: 'ivec2',
				0x8B54: 'ivec3',
				0x8B55: 'ivec4',
				0x8B56: 'bool',
				0x8B57: 'bvec2',
				0x8B58: 'bvec3',
				0x8B59: 'bvec4',
				0x8B5A: 'mat2',
				0x8B5B: 'mat3',
				0x8B5C: 'mat4',
				0x8B5E: 'sampler2D',
				0x8B60: 'samplerCube',
				0x1400: 'byte',
				0x1401: 'ubyte',
				0x1402: 'short',
				0x1403: 'ushort',
				0x1404: 'int',
				0x1405: 'uint',
				0x1406: 'float',
			};

			// Loop through active uniforms
			for (var i = 0; i < activeUniforms; ++ i)
			{
				var uniform = gl .getActiveUniform (program, i);
				uniform .typeName = enums [uniform.type];
				result .uniforms .push (Object .assign ({ }, uniform));
				result .uniformCount += uniform .size;
			}

			// Loop through active attributes
			for (var i = 0; i < activeAttributes; ++ i)
			{
				var attribute = gl .getActiveAttrib (program, i);
				attribute .typeName = enums [attribute .type];
				result .attributes .push (Object .assign ({ }, attribute));
				result .attributeCount += attribute .size;
			}

			result .uniforms   .sort (function (a, b) { return cmp (a .name, b .name); });
			result .attributes .sort (function (a, b) { return cmp (a .name, b .name); });

			return result;
		},
		printProgramInfo: function ()
		{
			var programInfo = this .getProgramInfo ();

			console .log (this .getName ());
			console .table (programInfo .attributes);
			console .log (this .getName (), "attributeCount", programInfo .attributeCount);
			console .log (this .getName ());
			console .table (programInfo .uniforms);
			console .log (this .getName (), "uniformCount", programInfo .uniformCount);
		},
	};

	return X3DProgrammableShaderObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/X3DNetworkSensorNode',[
	"x_ite/Components/Core/X3DSensorNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DSensorNode, 
          X3DConstants)
{
"use strict";

	function X3DNetworkSensorNode (executionContext)
	{
		X3DSensorNode .call (this, executionContext);

		this .addType (X3DConstants .X3DNetworkSensorNode);
	}

	X3DNetworkSensorNode .prototype = Object .assign (Object .create (X3DSensorNode .prototype),
	{
		constructor: X3DNetworkSensorNode,
	});

	return X3DNetworkSensorNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/LoadSensor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Networking/X3DNetworkSensorNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNetworkSensorNode,
          X3DCast,
          X3DConstants)
{
"use strict";

	function LoadSensor (executionContext)
	{
		X3DNetworkSensorNode .call (this, executionContext);

		this .addType (X3DConstants .LoadSensor);

		this .urlObjects = [ ];
		this .aborted    = false;
		this .timeOutId  = undefined;
	}

	LoadSensor .prototype = Object .assign (Object .create (X3DNetworkSensorNode .prototype),
	{
		constructor: LoadSensor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",   new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "timeOut",   new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",  new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isLoaded",  new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "progress",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "loadTime",  new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "watchList", new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "LoadSensor";
		},
		getComponentName: function ()
		{
			return "Networking";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DNetworkSensorNode .prototype .initialize .call (this);

			this .enabled_   .addInterest ("set_enabled__", this);
			this .timeOut_   .addInterest ("set_timeOut__", this);
			this .watchList_ .addInterest ("set_watchList__", this);

			this .watchList_ .addEvent ();
		},
		set_enabled__: function ()
		{
			if (this .enabled_ .getValue ())
				this .reset ();
		
			else
			{
				this .abort ();
				this .remove ();
			}
		},
		set_timeOut__: function ()
		{
			if (this .isActive_ .getValue ())
			{
				this .clearTimeout ();

				this .aborted = false;

				if (this .timeOut_ .getValue () > 0)
					this .timeOutId = setTimeout (this .abort .bind (this), this .timeOut_ .getValue () * 1000);
			}
		},
		set_watchList__: function ()
		{
			this .reset ();
		},
		set_loadState__: function (dummy, urlObject)
		{
			switch (urlObject .checkLoadState ())
			{
				case X3DConstants .NOT_STARTED_STATE:
					break;
				case X3DConstants .IN_PROGRESS_STATE:
				case X3DConstants .COMPLETE_STATE:
				case X3DConstants .FAILED_STATE:
				{
					this .count ();
					break;
				}
			}
		},
		count: function ()
		{
			var
				complete   = 0,
				failed     = 0,
				urlObjects = this .urlObjects;

			for (var i = 0, length = urlObjects .length; i < length; ++ i)
			{
				var urlObject = urlObjects [i];

				complete += urlObject .checkLoadState () == X3DConstants .COMPLETE_STATE;
				failed   += urlObject .checkLoadState () == X3DConstants .FAILED_STATE;
			}

			var
				loaded   = complete == urlObjects .length,
				progress = complete / urlObjects .length;

			if (this .aborted || failed || loaded)
			{
				this .clearTimeout ();

				this .isActive_ = false;
				this .isLoaded_ = loaded;
				this .progress_ = progress;

				if (loaded)
					this .loadTime_ = this .getBrowser () .getCurrentTime ();
			}
			else
			{
				if (this .isActive_ .getValue ())
				{
					this .progress_ = progress;
				}
				else
				{
					this .isActive_ = true;

					this .progress_ = progress;
		
					this .set_timeOut__ ();
				}
			}
		},
		abort: function ()
		{
			this .clearTimeout ();

			this .aborted = true;

			if (this .enabled_ .getValue ())
				this .count ();
		},
		reset: function ()
		{
			this .remove ();
		
			if (this .enabled_ .getValue ())
			{
				var
					watchList  = this .watchList_ .getValue (),
					urlObjects = this .urlObjects;

				for (var i = 0, length = watchList .length; i < length; ++ i)
				{
					var urlObject = X3DCast (X3DConstants .X3DUrlObject, watchList [i]);
		
					if (urlObject)
					{
						urlObjects .push (urlObject);
		
						urlObject .loadState_ .addInterest ("set_loadState__", this, urlObject);
					}
				}

				this .count ();
			}
		},
		remove: function ()
		{
			this .clearTimeout ();

			var urlObjects = this .urlObjects;

			for (var i = 0, length = urlObjects .length; i < length; ++ i)
				urlObjects [i] .loadState_ .removeInterest ("set_loadState__", this);

			urlObjects .length = 0;
		},
		clearTimeout: function ()
		{
			clearTimeout (this .timeOutId);
			this .timeOutId = undefined;
		},
	});

	return LoadSensor;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/ComposedShader',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shaders/X3DShaderNode",
	"x_ite/Components/Shaders/X3DProgrammableShaderObject",
	"x_ite/Components/Networking/LoadSensor",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DShaderNode,
          X3DProgrammableShaderObject,
          LoadSensor,
          X3DCast,
          X3DConstants)
{
"use strict";

	function ComposedShader (executionContext)
	{
		X3DShaderNode               .call (this, executionContext);
		X3DProgrammableShaderObject .call (this, executionContext);

		this .addType (X3DConstants .ComposedShader);

		this .loadSensor = new LoadSensor (executionContext);
	}

	ComposedShader .prototype = Object .assign (Object .create (X3DShaderNode .prototype),
		X3DProgrammableShaderObject .prototype,
	{
		constructor: ComposedShader,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "activate",   new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isSelected", new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isValid",    new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "language",   new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "parts",      new Fields .MFNode ()),
		]),
		wireframe: false,
		getTypeName: function ()
		{
			return "ComposedShader";
		},
		getComponentName: function ()
		{
			return "Shaders";
		},
		getContainerField: function ()
		{
			return "shaders";
		},
		initialize: function ()
		{
			X3DShaderNode               .prototype .initialize .call (this);
			X3DProgrammableShaderObject .prototype .initialize .call (this);

			var gl = this .getBrowser () .getContext ();

			this .primitiveMode = gl .TRIANGLES;

			this .isLive () .addInterest ("set_live__", this);

			this .parts_ .addFieldInterest (this .loadSensor .watchList_);

			this .loadSensor .isLoaded_ .addInterest ("set_loaded__", this);
			this .loadSensor .watchList_ = this .parts_;
			this .loadSensor .setPrivate (true);
			this .loadSensor .setup ();

			//Must not call set_live__.
		},
		getProgram: function ()
		{
			return this .program;
		},
		set_live__: function ()
		{
			var gl = this .getBrowser () .getContext ();

			if (this .isLive () .getValue ())
			{
				if (this .getValid ())
				{
					this .enable (gl);
					this .addShaderFields ();
					this .disable (gl);
				}
			}
			else
			{
				if (this .getValid ())
				{
					this .enable (gl);
					this .removeShaderFields ();
					this .disable (gl);
				}
			}
		},
		set_loaded__: function ()
		{
			if (this .loadSensor .isLoaded_ .getValue ())
			{
				var
					gl      = this .getBrowser () .getContext (),
					program = gl .createProgram (),
					parts   = this .parts_ .getValue (),
					valid   = 0;

				if (this .getValid ())
					this .removeShaderFields ();

				this .program = program;

				for (var i = 0, length = parts .length; i < length; ++ i)
				{
					var partNode = X3DCast (X3DConstants .ShaderPart, parts [i]);

					if (partNode)
					{
						valid += partNode .isValid ();
						gl .attachShader (program, partNode .getShader ());
					}
				}

				if (valid)
				{
					this .bindAttributeLocations (gl, program);

					gl .linkProgram (program);

					valid = gl .getProgramParameter (program, gl .LINK_STATUS);
				}

				if (valid)
				{
					gl .useProgram (this .program);

					// Initialize uniform variables and attributes
					if (this .getDefaultUniforms ())
					{
						// Setup user-defined fields.
						this .addShaderFields ();
					}
					else
					{
						valid = false;
					}

					// Debug, print complete shader info and statistics.
					// this .printProgramInfo ();
				}
				else
				{
					console .warn ("Couldn't initialize " + this .getTypeName () + " '" + this .getName () + "': " + gl .getProgramInfoLog (program));
				}

				this .setValid (Boolean (valid));
			}
			else
			{
				this .setValid (false);
			}
		},
		set_field__: function (field)
		{
			var gl = this .getBrowser () .getContext ();

			gl .useProgram (this .program);

			X3DProgrammableShaderObject .prototype .set_field__ .call (this, field);
		},
		setGlobalUniforms: function (gl, renderObject, cameraSpaceMatrixArray, projectionMatrixArray, viewportArray)
		{
			gl .useProgram (this .program);

			X3DProgrammableShaderObject .prototype .setGlobalUniforms .call (this, gl, renderObject, cameraSpaceMatrixArray, projectionMatrixArray, viewportArray);
		},
		enable: function (gl)
		{
			gl .useProgram (this .program);

			X3DProgrammableShaderObject .prototype .enable .call (this, gl);
		},
	});

	return ComposedShader;
});






























define('text/text!assets/shaders/Types.h',[],function () { return '\nstruct x3d_FogParameters {\n\tmediump int   type;\n\tmediump vec3  color;\n\tmediump float visibilityRange;\n\tmediump mat3  matrix;\n\tbool          fogCoord;\n};\n\n//uniform x3d_FogParameters x3d_Fog;\n\nstruct x3d_LightSourceParameters {\n\tmediump int   type;\n\tmediump vec3  color;\n\tmediump float intensity;\n\tmediump float ambientIntensity;\n\tmediump vec3  attenuation;\n\tmediump vec3  location;\n\tmediump vec3  direction;\n\tmediump float radius;\n\tmediump float beamWidth;\n\tmediump float cutOffAngle;\n\tmediump mat3  matrix;\n\t#ifdef X3D_SHADOWS\n\tmediump vec3  shadowColor;\n\tmediump float shadowIntensity;\n\tmediump float shadowBias;\n\tmediump mat4  shadowMatrix;\n\tmediump int   shadowMapSize;\n\t#endif\n};\n\n//uniform x3d_LightSourceParameters x3d_LightSource [x3d_MaxLights];\n\nstruct x3d_PointPropertiesParameters\n{\n\tmediump float pointSizeScaleFactor;\n\tmediump float pointSizeMinValue;\n\tmediump float pointSizeMaxValue;\n\tmediump vec3  pointSizeAttenuation;\n\tmediump int   colorMode;\n};\n\n//uniform x3d_PointPropertiesParameters x3d_PointProperties;\n\nstruct x3d_LinePropertiesParameters\n{\n\tbool          applied;\n\tmediump float linewidthScaleFactor;\n\tsampler2D     linetype;\n};\n\n//uniform x3d_LinePropertiesParameters x3d_LineProperties;\n\nstruct x3d_FillPropertiesParameters\n{\n\tbool         filled;\n\tbool         hatched;\n\tmediump vec3 hatchColor;\n\tsampler2D    hatchStyle;\n};\n\n//uniform x3d_FillPropertiesParameters x3d_FillProperties;\n\nstruct x3d_MaterialParameters\n{\n\tmediump float ambientIntensity;\n\tmediump vec3  diffuseColor;\n\tmediump vec3  specularColor;\n\tmediump vec3  emissiveColor;\n\tmediump float shininess;\n\tmediump float transparency;\n};\n\n//uniform x3d_MaterialParameters x3d_FrontMaterial;\n//uniform x3d_MaterialParameters x3d_BackMaterial;\n\nstruct x3d_MultiTextureParameters\n{\n\tmediump int mode;\n\tmediump int alphaMode;\n\tmediump int source;\n\tmediump int function;\n};\n\n//uniform x3d_MultiTextureParameters x3d_MultiTexture [x3d_MaxTextures];\n\nstruct x3d_TextureCoordinateGeneratorParameters\n{\n\tmediump int   mode;\n\tmediump float parameter [6];\n};\n\n//uniform x3d_TextureCoordinateGeneratorParameters x3d_TextureCoordinateGenerator [x3d_MaxTextures];\n\nstruct x3d_ParticleParameters\n{\n\tmediump int   id;\n\tmediump int   life;\n\tmediump float elapsedTime;\n};\n\n//uniform x3d_ParticleParameters x3d_Particle;\n';});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/MultiTextureModeType',[],function ()
{
"use strict";

	var i = 0;

	var ModeType =
	{
		REPLACE:                   i ++,
		MODULATE:                  i ++,
		MODULATE2X:                i ++,
		MODULATE4X:                i ++,
		ADD:                       i ++,
		ADDSIGNED:                 i ++,
		ADDSIGNED2X:               i ++,
		ADDSMOOTH:                 i ++,
		SUBTRACT:                  i ++,
		BLENDDIFFUSEALPHA:         i ++,
		BLENDTEXTUREALPHA:         i ++,
		BLENDFACTORALPHA:          i ++,
		BLENDCURRENTALPHA:         i ++,
		MODULATEALPHA_ADDCOLOR:    i ++,
		MODULATEINVALPHA_ADDCOLOR: i ++,
		MODULATEINVCOLOR_ADDALPHA: i ++,
		DOTPRODUCT3:               i ++,
		SELECTARG1:                i ++,
		SELECTARG2:                i ++,
		OFF:                       i ++,
	};

	return ModeType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/MultiTextureSourceType',[],function ()
{
"use strict";

	var i = 0;

	var SourceType =
	{
		DEFAULT:  i ++,
		DIFFUSE:  i ++,
		SPECULAR: i ++,
		FACTOR:   i ++,
	};

	return SourceType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/MultiTextureFunctionType',[],function ()
{
"use strict";

	var i = 0;

	var FunctionType =
	{
		DEFAULT:        i ++,
		COMPLEMENT:     i ++,
		ALPHAREPLICATE: i ++,
	};

	return FunctionType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/TextureCoordinateGeneratorModeType',[],function ()
{
"use strict";

	var i = 0;

	var ModeType =
	{
		NONE:                        i ++,
		SPHERE:                      i ++,
		CAMERASPACENORMAL:           i ++,
		CAMERASPACEPOSITION:         i ++,
		CAMERASPACEREFLECTIONVECTOR: i ++,
		SPHERE_LOCAL:                i ++,
		COORD:                       i ++,
		COORD_EYE:                   i ++,
		NOISE:                       i ++,
		NOISE_EYE:                   i ++,
		SPHERE_REFLECT:              i ++,
		SPHERE_REFLECT_LOCAL:        i ++,
	};

	return ModeType;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public LicINFINITY, 88, 51, 68ense version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Shaders/Shader',[
	"x_ite/Browser/Shaders/ShaderSource",
	"text!assets/shaders/Types.h",
	"x_ite/Browser/Texturing/MultiTextureModeType",
	"x_ite/Browser/Texturing/MultiTextureSourceType",
	"x_ite/Browser/Texturing/MultiTextureFunctionType",
	"x_ite/Browser/Texturing/TextureCoordinateGeneratorModeType",
],
function (ShaderSource,
          Types,
          MultiTextureModeType,
          MultiTextureSourceType,
          MultiTextureFunctionType,
          TextureCoordinateGeneratorModeType)
{
"use strict";

	var Shader =
	{
		getShaderSource: function (browser, name, source, shadow)
		{
			var gl = browser .getContext ();

			source = ShaderSource .get (gl, source);

			var
				COMMENTS     = "\\s+|/\\*[^]*?\\*/|//.*?\\n",
				LINE         = "#line\\s+.*?\\n",
				IF           = "#if\\s+.*?\\n",
				ELIF         = "#elif\\s+.*?\\n",
				IFDEF        = "#ifdef\\s+.*?\\n",
				IFNDEF       = "#ifndef\\s+.*?\\n",
				ELSE         = "#else.*?\\n",
				ENDIF        = "#endif.*?\\n",
				DEFINE       = "#define\\s+(?:[^\\n\\\\]|\\\\[^\\r\\n]|\\\\\\r?\\n)*\\n",
				UNDEF        = "#undef\\s+.*?\\n",
				PRAGMA       = "#pragma\\s+.*?\\n",
				PREPROCESSOR =  LINE + "|" + IF + "|" + ELIF + "|" + IFDEF + "|" + IFNDEF + "|" + ELSE + "|" + ENDIF + "|" + DEFINE + "|" + UNDEF + "|" + PRAGMA,
				VERSION      = "#version\\s+.*?\\n",
				EXTENSION    = "#extension\\s+.*?\\n",
				ANY          = "[^]*";

			var
				GLSL  = new RegExp ("^((?:" + VERSION + ")?)((?:" + COMMENTS + "|" + PREPROCESSOR + "|" + EXTENSION + ")*)(" + ANY + ")$"),
				match = source .match (GLSL);

			if (! match)
				return source;

			var
				lines1 = (match [1] .match (/\n/g) || []) .length,
				lines2 = (match [1] .match (/\n/g) || []) .length;

			var constants = "";

			constants += "#define X_ITE\n";

			if (browser .getRenderingProperty ("LogarithmicDepthBuffer"))
				constants += "#define X3D_LOGARITHMIC_DEPTH_BUFFER\n";

			if (gl .getVersion () >= 2 || browser .getExtension ("WEBGL_depth_texture"))
				constants += "#define X3D_DEPTH_TEXTURE\n";

			if (browser .getMultiTexturing ())
				constants += "#define X3D_MULTI_TEXTURING\n";

			if (browser .getProjectiveTextureMapping ())
				constants += "#define X3D_PROJECTIVE_TEXTURE_MAPPING\n";

			if (shadow)
			{
				constants += "#define X3D_SHADOWS\n";
				constants += "#define X3D_PCF_FILTERING\n";
			}

			constants += "#line " + (lines1 + 1) + "\n";

			var definitions = "";

			definitions += "#define x3d_None 0\n";

			definitions += "#define x3d_Points      0\n";
			definitions += "#define x3d_Lines       1\n";
			definitions += "#define x3d_Geometry2D  2\n";
			definitions += "#define x3d_Geometry3D  3\n";

			definitions += "#define x3d_MaxClipPlanes  " + browser .getMaxClipPlanes () + "\n";

			definitions += "#define x3d_LinearFog        1\n";
			definitions += "#define x3d_ExponentialFog   2\n";
			definitions += "#define x3d_Exponential2Fog  3\n";

			definitions += "#define x3d_MaxLights         " + browser .getMaxLights () + "\n";
			definitions += "#define x3d_DirectionalLight  1\n";
			definitions += "#define x3d_PointLight        2\n";
			definitions += "#define x3d_SpotLight         3\n";

			definitions += "#define x3d_MaxTextures                " + browser .getMaxTextures () + "\n";
			definitions += "#define x3d_TextureType2D              2\n";
			definitions += "#define x3d_TextureType3D              3\n";
			definitions += "#define x3d_TextureTypeCubeMapTexture  4\n";

			definitions += "#define x3d_PointColor           0\n";
			definitions += "#define x3d_TextureColor         1\n";
			definitions += "#define x3d_TextureAndPointColor 2\n";

			definitions += "#define x3d_Replace                   " + MultiTextureModeType .REPLACE                   + "\n";
			definitions += "#define x3d_Modulate                  " + MultiTextureModeType .MODULATE                  + "\n";
			definitions += "#define x3d_Modulate2X                " + MultiTextureModeType .MODULATE2X                + "\n";
			definitions += "#define x3d_Modulate4X                " + MultiTextureModeType .MODULATE4X                + "\n";
			definitions += "#define x3d_Add                       " + MultiTextureModeType .ADD                       + "\n";
			definitions += "#define x3d_AddSigned                 " + MultiTextureModeType .ADDSIGNED                 + "\n";
			definitions += "#define x3d_AddSigned2X               " + MultiTextureModeType .ADDSIGNED2X               + "\n";
			definitions += "#define x3d_AddSmooth                 " + MultiTextureModeType .ADDSMOOTH                 + "\n";
			definitions += "#define x3d_Subtract                  " + MultiTextureModeType .SUBTRACT                  + "\n";
			definitions += "#define x3d_BlendDiffuseAlpha         " + MultiTextureModeType .BLENDDIFFUSEALPHA         + "\n";
			definitions += "#define x3d_BlendTextureAlpha         " + MultiTextureModeType .BLENDTEXTUREALPHA         + "\n";
			definitions += "#define x3d_BlendFactorAlpha          " + MultiTextureModeType .BLENDFACTORALPHA          + "\n";
			definitions += "#define x3d_BlendCurrentAlpha         " + MultiTextureModeType .BLENDCURRENTALPHA         + "\n";
			definitions += "#define x3d_ModulateAlphaAddColor     " + MultiTextureModeType .MODULATEALPHA_ADDCOLOR    + "\n";
			definitions += "#define x3d_ModulateInvAlphaAddColor  " + MultiTextureModeType .MODULATEINVALPHA_ADDCOLOR + "\n";
			definitions += "#define x3d_ModulateInvColorAddAlpha  " + MultiTextureModeType .MODULATEINVCOLOR_ADDALPHA + "\n";
			definitions += "#define x3d_DotProduct3               " + MultiTextureModeType .DOTPRODUCT3               + "\n";
			definitions += "#define x3d_SelectArg1                " + MultiTextureModeType .SELECTARG1                + "\n";
			definitions += "#define x3d_SelectArg2                " + MultiTextureModeType .SELECTARG2                + "\n";
			definitions += "#define x3d_Off                       " + MultiTextureModeType .OFF                       + "\n";

			definitions += "#define x3d_Diffuse  " + MultiTextureSourceType .DIFFUSE  + "\n";
			definitions += "#define x3d_Specular " + MultiTextureSourceType .SPECULAR + "\n";
			definitions += "#define x3d_Factor   " + MultiTextureSourceType .FACTOR   + "\n";

			definitions += "#define x3d_Complement     " + MultiTextureFunctionType .COMPLEMENT     + "\n";
			definitions += "#define x3d_AlphaReplicate " + MultiTextureFunctionType .ALPHAREPLICATE + "\n";

			definitions += "#define x3d_Sphere                      " + TextureCoordinateGeneratorModeType .SPHERE                      + "\n";
			definitions += "#define x3d_CameraSpaceNormal           " + TextureCoordinateGeneratorModeType .CAMERASPACENORMAL           + "\n";
			definitions += "#define x3d_CameraSpacePosition         " + TextureCoordinateGeneratorModeType .CAMERASPACEPOSITION         + "\n";
			definitions += "#define x3d_CameraSpaceReflectionVector " + TextureCoordinateGeneratorModeType .CAMERASPACEREFLECTIONVECTOR + "\n";
			definitions += "#define x3d_SphereLocal                 " + TextureCoordinateGeneratorModeType .SPHERE_LOCAL                + "\n";
			definitions += "#define x3d_Coord                       " + TextureCoordinateGeneratorModeType .COORD                       + "\n";
			definitions += "#define x3d_CoordEye                    " + TextureCoordinateGeneratorModeType .COORD_EYE                   + "\n";
			definitions += "#define x3d_Noise                       " + TextureCoordinateGeneratorModeType .NOISE                       + "\n";
			definitions += "#define x3d_NoiseEye                    " + TextureCoordinateGeneratorModeType .NOISE_EYE                   + "\n";
			definitions += "#define x3d_SphereReflect               " + TextureCoordinateGeneratorModeType .SPHERE_REFLECT              + "\n";
			definitions += "#define x3d_SphereReflectLocal          " + TextureCoordinateGeneratorModeType .SPHERE_REFLECT_LOCAL        + "\n";

			// Legacy
			definitions += "#define x3d_GeometryPoints  0\n";
			definitions += "#define x3d_GeometryLines   1\n";
			definitions += "#define x3d_NoneClipPlane   vec4 (88.0, 51.0, 68.0, 33.0)\n"; // ASCII »X3D!«
			definitions += "#define x3d_NoneFog         0\n";
			definitions += "#define x3d_NoneLight       0\n";
			definitions += "#define x3d_NoneTexture     0\n";

			depreciatedWarning (source, "x3d_GeometryPoints", "x3d_Points");
			depreciatedWarning (source, "x3d_GeometryLines",  "x3d_Lines");
			depreciatedWarning (source, "x3d_NoneClipPlane",  "x3d_NumClipPlanes");
			depreciatedWarning (source, "x3d_NoneFog",        "x3d_None");
			depreciatedWarning (source, "x3d_NoneLight",      "x3d_NumLights");
			depreciatedWarning (source, "x3d_NoneTexture",    "x3d_NumTextures");

			// Adjust precision of struct types;

			var
				sourceNoComments = source .replace (/\/\*[\s\S]*?\*\/|\/\/.*?\n/g, ""),
				types            = Types,
				mf               = sourceNoComments .match (/\s*precision\s+(lowp|mediump|highp)\s+float\s*;/),
				mi               = sourceNoComments .match (/\s*precision\s+(lowp|mediump|highp)\s+int\s*;/),
				pf               = mf ? mf [1] : "mediump",
				pi               = mi ? mi [1] : "mediump";

			types = types .replace (/mediump\s+(float|vec2|vec3|mat3|mat4)/g, pf + " $1");
			types = types .replace (/mediump\s+(int)/g, pi + " $1");

			types += "#line " + (lines1 + lines2 + 1) + "\n";

			var source = match [1] + constants + match [2] + definitions + types + match [3];

			return source;
		},
	};

	function depreciatedWarning (source, depreciated, current)
	{
		if (source .indexOf (depreciated) === -1)
			return;

		console .warn ("Use of '" + depreciated + "' is depreciated, use '" + current + "' instead. See http://create3000.de/x_ite/custom-shaders/.");
	}

	return Shader;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This file is part of the X_ITE Project.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains "non-military use only" components.
 *
 * Copyright 2016 Andreas Plesch.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/HTMLSupport',[],function ()
{
"use strict";

	var HTMLSupport =
	{
		// Fields are set when component is registered.
		fields: new Map (),
	};

	Object .preventExtensions (HTMLSupport);
	Object .freeze (HTMLSupport);
	Object .seal (HTMLSupport);

	return HTMLSupport;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/XMLParser',[
	"jquery",
	"x_ite/Basic/X3DField",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Components/Core/X3DPrototypeInstance",
	"x_ite/Fields",
	"x_ite/Parser/Parser",
	"x_ite/Parser/X3DParser",
	"x_ite/Parser/HTMLSupport",
	"x_ite/Prototype/X3DExternProtoDeclaration",
	"x_ite/Prototype/X3DProtoDeclaration",
	"x_ite/Bits/X3DConstants",
],
function ($,
          X3DField,
          X3DBaseNode,
          X3DPrototypeInstance,
          Fields,
          Parser,
          X3DParser,
          HTMLSupport,
          X3DExternProtoDeclaration,
          X3DProtoDeclaration,
          X3DConstants)
{
"use strict";

	var AccessType =
	{
		initializeOnly: X3DConstants .initializeOnly,
		inputOnly:      X3DConstants .inputOnly,
		outputOnly:     X3DConstants .outputOnly,
		inputOutput:    X3DConstants .inputOutput,
	};

	function XMLParser (scene)
	{
		X3DParser .call (this, scene);

		this .protoDeclarations = [ ];
		this .parents           = [ ];
		this .parser            = new Parser (scene);
		this .url               = new Fields .MFString ();

		try
		{
			this .setUnits (this .getScene () .getMetaData ("generator"));
			this .parser .setUnits (this .getUnits ());
		}
		catch (error)
		{ }
	}

	XMLParser .prototype = Object .assign (Object .create (X3DParser .prototype),
	{
		constructor: XMLParser,
		parseIntoScene: function (xmlElement, success, error)
		{
			this .success = success;
			this .error   = error;

			this .getScene () .setEncoding ("XML");
			this .getScene () .setProfile (this .getBrowser () .getProfile ("Full"));

			this .xmlElement (xmlElement);
		},
		parseIntoNode: function (node, xmlElement)
		{
			this .pushExecutionContext (node .getExecutionContext ());
			this .pushParent (node);

			this .childElement (xmlElement);

			this .popParent ();
			this .popExecutionContext ();
		},
		xmlElement: function (xmlElement)
		{
			switch (xmlElement .nodeName)
			{
				case "#document":
				{
					var X3D = $(xmlElement) .children ("X3D");

					if (X3D .length)
					{
						for (var i = 0; i < X3D .length; ++ i)
							this .x3dElement (X3D [i]);
					}
					else
					{
						if (this .success)
						{
							require (this .getProviderUrls (),
							function ()
							{
								try
								{
									this .childrenElements (xmlElement);

									this .success (this);
								}
								catch (error)
								{
									if (this .error)
										this .error (error);
								}
							}
							.bind (this),
							function (error)
							{
								if (this .error)
									this .error (error);
							}
							.bind (this));
						}
						else
						{
							this .childrenElements (xmlElement);
						}
					}

					break;
				}
				case "X3D":
				{
					this .x3dElement (xmlElement);
					break;
				}
				case "Scene":
				case "SCENE":
				{
					if (this .success)
					{
						require (this .getProviderUrls (),
						function ()
						{
							try
							{
								this .sceneElement (xmlElement);

								this .success (this);
							}
							catch (error)
							{
								if (this .error)
									this .error (error);
							}
						}
						.bind (this),
						function (error)
						{
							if (this .error)
								this .error (error);
						}
						.bind (this));
					}
					else
					{
						this .sceneElement (xmlElement);
					}

					break;
				}
				default:
				{
					if (this .success)
					{
						require (this .getProviderUrls (),
						function ()
						{
							try
							{
								this .childrenElements (xmlElement);

								this .success (this);
							}
							catch (error)
							{
								if (this .error)
									this .error (error);
							}
						}
						.bind (this),
						function (error)
						{
							if (this .error)
								this .error (error);
						}
						.bind (this));
					}
					else
					{
						this .childrenElements (xmlElement);
					}

					break;
				}
			}
		},
		x3dElement: function (xmlElement)
		{
			try
			{
				// Profile

				var
					profileNameId = xmlElement .getAttribute ("profile"),
					profile       = this .getBrowser () .getProfile (profileNameId || "Full");

				this .getScene () .setProfile (profile);
			}
			catch (error)
			{
				console .log (error);
			}

			// Specification version

			var specificationVersion = xmlElement .getAttribute ("version");

			if (specificationVersion)
				this .getScene () .setSpecificationVersion (specificationVersion);

			// Process child nodes

			var childNodes = xmlElement .childNodes;

			for (var i = 0; i < childNodes .length; ++ i)
				this .x3dElementChildHead (childNodes [i])

			if (this .success)
			{
				require (this .getProviderUrls (),
				function ()
				{
					try
					{
						for (var i = 0; i < childNodes .length; ++ i)
							this .x3dElementChildScene (childNodes [i])

						this .success (this);
					}
					catch (error)
					{
						if (this .error)
							this .error (error);
					}
				}
				.bind (this),
				function (error)
				{
					if (this .error)
						this .error (error);
				}
				.bind (this));
			}
			else
			{
				for (var i = 0; i < childNodes .length; ++ i)
					this .x3dElementChildScene (childNodes [i])
			}
		},
		x3dElementChildHead: function (xmlElement)
		{
			switch (xmlElement .nodeName)
			{
				case "head":
				case "HEAD":
					this .headElement (xmlElement);
					return;
			}
		},
		x3dElementChildScene: function (xmlElement)
		{
			switch (xmlElement .nodeName)
			{
				case "Scene":
				case "SCENE":
					this .sceneElement (xmlElement);
					return;
			}
		},
		headElement: function (xmlElement)
		{
			var childNodes = xmlElement .childNodes;

			for (var i = 0; i < childNodes .length; ++ i)
				this .headElementChild (childNodes [i]);

			try
			{
				this .setUnits (this .getScene () .getMetaData ("generator"));
				this .parser .setUnits (this .getUnits ());
			}
			catch (error)
			{ }
		},
		headElementChild: function (xmlElement)
		{
			switch (xmlElement .nodeName)
			{
				case "component":
				case "COMPONENT":
					this .componentElement (xmlElement);
					return;
				case "unit":
				case "UNIT":
					this .unitElement (xmlElement);
					return;
				case "meta":
				case "META":
					this .metaElement (xmlElement);
					return;
			}
		},
		componentElement: function (xmlElement)
		{
			try
			{
				var
					componentNameIdCharacters = xmlElement .getAttribute ("name"),
					componentSupportLevel = parseInt (xmlElement .getAttribute ("level"));

				if (componentNameIdCharacters === null)
					return console .warn ("XML Parser Error: Bad component statement: Expected name attribute.");

				if (componentSupportLevel === null)
					return console .warn ("XML Parser Error: Bad component statement: Expected level attribute.");

				var component = this .getBrowser () .getComponent (componentNameIdCharacters, componentSupportLevel);

				this .getScene () .addComponent (component);
			}
			catch (error)
			{
				console .log (error .message);
			}
		},
		unitElement: function (xmlElement)
		{
			var
				category         = xmlElement .getAttribute ("category"),
				name             = xmlElement .getAttribute ("name"),
				conversionFactor = xmlElement .getAttribute ("conversionFactor"); //works for html5 as well

			if (category === null)
				return console .warn ("XML Parser Error: Bad unit statement: Expected category attribute.");

			if (name === null)
				return console .warn ("XML Parser Error: Bad unit statement: Expected name attribute.");

			if (conversionFactor === null)
				return console .warn ("XML Parser Error: Bad unit statement: Expected conversionFactor attribute.");

			this .getScene () .updateUnit (category, name, parseFloat (conversionFactor));
		},
		metaElement: function (xmlElement)
		{
			var
				metakey   = xmlElement .getAttribute ("name"),
				metavalue = xmlElement .getAttribute ("content");

			if (metakey === null)
				return console .warn ("XML Parser Error: Bad meta statement: Expected name attribute.");

			if (metavalue === null)
				return console .warn ("XML Parser Error: Bad meta statement: Expected content attribute.");

			this .getScene () .setMetaData (metakey, metavalue);
		},
		sceneElement: function (xmlElement)
		{
			this .childrenElements (xmlElement);
		},
		childrenElements: function (xmlElement)
		{
			var childNodes = xmlElement .childNodes;

			for (var i = 0; i < childNodes .length; ++ i)
				this .childElement (childNodes [i]);
		},
		childElement: function (xmlElement)
		{
			switch (xmlElement .nodeName)
			{
				case "#comment":
				case "#text":
					return;

				case "#cdata-section":
					this .cdataNode (xmlElement);
					return;

				case "ExternProtoDeclare":
				case "EXTERNPROTODECLARE":
					this .externProtoDeclareElement (xmlElement);
					return;

				case "ProtoDeclare":
				case "PROTODECLARE":
					this .protoDeclareElement (xmlElement);
					return;

				case "IS":
					this .isElement (xmlElement);
					return;

				case "ProtoInstance":
				case "PROTOINSTANCE":
					this .protoInstanceElement (xmlElement);
					return;

				case "fieldValue":
				case "FIELDVALUE":
					this .fieldValueElement (xmlElement);
					return;

				case "field":
				case "FIELD":
					this .fieldElement (xmlElement);
					return;

				case "ROUTE":
					this .routeElement (xmlElement);
					return;

				case "IMPORT":
					this .importElement (xmlElement);
					return;

				case "EXPORT":
					this .exportElement (xmlElement);
					return;

				default:
					this .nodeElement (xmlElement);
					return;
			}
		},
		externProtoDeclareElement: function (xmlElement)
		{
			var name = xmlElement .getAttribute ("name");

			if (this .id (name))
			{
				var url = xmlElement .getAttribute ("url");

				if (url === null)
					return console .warn ("XML Parser Error: Bad ExternProtoDeclare statement: Expected url attribute.");

				this .parser .setInput (url);
				Parser .prototype .sfstringValues .call (this .parser, this .url);

				var externproto = new X3DExternProtoDeclaration (this .getExecutionContext ());

				this .pushParent (externproto);
				this .protoInterfaceElement (xmlElement); // parse fields
				this .popParent ();

				externproto .setName (name);
				externproto .url_ = this .url;
				externproto .setup ();

				this .getExecutionContext () .externprotos .add (name, externproto);
			}
		},
		protoDeclareElement: function (xmlElement)
		{
			var name = xmlElement .getAttribute ("name");

			if (this .id (name))
			{
				var
					proto      = new X3DProtoDeclaration (this .getExecutionContext ()),
					childNodes = xmlElement .childNodes;

				for (var i = 0; i < childNodes .length; ++ i)
				{
					var child = childNodes [i];

					switch (child .nodeName)
					{
						case "ProtoInterface":
						case "PROTOINTERFACE":
						{
							this .pushParent (proto);
							this .protoInterfaceElement (child);
							this .popParent ();
							break;
						}
						default:
							continue;
					}

					break;
				}

				for (var i = 0; i < childNodes .length; ++ i)
				{
					var child = childNodes [i];

					switch (child .nodeName)
					{
						case "ProtoBody":
						case "PROTOBODY":
						{
							this .pushExecutionContext (proto);
							this .pushParent (proto);
							this .protoBodyElement (child);
							this .popParent ();
							this .popExecutionContext ();
							break;
						}
						default:
							continue;
					}

					break;
				}

				proto .setName (name);
				proto .setup ();

				this .getExecutionContext () .protos .add (name, proto);
			}
		},
		protoInterfaceElement: function (xmlElement)
		{
			var childNodes = xmlElement .childNodes;

			for (var i = 0; i < childNodes .length; ++ i)
				this .protoInterfaceElementChild (childNodes [i]);
		},
		protoInterfaceElementChild: function (xmlElement)
		{
			switch (xmlElement .nodeName)
			{
				case "field": // User-defined field
				case "FIELD": // User-defined field
					this .fieldElement (xmlElement);
					return;
			}
		},
		fieldElement: function (xmlElement)
		{
			try
			{
				if (this .getParents () .length === 0)
					return;

				var node = this .getParent ();

				if (! (node instanceof X3DBaseNode))
					return;

				if (! node .hasUserDefinedFields ())
					return;

				var accessType = AccessType [xmlElement .getAttribute ("accessType")];

				if (accessType === undefined)
					accessType = X3DConstants .initializeOnly;

				var type = Fields [xmlElement .getAttribute ("type")];

				if (type === undefined)
					return;

				var name = xmlElement .getAttribute ("name");

				if (! this .id (name))
					return;

				var field = new type ();

				if (accessType & X3DConstants .initializeOnly)
				{
					this .fieldValue (field, xmlElement .getAttribute ("value"));

					this .pushParent (field);
					this .childrenElements (xmlElement);
					this .popParent ();
				}

				node .addUserDefinedField (accessType, name, field);
			}
			catch (error)
			{
				//console .log (error);
			}
		},
		protoBodyElement: function (xmlElement)
		{
			this .childrenElements (xmlElement);
		},
		isElement: function (xmlElement)
		{
			if (this .getExecutionContext () instanceof X3DProtoDeclaration)
			{
				var childNodes = xmlElement .childNodes;

				for (var i = 0; i < childNodes .length; ++ i)
					this .isElementChild (childNodes [i]);
			}
		},
		isElementChild: function (xmlElement)
		{
			switch (xmlElement .nodeName)
			{
				case "connect":
				case "CONNECT":
					this .connectElement (xmlElement);
					return;
			}
		},
		connectElement: function (xmlElement)
		{
			var
				nodeFieldName  = xmlElement .getAttribute ("nodeField"),
				protoFieldName = xmlElement .getAttribute ("protoField");

			if (nodeFieldName === null)
				return console .warn ("XML Parser Error: Bad connect statement: Expected nodeField attribute.");

			if (protoFieldName === null)
				return console .warn ("XML Parser Error: Bad connect statement: Expected protoField attribute.");

			try
			{
				if (this .getParents () .length === 0)
					return;

				var
					node  = this .getParent (),
					proto = this .getExecutionContext ();

				if (! (node instanceof X3DBaseNode))
					return;

				var
					nodeField  = node .getField (nodeFieldName),
					protoField = proto .getField (protoFieldName);

				if (nodeField .getType () === protoField .getType ())
				{
					if (protoField .isReference (nodeField .getAccessType ()))
						nodeField .addReference (protoField);
					else
						throw new Error ("Field '" + nodeField .getName () + "' and '" + protoField .getName () + "' in PROTO " + this .getExecutionContext () . getName () + " are incompatible as an IS mapping.");
				}
				else
					throw new Error ("Field '" + nodeField .getName () + "' and '" + protoField .getName () + "' in PROTO " + this .getExecutionContext () .getName () + " have different types.");
			}
			catch (error)
			{
				console .warn ("XML Parser Error: Couldn't create IS reference: " + error .message);
			}
		},
		protoInstanceElement: function (xmlElement)
		{
			try
			{
				if (this .useAttribute (xmlElement))
					return;

				var name = xmlElement .getAttribute ("name");

				if (this .id (name))
				{
					var node = this .getExecutionContext () .createProto (name, false);

					if (! node)
						throw new Error ("Unkown proto or externproto type '" + name + "'.");

					//AP: attach node to DOM xmlElement for access from DOM.
					xmlElement .x3d = node;

					this .defAttribute (xmlElement, node);
					this .addNode (xmlElement, node);
					this .pushParent (node);
					this .childrenElements (xmlElement);
					this .getExecutionContext () .addUninitializedNode (node);
					this .popParent ();
				}
			}
			catch (error)
			{
				console .warn ("XML Parser Error: ", error .message);
				//console .warn (error);
			}
		},
		fieldValueElement: function (xmlElement)
		{
			try
			{
				if (this .getParents () .length === 0)
					return;

				var
					node = this .getParent (),
					name = xmlElement .getAttribute ("name");

				if (! (node instanceof X3DPrototypeInstance))
					return;

				if (! this .id (name))
					return;

				var
					field      = node .getField (name),
					accessType = field .getAccessType ();

				if (accessType & X3DConstants .initializeOnly)
				{
					if (field .getType () === X3DConstants .MFNode)
					{
						field .length = 0
					}

					this .fieldValue (field, xmlElement .getAttribute ("value"));

					this .pushParent (field);
					this .childrenElements (xmlElement);
					this .popParent ();
				}
			}
			catch (error)
			{
				console .warn ("XML Parser Error: Couldn't assign field value: " + error .message);
			}
		},
		nodeElement: function (xmlElement)
		{
			try
			{
				if (this .useAttribute (xmlElement))
					return;

				var node = this .getExecutionContext () .createNode (xmlElement .nodeName, false);

				if (! node)
					throw new Error ("Unkown node type '" + xmlElement .nodeName + "', you probably have insufficient component/profile statements.");

				//AP: attach node to DOM xmlElement for access from DOM.
				xmlElement .x3d = node;

				this .defAttribute (xmlElement, node);
				this .addNode (xmlElement, node);
				this .pushParent (node);
				this .nodeAttributes (xmlElement, node);
				this .childrenElements (xmlElement);
				this .getExecutionContext () .addUninitializedNode (node);
				this .popParent ();
			}
			catch (error)
			{
				//console .error (error);

				console .error ("XML Parser Error: " + error .message);
			}
		},
		routeElement: function (xmlElement)
		{
			try
			{
				var
					sourceNodeName      = xmlElement .getAttribute ("fromNode"),
					sourceField         = xmlElement .getAttribute ("fromField"),
					destinationNodeName = xmlElement .getAttribute ("toNode"),
					destinationField    = xmlElement .getAttribute ("toField");

				if (sourceNodeName === null)
					throw new Error ("Bad ROUTE statement: Expected fromNode attribute.");

				if (sourceField === null)
					throw new Error ("Bad ROUTE statement: Expected fromField attribute.");

				if (destinationNodeName === null)
					throw new Error ("Bad ROUTE statement: Expected toNode attribute.");

				if (destinationField === null)
					throw new Error ("Bad ROUTE statement: Expected toField attribute.");

				var
					executionContext = this .getExecutionContext (),
					sourceNode       = executionContext .getLocalNode (sourceNodeName),
					destinationNode  = executionContext .getLocalNode (destinationNodeName),
					route            = executionContext .addRoute (sourceNode, sourceField, destinationNode, destinationField);

				xmlElement .x3d = route;
			}
			catch (error)
			{
				console .log (error);
				console .warn ("XML Parser Error: " + error .message);
			}
		},
		importElement: function (xmlElement)
		{
			try
			{
				var
					inlineNodeName   = xmlElement .getAttribute ("inlineDEF"),
					exportedNodeName = xmlElement .getAttribute ("importedDEF") || xmlElement .getAttribute ("exportedDEF"),
					localNodeName    = xmlElement .getAttribute ("AS");

				if (inlineNodeName === null)
					throw new Error ("Bad IMPORT statement: Expected inlineDEF attribute.");

				if (exportedNodeName === null)
					throw new Error ("Bad IMPORT statement: Expected importedDEF attribute.");

				if (! localNodeName)
					localNodeName = exportedNodeName;

				var inlineNode = this .getExecutionContext () .getNamedNode (inlineNodeName);

				this .getExecutionContext () .updateImportedNode (inlineNode, exportedNodeName, localNodeName);
			}
			catch (error)
			{
				console .warn ("XML Parser Error: " + error .message);
			}
		},
		exportElement: function (xmlElement)
		{
			try
			{
				if (this .getScene () !== this .getExecutionContext ())
					return;

				var
					localNodeName    = xmlElement .getAttribute ("localDEF"),
					exportedNodeName = xmlElement .getAttribute ("AS");

				if (localNodeName === null)
					throw new Error ("Bad EXPORT statement: Expected localDEF attribute.");

				if (! exportedNodeName)
					exportedNodeName = localNodeName;

				var localNode = this .getExecutionContext () .getLocalNode (localNodeName);

				this .getScene () .updateExportedNode (exportedNodeName, localNode);
			}
			catch (error)
			{
				console .warn ("XML Parser Error: " + error .message);
			}
		},
		cdataNode: function (xmlElement)
		{
			if (this .getParents () .length === 0)
				return;

			var node = this .getParent ();

			if (node instanceof X3DBaseNode)
			{
				var field = node .getSourceText ();

				if (field)
				{
					field .push (xmlElement .data);
					field .setSet (true);
				}
			}
		},
		useAttribute: function (xmlElement)
		{
			try
			{
				var name = xmlElement .getAttribute ("USE");

				if (this .id (name))
				{
					var node = this .getExecutionContext () .getNamedNode (name);

					this .addNode (xmlElement, node .getValue ());
					return true;
				}
			}
			catch (error)
			{
				console .warn ("Invalid USE name: " + error .message);
			}

			return false;
		},
		defAttribute: function (xmlElement, node)
		{
			try
			{
				var name = xmlElement .getAttribute ("DEF");

				if (name)
				{
					try
					{
						var namedNode = this .getExecutionContext () .getNamedNode (name);

						this .getExecutionContext () .updateNamedNode (this .getExecutionContext () .getUniqueName (name), namedNode);
					}
					catch (error)
					{ }

					this .getExecutionContext () .updateNamedNode (name, node);
				}
			}
			catch (error)
			{
				console .warn ("Invalid DEF name: " + error .message);
			}
		},
		nodeAttributes: function (xmlElement, node)
		{
			var xmlAttributes = xmlElement .attributes;

			for (var i = 0; i < xmlAttributes .length; ++ i)
				this .nodeAttribute (xmlAttributes [i], node);
		},
		nodeAttribute: function (xmlAttribute, node)
		{
			try
			{
				var
					field      = node .getField (this .attributeToCamelCase (xmlAttribute .name)),
					accessType = field .getAccessType ();

				if (accessType & X3DConstants .initializeOnly)
					this .fieldValue (field, xmlAttribute .value);
			}
			catch (error)
			{
				//console .warn (error .message);
			}
		},
		fieldValue: function (field, value)
		{
			if (value === null)
				return;

			field .setSet (true);

			this .parser .pushExecutionContext (this .getExecutionContext ());

			this .parser .setInput (value);
			this .fieldTypes [field .getType ()] .call (this .parser, field);

			this .parser .popExecutionContext ();
		},
		addNode: function (xmlElement, node)
		{
			if (this .parents .length === 0 || this .getParent () instanceof X3DProtoDeclaration)
			{
				this .getExecutionContext () .rootNodes .push (node);
				return;
			}

			var parent = this .getParent ();

			if (parent instanceof X3DField)
			{
				switch (parent .getType ())
				{
					case X3DConstants .SFNode:
						parent .setValue (node);
						parent .setSet (true);
						return;

					case X3DConstants .MFNode:
						parent .push (node);
						parent .setSet (true);
						return;
				}

				return;
			}

			// parent is a node.

			try
			{
				var containerField = xmlElement .getAttribute ("containerField");

				if (! containerField)
					containerField = node .getContainerField ();

				var field = parent .getField (containerField);

				switch (field .getType ())
				{
					case X3DConstants .SFNode:
						field .setValue (node);
						field .setSet (true);
						return;

					case X3DConstants .MFNode:
						field .push (node);
						field .setSet (true);
						return;
				}
			}
			catch (error)
			{
				//console .warn (error .message);
			}
		},
		getParents: function ()
		{
			return this .parents;
		},
		getParent: function ()
		{
			return this .parents [this .parents .length - 1];
		},
		pushParent: function (parent)
		{
			return this .parents .push (parent);
		},
		popParent: function ()
		{
			this .parents .pop ();
		},
		id: function (string)
		{
			if (string === null)
				return false;

			if (string .length === 0)
				return false;

			return true;
		},
		attributeToCamelCase: function (name)
		{
			// Function also needed by X_ITE DOM.
			return HTMLSupport .fields .get (name);
		},
	});

	XMLParser .prototype .fieldTypes = [ ];
	XMLParser .prototype .fieldTypes [X3DConstants .SFBool]      = Parser .prototype .sfboolValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFColor]     = Parser .prototype .sfcolorValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFColorRGBA] = Parser .prototype .sfcolorrgbaValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFDouble]    = Parser .prototype .sfdoubleValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFFloat]     = Parser .prototype .sffloatValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFImage]     = Parser .prototype .sfimageValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFInt32]     = Parser .prototype .sfint32Value;
	XMLParser .prototype .fieldTypes [X3DConstants .SFMatrix3f]  = Parser .prototype .sfmatrix3dValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFMatrix3d]  = Parser .prototype .sfmatrix3fValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFMatrix4f]  = Parser .prototype .sfmatrix4dValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFMatrix4d]  = Parser .prototype .sfmatrix4fValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFNode]      = function (field) { field .set (null); };
	XMLParser .prototype .fieldTypes [X3DConstants .SFRotation]  = Parser .prototype .sfrotationValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFString]    = function (field) { field .set (this .input); };
	XMLParser .prototype .fieldTypes [X3DConstants .SFTime]      = Parser .prototype .sftimeValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFVec2d]     = Parser .prototype .sfvec2dValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFVec2f]     = Parser .prototype .sfvec2fValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFVec3d]     = Parser .prototype .sfvec3dValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFVec3f]     = Parser .prototype .sfvec3fValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFVec4d]     = Parser .prototype .sfvec4dValue;
	XMLParser .prototype .fieldTypes [X3DConstants .SFVec4f]     = Parser .prototype .sfvec4fValue;

	XMLParser .prototype .fieldTypes [X3DConstants .MFBool]      = Parser .prototype .sfboolValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFColor]     = Parser .prototype .sfcolorValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFColorRGBA] = Parser .prototype .sfcolorrgbaValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFDouble]    = Parser .prototype .sfdoubleValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFFloat]     = Parser .prototype .sffloatValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFImage]     = Parser .prototype .sfimageValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFInt32]     = Parser .prototype .sfint32Values;
	XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3d]  = Parser .prototype .sfmatrix3dValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3f]  = Parser .prototype .sfmatrix3fValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4d]  = Parser .prototype .sfmatrix4dValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4f]  = Parser .prototype .sfmatrix4fValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFNode]      = function (field) { field .length = 0; };
	XMLParser .prototype .fieldTypes [X3DConstants .MFRotation]  = Parser .prototype .sfrotationValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFString]    = Parser .prototype .sfstringValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFTime]      = Parser .prototype .sftimeValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec2d]     = Parser .prototype .sfvec2dValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec2f]     = Parser .prototype .sfvec2fValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec3d]     = Parser .prototype .sfvec3dValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec3f]     = Parser .prototype .sfvec3fValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec4d]     = Parser .prototype .sfvec4dValues;
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec4f]     = Parser .prototype .sfvec4fValues;

	/*
	 * Lazy parse functions.
	 */

	var
		infs            = /\binf\b/g,
		nans            = /\bnan\b/g,
		trimWhitespaces = /^[\x20\n,\t\r"]+|[\x20\n,\t\r"]+$/g,
		whitespaces     = /[\x20\n,\t\r"]+/,
		strings         = new RegExp ('"((?:[^\\\\"]|\\\\\\\\|\\\\\\")*)"', 'g');

   function prepareBools (string)
	{
		return string .replace (trimWhitespaces, "") .split (whitespaces);
	}

   function prepareFloats (string)
	{
		return (string
			.replace (infs, "Infinity")
			.replace (nans, "NaN")
			.replace (trimWhitespaces, "")
			.split (whitespaces));
	}

   function prepareInts (string)
	{
		return string .replace (trimWhitespaces, "") .split (whitespaces);
	}

   function prepareStrings (string)
	{
		var
			match = null,
			array = [ ];

		while (match = strings .exec (string))
			array .push (match [1]);

		return array .map (Fields .SFString .unescape);
	}

	// Unitless fields.

	XMLParser .prototype .fieldTypes [X3DConstants .MFColor] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFColorRGBA] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3d] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix3f] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4d] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFMatrix4f] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec4d] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec4f] = function (field)
	{
		field .setValue (prepareFloats (this .getInput ()) .map (function (value)
		{
			return parseFloat (value);
		}));
	};

	XMLParser .prototype .fieldTypes [X3DConstants .MFBool] = function (field)
	{
		field .setValue (prepareBools (this .getInput ()) .map (function (value)
		{
			if (value === "true" || value === "TRUE")
				return true;

			return false;
		}));
	};

	XMLParser .prototype .fieldTypes [X3DConstants .MFInt32] = function (field)
	{
		field .setValue (prepareInts (this .getInput ()) .map (function (value)
		{
			return parseInt (value);
		}));
	};

	// Unit fields.

	XMLParser .prototype .fieldTypes [X3DConstants .MFDouble] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFFloat] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec2d] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec2f] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec3d] =
	XMLParser .prototype .fieldTypes [X3DConstants .MFVec3f] = function (field)
	{
		var category = field .getUnit ();

		field .setValue (prepareFloats (this .getInput ()) .map (function (value)
		{
			return this .fromUnit (category, parseFloat (value));
		},
		this));
	};

	XMLParser .prototype .fieldTypes [X3DConstants .MFString] = function (field)
	{
		field .setValue (prepareStrings (this .getInput ()));
	};

	return XMLParser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 * X3DJSONLD Copyright John Carlson, USA 2016-2017
 * https://coderextreme.net/X3DJSONLD/
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the Cobweb Project.
 *
 * Cobweb is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * Cobweb is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with Cobweb.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Parser/JSONParser',[
	"x_ite/Fields",
	"x_ite/Parser/Parser",
	"x_ite/Parser/XMLParser"
],
function (
          Fields,
          Parser,
          XMLParser
          )
{
"use strict";

	function JSONParser (scene)
	{
		this .scene             = scene;
		this .executionContexts = [ scene ];
		this .protoDeclarations = [ ];
		this .parents           = [ ];
		this .parser            = new Parser (this .scene);
		this .url               = new Fields .MFString ();
		this .x3djsonNS         = "https://www.web3d.org/specifications/x3d-namespace";
	}

	JSONParser.prototype = Object.create(XMLParser.prototype);

	JSONParser .prototype.
		constructor = JSONParser;

		/**
		 * Load X3D JSON into an element.
		 * jsobj - the JavaScript object to convert to DOM.
		 */
	JSONParser .prototype.
		parseJavaScript = function(jsobj, success, error) {
			var child = this.CreateElement('X3D');
			this.ConvertToX3DOM(jsobj, "", child);
			// call the DOM parser
			this.parseIntoScene(child, success, error);
			return child;
		};

		// 'https://www.web3d.org/specifications/x3d-namespace'

		// Load X3D JavaScript object into XML or DOM

		/**
		 * Yet another way to set an attribute on an element.  does not allow you to
		 * set JSON schema or encoding.
		 */
	JSONParser .prototype.
		elementSetAttribute = function(element, key, value) {
			if (key === 'SON schema') {
				// JSON Schema
			} else if (key === 'ncoding') {
				// encoding, UTF-8, UTF-16 or UTF-32
			} else {
				if (typeof element.setAttribute === 'function') {
					element.setAttribute(key, value);
				}
			}
		};

		/**
		 * converts children of object to DOM.
		 */
	JSONParser .prototype.
		ConvertChildren = function(parentkey, object, element) {
			var key;

			for (key in object) {
				if (typeof object[key] === 'object') {
					if (isNaN(parseInt(key))) {
						this.ConvertObject(key, object, element, parentkey.substr(1));
					} else {
						this.ConvertToX3DOM(object[key], key, element, parentkey.substr(1));
					}
				}
			}
		};

		/**
		 * a method to create and element with tagnam key to DOM in a namespace.  If
		 * containerField is set, then the containerField is set in the elemetn.
		 */
	JSONParser .prototype.
		CreateElement = function(key, containerField) {
			var child = null;
			if (typeof this.x3djsonNS === 'undefined') {
				child = document.createElement(key);
			} else {
				child = document.createElementNS(this.x3djsonNS, key);
				if (child === null || typeof child === 'undefined') {
					console.error('Trouble creating element for', key);
					child = document.createElement(key);
				}
			}
			if (typeof containerField !== 'undefined') {
				this.elementSetAttribute(child, 'containerField', containerField);
			}
			return child;
		};

		/**
		 * a way to create a CDATA function or script in HTML, by using a DOM parser.
		 */
	JSONParser .prototype.
		CDATACreateFunction = function(document, element, str) {
			var y = str.trim().replace(/\\"/g, "\\\"")
				.replace(/&lt;/g, "<")
				.replace(/&gt;/g, ">")
				.replace(/&amp;/g, "&");
			do {
				str = y;
				y = str.replace(/'([^'\r\n]*)\n([^']*)'/g, "'$1\\n$2'");
				if (str !== y) {
					console.log("CDATA Replacing",str,"with",y);
				}
			} while (y != str);
			var domParser = new DOMParser();
			var cdataStr = '<script> <![CDATA[ ' + y + ' ]]> </script>'; // has to be wrapped into an element
			var scriptDoc = domParser .parseFromString (cdataStr, 'application/xml');
			var cdata = scriptDoc .children[0] .childNodes[1]; // space after script is childNode[0]
			element .appendChild(cdata);
		};

		/**
		 * convert the object at object[key] to DOM.
		 */
	JSONParser .prototype.
		ConvertObject = function(key, object, element, containerField) {
			var child;
			if (object !== null && typeof object[key] === 'object') {
				if (key.substr(0,1) === '@') {
					this.ConvertToX3DOM(object[key], key, element);
				} else if (key.substr(0,1) === '-') {
					this.ConvertChildren(key, object[key], element);
				} else if (key === '#comment') {
					for (var c in object[key]) {
						child = document.createComment(this.CommentStringToXML(object[key][c]));
						element.appendChild(child);
					}
				} else if (key === '#sourceText') {
					this.CDATACreateFunction(document, element, object[key].join("\r\n")+"\r\n");
				} else {
					if (key === 'connect' || key === 'fieldValue' || key === 'field' || key === 'meta' || key === 'component') {
						for (var childkey in object[key]) {  // for each field
							if (typeof object[key][childkey] === 'object') {
								child = this.CreateElement(key, containerField);
								this.ConvertToX3DOM(object[key][childkey], childkey, child);
								element.appendChild(child);
								element.appendChild(document.createTextNode("\n"));
							}
						}
					} else {
						child = this.CreateElement(key, containerField);
						this.ConvertToX3DOM(object[key], key, child);
						element.appendChild(child);
						element.appendChild(document.createTextNode("\n"));
					}
				}
			}
		};

		/**
		 * convert a comment string in JavaScript to XML.  Pass the string
		 */
	JSONParser .prototype.
		CommentStringToXML = function(str) {
			var y = str;
			str = str.replace(/\\\\/g, '\\');
			if (y !== str) {
				console.log("X3DJSONLD <!-> replacing", y, "with", str);
			}
			return str;
		};

		/**
		 * convert an SFString to XML.
		 */
	JSONParser .prototype.
		SFStringToXML = function(str) {
			var y = str;
			/*
			str = (""+str).replace(/\\\\/g, '\\\\');
			str = str.replace(/\\\\\\\\/g, '\\\\');
			str = str.replace(/(\\+)"/g, '\\"');
			*/
			str = str.replace(/\\/g, '\\\\');
			str = str.replace(/"/g, '\\"');
			if (y !== str) {
				console.log("X3DJSONLD [] replacing", y, "with", str);
			}
			return str;
		};

		/**
		 * convert a JSON String to XML.
		 */
	JSONParser .prototype.
		JSONStringToXML = function(str) {
			var y = str;
			str = str.replace(/\\/g, '\\\\');
			str = str.replace(/\n/g, '\\n');
			if (y !== str) {
				console.log("X3DJSONLD replacing", y, "with", str);
			}
			return str;
		};

		/**
		 * main routine for converting a JavaScript object to DOM.
		 * object is the object to convert.
		 * parentkey is the key of the object in the parent.
		 * element is the parent element.
		 * containerField is a possible containerField.
		 */
	JSONParser .prototype.
		ConvertToX3DOM = function(object, parentkey, element, containerField) {
			var key;
			var localArray = [];
			var isArray = false;
			var arrayOfStrings = false;
			for (key in object) {
				if (isNaN(parseInt(key))) {
					isArray = false;
				} else {
					isArray = true;
				}
				if (isArray) {
					if (typeof object[key] === 'number') {
						localArray.push(object[key]);
					} else if (typeof object[key] === 'string') {
						localArray.push(object[key]);
						arrayOfStrings = true;
					} else if (typeof object[key] === 'boolean') {
						localArray.push(object[key]);
					} else if (typeof object[key] === 'object') {
						/*
						if (object[key] != null && typeof object[key].join === 'function') {
							localArray.push(object[key].join(" "));
						}
						*/
						this.ConvertToX3DOM(object[key], key, element);
					} else if (typeof object[key] !== 'undefined') {
						console.error("Unknown type found in array "+typeof object[key]);
					}
				} else if (typeof object[key] === 'object') {
					// This is where the whole thing starts
					if (key === 'X3D') {
						this.ConvertToX3DOM(object[key], key, element);
					} else {
						// this.ConvertObject(key, object, element, containerField);
						if ( key === "-skin" || key === "-skeleton" || key === "-value" )
						{
						    var firstNode = object[ key ][ 0 ];
						    for ( var skv in firstNode )
						    {
							firstNode[ skv ][ "@containerField" ] = key.substr( 1 );
							this.ConvertObject( key, object, element, firstNode[ skv ][ "@containerField" ] );
						    }
						}
                				else if (key.indexOf("HAnim") === 0 && key !== "HAnimHumanoid" && typeof object[key]['@USE'] != 'undefined')
						{
							object[key]['@containerField'] = key.substr(5).toLowerCase()+"s";
							this.ConvertObject(key, object, element, object[key]['@containerField']);
						} else {
							this.ConvertObject(key, object, element, containerField);
						}

					}
				} else if (typeof object[key] === 'number') {
					this.elementSetAttribute(element, key.substr(1),object[key]);
				} else if (typeof object[key] === 'string') {
					if (key !== '#comment') {
						// ordinary string attributes
						this.elementSetAttribute(element, key.substr(1), this.JSONStringToXML(object[key]));
					} else {
						var child = document.createComment(this.CommentStringToXML(object[key]));
						element.appendChild(child);
					}
				} else if (typeof object[key] === 'boolean') {
					this.elementSetAttribute(element, key.substr(1),object[key]);
				} else if (typeof object[key] !== 'undefined') {
					console.error("Unknown type found in object "+typeof object[key]);
					console.error(object);
				}
			}
			if (isArray) {
				if (parentkey.substr(0,1) === '@') {
					if (arrayOfStrings) {
						arrayOfStrings = false;
						for (var str in localArray) {
							localArray[str] = this.SFStringToXML(localArray[str]);
						}
						this.elementSetAttribute(element, parentkey.substr(1),'"'+localArray.join('" "')+'"');
					} else {
						// if non string array
						this.elementSetAttribute(element, parentkey.substr(1),localArray.join(" "));
					}
				}
				isArray = false;
			}
			return element;
		};
	return JSONParser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Networking/BinaryTransport',[],function ()
{
"use strict";

	return function ($)
	{
		// Use this transport for "binary" data type
		$.ajaxTransport ("+binary", function (options, originalOptions, jqXHR)
		{
			// Check for conditions and support for blob / arraybuffer response type
			if (options .dataType && options .dataType == 'binary')
			{
				return {
					send: function (headers, callback)
					{
						// Setup all variables
						var xhr = options .xhr ();

						xhr .open (options .type, options .url, options .async, options .username, options .password);

						// Apply custom fields if provided
						if ( options.xhrFields )
						{
							for (var i in options .xhrFields)
								xhr [i] = options .xhrFields [i];
						}

						// Override mime type if needed
						if (options .mimeType && xhr .overrideMimeType)
							xhr .overrideMimeType (options .mimeType);

						// Setup custom headers
						for (var i in headers)
							xhr .setRequestHeader (i, headers [i]);

						// Setup onload callback
						xhr .onload = function ()
						{
							xhr .onload = xhr .onerror = null;

							var data = { };

							data [options .dataType] = xhr .response;

							callback (xhr .status, xhr .statusText, data, xhr .getAllResponseHeaders ());
						};

						// Setup onerror callback
						xhr.onerror = function ()
						{
							xhr .onload = xhr .onerror = null;

							callback (xhr .status || 404, xhr .statusText);
						};
						
						// Send data
						xhr .responseType = options .responseType || "blob";
						xhr .send (options .hasContent && options .data || null);
					},
					abort: function ()
					{
						var xhr = options .xhr ();

						xhr .onload = xhr .onerror = null;

						xhr .abort ();
					}
				};
			}
		});
	};
});
/* pako 1.0.11 nodeca/pako */(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('pako_inflate/dist/pako_inflate',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pako = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],2:[function(require,module,exports){
// String encode/decode helpers



var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":1}],3:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],4:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],5:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],6:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],7:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],8:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":1,"./adler32":3,"./crc32":5,"./inffast":7,"./inftrees":9}],9:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":1}],10:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],11:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],"/lib/inflate.js":[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":1,"./utils/strings":2,"./zlib/constants":4,"./zlib/gzheader":6,"./zlib/inflate":8,"./zlib/messages":10,"./zlib/zstream":11}]},{},[])("/lib/inflate.js")
});

define('pako_inflate', ['pako_inflate/dist/pako_inflate'], function (main) { return main; });

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/InputOutput/FileLoader',[
	"jquery",
	"x_ite/Base/X3DObject",
	"x_ite/Fields",
	"x_ite/Browser/Networking/urls",
	"x_ite/Parser/Parser",
	"x_ite/Parser/XMLParser",
	"x_ite/Parser/JSONParser",
	"standard/Networking/URI",
	"standard/Networking/BinaryTransport",
	"pako_inflate",
	"x_ite/DEBUG",
],
function ($,
          X3DObject,
          Fields,
          urls,
          Parser,
          XMLParser,
          JSONParser,
          URI,
          BinaryTransport,
          pako,
          DEBUG)
{
"use strict";

	BinaryTransport ($);

	var
		TIMEOUT       = 17,
		ECMAScript    = /^\s*(?:vrmlscript|javascript|ecmascript)\:([^]*)$/,
		dataURL       = /^data:(.*?)(?:;charset=(.*?))?(?:;(base64))?,([^]*)$/,
		contentTypeRx = /^(?:(.*?);(.*?)$)/;

	var foreignExtensions = new RegExp ("\.(?:html|xhtml)$");

	var foreign = {
		"text/html":             true,
		"application/xhtml+xml": true,
	};

	var defaultParameter = new Fields .MFString ();

	function FileLoader (node, external)
	{
		X3DObject .call (this);

		this .node             = node;
		this .browser          = node .getBrowser ();
		this .external         = external === undefined ? this .browser .isExternal () : external;
		this .executionContext = this .external ? node .getExecutionContext () : this .browser .currentScene;
		this .userAgent        = this .browser .getName () + "/" + this .browser .getVersion () + " (X3D Browser; +" + this .browser .getProviderUrl () + ")";
		this .target           = "";
		this .url              = [ ];
		this .URL              = new URI ();
		this .fileReader       = new FileReader ();
		this .text             = true;
	}

	FileLoader .prototype = Object .assign (Object .create (X3DObject .prototype),
	{
		constructor: FileLoader,
		abort: function ()
		{
			this .callback      = Function .prototype;
			this .bindViewpoint = Function .prototype;
			this .foreign       = Function .prototype;
		},
		getWorldURL: function ()
		{
			return this .URL;
		},
		createX3DFromString: function (worldURL, string, success, error)
		{
			var scene = this .browser .createScene ();

			scene .setURL (this .browser .getLocation () .transform (worldURL));

			if (success)
			{
				// Async branch.

				var handlers = [
					function (scene, string, success, error)
					{
						// Try parse X3D XML Encoding.
						setTimeout (this .importDocument .bind (this, scene, $.parseXML (string), success, error), TIMEOUT);
					},
					function (scene, string, success, error)
					{
						// Try parse X3D JSON Encoding.
						setTimeout (this .importJS .bind (this, scene, JSON .parse (string), success, error), TIMEOUT);
					},
					function (scene, string, success, error)
					{
						if (success)
						{
							success = function (scene, success, error)
							{
								this .setScene (scene, success, error);
							}
							.bind (this, scene, success, error);
						}

						// Try parse X3D Classic Encoding.
						new Parser (scene) .parseIntoScene (string, success, error);
					},
				];

				var errors = [ ];

				for (var i = 0, length = handlers .length; i < length; ++ i)
				{
					try
					{
						handlers [i] .call (this, scene, string, success, error);
						return;
					}
					catch (error)
					{
						// Try next handler.
						errors .push (error);
					}
				}

				console .error (errors);

				throw new Error ("Couldn't parse X3D. No suitable file handler found for '" + worldURL + "'.");
			}
			else
			{
				// Sync branch.

				var handlers = [
					function (scene, string)
					{
						// Try parse X3D XML Encoding.
						this .importDocument (scene, $.parseXML (string));
					},
					function (scene, string)
					{
						// Try parse X3D JSON Encoding.
						this .importJS (scene, JSON.parse (string));
					},
					function (scene, string)
					{
						// Try parse X3D Classic Encoding.
						new Parser (scene) .parseIntoScene (string);
					},
				];

				var errors = [ ];

				for (var i = 0, length = handlers .length; i < length; ++ i)
				{
					try
					{
						handlers [i] .call (this, scene, string);
						return scene;
					}
					catch (error)
					{
						// Try next handler.
						errors .push (error);
					}
				}

				console .error (errors);

				throw new Error ("Couldn't parse x3d syntax.");
			}
		},
		importDocument: function (scene, dom, success, error)
		{
			try
			{
				if (success)
				{
					success = function (scene, success, error)
					{
						this .setScene (scene, success, error);
					}
					.bind (this, scene, success, error);
				}

				new XMLParser (scene) .parseIntoScene (dom, success, error);

				//AP: add reference to dom for later access.
				this .node .dom = dom;
			}
			catch (exception)
			{
				delete this .node .dom;

				if (error)
					error (exception);
				else
					throw exception;
			}
		},
		importJS: function (scene, jsobj, success, error)
		{
			try
			{
				if (success)
				{
					success = function (scene, success, error)
					{
						this .setScene (scene, success, error);
					}
					.bind (this, scene, success, error);
				}

				//AP: add reference to dom for later access.
				this .node .dom = new JSONParser (scene) .parseJavaScript (jsobj, success, error);
			}
			catch (exception)
			{
				delete this .node .dom;

				if (error)
					error (exception);
				else
					throw exception;
			}
		},
		setScene: function (scene, success, error)
		{
			scene .initLoadCount_ .addInterest ("set_initLoadCount__", this, scene, success, error);
			scene .initLoadCount_ .addEvent ();
		},
		set_initLoadCount__: function (field, scene, success, error)
		{
			if (field .getValue ())
				return;

			scene .initLoadCount_ .removeInterest ("set_initLoadCount__", this);

			try
			{
				success (scene);
			}
			catch (exception)
			{
				if (error)
					error (exception);
				else
					throw exception;
			}

			if (DEBUG)
			{
				if (this .URL .length && this .URL .scheme !== "data")
					console .info ("Done loading scene " + this .URL);
			}
		},
		createX3DFromURL: function (url, parameter, callback, bindViewpoint, foreign)
		{
			this .bindViewpoint = bindViewpoint;
			this .foreign       = foreign;
			this .target        = this .getTarget (parameter || defaultParameter);

			if (callback)
				return this .loadDocument (url, this .createX3DFromURLAsync .bind (this, callback));

			return this .createX3DFromURLSync (url);
		},
		createX3DFromURLAsync: function (callback, data)
		{
			if (data === null)
				callback (null);
			else
				this .createX3DFromString (this .URL, data, callback, this .loadDocumentError .bind (this));
		},
		createX3DFromURLSync: function (url)
		{
			if (url .length === 0)
				throw new Error ("No URL given.");

			var
				scene   = null,
				success = false;

			for (var i = 0; i < url .length; ++ i)
			{
				this .URL = this .transform (url [i]);

				$.ajax ({
					url: this .URL .escape (),
					dataType: "text",
					async: false,
					cache: this .browser .getBrowserOptions () .getCache (),
					//timeout: 15000,
					global: false,
					context: this,
					success: function (data)
					{
						try
						{
							scene   = this .createX3DFromString (this .URL, data);
							success = true;
						}
						catch (exception)
						{
							this .error (exception);
						}
					},
					error: function (jqXHR, textStatus, errorThrown)
					{
						//console .warn ("Couldn't load URL '" + this .URL .toString () + "': " + errorThrown + ".");
					},
				});

				if (success)
					break;
			}

			if (success)
				return scene;

			throw new Error ("Couldn't load any url of '" + url .getValue () .join (", ") + "'.");
		},
		loadScript: function (url, callback)
		{
			this .script = true;

			this .loadDocument (url, callback);
		},
		loadDocument: function (url, callback)
		{
			this .url       = url .copy ();
			this .callback  = callback;

			if (url .length === 0)
				return this .loadDocumentError (new Error ("No URL given."));

			this .loadDocumentAsync (this .url .shift ());
		},
		loadBinaryDocument: function (url, callback)
		{
			this .url       = url .copy ();
			this .callback  = callback;
			this .text      = false;

			if (url .length === 0)
				return this .loadDocumentError (new Error ("No URL given."));

			this .loadDocumentAsync (this .url .shift ());
		},
		getTarget: function (parameter)
		{
			for (var i = 0, length = parameter .length; i < length; ++ i)
			{
				var pair = parameter [i] .split ("=");

				if (pair .length !== 2)
					continue;

				if (pair [0] === "target")
					return pair [1];
			}

			return "";
		},
		loadDocumentAsync: function (URL)
		{
			var uri = new URI (URL);

			if (URL .length == 0)
			{
				this .loadDocumentError (new Error ("URL is empty."));
				return;
			}

			try
			{
				if (this .bindViewpoint)
				{
					if (uri .filename .toString () .length === 0 && uri .query .length === 0)
					{
						this .bindViewpoint (uri .fragment);
						return;
					}
				}
			}
			catch (exception)
			{
				this .loadDocumentError (exception);
				return;
			}

			if (this .script)
			{
				try
				{
					var result = ECMAScript .exec (URL);

					if (result)
					{
						this .callback (result [1]);
						return;
					}
				}
				catch (exception)
				{
					this .loadDocumentError (exception);
					return;
				}
			}

			// Test for data URL here.

			this .URL = this .transform (URL);

			try
			{
				var result = dataURL .exec (URL);

				if (result)
				{
					//var mimeType = result [1];

					// ??? If called from loadURL and mime type is text/html do a window.open or window.location=URL and return; ???

					var data = result [4];

					if (result [3] === "base64")
						data = atob (data);
					else
						data = unescape (data);

					if (this .target .length && this .target !== "_self" && this .foreign)
						return this .foreign (this .URL .toString () .replace (urls .getFallbackExpression (), ""), this .target);

					this .callback (data);
					return;
				}
			}
			catch (exception)
			{
				this .loadDocumentError (exception);
				return;
			}

			// Handle target

			if (this .target .length && this .target !== "_self" && this .foreign)
				return this .foreign (this .URL .toString () .replace (urls .getFallbackExpression (), ""), this .target);

			// Handle well known foreign content depending on extension or if path looks like directory.

			if (this .foreign)
			{
				if (this .URL .extension .match (foreignExtensions))
				{
					return this .foreign (this .URL .toString () .replace (urls .getFallbackExpression (), ""), this .target);
				}
			}

			// Load URL async

			$.ajax ({
				url: this .URL .escape (),
				dataType: "binary",
				async: true,
				cache: this .browser .getBrowserOptions () .getCache (),
				//timeout: 15000,
				global: false,
				context: this,
				success: function (blob, status, xhr)
				{
					if (this .foreign)
					{
						//console .log (this .getContentType (xhr));

						if (foreign [this .getContentType (xhr)])
							return this .foreign (this .URL .toString () .replace (urls .getFallbackExpression (), ""), this .target);
					}

					if (this .text)
					{
						this .fileReader .onload = this .readAsArrayBuffer .bind (this, blob);

						this .fileReader .readAsArrayBuffer (blob);
					}
					else
					{
						this .fileReader .onload = this .readAsBinaryString .bind (this);

						this .fileReader .readAsBinaryString (blob);
					}
				},
				error: function (xhr, textStatus, exception)
				{
					this .loadDocumentError (new Error (exception));
				},
			});
		},
		readAsArrayBuffer: function (blob)
		{
			try
			{
				this .callback (pako .ungzip (this .fileReader .result, { to: "string" }));
			}
			catch (exception)
			{
				this .fileReader .onload = this .readAsText .bind (this, blob);

				this .fileReader .readAsText (blob);
			}
		},
		readAsText: function (blob)
		{
			try
			{
				this .callback (this .fileReader .result);
			}
			catch (exception)
			{
				this .loadDocumentError (exception);
			}
		},
		readAsBinaryString: function ()
		{
			try
			{
				this .callback (this .fileReader .result);
			}
			catch (exception)
			{
				this .loadDocumentError (exception);
			}
		},
		loadDocumentError: function (exception)
		{
			// Output exception.

			this .error (exception);

			// Try to load next URL.

			if (this .url .length)
				this .loadDocumentAsync (this .url .shift ());

			else
				this .callback (null);
		},
		error: function (exception)
		{
			if (this .URL .scheme === "data")
				console .warn ("Couldn't load URL 'data':", exception .message);
			else
				console .warn ("Couldn't load URL '" + this .URL + "':", exception .message);

			if (DEBUG)
				console .log (exception);
		},
		transform: function (sURL)
		{
			var URL = this .getReferer () .transform (new URI (sURL));

			if (URL .isLocal () || URL .host === "localhost")
			{
				URL = this .browser .getLocation () .getRelativePath (URL);
			}
			else
			{
				if (DEBUG)
				{
					if (! sURL .match (urls .getFallbackExpression ()))
						this .url .unshift (urls .getFallbackUrl (URL));
				}
			}

			return URL;
		},
		getReferer: function ()
		{
			if (this .node .getTypeName () === "World")
			{
				if (this .external)
					return this .browser .getLocation ();
			}

			return this .executionContext .getURL ();
		},
		getContentType: function (xhr)
		{
			var
				contentType = xhr .getResponseHeader ("Content-Type"),
				result      = contentTypeRx .exec (contentType);

			if (result)
				return result [1];

			return "";
		},
	});

	return FileLoader;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/ShaderPart',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Browser/Shaders/Shader",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Networking/X3DUrlObject",
	"x_ite/InputOutput/FileLoader",
	"x_ite/Bits/X3DConstants",
	"x_ite/DEBUG",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          Shader,
          X3DNode,
          X3DUrlObject,
          FileLoader,
          X3DConstants,
          DEBUG)
{
"use strict";

	var shaderTypes =
	{
		VERTEX:          "VERTEX_SHADER",
		TESS_CONTROL:    "TESS_CONTROL_SHADER",
		TESS_EVALUATION: "TESS_EVALUATION_SHADER",
		GEOMETRY:        "GEOMETRY_SHADER",
		FRAGMENT:        "FRAGMENT_SHADER",
		COMPUTE:         "COMPUTE_SHADER",
	};

	function ShaderPart (executionContext)
	{
		X3DNode      .call (this, executionContext);
		X3DUrlObject .call (this, executionContext);

		this .addType (X3DConstants .ShaderPart);

		this .addChildObjects ("buffer", new Fields .MFString ());

		this .valid = false;
	}

	ShaderPart .prototype = Object .assign (Object .create (X3DNode .prototype),
		X3DUrlObject .prototype,
	{
		constructor: ShaderPart,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "type",     new Fields .SFString ("VERTEX")),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "url",      new Fields .MFString ()),
		]),
		getTypeName: function ()
		{
			return "ShaderPart";
		},
		getComponentName: function ()
		{
			return "Shaders";
		},
		getContainerField: function ()
		{
			return "parts";
		},
		initialize: function ()
		{
			X3DNode      .prototype .initialize .call (this);
			X3DUrlObject .prototype .initialize .call (this);

			var gl = this .getBrowser () .getContext ();

			this .shader = gl .createShader (gl [this .getShaderType ()]);

			this .url_    .addInterest ("set_url__",    this);
			this .buffer_ .addInterest ("set_buffer__", this);

			this .set_url__ ();
		},
		set_url__: function ()
		{
			this .setLoadState (X3DConstants .NOT_STARTED_STATE);

			this .requestAsyncLoad ();
		},
		isValid: function ()
		{
			return this .valid;
		},
		getShader: function ()
		{
			return this .shader;
		},
		getShaderType: function ()
		{
			var type = shaderTypes [this .type_ .getValue ()];

			if (type)
				return type;

			return "VERTEX_SHADER";
		},
		getSourceText: function ()
		{
			return this .url_;
		},
		setShadow: function (value)
		{
			this .shadow = value;
		},
		getShadow: function ()
		{
			return this .shadow;
		},
		requestAsyncLoad: function ()
		{
			if (this .checkLoadState () == X3DConstants .COMPLETE_STATE || this .checkLoadState () == X3DConstants .IN_PROGRESS_STATE)
				return;

			this .setLoadState (X3DConstants .IN_PROGRESS_STATE);

			this .buffer_ = this .url_;
		},
		set_buffer__: function ()
		{
			this .valid = false;

			new FileLoader (this) .loadDocument (this .buffer_,
			function (data)
			{
				if (data === null)
				{
					// No URL could be loaded.
					this .setLoadState (X3DConstants .FAILED_STATE);
				}
				else
				{
					var
						gl     = this .getBrowser () .getContext (),
						source = Shader .getShaderSource (this .getBrowser (), this .getName (), data, this .shadow);

					gl .shaderSource (this .shader, source);
					gl .compileShader (this .shader);

					this .valid = gl .getShaderParameter (this .shader, gl .COMPILE_STATUS);

					if (! this .valid)
						throw new Error (this .getTypeName () + " '" + this .getName () + "': " + gl .getShaderInfoLog (this .shader));

					this .setLoadState (X3DConstants .COMPLETE_STATE);
				}
			}
			.bind (this));
		},
	});

	return ShaderPart;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Plane3',[
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
],
function (Vector3,
          Matrix4)
{
"use strict";

	var
		normal    = new Vector3 (0, 0, 0),
		point     = new Vector3 (0, 0, 0),
		invMatrix = new Matrix4 ();

	function Plane3 (point, normal)
	{
		this .normal             = normal .copy ();
		this .distanceFromOrigin = normal .dot (point);
	}

	Plane3 .prototype =
	{
		constructor: Plane3,
		copy: function ()
		{
			var copy = Object .create (Plane3 .prototype);
			copy .normal             = this .normal .copy ();
			copy .distanceFromOrigin = this .distanceFromOrigin;
			return copy;
		},
		assign: function (plane)
		{
			this .normal .assign (plane .normal);
			this .distanceFromOrigin = plane .distanceFromOrigin;
			return this;
		},
		set: function (point, normal)
		{
			this .normal .assign (normal);
			this .distanceFromOrigin = normal .dot (point);	   
			return this;
		},
		multRight: function (matrix)
		//throw
		{
			// Taken from Inventor:
		
			// Find the point on the plane along the normal from the origin
			point .assign (this .normal) .multiply (this .distanceFromOrigin);
		
			// Transform the plane normal by the matrix
			// to get the new normal. Use the inverse transpose
			// of the matrix so that normals are not scaled incorrectly.
			// n' = n * !~m = ~m * n
			invMatrix .assign (matrix) .inverse ();
			invMatrix .multMatrixDir (normal .assign (this .normal)) .normalize ();
		
			// Transform the point by the matrix
			matrix .multVecMatrix (point);
		
			// The new distance is the projected distance of the vector to the
			// transformed point onto the (unit) transformed normal. This is
			// just a dot product.
			this .normal .assign (normal);
			this .distanceFromOrigin = normal .dot (point);

			return this;
		},
		multLeft: function (matrix)
		//throw
		{
			// Taken from Inventor:
		
			// Find the point on the plane along the normal from the origin
			point .assign (this .normal) .multiply (this .distanceFromOrigin);
		
			// Transform the plane normal by the matrix
			// to get the new normal. Use the inverse transpose
			// of the matrix so that normals are not scaled incorrectly.
			// n' = !~m * n = n * ~m
			invMatrix .assign (matrix) .inverse ();
			invMatrix .multDirMatrix (normal .assign (this .normal)) .normalize ();
		
			// Transform the point by the matrix
			matrix .multMatrixVec (point);
		
			// The new distance is the projected distance of the vector to the
			// transformed point onto the (unit) transformed normal. This is
			// just a dot product.
			this .normal .assign (normal);
			this .distanceFromOrigin = normal .dot (point);

			return this;
		},
		getDistanceToPoint: function (point)
		{
			return Vector3 .dot (point, this .normal) - this .distanceFromOrigin;
		},
		intersectsLine: function (line, intersection)
		{
			var
				point     = line .point,
				direction = line .direction;
		
			// Check if the line is parallel to the plane.
			var theta = direction .dot (this .normal);

			// Plane and line are parallel.
			if (theta === 0)
				return false;

			// Plane and line are not parallel. The intersection point can be calculated now.
			var t = (this .distanceFromOrigin - this .normal .dot (point)) / theta;

			intersection .x = point .x + direction .x * t;
			intersection .y = point .y + direction .y * t;
			intersection .z = point .z + direction .z * t;

			return true;
		},
		toString: function ()
		{
			return this .normal .toString () + " " + this .distanceFromOrigin;
		},
	};

	return Plane3;
});

/**
 * @license
 * Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.
 * Copyright 2015, Google Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Original Code. The Original Code is: OpenGL Sample Implementation,
 * Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
 * Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
 * Copyright in any portions created by third parties is as indicated
 * elsewhere herein. All Rights Reserved.
 */
/**
 * @author ericv@cs.stanford.edu (Eric Veach)
 * @author bckenny@google.com (Brendan Kenny)
 */

/**
 * Base namespace.
 * @const
 */
var libtess = {};

/**
 * Whether to run asserts and extra debug checks.
 * @define {boolean}
 */
libtess.DEBUG = false;

/**
 * Checks if the condition evaluates to true if libtess.DEBUG is true.
 * @param {*} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @throws {Error} Assertion failed, the condition evaluates to false.
 */
libtess.assert = function(condition, opt_message) {
  if (libtess.DEBUG && !condition) {
    throw new Error('Assertion failed' +
        (opt_message ? ': ' + opt_message : ''));
  }
};

/**
 * The maximum vertex coordinate size, 1e150. Anything larger will trigger a
 * GLU_TESS_COORD_TOO_LARGE error callback and the vertex will be clamped to
 * this value for all tessellation calculations.
 * @const {number}
 */
libtess.GLU_TESS_MAX_COORD = 1e150;
// NOTE(bckenny): value from glu.pl generator

/**
 * Normally the polygon is projected to a plane perpendicular to one of the
 * three coordinate axes before tessellating in 2d. This helps numerical
 * accuracy by forgoing a transformation step by simply dropping one coordinate
 * dimension.
 *
 * However, this can affect the placement of intersection points for non-axis-
 * aligned polygons. Setting TRUE_PROJECT to true will instead project onto a
 * plane actually perpendicular to the polygon's normal.
 *
 * NOTE(bckenny): I can find no instances on the internet in which this mode has
 * been used, but it's difficult to search for. This was a compile-time setting
 * in the original, so setting this as constant. If this is exposed in the
 * public API, remove the ignore coverage directives on
 * libtess.normal.projectPolygon and libtess.normal.normalize_.
 * @const {boolean}
 */
libtess.TRUE_PROJECT = false;

/**
 * The default tolerance for merging features, 0, meaning vertices are only
 * merged if they are exactly coincident
 * If a higher tolerance is needed, significant rewriting will need to occur.
 * See libtess.sweep.TOLERANCE_NONZERO_ as a starting place.
 * @const {number}
 */
libtess.GLU_TESS_DEFAULT_TOLERANCE = 0;

/**
 * The input contours parition the plane into regions. A winding
 * rule determines which of these regions are inside the polygon.
 *
 * For a single contour C, the winding number of a point x is simply
 * the signed number of revolutions we make around x as we travel
 * once around C (where CCW is positive). When there are several
 * contours, the individual winding numbers are summed. This
 * procedure associates a signed integer value with each point x in
 * the plane. Note that the winding number is the same for all
 * points in a single region.
 *
 * The winding rule classifies a region as "inside" if its winding
 * number belongs to the chosen category (odd, nonzero, positive,
 * negative, or absolute value of at least two). The current GLU
 * tesselator implements the "odd" rule. The "nonzero" rule is another
 * common way to define the interior. The other three rules are
 * useful for polygon CSG operations.
 * @enum {number}
 */
libtess.windingRule = {
  // NOTE(bckenny): values from enumglu.spec
  GLU_TESS_WINDING_ODD: 100130,
  GLU_TESS_WINDING_NONZERO: 100131,
  GLU_TESS_WINDING_POSITIVE: 100132,
  GLU_TESS_WINDING_NEGATIVE: 100133,
  GLU_TESS_WINDING_ABS_GEQ_TWO: 100134
};

/**
 * The type of primitive return from a "begin" callback. GL_LINE_LOOP is only
 * returned when GLU_TESS_BOUNDARY_ONLY is true. GL_TRIANGLE_STRIP and
 * GL_TRIANGLE_FAN are no longer returned since 1.1.0 (see release notes).
 * @enum {number}
 */
libtess.primitiveType = {
  GL_LINE_LOOP: 2,
  GL_TRIANGLES: 4,
  GL_TRIANGLE_STRIP: 5,
  GL_TRIANGLE_FAN: 6
};

/**
 * The types of errors provided in the error callback.
 * @enum {number}
 */
libtess.errorType = {
  // TODO(bckenny) doc types
  // NOTE(bckenny): values from enumglu.spec
  GLU_TESS_MISSING_BEGIN_POLYGON: 100151,
  GLU_TESS_MISSING_END_POLYGON: 100153,
  GLU_TESS_MISSING_BEGIN_CONTOUR: 100152,
  GLU_TESS_MISSING_END_CONTOUR: 100154,
  GLU_TESS_COORD_TOO_LARGE: 100155,
  GLU_TESS_NEED_COMBINE_CALLBACK: 100156
};

/**
 * Enum values necessary for providing settings and callbacks. See the readme
 * for details.
 * @enum {number}
 */
libtess.gluEnum = {
  // TODO(bckenny): rename so not always typing libtess.gluEnum.*?

  // NOTE(bckenny): values from enumglu.spec
  GLU_TESS_BEGIN: 100100,
  GLU_TESS_VERTEX: 100101,
  GLU_TESS_END: 100102,
  GLU_TESS_ERROR: 100103,
  GLU_TESS_EDGE_FLAG: 100104,
  GLU_TESS_COMBINE: 100105,
  GLU_TESS_BEGIN_DATA: 100106,
  GLU_TESS_VERTEX_DATA: 100107,
  GLU_TESS_END_DATA: 100108,
  GLU_TESS_ERROR_DATA: 100109,
  GLU_TESS_EDGE_FLAG_DATA: 100110,
  GLU_TESS_COMBINE_DATA: 100111,

  GLU_TESS_MESH: 100112,  //  NOTE(bckenny): from tess.c
  GLU_TESS_TOLERANCE: 100142,
  GLU_TESS_WINDING_RULE: 100140,
  GLU_TESS_BOUNDARY_ONLY: 100141,

  // TODO(bckenny): move this to libtess.errorType?
  GLU_INVALID_ENUM: 100900,
  GLU_INVALID_VALUE: 100901
};

/** @typedef {number} */
libtess.PQHandle;

/* global libtess */

/** @const */
libtess.geom = {};

/**
 * Returns whether vertex u and vertex v are equal.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @return {boolean}
 */
libtess.geom.vertEq = function(u, v) {
  return u.s === v.s && u.t === v.t;
};

/**
 * Returns whether vertex u is lexicographically less than or equal to vertex v.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @return {boolean}
 */
libtess.geom.vertLeq = function(u, v) {
  return (u.s < v.s) || (u.s === v.s && u.t <= v.t);
};

/**
 * Given three vertices u,v,w such that geom.vertLeq(u,v) && geom.vertLeq(v,w),
 * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
 * Returns v.t - (uw)(v.s), ie. the signed distance from uw to v.
 * If uw is vertical (and thus passes thru v), the result is zero.
 *
 * The calculation is extremely accurate and stable, even when v
 * is very close to u or w.  In particular if we set v.t = 0 and
 * let r be the negated result (this evaluates (uw)(v.s)), then
 * r is guaranteed to satisfy MIN(u.t,w.t) <= r <= MAX(u.t,w.t).
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @param {libtess.GluVertex} w
 * @return {number}
 */
libtess.geom.edgeEval = function(u, v, w) {

  var gapL = v.s - u.s;
  var gapR = w.s - v.s;

  if (gapL + gapR > 0) {
    if (gapL < gapR) {
      return (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));
    } else {
      return (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));
    }
  }

  // vertical line
  return 0;
};

/**
 * Returns a number whose sign matches geom.edgeEval(u,v,w) but which
 * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
 * as v is above, on, or below the edge uw.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @param {libtess.GluVertex} w
 * @return {number}
 */
libtess.geom.edgeSign = function(u, v, w) {

  var gapL = v.s - u.s;
  var gapR = w.s - v.s;

  if (gapL + gapR > 0) {
    return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
  }

  // vertical line
  return 0;
};

/**
 * Version of VertLeq with s and t transposed.
 * Returns whether vertex u is lexicographically less than or equal to vertex v.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @return {boolean}
 */
libtess.geom.transLeq = function(u, v) {
  return (u.t < v.t) || (u.t === v.t && u.s <= v.s);
};

/**
 * Version of geom.edgeEval with s and t transposed.
 * Given three vertices u,v,w such that geom.transLeq(u,v) &&
 * geom.transLeq(v,w), evaluates the t-coord of the edge uw at the s-coord of
 * the vertex v. Returns v.s - (uw)(v.t), ie. the signed distance from uw to v.
 * If uw is vertical (and thus passes thru v), the result is zero.
 *
 * The calculation is extremely accurate and stable, even when v
 * is very close to u or w.  In particular if we set v.s = 0 and
 * let r be the negated result (this evaluates (uw)(v.t)), then
 * r is guaranteed to satisfy MIN(u.s,w.s) <= r <= MAX(u.s,w.s).
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @param {libtess.GluVertex} w
 * @return {number}
 */
libtess.geom.transEval = function(u, v, w) {

  var gapL = v.t - u.t;
  var gapR = w.t - v.t;

  if (gapL + gapR > 0) {
    if (gapL < gapR) {
      return (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));
    } else {
      return (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));
    }
  }

  // vertical line
  return 0;
};

/**
 * Version of geom.edgeSign with s and t transposed.
 * Returns a number whose sign matches geom.transEval(u,v,w) but which
 * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
 * as v is above, on, or below the edge uw.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @param {libtess.GluVertex} w
 * @return {number}
 */
libtess.geom.transSign = function(u, v, w) {

  var gapL = v.t - u.t;
  var gapR = w.t - v.t;

  if (gapL + gapR > 0) {
    return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
  }

  // vertical line
  return 0;
};

/**
 * Returns whether edge is directed from right to left.
 * @param {libtess.GluHalfEdge} e
 * @return {boolean}
 */
libtess.geom.edgeGoesLeft = function(e) {
  return libtess.geom.vertLeq(e.dst(), e.org);
};

/**
 * Returns whether edge is directed from left to right.
 * @param {libtess.GluHalfEdge} e
 * @return {boolean}
 */
libtess.geom.edgeGoesRight = function(e) {
  return libtess.geom.vertLeq(e.org, e.dst());
};

/**
 * Calculates the L1 distance between vertices u and v.
 * @param {libtess.GluVertex} u
 * @param {libtess.GluVertex} v
 * @return {number}
 */
libtess.geom.vertL1dist = function(u, v) {
  return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
};

// NOTE(bckenny): vertCCW is called nowhere in libtess and isn't part of the
// public API.
/* istanbul ignore next */
/**
 * For almost-degenerate situations, the results are not reliable.
 * Unless the floating-point arithmetic can be performed without
 * rounding errors, *any* implementation will give incorrect results
 * on some degenerate inputs, so the client must have some way to
 * handle this situation.
 * @param {!libtess.GluVertex} u
 * @param {!libtess.GluVertex} v
 * @param {!libtess.GluVertex} w
 * @return {boolean}
 */
libtess.geom.vertCCW = function(u, v, w) {
  return (u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t)) >= 0;
};

/**
 * Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
 * or (x+y)/2 if a==b==0. It requires that a,b >= 0, and enforces
 * this in the rare case that one argument is slightly negative.
 * The implementation is extremely stable numerically.
 * In particular it guarantees that the result r satisfies
 * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
 * even when a and b differ greatly in magnitude.
 * @private
 * @param {number} a
 * @param {number} x
 * @param {number} b
 * @param {number} y
 * @return {number}
 */
libtess.geom.interpolate_ = function(a, x, b, y) {
  // from Macro RealInterpolate:
  //(a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b == 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))))
  a = (a < 0) ? 0 : a;
  b = (b < 0) ? 0 : b;

  if (a <= b) {
    if (b === 0) {
      return (x + y) / 2;
    } else {
      return x + (y - x) * (a / (a + b));
    }
  } else {
    return y + (x - y) * (b / (a + b));
  }
};

/**
 * Given edges (o1,d1) and (o2,d2), compute their point of intersection.
 * The computed point is guaranteed to lie in the intersection of the
 * bounding rectangles defined by each edge.
 * @param {!libtess.GluVertex} o1
 * @param {!libtess.GluVertex} d1
 * @param {!libtess.GluVertex} o2
 * @param {!libtess.GluVertex} d2
 * @param {!libtess.GluVertex} v
 */
libtess.geom.edgeIntersect = function(o1, d1, o2, d2, v) {
  // This is certainly not the most efficient way to find the intersection
  // of two line segments, but it is very numerically stable.

  // Strategy: find the two middle vertices in the VertLeq ordering,
  // and interpolate the intersection s-value from these. Then repeat
  // using the TransLeq ordering to find the intersection t-value.
  var z1;
  var z2;
  var tmp;
  if (!libtess.geom.vertLeq(o1, d1)) {
    // Swap(o1, d1);
    tmp = o1;
    o1 = d1;
    d1 = tmp;
  }
  if (!libtess.geom.vertLeq(o2, d2)) {
    // Swap(o2, d2);
    tmp = o2;
    o2 = d2;
    d2 = tmp;
  }
  if (!libtess.geom.vertLeq(o1, o2)) {
    // Swap(o1, o2);
    tmp = o1;
    o1 = o2;
    o2 = tmp;
    // Swap(d1, d2);
    tmp = d1;
    d1 = d2;
    d2 = tmp;
  }

  if (!libtess.geom.vertLeq(o2, d1)) {
    // Technically, no intersection -- do our best
    v.s = (o2.s + d1.s) / 2;

  } else if (libtess.geom.vertLeq(d1, d2)) {
    // Interpolate between o2 and d1
    z1 = libtess.geom.edgeEval(o1, o2, d1);
    z2 = libtess.geom.edgeEval(o2, d1, d2);
    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
    v.s = libtess.geom.interpolate_(z1, o2.s, z2, d1.s);

  } else {
    // Interpolate between o2 and d2
    z1 = libtess.geom.edgeSign(o1, o2, d1);
    z2 = -libtess.geom.edgeSign(o1, d2, d1);
    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
    v.s = libtess.geom.interpolate_(z1, o2.s, z2, d2.s);
  }

  // Now repeat the process for t
  if (!libtess.geom.transLeq(o1, d1)) {
    // Swap(o1, d1);
    tmp = o1;
    o1 = d1;
    d1 = tmp;
  }
  if (!libtess.geom.transLeq(o2, d2)) {
    // Swap(o2, d2);
    tmp = o2;
    o2 = d2;
    d2 = tmp;
  }
  if (!libtess.geom.transLeq(o1, o2)) {
    // Swap(o1, o2);
    tmp = o1;
    o1 = o2;
    o2 = tmp;
    // Swap(d1, d2);
    tmp = d1;
    d1 = d2;
    d2 = tmp;
  }

  if (!libtess.geom.transLeq(o2, d1)) {
    // Technically, no intersection -- do our best
    v.t = (o2.t + d1.t) / 2;

  } else if (libtess.geom.transLeq(d1, d2)) {
    // Interpolate between o2 and d1
    z1 = libtess.geom.transEval(o1, o2, d1);
    z2 = libtess.geom.transEval(o2, d1, d2);
    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
    v.t = libtess.geom.interpolate_(z1, o2.t, z2, d1.t);

  } else {
    // Interpolate between o2 and d2
    z1 = libtess.geom.transSign(o1, o2, d1);
    z2 = -libtess.geom.transSign(o1, d2, d1);
    if (z1 + z2 < 0) { z1 = -z1; z2 = -z2; }
    v.t = libtess.geom.interpolate_(z1, o2.t, z2, d2.t);
  }
};

/* global libtess */

// TODO(bckenny): could maybe merge GluMesh and mesh.js since these are
// operations on the mesh

/** @const */
libtess.mesh = {};

/****************** Basic Edge Operations **********************/


/**
 * makeEdge creates one edge, two vertices, and a loop (face).
 * The loop consists of the two new half-edges.
 *
 * @param {libtess.GluMesh} mesh [description].
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.mesh.makeEdge = function(mesh) {
  // TODO(bckenny): probably move to GluMesh, but needs Make* methods with it

  var e = libtess.mesh.makeEdgePair_(mesh.eHead);

  // complete edge with vertices and face (see mesh.makeEdgePair_)
  libtess.mesh.makeVertex_(e, mesh.vHead);
  libtess.mesh.makeVertex_(e.sym, mesh.vHead);
  libtess.mesh.makeFace_(e, mesh.fHead);

  return e;
};


/**
 * meshSplice(eOrg, eDst) is the basic operation for changing the
 * mesh connectivity and topology. It changes the mesh so that
 *  eOrg.oNext <- OLD( eDst.oNext )
 *  eDst.oNext <- OLD( eOrg.oNext )
 * where OLD(...) means the value before the meshSplice operation.
 *
 * This can have two effects on the vertex structure:
 *  - if eOrg.org != eDst.org, the two vertices are merged together
 *  - if eOrg.org == eDst.org, the origin is split into two vertices
 * In both cases, eDst.org is changed and eOrg.org is untouched.
 *
 * Similarly (and independently) for the face structure,
 *  - if eOrg.lFace == eDst.lFace, one loop is split into two
 *  - if eOrg.lFace != eDst.lFace, two distinct loops are joined into one
 * In both cases, eDst.lFace is changed and eOrg.lFace is unaffected.
 *
 * Some special cases:
 * If eDst == eOrg, the operation has no effect.
 * If eDst == eOrg.lNext, the new face will have a single edge.
 * If eDst == eOrg.lPrev(), the old face will have a single edge.
 * If eDst == eOrg.oNext, the new vertex will have a single edge.
 * If eDst == eOrg.oPrev(), the old vertex will have a single edge.
 *
 * @param {libtess.GluHalfEdge} eOrg [description].
 * @param {libtess.GluHalfEdge} eDst [description].
 */
libtess.mesh.meshSplice = function(eOrg, eDst) {
  // TODO: more descriptive name?

  var joiningLoops = false;
  var joiningVertices = false;

  if (eOrg === eDst) {
    return;
  }

  if (eDst.org !== eOrg.org) {
    // We are merging two disjoint vertices -- destroy eDst.org
    joiningVertices = true;
    libtess.mesh.killVertex_(eDst.org, eOrg.org);
  }

  if (eDst.lFace !== eOrg.lFace) {
    // We are connecting two disjoint loops -- destroy eDst.lFace
    joiningLoops = true;
    libtess.mesh.killFace_(eDst.lFace, eOrg.lFace);
  }

  // Change the edge structure
  libtess.mesh.splice_(eDst, eOrg);

  if (!joiningVertices) {
    // We split one vertex into two -- the new vertex is eDst.org.
    // Make sure the old vertex points to a valid half-edge.
    libtess.mesh.makeVertex_(eDst, eOrg.org);
    eOrg.org.anEdge = eOrg;
  }

  if (!joiningLoops) {
    // We split one loop into two -- the new loop is eDst.lFace.
    // Make sure the old face points to a valid half-edge.
    libtess.mesh.makeFace_(eDst, eOrg.lFace);
    eOrg.lFace.anEdge = eOrg;
  }
};


/**
 * deleteEdge(eDel) removes the edge eDel. There are several cases:
 * if (eDel.lFace != eDel.rFace()), we join two loops into one; the loop
 * eDel.lFace is deleted. Otherwise, we are splitting one loop into two;
 * the newly created loop will contain eDel.dst(). If the deletion of eDel
 * would create isolated vertices, those are deleted as well.
 *
 * This function could be implemented as two calls to __gl_meshSplice
 * plus a few calls to memFree, but this would allocate and delete
 * unnecessary vertices and faces.
 *
 * @param {libtess.GluHalfEdge} eDel [description].
 */
libtess.mesh.deleteEdge = function(eDel) {
  var eDelSym = eDel.sym;
  var joiningLoops = false;

  // First step: disconnect the origin vertex eDel.org.  We make all
  // changes to get a consistent mesh in this "intermediate" state.
  if (eDel.lFace !== eDel.rFace()) {
    // We are joining two loops into one -- remove the left face
    joiningLoops = true;
    libtess.mesh.killFace_(eDel.lFace, eDel.rFace());
  }

  if (eDel.oNext === eDel) {
    libtess.mesh.killVertex_(eDel.org, null);

  } else {
    // Make sure that eDel.org and eDel.rFace() point to valid half-edges
    eDel.rFace().anEdge = eDel.oPrev();
    eDel.org.anEdge = eDel.oNext;

    libtess.mesh.splice_(eDel, eDel.oPrev());

    if (!joiningLoops) {
      // We are splitting one loop into two -- create a new loop for eDel.
      libtess.mesh.makeFace_(eDel, eDel.lFace);
    }
  }

  // Claim: the mesh is now in a consistent state, except that eDel.org
  // may have been deleted.  Now we disconnect eDel.dst().
  if (eDelSym.oNext === eDelSym) {
    libtess.mesh.killVertex_(eDelSym.org, null);
    libtess.mesh.killFace_(eDelSym.lFace, null);

  } else {
    // Make sure that eDel.dst() and eDel.lFace point to valid half-edges
    eDel.lFace.anEdge = eDelSym.oPrev();
    eDelSym.org.anEdge = eDelSym.oNext;
    libtess.mesh.splice_(eDelSym, eDelSym.oPrev());
  }

  // Any isolated vertices or faces have already been freed.
  libtess.mesh.killEdge_(eDel);
};

/******************** Other Edge Operations **********************/

/* All these routines can be implemented with the basic edge
 * operations above.  They are provided for convenience and efficiency.
 */


/**
 * addEdgeVertex(eOrg) creates a new edge eNew such that
 * eNew == eOrg.lNext, and eNew.dst() is a newly created vertex.
 * eOrg and eNew will have the same left face.
 *
 * @param {libtess.GluHalfEdge} eOrg [description].
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.mesh.addEdgeVertex = function(eOrg) {
  // TODO(bckenny): why is it named this?

  var eNew = libtess.mesh.makeEdgePair_(eOrg);
  var eNewSym = eNew.sym;

  // Connect the new edge appropriately
  libtess.mesh.splice_(eNew, eOrg.lNext);

  // Set the vertex and face information
  eNew.org = eOrg.dst();

  libtess.mesh.makeVertex_(eNewSym, eNew.org);

  eNew.lFace = eNewSym.lFace = eOrg.lFace;

  return eNew;
};


/**
 * splitEdge(eOrg) splits eOrg into two edges eOrg and eNew,
 * such that eNew == eOrg.lNext. The new vertex is eOrg.dst() == eNew.org.
 * eOrg and eNew will have the same left face.
 *
 * @param {libtess.GluHalfEdge} eOrg [description].
 * @return {!libtess.GluHalfEdge} [description].
 */
libtess.mesh.splitEdge = function(eOrg) {
  var tempHalfEdge = libtess.mesh.addEdgeVertex(eOrg);
  var eNew = tempHalfEdge.sym;

  // Disconnect eOrg from eOrg.dst() and connect it to eNew.org
  libtess.mesh.splice_(eOrg.sym, eOrg.sym.oPrev());
  libtess.mesh.splice_(eOrg.sym, eNew);

  // Set the vertex and face information
  eOrg.sym.org = eNew.org; // NOTE(bckenny): assignment to dst
  eNew.dst().anEdge = eNew.sym;  // may have pointed to eOrg.sym
  eNew.sym.lFace = eOrg.rFace(); // NOTE(bckenny): assignment to rFace
  eNew.winding = eOrg.winding;  // copy old winding information
  eNew.sym.winding = eOrg.sym.winding;

  return eNew;
};


/**
 * connect(eOrg, eDst) creates a new edge from eOrg.dst()
 * to eDst.org, and returns the corresponding half-edge eNew.
 * If eOrg.lFace == eDst.lFace, this splits one loop into two,
 * and the newly created loop is eNew.lFace. Otherwise, two disjoint
 * loops are merged into one, and the loop eDst.lFace is destroyed.
 *
 * If (eOrg == eDst), the new face will have only two edges.
 * If (eOrg.lNext == eDst), the old face is reduced to a single edge.
 * If (eOrg.lNext.lNext == eDst), the old face is reduced to two edges.
 *
 * @param {libtess.GluHalfEdge} eOrg [description].
 * @param {libtess.GluHalfEdge} eDst [description].
 * @return {!libtess.GluHalfEdge} [description].
 */
libtess.mesh.connect = function(eOrg, eDst) {
  var joiningLoops = false;
  var eNew = libtess.mesh.makeEdgePair_(eOrg);
  var eNewSym = eNew.sym;

  if (eDst.lFace !== eOrg.lFace) {
    // We are connecting two disjoint loops -- destroy eDst.lFace
    joiningLoops = true;
    libtess.mesh.killFace_(eDst.lFace, eOrg.lFace);
  }

  // Connect the new edge appropriately
  libtess.mesh.splice_(eNew, eOrg.lNext);
  libtess.mesh.splice_(eNewSym, eDst);

  // Set the vertex and face information
  eNew.org = eOrg.dst();
  eNewSym.org = eDst.org;
  eNew.lFace = eNewSym.lFace = eOrg.lFace;

  // Make sure the old face points to a valid half-edge
  eOrg.lFace.anEdge = eNewSym;

  if (!joiningLoops) {
    // We split one loop into two -- the new loop is eNew.lFace
    libtess.mesh.makeFace_(eNew, eOrg.lFace);
  }
  return eNew;
};

/******************** Other Operations **********************/


/**
 * zapFace(fZap) destroys a face and removes it from the
 * global face list. All edges of fZap will have a null pointer as their
 * left face. Any edges which also have a null pointer as their right face
 * are deleted entirely (along with any isolated vertices this produces).
 * An entire mesh can be deleted by zapping its faces, one at a time,
 * in any order. Zapped faces cannot be used in further mesh operations!
 *
 * @param {libtess.GluFace} fZap [description].
 */
libtess.mesh.zapFace = function(fZap) {
  var eStart = fZap.anEdge;

  // walk around face, deleting edges whose right face is also NULL
  var eNext = eStart.lNext;
  var e;
  do {
    e = eNext;
    eNext = e.lNext;

    e.lFace = null;
    if (e.rFace() === null) {
      // delete the edge -- see mesh.deleteEdge above
      if (e.oNext === e) {
        libtess.mesh.killVertex_(e.org, null);

      } else {
        // Make sure that e.org points to a valid half-edge
        e.org.anEdge = e.oNext;
        libtess.mesh.splice_(e, e.oPrev());
      }

      var eSym = e.sym;

      if (eSym.oNext === eSym) {
        libtess.mesh.killVertex_(eSym.org, null);

      } else {
        // Make sure that eSym.org points to a valid half-edge
        eSym.org.anEdge = eSym.oNext;
        libtess.mesh.splice_(eSym, eSym.oPrev());
      }
      libtess.mesh.killEdge_(e);
    }
  } while (e !== eStart);

  // delete from circular doubly-linked list
  var fPrev = fZap.prev;
  var fNext = fZap.next;
  fNext.prev = fPrev;
  fPrev.next = fNext;

  // TODO(bckenny): memFree( fZap );
  // TODO(bckenny): probably null at callsite
};

// TODO(bckenny): meshUnion isn't called within libtess and isn't part of the
// public API. Could be useful if more mesh manipulation functions are exposed.
/* istanbul ignore next */
/**
 * meshUnion() forms the union of all structures in
 * both meshes, and returns the new mesh (the old meshes are destroyed).
 *
 * @param {!libtess.GluMesh} mesh1
 * @param {!libtess.GluMesh} mesh2
 * @return {!libtess.GluMesh}
 */
libtess.mesh.meshUnion = function(mesh1, mesh2) {
  // TODO(bceknny): probably move to GluMesh method
  var f1 = mesh1.fHead;
  var v1 = mesh1.vHead;
  var e1 = mesh1.eHead;

  var f2 = mesh2.fHead;
  var v2 = mesh2.vHead;
  var e2 = mesh2.eHead;

  // Add the faces, vertices, and edges of mesh2 to those of mesh1
  if (f2.next !== f2) {
    f1.prev.next = f2.next;
    f2.next.prev = f1.prev;
    f2.prev.next = f1;
    f1.prev = f2.prev;
  }

  if (v2.next !== v2) {
    v1.prev.next = v2.next;
    v2.next.prev = v1.prev;
    v2.prev.next = v1;
    v1.prev = v2.prev;
  }

  if (e2.next !== e2) {
    e1.sym.next.sym.next = e2.next;
    e2.next.sym.next = e1.sym.next;
    e2.sym.next.sym.next = e1;
    e1.sym.next = e2.sym.next;
  }

  // TODO(bckenny): memFree(mesh2);
  // TODO(bckenny): If function is kept, remove mesh2's data to enforce.
  return mesh1;
};


/**
 * deleteMesh(mesh) will free all storage for any valid mesh.
 * @param {libtess.GluMesh} mesh [description].
 */
libtess.mesh.deleteMesh = function(mesh) {
  // TODO(bckenny): unnecessary, I think.
  // TODO(bckenny): might want to explicitly null at callsite
  // lots of memFrees. see also DELETE_BY_ZAPPING
};

/************************ Utility Routines ************************/


/**
 * Creates a new pair of half-edges which form their own loop.
 * No vertex or face structures are allocated, but these must be assigned
 * before the current edge operation is completed.
 *
 * TODO(bckenny): warning about eNext strictly being first of pair? (see code)
 *
 * @private
 * @param {libtess.GluHalfEdge} eNext [description].
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.mesh.makeEdgePair_ = function(eNext) {
  var e = new libtess.GluHalfEdge();
  var eSym = new libtess.GluHalfEdge();

  // TODO(bckenny): how do we ensure this? see above comment in jsdoc
  // Make sure eNext points to the first edge of the edge pair
  // if (eNext->Sym < eNext ) { eNext = eNext->Sym; }

  // NOTE(bckenny): check this for bugs in current implementation!

  // Insert in circular doubly-linked list before eNext.
  // Note that the prev pointer is stored in sym.next.
  var ePrev = eNext.sym.next;
  eSym.next = ePrev;
  ePrev.sym.next = e;
  e.next = eNext;
  eNext.sym.next = eSym;

  e.sym = eSym;
  e.oNext = e;
  e.lNext = eSym;

  eSym.sym = e;
  eSym.oNext = eSym;
  eSym.lNext = e;

  return e;
};


/**
 * splice_ is best described by the Guibas/Stolfi paper or the
 * CS348a notes. Basically, it modifies the mesh so that
 * a.oNext and b.oNext are exchanged. This can have various effects
 * depending on whether a and b belong to different face or vertex rings.
 * For more explanation see mesh.meshSplice below.
 *
 * @private
 * @param {libtess.GluHalfEdge} a [description].
 * @param {libtess.GluHalfEdge} b [description].
 */
libtess.mesh.splice_ = function(a, b) {
  var aONext = a.oNext;
  var bONext = b.oNext;

  aONext.sym.lNext = b;
  bONext.sym.lNext = a;
  a.oNext = bONext;
  b.oNext = aONext;
};


/**
 * makeVertex_(eOrig, vNext) attaches a new vertex and makes it the
 * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
 * a place to insert the new vertex in the global vertex list.  We insert
 * the new vertex *before* vNext so that algorithms which walk the vertex
 * list will not see the newly created vertices.
 *
 * NOTE: unlike original, acutally allocates new vertex.
 *
 * @private
 * @param {libtess.GluHalfEdge} eOrig [description].
 * @param {libtess.GluVertex} vNext [description].
 */
libtess.mesh.makeVertex_ = function(eOrig, vNext) {
  // insert in circular doubly-linked list before vNext
  var vPrev = vNext.prev;
  var vNew = new libtess.GluVertex(vNext, vPrev);
  vPrev.next = vNew;
  vNext.prev = vNew;

  vNew.anEdge = eOrig;
  // leave coords, s, t undefined
  // TODO(bckenny): does above line mean 0 specifically, or does it matter?

  // fix other edges on this vertex loop
  var e = eOrig;
  do {
    e.org = vNew;
    e = e.oNext;
  } while (e !== eOrig);
};


/**
 * makeFace_(eOrig, fNext) attaches a new face and makes it the left
 * face of all edges in the face loop to which eOrig belongs. "fNext" gives
 * a place to insert the new face in the global face list.  We insert
 * the new face *before* fNext so that algorithms which walk the face
 * list will not see the newly created faces.
 *
 * NOTE: unlike original, acutally allocates new face.
 *
 * @private
 * @param {libtess.GluHalfEdge} eOrig [description].
 * @param {libtess.GluFace} fNext [description].
 */
libtess.mesh.makeFace_ = function(eOrig, fNext) {
  // insert in circular doubly-linked list before fNext
  var fPrev = fNext.prev;
  var fNew = new libtess.GluFace(fNext, fPrev);
  fPrev.next = fNew;
  fNext.prev = fNew;

  fNew.anEdge = eOrig;

  // The new face is marked "inside" if the old one was.  This is a
  // convenience for the common case where a face has been split in two.
  fNew.inside = fNext.inside;

  // fix other edges on this face loop
  var e = eOrig;
  do {
    e.lFace = fNew;
    e = e.lNext;
  } while (e !== eOrig);
};


/**
 * killEdge_ destroys an edge (the half-edges eDel and eDel.sym),
 * and removes from the global edge list.
 *
 * @private
 * @param {libtess.GluHalfEdge} eDel [description].
 */
libtess.mesh.killEdge_ = function(eDel) {
  // TODO(bckenny): in this case, no need to worry(?), but check when checking mesh.makeEdgePair_
  // Half-edges are allocated in pairs, see EdgePair above
  // if (eDel->Sym < eDel ) { eDel = eDel->Sym; }

  // delete from circular doubly-linked list
  var eNext = eDel.next;
  var ePrev = eDel.sym.next;
  eNext.sym.next = ePrev;
  ePrev.sym.next = eNext;

  // TODO(bckenny): memFree( eDel ); (which also frees eDel.sym)
  // TODO(bckenny): need to null at callsites?
};


/**
 * killVertex_ destroys a vertex and removes it from the global
 * vertex list. It updates the vertex loop to point to a given new vertex.
 *
 * @private
 * @param {libtess.GluVertex} vDel [description].
 * @param {libtess.GluVertex} newOrg [description].
 */
libtess.mesh.killVertex_ = function(vDel, newOrg) {
  var eStart = vDel.anEdge;

  // change the origin of all affected edges
  var e = eStart;
  do {
    e.org = newOrg;
    e = e.oNext;
  } while (e !== eStart);

  // delete from circular doubly-linked list
  var vPrev = vDel.prev;
  var vNext = vDel.next;
  vNext.prev = vPrev;
  vPrev.next = vNext;

  // TODO(bckenny): memFree( vDel );
  // TODO(bckenny): need to null at callsites?
};


/**
 * killFace_ destroys a face and removes it from the global face
 * list. It updates the face loop to point to a given new face.
 *
 * @private
 * @param {libtess.GluFace} fDel [description].
 * @param {libtess.GluFace} newLFace [description].
 */
libtess.mesh.killFace_ = function(fDel, newLFace) {
  var eStart = fDel.anEdge;

  // change the left face of all affected edges
  var e = eStart;
  do {
    e.lFace = newLFace;
    e = e.lNext;
  } while (e !== eStart);

  // delete from circular doubly-linked list
  var fPrev = fDel.prev;
  var fNext = fDel.next;
  fNext.prev = fPrev;
  fPrev.next = fNext;

  // TODO(bckenny): memFree( fDel );
  // TODO(bckenny): need to null at callsites?
};

/* global libtess */

/** @const */
libtess.normal = {};

// TODO(bckenny): Integrate SLANTED_SWEEP somehow?
/* The "feature merging" is not intended to be complete. There are
 * special cases where edges are nearly parallel to the sweep line
 * which are not implemented. The algorithm should still behave
 * robustly (ie. produce a reasonable tesselation) in the presence
 * of such edges, however it may miss features which could have been
 * merged. We could minimize this effect by choosing the sweep line
 * direction to be something unusual (ie. not parallel to one of the
 * coordinate axes).
 * #if defined(SLANTED_SWEEP)
 * #define S_UNIT_X  0.50941539564955385 // Pre-normalized
 * #define S_UNIT_Y  0.86052074622010633
 * #endif
 */

/**
 * X coordinate of local basis for polygon projection.
 * @private {number}
 * @const
 */
libtess.normal.S_UNIT_X_ = 1.0;

/**
 * Y coordinate of local basis for polygon projection.
 * @private {number}
 * @const
 */
libtess.normal.S_UNIT_Y_ = 0.0;

/**
 * Determines a polygon normal and projects vertices onto the plane of the
 * polygon. A pre-computed normal for the data may be provided, or set to the
 * zero vector if one should be computed from it.
 * @param {!libtess.GluTesselator} tess
 * @param {number} normalX
 * @param {number} normalY
 * @param {number} normalZ
 */
libtess.normal.projectPolygon = function(tess, normalX, normalY, normalZ) {
  var computedNormal = false;

  var norm = [
    normalX,
    normalY,
    normalZ
  ];
  if (normalX === 0 && normalY === 0 && normalZ === 0) {
    libtess.normal.computeNormal_(tess, norm);
    computedNormal = true;
  }

  var i = libtess.normal.longAxis_(norm);
  var vHead = tess.mesh.vHead;
  var v;

  // NOTE(bckenny): This branch is never taken. See comment on
  // libtess.TRUE_PROJECT.
  /* istanbul ignore if */
  if (libtess.TRUE_PROJECT) {
    // Choose the initial sUnit vector to be approximately perpendicular
    // to the normal.
    libtess.normal.normalize_(norm);

    var sUnit = [0, 0, 0];
    var tUnit = [0, 0, 0];

    sUnit[i] = 0;
    sUnit[(i + 1) % 3] = libtess.normal.S_UNIT_X_;
    sUnit[(i + 2) % 3] = libtess.normal.S_UNIT_Y_;

    // Now make it exactly perpendicular
    var w = libtess.normal.dot_(sUnit, norm);
    sUnit[0] -= w * norm[0];
    sUnit[1] -= w * norm[1];
    sUnit[2] -= w * norm[2];
    libtess.normal.normalize_(sUnit);

    // Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame
    tUnit[0] = norm[1] * sUnit[2] - norm[2] * sUnit[1];
    tUnit[1] = norm[2] * sUnit[0] - norm[0] * sUnit[2];
    tUnit[2] = norm[0] * sUnit[1] - norm[1] * sUnit[0];
    libtess.normal.normalize_(tUnit);

    // Project the vertices onto the sweep plane
    for (v = vHead.next; v !== vHead; v = v.next) {
      v.s = libtess.normal.dot_(v.coords, sUnit);
      v.t = libtess.normal.dot_(v.coords, tUnit);
    }

  } else {
    // Project perpendicular to a coordinate axis -- better numerically
    var sAxis = (i + 1) % 3;
    var tAxis = (i + 2) % 3;
    var tNegate = norm[i] > 0 ? 1 : -1;

    // Project the vertices onto the sweep plane
    for (v = vHead.next; v !== vHead; v = v.next) {
      v.s = v.coords[sAxis];
      v.t = tNegate * v.coords[tAxis];
    }
  }

  if (computedNormal) {
    libtess.normal.checkOrientation_(tess);
  }
};

// NOTE(bckenny): libtess.normal.dot_ is no longer called in code without
// libtess.TRUE_PROJECT defined.
/* istanbul ignore next */
/**
 * Computes the dot product of vectors u and v.
 * @private
 * @param {!Array<number>} u
 * @param {!Array<number>} v
 * @return {number}
 */
libtess.normal.dot_ = function(u, v) {
  return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
};

// NOTE(bckenny): only called from within libtess.normal.projectPolygon's
// TRUE_PROJECT branch, so ignoring for code coverage.
/* istanbul ignore next */
/**
 * Normalize vector v.
 * @private
 * @param {!Array<number>} v
 */
libtess.normal.normalize_ = function(v) {
  var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];

  len = Math.sqrt(len);
  v[0] /= len;
  v[1] /= len;
  v[2] /= len;
};

/**
 * Returns the index of the longest component of vector v.
 * @private
 * @param {!Array<number>} v
 * @return {number}
 */
libtess.normal.longAxis_ = function(v) {
  var i = 0;

  if (Math.abs(v[1]) > Math.abs(v[0])) {
    i = 1;
  }
  if (Math.abs(v[2]) > Math.abs(v[i])) {
    i = 2;
  }

  return i;
};

/**
 * Compute an approximate normal of the polygon from the vertices themselves.
 * Result returned in norm.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {!Array<number>} norm
 */
libtess.normal.computeNormal_ = function(tess, norm) {
  var maxVal = [
    -2 * libtess.GLU_TESS_MAX_COORD,
    -2 * libtess.GLU_TESS_MAX_COORD,
    -2 * libtess.GLU_TESS_MAX_COORD
  ];
  var minVal = [
    2 * libtess.GLU_TESS_MAX_COORD,
    2 * libtess.GLU_TESS_MAX_COORD,
    2 * libtess.GLU_TESS_MAX_COORD
  ];
  var maxVert = [];
  var minVert = [];

  var v;
  var vHead = tess.mesh.vHead;
  for (v = vHead.next; v !== vHead; v = v.next) {
    for (var i = 0; i < 3; ++i) {
      var c = v.coords[i];
      if (c < minVal[i]) { minVal[i] = c; minVert[i] = v; }
      if (c > maxVal[i]) { maxVal[i] = c; maxVert[i] = v; }
    }
  }

  // Find two vertices separated by at least 1/sqrt(3) of the maximum
  // distance between any two vertices
  var index = 0;
  if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) { index = 1; }
  if (maxVal[2] - minVal[2] > maxVal[index] - minVal[index]) { index = 2; }
  if (minVal[index] >= maxVal[index]) {
    // All vertices are the same -- normal doesn't matter
    norm[0] = 0; norm[1] = 0; norm[2] = 1;
    return;
  }

  // Look for a third vertex which forms the triangle with maximum area
  // (Length of normal == twice the triangle area)
  var maxLen2 = 0;
  var v1 = minVert[index];
  var v2 = maxVert[index];
  var tNorm = [0, 0, 0];
  var d1 = [
    v1.coords[0] - v2.coords[0],
    v1.coords[1] - v2.coords[1],
    v1.coords[2] - v2.coords[2]
  ];
  var d2 = [0, 0, 0];
  for (v = vHead.next; v !== vHead; v = v.next) {
    d2[0] = v.coords[0] - v2.coords[0];
    d2[1] = v.coords[1] - v2.coords[1];
    d2[2] = v.coords[2] - v2.coords[2];
    tNorm[0] = d1[1] * d2[2] - d1[2] * d2[1];
    tNorm[1] = d1[2] * d2[0] - d1[0] * d2[2];
    tNorm[2] = d1[0] * d2[1] - d1[1] * d2[0];
    var tLen2 = tNorm[0] * tNorm[0] + tNorm[1] * tNorm[1] + tNorm[2] * tNorm[2];
    if (tLen2 > maxLen2) {
      maxLen2 = tLen2;
      norm[0] = tNorm[0];
      norm[1] = tNorm[1];
      norm[2] = tNorm[2];
    }
  }

  if (maxLen2 <= 0) {
    // All points lie on a single line -- any decent normal will do
    norm[0] = norm[1] = norm[2] = 0;
    norm[libtess.normal.longAxis_(d1)] = 1;
  }
};

/**
 * Check that the sum of the signed area of all projected contours is
 * non-negative. If not, negate the t-coordinates to reverse the orientation and
 * make it so.
 * @private
 * @param {!libtess.GluTesselator} tess
 */
libtess.normal.checkOrientation_ = function(tess) {
  var area = 0;
  var fHead = tess.mesh.fHead;
  for (var f = fHead.next; f !== fHead; f = f.next) {
    var e = f.anEdge;
    if (e.winding <= 0) { continue; }
    do {
      area += (e.org.s - e.dst().s) * (e.org.t + e.dst().t);
      e = e.lNext;
    } while (e !== f.anEdge);
  }

  if (area < 0) {
    // Reverse the orientation by flipping all the t-coordinates
    var vHead = tess.mesh.vHead;
    for (var v = vHead.next; v !== vHead; v = v.next) {
      v.t = -v.t;
    }
  }
};

/* global libtess */

/** @const */
libtess.render = {};

/**
 * Takes a mesh, breaks it into separate triangles, and renders them. The
 * rendering output is provided as callbacks (see the API). Set flagEdges to
 * true to get edgeFlag callbacks (tess.flagBoundary in original libtess).
 * @param {!libtess.GluTesselator} tess
 * @param {!libtess.GluMesh} mesh
 * @param {boolean} flagEdges
 */
libtess.render.renderMesh = function(tess, mesh, flagEdges) {
  var beginCallbackCalled = false;

  // TODO(bckenny): edgeState needs to be boolean, but !== on first call
  // force edge state output for first vertex
  var edgeState = -1;

  // We examine all faces in an arbitrary order. Whenever we find
  // an inside triangle f, we render f.
  // NOTE(bckenny): go backwards through face list to match original libtess
  // triangle order
  for (var f = mesh.fHead.prev; f !== mesh.fHead; f = f.prev) {
    if (f.inside) {
      // We're going to emit a triangle, so call begin callback once
      if (!beginCallbackCalled) {
        tess.callBeginCallback(libtess.primitiveType.GL_TRIANGLES);
        beginCallbackCalled = true;
      }

      // check that face has only three edges
      var e = f.anEdge;
      // Loop once for each edge (there will always be 3 edges)
      do {
        if (flagEdges) {
          // Set the "edge state" to true just before we output the
          // first vertex of each edge on the polygon boundary.
          var newState = !e.rFace().inside ? 1 : 0; // TODO(bckenny): total hack to get edgeState working. fix me.
          if (edgeState !== newState) {
            edgeState = newState;
            // TODO(bckenny): edgeState should be boolean now
            tess.callEdgeFlagCallback(!!edgeState);
          }
        }

        // emit vertex
        tess.callVertexCallback(e.org.data);

        e = e.lNext;
      } while (e !== f.anEdge);
    }
  }

  // only call end callback if begin was called
  if (beginCallbackCalled) {
    tess.callEndCallback();
  }
};

/**
 * Takes a mesh, and outputs one contour for each face marked "inside". The
 * rendering output is provided as callbacks (see the API).
 * @param {!libtess.GluTesselator} tess
 * @param {!libtess.GluMesh} mesh
 */
libtess.render.renderBoundary = function(tess, mesh) {
  for (var f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {
    if (f.inside) {
      tess.callBeginCallback(libtess.primitiveType.GL_LINE_LOOP);

      var e = f.anEdge;
      do {
        tess.callVertexCallback(e.org.data);
        e = e.lNext;
      } while (e !== f.anEdge);

      tess.callEndCallback();
    }
  }
};

/* global libtess */

// TODO(bckenny): a number of these never return null (as opposed to original) and should be typed appropriately

/*
 * Invariants for the Edge Dictionary.
 * - each pair of adjacent edges e2=succ(e1) satisfies edgeLeq_(e1,e2)
 *   at any valid location of the sweep event
 * - if edgeLeq_(e2,e1) as well (at any valid sweep event), then e1 and e2
 *   share a common endpoint
 * - for each e, e.dst() has been processed, but not e.org
 * - each edge e satisfies vertLeq(e.dst(),event) && vertLeq(event,e.org)
 *   where "event" is the current sweep line event.
 * - no edge e has zero length
 *
 * Invariants for the Mesh (the processed portion).
 * - the portion of the mesh left of the sweep line is a planar graph,
 *   ie. there is *some* way to embed it in the plane
 * - no processed edge has zero length
 * - no two processed vertices have identical coordinates
 * - each "inside" region is monotone, ie. can be broken into two chains
 *   of monotonically increasing vertices according to VertLeq(v1,v2)
 *   - a non-invariant: these chains may intersect (very slightly)
 *
 * Invariants for the Sweep.
 * - if none of the edges incident to the event vertex have an activeRegion
 *   (ie. none of these edges are in the edge dictionary), then the vertex
 *   has only right-going edges.
 * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
 *   by ConnectRightVertex), then it is the only right-going edge from
 *   its associated vertex.  (This says that these edges exist only
 *   when it is necessary.)
 */

/** @const */
libtess.sweep = {};


/**
 * Make the sentinel coordinates big enough that they will never be
 * merged with real input features.  (Even with the largest possible
 * input contour and the maximum tolerance of 1.0, no merging will be
 * done with coordinates larger than 3 * libtess.GLU_TESS_MAX_COORD).
 * @private
 * @const
 * @type {number}
 */
libtess.sweep.SENTINEL_COORD_ = 4 * libtess.GLU_TESS_MAX_COORD;


/**
 * Because vertices at exactly the same location are merged together
 * before we process the sweep event, some degenerate cases can't occur.
 * However if someone eventually makes the modifications required to
 * merge features which are close together, the cases below marked
 * TOLERANCE_NONZERO will be useful.  They were debugged before the
 * code to merge identical vertices in the main loop was added.
 * @private
 * @const
 * @type {boolean}
 */
libtess.sweep.TOLERANCE_NONZERO_ = false;


/**
 * computeInterior(tess) computes the planar arrangement specified
 * by the given contours, and further subdivides this arrangement
 * into regions. Each region is marked "inside" if it belongs
 * to the polygon, according to the rule given by tess.windingRule.
 * Each interior region is guaranteed be monotone.
 *
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.computeInterior = function(tess) {
  tess.fatalError = false;

  // Each vertex defines an event for our sweep line. Start by inserting
  // all the vertices in a priority queue. Events are processed in
  // lexicographic order, ie.
  // e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
  libtess.sweep.removeDegenerateEdges_(tess);
  libtess.sweep.initPriorityQ_(tess);
  libtess.sweep.initEdgeDict_(tess);

  var v;
  while ((v = tess.pq.extractMin()) !== null) {
    for (;;) {
      var vNext = tess.pq.minimum();
      if (vNext === null || !libtess.geom.vertEq(vNext, v)) {
        break;
      }

      /* Merge together all vertices at exactly the same location.
       * This is more efficient than processing them one at a time,
       * simplifies the code (see connectLeftDegenerate), and is also
       * important for correct handling of certain degenerate cases.
       * For example, suppose there are two identical edges A and B
       * that belong to different contours (so without this code they would
       * be processed by separate sweep events).  Suppose another edge C
       * crosses A and B from above.  When A is processed, we split it
       * at its intersection point with C.  However this also splits C,
       * so when we insert B we may compute a slightly different
       * intersection point.  This might leave two edges with a small
       * gap between them.  This kind of error is especially obvious
       * when using boundary extraction (GLU_TESS_BOUNDARY_ONLY).
       */
      vNext = tess.pq.extractMin();
      libtess.sweep.spliceMergeVertices_(tess, v.anEdge, vNext.anEdge);
    }
    libtess.sweep.sweepEvent_(tess, v);
  }

  // TODO(bckenny): what does the next comment mean? can we eliminate event except when debugging?
  // Set tess.event for debugging purposes
  var minRegion = tess.dict.getMin().getKey();
  tess.event = minRegion.eUp.org;
  libtess.sweep.doneEdgeDict_(tess);
  libtess.sweep.donePriorityQ_(tess);

  libtess.sweep.removeDegenerateFaces_(tess.mesh);
  tess.mesh.checkMesh();
};


/**
 * When we merge two edges into one, we need to compute the combined
 * winding of the new edge.
 * @private
 * @param {libtess.GluHalfEdge} eDst [description].
 * @param {libtess.GluHalfEdge} eSrc [description].
 */
libtess.sweep.addWinding_ = function(eDst, eSrc) {
  // NOTE(bckenny): from AddWinding macro
  eDst.winding += eSrc.winding;
  eDst.sym.winding += eSrc.sym.winding;
};


/**
 * Both edges must be directed from right to left (this is the canonical
 * direction for the upper edge of each region).
 *
 * The strategy is to evaluate a "t" value for each edge at the
 * current sweep line position, given by tess.event.  The calculations
 * are designed to be very stable, but of course they are not perfect.
 *
 * Special case: if both edge destinations are at the sweep event,
 * we sort the edges by slope (they would otherwise compare equally).
 *
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {!libtess.ActiveRegion} reg1
 * @param {!libtess.ActiveRegion} reg2
 * @return {boolean}
 */
libtess.sweep.edgeLeq_ = function(tess, reg1, reg2) {
  var event = tess.event;
  var e1 = reg1.eUp;
  var e2 = reg2.eUp;

  if (e1.dst() === event) {
    if (e2.dst() === event) {
      // Two edges right of the sweep line which meet at the sweep event.
      // Sort them by slope.
      if (libtess.geom.vertLeq(e1.org, e2.org)) {
        return libtess.geom.edgeSign(e2.dst(), e1.org, e2.org) <= 0;
      }

      return libtess.geom.edgeSign(e1.dst(), e2.org, e1.org) >= 0;
    }

    return libtess.geom.edgeSign(e2.dst(), event, e2.org) <= 0;
  }

  if (e2.dst() === event) {
    return libtess.geom.edgeSign(e1.dst(), event, e1.org) >= 0;
  }

  // General case - compute signed distance *from* e1, e2 to event
  var t1 = libtess.geom.edgeEval(e1.dst(), event, e1.org);
  var t2 = libtess.geom.edgeEval(e2.dst(), event, e2.org);
  return (t1 >= t2);
};


/**
 * [deleteRegion_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} reg [description].
 */
libtess.sweep.deleteRegion_ = function(tess, reg) {
  if (reg.fixUpperEdge) {
    // It was created with zero winding number, so it better be
    // deleted with zero winding number (ie. it better not get merged
    // with a real edge).
  }

  reg.eUp.activeRegion = null;

  tess.dict.deleteNode(reg.nodeUp);
  reg.nodeUp = null;

  // memFree( reg ); TODO(bckenny)
  // TODO(bckenny): may need to null at callsite
};


/**
 * Replace an upper edge which needs fixing (see connectRightVertex).
 * @private
 * @param {libtess.ActiveRegion} reg [description].
 * @param {libtess.GluHalfEdge} newEdge [description].
 */
libtess.sweep.fixUpperEdge_ = function(reg, newEdge) {
  libtess.mesh.deleteEdge(reg.eUp);

  reg.fixUpperEdge = false;
  reg.eUp = newEdge;
  newEdge.activeRegion = reg;
};


/**
 * Find the region above the uppermost edge with the same origin.
 * @private
 * @param {libtess.ActiveRegion} reg [description].
 * @return {libtess.ActiveRegion} [description].
 */
libtess.sweep.topLeftRegion_ = function(reg) {
  var org = reg.eUp.org;

  // Find the region above the uppermost edge with the same origin
  do {
    reg = reg.regionAbove();
  } while (reg.eUp.org === org);

  // If the edge above was a temporary edge introduced by connectRightVertex,
  // now is the time to fix it.
  if (reg.fixUpperEdge) {
    var e = libtess.mesh.connect(reg.regionBelow().eUp.sym, reg.eUp.lNext);
    libtess.sweep.fixUpperEdge_(reg, e);
    reg = reg.regionAbove();
  }

  return reg;
};


/**
 * Find the region above the uppermost edge with the same destination.
 * @private
 * @param {libtess.ActiveRegion} reg [description].
 * @return {libtess.ActiveRegion} [description].
 */
libtess.sweep.topRightRegion_ = function(reg) {
  var dst = reg.eUp.dst();

  do {
    reg = reg.regionAbove();
  } while (reg.eUp.dst() === dst);

  return reg;
};


/**
 * Add a new active region to the sweep line, *somewhere* below "regAbove"
 * (according to where the new edge belongs in the sweep-line dictionary).
 * The upper edge of the new region will be "eNewUp".
 * Winding number and "inside" flag are not updated.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regAbove [description].
 * @param {libtess.GluHalfEdge} eNewUp [description].
 * @return {libtess.ActiveRegion} regNew.
 */
libtess.sweep.addRegionBelow_ = function(tess, regAbove, eNewUp) {
  var regNew = new libtess.ActiveRegion();

  regNew.eUp = eNewUp;
  regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp, regNew);
  eNewUp.activeRegion = regNew;

  return regNew;
};


/**
 * [isWindingInside_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {number} n int.
 * @return {boolean} [description].
 */
libtess.sweep.isWindingInside_ = function(tess, n) {
  switch (tess.windingRule) {
    case libtess.windingRule.GLU_TESS_WINDING_ODD:
      return ((n & 1) !== 0);
    case libtess.windingRule.GLU_TESS_WINDING_NONZERO:
      return (n !== 0);
    case libtess.windingRule.GLU_TESS_WINDING_POSITIVE:
      return (n > 0);
    case libtess.windingRule.GLU_TESS_WINDING_NEGATIVE:
      return (n < 0);
    case libtess.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
      return (n >= 2) || (n <= -2);
  }

  // TODO(bckenny): not reached
  return false;
};


/**
 * [computeWinding_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} reg [description].
 */
libtess.sweep.computeWinding_ = function(tess, reg) {
  reg.windingNumber = reg.regionAbove().windingNumber + reg.eUp.winding;
  reg.inside = libtess.sweep.isWindingInside_(tess, reg.windingNumber);
};


/**
 * Delete a region from the sweep line. This happens when the upper
 * and lower chains of a region meet (at a vertex on the sweep line).
 * The "inside" flag is copied to the appropriate mesh face (we could
 * not do this before -- since the structure of the mesh is always
 * changing, this face may not have even existed until now).
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} reg [description].
 */
libtess.sweep.finishRegion_ = function(tess, reg) {
  // TODO(bckenny): may need to null reg at callsite

  var e = reg.eUp;
  var f = e.lFace;

  f.inside = reg.inside;
  f.anEdge = e;   // optimization for tessmono.tessellateMonoRegion() // TODO(bckenny): how so?
  libtess.sweep.deleteRegion_(tess, reg);
};


/**
 * We are given a vertex with one or more left-going edges. All affected
 * edges should be in the edge dictionary. Starting at regFirst.eUp,
 * we walk down deleting all regions where both edges have the same
 * origin vOrg. At the same time we copy the "inside" flag from the
 * active region to the face, since at this point each face will belong
 * to at most one region (this was not necessarily true until this point
 * in the sweep). The walk stops at the region above regLast; if regLast
 * is null we walk as far as possible. At the same time we relink the
 * mesh if necessary, so that the ordering of edges around vOrg is the
 * same as in the dictionary.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regFirst [description].
 * @param {libtess.ActiveRegion} regLast [description].
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.sweep.finishLeftRegions_ = function(tess, regFirst, regLast) {
  var regPrev = regFirst;
  var ePrev = regFirst.eUp;
  while (regPrev !== regLast) {
    // placement was OK
    regPrev.fixUpperEdge = false;
    var reg = regPrev.regionBelow();
    var e = reg.eUp;
    if (e.org !== ePrev.org) {
      if (!reg.fixUpperEdge) {
        /* Remove the last left-going edge. Even though there are no further
         * edges in the dictionary with this origin, there may be further
         * such edges in the mesh (if we are adding left edges to a vertex
         * that has already been processed). Thus it is important to call
         * finishRegion rather than just deleteRegion.
         */
        libtess.sweep.finishRegion_(tess, regPrev);
        break;
      }

      // If the edge below was a temporary edge introduced by
      // connectRightVertex, now is the time to fix it.
      e = libtess.mesh.connect(ePrev.lPrev(), e.sym);
      libtess.sweep.fixUpperEdge_(reg, e);
    }

    // Relink edges so that ePrev.oNext === e
    if (ePrev.oNext !== e) {
      libtess.mesh.meshSplice(e.oPrev(), e);
      libtess.mesh.meshSplice(ePrev, e);
    }

    // may change reg.eUp
    libtess.sweep.finishRegion_(tess, regPrev);
    ePrev = reg.eUp;
    regPrev = reg;
  }

  return ePrev;
};


/**
 * Purpose: insert right-going edges into the edge dictionary, and update
 * winding numbers and mesh connectivity appropriately. All right-going
 * edges share a common origin vOrg. Edges are inserted CCW starting at
 * eFirst; the last edge inserted is eLast.oPrev. If vOrg has any
 * left-going edges already processed, then eTopLeft must be the edge
 * such that an imaginary upward vertical segment from vOrg would be
 * contained between eTopLeft.oPrev and eTopLeft; otherwise eTopLeft
 * should be null.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @param {libtess.GluHalfEdge} eFirst [description].
 * @param {libtess.GluHalfEdge} eLast [description].
 * @param {libtess.GluHalfEdge} eTopLeft [description].
 * @param {boolean} cleanUp [description].
 */
libtess.sweep.addRightEdges_ = function(tess, regUp, eFirst, eLast, eTopLeft,
    cleanUp) {

  var firstTime = true;

  // Insert the new right-going edges in the dictionary
  var e = eFirst;
  do {
    libtess.sweep.addRegionBelow_(tess, regUp, e.sym);
    e = e.oNext;
  } while (e !== eLast);

  // Walk *all* right-going edges from e.org, in the dictionary order,
  // updating the winding numbers of each region, and re-linking the mesh
  // edges to match the dictionary ordering (if necessary).
  if (eTopLeft === null) {
    eTopLeft = regUp.regionBelow().eUp.rPrev();
  }
  var regPrev = regUp;
  var ePrev = eTopLeft;
  var reg;
  for (;;) {
    reg = regPrev.regionBelow();
    e = reg.eUp.sym;
    if (e.org !== ePrev.org) {
      break;
    }

    if (e.oNext !== ePrev) {
      // Unlink e from its current position, and relink below ePrev
      libtess.mesh.meshSplice(e.oPrev(), e);
      libtess.mesh.meshSplice(ePrev.oPrev(), e);
    }
    // Compute the winding number and "inside" flag for the new regions
    reg.windingNumber = regPrev.windingNumber - e.winding;
    reg.inside = libtess.sweep.isWindingInside_(tess, reg.windingNumber);

    // Check for two outgoing edges with same slope -- process these
    // before any intersection tests (see example in libtess.sweep.computeInterior).
    regPrev.dirty = true;
    if (!firstTime && libtess.sweep.checkForRightSplice_(tess, regPrev)) {
      libtess.sweep.addWinding_(e, ePrev);
      libtess.sweep.deleteRegion_(tess, regPrev); // TODO(bckenny): need to null regPrev anywhere else?
      libtess.mesh.deleteEdge(ePrev);
    }
    firstTime = false;
    regPrev = reg;
    ePrev = e;
  }

  regPrev.dirty = true;

  if (cleanUp) {
    // Check for intersections between newly adjacent edges.
    libtess.sweep.walkDirtyRegions_(tess, regPrev);
  }
};


/**
 * Set up data for and call GLU_TESS_COMBINE callback on GluTesselator.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {!libtess.GluVertex} isect A raw vertex at the intersection.
 * @param {!Array<Object>} data The vertices of the intersecting edges.
 * @param {!Array<number>} weights The linear combination coefficients for this intersection.
 * @param {boolean} needed Whether a returned vertex is necessary in this case.
 */
libtess.sweep.callCombine_ = function(tess, isect, data, weights, needed) {
  // Copy coord data in case the callback changes it.
  var coords = [
    isect.coords[0],
    isect.coords[1],
    isect.coords[2]
  ];

  isect.data = null;
  isect.data = tess.callCombineCallback(coords, data, weights);
  if (isect.data === null) {
    if (!needed) {
      // not needed, so just use data from first vertex
      isect.data = data[0];

    } else if (!tess.fatalError) {
      // The only way fatal error is when two edges are found to intersect,
      // but the user has not provided the callback necessary to handle
      // generated intersection points.
      tess.callErrorCallback(libtess.errorType.GLU_TESS_NEED_COMBINE_CALLBACK);
      tess.fatalError = true;
    }
  }
};


/**
 * Two vertices with idential coordinates are combined into one.
 * e1.org is kept, while e2.org is discarded.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {libtess.GluHalfEdge} e1 [description].
 * @param {libtess.GluHalfEdge} e2 [description].
 */
libtess.sweep.spliceMergeVertices_ = function(tess, e1, e2) {
  // TODO(bckenny): better way to init these? save them?
  var data = [null, null, null, null];
  var weights = [0.5, 0.5, 0, 0];

  data[0] = e1.org.data;
  data[1] = e2.org.data;
  libtess.sweep.callCombine_(tess, e1.org, data, weights, false);
  libtess.mesh.meshSplice(e1, e2);
};


/**
 * Find some weights which describe how the intersection vertex is
 * a linear combination of org and dst. Each of the two edges
 * which generated "isect" is allocated 50% of the weight; each edge
 * splits the weight between its org and dst according to the
 * relative distance to "isect".
 *
 * @private
 * @param {libtess.GluVertex} isect [description].
 * @param {libtess.GluVertex} org [description].
 * @param {libtess.GluVertex} dst [description].
 * @param {Array.<number>} weights [description].
 * @param {number} weightIndex Index into weights for first weight to supply.
 */
libtess.sweep.vertexWeights_ = function(isect, org, dst, weights, weightIndex) {
  // TODO(bckenny): think through how we can use L1dist here and be correct for coords
  var t1 = libtess.geom.vertL1dist(org, isect);
  var t2 = libtess.geom.vertL1dist(dst, isect);

  // TODO(bckenny): introduced weightIndex to mimic addressing in original
  // 1) document (though it is private and only used from getIntersectData)
  // 2) better way? manually inline into getIntersectData? supply two two-length tmp arrays?
  var i0 = weightIndex;
  var i1 = weightIndex + 1;
  weights[i0] = 0.5 * t2 / (t1 + t2);
  weights[i1] = 0.5 * t1 / (t1 + t2);
  isect.coords[0] += weights[i0] * org.coords[0] + weights[i1] * dst.coords[0];
  isect.coords[1] += weights[i0] * org.coords[1] + weights[i1] * dst.coords[1];
  isect.coords[2] += weights[i0] * org.coords[2] + weights[i1] * dst.coords[2];
};


/**
 * We've computed a new intersection point, now we need a "data" pointer
 * from the user so that we can refer to this new vertex in the
 * rendering callbacks.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {libtess.GluVertex} isect [description].
 * @param {libtess.GluVertex} orgUp [description].
 * @param {libtess.GluVertex} dstUp [description].
 * @param {libtess.GluVertex} orgLo [description].
 * @param {libtess.GluVertex} dstLo [description].
 */
libtess.sweep.getIntersectData_ = function(tess, isect, orgUp, dstUp, orgLo,
    dstLo) {

  // TODO(bckenny): called for every intersection event, should these be from a pool?
  // TODO(bckenny): better way to init these?
  var weights = [0, 0, 0, 0];
  var data = [
    orgUp.data,
    dstUp.data,
    orgLo.data,
    dstLo.data
  ];

  // TODO(bckenny): it appears isect is a reappropriated vertex, so does need to be zeroed.
  // double check this.
  isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;

  // TODO(bckenny): see note in libtess.sweep.vertexWeights_ for explanation of weightIndex. fix?
  libtess.sweep.vertexWeights_(isect, orgUp, dstUp, weights, 0);
  libtess.sweep.vertexWeights_(isect, orgLo, dstLo, weights, 2);

  libtess.sweep.callCombine_(tess, isect, data, weights, true);
};


/**
 * Check the upper and lower edge of regUp, to make sure that the
 * eUp.org is above eLo, or eLo.org is below eUp (depending on which
 * origin is leftmost).
 *
 * The main purpose is to splice right-going edges with the same
 * dest vertex and nearly identical slopes (ie. we can't distinguish
 * the slopes numerically). However the splicing can also help us
 * to recover from numerical errors. For example, suppose at one
 * point we checked eUp and eLo, and decided that eUp.org is barely
 * above eLo. Then later, we split eLo into two edges (eg. from
 * a splice operation like this one). This can change the result of
 * our test so that now eUp.org is incident to eLo, or barely below it.
 * We must correct this condition to maintain the dictionary invariants.
 *
 * One possibility is to check these edges for intersection again
 * (i.e. checkForIntersect). This is what we do if possible. However
 * checkForIntersect requires that tess.event lies between eUp and eLo,
 * so that it has something to fall back on when the intersection
 * calculation gives us an unusable answer. So, for those cases where
 * we can't check for intersection, this routine fixes the problem
 * by just splicing the offending vertex into the other edge.
 * This is a guaranteed solution, no matter how degenerate things get.
 * Basically this is a combinatorial solution to a numerical problem.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @return {boolean} [description].
 */
libtess.sweep.checkForRightSplice_ = function(tess, regUp) {
  // TODO(bckenny): fully learn how these two checks work

  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;

  if (libtess.geom.vertLeq(eUp.org, eLo.org)) {
    if (libtess.geom.edgeSign(eLo.dst(), eUp.org, eLo.org) > 0) {
      return false;
    }

    // eUp.org appears to be below eLo
    if (!libtess.geom.vertEq(eUp.org, eLo.org)) {
      // Splice eUp.org into eLo
      libtess.mesh.splitEdge(eLo.sym);
      libtess.mesh.meshSplice(eUp, eLo.oPrev());
      regUp.dirty = regLo.dirty = true;

    } else if (eUp.org !== eLo.org) {
      // merge the two vertices, discarding eUp.org
      tess.pq.remove(eUp.org.pqHandle);
      libtess.sweep.spliceMergeVertices_(tess, eLo.oPrev(), eUp);
    }

  } else {
    if (libtess.geom.edgeSign(eUp.dst(), eLo.org, eUp.org) < 0) {
      return false;
    }

    // eLo.org appears to be above eUp, so splice eLo.org into eUp
    regUp.regionAbove().dirty = regUp.dirty = true;
    libtess.mesh.splitEdge(eUp.sym);
    libtess.mesh.meshSplice(eLo.oPrev(), eUp);
  }

  return true;
};


/**
 * Check the upper and lower edge of regUp to make sure that the
 * eUp.dst() is above eLo, or eLo.dst() is below eUp (depending on which
 * destination is rightmost).
 *
 * Theoretically, this should always be true. However, splitting an edge
 * into two pieces can change the results of previous tests. For example,
 * suppose at one point we checked eUp and eLo, and decided that eUp.dst()
 * is barely above eLo. Then later, we split eLo into two edges (eg. from
 * a splice operation like this one). This can change the result of
 * the test so that now eUp.dst() is incident to eLo, or barely below it.
 * We must correct this condition to maintain the dictionary invariants
 * (otherwise new edges might get inserted in the wrong place in the
 * dictionary, and bad stuff will happen).
 *
 * We fix the problem by just splicing the offending vertex into the
 * other edge.
 *
 * @private
 * @param {libtess.GluTesselator} tess description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @return {boolean} [description].
 */
libtess.sweep.checkForLeftSplice_ = function(tess, regUp) {
  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;
  var e;

  if (libtess.geom.vertLeq(eUp.dst(), eLo.dst())) {
    if (libtess.geom.edgeSign(eUp.dst(), eLo.dst(), eUp.org) < 0) {
      return false;
    }

    // eLo.dst() is above eUp, so splice eLo.dst() into eUp
    regUp.regionAbove().dirty = regUp.dirty = true;
    e = libtess.mesh.splitEdge(eUp);
    libtess.mesh.meshSplice(eLo.sym, e);
    e.lFace.inside = regUp.inside;

  } else {
    if (libtess.geom.edgeSign(eLo.dst(), eUp.dst(), eLo.org) > 0) {
      return false;
    }

    // eUp.dst() is below eLo, so splice eUp.dst() into eLo
    regUp.dirty = regLo.dirty = true;
    e = libtess.mesh.splitEdge(eLo);
    libtess.mesh.meshSplice(eUp.lNext, eLo.sym);
    e.rFace().inside = regUp.inside;
  }

  return true;
};


/**
 * Check the upper and lower edges of the given region to see if
 * they intersect. If so, create the intersection and add it
 * to the data structures.
 *
 * Returns true if adding the new intersection resulted in a recursive
 * call to addRightEdges_(); in this case all "dirty" regions have been
 * checked for intersections, and possibly regUp has been deleted.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @return {boolean} [description].
 */
libtess.sweep.checkForIntersect_ = function(tess, regUp) {
  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;
  var orgUp = eUp.org;
  var orgLo = eLo.org;
  var dstUp = eUp.dst();
  var dstLo = eLo.dst();

  var isect = new libtess.GluVertex();

  if (orgUp === orgLo) {
    // right endpoints are the same
    return false;
  }

  var tMinUp = Math.min(orgUp.t, dstUp.t);
  var tMaxLo = Math.max(orgLo.t, dstLo.t);
  if (tMinUp > tMaxLo) {
    // t ranges do not overlap
    return false;
  }

  if (libtess.geom.vertLeq(orgUp, orgLo)) {
    if (libtess.geom.edgeSign(dstLo, orgUp, orgLo) > 0) {
      return false;
    }
  } else {
    if (libtess.geom.edgeSign(dstUp, orgLo, orgUp) < 0) {
      return false;
    }
  }

  // At this point the edges intersect, at least marginally
  libtess.geom.edgeIntersect(dstUp, orgUp, dstLo, orgLo, isect);

  // The following properties are guaranteed:

  if (libtess.geom.vertLeq(isect, tess.event)) {
    /* The intersection point lies slightly to the left of the sweep line,
     * so move it until it's slightly to the right of the sweep line.
     * (If we had perfect numerical precision, this would never happen
     * in the first place). The easiest and safest thing to do is
     * replace the intersection by tess.event.
     */
    isect.s = tess.event.s;
    isect.t = tess.event.t;
  }

  // TODO(bckenny): try to find test54.d
  /* Similarly, if the computed intersection lies to the right of the
   * rightmost origin (which should rarely happen), it can cause
   * unbelievable inefficiency on sufficiently degenerate inputs.
   * (If you have the test program, try running test54.d with the
   * "X zoom" option turned on).
   */
  var orgMin = libtess.geom.vertLeq(orgUp, orgLo) ? orgUp : orgLo;
  if (libtess.geom.vertLeq(orgMin, isect)) {
    isect.s = orgMin.s;
    isect.t = orgMin.t;
  }

  if (libtess.geom.vertEq(isect, orgUp) || libtess.geom.vertEq(isect, orgLo)) {
    // Easy case -- intersection at one of the right endpoints
    libtess.sweep.checkForRightSplice_(tess, regUp);
    return false;
  }

  // TODO(bckenny): clean this up; length is distracting
  if ((!libtess.geom.vertEq(dstUp, tess.event) &&
      libtess.geom.edgeSign(dstUp, tess.event, isect) >= 0) ||
      (!libtess.geom.vertEq(dstLo, tess.event) &&
      libtess.geom.edgeSign(dstLo, tess.event, isect) <= 0)) {

    /* Very unusual -- the new upper or lower edge would pass on the
     * wrong side of the sweep event, or through it. This can happen
     * due to very small numerical errors in the intersection calculation.
     */
    if (dstLo === tess.event) {
      // Splice dstLo into eUp, and process the new region(s)
      libtess.mesh.splitEdge(eUp.sym);
      libtess.mesh.meshSplice(eLo.sym, eUp);
      regUp = libtess.sweep.topLeftRegion_(regUp);
      eUp = regUp.regionBelow().eUp;
      libtess.sweep.finishLeftRegions_(tess, regUp.regionBelow(), regLo);
      libtess.sweep.addRightEdges_(tess, regUp, eUp.oPrev(), eUp, eUp, true);
      return true;
    }

    if (dstUp === tess.event) {
      // Splice dstUp into eLo, and process the new region(s)
      libtess.mesh.splitEdge(eLo.sym);
      libtess.mesh.meshSplice(eUp.lNext, eLo.oPrev());
      regLo = regUp;
      regUp = libtess.sweep.topRightRegion_(regUp);
      var e = regUp.regionBelow().eUp.rPrev();
      regLo.eUp = eLo.oPrev();
      eLo = libtess.sweep.finishLeftRegions_(tess, regLo, null);
      libtess.sweep.addRightEdges_(tess, regUp, eLo.oNext, eUp.rPrev(), e,
          true);
      return true;
    }

    /* Special case: called from connectRightVertex. If either
     * edge passes on the wrong side of tess.event, split it
     * (and wait for connectRightVertex to splice it appropriately).
     */
    if (libtess.geom.edgeSign(dstUp, tess.event, isect) >= 0) {
      regUp.regionAbove().dirty = regUp.dirty = true;
      libtess.mesh.splitEdge(eUp.sym);
      eUp.org.s = tess.event.s;
      eUp.org.t = tess.event.t;
    }

    if (libtess.geom.edgeSign(dstLo, tess.event, isect) <= 0) {
      regUp.dirty = regLo.dirty = true;
      libtess.mesh.splitEdge(eLo.sym);
      eLo.org.s = tess.event.s;
      eLo.org.t = tess.event.t;
    }

    // leave the rest for connectRightVertex
    return false;
  }

  /* General case -- split both edges, splice into new vertex.
   * When we do the splice operation, the order of the arguments is
   * arbitrary as far as correctness goes. However, when the operation
   * creates a new face, the work done is proportional to the size of
   * the new face. We expect the faces in the processed part of
   * the mesh (ie. eUp.lFace) to be smaller than the faces in the
   * unprocessed original contours (which will be eLo.oPrev.lFace).
   */
  libtess.mesh.splitEdge(eUp.sym);
  libtess.mesh.splitEdge(eLo.sym);
  libtess.mesh.meshSplice(eLo.oPrev(), eUp);
  eUp.org.s = isect.s;
  eUp.org.t = isect.t;
  eUp.org.pqHandle = tess.pq.insert(eUp.org);
  libtess.sweep.getIntersectData_(tess, eUp.org, orgUp, dstUp, orgLo, dstLo);
  regUp.regionAbove().dirty = regUp.dirty = regLo.dirty = true;

  return false;
};


/**
 * When the upper or lower edge of any region changes, the region is
 * marked "dirty". This routine walks through all the dirty regions
 * and makes sure that the dictionary invariants are satisfied
 * (see the comments at the beginning of this file). Of course,
 * new dirty regions can be created as we make changes to restore
 * the invariants.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 */
libtess.sweep.walkDirtyRegions_ = function(tess, regUp) {
  var regLo = regUp.regionBelow();

  for (;;) {
    // Find the lowest dirty region (we walk from the bottom up).
    while (regLo.dirty) {
      regUp = regLo;
      regLo = regLo.regionBelow();
    }
    if (!regUp.dirty) {
      regLo = regUp;
      regUp = regUp.regionAbove();
      if (regUp === null || !regUp.dirty) {
        // We've walked all the dirty regions
        return;
      }
    }

    regUp.dirty = false;
    var eUp = regUp.eUp;
    var eLo = regLo.eUp;

    if (eUp.dst() !== eLo.dst()) {
      // Check that the edge ordering is obeyed at the dst vertices.
      if (libtess.sweep.checkForLeftSplice_(tess, regUp)) {
        // If the upper or lower edge was marked fixUpperEdge, then
        // we no longer need it (since these edges are needed only for
        // vertices which otherwise have no right-going edges).
        if (regLo.fixUpperEdge) {
          libtess.sweep.deleteRegion_(tess, regLo);
          libtess.mesh.deleteEdge(eLo);
          regLo = regUp.regionBelow();
          eLo = regLo.eUp;

        } else if (regUp.fixUpperEdge) {
          libtess.sweep.deleteRegion_(tess, regUp);
          libtess.mesh.deleteEdge(eUp);
          regUp = regLo.regionAbove();
          eUp = regUp.eUp;
        }
      }
    }

    if (eUp.org !== eLo.org) {
      if (eUp.dst() !== eLo.dst() && !regUp.fixUpperEdge &&
          !regLo.fixUpperEdge &&
          (eUp.dst() === tess.event || eLo.dst() === tess.event)) {
        /* When all else fails in checkForIntersect(), it uses tess.event
         * as the intersection location. To make this possible, it requires
         * that tess.event lie between the upper and lower edges, and also
         * that neither of these is marked fixUpperEdge (since in the worst
         * case it might splice one of these edges into tess.event, and
         * violate the invariant that fixable edges are the only right-going
         * edge from their associated vertex).
         */
        if (libtess.sweep.checkForIntersect_(tess, regUp)) {
          // walkDirtyRegions() was called recursively; we're done
          return;
        }

      } else {
        // Even though we can't use checkForIntersect(), the org vertices
        // may violate the dictionary edge ordering. Check and correct this.
        libtess.sweep.checkForRightSplice_(tess, regUp);
      }
    }

    if (eUp.org === eLo.org && eUp.dst() === eLo.dst()) {
      // A degenerate loop consisting of only two edges -- delete it.
      libtess.sweep.addWinding_(eLo, eUp);
      libtess.sweep.deleteRegion_(tess, regUp);
      libtess.mesh.deleteEdge(eUp);
      regUp = regLo.regionAbove();
    }
  }
};


/**
 * Purpose: connect a "right" vertex vEvent (one where all edges go left)
 * to the unprocessed portion of the mesh. Since there are no right-going
 * edges, two regions (one above vEvent and one below) are being merged
 * into one. regUp is the upper of these two regions.
 *
 * There are two reasons for doing this (adding a right-going edge):
 *  - if the two regions being merged are "inside", we must add an edge
 *    to keep them separated (the combined region would not be monotone).
 *  - in any case, we must leave some record of vEvent in the dictionary,
 *    so that we can merge vEvent with features that we have not seen yet.
 *    For example, maybe there is a vertical edge which passes just to
 *    the right of vEvent; we would like to splice vEvent into this edge.
 *
 * However, we don't want to connect vEvent to just any vertex. We don't
 * want the new edge to cross any other edges; otherwise we will create
 * intersection vertices even when the input data had no self-intersections.
 * (This is a bad thing; if the user's input data has no intersections,
 * we don't want to generate any false intersections ourselves.)
 *
 * Our eventual goal is to connect vEvent to the leftmost unprocessed
 * vertex of the combined region (the union of regUp and regLo).
 * But because of unseen vertices with all right-going edges, and also
 * new vertices which may be created by edge intersections, we don't
 * know where that leftmost unprocessed vertex is. In the meantime, we
 * connect vEvent to the closest vertex of either chain, and mark the region
 * as "fixUpperEdge". This flag says to delete and reconnect this edge
 * to the next processed vertex on the boundary of the combined region.
 * Quite possibly the vertex we connected to will turn out to be the
 * closest one, in which case we won't need to make any changes.
 *
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.ActiveRegion} regUp [description].
 * @param {libtess.GluHalfEdge} eBottomLeft [description].
 */
libtess.sweep.connectRightVertex_ = function(tess, regUp, eBottomLeft) {
  var eTopLeft = eBottomLeft.oNext;
  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;
  var degenerate = false;

  if (eUp.dst() !== eLo.dst()) {
    libtess.sweep.checkForIntersect_(tess, regUp);
  }

  // Possible new degeneracies: upper or lower edge of regUp may pass
  // through vEvent, or may coincide with new intersection vertex
  if (libtess.geom.vertEq(eUp.org, tess.event)) {
    libtess.mesh.meshSplice(eTopLeft.oPrev(), eUp);
    regUp = libtess.sweep.topLeftRegion_(regUp);
    eTopLeft = regUp.regionBelow().eUp;
    libtess.sweep.finishLeftRegions_(tess, regUp.regionBelow(), regLo);
    degenerate = true;
  }
  if (libtess.geom.vertEq(eLo.org, tess.event)) {
    libtess.mesh.meshSplice(eBottomLeft, eLo.oPrev());
    eBottomLeft = libtess.sweep.finishLeftRegions_(tess, regLo, null);
    degenerate = true;
  }
  if (degenerate) {
    libtess.sweep.addRightEdges_(tess, regUp, eBottomLeft.oNext, eTopLeft,
        eTopLeft, true);
    return;
  }

  // Non-degenerate situation -- need to add a temporary, fixable edge.
  // Connect to the closer of eLo.org, eUp.org.
  var eNew;
  if (libtess.geom.vertLeq(eLo.org, eUp.org)) {
    eNew = eLo.oPrev();
  } else {
    eNew = eUp;
  }
  eNew = libtess.mesh.connect(eBottomLeft.lPrev(), eNew);

  // Prevent cleanup, otherwise eNew might disappear before we've even
  // had a chance to mark it as a temporary edge.
  libtess.sweep.addRightEdges_(tess, regUp, eNew, eNew.oNext, eNew.oNext,
      false);
  eNew.sym.activeRegion.fixUpperEdge = true;
  libtess.sweep.walkDirtyRegions_(tess, regUp);
};


/**
 * The event vertex lies exacty on an already-processed edge or vertex.
 * Adding the new vertex involves splicing it into the already-processed
 * part of the mesh.
 * @private
 * @param {!libtess.GluTesselator} tess
 * @param {libtess.ActiveRegion} regUp [description].
 * @param {libtess.GluVertex} vEvent [description].
 */
libtess.sweep.connectLeftDegenerate_ = function(tess, regUp, vEvent) {
  var e = regUp.eUp;
  /* istanbul ignore if */
  if (libtess.geom.vertEq(e.org, vEvent)) {
    // NOTE(bckenny): this code is unreachable but remains for a hypothetical
    // future extension of libtess. See docs on libtess.sweep.TOLERANCE_NONZERO_
    // for more information. Conditional on TOLERANCE_NONZERO_ to help Closure
    // Compiler eliminate dead code.
    // e.org is an unprocessed vertex - just combine them, and wait
    // for e.org to be pulled from the queue
    if (libtess.sweep.TOLERANCE_NONZERO_) {
      libtess.sweep.spliceMergeVertices_(tess, e, vEvent.anEdge);
    }
    return;
  }

  if (!libtess.geom.vertEq(e.dst(), vEvent)) {
    // General case -- splice vEvent into edge e which passes through it
    libtess.mesh.splitEdge(e.sym);

    if (regUp.fixUpperEdge) {
      // This edge was fixable -- delete unused portion of original edge
      libtess.mesh.deleteEdge(e.oNext);
      regUp.fixUpperEdge = false;
    }

    libtess.mesh.meshSplice(vEvent.anEdge, e);

    // recurse
    libtess.sweep.sweepEvent_(tess, vEvent);
    return;
  }

  // NOTE(bckenny): this code is unreachable but remains for a hypothetical
  // future extension of libtess. See docs on libtess.sweep.TOLERANCE_NONZERO_
  // for more information. Conditional on TOLERANCE_NONZERO_ to help Closure
  // Compiler eliminate dead code.
  // vEvent coincides with e.dst(), which has already been processed.
  // Splice in the additional right-going edges.
  /* istanbul ignore next */

  /* istanbul ignore next */
  if (libtess.sweep.TOLERANCE_NONZERO_) {
    regUp = libtess.sweep.topRightRegion_(regUp);
    var reg = regUp.regionBelow();
    var eTopRight = reg.eUp.sym;
    var eTopLeft = eTopRight.oNext;
    var eLast = eTopLeft;

    if (reg.fixUpperEdge) {
      // Here e.dst() has only a single fixable edge going right.
      // We can delete it since now we have some real right-going edges.

      // there are some left edges too
      libtess.sweep.deleteRegion_(tess, reg); // TODO(bckenny): something to null?
      libtess.mesh.deleteEdge(eTopRight);
      eTopRight = eTopLeft.oPrev();
    }

    libtess.mesh.meshSplice(vEvent.anEdge, eTopRight);
    if (!libtess.geom.edgeGoesLeft(eTopLeft)) {
      // e.dst() had no left-going edges -- indicate this to addRightEdges()
      eTopLeft = null;
    }

    libtess.sweep.addRightEdges_(tess, regUp, eTopRight.oNext, eLast, eTopLeft,
        true);
  }
};


/**
 * Connect a "left" vertex (one where both edges go right)
 * to the processed portion of the mesh. Let R be the active region
 * containing vEvent, and let U and L be the upper and lower edge
 * chains of R. There are two possibilities:
 *
 * - the normal case: split R into two regions, by connecting vEvent to
 *   the rightmost vertex of U or L lying to the left of the sweep line
 *
 * - the degenerate case: if vEvent is close enough to U or L, we
 *   merge vEvent into that edge chain. The subcases are:
 *  - merging with the rightmost vertex of U or L
 *  - merging with the active edge of U or L
 *  - merging with an already-processed portion of U or L
 *
 * @private
 * @param {libtess.GluTesselator} tess   [description].
 * @param {libtess.GluVertex} vEvent [description].
 */
libtess.sweep.connectLeftVertex_ = function(tess, vEvent) {
  // TODO(bckenny): tmp only used for sweep. better to keep tmp across calls?
  var tmp = new libtess.ActiveRegion();

  // NOTE(bckenny): this was commented out in the original
  // libtess.assert(vEvent.anEdge.oNext.oNext === vEvent.anEdge);

  // Get a pointer to the active region containing vEvent
  tmp.eUp = vEvent.anEdge.sym;
  var regUp = tess.dict.search(tmp).getKey();
  var regLo = regUp.regionBelow();
  var eUp = regUp.eUp;
  var eLo = regLo.eUp;

  // try merging with U or L first
  if (libtess.geom.edgeSign(eUp.dst(), vEvent, eUp.org) === 0) {
    libtess.sweep.connectLeftDegenerate_(tess, regUp, vEvent);
    return;
  }

  // Connect vEvent to rightmost processed vertex of either chain.
  // e.dst() is the vertex that we will connect to vEvent.
  var reg = libtess.geom.vertLeq(eLo.dst(), eUp.dst()) ? regUp : regLo;
  var eNew;
  if (regUp.inside || reg.fixUpperEdge) {
    if (reg === regUp) {
      eNew = libtess.mesh.connect(vEvent.anEdge.sym, eUp.lNext);

    } else {
      var tempHalfEdge = libtess.mesh.connect(eLo.dNext(), vEvent.anEdge);
      eNew = tempHalfEdge.sym;
    }

    if (reg.fixUpperEdge) {
      libtess.sweep.fixUpperEdge_(reg, eNew);

    } else {
      libtess.sweep.computeWinding_(tess,
          libtess.sweep.addRegionBelow_(tess, regUp, eNew));
    }
    libtess.sweep.sweepEvent_(tess, vEvent);

  } else {
    // The new vertex is in a region which does not belong to the polygon.
    // We don''t need to connect this vertex to the rest of the mesh.
    libtess.sweep.addRightEdges_(tess, regUp, vEvent.anEdge, vEvent.anEdge,
        null, true);
  }
};


/**
 * Does everything necessary when the sweep line crosses a vertex.
 * Updates the mesh and the edge dictionary.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {libtess.GluVertex} vEvent [description].
 */
libtess.sweep.sweepEvent_ = function(tess, vEvent) {
  tess.event = vEvent; // for access in edgeLeq_ // TODO(bckenny): wuh?

  /* Check if this vertex is the right endpoint of an edge that is
   * already in the dictionary.  In this case we don't need to waste
   * time searching for the location to insert new edges.
   */
  var e = vEvent.anEdge;
  while (e.activeRegion === null) {
    e = e.oNext;
    if (e === vEvent.anEdge) {
      // All edges go right -- not incident to any processed edges
      libtess.sweep.connectLeftVertex_(tess, vEvent);
      return;
    }
  }

  /* Processing consists of two phases: first we "finish" all the
   * active regions where both the upper and lower edges terminate
   * at vEvent (ie. vEvent is closing off these regions).
   * We mark these faces "inside" or "outside" the polygon according
   * to their winding number, and delete the edges from the dictionary.
   * This takes care of all the left-going edges from vEvent.
   */
  var regUp = libtess.sweep.topLeftRegion_(e.activeRegion);
  var reg = regUp.regionBelow();
  var eTopLeft = reg.eUp;
  var eBottomLeft = libtess.sweep.finishLeftRegions_(tess, reg, null);

  /* Next we process all the right-going edges from vEvent. This
   * involves adding the edges to the dictionary, and creating the
   * associated "active regions" which record information about the
   * regions between adjacent dictionary edges.
   */
  if (eBottomLeft.oNext === eTopLeft) {
    // No right-going edges -- add a temporary "fixable" edge
    libtess.sweep.connectRightVertex_(tess, regUp, eBottomLeft);

  } else {
    libtess.sweep.addRightEdges_(tess, regUp, eBottomLeft.oNext, eTopLeft,
        eTopLeft, true);
  }
};


/**
 * We add two sentinel edges above and below all other edges,
 * to avoid special cases at the top and bottom.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 * @param {number} t [description].
 */
libtess.sweep.addSentinel_ = function(tess, t) {
  var reg = new libtess.ActiveRegion();

  var e = libtess.mesh.makeEdge(tess.mesh);

  e.org.s = libtess.sweep.SENTINEL_COORD_;
  e.org.t = t;
  e.dst().s = -libtess.sweep.SENTINEL_COORD_;
  e.dst().t = t;
  tess.event = e.dst(); //initialize it

  reg.eUp = e;
  reg.windingNumber = 0;
  reg.inside = false;
  reg.fixUpperEdge = false;
  reg.sentinel = true;
  reg.dirty = false;
  reg.nodeUp = tess.dict.insert(reg);
};


/**
 * We maintain an ordering of edge intersections with the sweep line.
 * This order is maintained in a dynamic dictionary.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.initEdgeDict_ = function(tess) {
  tess.dict = new libtess.Dict(tess, libtess.sweep.edgeLeq_);

  libtess.sweep.addSentinel_(tess, -libtess.sweep.SENTINEL_COORD_);
  libtess.sweep.addSentinel_(tess, libtess.sweep.SENTINEL_COORD_);
};


/**
 * [doneEdgeDict_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.doneEdgeDict_ = function(tess) {
  // NOTE(bckenny): fixedEdges is only used in the assert below, so ignore so
  // when asserts are removed jshint won't error.
  /* jshint unused:false */
  var fixedEdges = 0;

  var reg;
  while ((reg = tess.dict.getMin().getKey()) !== null) {
    // At the end of all processing, the dictionary should contain
    // only the two sentinel edges, plus at most one "fixable" edge
    // created by connectRightVertex().
    if (!reg.sentinel) {
    }
    libtess.sweep.deleteRegion_(tess, reg);
  }

  // NOTE(bckenny): see tess.dict.deleteDict_() for old delete dict function
  tess.dict = null;
};


/**
 * Remove zero-length edges, and contours with fewer than 3 vertices.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.removeDegenerateEdges_ = function(tess) {
  var eHead = tess.mesh.eHead;

  var eNext;
  for (var e = eHead.next; e !== eHead; e = eNext) {
    eNext = e.next;
    var eLNext = e.lNext;

    if (libtess.geom.vertEq(e.org, e.dst()) && e.lNext.lNext !== e) {
      // Zero-length edge, contour has at least 3 edges
      libtess.sweep.spliceMergeVertices_(tess, eLNext, e); // deletes e.org
      libtess.mesh.deleteEdge(e); // e is a self-loop TODO(bckenny): does this comment really apply here?
      e = eLNext;
      eLNext = e.lNext;
    }

    if (eLNext.lNext === e) {
      // Degenerate contour (one or two edges)
      if (eLNext !== e) {
        if (eLNext === eNext || eLNext === eNext.sym) {
          eNext = eNext.next;
        }
        libtess.mesh.deleteEdge(eLNext);
      }

      if (e === eNext || e === eNext.sym) {
        eNext = eNext.next;
      }
      libtess.mesh.deleteEdge(e);
    }
  }
};


/**
 * Construct priority queue and insert all vertices into it, which determines
 * the order in which vertices cross the sweep line.
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.initPriorityQ_ = function(tess) {
  var pq = new libtess.PriorityQ();
  tess.pq = pq;

  var vHead = tess.mesh.vHead;
  var v;
  for (v = vHead.next; v !== vHead; v = v.next) {
    v.pqHandle = pq.insert(v);
  }

  pq.init();
};


/**
 * [donePriorityQ_ description]
 * @private
 * @param {libtess.GluTesselator} tess [description].
 */
libtess.sweep.donePriorityQ_ = function(tess) {
  // TODO(bckenny): probably don't need deleteQ. check that function for comment
  tess.pq.deleteQ();
  tess.pq = null;
};


/**
 * Delete any degenerate faces with only two edges. walkDirtyRegions()
 * will catch almost all of these, but it won't catch degenerate faces
 * produced by splice operations on already-processed edges.
 * The two places this can happen are in finishLeftRegions(), when
 * we splice in a "temporary" edge produced by connectRightVertex(),
 * and in checkForLeftSplice(), where we splice already-processed
 * edges to ensure that our dictionary invariants are not violated
 * by numerical errors.
 *
 * In both these cases it is *very* dangerous to delete the offending
 * edge at the time, since one of the routines further up the stack
 * will sometimes be keeping a pointer to that edge.
 *
 * @private
 * @param {libtess.GluMesh} mesh [description].
 */
libtess.sweep.removeDegenerateFaces_ = function(mesh) {
  var fNext;
  for (var f = mesh.fHead.next; f !== mesh.fHead; f = fNext) {
    fNext = f.next;
    var e = f.anEdge;

    if (e.lNext.lNext === e) {
      // A face with only two edges
      libtess.sweep.addWinding_(e.oNext, e);
      libtess.mesh.deleteEdge(e);
    }
  }
};

/* global libtess */

/** @const */
libtess.tessmono = {};

/**
 * Tessellates a monotone region (what else would it do??). The region must
 * consist of a single loop of half-edges (see mesh.js) oriented CCW. "Monotone"
 * in this case means that any vertical line intersects the interior of the
 * region in a single interval.
 *
 * Tessellation consists of adding interior edges (actually pairs of
 * half-edges), to split the region into non-overlapping triangles.
 * @private
 * @param {!libtess.GluFace} face
 */
libtess.tessmono.tessellateMonoRegion_ = function(face) {
  /* The basic idea is explained in Preparata and Shamos (which I don't
   * have handy right now), although their implementation is more
   * complicated than this one. The are two edge chains, an upper chain
   * and a lower chain. We process all vertices from both chains in order,
   * from right to left.
   *
   * The algorithm ensures that the following invariant holds after each
   * vertex is processed: the untessellated region consists of two
   * chains, where one chain (say the upper) is a single edge, and
   * the other chain is concave. The left vertex of the single edge
   * is always to the left of all vertices in the concave chain.
   *
   * Each step consists of adding the rightmost unprocessed vertex to one
   * of the two chains, and forming a fan of triangles from the rightmost
   * of two chain endpoints. Determining whether we can add each triangle
   * to the fan is a simple orientation test. By making the fan as large
   * as possible, we restore the invariant (check it yourself).
   *
   * All edges are oriented CCW around the boundary of the region.
   * First, find the half-edge whose origin vertex is rightmost.
   * Since the sweep goes from left to right, face.anEdge should
   * be close to the edge we want.
   */
  var up = face.anEdge;

  for (; libtess.geom.vertLeq(up.dst(), up.org); up = up.lPrev()) { }
  for (; libtess.geom.vertLeq(up.org, up.dst()); up = up.lNext) { }

  var lo = up.lPrev();

  var tempHalfEdge;
  while (up.lNext !== lo) {
    if (libtess.geom.vertLeq(up.dst(), lo.org)) {
      // up.dst() is on the left. It is safe to form triangles from lo.org.
      // The edgeGoesLeft test guarantees progress even when some triangles
      // are CW, given that the upper and lower chains are truly monotone.
      while (lo.lNext !== up && (libtess.geom.edgeGoesLeft(lo.lNext) ||
          libtess.geom.edgeSign(lo.org, lo.dst(), lo.lNext.dst()) <= 0)) {

        tempHalfEdge = libtess.mesh.connect(lo.lNext, lo);
        lo = tempHalfEdge.sym;
      }
      lo = lo.lPrev();

    } else {
      // lo.org is on the left. We can make CCW triangles from up.dst().
      while (lo.lNext !== up && (libtess.geom.edgeGoesRight(up.lPrev()) ||
          libtess.geom.edgeSign(up.dst(), up.org, up.lPrev().org) >= 0)) {

        tempHalfEdge = libtess.mesh.connect(up, up.lPrev());
        up = tempHalfEdge.sym;
      }
      up = up.lNext;
    }
  }

  // Now lo.org == up.dst() == the leftmost vertex. The remaining region
  // can be tessellated in a fan from this leftmost vertex.
  while (lo.lNext.lNext !== up) {
    tempHalfEdge = libtess.mesh.connect(lo.lNext, lo);
    lo = tempHalfEdge.sym;
  }
};

/**
 * Tessellates each region of the mesh which is marked "inside" the polygon.
 * Each such region must be monotone.
 * @param {!libtess.GluMesh} mesh
 */
libtess.tessmono.tessellateInterior = function(mesh) {
  var next;
  for (var f = mesh.fHead.next; f !== mesh.fHead; f = next) {
    // Make sure we don't try to tessellate the new triangles.
    next = f.next;
    if (f.inside) {
      libtess.tessmono.tessellateMonoRegion_(f);
    }
  }
};

/**
 * Zaps (i.e. sets to null) all faces which are not marked "inside" the polygon.
 * Since further mesh operations on null faces are not allowed, the main purpose
 * is to clean up the mesh so that exterior loops are not represented in the
 * data structure.
 * @param {!libtess.GluMesh} mesh
 */
libtess.tessmono.discardExterior = function(mesh) {
  var next;
  for (var f = mesh.fHead.next; f !== mesh.fHead; f = next) {
    // Since f will be destroyed, save its next pointer.
    next = f.next;
    if (!f.inside) {
      libtess.mesh.zapFace(f);
    }
  }
};

/**
 * Resets the winding numbers on all edges so that regions marked "inside" the
 * polygon have a winding number of "value", and regions outside have a winding
 * number of 0.
 *
 * If keepOnlyBoundary is true, it also deletes all edges which do not separate
 * an interior region from an exterior one.
 *
 * @param {!libtess.GluMesh} mesh
 * @param {number} value
 * @param {boolean} keepOnlyBoundary
 */
libtess.tessmono.setWindingNumber = function(mesh, value, keepOnlyBoundary) {
  var eNext;
  for (var e = mesh.eHead.next; e !== mesh.eHead; e = eNext) {
    eNext = e.next;

    if (e.rFace().inside !== e.lFace.inside) {
      // This is a boundary edge (one side is interior, one is exterior).
      e.winding = (e.lFace.inside) ? value : -value;

    } else {
      // Both regions are interior, or both are exterior.
      if (!keepOnlyBoundary) {
        e.winding = 0;

      } else {
        libtess.mesh.deleteEdge(e);
      }
    }
  }
};

/* global libtess */

/**
 * A list of edges crossing the sweep line, sorted from top to bottom.
 * Implementation is a doubly-linked list, sorted by the injected edgeLeq
 * comparator function. Here it is a simple ordering, but see libtess.sweep for
 * the list of invariants on the edge dictionary this ordering creates.
 * @constructor
 * @struct
 * @param {!libtess.GluTesselator} frame
 * @param {function(!libtess.GluTesselator, !libtess.ActiveRegion, !libtess.ActiveRegion): boolean} leq
 */
libtess.Dict = function(frame, leq) {

  /**
   * The head of the doubly-linked DictNode list. At creation time, links back
   * and forward only to itself.
   * @private {!libtess.DictNode}
   */
  this.head_ = new libtess.DictNode();

  /**
   * The GluTesselator used as the frame for edge/event comparisons.
   * @private {!libtess.GluTesselator}
   */
  this.frame_ = frame;

  /**
   * Comparison function to maintain the invariants of the Dict. See
   * libtess.sweep.edgeLeq_ for source.
   * @private
   * @type {function(!libtess.GluTesselator, !libtess.ActiveRegion, !libtess.ActiveRegion): boolean}
   */
  this.leq_ = leq;
};

/* istanbul ignore next */
/**
 * Formerly used to delete the dict.
 * NOTE(bckenny): No longer called but left for memFree documentation. Nulled at
 * former callsite instead (sweep.doneEdgeDict_)
 * @private
 */
libtess.Dict.prototype.deleteDict_ = function() {
  // for (var node = this.head_.next; node !== this.head_; node = node.next) {
  //   memFree(node);
  // }
  // memFree(dict);
};

/**
 * Insert the supplied key into the edge list and return its new node.
 * @param {libtess.DictNode} node
 * @param {!libtess.ActiveRegion} key
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.insertBefore = function(node, key) {
  do {
    node = node.prev;
  } while (node.key !== null && !this.leq_(this.frame_, node.key, key));

  // insert the new node and update the surrounding nodes to point to it
  var newNode = new libtess.DictNode(key, node.next, node);
  node.next.prev = newNode;
  node.next = newNode;

  return newNode;
};

/**
 * Insert key into the dict and return the new node that contains it.
 * @param {!libtess.ActiveRegion} key
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.insert = function(key) {
  // NOTE(bckenny): from a macro in dict.h/dict-list.h
  return this.insertBefore(this.head_, key);
};

/**
 * Remove node from the list.
 * @param {libtess.DictNode} node
 */
libtess.Dict.prototype.deleteNode = function(node) {
  node.next.prev = node.prev;
  node.prev.next = node.next;

  // NOTE(bckenny): nulled at callsite (sweep.deleteRegion_)
  // memFree( node );
};

/**
 * Search returns the node with the smallest key greater than or equal
 * to the given key. If there is no such key, returns a node whose
 * key is null. Similarly, max(d).getSuccessor() has a null key, etc.
 * @param {!libtess.ActiveRegion} key
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.search = function(key) {
  var node = this.head_;

  do {
    node = node.next;
  } while (node.key !== null && !this.leq_(this.frame_, key, node.key));

  return node;
};

/**
 * Return the node with the smallest key.
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.getMin = function() {
  // NOTE(bckenny): from a macro in dict.h/dict-list.h
  return this.head_.next;
};

// NOTE(bckenny): libtess.Dict.getMax isn't called within libtess and isn't part
// of the public API. For now, leaving in but ignoring for coverage.
/* istanbul ignore next */
/**
 * Returns the node with the greatest key.
 * @return {!libtess.DictNode}
 */
libtess.Dict.prototype.getMax = function() {
  // NOTE(bckenny): from a macro in dict.h/dict-list.h
  return this.head_.prev;
};

/* global libtess */

/**
 * A doubly-linked-list node with a libtess.ActiveRegion payload.
 * The key for this node and the next and previous nodes in the parent Dict list
 * can be provided to insert it into an existing list (or all can be omitted if
 * this is to be the founding node of the list).
 * @param {!libtess.ActiveRegion=} opt_key
 * @param {!libtess.DictNode=} opt_nextNode
 * @param {!libtess.DictNode=} opt_prevNode
 * @constructor
 * @struct
 */
libtess.DictNode = function(opt_key, opt_nextNode, opt_prevNode) {
  /**
   * The ActiveRegion key for this node, or null if the head of the list.
   * @type {libtess.ActiveRegion}
   */
  this.key = opt_key || null;

  /**
   * Link to next DictNode in parent list or to self if this is the first node.
   * @type {!libtess.DictNode}
   */
  this.next = opt_nextNode || this;

  /**
   * Link to previous DictNode in parent list or to self if this is the first
   * node.
   * @type {!libtess.DictNode}
   */
  this.prev = opt_prevNode || this;
};

/**
 * Get the key from this node.
 * @return {libtess.ActiveRegion}
 */
libtess.DictNode.prototype.getKey = function() {
  return this.key;
};

/**
 * Get the successor node to this one.
 * @return {!libtess.DictNode}
 */
libtess.DictNode.prototype.getSuccessor = function() {
  return this.next;
};

/**
 * Get the predecessor node to this one.
 * @return {!libtess.DictNode}
 */
libtess.DictNode.prototype.getPredecessor = function() {
  return this.prev;
};

/* global libtess */

// TODO(bckenny): create more javascript-y API, e.g. make gluTessEndPolygon
// async, don't require so many temp objects created

/**
 * The tesselator main class, providing the public API.
 * @constructor
 * @struct
 */
libtess.GluTesselator = function() {
  // Only initialize fields which can be changed by the api. Other fields
  // are initialized where they are used.

  /*** state needed for collecting the input data ***/

  /**
   * Tesselator state, tracking what begin/end calls have been seen.
   * @private {libtess.GluTesselator.tessState_}
   */
  this.state_ = libtess.GluTesselator.tessState_.T_DORMANT;

  /**
   * lastEdge_.org is the most recent vertex
   * @private {libtess.GluHalfEdge}
   */
  this.lastEdge_ = null;

  /**
   * stores the input contours, and eventually the tessellation itself
   * @type {libtess.GluMesh}
   */
  this.mesh = null;

  /**
   * Error callback.
   * @private {?function((libtess.errorType|libtess.gluEnum), Object=)}
   */
  this.errorCallback_ = null;

  /*** state needed for projecting onto the sweep plane ***/

  /**
   * user-specified normal (if provided)
   * @private {!Array<number>}
   */
  this.normal_ = [0, 0, 0];

  /*** state needed for the line sweep ***/

  /**
   * rule for determining polygon interior
   * @type {libtess.windingRule}
   */
  this.windingRule = libtess.windingRule.GLU_TESS_WINDING_ODD;

  /**
   * fatal error: needed combine callback
   * @type {boolean}
   */
  this.fatalError = false;

  /**
   * edge dictionary for sweep line
   * @type {libtess.Dict}
   */
  this.dict = null;
  // NOTE(bckenny): dict initialized in sweep.initEdgeDict_, removed in sweep.doneEdgeDict_

  /**
   * priority queue of vertex events
   * @type {libtess.PriorityQ}
   */
  this.pq = null;
  // NOTE(bckenny): pq initialized in sweep.initPriorityQ

  /**
   * current sweep event being processed
   * @type {libtess.GluVertex}
   */
  this.event = null;

  /**
   * Combine callback.
   * @private {?function(Array<number>, Array<Object>, Array<number>, Object=): Object}
   */
  this.combineCallback_ = null;

  /*** state needed for rendering callbacks (see render.js) ***/

  /**
   * Extract contours, not triangles
   * @private {boolean}
   */
  this.boundaryOnly_ = false;

  /**
   * Begin callback.
   * @private {?function(libtess.primitiveType, Object=)}
   */
  this.beginCallback_ = null;

  /**
   * Edge flag callback.
   * @private {?function(boolean, Object=)}
   */
  this.edgeFlagCallback_ = null;

  /**
   * Vertex callback.
   * @private {?function(Object, Object=)}
   */
  this.vertexCallback_ = null;

  /**
   * End callback.
   * @private {?function(Object=)}
   */
  this.endCallback_ = null;

  /**
   * Mesh callback.
   * @private {?function(libtess.GluMesh)}
   */
  this.meshCallback_ = null;

  /**
   * client data for current polygon
   * @private {Object}
   */
  this.polygonData_ = null;
};

/**
 * The begin/end calls must be properly nested. We keep track of the current
 * state to enforce the ordering.
 * @enum {number}
 * @private
 */
libtess.GluTesselator.tessState_ = {
  T_DORMANT: 0,
  T_IN_POLYGON: 1,
  T_IN_CONTOUR: 2
};

/**
 * Destory the tesselator object. See README.
 */
libtess.GluTesselator.prototype.gluDeleteTess = function() {
  // TODO(bckenny): This does nothing but assert that it isn't called while
  // building the polygon since we rely on GC to handle memory. *If* the public
  // API changes, this should go.
  this.requireState_(libtess.GluTesselator.tessState_.T_DORMANT);
  // memFree(tess); TODO(bckenny)
};

/**
 * Set properties for control over tesselation. See README.
 * @param {libtess.gluEnum} which [description].
 * @param {number|boolean} value [description].
 */
libtess.GluTesselator.prototype.gluTessProperty = function(which, value) {
  // TODO(bckenny): split into more setters?
  // TODO(bckenny): in any case, we can do better than this switch statement

  switch (which) {
    case libtess.gluEnum.GLU_TESS_TOLERANCE:
      // NOTE(bckenny): libtess has never supported any tolerance but 0.
      return;

    case libtess.gluEnum.GLU_TESS_WINDING_RULE:
      var windingRule = /** @type {libtess.windingRule} */(value);

      switch (windingRule) {
        case libtess.windingRule.GLU_TESS_WINDING_ODD:
        case libtess.windingRule.GLU_TESS_WINDING_NONZERO:
        case libtess.windingRule.GLU_TESS_WINDING_POSITIVE:
        case libtess.windingRule.GLU_TESS_WINDING_NEGATIVE:
        case libtess.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
          this.windingRule = windingRule;
          return;
        default:
      }
      break;

    case libtess.gluEnum.GLU_TESS_BOUNDARY_ONLY:
      this.boundaryOnly_ = !!value;
      return;

    default:
      this.callErrorCallback(libtess.gluEnum.GLU_INVALID_ENUM);
      return;
  }
  this.callErrorCallback(libtess.gluEnum.GLU_INVALID_VALUE);
};

/**
 * Returns tessellator property
 * @param {libtess.gluEnum} which [description].
 * @return {number|boolean} [description].
 */
libtess.GluTesselator.prototype.gluGetTessProperty = function(which) {
  // TODO(bckenny): as above, split into more getters? and improve on switch statement
  // why are these being asserted in getter but not setter?

  switch (which) {
    case libtess.gluEnum.GLU_TESS_TOLERANCE:
      return 0;

    case libtess.gluEnum.GLU_TESS_WINDING_RULE:
      var rule = this.windingRule;
      return rule;

    case libtess.gluEnum.GLU_TESS_BOUNDARY_ONLY:
      return this.boundaryOnly_;

    default:
      this.callErrorCallback(libtess.gluEnum.GLU_INVALID_ENUM);
      break;
  }
  return false;
};

/**
 * Lets the user supply the polygon normal, if known. All input data is
 * projected into a plane perpendicular to the normal before tesselation. All
 * output triangles are oriented CCW with respect to the normal (CW orientation
 * can be obtained by reversing the sign of the supplied normal). For example,
 * if you know that all polygons lie in the x-y plane, call
 * `tess.gluTessNormal(0.0, 0.0, 1.0)` before rendering any polygons.
 * @param {number} x
 * @param {number} y
 * @param {number} z
 */
libtess.GluTesselator.prototype.gluTessNormal = function(x, y, z) {
  this.normal_[0] = x;
  this.normal_[1] = y;
  this.normal_[2] = z;
};

/**
 * Specify callbacks. See README for callback descriptions. A null or undefined
 * opt_fn removes current callback.
 * @param {libtess.gluEnum} which The callback-type gluEnum value.
 * @param {?Function=} opt_fn
 */
libtess.GluTesselator.prototype.gluTessCallback = function(which, opt_fn) {
  var fn = !opt_fn ? null : opt_fn;
  // TODO(bckenny): better opt_fn typing?
  // TODO(bckenny): should add documentation that references in callback are volatile (or make a copy)

  switch (which) {
    case libtess.gluEnum.GLU_TESS_BEGIN:
    case libtess.gluEnum.GLU_TESS_BEGIN_DATA:
      this.beginCallback_ = /** @type {?function(libtess.primitiveType, Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_EDGE_FLAG:
    case libtess.gluEnum.GLU_TESS_EDGE_FLAG_DATA:
      this.edgeFlagCallback_ = /** @type {?function(boolean, Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_VERTEX:
    case libtess.gluEnum.GLU_TESS_VERTEX_DATA:
      this.vertexCallback_ = /** @type {?function(Object, Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_END:
    case libtess.gluEnum.GLU_TESS_END_DATA:
      this.endCallback_ = /** @type {?function(Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_ERROR:
    case libtess.gluEnum.GLU_TESS_ERROR_DATA:
      this.errorCallback_ = /** @type {?function((libtess.errorType|libtess.gluEnum), Object=)} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_COMBINE:
    case libtess.gluEnum.GLU_TESS_COMBINE_DATA:
      this.combineCallback_ = /** @type {?function(Array<number>, Array<Object>, Array<number>, Object=): Object} */ (fn);
      return;

    case libtess.gluEnum.GLU_TESS_MESH:
      this.meshCallback_ = /** @type {?function(libtess.GluMesh)} */ (fn);
      return;

    default:
      this.callErrorCallback(libtess.gluEnum.GLU_INVALID_ENUM);
      return;
  }
};

/**
 * Specify a vertex and associated data. Must be within calls to
 * beginContour/endContour. See README.
 * @param {!Array<number>} coords
 * @param {Object} data
 */
libtess.GluTesselator.prototype.gluTessVertex = function(coords, data) {
  var tooLarge = false;

  // TODO(bckenny): pool allocation?
  var clamped = [0, 0, 0];

  this.requireState_(libtess.GluTesselator.tessState_.T_IN_CONTOUR);

  for (var i = 0; i < 3; ++i) {
    var x = coords[i];
    if (x < -libtess.GLU_TESS_MAX_COORD) {
      x = -libtess.GLU_TESS_MAX_COORD;
      tooLarge = true;
    }
    if (x > libtess.GLU_TESS_MAX_COORD) {
      x = libtess.GLU_TESS_MAX_COORD;
      tooLarge = true;
    }
    clamped[i] = x;
  }

  if (tooLarge) {
    this.callErrorCallback(libtess.errorType.GLU_TESS_COORD_TOO_LARGE);
  }

  this.addVertex_(clamped, data);
};

/**
 * [gluTessBeginPolygon description]
 * @param {Object} data Client data for current polygon.
 */
libtess.GluTesselator.prototype.gluTessBeginPolygon = function(data) {
  this.requireState_(libtess.GluTesselator.tessState_.T_DORMANT);

  this.state_ = libtess.GluTesselator.tessState_.T_IN_POLYGON;

  this.mesh = new libtess.GluMesh();

  this.polygonData_ = data;
};

/**
 * [gluTessBeginContour description]
 */
libtess.GluTesselator.prototype.gluTessBeginContour = function() {
  this.requireState_(libtess.GluTesselator.tessState_.T_IN_POLYGON);

  this.state_ = libtess.GluTesselator.tessState_.T_IN_CONTOUR;
  this.lastEdge_ = null;
};

/**
 * [gluTessEndContour description]
 */
libtess.GluTesselator.prototype.gluTessEndContour = function() {
  this.requireState_(libtess.GluTesselator.tessState_.T_IN_CONTOUR);
  this.state_ = libtess.GluTesselator.tessState_.T_IN_POLYGON;
};

/**
 * [gluTessEndPolygon description]
 */
libtess.GluTesselator.prototype.gluTessEndPolygon = function() {
  this.requireState_(libtess.GluTesselator.tessState_.T_IN_POLYGON);
  this.state_ = libtess.GluTesselator.tessState_.T_DORMANT;

  // Determine the polygon normal and project vertices onto the plane
  // of the polygon.
  libtess.normal.projectPolygon(this, this.normal_[0], this.normal_[1],
      this.normal_[2]);

  // computeInterior(tess) computes the planar arrangement specified
  // by the given contours, and further subdivides this arrangement
  // into regions. Each region is marked "inside" if it belongs
  // to the polygon, according to the rule given by this.windingRule.
  // Each interior region is guaranteed be monotone.
  libtess.sweep.computeInterior(this);

  if (!this.fatalError) {
    // If the user wants only the boundary contours, we throw away all edges
    // except those which separate the interior from the exterior.
    // Otherwise we tessellate all the regions marked "inside".
    // NOTE(bckenny): we know this.mesh has been initialized, so help closure out.
    var mesh = /** @type {!libtess.GluMesh} */(this.mesh);
    if (this.boundaryOnly_) {
      libtess.tessmono.setWindingNumber(mesh, 1, true);
    } else {
      libtess.tessmono.tessellateInterior(mesh);
    }

    this.mesh.checkMesh();

    if (this.beginCallback_ || this.endCallback_ || this.vertexCallback_ ||
        this.edgeFlagCallback_) {

      if (this.boundaryOnly_) {
        // output boundary contours
        libtess.render.renderBoundary(this, this.mesh);

      } else {
        // output triangles (with edge callback if one is set)
        var flagEdges = !!this.edgeFlagCallback_;
        libtess.render.renderMesh(this, this.mesh, flagEdges);
      }
    }

    if (this.meshCallback_) {
      // Throw away the exterior faces, so that all faces are interior.
      // This way the user doesn't have to check the "inside" flag,
      // and we don't need to even reveal its existence. It also leaves
      // the freedom for an implementation to not generate the exterior
      // faces in the first place.
      libtess.tessmono.discardExterior(this.mesh);
      // user wants the mesh itself
      this.meshCallback_(this.mesh);

      this.mesh = null;
      this.polygonData_ = null;
      return;
    }
  }

  libtess.mesh.deleteMesh(this.mesh);
  this.polygonData_ = null;
  this.mesh = null;
};

/**
 * Change the tesselator state.
 * @private
 * @param {libtess.GluTesselator.tessState_} state
 */
libtess.GluTesselator.prototype.requireState_ = function(state) {
  if (this.state_ !== state) {
    this.gotoState_(state);
  }
};

/**
 * Change the current tesselator state one level at a time to get to the
 * desired state. Only triggered when the API is not called in the correct order
 * so an error callback is made, however the tesselator will always attempt to
 * recover afterwards (see README).
 * @private
 * @param {libtess.GluTesselator.tessState_} newState
 */
libtess.GluTesselator.prototype.gotoState_ = function(newState) {
  while (this.state_ !== newState) {
    if (this.state_ < newState) {
      switch (this.state_) {
        case libtess.GluTesselator.tessState_.T_DORMANT:
          this.callErrorCallback(
              libtess.errorType.GLU_TESS_MISSING_BEGIN_POLYGON);
          this.gluTessBeginPolygon(null);
          break;

        case libtess.GluTesselator.tessState_.T_IN_POLYGON:
          this.callErrorCallback(
              libtess.errorType.GLU_TESS_MISSING_BEGIN_CONTOUR);
          this.gluTessBeginContour();
          break;
      }

    } else {
      switch (this.state_) {
        case libtess.GluTesselator.tessState_.T_IN_CONTOUR:
          this.callErrorCallback(
              libtess.errorType.GLU_TESS_MISSING_END_CONTOUR);
          this.gluTessEndContour();
          break;

        case libtess.GluTesselator.tessState_.T_IN_POLYGON:
          this.callErrorCallback(
              libtess.errorType.GLU_TESS_MISSING_END_POLYGON);
          // NOTE(bckenny): libtess originally reset the tesselator, even though
          // the README claims it should spit out the tessellated results at
          // this point.
          // (see http://cgit.freedesktop.org/mesa/glu/tree/src/libtess/tess.c#n180)
          this.gluTessEndPolygon();
          break;
      }
    }
  }
};

/**
 * [addVertex_ description]
 * @private
 * @param {!Array<number>} coords [description].
 * @param {Object} data [description].
 */
libtess.GluTesselator.prototype.addVertex_ = function(coords, data) {
  var e = this.lastEdge_;
  if (e === null) {
    // Make a self-loop (one vertex, one edge).
    e = libtess.mesh.makeEdge(this.mesh);
    libtess.mesh.meshSplice(e, e.sym);

  } else {
    // Create a new vertex and edge which immediately follow e
    // in the ordering around the left face.
    libtess.mesh.splitEdge(e);
    e = e.lNext;
  }

  // The new vertex is now e.org.
  e.org.data = data;
  e.org.coords[0] = coords[0];
  e.org.coords[1] = coords[1];
  e.org.coords[2] = coords[2];

  // The winding of an edge says how the winding number changes as we
  // cross from the edge''s right face to its left face.  We add the
  // vertices in such an order that a CCW contour will add +1 to
  // the winding number of the region inside the contour.
  e.winding = 1;
  e.sym.winding = -1;

  this.lastEdge_ = e;
};

/**
 * Call callback to indicate the start of a primitive, to be followed by emitted
 * vertices, if any. In libtess.js, `type` will always be `GL_TRIANGLES`.
 * @param {libtess.primitiveType} type
 */
libtess.GluTesselator.prototype.callBeginCallback = function(type) {
  if (this.beginCallback_) {
    this.beginCallback_(type, this.polygonData_);
  }
};

/**
 * Call callback to emit a vertex of the tessellated polygon.
 * @param {Object} data
 */
libtess.GluTesselator.prototype.callVertexCallback = function(data) {
  if (this.vertexCallback_) {
    this.vertexCallback_(data, this.polygonData_);
  }
};

/**
 * Call callback to indicate whether the vertices to follow begin edges which
 * lie on a polygon boundary.
 * @param {boolean} flag
 */
libtess.GluTesselator.prototype.callEdgeFlagCallback = function(flag) {
  if (this.edgeFlagCallback_) {
    this.edgeFlagCallback_(flag, this.polygonData_);
  }
};

/**
 * Call callback to indicate the end of tessellation.
 */
libtess.GluTesselator.prototype.callEndCallback = function() {
  if (this.endCallback_) {
    this.endCallback_(this.polygonData_);
  }
};

/* jscs:disable maximumLineLength */
/**
 * Call callback for combining vertices at edge intersection requiring the
 * creation of a new vertex.
 * @param {!Array<number>} coords Intersection coordinates.
 * @param {!Array<Object>} data Array of vertex data, one per edge vertices.
 * @param {!Array<number>} weight Coefficients used for the linear combination of vertex coordinates that gives coords.
 * @return {?Object} Interpolated vertex.
 */
libtess.GluTesselator.prototype.callCombineCallback = function(coords, data, weight) {
  if (this.combineCallback_) {
    return this.combineCallback_(coords, data, weight, this.polygonData_) ||
        null;
  }

  return null;
};
/* jscs:enable maximumLineLength */

/**
 * Call error callback, if specified, with errno.
 * @param {(libtess.errorType|libtess.gluEnum)} errno
 */
libtess.GluTesselator.prototype.callErrorCallback = function(errno) {
  if (this.errorCallback_) {
    this.errorCallback_(errno, this.polygonData_);
  }
};

/* global libtess */

/**
 * Each face has a pointer to the next and previous faces in the
 * circular list, and a pointer to a half-edge with this face as
 * the left face (null if this is the dummy header). There is also
 * a field "data" for client data.
 *
 * @param {libtess.GluFace=} opt_nextFace
 * @param {libtess.GluFace=} opt_prevFace
 * @constructor
 * @struct
 */
libtess.GluFace = function(opt_nextFace, opt_prevFace) {
  // TODO(bckenny): reverse order of params?

  /**
   * next face (never null)
   * @type {!libtess.GluFace}
   */
  this.next = opt_nextFace || this;

  /**
   * previous face (never NULL)
   * @type {!libtess.GluFace}
   */
  this.prev = opt_prevFace || this;

  /**
   * A half edge with this left face.
   * @type {libtess.GluHalfEdge}
   */
  this.anEdge = null;

  /**
   * room for client's data
   * @type {Object}
   */
  this.data = null;

  /**
   * This face is in the polygon interior.
   * @type {boolean}
   */
  this.inside = false;
};

/* global libtess */

/**
 * The fundamental data structure is the "half-edge". Two half-edges
 * go together to make an edge, but they point in opposite directions.
 * Each half-edge has a pointer to its mate (the "symmetric" half-edge sym),
 * its origin vertex (org), the face on its left side (lFace), and the
 * adjacent half-edges in the CCW direction around the origin vertex
 * (oNext) and around the left face (lNext). There is also a "next"
 * pointer for the global edge list (see below).
 *
 * The notation used for mesh navigation:
 *  sym   = the mate of a half-edge (same edge, but opposite direction)
 *  oNext = edge CCW around origin vertex (keep same origin)
 *  dNext = edge CCW around destination vertex (keep same dest)
 *  lNext = edge CCW around left face (dest becomes new origin)
 *  rNext = edge CCW around right face (origin becomes new dest)
 *
 * "prev" means to substitute CW for CCW in the definitions above.
 *
 * The circular edge list is special; since half-edges always occur
 * in pairs (e and e.sym), each half-edge stores a pointer in only
 * one direction. Starting at eHead and following the e.next pointers
 * will visit each *edge* once (ie. e or e.sym, but not both).
 * e.sym stores a pointer in the opposite direction, thus it is
 * always true that e.sym.next.sym.next === e.
 *
 * @param {libtess.GluHalfEdge=} opt_nextEdge
 * @constructor
 * @struct
 */
libtess.GluHalfEdge = function(opt_nextEdge) {
  // TODO(bckenny): are these the right defaults? (from gl_meshNewMesh requirements)

  /**
   * doubly-linked list (prev==sym->next)
   * @type {!libtess.GluHalfEdge}
   */
  this.next = opt_nextEdge || this;

  // TODO(bckenny): how can this be required if created in pairs? move to factory creation only?
  /**
   * same edge, opposite direction
   * @type {libtess.GluHalfEdge}
   */
  this.sym = null;

  /**
   * next edge CCW around origin
   * @type {libtess.GluHalfEdge}
   */
  this.oNext = null;

  /**
   * next edge CCW around left face
   * @type {libtess.GluHalfEdge}
   */
  this.lNext = null;

  /**
   * origin vertex (oVertex too long)
   * @type {libtess.GluVertex}
   */
  this.org = null;

  /**
   * left face
   * @type {libtess.GluFace}
   */
  this.lFace = null;

  // Internal data (keep hidden)
  // NOTE(bckenny): can't be private, though...

  /**
   * a region with this upper edge (see sweep.js)
   * @type {libtess.ActiveRegion}
   */
  this.activeRegion = null;

  /**
   * change in winding number when crossing from the right face to the left face
   * @type {number}
   */
  this.winding = 0;
};

// NOTE(bckenny): the following came from macros in mesh
// TODO(bckenny): using methods as aliases for sym connections for now.
// not sure about this approach. getters? renames?


/**
 * [rFace description]
 * @return {libtess.GluFace} [description].
 */
libtess.GluHalfEdge.prototype.rFace = function() {
  return this.sym.lFace;
};


/**
 * [dst description]
 * @return {libtess.GluVertex} [description].
 */
libtess.GluHalfEdge.prototype.dst = function() {
  return this.sym.org;
};


/**
 * [oPrev description]
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.GluHalfEdge.prototype.oPrev = function() {
  return this.sym.lNext;
};


/**
 * [lPrev description]
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.GluHalfEdge.prototype.lPrev = function() {
  return this.oNext.sym;
};

// NOTE(bckenny): libtess.GluHalfEdge.dPrev is called nowhere in libtess and
// isn't part of the current public API. It could be useful for mesh traversal
// and manipulation if made public, however.
/* istanbul ignore next */
/**
 * The edge clockwise around destination vertex (keep same dest).
 * @return {libtess.GluHalfEdge}
 */
libtess.GluHalfEdge.prototype.dPrev = function() {
  return this.lNext.sym;
};


/**
 * [rPrev description]
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.GluHalfEdge.prototype.rPrev = function() {
  return this.sym.oNext;
};


/**
 * [dNext description]
 * @return {libtess.GluHalfEdge} [description].
 */
libtess.GluHalfEdge.prototype.dNext = function() {
  return this.rPrev().sym;
};


// NOTE(bckenny): libtess.GluHalfEdge.rNext is called nowhere in libtess and
// isn't part of the current public API. It could be useful for mesh traversal
// and manipulation if made public, however.
/* istanbul ignore next */
/**
 * The edge CCW around the right face (origin of this becomes new dest).
 * @return {libtess.GluHalfEdge}
 */
libtess.GluHalfEdge.prototype.rNext = function() {
  return this.oPrev().sym;
};

/* global libtess */

/**
 * Creates a new mesh with no edges, no vertices,
 * and no loops (what we usually call a "face").
 *
 * @constructor
 * @struct
 */
libtess.GluMesh = function() {
  /**
   * dummy header for vertex list
   * @type {libtess.GluVertex}
   */
  this.vHead = new libtess.GluVertex();

  /**
   * dummy header for face list
   * @type {libtess.GluFace}
   */
  this.fHead = new libtess.GluFace();

  /**
   * dummy header for edge list
   * @type {libtess.GluHalfEdge}
   */
  this.eHead = new libtess.GluHalfEdge();

  /**
   * and its symmetric counterpart
   * @type {libtess.GluHalfEdge}
   */
  this.eHeadSym = new libtess.GluHalfEdge();

  // TODO(bckenny): better way to pair these?
  this.eHead.sym = this.eHeadSym;
  this.eHeadSym.sym = this.eHead;
};


// TODO(bckenny): #ifndef NDEBUG
/**
 * Checks mesh for self-consistency.
 */
libtess.GluMesh.prototype.checkMesh = function() {
  if (!libtess.DEBUG) {
    return;
  }

  var fHead = this.fHead;
  var vHead = this.vHead;
  var eHead = this.eHead;

  var e;

  // faces
  var f;
  var fPrev = fHead;
  for (fPrev = fHead; (f = fPrev.next) !== fHead; fPrev = f) {
    e = f.anEdge;
    do {
      e = e.lNext;
    } while (e !== f.anEdge);
  }

  // vertices
  var v;
  var vPrev = vHead;
  for (vPrev = vHead; (v = vPrev.next) !== vHead; vPrev = v) {
    e = v.anEdge;
    do {
      e = e.oNext;
    } while (e !== v.anEdge);
  }

  // edges
  var ePrev = eHead;
  for (ePrev = eHead; (e = ePrev.next) !== eHead; ePrev = e) {
  }
};

/* global libtess */

/**
 * Each vertex has a pointer to next and previous vertices in the
 * circular list, and a pointer to a half-edge with this vertex as
 * the origin (null if this is the dummy header). There is also a
 * field "data" for client data.
 * @param {libtess.GluVertex=} opt_nextVertex Optional reference to next vertex in the vertex list.
 * @param {libtess.GluVertex=} opt_prevVertex Optional reference to previous vertex in the vertex list.
 * @constructor
 * @struct
 */
libtess.GluVertex = function(opt_nextVertex, opt_prevVertex) {
  /**
   * Next vertex (never null).
   * @type {!libtess.GluVertex}
   */
  this.next = opt_nextVertex || this;

  /**
   * Previous vertex (never null).
   * @type {!libtess.GluVertex}
   */
  this.prev = opt_prevVertex || this;

  /**
   * A half-edge with this origin.
   * @type {libtess.GluHalfEdge}
   */
  this.anEdge = null;

  /**
   * The client's data.
   * @type {Object}
   */
  this.data = null;

  /**
   * The vertex location in 3D.
   * @type {!Array.<number>}
   */
  this.coords = [0, 0, 0];
  // TODO(bckenny): we may want to rethink coords, either eliminate (using s
  // and t and user data) or index into contiguous storage?

  /**
   * Component of projection onto the sweep plane.
   * @type {number}
   */
  this.s = 0;

  /**
   * Component of projection onto the sweep plane.
   * @type {number}
   */
  this.t = 0;

  /**
   * Handle to allow deletion from priority queue, or 0 if not yet inserted into
   * queue.
   * @type {libtess.PQHandle}
   */
  this.pqHandle = 0;
};

/* global libtess */

/**
 * A priority queue of vertices, ordered by libtess.geom.vertLeq, implemented
 * with a sorted array. Used for initial insertion of vertices (see
 * libtess.sweep.initPriorityQ_), sorted once, then it uses an internal
 * libtess.PriorityQHeap for any subsequently created vertices from
 * intersections.
 * @constructor
 * @struct
 */
libtess.PriorityQ = function() {
  /**
   * An unordered list of vertices that have been inserted in the queue, with
   * null in empty slots.
   * @private {Array<libtess.GluVertex>}
   */
  this.verts_ = [];

  /**
   * Array of indices into this.verts_, sorted by vertLeq over the addressed
   * vertices.
   * @private {Array<number>}
   */
  this.order_ = null;

  /**
   * The size of this queue, not counting any vertices stored in heap_.
   * @private {number}
   */
  this.size_ = 0;

  /**
   * Indicates that the queue has been initialized via init. If false, inserts
   * are fast insertions at the end of the verts_ array. If true, the verts_
   * array is sorted and subsequent inserts are done in the heap.
   * @private {boolean}
   */
  this.initialized_ = false;

  /**
   * A priority queue heap, used for faster insertions of vertices after verts_
   * has been sorted.
   * @private {libtess.PriorityQHeap}
   */
  this.heap_ = new libtess.PriorityQHeap();
};

/**
 * Release major storage memory used by priority queue.
 */
libtess.PriorityQ.prototype.deleteQ = function() {
  // TODO(bckenny): could instead clear most of these.
  this.heap_ = null;
  this.order_ = null;
  this.verts_ = null;
  // NOTE(bckenny): nulled at callsite (sweep.donePriorityQ_)
};

/**
 * Sort vertices by libtess.geom.vertLeq. Must be called before any method other
 * than insert is called to ensure correctness when removing or querying.
 */
libtess.PriorityQ.prototype.init = function() {
  // TODO(bckenny): reuse. in theory, we don't have to empty this, as access is
  // dictated by this.size_, but array.sort doesn't know that
  this.order_ = [];

  // Create an array of indirect pointers to the verts, so that
  // the handles we have returned are still valid.
  // TODO(bckenny): valid for when? it appears we can just store indexes into
  // verts_, but what did this mean?
  for (var i = 0; i < this.size_; i++) {
    this.order_[i] = i;
  }

  // sort the indirect pointers in descending order of the verts themselves
  // TODO(bckenny): make sure it's ok that verts[a] === verts[b] returns 1
  // TODO(bckenny): unstable sort means we may get slightly different polys in
  // different browsers, but only when passing in equal points
  // TODO(bckenny): make less awkward closure?
  var comparator = (function(verts) {
    return function(a, b) {
      return libtess.geom.vertLeq(verts[a], verts[b]) ? 1 : -1;
    };
  })(this.verts_);
  this.order_.sort(comparator);

  this.initialized_ = true;
  this.heap_.init();

  // NOTE(bckenny): debug assert of ordering of the verts_ array.
  if (libtess.DEBUG) {
    var p = 0;
    var r = p + this.size_ - 1;
    for (i = p; i < r; ++i) {
    }
  }
};

/**
 * Insert a vertex into the priority queue. Returns a PQHandle to refer to it,
 * which will never be 0.
 * @param {libtess.GluVertex} vert
 * @return {libtess.PQHandle}
 */
libtess.PriorityQ.prototype.insert = function(vert) {
  // NOTE(bckenny): originally returned LONG_MAX as alloc failure signal. no
  // longer does.
  if (this.initialized_) {
    return this.heap_.insert(vert);
  }

  var curr = this.size_++;

  this.verts_[curr] = vert;

  // Negative handles index the sorted array.
  return -(curr + 1);
};

/**
 * Removes the minimum vertex from the queue and returns it. If the queue is
 * empty, null will be returned.
 * @return {libtess.GluVertex}
 */
libtess.PriorityQ.prototype.extractMin = function() {
  if (this.size_ === 0) {
    return this.heap_.extractMin();
  }

  var sortMin = this.verts_[this.order_[this.size_ - 1]];
  if (!this.heap_.isEmpty()) {
    var heapMin = this.heap_.minimum();
    if (libtess.geom.vertLeq(heapMin, sortMin)) {
      return this.heap_.extractMin();
    }
  }

  do {
    --this.size_;
  } while (this.size_ > 0 && this.verts_[this.order_[this.size_ - 1]] === null);

  return sortMin;
};

/**
 * Returns the minimum vertex in the queue. If the queue is empty, null will be
 * returned.
 * @return {libtess.GluVertex}
 */
libtess.PriorityQ.prototype.minimum = function() {
  if (this.size_ === 0) {
    return this.heap_.minimum();
  }

  var sortMin = this.verts_[this.order_[this.size_ - 1]];
  if (!this.heap_.isEmpty()) {
    var heapMin = this.heap_.minimum();
    if (libtess.geom.vertLeq(heapMin, sortMin)) {
      return heapMin;
    }
  }

  return sortMin;
};

/**
 * Remove vertex with handle removeHandle from queue.
 * @param {libtess.PQHandle} removeHandle
 */
libtess.PriorityQ.prototype.remove = function(removeHandle) {
  if (removeHandle >= 0) {
    this.heap_.remove(removeHandle);
    return;
  }
  removeHandle = -(removeHandle + 1);

  this.verts_[removeHandle] = null;
  while (this.size_ > 0 && this.verts_[this.order_[this.size_ - 1]] === null) {
    --this.size_;
  }
};

/* global libtess */

/**
 * A priority queue of vertices, ordered by libtess.geom.vertLeq, implemented
 * with a binary heap. Used only within libtess.PriorityQ for prioritizing
 * vertices created by intersections (see libtess.sweep.checkForIntersect_).
 * @constructor
 * @struct
 */
libtess.PriorityQHeap = function() {
  /**
   * The heap itself. Active nodes are stored in the range 1..size, with the
   * minimum at 1. Each node stores only an index into verts_ and handles_.
   * @private {!Array<number>}
   */
  this.heap_ = libtess.PriorityQHeap.reallocNumeric_([0],
      libtess.PriorityQHeap.INIT_SIZE_ + 1);

  /**
   * An unordered list of vertices in the heap, with null in empty slots.
   * @private {!Array<libtess.GluVertex>}
   */
  this.verts_ = [null, null];

  /**
   * An unordered list of indices mapping vertex handles into the heap. An entry
   * at index i will map the vertex at i in verts_ to its place in the heap
   * (i.e. heap_[handles_[i]] === i).
   * Empty slots below size_ are a free list chain starting at freeList_.
   * @private {!Array<number>}
   */
  this.handles_ = [0, 0];

  /**
   * The size of the queue.
   * @private {number}
   */
  this.size_ = 0;

  /**
   * The queue's current allocated space.
   * @private {number}
   */
  this.max_ = libtess.PriorityQHeap.INIT_SIZE_;

  /**
   * The index of the next free hole in the verts_ array. That slot in handles_
   * has the next index in the free list. If there are no holes, freeList_ === 0
   * and a new vertex must be appended to the list.
   * @private {libtess.PQHandle}
   */
  this.freeList_ = 0;

  /**
   * Indicates that the heap has been initialized via init. If false, inserts
   * are fast insertions at the end of a list. If true, all inserts will now be
   * correctly ordered in the queue before returning.
   * @private {boolean}
   */
  this.initialized_ = false;

  // Point the first index at the first (currently null) vertex.
  this.heap_[1] = 1;
};

/**
 * The initial allocated space for the queue.
 * @const
 * @private {number}
 */
libtess.PriorityQHeap.INIT_SIZE_ = 32;

/**
 * Allocate a numeric index array of size size. oldArray's contents are copied
 * to the beginning of the new array. The rest of the array is filled with
 * zeroes.
 * @private
 * @param {!Array<number>} oldArray
 * @param {number} size
 * @return {!Array<number>}
 */
libtess.PriorityQHeap.reallocNumeric_ = function(oldArray, size) {
  var newArray = new Array(size);

  // NOTE(bckenny): V8 likes this significantly more than simply growing the
  // array element-by-element or expanding the existing array all at once, so,
  // for now, emulating realloc.
  for (var index = 0; index < oldArray.length; index++) {
    newArray[index] = oldArray[index];
  }

  for (; index < size; index++) {
    newArray[index] = 0;
  }

  return newArray;
};

/**
 * Initializing ordering of the heap. Must be called before any method other
 * than insert is called to ensure correctness when removing or querying.
 */
libtess.PriorityQHeap.prototype.init = function() {
  // This method of building a heap is O(n), rather than O(n lg n).
  for (var i = this.size_; i >= 1; --i) {
    // TODO(bckenny): since init is called before anything is inserted (see
    // PriorityQ.init), this will always be empty. Better to lazily init?
    this.floatDown_(i);
  }

  this.initialized_ = true;
};

/**
 * Insert a new vertex into the heap.
 * @param {libtess.GluVertex} vert The vertex to insert.
 * @return {libtess.PQHandle} A handle that can be used to remove the vertex.
 */
libtess.PriorityQHeap.prototype.insert = function(vert) {
  var endIndex = ++this.size_;

  // If the heap overflows, double its size.
  if ((endIndex * 2) > this.max_) {
    this.max_ *= 2;

    this.handles_ = libtess.PriorityQHeap.reallocNumeric_(this.handles_,
        this.max_ + 1);
  }

  var newVertSlot;
  if (this.freeList_ === 0) {
    // No free slots, append vertex.
    newVertSlot = endIndex;
  } else {
    // Put vertex in free slot, update freeList_ to next free slot.
    newVertSlot = this.freeList_;
    this.freeList_ = this.handles_[this.freeList_];
  }

  this.verts_[newVertSlot] = vert;
  this.handles_[newVertSlot] = endIndex;
  this.heap_[endIndex] = newVertSlot;

  if (this.initialized_) {
    this.floatUp_(endIndex);
  }
  return newVertSlot;
};

/**
 * @return {boolean} Whether the heap is empty.
 */
libtess.PriorityQHeap.prototype.isEmpty = function() {
  return this.size_ === 0;
};

/**
 * Returns the minimum vertex in the heap. If the heap is empty, null will be
 * returned.
 * @return {libtess.GluVertex}
 */
libtess.PriorityQHeap.prototype.minimum = function() {
  return this.verts_[this.heap_[1]];
};

/**
 * Removes the minimum vertex from the heap and returns it. If the heap is
 * empty, null will be returned.
 * @return {libtess.GluVertex}
 */
libtess.PriorityQHeap.prototype.extractMin = function() {
  var heap = this.heap_;
  var verts = this.verts_;
  var handles = this.handles_;

  var minHandle = heap[1];
  var minVertex = verts[minHandle];

  if (this.size_ > 0) {
    // Replace min with last vertex.
    heap[1] = heap[this.size_];
    handles[heap[1]] = 1;

    // Clear min vertex and put slot at front of freeList_.
    verts[minHandle] = null;
    handles[minHandle] = this.freeList_;
    this.freeList_ = minHandle;

    // Restore heap.
    if (--this.size_ > 0) {
      this.floatDown_(1);
    }
  }

  return minVertex;
};

/**
 * Remove vertex with handle removeHandle from heap.
 * @param {libtess.PQHandle} removeHandle
 */
libtess.PriorityQHeap.prototype.remove = function(removeHandle) {
  var heap = this.heap_;
  var verts = this.verts_;
  var handles = this.handles_;

  var heapIndex = handles[removeHandle];

  // Replace with last vertex.
  heap[heapIndex] = heap[this.size_];
  handles[heap[heapIndex]] = heapIndex;

  // Restore heap.
  if (heapIndex <= --this.size_) {
    if (heapIndex <= 1) {
      this.floatDown_(heapIndex);
    } else {
      var vert = verts[heap[heapIndex]];
      var parentVert = verts[heap[heapIndex >> 1]];
      if (libtess.geom.vertLeq(parentVert, vert)) {
        this.floatDown_(heapIndex);
      } else {
        this.floatUp_(heapIndex);
      }
    }
  }

  // Clear vertex and put slot at front of freeList_.
  verts[removeHandle] = null;
  handles[removeHandle] = this.freeList_;
  this.freeList_ = removeHandle;
};

/**
 * Restore heap by moving the vertex at index in the heap downwards to a valid
 * slot.
 * @private
 * @param {libtess.PQHandle} index
 */
libtess.PriorityQHeap.prototype.floatDown_ = function(index) {
  var heap = this.heap_;
  var verts = this.verts_;
  var handles = this.handles_;

  var currIndex = index;
  var currHandle = heap[currIndex];
  for (;;) {
    // The children of node i are nodes 2i and 2i+1.
    var childIndex = currIndex << 1;
    if (childIndex < this.size_) {
      // Set child to the index of the child with the minimum vertex.
      if (libtess.geom.vertLeq(verts[heap[childIndex + 1]],
          verts[heap[childIndex]])) {
        childIndex = childIndex + 1;
      }
    }

    var childHandle = heap[childIndex];
    if (childIndex > this.size_ ||
        libtess.geom.vertLeq(verts[currHandle], verts[childHandle])) {
      // Heap restored.
      heap[currIndex] = currHandle;
      handles[currHandle] = currIndex;
      return;
    }

    // Swap current node and child; repeat from childIndex.
    heap[currIndex] = childHandle;
    handles[childHandle] = currIndex;
    currIndex = childIndex;
  }
};

/**
 * Restore heap by moving the vertex at index in the heap upwards to a valid
 * slot.
 * @private
 * @param {libtess.PQHandle} index
 */
libtess.PriorityQHeap.prototype.floatUp_ = function(index) {
  var heap = this.heap_;
  var verts = this.verts_;
  var handles = this.handles_;

  var currIndex = index;
  var currHandle = heap[currIndex];
  for (;;) {
    // The parent of node i is node floor(i/2).
    var parentIndex = currIndex >> 1;
    var parentHandle = heap[parentIndex];

    if (parentIndex === 0 ||
        libtess.geom.vertLeq(verts[parentHandle], verts[currHandle])) {
      // Heap restored.
      heap[currIndex] = currHandle;
      handles[currHandle] = currIndex;
      return;
    }

    // Swap current node and parent; repeat from parentIndex.
    heap[currIndex] = parentHandle;
    handles[parentHandle] = currIndex;
    currIndex = parentIndex;
  }
};

/* global libtess */

// TODO(bckenny): apparently only visible outside of sweep for debugging routines.
// find out if we can hide

/**
 * For each pair of adjacent edges crossing the sweep line, there is
 * an ActiveRegion to represent the region between them. The active
 * regions are kept in sorted order in a dynamic dictionary. As the
 * sweep line crosses each vertex, we update the affected regions.
 * @constructor
 * @struct
 */
libtess.ActiveRegion = function() {
  // TODO(bckenny): I *think* eUp and nodeUp could be passed in as constructor params

  /**
   * The upper edge of the region, directed right to left
   * @type {libtess.GluHalfEdge}
   */
  this.eUp = null;

  /**
   * Dictionary node corresponding to eUp edge.
   * @type {libtess.DictNode}
   */
  this.nodeUp = null;

  /**
   * Used to determine which regions are inside the polygon.
   * @type {number}
   */
  this.windingNumber = 0;

  /**
   * Whether this region is inside the polygon.
   * @type {boolean}
   */
  this.inside = false;

  /**
   * Marks fake edges at t = +/-infinity.
   * @type {boolean}
   */
  this.sentinel = false;

  /**
   * Marks regions where the upper or lower edge has changed, but we haven't
   * checked whether they intersect yet.
   * @type {boolean}
   */
  this.dirty = false;

  /**
   * marks temporary edges introduced when we process a "right vertex" (one
   * without any edges leaving to the right)
   * @type {boolean}
   */
  this.fixUpperEdge = false;
};

/**
 * Returns the ActiveRegion below this one.
 * @return {libtess.ActiveRegion}
 */
libtess.ActiveRegion.prototype.regionBelow = function() {
  return this.nodeUp.getPredecessor().getKey();
};

/**
 * Returns the ActiveRegion above this one.
 * @return {libtess.ActiveRegion}
 */
libtess.ActiveRegion.prototype.regionAbove = function() {
  return this.nodeUp.getSuccessor().getKey();
};

/* global libtess, module */

/**
 * node.js export for non-compiled source
 */
if (typeof module !== 'undefined') {
  module.exports = libtess;
}
;
define('libtess', ['libtess/libtess.cat'], function (main) { return main; });

define("libtess/libtess.cat", function(){});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Triangle3',[
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
	"libtess",
],
function (Vector3,
          libtess_)
{
"use strict";

	return {
	   area: (function ()
		{
			var
				B = new Vector3 (0, 0, 0),
				C = new Vector3 (0, 0, 0);

			return function (a, b, c)
		   {
		      return B .assign (b) .subtract (a) .cross (C .assign (c) .subtract (a)) .abs () / 2;
		   };
		})(),
		normal: function (v1, v2, v3, normal)
		{
			var
				x1 = v3 .x - v2 .x,
				y1 = v3 .y - v2 .y,
				z1 = v3 .z - v2 .z,
				x2 = v1 .x - v2 .x,
				y2 = v1 .y - v2 .y,
				z2 = v1 .z - v2 .z;

			normal .set (y1 * z2 - z1 * y2,
			             z1 * x2 - x1 * z2,
			             x1 * y2 - y1 * x2);

			return normal .normalize ();
		},
		quadNormal: function (v1, v2, v3, v4, normal)
		{
			var
				x1 = v3 .x - v1 .x,
				y1 = v3 .y - v1 .y,
				z1 = v3 .z - v1 .z,
				x2 = v4 .x - v2 .x,
				y2 = v4 .y - v2 .y,
				z2 = v4 .z - v2 .z;

			normal .set (y1 * z2 - z1 * y2,
			             z1 * x2 - x1 * z2,
			             x1 * y2 - y1 * x2);

			return normal .normalize ();
		},
		triangulatePolygon: (function ()
		{
			var tessy = (function ()
			{
				// Function called for each vertex of tesselator output.
				function vertexCallback (data, polyVertArray)
				{
					//console .log (data);
					polyVertArray [polyVertArray .length] = data;
				}

				function beginCallback (type)
				{
					if (type !== libtess .primitiveType .GL_TRIANGLES)
						console .log ('expected TRIANGLES but got type: ' + type);
				}

				function errorCallback (errno)
				{
					console .log ('error callback');
					console .log ('error number: ' + errno);
				}

				// Callback for when segments intersect and must be split.
				function combineCallback (coords, data, weight)
				{
					//console.log ('combine callback');
					return data [0];
				}

				function edgeCallback (flag)
				{
					// Don't really care about the flag, but need no-strip/no-fan behavior.
					// console .log ('edge flag: ' + flag);
				}

				var tessy = new libtess .GluTesselator ();

				tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_VERTEX_DATA,  vertexCallback);
				tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_BEGIN,        beginCallback);
				tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_ERROR,        errorCallback);
				tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_COMBINE,      combineCallback);
				tessy .gluTessCallback (libtess .gluEnum .GLU_TESS_EDGE_FLAG,    edgeCallback);
				tessy .gluTessProperty (libtess .gluEnum .GLU_TESS_TOLERANCE,    0);
				tessy .gluTessProperty (libtess .gluEnum .GLU_TESS_WINDING_RULE, libtess .windingRule .GLU_TESS_WINDING_ODD);

				return tessy;
			})();

			return function (/* contour, [ contour, ..., ] triangles */)
			{
				var triangles = arguments [arguments .length - 1];

				tessy .gluTessBeginPolygon (triangles);

				for (var i = 0, length = arguments .length - 1; i < length; ++ i)
				{
					tessy .gluTessBeginContour ();

					var contour = arguments [i];

					for (var j = 0; j < contour .length; ++ j)
					{
						tessy .gluTessVertex (contour [j], contour [j]);
					}

					tessy .gluTessEndContour ();
				}

				tessy .gluTessEndPolygon ();

				return triangles;
			};
		})(),
		triangulateConvexPolygon: function (vertices, triangles)
		{
			// Fallback: Very simple triangulation for convex polygons.
			for (var i = 1, length = vertices .length - 1; i < length; ++ i)
				triangles .push (vertices [0], vertices [i], vertices [i + 1]);
		},
		getPolygonNormal: function (vertices, normal)
		{
			// Determine polygon normal.
			// We use Newell's method https://www.opengl.org/wiki/Calculating_a_Surface_Normal here:

			normal .set (0, 0, 0);

			var next = vertices [0];

			for (var i = 0, length = vertices .length; i < length; ++ i)
			{
				var
					current = next,
					next    = vertices [(i + 1) % length];

				normal .x += (current .y - next .y) * (current .z + next .z);
				normal .y += (current .z - next .z) * (current .x + next .x);
				normal .z += (current .x - next .x) * (current .y + next .y);
			}

			return normal .normalize ();
		},
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithms/SAT',[],function ()
{
"use strict";

	var
		extents1 = { min: 0, max: 0 },
		extents2 = { min: 0, max: 0 };

	/**
	 *  Class to represent the Separating Axis Theorem.
	 */
	function SAT () { }

	SAT .isSeparated = function (axes, points1, points2)
	{
		// http://gamedev.stackexchange.com/questions/25397/obb-vs-obb-collision-detection

		for (var i = 0, length = axes .length; i < length; ++ i)
		{
			var axis = axes [i];

			project (points1, axis, extents1);
			project (points2, axis, extents2);

			if (overlaps (extents1 .min, extents1 .max, extents2 .min, extents2 .max))
				continue;

			return true;
		}

		return false;
	};

	///  Projects @a points to @a axis and returns the minimum and maximum bounds.
	function project (points, axis, extents)
	{
		extents .min = Number .POSITIVE_INFINITY;
		extents .max = Number .NEGATIVE_INFINITY;

		for (var i = 0, length = points .length; i < length; ++ i)
		{
			var point = points [i];

			// Just dot it to get the min and max along this axis.
			// NOTE: the axis must be normalized to get accurate projections to calculate the MTV, but if it is only needed to
			// know whether it overlaps, every axis can be used.

			var dotVal = point .dot (axis);

			if (dotVal < extents .min)
				extents .min = dotVal;

			if (dotVal > extents .max)
				extents .max = dotVal;
		}
	}

	///  Returns true if both ranges overlap, otherwise false.
	function overlaps (min1, max1, min2, max2)
	{
		return is_between (min2, min1, max1) || is_between (min1, min2, max2);
	}

	///  Returns true if @a value is between @a lowerBound and @a upperBound, otherwise false.
	function is_between (value, lowerBound, upperBound)
	{
		return lowerBound <= value && value <= upperBound;
	}

	return SAT;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/ViewVolume',[
	"standard/Math/Geometry/Plane3",
	"standard/Math/Geometry/Triangle3",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Algorithms/SAT",
],
function (Plane3,
          Triangle3,
          Vector3,
          Vector4,
          Matrix4,
          SAT)
{
"use strict";

	/*
	 * p7 -------- p6  far plane
	 * | \         | \
	 * | p3 --------- p2
	 * |  |        |  |
	 * |  |        |  |
	 * p4 |______ p5  |
	 *  \ |         \ |
	 *   \|          \|
	 *    p0 -------- p1  near plane
	 */

	function ViewVolume (projectionMatrix, viewport, scissor)
	{
		this .viewport = new Vector4 (0, 0, 0, 0);
		this .scissor  = new Vector4 (0, 0, 0, 0);
		
		this .points = [
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),

			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
		];

		this .normals = [
			new Vector3 (0, 0, 0), // front
			new Vector3 (0, 0, 0), // left
			new Vector3 (0, 0, 0), // right
			new Vector3 (0, 0, 0), // top
			new Vector3 (0, 0, 0), // bottom
			new Vector3 (0, 0, 0), // back  
		];

		this .edges = [
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),

			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
			new Vector3 (0, 0, 0),
		];

		this .planes = [
			new Plane3 (Vector3 .Zero, Vector3 .Zero), // front
			new Plane3 (Vector3 .Zero, Vector3 .Zero), // left
			new Plane3 (Vector3 .Zero, Vector3 .Zero), // right
			new Plane3 (Vector3 .Zero, Vector3 .Zero), // top
			new Plane3 (Vector3 .Zero, Vector3 .Zero), // bottom
			new Plane3 (Vector3 .Zero, Vector3 .Zero), // back  
		];

		if (arguments .length)
			this .set (projectionMatrix, viewport, scissor);
	}

	ViewVolume .prototype =
	{
		constructor: ViewVolume,
		set: (function ()
		{
			var matrix = new Matrix4 ();

			return function (projectionMatrix, viewport, scissor)
			{
				try
				{
					this .viewport .assign (viewport);
					this .scissor  .assign (scissor);
	
					var points = this .points;

					var
						p0 = points [0],
						p1 = points [1],
						p2 = points [2],
						p3 = points [3],
						p4 = points [4],
						p5 = points [5],
						p6 = points [6],
						p7 = points [7];

					var
						x1 = scissor [0],
						x2 = x1 + scissor [2],
						y1 = scissor [1],
						y2 = y1 + scissor [3];
	
					matrix .assign (projectionMatrix) .inverse ();

					ViewVolume .unProjectPointMatrix (x1, y1, 0, matrix, viewport, p0),
					ViewVolume .unProjectPointMatrix (x2, y1, 0, matrix, viewport, p1),
					ViewVolume .unProjectPointMatrix (x2, y2, 0, matrix, viewport, p2),
					ViewVolume .unProjectPointMatrix (x1, y2, 0, matrix, viewport, p3),
					ViewVolume .unProjectPointMatrix (x1, y1, 1, matrix, viewport, p4),
					ViewVolume .unProjectPointMatrix (x2, y1, 1, matrix, viewport, p5);
					ViewVolume .unProjectPointMatrix (x2, y2, 1, matrix, viewport, p6);
					ViewVolume .unProjectPointMatrix (x1, y2, 1, matrix, viewport, p7);

					var normals = this .normals;

					Triangle3 .normal (p0, p1, p2, normals [0]); // front
					Triangle3 .normal (p7, p4, p0, normals [1]); // left
					Triangle3 .normal (p6, p2, p1, normals [2]); // right
					Triangle3 .normal (p2, p6, p7, normals [3]); // top
					Triangle3 .normal (p1, p0, p4, normals [4]); // bottom
					Triangle3 .normal (p4, p7, p6, normals [5]); // back  

					var planes = this .planes;

					planes [0] .set (p1, normals [0]); // front
					planes [1] .set (p4, normals [1]); // left
					planes [2] .set (p2, normals [2]); // right
					planes [3] .set (p6, normals [3]); // top
					planes [4] .set (p0, normals [4]); // bottom
					planes [5] .set (p7, normals [5]); // back  

					this .edges .tainted = true;
					this .valid          = true;
				}
				catch (error)
				{
					this .valid = false;
					//console .log (error);
				}
	
				return this;
			};
		})(),
		getViewport: function ()
		{
			return this .viewport;
		},
		getScissor: function ()
		{
			return this .scissor;
		},
		getEdges: function ()
		{
			// Return suitable edges for SAT theorem.

			var edges = this .edges;

			if (edges .tainted)
			{
				var points = this .points;

				edges [0] .assign (points [0]) .subtract (points [1]);
				edges [1] .assign (points [1]) .subtract (points [2]);
				edges [2] .assign (points [2]) .subtract (points [3]);
				edges [3] .assign (points [3]) .subtract (points [0]);

				edges [4] .assign (points [0]) .subtract (points [4]);
				edges [5] .assign (points [1]) .subtract (points [5]);
				edges [6] .assign (points [2]) .subtract (points [6]);
				edges [7] .assign (points [3]) .subtract (points [7]);

				// Edges 8 - 11 are equal to edges 0 - 3.

				edges .tainted = false;
			}

			return edges;
		},
		intersectsSphere: function (radius, center)
		{
			if (this .valid)
			{
				var planes = this .planes;
			
				if (planes [0] .getDistanceToPoint (center) > radius)
					return false;
	
				if (planes [1] .getDistanceToPoint (center) > radius)
					return false;
	
				if (planes [2] .getDistanceToPoint (center) > radius)
					return false;
	
				if (planes [3] .getDistanceToPoint (center) > radius)
					return false;
	
				if (planes [4] .getDistanceToPoint (center) > radius)
					return false;
	
				if (planes [5] .getDistanceToPoint (center) > radius)
					return false;
			}

			return true;
		},
		intersectsBox: (function ()
		{
			var points1 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
		
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var normals1 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var axes1 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var axes = [ ];

			for (var i = 0; i < 3 * 8; ++ i)
				axes .push (new Vector3 (0, 0, 0));

			return function (box)
			{
				// Get points.
			
				box .getPoints (points1);

				var points2 = this .points;
			
				// Test the three planes spanned by the normal vectors of the faces of the box.
			
				if (SAT .isSeparated (box .getNormals (normals1), points1, points2))
					return false;
			
				// Test the six planes spanned by the normal vectors of the faces of the view volume.
			
				if (SAT .isSeparated (this .normals, points1, points2))
					return false;
	
				// Test the planes spanned by the edges of each object.
			
				box .getAxes (axes1);

				var edges = this .getEdges ();

				for (var i1 = 0; i1 < 3; ++ i1)
				{
					for (var i2 = 0; i2 < 8; ++ i2)
						axes [i1 * 3 + i2] .assign (axes1 [i1]) .cross (edges [i2]);
				}

				if (SAT .isSeparated (axes, points1, points2))
					return false;
			
				// Both boxes intersect.
			
				return true;
			};
		})(),
	};

	Object .assign (ViewVolume,
	{
		unProjectPoint: (function ()
		{
			var matrix = new Matrix4 ();

			return function (winx, winy, winz, modelViewMatrix, projectionMatrix, viewport, point)
			{
				matrix .assign (modelViewMatrix) .multRight (projectionMatrix) .inverse ();
	
				return this .unProjectPointMatrix (winx, winy, winz, matrix, viewport, point);
			};
		})(),
		unProjectPointMatrix: (function ()
		{
			var vin = new Vector4 (0, 0, 0, 0);

			return function (winx, winy, winz, invModelViewProjection, viewport, point)
			{
				// Transformation of normalized coordinates between -1 and 1
				vin .set ((winx - viewport [0]) / viewport [2] * 2 - 1,
				          (winy - viewport [1]) / viewport [3] * 2 - 1,
				          2 * winz - 1,
				          1);
	
				//Objects coordinates
				invModelViewProjection .multVecMatrix (vin);
	
				if (vin .w === 0)
					throw new Error ("Couldn't unproject point: divisor is 0.");
	
				var d = 1 / vin .w;
	
				return point .set (vin .x * d, vin .y * d, vin .z * d);
			};
		})(),
		unProjectRay: (function ()
		{
			var
				near   = new Vector3 (0, 0, 0),
				far    = new Vector3 (0, 0, 0),
				matrix = new Matrix4 ();

			return function (winx, winy, modelViewMatrix, projectionMatrix, viewport, result)
			{
				matrix .assign (modelViewMatrix) .multRight (projectionMatrix) .inverse ();
	
				ViewVolume .unProjectPointMatrix (winx, winy, 0.0, matrix, viewport, near);
				ViewVolume .unProjectPointMatrix (winx, winy, 0.9, matrix, viewport, far);
	
				return result .setPoints (near, far);
			};
		})(),
		projectPoint: (function ()
		{
			var vin = new Vector4 (0, 0, 0, 0);

			return function (point, modelViewMatrix, projectionMatrix, viewport, vout)
			{
				vin .set (point .x, point .y, point .z, 1);
	
				projectionMatrix .multVecMatrix (modelViewMatrix .multVecMatrix (vin));
	
				if (vin .w === 0)
					throw new Error ("Couldn't project point: divisor is 0.");
	
				var d = 1 / (2 * vin .w);
	
				return vout .set ((vin .x * d + 0.5) * viewport [2] + viewport [0],
				                  (vin .y * d + 0.5) * viewport [3] + viewport [1],
				                  (vin .z * d + 0.5));
			};
		})(),
		projectLine: (function ()
		{
			var
				near = new Vector3 (0, 0, 0),
				far  = new Vector3 (0, 0, 0);

			return function (line, modelViewMatrix, projectionMatrix, viewport, result)
			{
				ViewVolume .projectPoint (line .point, modelViewMatrix, projectionMatrix, viewport, near);
				ViewVolume .projectPoint (Vector3 .multiply (line .direction, 1e9) .add (line .point), modelViewMatrix, projectionMatrix, viewport, far);
	
				near .z = 0;
				far  .z = 0;
	
				return result .setPoints (near, far);
			};
		})(),
	});

	return ViewVolume;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Rendering/TextureBuffer',[
	"standard/Math/Geometry/ViewVolume",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
],
function (ViewVolume,
          Vector3,
          Matrix4)
{
"use strict";

	function TextureBuffer (browser, width, height)
	{
		var gl = browser .getContext ();

		this .browser = browser;
		this .width   = width;
		this .height  = height;
		this .array   = new Uint8Array (width * height * 4);

		// The frame buffer.

		this .lastBuffer = gl .getParameter (gl .FRAMEBUFFER_BINDING);
		this .buffer     = gl .createFramebuffer ();

		gl .bindFramebuffer (gl .FRAMEBUFFER, this .buffer);

		// The depth texture

		this .colorTexture = gl .createTexture ();

		gl .bindTexture (gl .TEXTURE_2D, this .colorTexture);
		gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_S,     gl .CLAMP_TO_EDGE);
		gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_T,     gl .CLAMP_TO_EDGE);
		gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MIN_FILTER, gl .LINEAR);
		gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MAG_FILTER, gl .LINEAR);
		gl .texImage2D (gl .TEXTURE_2D, 0, gl .RGBA, width, height, 0, gl .RGBA, gl .UNSIGNED_BYTE, null);

		gl .framebufferTexture2D (gl .FRAMEBUFFER, gl .COLOR_ATTACHMENT0, gl .TEXTURE_2D, this .colorTexture, 0);

		// The depth buffer

		if (gl .getVersion () >= 2 || browser .getExtension ("WEBGL_depth_texture"))
		{
			this .depthTexture = gl .createTexture ();

			gl .bindTexture (gl .TEXTURE_2D, this .depthTexture);

			gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_S,     gl .CLAMP_TO_EDGE);
			gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_WRAP_T,     gl .CLAMP_TO_EDGE);
			gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MAG_FILTER, gl .NEAREST);
			gl .texParameteri (gl .TEXTURE_2D, gl .TEXTURE_MIN_FILTER, gl .NEAREST);

			var internalFormat = gl .getVersion () >= 2 ? gl .DEPTH_COMPONENT24 : gl .DEPTH_COMPONENT;

			gl .texImage2D (gl .TEXTURE_2D, 0, internalFormat, width, height, 0, gl .DEPTH_COMPONENT, gl .UNSIGNED_INT, null);
			gl.framebufferTexture2D (gl .FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this .depthTexture, 0);
		}
		else
		{
			this .depthBuffer = gl .createRenderbuffer ();

			gl .bindRenderbuffer (gl .RENDERBUFFER, this .depthBuffer);
			gl .renderbufferStorage (gl .RENDERBUFFER, gl .DEPTH_COMPONENT16, width, height);
			gl .framebufferRenderbuffer (gl .FRAMEBUFFER, gl .DEPTH_ATTACHMENT, gl .RENDERBUFFER, this .depthBuffer);
		}

		// Always check that our framebuffer is ok

		var complete = gl .checkFramebufferStatus (gl .FRAMEBUFFER) === gl .FRAMEBUFFER_COMPLETE;

		gl .bindFramebuffer (gl .FRAMEBUFFER, this .lastBuffer);

		if (complete)
			return;

		throw new Error ("Couldn't create frame buffer.");
	}

	TextureBuffer .prototype =
	{
		constructor: TextureBuffer,
		getWidth: function ()
		{
			return this .width;
		},
		getHeight: function ()
		{
			return this .height;
		},
		getColorTexture: function ()
		{
			return this .colorTexture;
		},
		getDepthTexture: function ()
		{
			return this .depthTexture;
		},
		readPixels: function ()
		{
			var
				gl     = this .browser .getContext (),
				array  = this .array,
				width  = this .width,
				height = this .height;

			gl .readPixels (0, 0, width, height, gl .RGBA, gl .UNSIGNED_BYTE, array);

			return array;
		},
		getDepth: (function ()
		{
			var
				invProjectionMatrix = new Matrix4 (),
				point               = new Vector3 (0, 0, 0);

			return function (projectionMatrix, viewport)
			{
				try
				{
					var
						gl     = this .browser .getContext (),
						array  = this .array,
						width  = this .width,
						height = this .height,
						winx   = 0,
						winy   = 0,
						winz   = Number .POSITIVE_INFINITY;

					invProjectionMatrix .assign (projectionMatrix) .inverse ();

					gl .readPixels (0, 0, width, height, gl .RGBA, gl .UNSIGNED_BYTE, array);
	
					for (var wy = 0, i = 0; wy < height; ++ wy)
					{
						for (var wx = 0; wx < width; ++ wx, i += 4)
						{
							var wz = array [i] / 255 + array [i + 1] / (255 * 255) + array [i + 2] / (255 * 255 * 255) + array [i + 3] / (255 * 255 * 255 * 255);
	
							if (wz < winz)
							{
								winx = wx;
								winy = wy;
								winz = wz;
							}
						}
					}

					ViewVolume .unProjectPointMatrix (winx, winy, winz, invProjectionMatrix, viewport, point);
	
					return point .z;
				}
				catch (error)
				{
					return 0;
				}
			};
		})(),
		bind: function ()
		{
			var gl = this .browser .getContext ();

			this .lastBuffer = gl .getParameter (gl .FRAMEBUFFER_BINDING);

			gl .bindFramebuffer (gl .FRAMEBUFFER, this .buffer);
		},
		unbind: function ()
		{
			var gl = this .browser .getContext ();
			gl .bindFramebuffer (gl .FRAMEBUFFER, this .lastBuffer);
		},
	};

	return TextureBuffer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Shaders/ShaderTest',[
	"x_ite/Rendering/TextureBuffer",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Matrix3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Camera",
],
function (TextureBuffer,
          Vector4,
          Matrix3,
          Matrix4,
          Camera)
{
"use strict";

	var ShaderTest =
	{
		verify: (function ()
		{
			var normals = [
				0, 0, 1,
				0, 0, 1,
				0, 0, 1,
				0, 0, 1,
				0, 0, 1,
				0, 0, 1,
			];

			var vertices = [
				 2,  2, 0, 1,
				-2,  2, 0, 1,
				-2, -2, 0, 1,
				 2,  2, 0, 1,
				-2, -2, 0, 1,
				 2, -2, 0, 1,
			];

			return function (browser, shaderNode)
			{
				var
					gl           = browser .getContext (),
					frameBuffer  = new TextureBuffer (browser, 16, 16),
		         normalBuffer = gl .createBuffer (),
		         vertexBuffer = gl .createBuffer ();

				frameBuffer .bind ();

				shaderNode .enable (gl);
				shaderNode .setLocalObjects (gl, [ ]);

				gl .bindBuffer (gl .ARRAY_BUFFER, vertexBuffer);
				gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (vertices), gl .STATIC_DRAW);
				gl .bindBuffer (gl .ARRAY_BUFFER, normalBuffer);
				gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (normals), gl .STATIC_DRAW);

				// Matrices

				gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, new Float32Array (Camera .ortho (-1, 1, -1, 1, -1, 1, new Matrix4 ())));
				gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,  false, new Float32Array (new Matrix4 ()));
				gl .uniformMatrix3fv (shaderNode .x3d_NormalMatrix,     false, new Float32Array (new Matrix3 ()));

				// Set clip planes and lights to none.

				gl .uniform1i (shaderNode .x3d_FogType,               0);
				gl .uniform1i (shaderNode .x3d_FillPropertiesFilled,  true);
				gl .uniform1i (shaderNode .x3d_FillPropertiesHatched, false);
				gl .uniform1i (shaderNode .x3d_ColorMaterial,         false);
				gl .uniform1i (shaderNode .x3d_Lighting,              true);
				gl .uniform1i (shaderNode .x3d_NumLights,             0);
				gl .uniform1i (shaderNode .x3d_NumTextures,           0);
				gl .uniform1i (shaderNode .x3d_NumProjectiveTextures, 0);
				gl .uniform1i (shaderNode .x3d_NumClipPlanes,         0);

				gl .uniform1i (shaderNode .x3d_SeparateBackColor, false);
				gl .uniform1f (shaderNode .x3d_AmbientIntensity,  0);
				gl .uniform3f (shaderNode .x3d_DiffuseColor,      1, 0, 0);
				gl .uniform3f (shaderNode .x3d_SpecularColor,     1, 0, 0);
				gl .uniform3f (shaderNode .x3d_EmissiveColor,     1, 0, 0);
				gl .uniform1f (shaderNode .x3d_Shininess,         0);
				gl .uniform1f (shaderNode .x3d_Transparency,      0);

				gl .viewport (0, 0, 16, 16);
				gl .clearColor (0, 0, 0, 0);
				gl .clear (gl .COLOR_BUFFER_BIT);

				gl .disable (gl .DEPTH_TEST);
				gl .disable (gl .BLEND);
				gl .frontFace (gl .CCW);
				gl .enable (gl .CULL_FACE);
				gl .cullFace (gl .BACK);

				shaderNode .enableNormalAttribute (gl, normalBuffer);
				shaderNode .enableVertexAttribute (gl, vertexBuffer);

				gl .drawArrays (gl .TRIANGLES, 0, 6);

				shaderNode .disableNormalAttribute (gl, normalBuffer);
				shaderNode .disable                (gl);

				var data = frameBuffer .readPixels ();

				frameBuffer .unbind ();

				return data [0] == 255 && data [1] == 0 && data [2] == 0 && data [3] == 255;
			};
		})(),
	};

	return ShaderTest;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Shaders/X3DShadersContext',[
	"x_ite/Browser/Core/Shading",
	"x_ite/Components/Shaders/ComposedShader",
	"x_ite/Components/Shaders/ShaderPart",
	"x_ite/Browser/Shaders/ShaderTest",
	"x_ite/Browser/Networking/urls",
],
function (Shading,
          ComposedShader,
          ShaderPart,
          ShaderTest,
          urls)
{
"use strict";

	function X3DShadersContext ()
	{
		this .shaders = new Set ();
	}

	X3DShadersContext .prototype =
	{
		initialize: function ()
		{
			this .setShading (Shading .GOURAUD);
		},
		getShadingLanguageVersion: function ()
		{
			return this .getContext () .getParameter (this .getContext () .SHADING_LANGUAGE_VERSION);
		},
		getMaxVertexUniformVectors: function ()
		{
			return this .getContext () .getParameter (this .getContext () .MAX_VERTEX_UNIFORM_VECTORS);
		},
		getMaxFragmentUniformVectors: function ()
		{
			return this .getContext () .getParameter (this .getContext () .MAX_FRAGMENT_UNIFORM_VECTORS);
		},
		getMaxVertexAttribs: function ()
		{
			return this .getContext () .getParameter (this .getContext () .MAX_VERTEX_ATTRIBS);
		},
		addShader: function (shader)
		{
			this .shaders .add (shader);

			shader .setShading (this .getBrowserOptions () .getShading ());
		},
		removeShader: function (shader)
		{
			this .shaders .delete (shader);
		},
		getShaders: function ()
		{
			return this .shaders;
		},
		getDefaultShader: function ()
		{ },
		getDefaultShadowShader: function ()
		{
			return this .getDefaultShader () .getShadowShader ();
		},
		hasPointShader: function ()
		{
			return !! this .pointShader;
		},
		getPointShader: function ()
		{
			if (this .pointShader)
				return this .pointShader;

			this .pointShader = this .createShader ("PointShader", "PointSet", false);

			this .pointShader .getShadowShader = this .getPointShader .bind (this);

			return this .pointShader;
		},
		hasLineShader: function ()
		{
			return !! this .lineShader;
		},
		getLineShader: function ()
		{
			if (this .lineShader)
				return this .lineShader;

			this .lineShader = this .createShader ("WireframeShader", "Wireframe", false);

			this .lineShader .getShadowShader = this .getLineShader .bind (this);

			return this .lineShader;
		},
		hasGouraudShader: function ()
		{
			return !! this .gouraudShader;
		},
		getGouraudShader: function ()
		{
			if (this .gouraudShader)
				return this .gouraudShader;

			this .gouraudShader = this .createShader ("GouraudShader", "Gouraud", false);

			this .gouraudShader .getShadowShader = this .getShadowShader .bind (this);

			this .gouraudShader .isValid_ .addInterest ("set_gouraud_shader_valid__", this);

			return this .gouraudShader;
		},
		hasPhongShader: function ()
		{
			return !! this .phongShader;
		},
		getPhongShader: function ()
		{
			if (this .phongShader)
				return this .phongShader;

			this .phongShader = this .createShader ("PhongShader", "Phong", false);

			this .phongShader .getShadowShader = this .getShadowShader .bind (this);

			this .phongShader .isValid_ .addInterest ("set_phong_shader_valid__", this);

			return this .phongShader;
		},
		hasShadowShader: function ()
		{
			return !! this .shadowShader;
		},
		getShadowShader: function ()
		{
			if (this .shadowShader)
				return this .shadowShader;

			this .shadowShader = this .createShader ("ShadowShader", "Phong", true);

			this .shadowShader .isValid_ .addInterest ("set_shadow_shader_valid__", this);

			return this .shadowShader;
		},
		hasDepthShader: function ()
		{
			return !! this .depthShader;
		},
		getDepthShader: function ()
		{
			if (this .depthShader)
				return this .depthShader;

			this .depthShader = this .createShader ("DepthShader", "Depth", false);

			return this .depthShader;
		},
		setShading: function (type)
		{
			switch (type)
			{
				case Shading .PHONG:
				{
					this .getDefaultShader = this .getPhongShader;
					break;
				}
				default:
				{
					this .getDefaultShader = this .getGouraudShader;
					break;
				}
			}

			// Configure shaders.

			for (var shader of this .getShaders ())
				shader .setShading (type);
		},
		createShader: function (name, file, shadow)
		{
			if (this .getDebug ())
				console .log ("Initializing " + name);

			var version = this .getContext () .getVersion ();

			var vertexShader = new ShaderPart (this .getPrivateScene ());
			vertexShader .setName (name + "Vertex");
			vertexShader .url_ .push (urls .getShaderUrl ("webgl" + version + "/" + file + ".vs"));
			vertexShader .setShadow (shadow);
			vertexShader .setup ();

			var fragmentShader = new ShaderPart (this .getPrivateScene ());
			fragmentShader .setName (name + "Fragment");
			fragmentShader .type_  = "FRAGMENT";
			fragmentShader .url_ .push (urls .getShaderUrl ("webgl" + version + "/" + file + ".fs"));
			fragmentShader .setShadow (shadow);
			fragmentShader .setup ();

			var shader = new ComposedShader (this .getPrivateScene ());
			shader .setName (name);
			shader .language_ = "GLSL";
			shader .parts_ .push (vertexShader);
			shader .parts_ .push (fragmentShader);
			shader .setCustom (false);
			shader .setShading (this .getBrowserOptions () .getShading ());
			shader .setup ();

			this .addShader (shader);

			return shader;
		},
		set_gouraud_shader_valid__: function (valid)
		{
			this .gouraudShader .isValid_ .removeInterest ("set_gouraud_shader_valid__", this);

			if (valid .getValue () && ShaderTest .verify (this, this .gouraudShader))
				return;

			console .warn ("X_ITE: All else fails, using fallback VRML shader.");

			// Recompile shader.
			this .gouraudShader .parts_ [0] .url = [ urls .getShaderUrl ("webgl1/Fallback.vs") ];
			this .gouraudShader .parts_ [1] .url = [ urls .getShaderUrl ("webgl1/Fallback.fs") ];
		},
		set_phong_shader_valid__: function (valid)
		{
			this .phongShader .isValid_ .removeInterest ("set_phong_shader_valid__", this);

			if (valid .getValue () && ShaderTest .verify (this, this .phongShader))
				return;

			console .warn ("X_ITE: Phong shading is not available, using Gouraud shading.");

			this .phongShader = this .getGouraudShader ();
		},
		set_shadow_shader_valid__: function (valid)
		{
			this .shadowShader .isValid_ .removeInterest ("set_shadow_shader_valid__", this);

			if (valid .getValue () && ShaderTest .verify (this, this .shadowShader))
				return;

			console .warn ("X_ITE: Shadow shading is not available, using Gouraud shading.");

			this .shadowShader = this .getGouraudShader ();
		},
	};

	return X3DShadersContext;
});



/**
 * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
 * directory of this distribution and at
 * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
 */
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define('ResizeSensor/src/ResizeSensor',factory);
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        root.ResizeSensor = factory();
    }
}(typeof window !== 'undefined' ? window : this, function () {

    // Make sure it does not throw in a SSR (Server Side Rendering) situation
    if (typeof window === "undefined") {
        return null;
    }
    // https://github.com/Semantic-Org/Semantic-UI/issues/3855
    // https://github.com/marcj/css-element-queries/issues/257
    var globalWindow = typeof window != 'undefined' && window.Math == Math
        ? window
        : typeof self != 'undefined' && self.Math == Math
            ? self
            : Function('return this')();
    // Only used for the dirty checking, so the event callback count is limited to max 1 call per fps per sensor.
    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and
    // would generate too many unnecessary events.
    var requestAnimationFrame = globalWindow.requestAnimationFrame ||
        globalWindow.mozRequestAnimationFrame ||
        globalWindow.webkitRequestAnimationFrame ||
        function (fn) {
            return globalWindow.setTimeout(fn, 20);
        };

    var cancelAnimationFrame = globalWindow.cancelAnimationFrame ||
        globalWindow.mozCancelAnimationFrame ||
        globalWindow.webkitCancelAnimationFrame ||
        function (timer) {
            globalWindow.clearTimeout(timer);
        };

    /**
     * Iterate over each of the provided element(s).
     *
     * @param {HTMLElement|HTMLElement[]} elements
     * @param {Function}                  callback
     */
    function forEachElement(elements, callback){
        var elementsType = Object.prototype.toString.call(elements);
        var isCollectionTyped = ('[object Array]' === elementsType
            || ('[object NodeList]' === elementsType)
            || ('[object HTMLCollection]' === elementsType)
            || ('[object Object]' === elementsType)
            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery
            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools
        );
        var i = 0, j = elements.length;
        if (isCollectionTyped) {
            for (; i < j; i++) {
                callback(elements[i]);
            }
        } else {
            callback(elements);
        }
    }

    /**
    * Get element size
    * @param {HTMLElement} element
    * @returns {Object} {width, height}
    */
    function getElementSize(element) {
        if (!element.getBoundingClientRect) {
            return {
                width: element.offsetWidth,
                height: element.offsetHeight
            }
        }

        var rect = element.getBoundingClientRect();
        return {
            width: Math.round(rect.width),
            height: Math.round(rect.height)
        }
    }

    /**
     * Apply CSS styles to element.
     *
     * @param {HTMLElement} element
     * @param {Object} style
     */
    function setStyle(element, style) {
        Object.keys(style).forEach(function(key) {
            element.style[key] = style[key];
        });
    }

    /**
     * Class for dimension change detection.
     *
     * @param {Element|Element[]|Elements|jQuery} element
     * @param {Function} callback
     *
     * @constructor
     */
    var ResizeSensor = function(element, callback) {
        //Is used when checking in reset() only for invisible elements
        var lastAnimationFrameForInvisibleCheck = 0;

        /**
         *
         * @constructor
         */
        function EventQueue() {
            var q = [];
            this.add = function(ev) {
                q.push(ev);
            };

            var i, j;
            this.call = function(sizeInfo) {
                for (i = 0, j = q.length; i < j; i++) {
                    q[i].call(this, sizeInfo);
                }
            };

            this.remove = function(ev) {
                var newQueue = [];
                for(i = 0, j = q.length; i < j; i++) {
                    if(q[i] !== ev) newQueue.push(q[i]);
                }
                q = newQueue;
            };

            this.length = function() {
                return q.length;
            }
        }

        /**
         *
         * @param {HTMLElement} element
         * @param {Function}    resized
         */
        function attachResizeEvent(element, resized) {
            if (!element) return;
            if (element.resizedAttached) {
                element.resizedAttached.add(resized);
                return;
            }

            element.resizedAttached = new EventQueue();
            element.resizedAttached.add(resized);

            element.resizeSensor = document.createElement('div');
            element.resizeSensor.dir = 'ltr';
            element.resizeSensor.className = 'resize-sensor';

            var style = {
                pointerEvents: 'none',
                position: 'absolute',
                left: '0px',
                top: '0px',
                right: '0px',
                bottom: '0px',
                overflow: 'hidden',
                zIndex: '-1',
                visibility: 'hidden',
                maxWidth: '100%'
            };
            var styleChild = {
                position: 'absolute',
                left: '0px',
                top: '0px',
                transition: '0s',
            };

            setStyle(element.resizeSensor, style);

            var expand = document.createElement('div');
            expand.className = 'resize-sensor-expand';
            setStyle(expand, style);

            var expandChild = document.createElement('div');
            setStyle(expandChild, styleChild);
            expand.appendChild(expandChild);

            var shrink = document.createElement('div');
            shrink.className = 'resize-sensor-shrink';
            setStyle(shrink, style);

            var shrinkChild = document.createElement('div');
            setStyle(shrinkChild, styleChild);
            setStyle(shrinkChild, { width: '200%', height: '200%' });
            shrink.appendChild(shrinkChild);

            element.resizeSensor.appendChild(expand);
            element.resizeSensor.appendChild(shrink);
            element.appendChild(element.resizeSensor);

            var computedStyle = window.getComputedStyle(element);
            var position = computedStyle ? computedStyle.getPropertyValue('position') : null;
            if ('absolute' !== position && 'relative' !== position && 'fixed' !== position && 'sticky' !== position) {
                element.style.position = 'relative';
            }

            var dirty = false;

            //last request animation frame id used in onscroll event
            var rafId = 0;
            var size = getElementSize(element);
            var lastWidth = 0;
            var lastHeight = 0;
            var initialHiddenCheck = true;
            lastAnimationFrameForInvisibleCheck = 0;

            var resetExpandShrink = function () {
                var width = element.offsetWidth;
                var height = element.offsetHeight;

                expandChild.style.width = (width + 10) + 'px';
                expandChild.style.height = (height + 10) + 'px';

                expand.scrollLeft = width + 10;
                expand.scrollTop = height + 10;

                shrink.scrollLeft = width + 10;
                shrink.scrollTop = height + 10;
            };

            var reset = function() {
                // Check if element is hidden
                if (initialHiddenCheck) {
                    var invisible = element.offsetWidth === 0 && element.offsetHeight === 0;
                    if (invisible) {
                        // Check in next frame
                        if (!lastAnimationFrameForInvisibleCheck){
                            lastAnimationFrameForInvisibleCheck = requestAnimationFrame(function(){
                                lastAnimationFrameForInvisibleCheck = 0;
                                reset();
                            });
                        }

                        return;
                    } else {
                        // Stop checking
                        initialHiddenCheck = false;
                    }
                }

                resetExpandShrink();
            };
            element.resizeSensor.resetSensor = reset;

            var onResized = function() {
                rafId = 0;

                if (!dirty) return;

                lastWidth = size.width;
                lastHeight = size.height;

                if (element.resizedAttached) {
                    element.resizedAttached.call(size);
                }
            };

            var onScroll = function() {
                size = getElementSize(element);
                dirty = size.width !== lastWidth || size.height !== lastHeight;

                if (dirty && !rafId) {
                    rafId = requestAnimationFrame(onResized);
                }

                reset();
            };

            var addEvent = function(el, name, cb) {
                if (el.attachEvent) {
                    el.attachEvent('on' + name, cb);
                } else {
                    el.addEventListener(name, cb);
                }
            };

            addEvent(expand, 'scroll', onScroll);
            addEvent(shrink, 'scroll', onScroll);

            // Fix for custom Elements and invisible elements
            lastAnimationFrameForInvisibleCheck = requestAnimationFrame(function(){
                lastAnimationFrameForInvisibleCheck = 0;
                reset();
            });
        }

        forEachElement(element, function(elem){
            attachResizeEvent(elem, callback);
        });

        this.detach = function(ev) {
            // clean up the unfinished animation frame to prevent a potential endless requestAnimationFrame of reset
            if (!lastAnimationFrameForInvisibleCheck) {
                cancelAnimationFrame(lastAnimationFrameForInvisibleCheck);
                lastAnimationFrameForInvisibleCheck = 0;
            }
            ResizeSensor.detach(element, ev);
        };

        this.reset = function() {
            element.resizeSensor.resetSensor();
        };
    };

    ResizeSensor.reset = function(element) {
        forEachElement(element, function(elem){
            elem.resizeSensor.resetSensor();
        });
    };

    ResizeSensor.detach = function(element, ev) {
        forEachElement(element, function(elem){
            if (!elem) return;
            if(elem.resizedAttached && typeof ev === "function"){
                elem.resizedAttached.remove(ev);
                if(elem.resizedAttached.length()) return;
            }
            if (elem.resizeSensor) {
                if (elem.contains(elem.resizeSensor)) {
                    elem.removeChild(elem.resizeSensor);
                }
                delete elem.resizeSensor;
                delete elem.resizedAttached;
            }
        });
    };

    if (typeof MutationObserver !== "undefined") {
        var observer = new MutationObserver(function (mutations) {
            for (var i in mutations) {
                if (mutations.hasOwnProperty(i)) {
                    var items = mutations[i].addedNodes;
                    for (var j = 0; j < items.length; j++) {
                        if (items[j].resizeSensor) {
                            ResizeSensor.reset(items[j]);
                        }
                    }
                }
            }
        });

        document.addEventListener("DOMContentLoaded", function (event) {
            observer.observe(document.body, {
                childList: true,
                subtree: true,
            });
        });
    }

    return ResizeSensor;

}));

define('ResizeSensor', ['ResizeSensor/src/ResizeSensor'], function (main) { return main; });

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


//https://github.com/sdecima/javascript-detect-element-resize

define ('x_ite/Browser/Rendering/X3DRenderingContext',[
	"jquery",
	"x_ite/Fields",
	"ResizeSensor",
],
function ($,
          Fields,
          ResizeSensor)
{
"use strict";

	function X3DRenderingContext ()
	{
		this .addChildObjects ("viewport", new Fields .MFInt32 (0, 0, 300, 150));

		this .localObjects = [ ]; // shader objects dumpster
	}

	X3DRenderingContext .prototype =
	{
		initialize: function ()
		{
			// Configure context.

			var gl = this .getContext ();

			gl .enable (gl .SCISSOR_TEST);
			gl .cullFace (gl .BACK);
			gl .enable (gl .DEPTH_TEST);
			gl .depthFunc (gl .LEQUAL);
			gl .clearDepth (1);

			gl .blendFuncSeparate (gl .SRC_ALPHA, gl .ONE_MINUS_SRC_ALPHA, gl .ONE, gl .ONE_MINUS_SRC_ALPHA);
			gl .blendEquationSeparate (gl .FUNC_ADD, gl .FUNC_ADD);
			gl .enable (gl .BLEND);

			// Configure viewport.

			$(document) .on ('webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange', this .onfullscreen .bind (this));

			this .resizer = new ResizeSensor (this .getSurface (), this .reshape .bind (this));

			this .reshape ();
		},
		getRenderer: function ()
		{
			var dbgRenderInfo = this .getExtension ("WEBGL_debug_renderer_info");

			if (dbgRenderInfo)
				return this .getContext () .getParameter (dbgRenderInfo .UNMASKED_RENDERER_WEBGL);

			return this .getContext () .getParameter (this .getContext () .RENDERER);
		},
		getVendor: function ()
		{
			var dbgRenderInfo = this .getExtension ("WEBGL_debug_renderer_info");

			if (dbgRenderInfo)
				return this .getContext () .getParameter (dbgRenderInfo .UNMASKED_VENDOR_WEBGL);

			return this .getContext () .getParameter (this .getContext () .VENDOR);
		},
		getWebGLVersion: function ()
		{
			return this .getContext () .getParameter (this .getContext () .VERSION);
		},
		getAntialiased: function ()
		{
			return this .getContext () .getParameter (this .getContext () .SAMPLES) > 0;
		},
		getMaxClipPlanes: function ()
		{
			return 6;
		},
		getDepthSize: function ()
		{
			var gl = this .context;

			return gl .getParameter (gl .DEPTH_BITS);
		},
		getColorDepth: function ()
		{
			var gl = this .context;

			var colorDepth = 0;
			colorDepth += gl .getParameter (gl .RED_BITS);
			colorDepth += gl .getParameter (gl .BLUE_BITS);
			colorDepth += gl .getParameter (gl .GREEN_BITS);
			colorDepth += gl .getParameter (gl .ALPHA_BITS);

			return colorDepth;
		},
		getViewport: function ()
		{
			return this .viewport_;
		},
		getLocalObjects: function ()
		{
			return this .localObjects;
		},
		reshape: function ()
		{
			var
				gl     = this .getContext (),
				canvas = this .getCanvas (),
				width  = canvas .width (),
				height = canvas .height ();

			canvas = canvas [0];

			canvas .width  = width;
			canvas .height = height;

			this .viewport_ [2] = width;
			this .viewport_ [3] = height;

			gl .viewport (0, 0, width, height);
			gl .scissor  (0, 0, width, height);

			this .addBrowserEvent ();
		},
		onfullscreen: function ()
		{
			if (this .getElement () .fullScreen ())
				this .getElement () .addClass  ("x_ite-fullscreen");
			else
				this .getElement () .removeClass ("x_ite-fullscreen");
		},
	};

	return X3DRenderingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/X3DAppearanceNode',[
	"x_ite/Fields",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DNode, 
          X3DConstants)
{
"use strict";

	function X3DAppearanceNode (executionContext)
	{
		X3DNode .call (this, executionContext);

		this .addType (X3DConstants .X3DAppearanceNode);
		
		this .addChildObjects ("transparent", new Fields .SFBool ());

		this .transparent_ .setAccessType (X3DConstants .outputOnly);
	}

	X3DAppearanceNode .prototype = Object .assign (Object .create (X3DNode .prototype),
	{
		constructor: X3DAppearanceNode,
		initialize: function ()
		{
			X3DNode .prototype .initialize .call (this);
		},
		setTransparent: function (value)
		{
			if (value !== this .transparent_ .getValue ())
				this .transparent_ = value;
		},
		getTransparent: function ()
		{
			return this .transparent_ .getValue ();
		},
	});

	return X3DAppearanceNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/Appearance',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shape/X3DAppearanceNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DAppearanceNode,
          X3DCast,
          X3DConstants)
{
"use strict";

	function Appearance (executionContext)
	{
		X3DAppearanceNode .call (this, executionContext);

		this .addType (X3DConstants .Appearance);

		this .pointPropertiesNode  = null;
		this .linePropertiesNode   = null;
		this .fillPropertiesNode   = null;
		this .materialNode         = null;
		this .textureNode          = null;
		this .textureTransformNode = null;
		this .shaderNodes          = [ ];
		this .shaderNode           = null;
		this .blendModeNode        = null;
	}

	Appearance .prototype = Object .assign (Object .create (X3DAppearanceNode .prototype),
	{
		constructor: Appearance,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "pointProperties",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "lineProperties",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "fillProperties",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "material",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "texture",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "textureTransform", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "shaders",          new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "blendMode",        new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "Appearance";
		},
		getComponentName: function ()
		{
			return "Shape";
		},
		getContainerField: function ()
		{
			return "appearance";
		},
		initialize: function ()
		{
			X3DAppearanceNode .prototype .initialize .call (this);

			this .isLive () .addInterest ("set_live__", this);

			this .pointProperties_  .addInterest ("set_pointProperties__",  this);
			this .lineProperties_   .addInterest ("set_lineProperties__",   this);
			this .fillProperties_   .addInterest ("set_fillProperties__",   this);
			this .material_         .addInterest ("set_material__",         this);
			this .texture_          .addInterest ("set_texture__",          this);
			this .textureTransform_ .addInterest ("set_textureTransform__", this);
			this .shaders_          .addInterest ("set_shaders__",          this);
			this .blendMode_        .addInterest ("set_blendMode__",        this);

			this .set_live__ ();
			this .set_pointProperties__ ();
			this .set_lineProperties__ ();
			this .set_fillProperties__ ();
			this .set_material__ ();
			this .set_texture__ ();
			this .set_textureTransform__ ();
			this .set_shaders__ ();
			this .set_blendMode__ ();
		},
		set_live__: function ()
		{
			if (this .isLive () .getValue ())
			{
				this .getBrowser () .getBrowserOptions () .Shading_ .addInterest ("set_shading__", this);

				if (this .shaderNode)
					this .getBrowser () .addShader (this .shaderNode);
			}
			else
			{
				this .getBrowser () .getBrowserOptions () .Shading_ .removeInterest ("set_shading__", this);

				if (this .shaderNode)
					this .getBrowser () .removeShader (this .shaderNode);
			}
		},
		set_pointProperties__: function ()
		{
			this .pointPropertiesNode = X3DCast (X3DConstants .PointProperties, this .pointProperties_);

			if (! this .pointPropertiesNode)
				this .pointPropertiesNode = this .getBrowser () .getDefaultPointProperties ();
		},
		set_lineProperties__: function ()
		{
			this .linePropertiesNode = X3DCast (X3DConstants .LineProperties, this .lineProperties_);

			if (! this .linePropertiesNode)
				this .linePropertiesNode = this .getBrowser () .getDefaultLineProperties ();
		},
		set_fillProperties__: function ()
		{
			if (this .fillPropertiesNode)
				this .fillPropertiesNode .transparent_ .removeInterest ("set_transparent__", this);

			this .fillPropertiesNode = X3DCast (X3DConstants .FillProperties, this .fillProperties_);

			if (! this .fillPropertiesNode)
				this .fillPropertiesNode = this .getBrowser () .getDefaultFillProperties ();

			if (this .fillPropertiesNode)
				this .fillPropertiesNode .transparent_ .addInterest ("set_transparent__", this);

			this .set_transparent__ ();
		},
		set_material__: function ()
		{
			if (this .materialNode)
				this .materialNode .transparent_ .removeInterest ("set_transparent__", this);

			this .materialNode = X3DCast (X3DConstants .X3DMaterialNode, this .material_);

			if (this .materialNode)
				this .materialNode .transparent_ .addInterest ("set_transparent__", this);

			this .set_transparent__ ();
		},
		set_texture__: function ()
		{
			if (this .textureNode)
				this .textureNode .transparent_ .removeInterest ("set_transparent__", this);

			this .textureNode = X3DCast (X3DConstants .X3DTextureNode, this .texture_);

			if (this .textureNode)
				this .textureNode .transparent_ .addInterest ("set_transparent__", this);

			this .set_transparent__ ();
		},
		set_textureTransform__: function ()
		{
			this .textureTransformNode = X3DCast (X3DConstants .X3DTextureTransformNode, this .textureTransform_);

			if (this .textureTransformNode)
				return;

			this .textureTransformNode = this .getBrowser () .getDefaultTextureTransform ();
		},
		set_shaders__: function ()
		{
			var
				shaders     = this .shaders_ .getValue (),
				shaderNodes = this .shaderNodes;

			for (var i = 0, length = shaderNodes .length; i < length; ++ i)
			{
				var shaderNode = shaderNodes [i];

				shaderNode .isValid_        .removeInterest ("set_shader__", this);
				shaderNode .activationTime_ .removeInterest ("set_shader__", this);
			}

			shaderNodes .length = 0;

			for (var i = 0, length = shaders .length; i < length; ++ i)
			{
				var shaderNode = X3DCast (X3DConstants .X3DShaderNode, shaders [i]);

				if (shaderNode)
				{
					shaderNodes .push (shaderNode);
					shaderNode .isValid_        .addInterest ("set_shader__", this);
					shaderNode .activationTime_ .addInterest ("set_shader__", this);
				}
			}

			this .set_shader__ ();
		},
		set_shader__: function ()
		{
			var shaderNodes = this .shaderNodes;

			if (this .shaderNode)
			{
				this .getBrowser () .removeShader (this .shaderNode);
				this .shaderNode .deselect ();
			}

			this .shaderNode = null;

			for (var i = 0, length = shaderNodes .length; i < length; ++ i)
			{
				var shaderNode = shaderNodes [i];

				if (shaderNode .isValid_ .getValue ())
				{
					if (shaderNode .activationTime_ .getValue () === this .getBrowser () .getCurrentTime ())
					{
						this .shaderNode = shaderNode;
						break;
					}
				}
			}

			if (!this .shaderNode)
			{
				for (var i = 0, length = shaderNodes .length; i < length; ++ i)
				{
					var shaderNode = shaderNodes [i];

					if (shaderNode .isValid_ .getValue ())
					{
						this .shaderNode = shaderNode;
						break;
					}
				}
			}

			if (this .isLive () .getValue ())
			{
				if (this .shaderNode)
				{
					this .getBrowser () .addShader (this .shaderNode);
					this .shaderNode .select ();
				}
			}

			this .set_transparent__ ();
		},
		set_shading__: function ()
		{
			this .set_shader__ ();
		},
		set_blendMode__: function ()
		{
			this .blendModeNode = X3DCast (X3DConstants .BlendMode, this .blendMode_);

			this .set_transparent__ ();
		},
		set_transparent__: function ()
		{
			this .setTransparent (this .fillPropertiesNode .getTransparent () ||
			                      (this .materialNode && this .materialNode .getTransparent ()) ||
			                      (this .textureNode  && this .textureNode  .getTransparent () ||
			                      this .blendModeNode));
		},
		traverse: function (type, renderObject)
		{
			if (this .textureNode)
				this .textureNode .traverse (type, renderObject);

			if (this .shaderNode)
				this .shaderNode .traverse (type, renderObject);
		},
		enable: function (gl, context, geometryType)
		{
			var browser = context .browser;

			switch (geometryType)
			{
				case 0:
					context .stylePropertiesNode = this .pointPropertiesNode;
					break;
				case 1:
					context .stylePropertiesNode = this .linePropertiesNode;
					break;
				default:
					context .stylePropertiesNode = this .fillPropertiesNode;
					break;
			}

			context .materialNode         = this .materialNode;
			context .textureNode          = this .textureNode;
			context .textureTransformNode = this .textureTransformNode;

			if (this .shaderNode)
				context .shaderNode = this .shaderNode;
			else if (context .shadow)
				context .shaderNode = browser .getDefaultShadowShader ();
			else
				context .shaderNode = browser .getDefaultShader ();

			if (this .blendModeNode)
				this .blendModeNode .enable (gl);
		},
		disable: function (gl, context)
		{
			if (this .blendModeNode)
				this .blendModeNode .disable (gl);
		},
	});

	return Appearance;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/PointProperties',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shape/X3DAppearanceChildNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DAppearanceChildNode,
          X3DConstants)
{
"use strict";

	function PointProperties (executionContext)
	{
		X3DAppearanceChildNode .call (this, executionContext);

		this .addType (X3DConstants .PointProperties);

		this .pointSizeAttenuation = new Float32Array (3);
	}

	PointProperties .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
	{
		constructor: PointProperties,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",             new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "pointSizeScaleFactor", new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "pointSizeMinValue",    new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "pointSizeMaxValue",    new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "pointSizeAttenuation", new Fields .MFFloat (1, 0, 0)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "colorMode",            new Fields .SFString ("TEXTURE_AND_POINT_COLOR")),
		]),
		getTypeName: function ()
		{
			return "PointProperties";
		},
		getComponentName: function ()
		{
			return "Shape";
		},
		getContainerField: function ()
		{
			return "pointProperties";
		},
		initialize: function ()
		{
			X3DAppearanceChildNode .prototype .initialize .call (this);

			this .pointSizeScaleFactor_ .addInterest ("set_pointSizeScaleFactor__", this);
			this .pointSizeMinValue_    .addInterest ("set_pointSizeMinValue__",    this);
			this .pointSizeMaxValue_    .addInterest ("set_pointSizeMaxValue__",    this);
			this .pointSizeAttenuation_ .addInterest ("set_pointSizeAttenuation__", this);
			this .colorMode_            .addInterest ("set_colorMode__",            this);

			this .set_pointSizeScaleFactor__ ();
			this .set_pointSizeMinValue__ ();
			this .set_pointSizeMaxValue__ ();
			this .set_pointSizeAttenuation__ ();
			this .set_colorMode__ ();
		},
		set_pointSizeScaleFactor__: function ()
		{
			this .pointSizeScaleFactor = Math .max (1, this .pointSizeScaleFactor_ .getValue ());
		},
		set_pointSizeMinValue__: function ()
		{
			this .pointSizeMinValue = Math .max (0, this .pointSizeMinValue_ .getValue ());
		},
		set_pointSizeMaxValue__: function ()
		{
			this .pointSizeMaxValue = Math .max (0, this .pointSizeMaxValue_ .getValue ());
		},
		set_pointSizeAttenuation__: function ()
		{
			var length = this .pointSizeAttenuation_ .length;

			this .pointSizeAttenuation [0] = length > 0 ? Math .max (0, this .pointSizeAttenuation_ [0]) : 1;
			this .pointSizeAttenuation [1] = length > 1 ? Math .max (0, this .pointSizeAttenuation_ [1]) : 0;
			this .pointSizeAttenuation [2] = length > 2 ? Math .max (0, this .pointSizeAttenuation_ [2]) : 0;
		},
		set_colorMode__: (function ()
		{
			var colorModes = new Map ([
				["POINT_COLOR",             0],
				["TEXTURE_COLOR",           1],
				["TEXTURE_AND_POINT_COLOR", 2],
			]);

			return function ()
			{
				var colorMode = colorModes .get (this .colorMode_ .getValue ());

				if (colorMode !== undefined)
					this .colorMode = colorMode;
				else
					this .colorMode = colorModes .get ("TEXTURE_AND_POINT_COLOR");
			};
		})(),
		setShaderUniforms: function (gl, shaderObject)
		{
			gl .uniform1f  (shaderObject .x3d_PointPropertiesPointSizeScaleFactor, this .pointSizeScaleFactor);
			gl .uniform1f  (shaderObject .x3d_PointPropertiesPointSizeMinValue,    this .pointSizeMinValue);
			gl .uniform1f  (shaderObject .x3d_PointPropertiesPointSizeMaxValue,    this .pointSizeMaxValue);
			gl .uniform3fv (shaderObject .x3d_PointPropertiesPointSizeAttenuation, this .pointSizeAttenuation);
			gl .uniform1i  (shaderObject .x3d_PointPropertiesColorMode,            this .colorMode);
		},
	});

	return PointProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/LineProperties',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shape/X3DAppearanceChildNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DAppearanceChildNode,
          X3DConstants)
{
"use strict";

	function LineProperties (executionContext)
	{
		X3DAppearanceChildNode .call (this, executionContext);

		this .addType (X3DConstants .LineProperties);
	}

	LineProperties .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
	{
		constructor: LineProperties,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",             new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "applied",              new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "linetype",             new Fields .SFInt32 (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "linewidthScaleFactor", new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "LineProperties";
		},
		getComponentName: function ()
		{
			return "Shape";
		},
		getContainerField: function ()
		{
			return "lineProperties";
		},
		initialize: function ()
		{
			X3DAppearanceChildNode .prototype .initialize .call (this);

			this .applied_              .addInterest ("set_applied__",              this);
			this .linewidthScaleFactor_ .addInterest ("set_linewidthScaleFactor__", this);

			this .set_applied__ ();
			this .set_linewidthScaleFactor__ ();
		},
		set_applied__: function ()
		{
			this .applied = this .applied_ .getValue ();
		},
		set_linewidthScaleFactor__: function ()
		{
			this .linewidthScaleFactor = Math .max (1, this .linewidthScaleFactor_ .getValue ());
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			if (this .applied)
			{
				var
					browser = shaderObject .getBrowser (),
					texture = browser .getLinetype (this .linetype_ .getValue ());

				gl .lineWidth (this .linewidthScaleFactor);
				gl .uniform1i (shaderObject .x3d_LinePropertiesApplied,              true);
				gl .uniform1f (shaderObject .x3d_LinePropertiesLinewidthScaleFactor, this .linewidthScaleFactor);

				gl .activeTexture (gl .TEXTURE0 + browser .getLinetypeUnit ());
				gl .bindTexture (gl .TEXTURE_2D, texture .getTexture ());
			}
			else
			{
				gl .lineWidth (1);
				gl .uniform1i (shaderObject .x3d_LinePropertiesApplied,              false);
				gl .uniform1f (shaderObject .x3d_LinePropertiesLinewidthScaleFactor, 1);
			}
		},
	});

	return LineProperties;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/FillProperties',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shape/X3DAppearanceChildNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DAppearanceChildNode, 
          X3DConstants)
{
"use strict";

	function FillProperties (executionContext)
	{
		X3DAppearanceChildNode .call (this, executionContext);

		this .addType (X3DConstants .FillProperties);

		this .addChildObjects ("transparent", new Fields .SFBool ());

		this .transparent_ .setAccessType (X3DConstants .outputOnly);

		this .hatchColor = new Float32Array (3);
	}

	FillProperties .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
	{
		constructor: FillProperties,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "filled",     new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "hatched",    new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "hatchColor", new Fields .SFColor (1, 1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "hatchStyle", new Fields .SFInt32 (1)),
		]),
		getTypeName: function ()
		{
			return "FillProperties";
		},
		getComponentName: function ()
		{
			return "Shape";
		},
		getContainerField: function ()
		{
			return "fillProperties";
		},
		initialize: function ()
		{
			X3DAppearanceChildNode .prototype .initialize .call (this);

			this .filled_     .addInterest ("set_filled__",     this);
			this .hatched_    .addInterest ("set_hatched__",    this);
			this .hatchColor_ .addInterest ("set_hatchColor__", this);

			this .set_filled__ ();
			this .set_hatched__ ();
			this .set_hatchColor__ ();
		},
		set_filled__: function ()
		{
			this .filled = this .filled_ .getValue ();

			this .setTransparent (! this .filled);
		},
		set_hatched__: function ()
		{
			this .hatched = this .hatched_ .getValue ();
		},
		set_hatchColor__: function ()
		{
			this .hatchColor [0] = this .hatchColor_ [0];
			this .hatchColor [1] = this .hatchColor_ [1];
			this .hatchColor [2] = this .hatchColor_ [2];
		},
		setTransparent: function (value)
		{
			if (value !== this .transparent_ .getValue ())
				this .transparent_ = value;
		},
		getTransparent: function ()
		{
			return this .transparent_ .getValue ();
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			var hatched = this .hatched;

			gl .uniform1i (shaderObject .x3d_FillPropertiesFilled,  this .filled);
			gl .uniform1i (shaderObject .x3d_FillPropertiesHatched, hatched);

			if (hatched)
			{
				var
					browser = shaderObject .getBrowser (),
					texture = browser .getHatchStyle (this .hatchStyle_ .getValue ());

				gl .uniform3fv (shaderObject .x3d_FillPropertiesHatchColor, this .hatchColor);
				gl .activeTexture (gl .TEXTURE0 + browser .getHatchStyleUnit ());
				gl .bindTexture (gl .TEXTURE_2D, texture .getTexture ());
			}
		},
	});

	return FillProperties;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/X3DTextureNode',[
	"x_ite/Fields",
	"x_ite/Components/Shape/X3DAppearanceChildNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Texturing/MultiTextureModeType",
	"x_ite/Browser/Texturing/MultiTextureSourceType",
	"x_ite/Browser/Texturing/MultiTextureFunctionType",
],
function (Fields,
          X3DAppearanceChildNode,
          X3DConstants,
          ModeType,
          SourceType,
          FunctionType)
{
"use strict";

	// Anisotropic Filtering in WebGL is handled by an extension, use one of getExtension depending on browser:

	var ANISOTROPIC_EXT = [
		"EXT_texture_filter_anisotropic",
		"MOZ_EXT_texture_filter_anisotropic",
		"WEBKIT_EXT_texture_filter_anisotropic",
	];

	function X3DTextureNode (executionContext)
	{
		X3DAppearanceChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DTextureNode);

		this .addChildObjects ("transparent", new Fields .SFBool ());

		this .transparent_ .setAccessType (X3DConstants .outputOnly);
	}

	X3DTextureNode .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
	{
		constructor: X3DTextureNode,
		initialize: function ()
		{
			X3DAppearanceChildNode .prototype .initialize .call (this);

			var gl = this .getBrowser () .getContext ();

			this .texture = gl .createTexture ();
		},
		setTransparent: function (value)
		{
			if (value !== this .transparent_ .getValue ())
				this .transparent_ = value;
		},
		getTransparent: function ()
		{
			return this .transparent_ .getValue ();
		},
		getTexture: function ()
		{
			return this .texture;
		},
		updateTextureProperties: function (target, haveTextureProperties, textureProperties, width, height, repeatS, repeatT, repeatR)
		{
			var gl = this .getBrowser () .getContext ();

			gl .bindTexture (target, this .getTexture ());

			if (Math .max (width, height) < this .getBrowser () .getMinTextureSize () && ! haveTextureProperties)
			{
				// Dont generate mipmaps.
				gl .texParameteri (target, gl .TEXTURE_MIN_FILTER, gl .NEAREST);
				gl .texParameteri (target, gl .TEXTURE_MAG_FILTER, gl .NEAREST);
			}
			else
			{
				if (textureProperties .generateMipMaps_ .getValue ())
					gl .generateMipmap (target);

				gl .texParameteri (target, gl .TEXTURE_MIN_FILTER, gl [textureProperties .getMinificationFilter ()]);
				gl .texParameteri (target, gl .TEXTURE_MAG_FILTER, gl [textureProperties .getMagnificationFilter ()]);
			}

			if (haveTextureProperties)
			{
				gl .texParameteri (target, gl .TEXTURE_WRAP_S, gl [textureProperties .getBoundaryModeS ()]);
				gl .texParameteri (target, gl .TEXTURE_WRAP_T, gl [textureProperties .getBoundaryModeT ()]);

				if (gl .getVersion () >= 2)
					gl .texParameteri (target, gl .TEXTURE_WRAP_R, gl [textureProperties .getBoundaryModeR ()]);
			}
			else
			{
				gl .texParameteri (target, gl .TEXTURE_WRAP_S, repeatS ? gl .REPEAT : gl .CLAMP_TO_EDGE);
				gl .texParameteri (target, gl .TEXTURE_WRAP_T, repeatT ? gl .REPEAT : gl .CLAMP_TO_EDGE);

				if (gl .getVersion () >= 2)
					gl .texParameteri (target, gl .TEXTURE_WRAP_R, repeatR ? gl .REPEAT : gl .CLAMP_TO_EDGE);
			}

			//gl .texParameterfv (target, gl .TEXTURE_BORDER_COLOR, textureProperties .borderColor_ .getValue ());
			//gl .texParameterf  (target, gl .TEXTURE_PRIORITY,     textureProperties .texturePriority_ .getValue ());

			for (var i = 0; i < ANISOTROPIC_EXT .length; ++ i)
			{
				var ext = gl .getExtension (ANISOTROPIC_EXT [i]);

				if (ext)
				{
					gl .texParameterf (target, ext .TEXTURE_MAX_ANISOTROPY_EXT, textureProperties .anisotropicDegree_ .getValue ());
					break;
				}
			}
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			this .setShaderUniformsToChannel (gl, shaderObject, 0);

			gl .uniform1i (shaderObject .x3d_NumTextures, 1);
			gl .uniform1i (shaderObject .x3d_MultiTextureMode [0],      ModeType .MODULATE);
			gl .uniform1i (shaderObject .x3d_MultiTextureAlphaMode [0], ModeType .MODULATE);
			gl .uniform1i (shaderObject .x3d_MultiTextureSource [0],    SourceType .DEFAULT);
			gl .uniform1i (shaderObject .x3d_MultiTextureFunction [0],  FunctionType .DEFAULT);
		},
	});

	return X3DTextureNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/X3DTexture2DNode',[
	"x_ite/Fields",
	"x_ite/Components/Texturing/X3DTextureNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Bits/X3DCast",
],
function (Fields,
          X3DTextureNode,
          X3DConstants,
          X3DCast)
{
"use strict";

   var defaultData = new Uint8Array ([ 255, 255, 255, 255 ]);

	function X3DTexture2DNode (executionContext)
	{
		X3DTextureNode .call (this, executionContext);

		this .addType (X3DConstants .X3DTexture2DNode);

		this .width  = 0;
		this .height = 0;
		this .flipY  = false;
		this .data   = null;
	}

	X3DTexture2DNode .prototype = Object .assign (Object .create (X3DTextureNode .prototype),
	{
		constructor: X3DTexture2DNode,
		initialize: function ()
		{
			X3DTextureNode .prototype .initialize .call (this);

			var gl = this .getBrowser () .getContext ();

			this .target = gl .TEXTURE_2D;

			this .repeatS_           .addInterest ("updateTextureProperties", this);
			this .repeatT_           .addInterest ("updateTextureProperties", this);
			this .textureProperties_ .addInterest ("set_textureProperties__", this);

			gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
			gl .texImage2D  (gl .TEXTURE_2D, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);

			this .set_textureProperties__ ();
		},
		set_textureProperties__: function ()
		{
			if (this .texturePropertiesNode)
				this .texturePropertiesNode .removeInterest ("updateTextureProperties", this);

			this .texturePropertiesNode = X3DCast (X3DConstants .TextureProperties, this .textureProperties_);

			if (! this .texturePropertiesNode)
				this .texturePropertiesNode = this .getBrowser () .getDefaultTextureProperties ();

			this .texturePropertiesNode .addInterest ("updateTextureProperties", this);

			this .updateTextureProperties ();
		},
		getTarget: function ()
		{
			return this .target;
		},
		getWidth: function ()
		{
			return this .width;
		},
		getHeight: function ()
		{
			return this .height;
		},
		getFlipY: function ()
		{
			return this .flipY;
		},
		getData: function ()
		{
			return this .data;
		},
		clearTexture: function ()
		{
			this .setTexture (1, 1, false, defaultData, false);
		},
		setTexture: function (width, height, transparent, data, flipY)
		{
			try
			{
				this .width  = width;
				this .height = height;
				this .flipY  = flipY;
				this .data   = data;

				var gl = this .getBrowser () .getContext ();

				gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, flipY);
				gl .pixelStorei (gl .UNPACK_ALIGNMENT, 1);
				gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
				gl .texImage2D  (gl .TEXTURE_2D, 0, gl .RGBA, width, height, 0, gl .RGBA, gl .UNSIGNED_BYTE, data);

				this .setTransparent (transparent);
				this .updateTextureProperties ();
				this .addNodeEvent ();
			}
			catch (error)
			{ }
		},
		updateTexture: function (data, flipY)
		{
			try
			{
				this .data = data;

				var gl = this .getBrowser () .getContext ();

				gl .pixelStorei (gl .UNPACK_FLIP_Y_WEBGL, flipY);
				gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
				gl .texSubImage2D (gl .TEXTURE_2D, 0, 0, 0, gl .RGBA, gl .UNSIGNED_BYTE, data);

				if (this .texturePropertiesNode .generateMipMaps_ .getValue ())
					gl .generateMipmap (gl .TEXTURE_2D);

				this .addNodeEvent ();
			}
			catch (error)
			{ }
		},
		updateTextureProperties: function ()
		{
			var gl = this .getBrowser () .getContext ();

			X3DTextureNode .prototype .updateTextureProperties .call (this,
			                                                          gl .TEXTURE_2D,
			                                                          this .textureProperties_ .getValue (),
			                                                          this .texturePropertiesNode,
			                                                          this .width,
			                                                          this .height,
			                                                          this .repeatS_ .getValue (),
			                                                          this .repeatT_ .getValue (),
			                                                          false);
		},
		setShaderUniformsToChannel: function (gl, shaderObject, i)
		{
			gl .activeTexture (gl .TEXTURE0 + shaderObject .getBrowser () .getTexture2DUnits () [i]);
			gl .bindTexture (gl .TEXTURE_2D, this .getTexture ());
			gl .uniform1i (shaderObject .x3d_TextureType [i], 2);
		},
	});

	return X3DTexture2DNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/ImageTexture',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Texturing/X3DTexture2DNode",
	"x_ite/Components/Networking/X3DUrlObject",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Networking/urls",
	"standard/Networking/URI",
	"standard/Math/Algorithm",
	"x_ite/DEBUG",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTexture2DNode,
          X3DUrlObject,
          X3DConstants,
          urls,
          URI,
          Algorithm,
          DEBUG)
{
"use strict";

	function ImageTexture (executionContext)
	{
		X3DTexture2DNode .call (this, executionContext);
		X3DUrlObject     .call (this, executionContext);

		this .addType (X3DConstants .ImageTexture);

		this .addChildObjects ("buffer", new Fields .MFString ());

		this .urlStack = new Fields .MFString ();
	}

	ImageTexture .prototype = Object .assign (Object .create (X3DTexture2DNode .prototype),
		X3DUrlObject .prototype,
	{
		constructor: ImageTexture,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "url",               new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatS",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatT",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "textureProperties", new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "ImageTexture";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "texture";
		},
		initialize: function ()
		{
			X3DTexture2DNode .prototype .initialize .call (this);
			X3DUrlObject     .prototype .initialize .call (this);

			this .url_    .addInterest ("set_url__",   this);
			this .buffer_ .addInterest ("set_buffer__", this);

			this .canvas = $("<canvas></canvas>");

			this .image = $("<img></img>");
			this .image .on ("load", this .setImage .bind (this));
			this .image .on ("error", this .setError .bind (this));
			this .image .bind ("abort", this .setError .bind (this));

			this .image [0] .crossOrigin = "Anonymous";

			this .set_url__ ();
		},
		set_url__: function ()
		{
			this .setLoadState (X3DConstants .NOT_STARTED_STATE);

			this .requestAsyncLoad ();
		},
		requestAsyncLoad: function ()
		{
			if (this .checkLoadState () === X3DConstants .COMPLETE_STATE || this .checkLoadState () === X3DConstants .IN_PROGRESS_STATE)
				return;

			this .setLoadState (X3DConstants .IN_PROGRESS_STATE);

			this .buffer_ = this .url_;
		},
		set_buffer__: function ()
		{
			this .urlStack .setValue (this .buffer_);
			this .loadNext ();
		},
		loadNext: function ()
		{
			if (this .urlStack .length === 0)
			{
				this .clearTexture ();
				this .setLoadState (X3DConstants .FAILED_STATE);
				return;
			}

			// Get URL.

			this .URL = new URI (this .urlStack .shift ());
			this .URL = this .getExecutionContext () .getURL () .transform (this .URL);
			// In Firefox we don't need getRelativePath if file scheme, do we in Chrome???

			this .image .attr ("src", this .URL .toString ());
		},
		setError: function ()
		{
			var URL = this .URL .toString ();

			if (DEBUG)
			{
				if (! (this .URL .isLocal () || this .URL .host === "localhost"))
				{
					if (! URL .match (urls .getFallbackExpression ()))
						this .urlStack .unshift (urls .getFallbackUrl (URL));
				}
			}

			if (this .URL .scheme !== "data")
				console .warn ("Error loading image:", this .URL .toString ());

			this .loadNext ();
		},
		setImage: function ()
		{
			if (DEBUG)
			{
				 if (this .URL .scheme !== "data")
			   	console .info ("Done loading image:", this .URL .toString ());
			}

			try
			{
				var
					gl     = this .getBrowser () .getContext (),
				   image  = this .image [0],
					width  = image .width,
					height = image .height;

				var
					canvas = this .canvas [0],
					cx     = canvas .getContext ("2d");

				// Scale image if needed and flip vertically.

				if (gl .getVersion () >= 2 || (Algorithm .isPowerOfTwo (width) && Algorithm .isPowerOfTwo (height)))
				{
					// Flip Y

					canvas .width  = width;
					canvas .height = height;

					cx .clearRect (0, 0, width, height);
					cx .save ();
					cx .translate (0, height);
					cx .scale (1, -1);
					cx .drawImage (image, 0, 0);
					cx .restore ();
				}
				else
				{
					// Flip Y and scale image to next power of two.

					width  = Algorithm .nextPowerOfTwo (width);
					height = Algorithm .nextPowerOfTwo (height);

					canvas .width  = width;
					canvas .height = height;

					cx .clearRect (0, 0, width, height);
					cx .save ();
					cx .translate (0, height);
					cx .scale (1, -1);
					cx .drawImage (image, 0, 0, image .width, image .height, 0, 0, width, height);
					cx .restore ();
				}

				// Determine image alpha.

				var
					data        = cx .getImageData (0, 0, width, height) .data,
					transparent = false;

				for (var i = 3; i < data .length; i += 4)
				{
					if (data [i] !== 255)
					{
						transparent = true;
						break;
					}
				}

				this .setTexture (width, height, transparent, new Uint8Array (data), false);
				this .setLoadState (X3DConstants .COMPLETE_STATE);
			}
			catch (error)
			{
				// Catch security error from cross origin requests.
				console .log (error .message);
				this .setError ();
			}
		},
	});

	return ImageTexture;
});

// https://github.com/toji/texture-tester/blob/master/js/webgl-texture-util.js
;
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/TextureProperties',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode, 
          X3DConstants, 
          Algorithm)
{
"use strict";

	function TextureProperties (executionContext)
	{
		X3DNode .call (this, executionContext);

		this .addType (X3DConstants .TextureProperties);
	}

	TextureProperties .prototype = Object .assign (Object .create (X3DNode .prototype),
	{
		constructor: TextureProperties,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",            new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "borderColor",         new Fields .SFColorRGBA ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "borderWidth",         new Fields .SFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "anisotropicDegree",   new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "generateMipMaps",     new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "minificationFilter",  new Fields .SFString ("FASTEST")),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "magnificationFilter", new Fields .SFString ("FASTEST")),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "boundaryModeS",       new Fields .SFString ("REPEAT")),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "boundaryModeT",       new Fields .SFString ("REPEAT")),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "boundaryModeR",       new Fields .SFString ("REPEAT")),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "textureCompression",  new Fields .SFString ("FASTEST")),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "texturePriority",     new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "TextureProperties";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "textureProperties";
		},
		getBorderWidth: function ()
		{
			// https://stackoverflow.com/questions/27760277/webgl-border-color-shader?lq=1
			return Algorithm .clamp (this .borderWidth_ .getValue (), 0, 1);
		},
		getBoundaryMode: (function ()
		{
			var boundaryModes = new Map ([
				["CLAMP",             "CLAMP_TO_EDGE"], // "CLAMP"
				["CLAMP_TO_EDGE",     "CLAMP_TO_EDGE"], 
				["CLAMP_TO_BOUNDARY", "CLAMP_TO_EDGE"], // "CLAMP_TO_BORDER"
				["MIRRORED_REPEAT",   "MIRRORED_REPEAT"],
				["REPEAT",            "REPEAT"],
			]);

			return function (string)
			{
				var boundaryMode = boundaryModes .get (string);

				if (boundaryMode !== undefined)
					return boundaryMode;
	
				return "REPEAT";
			};
		})(),
		getBoundaryModeS: function ()
		{
			return this .getBoundaryMode (this .boundaryModeS_ .getValue ());
		},
		getBoundaryModeT: function ()
		{
			return this .getBoundaryMode (this .boundaryModeT_ .getValue ());
		},
		getBoundaryModeR: function ()
		{
			return this .getBoundaryMode (this .boundaryModeR_ .getValue ());
		},
		getMinificationFilter: (function ()
		{
			var minificationFilters = new Map ([
				["AVG_PIXEL_AVG_MIPMAP",         "LINEAR_MIPMAP_LINEAR"],
				["AVG_PIXEL",                    "LINEAR"],
				["AVG_PIXEL_NEAREST_MIPMAP",     "LINEAR_MIPMAP_NEAREST"],
				["NEAREST_PIXEL_AVG_MIPMAP",     "NEAREST_MIPMAP_LINEAR"],
				["NEAREST_PIXEL_NEAREST_MIPMAP", "NEAREST_MIPMAP_NEAREST"],
				["NEAREST_PIXEL",                "NEAREST"],
				["NICEST",                       "LINEAR_MIPMAP_LINEAR"],
				["FASTEST",                      "NEAREST"],
			]);

			return function ()
			{
				if (this .generateMipMaps_ .getValue ())
				{
					var minificationFilter = minificationFilters .get (this .minificationFilter_ .getValue ());
				
					if (minificationFilter !== undefined)
						return minificationFilter;

					return this .getBrowser () .getDefaultTextureProperties () .getMinificationFilter ();
				}
	
				return "LINEAR";
			};
		})(),
		getMagnificationFilter: (function ()
		{
			var magnificationFilters = new Map ([
				["AVG_PIXEL",     "LINEAR"],
				["NEAREST_PIXEL", "NEAREST"],
				["NICEST",        "LINEAR"],
				["FASTEST",       "NEAREST"],
			]);

			return function ()
			{
				var magnificationFilter = magnificationFilters .get (this .magnificationFilter_ .getValue ());
			
				if (magnificationFilter !== undefined)
					return magnificationFilter;
	
				// DEFAULT
				return this .getBrowser () .getDefaultTextureProperties () .getMagnificationFilter ();
			};
		})(),
		getTextureCompression: (function ()
		{
			var textureCompressions = new Map ([
				["DEFAULT", "RGBA"],
				["NICEST",  "RGBA"],
				["FASTEST", "RGBA"],
				["LOW",     "RGBA"],
				["MEDIUM",  "RGBA"],
				["HIGH",    "RGBA"],
			]);

			return function ()
			{
				var
					browser            = this .getBrowser (),
					gl                 = browser .getContext (),
					compressedTexture  = browser .getExtension ("WEBGL_compressed_texture_etc"), // TODO: find suitable compression.
					textureCompression = compressedTexture ? compressedTexture [textureCompressions .get (this .textureCompression_ .getValue ())] : undefined;

				if (textureCompression !== undefined)
					return textureCompression;

				// DEFAULT
				return gl .RGBA;
			};
		})(),
	});

	return TextureProperties;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Shape/X3DShapeContext',[
	"x_ite/Components/Shape/Appearance",
	"x_ite/Components/Shape/PointProperties",
	"x_ite/Components/Shape/LineProperties",
	"x_ite/Components/Shape/FillProperties",
	"x_ite/Components/Texturing/ImageTexture",
	"x_ite/Components/Texturing/TextureProperties",
	"x_ite/Browser/Networking/urls",
],
function (Appearance,
          PointProperties,
          LineProperties,
          FillProperties,
          ImageTexture,
          TextureProperties,
          urls)
{
"use strict";

	function X3DShapeContext ()
	{
		this .linetypeTextures   = [ ];
		this .hatchStyleTextures = [ ];
	}

	X3DShapeContext .prototype =
	{
		initialize: function ()
		{ },
		getDefaultAppearance: function ()
		{
			if (this .defaultAppearance)
				return this .defaultAppearance;

			this .defaultAppearance = new Appearance (this .getPrivateScene ());

			this .defaultAppearance .setup ();

			return this .defaultAppearance;
		},
		getDefaultPointProperties: function ()
		{
			if (this .defaultPointProperties)
				return this .defaultPointProperties;

			this .defaultPointProperties = new PointProperties (this .getPrivateScene ());

			this .defaultPointProperties .setup ();

			return this .defaultPointProperties;
		},
		getDefaultLineProperties: function ()
		{
			if (this .defaultLineProperties)
				return this .defaultLineProperties;

			this .defaultLineProperties = new LineProperties (this .getPrivateScene ());

			this .defaultLineProperties .applied_ = false;
			this .defaultLineProperties .setup ();

			return this .defaultLineProperties;
		},
		getDefaultFillProperties: function ()
		{
			if (this .defaultFillProperties)
				return this .defaultFillProperties;

			this .defaultFillProperties = new FillProperties (this .getPrivateScene ());

			this .defaultFillProperties .hatched_ = false;
			this .defaultFillProperties .setup ();

			return this .defaultFillProperties;
		},
		getLinetype: function (index)
		{
			if (index < 1 || index > 15)
				index = 1;

			var linetypeTexture = this .linetypeTextures [index];

			if (linetypeTexture)
				return linetypeTexture;

			linetypeTexture = this .linetypeTextures [index] = new ImageTexture (this .getPrivateScene ());

			linetypeTexture .url_ [0]           = urls .getLinetypeUrl (index);
			linetypeTexture .textureProperties_ = this .getLineFillTextureProperties ();
			linetypeTexture .setup ();

			return linetypeTexture;
		},
		getHatchStyle: function (index)
		{
			if (index < 1 || index > 19)
				index = 1;

			var hatchStyleTexture = this .hatchStyleTextures [index];

			if (hatchStyleTexture)
				return hatchStyleTexture;

			hatchStyleTexture = this .hatchStyleTextures [index] = new ImageTexture (this .getPrivateScene ());

			hatchStyleTexture .url_ [0]           = urls .getHatchingUrl (index);
			hatchStyleTexture .textureProperties_ = this .getLineFillTextureProperties ();
			hatchStyleTexture .setup ();

			return hatchStyleTexture;
		},
		getLineFillTextureProperties: function ()
		{
			if (this .lineFillTextureProperties)
				return this .lineFillTextureProperties;

			this .lineFillTextureProperties = new TextureProperties (this .getPrivateScene ());

			this .lineFillTextureProperties .setup ();

			return this .lineFillTextureProperties;
		},
	};

	return X3DShapeContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Box3',[
	"standard/Math/Geometry/Triangle3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Algorithms/SAT",
],
function (Triangle3,
          Matrix4,
          Vector3,
          SAT)
{
"use strict";

	function Box3 (size, center)
	{
		switch (arguments .length)
		{
			case 0:
			{
				this .matrix = new Matrix4 (0, 0, 0, 0,
				                            0, 0, 0, 0,
				                            0, 0, 0, 0,
				                            0, 0, 0, 0);
				return;
			}
			case 2:
			{
				this .matrix = new Matrix4 (size .x / 2, 0, 0, 0,
				                            0, size .y / 2, 0, 0,
				                            0, 0, size .z / 2, 0,
				                            center .x, center .y, center .z, 1);
				return;
			}
			case 3:
			{
				var
					min = arguments [0],
					max = arguments [1],
					sx  = (max .x - min .x) / 2,
					sy  = (max .y - min .y) / 2,
					sz  = (max .z - min .z) / 2,
					cx  = (max .x + min .x) / 2,
					cy  = (max .y + min .y) / 2,
					cz  = (max .z + min .z) / 2;

				this .matrix = new Matrix4 (sx, 0,  0,  0,
				                            0,  sy, 0,  0,
				                            0,  0,  sz, 0,
				                            cx, cy, cz, 1);
				return;
			}
		}
	}

	Box3 .prototype =
	{
		constructor: Box3,
		copy: function ()
		{
			var copy = Object .create (Box3 .prototype);
			copy .matrix = this .matrix .copy ();
			return copy;
		},
		assign: function (box)
		{
			this .matrix .assign (box .matrix);
			return this;
		},
		equals: function (box)
		{
			return this .matrix .equals (box .matrix);
		},
		getMatrix: function ()
		{
			return this .matrix;
		},
		set: function (size, center)
		{
			var m = this .matrix;

			switch (arguments .length)
			{
				case 0:
				{
					m [ 0] = 0.5; m [ 1] = 0;   m [ 2] = 0;   m [ 3] = 0;
					m [ 4] = 0;   m [ 5] = 0.5; m [ 6] = 0;   m [ 7] = 0;
					m [ 8] = 0;   m [ 9] = 0;   m [10] = 0.5; m [11] = 0;
					m [12] = 0;   m [13] = 0;   m [14] = 0;   m [15] = 0;
					return this;
				}
				case 2:
				{
					m [ 0] = size .x / 2; m [ 1] = 0;           m [ 2] = 0;           m [ 3] = 0;
					m [ 4] = 0;           m [ 5] = size .y / 2; m [ 6] = 0;           m [ 7] = 0;
					m [ 8] = 0;           m [ 9] = 0;           m [10] = size .z / 2; m [11] = 0;
					m [12] = center .x;   m [13] = center .y;   m [14] = center .z;   m [15] = 1;
					return this;
				}
				case 3:
				{
					var
						min = arguments [0],
						max = arguments [1],
						sx  = (max .x - min .x) / 2,
						sy  = (max .y - min .y) / 2,
						sz  = (max .z - min .z) / 2,
						cx  = (max .x + min .x) / 2,
						cy  = (max .y + min .y) / 2,
						cz  = (max .z + min .z) / 2;

					this .matrix .set (sx, 0,  0,  0,
					                   0,  sy, 0,  0,
					                   0,  0,  sz, 0,
					                   cx, cy, cz, 1);
					return this;
				}
			}
		},
		setExtents: function (min, max)
		{
			var
				m  = this .matrix,
				sx = (max .x - min .x) / 2,
				sy = (max .y - min .y) / 2,
				sz = (max .z - min .z) / 2,
				cx = (max .x + min .x) / 2,
				cy = (max .y + min .y) / 2,
				cz = (max .z + min .z) / 2;

			m [ 0] = sx; m [ 1] = 0;  m [ 2] = 0;  m [ 3] = 0;
			m [ 4] = 0;  m [ 5] = sy; m [ 6] = 0;  m [ 7] = 0;
			m [ 8] = 0;  m [ 9] = 0;  m [10] = sz; m [11] = 0;
			m [12] = cx; m [13] = cy; m [14] = cz; m [15] = 1;
			return this;
		},
		getExtents: function (min, max)
		{
			this .getAbsoluteExtents (min, max);

			min .add (this .center);
			max .add (this .center);
		},
		getAbsoluteExtents: (function ()
		{
			var
				r1 = new Vector3 (0, 0, 0),
				p1 = new Vector3 (0, 0, 0),
				p4 = new Vector3 (0, 0, 0);

			return function (min, max)
			{
				var
					m = this .matrix,
					x = m .xAxis,
					y = m .yAxis,
					z = m .zAxis;

				r1 .assign (y) .add (z);

				var r2 = z .subtract (y);

				p1 .assign (x) .add (r1),
				p4 .assign (x) .add (r2);

				var
					p2 = r1 .subtract (x),
					p3 = r2 .subtract (x);

				min .assign (p1);
				max .assign (p1);

				min .min (p2, p3, p4);
				max .max (p2, p3, p4);

				p1 .negate ();
				p2 .negate ();
				p3 .negate ();
				p4 .negate ();

				min .min (p1, p2, p3, p4);
				max .max (p1, p2, p3, p4);
			};
		})(),
		getPoints: (function ()
		{
			var
				x  = new Vector3 (0, 0, 0),
				y  = new Vector3 (0, 0, 0),
				z  = new Vector3 (0, 0, 0),
				r1 = new Vector3 (0, 0, 0);

			return function (points)
			{
				/*
				 * p6 ---------- p5
				 * | \           | \
				 * | p2------------ p1
				 * |  |          |  |
				 * |  |          |  |
				 * p7 |_________ p8 |
				 *  \ |           \ |
				 *   \|            \|
				 *    p3 ---------- p4
				 */

				var m = this .matrix;

				x .assign (m .xAxis);
				y .assign (m .yAxis);
				z .assign (m .zAxis);

				r1 .assign (y) .add (z);

				var r2 = z .subtract (y);

				points [0] .assign (x)  .add (r1);
				points [1] .assign (r1) .subtract (x);
				points [2] .assign (r2) .subtract (x);
				points [3] .assign (x)  .add (r2);

				points [4] .assign (points [2]) .negate ();
				points [5] .assign (points [3]) .negate ();
				points [6] .assign (points [0]) .negate ();
				points [7] .assign (points [1]) .negate ();

				var center = this .center;

				points [0] .add (center);
				points [1] .add (center);
				points [2] .add (center);
				points [3] .add (center);

				points [4] .add (center);
				points [5] .add (center);
				points [6] .add (center);
				points [7] .add (center);

				return points;
			};
		})(),
		getAxes: function (axes)
		{
			var m = this .matrix;

			axes [0] .assign (m .xAxis);
			axes [1] .assign (m .yAxis);
			axes [2] .assign (m .zAxis);

			return axes;
		},
		getNormals: (function ()
		{
			var
				x = new Vector3 (0, 0, 0),
				y = new Vector3 (0, 0, 0),
				z = new Vector3 (0, 0, 0);

			var axes = [ Vector3 .xAxis, Vector3 .yAxis, Vector3 .zAxis ];

			return function (planes)
			{
				var m = this .matrix;

				x .assign (m .xAxis);
				y .assign (m .yAxis);
				z .assign (m .zAxis);

				if (x .norm () == 0 && y .norm () == 0 && z .norm () == 0)
				{
					x .assign (Vector3 .xAxis);
					y .assign (Vector3 .yAxis);
					z .assign (Vector3 .zAxis);
				}
				else
				{
					if (x .norm () == 0)
					{
						x .assign (y) .cross (z);

						if (x .norm () == 0)
						{
							for (var i = 0; i < 3; ++ i)
							{
								x .assign (axes [i]) .cross (y);

								if (x .norm () == 0)
									continue;

								break;
							}
						}

						if (x .norm () == 0)
						{
							for (var i = 0; i < 3; ++ i)
							{
								x .assign (axes [i]) .cross (z);

								if (x .norm () == 0)
									continue;

								break;
							}
						}

						if (x .norm () == 0)
							x .assign (Vector3 .xAxis);
						else
							x .normalize ();
					}

					if (y .norm () == 0)
					{
						y .assign (z) .cross (x);

						if (y .norm () == 0)
						{
							for (var i = 0; i < 3; ++ i)
							{
								y .assign (axes [i]) .cross (z);

								if (y .norm () == 0)
									continue;

								break;
							}
						}

						if (y .norm () == 0)
						{
							for (var i = 0; i < 3; ++ i)
							{
								y .assign (axes [i]) .cross (x);

								if (y .norm () == 0)
									continue;

								break;
							}
						}

						if (y .norm () == 0)
							y .assign (Vector3 .yAxis);
						else
							y .normalize ();
					}

					if (z .norm () == 0)
					{
						z .assign (x) .cross (y);

						if (z .norm () == 0)
						{
							for (var i = 0; i < 3; ++ i)
							{
								z .assign (axes [i]) .cross (x);

								if (z .norm () == 0)
									continue;

								break;
							}
						}

						if (z .norm () == 0)
						{
							for (var i = 0; i < 3; ++ i)
							{
								z .assign (axes [i]) .cross (y);

								if (z .norm () == 0)
									continue;

								break;
							}
						}

						if (z .norm () == 0)
							z .assign (Vector3 .zAxis);
						else
							z .normalize ();
					}
				}

				planes [0] .assign (y) .cross (z) .normalize ();
				planes [1] .assign (z) .cross (x) .normalize ();
				planes [2] .assign (x) .cross (y) .normalize ();

				return planes;
			};
		})(),
		isEmpty: function ()
		{
			return this .matrix [15] === 0;
		},
		add: (function ()
		{
			var
				lhs_min = new Vector3 (0, 0, 0),
				lhs_max = new Vector3 (0, 0, 0),
				rhs_min = new Vector3 (0, 0, 0),
				rhs_max = new Vector3 (0, 0, 0);

			return function (box)
			{
				if (this .isEmpty ())
					return this .assign (box);

				if (box .isEmpty ())
					return this;

				this .getExtents (lhs_min, lhs_max);
				box  .getExtents (rhs_min, rhs_max);

				return this .set (lhs_min .min (rhs_min), lhs_max .max (rhs_max), true);
			};
		})(),
		multLeft: function (matrix)
		{
			this .matrix .multLeft (matrix);
			return this;
		},
		multRight: function (matrix)
		{
			this .matrix .multRight (matrix);
			return this;
		},
		intersectsPoint: (function ()
		{
			var
				min = new Vector3 (0, 0, 0),
				max = new Vector3 (0, 0, 0);

			return function (point)
			{
				this .getExtents (min, max);

				return min .x <= point .x &&
				       max .x >= point .x &&
				       min .y <= point .y &&
				       max .y >= point .y &&
				       min .z <= point .z &&
				       max .z >= point .z;
			};
		})(),
		intersectsBox: (function ()
		{
			var points1 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),

				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var points2 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),

				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var axes1 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var axes2 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var axes9 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),

				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),

				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var planes = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			return function (other)
			{
				// Test special cases.

				if (this .isEmpty ())
					return false;

				if (other .isEmpty ())
					return false;

				// Get points.

				this  .getPoints (points1);
				other .getPoints (points2);

				// Test the three planes spanned by the normal vectors of the faces of the first parallelepiped.

				if (SAT .isSeparated (this .getNormals (planes), points1, points2))
					return false;

				// Test the three planes spanned by the normal vectors of the faces of the second parallelepiped.

				if (SAT .isSeparated (other .getNormals (planes), points1, points2))
					return false;

				// Test the nine other planes spanned by the edges of each parallelepiped.

				this  .getAxes (axes1);
				other .getAxes (axes2);

				for (var i1 = 0; i1 < 3; ++ i1)
				{
					for (var i2 = 0; i2 < 3; ++ i2)
						axes9 [i1 * 3 + i2] .assign (axes1 [i1]) .cross (axes2 [i2]);
				}

				if (SAT .isSeparated (axes9, points1, points2))
					return false;

				// Both boxes intersect.

				return true;
			};
		})(),
		intersectsTriangle: (function ()
		{
			var points1 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),

				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var axes1 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var axes9 = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),

				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),

				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var planes = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
			];

			var triangle = [ ];

			var triangleNormal = [ new Vector3 (0, 0, 0) ];

			var triangleEdges = [
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0),
				new Vector3 (0, 0, 0)
			];

			return function (a, b, c)
			{
				// Test special cases.

				if (this .isEmpty ())
					return false;

				// Get points.

				this .getPoints (points1);

				triangle [0] = a;
				triangle [1] = b;
				triangle [2] = c;

				// Test the three planes spanned by the normal vectors of the faces of the first parallelepiped.

				if (SAT .isSeparated (this .getNormals (planes), points1, triangle))
					return false;

				// Test the normal of the triangle.

				Triangle3 .normal (a, b, c, triangleNormal [0]);

				if (SAT .isSeparated (triangleNormal, points1, triangle))
					return false;

				// Test the nine other planes spanned by the edges of each parallelepiped.

				this .getAxes (axes1);

				triangleEdges [0] .assign (a) .subtract (b);
				triangleEdges [1] .assign (b) .subtract (c);
				triangleEdges [2] .assign (c) .subtract (a);

				for (var i1 = 0; i1 < 3; ++ i1)
				{
					for (var i2 = 0; i2 < 3; ++ i2)
						axes9 [i1 * 3 + i2] .assign (axes1 [i1]) .cross (triangleEdges [i2]);
				}

				if (SAT .isSeparated (axes9, points1, triangle))
					return false;

				// Box and triangle intersect.

				return true;
			};
		})(),
		toString: function ()
		{
			return this .size + ", " + this .center;
		},
	};

	Object .defineProperty (Box3 .prototype, "size",
	{
		get: (function ()
		{
			var
				min = new Vector3 (0, 0, 0),
				max = new Vector3 (0, 0, 0);

			return function ()
			{
				this .getAbsoluteExtents (min, max);

				return max .subtract (min);
			};
		})(),
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (Box3 .prototype, "center",
	{
		get: function ()
		{
			return this .matrix .origin;
		},
		enumerable: true,
		configurable: false
	});

	return Box3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DGeometryNode',[
	"x_ite/Fields",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Core/Shading",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Box3",
	"standard/Math/Geometry/Plane3",
	"standard/Math/Geometry/Triangle3",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DNode,
          X3DConstants,
          Shading,
          Vector2,
          Vector3,
          Matrix4,
          Box3,
          Plane3,
          Triangle3,
          Algorithm)
{
"use strict";

	var ARRAY_TYPE = "Array"; // For color, texCoord, normal, and vertex array, can be MFFloat or Array;

	// Box normals for bbox / line intersection.
	var boxNormals = [
		new Vector3 (0,  0,  1), // front
		new Vector3 (0,  0, -1), // back
		new Vector3 (0,  1,  0), // top
		new Vector3 (0, -1,  0), // bottom
		new Vector3 (1,  0,  0)  // right
		// left: We do not have to test for left.
	];

	function X3DGeometryNode (executionContext)
	{
		X3DNode .call (this, executionContext);

		this .addType (X3DConstants .X3DGeometryNode);

		this .addChildObjects ("transparent",  new Fields .SFBool (),
		                       "bbox_changed", new Fields .SFTime (),
		                       "rebuild",      new Fields .SFTime ());

		this .transparent_  .setAccessType (X3DConstants .outputOnly);
		this .bbox_changed_ .setAccessType (X3DConstants .outputOnly);
		this .rebuild_      .setAccessType (X3DConstants .outputOnly);

		// Members

		this .min                   = new Vector3 (0, 0, 0);
		this .max                   = new Vector3 (0, 0, 0);
		this .bbox                  = new Box3 (this .min, this .max, true);
		this .solid                 = true;
		this .geometryType          = 3;
		this .flatShading           = undefined;
		this .colorMaterial         = false;
		this .attribNodes           = [ ];
		this .attribs               = [ ];
		this .textureCoordinateNode = this .getBrowser () .getDefaultTextureCoordinate ();
		this .multiTexCoords        = [ ];
		this .texCoords             = X3DGeometryNode .createArray ();
		this .fogDepths             = X3DGeometryNode .createArray ();
		this .colors                = X3DGeometryNode .createArray ();
		this .normals               = X3DGeometryNode .createArray ();
		this .flatNormals           = X3DGeometryNode .createArray ();
		this .vertices              = X3DGeometryNode .createArray ();
		this .vertexCount           = 0;

		// This methods are configured in transfer.
		this .depth            = Function .prototype;
		this .display          = Function .prototype;
		this .displayParticles = Function .prototype;
	}

	// Function to select ether Array or MFFloat for color/normal/vertex arrays.
	X3DGeometryNode .createArray = function ()
	{
		if (ARRAY_TYPE == "MFFloat")
			return new Fields .MFFloat ();

		var array = [ ];

		array .typedArray = new Float32Array ();

		array .assign = function (value)
		{
			for (var i = 0, length = value .length; i < length; ++ i)
				this [i] = value [i];

			this .length = length;
		};

		array .getValue = function ()
		{
			return this .typedArray;
		};

		array .shrinkToFit = function ()
		{
			if (this .length !== this .typedArray .length)
				this .typedArray = new Float32Array (this);
			else
				this .typedArray .set (this);
		};

		return array;
	}

	X3DGeometryNode .prototype = Object .assign (Object .create (X3DNode .prototype),
	{
		constructor: X3DGeometryNode,
		setup: function ()
		{
			X3DNode .prototype .setup .call (this);

			this .rebuild ();
		},
		initialize: function ()
		{
			X3DNode .prototype .initialize .call (this);

			this .isLive () .addInterest ("set_live__", this);

			this .addInterest ("requestRebuild", this);
			this .rebuild_ .addInterest ("rebuild", this);

			var gl = this .getBrowser () .getContext ();

			this .primitiveMode   = gl .TRIANGLES;
			this .frontFace       = gl .CCW;
			this .attribBuffers   = [ ];
			this .texCoordBuffers = [ ];
			this .fogDepthBuffer  = gl .createBuffer ();
			this .colorBuffer     = gl .createBuffer ();
			this .normalBuffer    = gl .createBuffer ();
			this .vertexBuffer    = gl .createBuffer ();
			this .planes          = [ ];

			if (this .geometryType > 1)
			{
				for (var i = 0; i < 5; ++ i)
					this .planes [i] = new Plane3 (Vector3 .Zero, boxNormals [0]);
			}

			this .set_live__ ();
		},
		setGeometryType: function (value)
		{
			this .geometryType = value;
		},
		getGeometryType: function ()
		{
			return this .geometryType;
		},
		setTransparent: function (value)
		{
			if (value !== this .transparent_ .getValue ())
				this .transparent_ = value;
		},
		getTransparent: function ()
		{
			return this .transparent_ .getValue ();
		},
		getBBox: function ()
		{
			// With screen matrix applied.
			return this .bbox;
		},
		setBBox: function (bbox)
		{
			if (bbox .equals (this .bbox))
				return;

		   bbox .getExtents (this .min, this .max);

			this .bbox .assign (bbox);

			for (var i = 0; i < 5; ++ i)
				this .planes [i] .set (i % 2 ? this .min : this .max, boxNormals [i]);

			this .bbox_changed_ .addEvent ();
		},
		getMin: function ()
		{
			// With screen matrix applied.
			return this .min;
		},
		getMax: function ()
		{
			// With screen matrix applied.
			return this .max;
		},
		getMatrix: function ()
		{
			return Matrix4 .Identity;
		},
		setPrimitiveMode: function (value)
		{
			this .primitiveMode = value;
		},
		getPrimitiveMode: function ()
		{
			return this .primitiveMode;
		},
		setSolid: function (value)
		{
			this .solid = value;
		},
		setCCW: function (value)
		{
			this .frontFace = value ? this .getBrowser () .getContext () .CCW : this .getBrowser () .getContext () .CW;
		},
		getAttrib: function ()
		{
			return this .attribNodes;
		},
		getAttribs: function ()
		{
			return this .attribs;
		},
		setFogDepths: function (value)
		{
			this .fogDepths .assign (value);
		},
		getFogDepths: function ()
		{
			return this .fogDepths;
		},
		setColors: function (value)
		{
			this .colors .assign (value);
		},
		getColors: function ()
		{
			return this .colors;
		},
		setMultiTexCoords: function (value)
		{
			var multiTexCoords = this .multiTexCoords;

			for (var i = 0, length = value .length; i < length; ++ i)
				multiTexCoords [i] = value [i];

			multiTexCoords .length = length;
		},
		getMultiTexCoords: function ()
		{
			return this .multiTexCoords;
		},
		getTexCoords: function ()
		{
			return this .texCoords;
		},
		setTextureCoordinate: function (value)
		{
			if (value)
				this .textureCoordinateNode = value;
			else
				this .textureCoordinateNode = this .getBrowser () .getDefaultTextureCoordinate ();
		},
		setNormals: function (value)
		{
			this .normals .assign (value);
		},
		getNormals: function ()
		{
			return this .normals;
		},
		setVertices: function (value)
		{
			this .vertices .assign (value);
		},
		getVertices: function ()
		{
			return this .vertices;
		},
		buildTexCoords: function ()
		{
			var texCoords = this .texCoords;

			if (texCoords .length === 0)
			{
				var
					p         = this .getTexCoordParams (),
					min       = p .min,
					Sindex    = p .Sindex,
					Tindex    = p .Tindex,
					Ssize     = p .Ssize,
					S         = min [Sindex],
					T         = min [Tindex],
					vertices  = this .vertices .getValue ();

				for (var i = 0, length = vertices .length; i < length; i += 4)
				{
					texCoords .push ((vertices [i + Sindex] - S) / Ssize,
					                 (vertices [i + Tindex] - T) / Ssize,
					                 0,
					                 1);
				}

				texCoords .shrinkToFit ();
			}

			return texCoords;
		},
		getTexCoordParams: (function ()
		{
			var texCoordParams = { min: new Vector3 (0, 0, 0) };

			return function ()
			{
				var
					bbox  = this .getBBox (),
					size  = bbox .size,
					Xsize = size .x,
					Ysize = size .y,
					Zsize = size .z;

				texCoordParams .min .assign (bbox .center) .subtract (size .divide (2));

				if ((Xsize >= Ysize) && (Xsize >= Zsize))
				{
					// X size largest
					texCoordParams .Ssize = Xsize; texCoordParams .Sindex = 0;

					if (Ysize >= Zsize)
						texCoordParams .Tindex = 1;
					else
						texCoordParams .Tindex = 2;
				}
				else if ((Ysize >= Xsize) && (Ysize >= Zsize))
				{
					// Y size largest
					texCoordParams .Ssize = Ysize; texCoordParams .Sindex = 1;

					if (Xsize >= Zsize)
						texCoordParams .Tindex = 0;
					else
						texCoordParams .Tindex = 2;
				}
				else
				{
					// Z is the largest
					texCoordParams .Ssize = Zsize; texCoordParams .Sindex = 2;

					if (Xsize >= Ysize)
						texCoordParams .Tindex = 0;
					else
						texCoordParams .Tindex = 1;
				}

				return texCoordParams;
			};
		})(),
		refineNormals: function (normalIndex, normals, creaseAngle)
		{
			if (creaseAngle === 0)
				return normals;

			var
				cosCreaseAngle = Math .cos (Algorithm .clamp (creaseAngle, 0, Math .PI)),
				normals_       = [ ];

			for (var i in normalIndex) // Don't use forEach
			{
				var vertex = normalIndex [i];

				for (var p = 0, length = vertex .length; p < length; ++ p)
				{
					var
						P = vertex [p],
						m = normals [P],
						n = new Vector3 (0, 0, 0);

					for (var q = 0; q < length; ++ q)
					{
						var Q = normals [vertex [q]];

						if (Q .dot (m) >= cosCreaseAngle)
							n .add (Q);
					}

					normals_ [P] = n .normalize ();
				}
			}

			return normals_;
		},
		isClipped: function (point, clipPlanes)
		{
			return clipPlanes .some (function (clipPlane)
			{
				return clipPlane .isClipped (point);
			});
		},
		transformLine: function (line)
		{
			// Apply sceen nodes transformation in place here.
		},
		transformMatrix: function (line)
		{
			// Apply sceen nodes transformation in place here.
		},
		intersectsLine: (function ()
		{
			var
				modelViewMatrix = new Matrix4 (),
				uvt             = { u: 0, v: 0, t: 0 },
				v0              = new Vector3 (0, 0, 0),
				v1              = new Vector3 (0, 0, 0),
				v2              = new Vector3 (0, 0, 0),
				clipPoint       = new Vector3 (0, 0, 0);

			return function (line, clipPlanes, modelViewMatrix_, intersections)
			{
				try
				{
					var intersected = false;

					if (this .intersectsBBox (line))
					{
						this .transformLine   (line);                                       // Apply screen transformations from screen nodes.
						this .transformMatrix (modelViewMatrix .assign (modelViewMatrix_)); // Apply screen transformations from screen nodes.

						var
							texCoords  = this .multiTexCoords [0] .getValue (),
							normals    = this .normals .getValue (),
							vertices   = this .vertices .getValue ();

						for (var i = 0, length = this .vertexCount; i < length; i += 3)
						{
							var i4 = i * 4;

							v0 .x = vertices [i4];     v0 .y = vertices [i4 + 1]; v0 .z = vertices [i4 +  2];
							v1 .x = vertices [i4 + 4]; v1 .y = vertices [i4 + 5]; v1 .z = vertices [i4 +  6];
							v2 .x = vertices [i4 + 8]; v2 .y = vertices [i4 + 9]; v2 .z = vertices [i4 + 10];

							if (line .intersectsTriangle (v0, v1, v2, uvt))
							{
								// Get barycentric coordinates.

								var
									u = uvt .u,
									v = uvt .v,
									t = uvt .t;

								// Determine vectors for X3DPointingDeviceSensors.

								var point = new Vector3 (t * vertices [i4]     + u * vertices [i4 + 4] + v * vertices [i4 +  8],
								                         t * vertices [i4 + 1] + u * vertices [i4 + 5] + v * vertices [i4 +  9],
								                         t * vertices [i4 + 2] + u * vertices [i4 + 6] + v * vertices [i4 + 10]);

								if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (point)), clipPlanes))
									continue;

								var texCoord = new Vector2 (t * texCoords [i4]     + u * texCoords [i4 + 4] + v * texCoords [i4 + 8],
								                            t * texCoords [i4 + 1] + u * texCoords [i4 + 5] + v * texCoords [i4 + 9]);

								var i3 = i * 3;

								var normal = new Vector3 (t * normals [i3]     + u * normals [i3 + 3] + v * normals [i3 + 6],
								                          t * normals [i3 + 1] + u * normals [i3 + 4] + v * normals [i3 + 7],
								                          t * normals [i3 + 2] + u * normals [i3 + 5] + v * normals [i3 + 8]);

								intersections .push ({ texCoord: texCoord, normal: normal, point: this .getMatrix () .multVecMatrix (point) });
								intersected = true;
							}
						}
					}

					return intersected;
				}
				catch (error)
				{
					console .log (error);
					return false;
				}
			};
		})(),
		intersectsBBox: (function ()
		{
			var intersection = new Vector3 (0, 0, 0);

			return function (line)
			{
				var
					planes = this .planes,
					min    = this .min,
					max    = this .max,
					minX   = min .x,
					maxX   = max .x,
					minY   = min .y,
					maxY   = max .y,
					minZ   = min .z,
					maxZ   = max .z;

			   // front
				if (planes [0] .intersectsLine (line, intersection))
				{
					if (intersection .x >= minX && intersection .x <= maxX &&
					    intersection .y >= minY && intersection .y <= maxY)
						return true;
				}

				// back
				if (planes [1] .intersectsLine (line, intersection))
				{
					if (intersection .x >= minX && intersection .x <= maxX &&
					    intersection .y >= minY && intersection .y <= maxY)
						return true;
				}

				// top
				if (planes [2] .intersectsLine (line, intersection))
				{
					if (intersection .x >= minX && intersection .x <= maxX &&
					    intersection .z >= minZ && intersection .z <= maxZ)
						return true;
				}

				// bottom
				if (planes [3] .intersectsLine (line, intersection))
				{
					if (intersection .x >= minX && intersection .x <= maxX &&
					    intersection .z >= minZ && intersection .z <= maxZ)
						return true;
				}

				// right
				if (planes [4] .intersectsLine (line, intersection))
				{
					if (intersection .y >= minY && intersection .y <= maxY &&
					    intersection .z >= minZ && intersection .z <= maxZ)
						return true;
				}

				return false;
			};
		})(),
		intersectsBox: (function ()
		{
			var
				v0        = new Vector3 (0, 0, 0),
				v1        = new Vector3 (0, 0, 0),
				v2        = new Vector3 (0, 0, 0),
				invMatrix = new Matrix4 (),
				clipPoint = new Vector3 (0, 0, 0);

			return function (box, clipPlanes, modelViewMatrix)
			{
				try
				{
					if (box .intersectsBox (this .bbox))
					{
						box .multRight (invMatrix .assign (this .getMatrix ()) .inverse ());

						this .transformMatrix (modelViewMatrix); // Apply screen transformations from screen nodes.

						var vertices = this .vertices .getValue ();

						for (var i = 0, length = this .vertexCount; i < length; i += 3)
						{
							var i4 = i * 4;

							v0 .x = vertices [i4];     v0 .y = vertices [i4 + 1]; v0 .z = vertices [i4 +  2];
							v1 .x = vertices [i4 + 4]; v1 .y = vertices [i4 + 5]; v1 .z = vertices [i4 +  6];
							v2 .x = vertices [i4 + 8]; v2 .y = vertices [i4 + 9]; v2 .z = vertices [i4 + 10];

							if (box .intersectsTriangle (v0, v1, v2))
							{
								if (clipPlanes .length)
								{
									if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (v0)), clipPlanes))
										continue;

									if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (v1)), clipPlanes))
										continue;

									if (this .isClipped (modelViewMatrix .multVecMatrix (clipPoint .assign (v2)), clipPlanes))
										continue;
								}

							   return true;
							}
					   }
					}

				   return false;
				}
				catch (error)
				{
					console .log (error);
					return false;
				}
			};
		})(),
		set_live__: function ()
		{
			if (this .isLive () .getValue ())
				this .getBrowser () .getBrowserOptions () .Shading_ .addInterest ("set_shading__", this);
			else
				this .getBrowser () .getBrowserOptions () .Shading_ .removeInterest ("set_shading__", this);
		},
		set_shading__: (function ()
		{
			var
				v0     = new Vector3 (0, 0, 0),
				v1     = new Vector3 (0, 0, 0),
				v2     = new Vector3 (0, 0, 0),
				normal = new Vector3 (0, 0, 0);

			return function (shading)
			{
				if (this .geometryType < 2)
					return;

				var flatShading = this .getBrowser () .getBrowserOptions () .getShading () === Shading .FLAT;

				if (flatShading === this .flatShading)
					return;

				this .flatShading = flatShading;

				// Generate flat normals if needed.

				var gl = this .getBrowser () .getContext ();

				if (flatShading)
				{
					if (! this .flatNormals .length)
					{
						var
							cw          = this .frontFace === gl .CW,
							flatNormals = this .flatNormals,
							vertices    = this .vertices .getValue ();

						for (var i = 0, length = vertices .length; i < length; i += 12)
						{
						   Triangle3 .normal (v0 .set (vertices [i],     vertices [i + 1], vertices [i + 2]),
						                      v1 .set (vertices [i + 4], vertices [i + 5], vertices [i + 6]),
						                      v2 .set (vertices [i + 8], vertices [i + 9], vertices [i + 10]),
						                      normal);

							if (cw)
								normal .negate ();

							flatNormals .push (normal .x, normal .y, normal .z,
							                   normal .x, normal .y, normal .z,
							                   normal .x, normal .y, normal .z);
						}

						flatNormals .shrinkToFit ();
					}
				}

				// Transfer normals.

				gl .bindBuffer (gl .ARRAY_BUFFER, this .normalBuffer);
				gl .bufferData (gl .ARRAY_BUFFER, flatShading ? this .flatNormals .getValue () : this .normals .getValue (), gl .STATIC_DRAW);
			};
		})(),
		requestRebuild: function ()
		{
			this .rebuild_ .addEvent ();
		},
		rebuild: (function ()
		{
			var point = new Vector3 (0, 0, 0);

			return function ()
			{
				this .clear ();
				this .build ();

				// Shrink arrays before transfer to graphics card.

				for (var i = 0, length = this .attribs .length; i < length; ++ i)
					this .attribs [i] .shrinkToFit ();

				for (var i = 0, length = this .multiTexCoords .length; i < length; ++ i)
					this .multiTexCoords [i] .shrinkToFit ();

				this .fogDepths .shrinkToFit ();
				this .colors    .shrinkToFit ();
				this .normals   .shrinkToFit ();
				this .vertices  .shrinkToFit ();

				// Determine bbox.

				var
					min      = this .min,
					max      = this .max,
					vertices = this .vertices .getValue ();

				if (vertices .length)
				{
					if (min .x === Number .POSITIVE_INFINITY)
					{
						for (var i = 0, length = vertices .length; i < length; i += 4)
						{
							point .set (vertices [i], vertices [i + 1], vertices [i + 2]);

							min .min (point);
							max .max (point);
						}
					}

					this .bbox .setExtents (min, max);
				}
				else
				{
					this .bbox .setExtents (min .set (0, 0, 0), max .set (0, 0, 0));
				}

				this .bbox_changed_ .addEvent ();

				// Generate texCoord if needed.

				if (this .geometryType > 1)
				{
					for (var i = 0; i < 5; ++ i)
						this .planes [i] .set (i % 2 ? min : max, boxNormals [i]);

					if (this .multiTexCoords .length === 0)
						this .multiTexCoords .push (this .buildTexCoords ());

					var last = this .multiTexCoords .length - 1;

					for (var i = this .multiTexCoords .length, length = this .getBrowser () .getMaxTextures (); i < length; ++ i)
						this .multiTexCoords [i] = this .multiTexCoords [last];

					this .multiTexCoords .length = length;
				}

				// Upload normals or flat normals.

				this .set_shading__ (this .getBrowser () .getBrowserOptions () .Shading_);

				// Upload arrays.

				this .transfer ();
			};
		})(),
		clear: function ()
		{
			// BBox

			this .min .set (Number .POSITIVE_INFINITY, Number .POSITIVE_INFINITY, Number .POSITIVE_INFINITY);
			this .max .set (Number .NEGATIVE_INFINITY, Number .NEGATIVE_INFINITY, Number .NEGATIVE_INFINITY);

			// Create attrib arrays.

			var attribs = this .attribs;

			for (var a = 0, length = attribs .length; a < length; ++ a)
				attribs [a] .length = 0;

			for (var a = attribs .length, length = this .attribNodes .length; a < length; ++ a)
				attribs [a] = X3DGeometryNode .createArray ();

			attribs .length = length;

			// Buffer

			this .flatShading = undefined;

			this .fogDepths      .length = 0;
			this .colors         .length = 0;
			this .multiTexCoords .length = 0;
			this .texCoords      .length = 0;
			this .normals        .length = 0;
			this .flatNormals    .length = 0;
			this .vertices       .length = 0;
		},
		transfer: function ()
		{
			var
				gl    = this .getBrowser () .getContext (),
				count = this .vertices .length / 4;

			// Transfer attribs.

			for (var i = this .attribBuffers .length, length = this .attribs .length; i < length; ++ i)
				this .attribBuffers .push (gl .createBuffer ());

			for (var i = 0, length = this .attribs .length; i < length; ++ i)
			{
				gl .bindBuffer (gl .ARRAY_BUFFER, this .attribBuffers [i]);
				gl .bufferData (gl .ARRAY_BUFFER, this .attribs [i] .getValue (), gl .STATIC_DRAW);
			}

			// Transfer fog depths.

			gl .bindBuffer (gl .ARRAY_BUFFER, this .fogDepthBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, this .fogDepths .getValue (), gl .STATIC_DRAW);
			this .fogCoords = !! (this .fogDepths .length);
			// Transfer colors.

			gl .bindBuffer (gl .ARRAY_BUFFER, this .colorBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, this .colors .getValue (), gl .STATIC_DRAW);
			this .colorMaterial = !! (this .colors .length);

			// Transfer multiTexCoords.

			for (var i = this .texCoordBuffers .length, length = this .multiTexCoords .length; i < length; ++ i)
				this .texCoordBuffers .push (gl .createBuffer ());

			for (var i = 0, length = this .multiTexCoords .length; i < length; ++ i)
			{
				gl .bindBuffer (gl .ARRAY_BUFFER, this .texCoordBuffers [i]);
				gl .bufferData (gl .ARRAY_BUFFER, this .multiTexCoords [i] .getValue (), gl .STATIC_DRAW);
			}

			// Transfer vertices.

			gl .bindBuffer (gl .ARRAY_BUFFER, this .vertexBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, this .vertices .getValue (), gl .STATIC_DRAW);
			this .vertexCount = count;

			// Setup render functions.

			if (this .vertexCount)
			{
				// Use default render functions.
				delete this .depth;
				delete this .display;
				delete this .displayParticles;
			}
			else
			{
				// Use no render function.
				this .depth            = Function .prototype;
				this .display          = Function .prototype;
				this .displayParticles = Function .prototype;
			}
	  	},
		traverse: function (type, renderObject)
		{ },
		depth: function (gl, context, shaderNode)
		{
			// Setup vertex attributes.

			// Attribs in depth rendering are not supported.
			//for (var i = 0, length = attribNodes .length; i < length; ++ i)
			//	attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

			shaderNode .enableVertexAttribute (gl, this .vertexBuffer);

			//for (var i = 0, length = attribNodes .length; i < length; ++ i)
			//	attribNodes [i] .disable (gl, shaderNode);

			gl .drawArrays (this .primitiveMode, 0, this .vertexCount);
		},
		display: function (gl, context)
		{
			try
			{
				var shaderNode = context .shaderNode;

				// Setup shader.

				if (shaderNode .getValid ())
				{
					var
						attribNodes   = this .attribNodes,
						attribBuffers = this .attribBuffers;

					context .geometryType          = this .geometryType;
					context .fogCoords             = this .fogCoords;
					context .colorMaterial         = this .colorMaterial;
					context .textureCoordinateNode = this .textureCoordinateNode;

					shaderNode .enable (gl);
					shaderNode .setLocalUniforms (gl, context);

					// Setup vertex attributes.

					for (var i = 0, length = attribNodes .length; i < length; ++ i)
						attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

					if (this .fogCoords)
						shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer);

					if (this .colorMaterial)
						shaderNode .enableColorAttribute (gl, this .colorBuffer);

					shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers);
					shaderNode .enableNormalAttribute   (gl, this .normalBuffer);
					shaderNode .enableVertexAttribute   (gl, this .vertexBuffer);

					// Draw depending on wireframe, solid and transparent.

					if (shaderNode .wireframe)
					{
						// Wireframes are always solid so only one drawing call is needed.

						for (var i = 0, length = this .vertexCount; i < length; i += 3)
							gl .drawArrays (shaderNode .primitiveMode, i, 3);
					}
					else
					{
						var positiveScale = Matrix4 .prototype .determinant3 .call (context .modelViewMatrix) > 0;

						gl .frontFace (positiveScale ? this .frontFace : (this .frontFace === gl .CCW ? gl .CW : gl .CCW));

						if (context .transparent)
						{
							gl .enable (gl .CULL_FACE);

							if (!this .solid)
							{
								gl .cullFace (gl .FRONT);
								gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
							}

							gl .cullFace (gl .BACK);
							gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
						}
						else
						{
							if (this .solid)
								gl .enable (gl .CULL_FACE);
							else
								gl .disable (gl .CULL_FACE);

							gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
						}
					}

					for (var i = 0, length = attribNodes .length; i < length; ++ i)
						attribNodes [i] .disable (gl, shaderNode);

					if (this .fogCoords)
						shaderNode .disableFogDepthAttribute (gl);

					if (this .colorMaterial)
						shaderNode .disableColorAttribute (gl);

					shaderNode .disableTexCoordAttribute (gl);
					shaderNode .disableNormalAttribute   (gl);
					shaderNode .disable                  (gl);
				}
			}
			catch (error)
			{
				// Catch error from setLocalUniforms.
				console .log (error);
			}
		},
		displayParticlesDepth: function (gl, context, shaderNode, particles, numParticles)
		{
			var gl = context .browser .getContext ();

			// Attribs in depth rendering are not supported:
			//for (var i = 0, length = attribNodes .length; i < length; ++ i)
			//	attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

			shaderNode .enableVertexAttribute (gl, this .vertexBuffer);

			// Draw depending on wireframe, solid and transparent.

			var
				modelViewMatrix = context .modelViewMatrix,
				x               = modelViewMatrix [12],
				y               = modelViewMatrix [13],
				z               = modelViewMatrix [14];

			for (var p = 0; p < numParticles; ++ p)
			{
				var particle = particles [p];

				modelViewMatrix [12] = x;
				modelViewMatrix [13] = y;
				modelViewMatrix [14] = z;

				Matrix4 .prototype .translate .call (modelViewMatrix, particle .position);

				shaderNode .setParticle (gl, p, particle, modelViewMatrix, false);

				gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
			}

			//for (var i = 0, length = attribNodes .length; i < length; ++ i)
			//	attribNodes [i] .disable (gl, shaderNode);
		},
		displayParticles: function (gl, context, particles, numParticles)
		{
			try
			{
				var shaderNode = context .shaderNode;

				if (shaderNode .getValid ())
				{
					var
						attribNodes   = this .attribNodes,
						attribBuffers = this .attribBuffers;

					// Setup shader.

					context .geometryType          = this .geometryType;
					context .fogCoords             = this .fogCoords;
					context .colorMaterial         = this .colorMaterial;
					context .textureCoordinateNode = this .textureCoordinateNode;

					shaderNode .enable (gl);
					shaderNode .setLocalUniforms (gl, context);

					// Setup vertex attributes.

					for (var i = 0, length = attribNodes .length; i < length; ++ i)
						attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);

					if (this .fogCoords)
						shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer);

					if (this .colorMaterial)
						shaderNode .enableColorAttribute (gl, this .colorBuffer);

					shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers);
					shaderNode .enableNormalAttribute   (gl, this .normalBuffer);
					shaderNode .enableVertexAttribute   (gl, this .vertexBuffer);

					// Draw depending on wireframe, solid and transparent.

					var
						materialNode    = context .materialNode,
						normalMatrix    = materialNode || shaderNode .getCustom (),
						modelViewMatrix = context .modelViewMatrix,
						x               = modelViewMatrix [12],
						y               = modelViewMatrix [13],
						z               = modelViewMatrix [14];

					if (shaderNode .wireframe)
					{
						// Wireframes are always solid so only one drawing call is needed.

						for (var p = 0; p < numParticles; ++ p)
						{
							var particle = particles [p];

							modelViewMatrix [12] = x;
							modelViewMatrix [13] = y;
							modelViewMatrix [14] = z;

							Matrix4 .prototype .translate .call (modelViewMatrix, particle .position);

							shaderNode .setParticle (gl, p, particle, modelViewMatrix, normalMatrix);

							for (var i = 0, length = this .vertexCount; i < length; i += 3)
								gl .drawArrays (shaderNode .primitiveMode, i, 3);
						}
					}
					else
					{
						var positiveScale = Matrix4 .prototype .determinant3 .call (context .modelViewMatrix) > 0;

						gl .frontFace (positiveScale ? this .frontFace : (this .frontFace === gl .CCW ? gl .CW : gl .CCW));

						if (context .transparent && ! this .solid)
						{
							for (var p = 0; p < numParticles; ++ p)
							{
								var particle = particles [p];

								modelViewMatrix [12] = x;
								modelViewMatrix [13] = y;
								modelViewMatrix [14] = z;

								Matrix4 .prototype .translate .call (modelViewMatrix, particle .position);

								shaderNode .setParticle (gl, p, particle, modelViewMatrix, normalMatrix);

								gl .enable (gl .CULL_FACE);
								gl .cullFace (gl .FRONT);
								gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);

								gl .cullFace (gl .BACK);
								gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
							}
						}
						else
						{
							if (this .solid)
								gl .enable (gl .CULL_FACE);
							else
								gl .disable (gl .CULL_FACE);

							for (var p = 0; p < numParticles; ++ p)
							{
								var particle = particles [p];

								modelViewMatrix [12] = x;
								modelViewMatrix [13] = y;
								modelViewMatrix [14] = z;

								Matrix4 .prototype .translate .call (modelViewMatrix, particle .position);

								shaderNode .setParticle (gl, p, particle, modelViewMatrix, normalMatrix);

								gl .drawArrays (shaderNode .primitiveMode, 0, this .vertexCount);
							}
						}
					}

					for (var i = 0, length = attribNodes .length; i < length; ++ i)
						attribNodes [i] .disable (gl, shaderNode);

					if (this .fogCoords)
						shaderNode .disableFogDepthAttribute (gl);

					if (this .colorMaterial)
						shaderNode .disableColorAttribute (gl);

					shaderNode .disableTexCoordAttribute (gl);
					shaderNode .disableNormalAttribute   (gl);
					shaderNode .disable                  (gl);
				}
			}
			catch (error)
			{
				// Catch error from setLocalUniforms.
				console .log (error);
			}
		},
	});

	return X3DGeometryNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DComposedGeometryNode',[
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (X3DGeometryNode,
          X3DCast,
          X3DConstants,
          Vector3)
{
"use strict";

	function X3DComposedGeometryNode (executionContext)
	{
		X3DGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .X3DComposedGeometryNode);

		this .fogCoordNode = null;
		this .colorNode    = null;
		this .texCoordNode = null;
		this .normalNode   = null;
		this .coordNode    = null;
	}

	X3DComposedGeometryNode .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
	{
		constructor: X3DComposedGeometryNode,
		initialize: function ()
		{
			X3DGeometryNode .prototype .initialize .call (this);

			this .attrib_   .addInterest ("set_attrib__",   this);
			this .fogCoord_ .addInterest ("set_fogCoord__", this);
			this .color_    .addInterest ("set_color__",    this);
			this .texCoord_ .addInterest ("set_texCoord__", this);
			this .normal_   .addInterest ("set_normal__",   this);
			this .coord_    .addInterest ("set_coord__",    this);

			this .set_attrib__ ();
			this .set_fogCoord__ ();
			this .set_color__ ();
			this .set_texCoord__ ();
			this .set_normal__ ();
			this .set_coord__ ();
		},
		getFogCoord: function ()
		{
			return this .fogCoordNode;
		},
		getColor: function ()
		{
			return this .colorNode;
		},
		getTexCoord: function ()
		{
			return this .texCoordNode;
		},
		getNormal: function ()
		{
			return this .normalNode;
		},
		getCoord: function ()
		{
			return this .coordNode;
		},
		set_attrib__: function ()
		{
			var attribNodes = this .getAttrib ();

			for (var i = 0, length = attribNodes .length; i < length; ++ i)
				attribNodes [i] .removeInterest ("requestRebuild", this);

			attribNodes .length = 0;

			for (var i = 0, length = this .attrib_ .length; i < length; ++ i)
			{
				var attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, this .attrib_ [i]);

				if (attribNode)
					attribNodes .push (attribNode);
			}

			for (var i = 0; i < this .attribNodes .length; ++ i)
				attribNodes [i] .addInterest ("requestRebuild", this);
		},
		set_fogCoord__: function ()
		{
			if (this .fogCoordNode)
				this .fogCoordNode .removeInterest ("requestRebuild", this);

			this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this .fogCoord_);

			if (this .fogCoordNode)
				this .fogCoordNode .addInterest ("requestRebuild", this);
		},
		set_color__: function ()
		{
			if (this .colorNode)
			{
				this .colorNode .removeInterest ("requestRebuild", this);
				this .colorNode .transparent_ .removeInterest ("set_transparent__", this);
			}

			this .colorNode = X3DCast (X3DConstants .X3DColorNode, this .color_);

			if (this .colorNode)
			{
				this .colorNode .addInterest ("requestRebuild", this);
				this .colorNode .transparent_ .addInterest ("set_transparent__", this);

				this .set_transparent__ ();
			}
			else
				this .setTransparent (false);
		},
		set_transparent__: function ()
		{
			this .setTransparent (this .colorNode .getTransparent ());
		},
		set_texCoord__: function ()
		{
			if (this .texCoordNode)
				this .texCoordNode .removeInterest ("requestRebuild", this);

			this .texCoordNode = X3DCast (X3DConstants .X3DTextureCoordinateNode, this .texCoord_);

			if (this .texCoordNode)
				this .texCoordNode .addInterest ("requestRebuild", this);

			this .setTextureCoordinate (this .texCoordNode);
		},
		set_normal__: function ()
		{
			if (this .normalNode)
				this .normalNode .removeInterest ("requestRebuild", this);

			this .normalNode = X3DCast (X3DConstants .X3DNormalNode, this .normal_);

			if (this .normalNode)
				this .normalNode .addInterest ("requestRebuild", this);
		},
		set_coord__: function ()
		{
			if (this .coordNode)
				this .coordNode .removeInterest ("requestRebuild", this);

			this .coordNode = X3DCast (X3DConstants .X3DCoordinateNode, this .coord_);

			if (this .coordNode)
				this .coordNode .addInterest ("requestRebuild", this);
		},
		getPolygonIndex: function (index)
		{
			return index;
		},
		getTriangleIndex: function (index)
		{
			return index;
		},
		build: function (verticesPerPolygon, polygonsSize, verticesPerFace, trianglesSize)
		{
			if (! this .coordNode || this .coordNode .isEmpty ())
				return;

			// Set size to a multiple of verticesPerPolygon.

			polygonsSize  -= polygonsSize % verticesPerPolygon;
			trianglesSize -= trianglesSize % verticesPerFace;

			var
				colorPerVertex     = this .colorPerVertex_ .getValue (),
				normalPerVertex    = this .normalPerVertex_ .getValue (),
				attribNodes        = this .getAttrib (),
				numAttrib          = attribNodes .length,
				attribs            = this .getAttribs (),
				fogCoordNode       = this .getFogCoord (),
				colorNode          = this .getColor (),
				texCoordNode       = this .getTexCoord (),
				normalNode         = this .getNormal (),
				coordNode          = this .getCoord (),
				fogDepthArray      = this .getFogDepths (),
				colorArray         = this .getColors (),
				multiTexCoordArray = this .getMultiTexCoords (),
				normalArray        = this .getNormals (),
				vertexArray        = this .getVertices (),
				face               = 0;

			if (texCoordNode)
				texCoordNode .init (multiTexCoordArray);
		
			// Fill GeometryNode
		
			for (var i = 0; i < trianglesSize; ++ i)
			{
				face = Math .floor (i / verticesPerFace);

				var index = this .getPolygonIndex (this .getTriangleIndex (i));

				for (var a = 0; a < numAttrib; ++ a)
					attribNodes [a] .addValue (index, attribs [a]);

				if (fogCoordNode)
					fogCoordNode .addDepth (index, fogDepthArray);

				if (colorNode)
				{
					if (colorPerVertex)
						colorNode .addColor (index, colorArray);
					else
						colorNode .addColor (face, colorArray);
				}

				if (texCoordNode)
					texCoordNode .addTexCoord (index, multiTexCoordArray);
	
				if (normalNode)
				{
					if (normalPerVertex)
						normalNode .addVector (index, normalArray);

					else
						normalNode .addVector (face, normalArray);
				}

				coordNode .addPoint (index, vertexArray);
			}
		
			// Autogenerate normal if not specified.

			if (! this .getNormal ())
				this .buildNormals (verticesPerPolygon, polygonsSize, trianglesSize);

			this .setSolid (this .solid_ .getValue ());
			this .setCCW (this .ccw_ .getValue ());
		},
		buildNormals: function (verticesPerPolygon, polygonsSize, trianglesSize)
		{
			var
				normals     = this .createNormals (verticesPerPolygon, polygonsSize),
				normalArray = this .getNormals ();

			for (var i = 0; i < trianglesSize; ++ i)
			{
				var normal = normals [this .getTriangleIndex (i)];

				normalArray .push (normal .x, normal .y, normal .z);
			}
		},
		createNormals: function (verticesPerPolygon, polygonsSize)
		{
			var normals = this .createFaceNormals (verticesPerPolygon, polygonsSize);
		
			if (this .normalPerVertex_ .getValue ())
			{
				var normalIndex = [ ];
		
				for (var i = 0; i < polygonsSize; ++ i)
				{
					var
						index      = this .getPolygonIndex (i),
						pointIndex = normalIndex [index];

					if (! pointIndex)
						pointIndex = normalIndex [index] = [ ];

					pointIndex .push (i);
				}

				return this .refineNormals (normalIndex, normals, Math .PI);
			}
		
			return normals;
		},
		createFaceNormals: function (verticesPerPolygon, polygonsSize)
		{
			var
				cw      = ! this .ccw_ .getValue (),
				coord   = this .coordNode,
				normals = [ ];

			for (var i = 0; i < polygonsSize; i += verticesPerPolygon)
			{
				var normal = this .getPolygonNormal (i, verticesPerPolygon, coord);

				if (cw)
					normal .negate ();

				for (var n = 0; n < verticesPerPolygon; ++ n)
					normals .push (normal);
			}

			return normals;
		},
		getPolygonNormal: (function ()
		{
			var
				current = new Vector3 (0, 0, 0),
				next    = new Vector3 (0, 0, 0);

			return function (index, verticesPerPolygon, coord)
			{
				// Determine polygon normal.
				// We use Newell's method https://www.opengl.org/wiki/Calculating_a_Surface_Normal here:
	
				var normal = new Vector3 (0, 0, 0);

				coord .get1Point (this .getPolygonIndex (index), next);

				for (var i = 0; i < verticesPerPolygon; ++ i)
				{
					var tmp = current;
					current = next;
					next    = tmp;

					coord .get1Point (this .getPolygonIndex (index + (i + 1) % verticesPerPolygon), next);

					normal .x += (current .y - next .y) * (current .z + next .z);
					normal .y += (current .z - next .z) * (current .x + next .x);
					normal .z += (current .x - next .x) * (current .y + next .y);
				}

				return normal .normalize ();
			};
		})(),
	});

	return X3DComposedGeometryNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/IndexedFaceSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DComposedGeometryNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Triangle3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants,
          Vector3,
          Matrix4,
          Triangle3)
{
"use strict";

	function IndexedFaceSet (executionContext)
	{
		X3DComposedGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .IndexedFaceSet);

		this .creaseAngle_ .setUnit ("angle");
	}

	IndexedFaceSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
	{
		constructor: IndexedFaceSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_colorIndex",    new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_texCoordIndex", new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_normalIndex",   new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_coordIndex",    new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",               new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "convex",            new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "creaseAngle",       new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",    new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex",   new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorIndex",        new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "texCoordIndex",     new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "normalIndex",       new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "coordIndex",        new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",            new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",             new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",            new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",             new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "IndexedFaceSet";
		},
		getComponentName: function ()
		{
			return "Geometry3D";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DComposedGeometryNode .prototype .initialize .call (this);

			this .set_colorIndex_    .addFieldInterest (this .colorIndex_);
			this .set_texCoordIndex_ .addFieldInterest (this .texCoordIndex_);
			this .set_normalIndex_   .addFieldInterest (this .normalIndex_);
			this .set_coordIndex_    .addFieldInterest (this .coordIndex_);
		},
		getTexCoordPerVertexIndex: function (index)
		{
			if (index < this .texCoordIndex_ .length)
				return this .texCoordIndex_ [index];

			return this .coordIndex_ [index];
		},
		getColorPerVertexIndex: function (index)
		{
			if (index < this .colorIndex_ .length)
				return this .colorIndex_ [index];

			return this .coordIndex_ [index];
		},
		getColorIndex: function (index)
		{
			if (index < this .colorIndex_ .length)
				return this .colorIndex_ [index];

			return index;
		},
		getNormalPerVertexIndex: function (index)
		{
			if (index < this .normalIndex_ .length)
				return this .normalIndex_ [index];

			return this .coordIndex_ [index];
		},
		getNormalIndex: function (index)
		{
			if (index < this .normalIndex_ .length)
				return this .normalIndex_ [index];

			return index;
		},
		build: function ()
		{
			// Triangulate

			var polygons = this .triangulate ();

			// Build arrays

			if (polygons .length === 0)
				return;

			// Fill GeometryNode

			var
				colorPerVertex     = this .colorPerVertex_ .getValue (),
				normalPerVertex    = this .normalPerVertex_ .getValue (),
				coordIndex         = this .coordIndex_ .getValue (),
				attribNodes        = this .getAttrib (),
				numAttrib          = attribNodes .length,
				attribs            = this .getAttribs (),
				fogCoordNode       = this .getFogCoord (),
				colorNode          = this .getColor (),
				texCoordNode       = this .getTexCoord (),
				normalNode         = this .getNormal (),
				coordNode          = this .getCoord (),
				fogDepthArray      = this .getFogDepths (),
				colorArray         = this .getColors (),
				multiTexCoordArray = this .getMultiTexCoords (),
				normalArray        = this .getNormals (),
				vertexArray        = this .getVertices ();

			if (texCoordNode)
				texCoordNode .init (multiTexCoordArray);

			for (var p = 0, numPolygons = polygons .length; p < numPolygons; ++ p)
			{
				var
					polygon   = polygons [p],
					triangles = polygon .triangles,
					face      = polygon .face;

				for (var v = 0, numVertices = triangles .length; v < numVertices; ++ v)
				{
					var
						i     = triangles [v],
						index = coordIndex [i];

					for (var a = 0; a < numAttrib; ++ a)
						attribNodes [a] .addValue (index, attribs [a]);

					if (fogCoordNode)
						fogCoordNode .addDepth (index, fogDepthArray);

					if (colorNode)
					{
						if (colorPerVertex)
							colorNode .addColor (this .getColorPerVertexIndex (i), colorArray);
						else
							colorNode .addColor (this .getColorIndex (face), colorArray);
					}

					if (texCoordNode)
						texCoordNode .addTexCoord (this .getTexCoordPerVertexIndex (i), multiTexCoordArray);

					if (normalNode)
					{
						if (normalPerVertex)
							normalNode .addVector (this .getNormalPerVertexIndex (i), normalArray);

						else
							normalNode .addVector (this .getNormalIndex (face), normalArray);
					}

					coordNode .addPoint (index, vertexArray);
				}

				++ face;
			}

			// Autogenerate normal if not specified.

			if (! this .getNormal ())
				this .buildNormals (polygons);

			this .setSolid (this .solid_ .getValue ());
			this .setCCW (this .ccw_ .getValue ());
		},
		triangulate: function ()
		{
			var
				convex      = this .convex_ .getValue (),
				coordLength = this .coordIndex_ .length,
				polygons    = [ ];

			if (! this .getCoord ())
				return polygons;

			if (coordLength)
			{
				// Add -1 (polygon end marker) to coordIndex if not present.
				if (this .coordIndex_ [coordLength - 1] > -1)
					this .coordIndex_ .push (-1);

				var
					coordIndex  = this .coordIndex_ .getValue (),
					coordLength = this .coordIndex_ .length;

				// Construct triangle array and determine the number of used points.
				var
					vertices = [ ],
					face     = 0;

				for (var i = 0; i < coordLength; ++ i)
				{
					var index = coordIndex [i];

					if (index > -1)
					{
						// Add vertex index.
						vertices .push (i);
					}
					else
					{
						// Negativ index.

						if (vertices .length)
						{
							// Closed polygon.
							//if (coordIndex [vertices [0]] === coordIndex [vertices [vertices .length - 1]])
							//	vertices .pop ();

							switch (vertices .length)
							{
								case 0:
								case 1:
								case 2:
								{
									vertices .length = 0;
									break;
								}
								case 3:
								{
									// Add polygon with one triangle.
									polygons .push ({ vertices: vertices, triangles: vertices, face: face });
									vertices = [ ];
									break;
								}
								default:
								{
									// Triangulate polygons.
									var
										triangles = [ ],
										polygon   = { vertices: vertices, triangles: triangles, face: face };

									if (convex)
										this .triangulateConvexPolygon (vertices, triangles);
									else
										this .triangulatePolygon (vertices, triangles);

									if (triangles .length < 3)
									{
										vertices .length = 0;
									}
									else
									{
										polygons .push (polygon);
										vertices = [ ];
									}

									break;
								}
							}
						}

						++ face;
					}
				}
			}

			return polygons;
		},
		triangulatePolygon: (function ()
		{
			var polygon = [ ];

			return function (vertices, triangles)
			{
				var
					coordIndex = this .coordIndex_ .getValue (),
					coord      = this .getCoord ();

				for (var v = 0, length = vertices .length; v < length; ++ v)
				{
					var
						vertex = polygon [v],
						i      = vertices [v];

					if (! vertex)
						vertex = polygon [v] = new Vector3 (0, 0, 0);

					vertex .index = i;

					coord .get1Point (coordIndex [i], vertex);
				}

				polygon .length = length;

				Triangle3 .triangulatePolygon (polygon, triangles);

				for (var i = 0, length = triangles .length; i < length; ++ i)
					triangles [i] = triangles [i] .index;
			};
		})(),
		triangulateConvexPolygon: function (vertices, triangles)
		{
			// Fallback: Very simple triangulation for convex polygons.
			for (var i = 1, length = vertices .length - 1; i < length; ++ i)
				triangles .push (vertices [0], vertices [i], vertices [i + 1]);
		},
		buildNormals: function (polygons)
		{
			var
				normals     = this .createNormals (polygons),
				normalArray = this .getNormals ();

			for (var p = 0, pl = polygons .length; p < pl; ++ p)
			{
				var triangles = polygons [p] .triangles;

				for (var v = 0, tl = triangles .length; v < tl; ++ v)
				{
					var normal = normals [triangles [v]];

					normalArray .push (normal .x, normal .y, normal .z);
				}
			}
		},
		createNormals: (function ()
		{
			var
				normals     = [ ],
				normalIndex = [ ];

			return function (polygons)
			{
				var
					cw          = ! this .ccw_ .getValue (),
					coordIndex  = this .coordIndex_ .getValue (),
					coord       = this .getCoord (),
					normal      = null;

				normals     .length = 0;
				normalIndex .length = 0;

				for (var p = 0, pl = polygons .length; p < pl; ++ p)
				{
					var
						polygon  = polygons [p],
						vertices = polygon .vertices,
						length   = vertices .length;

					switch (length)
					{
						case 3:
						{
							normal = coord .getNormal (coordIndex [vertices [0]],
							                           coordIndex [vertices [1]],
							                           coordIndex [vertices [2]]);
							break;
						}
						case 4:
						{
							normal = coord .getQuadNormal (coordIndex [vertices [0]],
							                               coordIndex [vertices [1]],
							                               coordIndex [vertices [2]],
							                               coordIndex [vertices [3]]);
							break;
						}
						default:
						{
							normal = this .getPolygonNormal (vertices, coordIndex, coord);
							break;
						}
					}

					// Add a normal index for each point.

					for (var i = 0; i < length; ++ i)
					{
						var
							index        = vertices [i],
							point        = coordIndex [index],
							pointNormals = normalIndex [point];

						if (! pointNormals)
							pointNormals = normalIndex [point] = [ ];

						pointNormals .push (index);
					}

					if (cw)
						normal .negate ();

					// Add this normal for each vertex.

					for (var i = 0; i < length; ++ i)
						normals [vertices [i]] = normal;
				}

				return this .refineNormals (normalIndex, normals, this .creaseAngle_ .getValue ());
			};
		})(),
		getPolygonNormal: (function ()
		{
			var
				current = new Vector3 (0, 0, 0),
				next    = new Vector3 (0, 0, 0);

			return function (vertices, coordIndex, coord)
			{
				// Determine polygon normal.
				// We use Newell's method https://www.opengl.org/wiki/Calculating_a_Surface_Normal here:

				var normal = new Vector3 (0, 0, 0);

				coord .get1Point (coordIndex [vertices [0]], next);

				for (var i = 0, length = vertices .length; i < length; ++ i)
				{
					var tmp = current;
					current = next;
					next    = tmp;

					coord .get1Point (coordIndex [vertices [(i + 1) % length]], next);

					normal .x += (current .y - next .y) * (current .z + next .z);
					normal .y += (current .z - next .z) * (current .x + next .x);
					normal .z += (current .x - next .x) * (current .y + next .y);
				}

				return normal .normalize ();
			};
		})(),
	});

	return IndexedFaceSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DGeometricPropertyNode',[
	"x_ite/Components/Core/X3DNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DNode, 
          X3DConstants)
{
"use strict";

	function X3DGeometricPropertyNode (executionContext)
	{
		X3DNode .call (this, executionContext);

		this .addType (X3DConstants .X3DGeometricPropertyNode);
	}

	X3DGeometricPropertyNode .prototype = Object .assign (Object .create (X3DNode .prototype),
	{
		constructor: X3DGeometricPropertyNode,
	});

	return X3DGeometricPropertyNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DCoordinateNode',[
	"x_ite/Components/Rendering/X3DGeometricPropertyNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Triangle3",
	"standard/Math/Numbers/Vector3",
],
function (X3DGeometricPropertyNode, 
          X3DConstants,
          Triangle3,
          Vector3)
{
"use strict";

	function X3DCoordinateNode (executionContext)
	{
		X3DGeometricPropertyNode .call (this, executionContext);

		this .addType (X3DConstants .X3DCoordinateNode);
	}

	X3DCoordinateNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
	{
		constructor: X3DCoordinateNode,
		initialize: function ()
		{
			X3DGeometricPropertyNode .prototype .initialize .call (this);

			this .point_ .addInterest ("set_point__", this);

			this .set_point__ ();
		},
		set_point__: function ()
		{
			this .point  = this .point_ .getValue ();
			this .length = this .point_ .length;
		},
		isEmpty: function ()
		{
			return this .length === 0;
		},
		getSize: function ()
		{
			return this .length;
		},
		set1Point: function (index, point)
		{
			this .point_ [index] = point;
		},
		get1Point: function (index, result)
		{
			if (index < this .length)
			{
				const point = this .point;

				index *= 3;

				return result .set (point [index], point [index + 1], point [index + 2]);
			}
			else
			{
				return result .set (0, 0, 0);
			}
		},
		addPoint: function (index, array)
		{
			if (index < this .length)
			{
				const point = this .point;

				index *= 3;

				array .push (point [index], point [index + 1], point [index + 2], 1);
			}
			else
			{
				array .push (0, 0, 0, 1);
			}
		},
		addPoints: function (array, min)
		{
			const point = this .point;

			for (var index = 0, length = this .length * 3; index < length; index += 3)
				array .push (point [index], point [index + 1], point [index + 2], 1);

			for (var index = length, length = min * 3; index < length; index += 3)
				array .push (0, 0, 0, 1);
		},
		getNormal: (function ()
		{
			var
				point1 = new Vector3 (0, 0, 0),
				point2 = new Vector3 (0, 0, 0),
				point3 = new Vector3 (0, 0, 0);

			return function (index1, index2, index3)
			{
				// The index[1,2,3] cannot be less than 0.
	
				var length = this .length;
	
				if (index1 < length && index2 < length && index3 < length)
				{
					return Triangle3 .normal (this .get1Point (index1, point1),
					                          this .get1Point (index2, point2),
					                          this .get1Point (index3, point3),
					                          new Vector3 (0, 0, 0));
				}
	
				return new Vector3 (0, 0, 0);
			};
		})(),
		getQuadNormal: (function ()
		{
			var
				point1 = new Vector3 (0, 0, 0),
				point2 = new Vector3 (0, 0, 0),
				point3 = new Vector3 (0, 0, 0),
				point4 = new Vector3 (0, 0, 0);

			return function (index1, index2, index3, index4)
			{
				// The index[1,2,3,4] cannot be less than 0.
	
				var length = this .length;
	
				if (index1 < length && index2 < length && index3 < length && index4 < length)
				{
					return Triangle3 .quadNormal (this .get1Point (index1, point1),
					                              this .get1Point (index2, point2),
					                              this .get1Point (index3, point3),
					                              this .get1Point (index4, point4),
					                              new Vector3 (0, 0, 0));
				}
	
				return new Vector3 (0, 0, 0);
			};
		})(),
	});

	return X3DCoordinateNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/Coordinate',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DCoordinateNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DCoordinateNode, 
          X3DConstants)
{
"use strict";

	function Coordinate (executionContext)
	{
		X3DCoordinateNode .call (this, executionContext);

		this .addType (X3DConstants .Coordinate);

		this .point_ .setUnit ("length");
	}

	Coordinate .prototype = Object .assign (Object .create (X3DCoordinateNode .prototype),
	{
		constructor: Coordinate,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "point",    new Fields .MFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "Coordinate";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "coord";
		},
	});

	return Coordinate;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/X3DTextureCoordinateNode',[
	"x_ite/Fields",
	"x_ite/Components/Rendering/X3DGeometricPropertyNode",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DGeometricPropertyNode, 
          X3DGeometryNode, 
          X3DConstants)
{
"use strict";

	function X3DTextureCoordinateNode (executionContext)
	{
		X3DGeometricPropertyNode .call (this, executionContext);

		this .addType (X3DConstants .X3DTextureCoordinateNode);

		this .texCoordArray = X3DGeometryNode .createArray ();
	}

	X3DTextureCoordinateNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
	{
		constructor: X3DTextureCoordinateNode,
		init: function (multiArray)
		{
			this .texCoordArray .length = 0;

			multiArray .push (this .texCoordArray);
		},
		addTexCoord: function (index, multiArray)
		{
			this .addTexCoordToChannel (index, multiArray [0]);
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			for (var i = 0, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
				this .setShaderUniformsToChannel (gl, shaderObject, i);
		},
		setShaderUniformsToChannel: function (gl, shaderObject, i)
		{
			gl .uniform1i (shaderObject .x3d_TextureCoordinateGeneratorMode [i], 0);
		},
	});

	return X3DTextureCoordinateNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/TextureCoordinate',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Texturing/X3DTextureCoordinateNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTextureCoordinateNode,
          X3DConstants,
          Vector4)
{
"use strict";

	function TextureCoordinate (executionContext)
	{
		X3DTextureCoordinateNode .call (this, executionContext);

		this .addType (X3DConstants .TextureCoordinate);
	}

	TextureCoordinate .prototype = Object .assign (Object .create (X3DTextureCoordinateNode .prototype),
	{
		constructor: TextureCoordinate,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "point",    new Fields .MFVec2f ()),
		]),
		getTypeName: function ()
		{
			return "TextureCoordinate";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "texCoord";
		},
		initialize: function ()
		{
			X3DTextureCoordinateNode .prototype .initialize .call (this);

			this .point_ .addInterest ("set_point__", this);

			this .set_point__ ();
		},
		set_point__: function ()
		{
			this .point  = this .point_ .getValue ();
			this .length = this .point_ .length;
		},
		isEmpty: function ()
		{
			return this .length === 0;
		},
		getSize: function ()
		{
			return this .length;
		},
		get1Point: function (index, vector)
		{
			if (index >= 0 && index < this .length)
			{
				const point = this .point;

				index *= 2;

				return vector .set (point [index], point [index + 1], 0, 1);
			}
			else if (index >= 0 && this .length)
			{
				const point = this .point;

				index %= this .length;
				index *= 2;

				return vector .set (point [index], point [index + 1], 0, 1);
			}
			else
			{
				return vector .set (0, 0, 0, 1);
			}
		},
		addTexCoordToChannel: function (index, array)
		{
			if (index >= 0 && index < this .length)
			{
				var point = this .point;

				index *= 2;

				array .push (point [index], point [index + 1], 0, 1);
			}
			else if (index >= 0 && this .length)
			{
				var point = this .point;

				index %= this .length;
				index *= 2;

				array .push (point [index], point [index + 1], 0, 1);
			}
			else
			{
				array .push (0, 0, 0, 1);
			}
		},
		getTexCoord: function (array)
		{
			var point = this .point_;

			for (var i = 0, length = point .length; i < length; ++ i)
			{
				var p = point [i];

				array [i] = new Vector4 (p .x, p .y, 0, 1);
			}

			array .length = length;

			return array;
		},
	});

	return TextureCoordinate;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/BoxOptions',[
	"x_ite/Fields",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Components/Geometry3D/IndexedFaceSet",
	"x_ite/Components/Rendering/Coordinate",
	"x_ite/Components/Texturing/TextureCoordinate",
],
function (Fields,
          X3DBaseNode,
          IndexedFaceSet,
          Coordinate,
          TextureCoordinate)
{
"use strict";
	
	function BoxOptions (executionContext)
	{
		X3DBaseNode .call (this, executionContext);
	}

	BoxOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: BoxOptions,
		getTypeName: function ()
		{
			return "BoxOptions";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "boxOptions";
		},
		initialize: function ()
		{
			X3DBaseNode .prototype .initialize .call (this);
		},
		getGeometry: function ()
		{
			if (this .geometry)
				return this .geometry;

			this .geometry            = new IndexedFaceSet (this .getExecutionContext ());
			this .geometry .texCoord_ = new TextureCoordinate (this .getExecutionContext ());
			this .geometry .coord_    = new Coordinate (this .getExecutionContext ());

			var
				geometry = this .geometry,
				texCoord = this .geometry .texCoord_ .getValue (),
				coord    = this .geometry .coord_ .getValue ();

			geometry .texCoordIndex_ = new Fields .MFInt32 (
				0, 1, 2, 3, -1, // front
				0, 1, 2, 3, -1, // back
				0, 1, 2, 3, -1, // left
				0, 1, 2, 3, -1, // right
				0, 1, 2, 3, -1, // top
				0, 1, 2, 3, -1  // bottom
			);

			geometry .coordIndex_ = new Fields .MFInt32 (
				0, 1, 2, 3, -1, // front
				5, 4, 7, 6, -1, // back
				1, 5, 6, 2, -1, // left
				4, 0, 3, 7, -1, // right
				4, 5, 1, 0, -1, // top
				3, 2, 6, 7, -1  // bottom
			);

			texCoord .point_ = new Fields .MFVec2f (
				new Fields .SFVec2f (1, 1), new Fields .SFVec2f (0, 1), new Fields .SFVec2f (0, 0), new Fields .SFVec2f (1, 0)
			);

			coord .point_ = new Fields .MFVec3f (
				new Fields .SFVec3f ( 1,  1,  1), new Fields .SFVec3f (-1,  1,  1), new Fields .SFVec3f (-1, -1,  1), new Fields .SFVec3f ( 1, -1,  1), 
				new Fields .SFVec3f ( 1,  1, -1), new Fields .SFVec3f (-1,  1, -1), new Fields .SFVec3f (-1, -1, -1), new Fields .SFVec3f ( 1, -1, -1)
			);

			texCoord .setup ();
			coord    .setup ();
			geometry .setup ();

			return this .geometry;
		},
	});

	return BoxOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/ConeOptions',[
	"x_ite/Fields",
	"x_ite/Basic/X3DBaseNode",
],
function (Fields,
          X3DBaseNode)
{
"use strict";
	
	function ConeOptions (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .addChildObjects ("xDimension", new Fields .SFInt32 (20),
		                       "yDimension", new Fields .SFInt32 (1))
	}

	ConeOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: ConeOptions,
		getTypeName: function ()
		{
			return "ConeOptions";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "coneOptions";
		},
	});

	return ConeOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/CylinderOptions',[
	"x_ite/Fields",
	"x_ite/Basic/X3DBaseNode",
],
function (Fields,
          X3DBaseNode)
{
"use strict";
	
	function CylinderOptions (executionContext)
	{
		X3DBaseNode .call (this, executionContext);
			
		this .addChildObjects ("xDimension", new Fields .SFInt32 (20),
		                       "yDimension", new Fields .SFInt32 (1))
	}

	CylinderOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: CylinderOptions,
		getTypeName: function ()
		{
			return "CylinderOptions";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "cylinderOptions";
		},
	});

	return CylinderOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Numbers/Complex',[],function ()
{
"use strict";

	function Complex (real, imag)
	{
		this .real = real
		this .imag = imag;
	}

	Complex .prototype =
	{
		constructor: Complex,
		copy: function ()
		{
			var copy = Object .create (Complex .prototype);
			copy .real = this .real;
			copy .imag = this .imag;
			return copy;
		},
		assign: function (complex)
		{
			this .real = complex .real;
			this .imag = complex .imag;
			return this;
		},
		equals: function (complex)
		{
			return this .real === complex .real &&
			       this .imag === complex .imag;
		},
		setRadius: function (radius)
		{
			return this .setPolar (radius, this .getAngle ());
		},
		getRadius: function ()
		{
			if (this .real)
			{
				if (this .imag)
					return Math .sqrt (this .real * this .real + this .imag * this .imag);

				return Math .abs (this .real);
			}

			return Math .abs (this .imag);
		},
		setAngle: function (angle)
		{
			return this .setPolar (this .getRadius (), angle);
		},
		getAngle: function ()
		{
			return Math .atan2 (this .imag, this .real);
		},
		setPolar: function (radius, angle)
		{
			this .real = radius * Math .cos (angle);
			this .imag = radius * Math .sin (angle);
			return this;
		},
		conjugate: function ()
		{
			this .imag = -this .imag;
			return this;
		},
		negate: function ()
		{
			this .real = -this .real;
			this .imag = -this .imag;
			return this;
		},
		inverse: function ()
		{
			var d = this .real * this .real + this .imag * this .imag;

			this .real /=  d;
			this .imag /= -d;
			return this;
		},
		add: function (value)
		{
			this .real += value .real;
			this .imag += value .imag;
			return this;
		},
		subtract: function (value)
		{
			this .real -= value .real;
			this .imag -= value .imag;
			return this;
		},
		multiply: function (value)
		{
			this .real *= value;
			this .imag *= value;
			return this;
		},
		multComp: function ()
		{
			var
				real = this .real, imag = this .imag;

			this .real = real * value .real - imag * value .imag;
			this .imag = real * value .imag + imag * value .real;
			return this;
		},
		//divide: function (value)
		//{
		//	return this;
		//},
		divComp: function (value)
		{
			var
				ar = this .real, ai = this .imag,
				br = value .real, bi = value .imag;

			var d = br * br + bi * bi;

			this .real = (ar * br + ai * bi) / d;
			this .imag = (ai * br - ar * bi) / d;
			return this;
		},
		toString: function ()
		{
			if (this .imag)
				return this .real + " " + this .imag + "i";

			return "" + this .real;
		},
	};

	Object .assign (Complex,
	{
		Polar: function (radius, angle)
		{
			var complex = Object .create (Complex .prototype);
			complex .real = radius * Math .cos (angle);
			complex .imag = radius * Math .sin (angle);
			return complex;
		},
		multiply: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .real = lhs .real * rhs;
			copy .imag = lhs .imag * rhs;
			return copy;
		},
		multComp: function (lhs, rhs)
		{
			var copy = Object .create (this .prototype);
			copy .real = lhs .real * rhs .real - lsh .imag * rhs .imag;
			copy .imag = lhs .real * rhs .imag + lsh .imag * rhs .real;
			return copy;
		},
	});

	return Complex;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/QuadSphereOptions',[
	"x_ite/Fields",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Components/Geometry3D/IndexedFaceSet",
	"x_ite/Components/Rendering/Coordinate",
	"x_ite/Components/Texturing/TextureCoordinate",
	"standard/Math/Numbers/Complex",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DBaseNode,
          IndexedFaceSet,
          Coordinate,
          TextureCoordinate,
          Complex,
          Vector2,
          Vector3)
{
"use strict";
	
	function QuadSphereOptions (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .addChildObjects ("xDimension", new Fields .SFInt32 (32),
		                       "yDimension", new Fields .SFInt32 (15))
	}

	QuadSphereOptions .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: QuadSphereOptions,
		getTypeName: function ()
		{
			return "QuadSphereOptions";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "quadSphereOptions";
		},
		initialize: function ()
		{
			X3DBaseNode .prototype .initialize .call (this);

			this .addInterest ("eventsProcessed", this);
		},
		getGeometry: function ()
		{
			if (! this .geometry)
				this .eventsProcessed ();
			
			return this .geometry;
		},
		createTexCoordIndex: function ()
		{
			var
				xDimension    = this .xDimension_ .getValue () + 1,
				yDimension    = this .yDimension_ .getValue (),
				texCoordIndex = this .geometry .texCoordIndex_;

			// North pole
			
			for (var u = 0, uLength = xDimension - 1; u < uLength; ++ u)
			{
				texCoordIndex .push (u);
				texCoordIndex .push (u + xDimension - 1);
				texCoordIndex .push (u + xDimension);
				texCoordIndex .push (-1);
			}

			// Sphere segments
			
			for (var p = xDimension - 1, v = 0, vLength = yDimension - 3; v < vLength; ++ v, ++ p)
			{
				for (var u = 0, uLength = xDimension - 1; u < uLength; ++ u, ++ p)
				{
					texCoordIndex .push (p);
					texCoordIndex .push (p + xDimension);
					texCoordIndex .push (p + xDimension + 1);
					texCoordIndex .push (p + 1);
					texCoordIndex .push (-1);
				}
			}
			
			// South pole

			var p = (yDimension - 2) * xDimension - 1;

			for (var u = 0, uLength = xDimension - 1; u < uLength; ++ u, ++ p)
			{
				texCoordIndex .push (p + xDimension);
				texCoordIndex .push (p + 1);
				texCoordIndex .push (p);
				texCoordIndex .push (-1);
			}
		},
		createTexCoord: function ()
		{
			var
				xDimension = this .xDimension_ .getValue () + 1,
				yDimension = this .yDimension_ .getValue (),
				point      = this .geometry .texCoord_ .getValue () .point_;

				var poleOffset = -0.5 / (xDimension - 1);

				// North pole
				
				for (var u = 1; u < xDimension; ++ u)
				{
					var x = u / (xDimension - 1) + poleOffset;
					
					point .push (new Vector2 (x, 1));
				}

				// Sphere segments
				
				for (var v = 1, vLength = yDimension - 1; v < vLength; ++ v)
				{
					var y = 1 - v / (yDimension - 1);
					
					for (var u = 0; u < xDimension; ++ u)
					{
						var x = u / (xDimension - 1);
						
						point .push (new Vector2 (x, y));
					}
				}

				// South pole
				
				for (var u = 1; u < xDimension; ++ u)
				{
					var x = u / (xDimension - 1) + poleOffset;
					
					point .push (new Vector2 (x, 0));
				}
		},
		createCoordIndex: function ()
		{
			var
				xDimension = this .xDimension_ .getValue () + 1,
				yDimension = this .yDimension_ .getValue (),
				coordIndex = this .geometry .coordIndex_;

			// North pole
			
			for (var u = 1, uLength = xDimension - 1; u < uLength; ++ u)
			{
				coordIndex .push (0);
				coordIndex .push (u);
				coordIndex .push (u + 1);
				coordIndex .push (-1);
			}

			coordIndex .push (0);
			coordIndex .push (u);
			coordIndex .push (1);
			coordIndex .push (-1);

			// Sphere segments
			
			var p = 1;

			for (var v = 0, vLength = yDimension - 3; v < vLength; ++ v, ++ p)
			{
				for (var u = 0, uLength = xDimension - 2; u < uLength; ++ u, ++ p)
				{
					coordIndex .push (p);
					coordIndex .push (p + xDimension - 1);
					coordIndex .push (p + xDimension);
					coordIndex .push (p + 1);
					coordIndex .push (-1);
				}

				coordIndex .push (p);
				coordIndex .push (p + xDimension - 1);
				coordIndex .push (p + 1);
				coordIndex .push (p - xDimension + 2);
				coordIndex .push (-1);
			}

			// South pole
			
			var last = p + xDimension - 1;

			for (var u = 0, uLength = xDimension - 2; u < uLength; ++ u, ++ p)
			{
				coordIndex .push (last);
				coordIndex .push (p + 1);
				coordIndex .push (p);
				coordIndex .push (-1);
			}

			coordIndex .push (last);
			coordIndex .push (last - xDimension + 1);
			coordIndex .push (p);
			coordIndex .push (-1);
		},
		createPoints: function ()
		{
			var
				xDimension = this .xDimension_ .getValue () + 1,
				yDimension = this .yDimension_ .getValue (),
				point      = this .geometry .coord_ .getValue () .point_;

			// North pole
			point .push (new Vector3 (0, 1, 0));

			// Sphere segments
			for (var v = 1, vLength = yDimension - 1; v < vLength; ++ v)
			{
				var zPlane = Complex .Polar (1, -Math .PI * v / vLength);

				for (var u = 0, uLength = xDimension - 1; u < uLength; ++ u)
				{
					var yPlane = Complex .Polar (zPlane .imag, 2 * Math .PI * u / uLength);

					point .push (new Vector3 (yPlane .imag, zPlane .real, yPlane .real));
				}
			}

			// South pole
			point .push (new Vector3 (0, -1, 0));
		},
		eventsProcessed: function ()
		{
			this .geometry            = new IndexedFaceSet (this .getExecutionContext ());
			this .geometry .texCoord_ = new TextureCoordinate (this .getExecutionContext ());
			this .geometry .coord_    = new Coordinate (this .getExecutionContext ());

			this .createTexCoordIndex ();
			this .createTexCoord ();
			this .createCoordIndex ();
			this .createPoints ();

			var
				geometry = this .geometry,
				texCoord = this .geometry .texCoord_ .getValue (),
				coord    = this .geometry .coord_ .getValue ();

			geometry .creaseAngle_ = Math .PI;

			texCoord .setup ();
			coord    .setup ();
			geometry .setup ();
		},
	});

	return QuadSphereOptions;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Geometry3D/X3DGeometry3DContext',[
	"x_ite/Browser/Geometry3D/BoxOptions",
	"x_ite/Browser/Geometry3D/ConeOptions",
	"x_ite/Browser/Geometry3D/CylinderOptions",
	"x_ite/Browser/Geometry3D/QuadSphereOptions",
],
function (BoxOptions,
          ConeOptions,
          CylinderOptions,
          QuadSphereOptions)
{
"use strict";
	
	function getOptionNode (name, Type)
	{
		if (this [name])
			return this [name];

		this [name] = new Type (this .getPrivateScene ());
		this [name] .setup ();

		return this [name];
	}

	function X3DGeometry3DContext () { }

	X3DGeometry3DContext .prototype =
	{
		initialize: function ()
		{ },
		getBoxOptions: function ()
		{
			return getOptionNode .call (this, "boxOptions", BoxOptions);
		},
		getConeOptions: function ()
		{
			return getOptionNode .call (this, "coneOptions", ConeOptions);
		},
		getCylinderOptions: function ()
		{
			return getOptionNode .call (this, "cylinderOptions", CylinderOptions);
		},
		getSphereOptions: function ()
		{
			return getOptionNode .call (this, "sphereOptions", QuadSphereOptions);
		},
	};

	return X3DGeometry3DContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/PointingDeviceSensor/PointingDevice',[
	"jquery",
	"x_ite/Basic/X3DBaseNode",
],
function ($,
          X3DBaseNode)
{
"use strict";

	function PointingDevice (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .cursor     = "DEFAULT";
		this .isOver     = false;
		this .motionTime = 0;
	}

	PointingDevice .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: PointingDevice,
		getTypeName: function ()
		{
			return "PointingDevice";
		},
		initialize: function ()
		{
			var element = this .getBrowser () .getElement ();

			//element .bind ("mousewheel.PointingDevice", this .mousewheel .bind (this));
			element .bind ("mousedown.PointingDevice" + this .getId (), this .mousedown  .bind (this));
			element .bind ("mouseup.PointingDevice"   + this .getId (), this .mouseup    .bind (this));
			element .bind ("dblclick.PointingDevice"  + this .getId (), this .dblclick   .bind (this));
			element .bind ("mousemove.PointingDevice" + this .getId (), this .mousemove  .bind (this));
			element .bind ("mouseout.PointingDevice"  + this .getId (), this .onmouseout .bind (this));

			element .bind ("touchstart.PointingDevice" + this .getId (), this .touchstart .bind (this));
			element .bind ("touchend.PointingDevice"   + this .getId (), this .touchend   .bind (this));
		},
		mousewheel: function (event)
		{
			// event .preventDefault () must be done in the several viewers.
		},
		mousedown: function (event)
		{
			var browser = this .getBrowser ();

			browser .getElement () .focus ();

			if (browser .getShiftKey () && browser .getControlKey ())
				return;

			if (event .button === 0)
			{
				var
					element = browser .getElement (),
					offset  = element .offset (),
					x       = event .pageX - offset .left,
					y       = element .height () - (event .pageY - offset .top);

				element .unbind ("mousemove.PointingDevice" + this .getId ());

				$(document) .bind ("mouseup.PointingDevice"   + this .getId (), this .mouseup   .bind (this));
				$(document) .bind ("mousemove.PointingDevice" + this .getId (), this .mousemove .bind (this));
				$(document) .bind ("touchend.PointingDevice"  + this .getId (), this .touchend  .bind (this));
				$(document) .bind ("touchmove.PointingDevice" + this .getId (), this .touchmove .bind (this));

				if (browser .buttonPressEvent (x, y))
				{
					event .preventDefault ();
					event .stopImmediatePropagation (); // Keeps the rest of the handlers from being executed

					browser .setCursor ("HAND");
					browser .finished () .addInterest ("onverifymotion", this, x, y);
				}
			}
		},
		mouseup: function (event)
		{
			event .preventDefault ();

			if (event .button === 0)
			{
				var
					browser = this .getBrowser (),
					element = browser .getElement (),
					offset  = element .offset (),
					x       = event .pageX - offset .left,
					y       = element .height () - (event .pageY - offset .top);

				$(document) .unbind (".PointingDevice"   + this .getId ());
				element .bind ("mousemove.PointingDevice" + this .getId (), this .mousemove .bind (this));

				browser .buttonReleaseEvent ();
				browser .setCursor (this .isOver ? "HAND" : "DEFAULT");
				browser .finished () .addInterest ("onverifymotion", this, x, y);
				browser .addBrowserEvent ();

				this .cursor = "DEFAULT";
			}
		},
		dblclick: function (event)
		{
			if (this .isOver)
				event .stopImmediatePropagation ();
		},
		mousemove: function (event)
		{
			event .preventDefault ();

			var browser = this .getBrowser ();

			if (this .motionTime === browser .getCurrentTime ())
				return;

			this .motionTime = browser .getCurrentTime ();

			var
				element = browser .getElement (),
				offset  = element .offset (),
				x       = event .pageX - offset .left,
				y       = element .height () - (event .pageY - offset .top);

			this .onmotion (x, y);
		},
		touchstart: function (event)
		{
			var touches = event .originalEvent .touches;

			switch (touches .length)
			{
				case 1:
				{
					// button 0.

					event .button = 0;
					event .pageX  = touches [0] .pageX;
					event .pageY  = touches [0] .pageY;

					this .mousedown (event);
					break;
				}
				case 2:
				{
					this .touchend (event);
					break;
				}
			}
		},
		touchend: function (event)
		{
			event .button = 0;
			this .mouseup (event);
		},
		touchmove: function (event)
		{
			var touches = event .originalEvent .touches;

			switch (touches .length)
			{
				case 1:
				{
					// button 0.

					event .button = 0;
					event .pageX  = touches [0] .pageX;
					event .pageY  = touches [0] .pageY;

					this .mousemove (event);
					break;
				}
			}
		},
		onmotion: function (x, y)
		{
			var browser = this .getBrowser ();

			if (browser .motionNotifyEvent (x, y))
			{
				if (! this .isOver)
				{
					this .isOver = true;
					this .cursor = browser .getCursor ();
					browser .setCursor ("HAND");
				}
			}
			else
			{
				if (this .isOver)
				{
					this .isOver = false;
					browser .setCursor (this .cursor);
				}
			}
		},
		onmouseout: function (event)
		{
			this .getBrowser () .leaveNotifyEvent ();
		},
		onverifymotion: function (value, x, y)
		{
			// Veryfy isOver state. This is neccessay if an Switch changes on buttonReleaseEvent
			// and the new child has a sensor node inside. This sensor node must be update to
			// reflect the correct isOver state.

			this .getBrowser () .finished () .removeInterest ("onverifymotion", this);

			this .onmotion (x, y);
		},
	});

	return PointingDevice;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Line3',[
	"standard/Math/Numbers/Vector3",
],
function (Vector3)
{
"use strict";

	function Line3 (point, direction)
	{
		this .point     = point     .copy ();
		this .direction = direction .copy ();
	}

	Line3 .prototype =
	{
		constructor: Line3,
		copy: function ()
		{
			var copy = Object .create (Line3 .prototype);
			copy .point     = this .point .copy ();
			copy .direction = this .direction .copy ();
			return copy;
		},
		assign: function (line)
		{
			this .point     .assign (line .point);
			this .direction .assign (line .direction);
			return this;
		},
		set: function (point, direction)
		{
			this .point     .assign (point);
			this .direction .assign (direction);
			return this;
		},
		setPoints: function (point1, point2)
		{
			this .point .assign (point1);
			this .direction .assign (point2) .subtract (point1) .normalize ();
			return this;
		},
		multMatrixLine: function (matrix)
		{
			matrix .multMatrixVec (this .point);
			matrix .multMatrixDir (this .direction) .normalize ();
			return this;
		},
		multLineMatrix: function (matrix)
		{
			matrix .multVecMatrix (this .point);
			matrix .multDirMatrix (this .direction) .normalize ();
			return this;
		},
		getClosestPointToPoint: function (point, result)
		{
			var
				r = result .assign (point) .subtract (this .point),
				d = r .dot (this .direction);

			return result .assign (this .direction) .multiply (d) .add (this .point);
		},
		getClosestPointToLine: (function ()
		{
			var u = new Vector3 (0, 0, 0);

			return function (line, point)
			{
				var
					p1 = this .point,
					p2 = line .point,
					d1 = this .direction,
					d2 = line .direction;
	
				var t = Vector3 .dot (d1, d2);
	
				if (Math .abs (t) >= 1)
					return false;  // lines are parallel
	
				u .assign (p2) .subtract (p1);
	
				t = (u .dot (d1) - t * u .dot (d2)) / (1 - t * t);
	
				point .assign (d1) .multiply (t) .add (p1);
				return true;
			};
		})(),
		getPerpendicularVector: function (point)
		{
			var d = Vector3 .subtract (this .point, point);

			return d .subtract (this .direction .copy () .multiply (Vector3 .dot (d, this .direction)));
		},
		intersectsTriangle: (function ()
		{
			var
				pvec = new Vector3 (0, 0, 0),
				tvec = new Vector3 (0, 0, 0);

			return function (A, B, C, uvt)
			{
				// Find vectors for two edges sharing vert0.
				var
					edge1 = B .subtract (A),
					edge2 = C .subtract (A);
	
				// Begin calculating determinant - also used to calculate U parameter.
				pvec .assign (this .direction) .cross (edge2);
	
				// If determinant is near zero, ray lies in plane of triangle.
				var det = edge1 .dot (pvec);
	
				// Non culling intersection.
	
				if (det === 0)
					return false;
	
				var inv_det = 1 / det;
	
				// Calculate distance from vert0 to ray point.
				tvec .assign (this .point) .subtract (A);
	
				// Calculate U parameter and test bounds.
				var u = tvec .dot (pvec) * inv_det;
	
				if (u < 0 || u > 1)
					return false;
	
				// Prepare to test V parameter.
				var qvec = tvec .cross (edge1);
	
				// Calculate V parameter and test bounds.
				var v = this .direction .dot (qvec) * inv_det;
	
				if (v < 0 || u + v > 1)
					return false;
	
				//var t = edge2 .dot (qvec) * inv_det;
	
				uvt .u = u;
				uvt .v = v;
				uvt .t = 1 - u - v;
	
				return true;
			};
		})(),
		toString: function ()
		{
			return this .point + ", " + this .direction;
		},
	};

	Line3 .Points = function (point1, point2)
	{
		var line = Object .create (Line3 .prototype);
		line .point     = point1 .copy ();
		line .direction = Vector3 .subtract (point2, point1) .normalize ();
		return line;
	};

	return Line3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithms/MergeSort',[],function ()
{
"use strict";

	function MergeSort (array, compare)
	{
		this .array     = array;
		this .auxiliary = [ ];

		if (compare)
			this .compare = compare;
	}

	MergeSort .prototype =
	{
		compare: function (lhs, rhs)
		{
			return lhs < rhs;
		},
		sort: function (first, last)
		{
			this .mergeSort (first, last - 1);
		},
		mergeSort: function (lo, hi)
		{
			if (lo < hi)
			{
				var m = (lo + hi) >>> 1;
				this .mergeSort (lo, m);   // Recursion
				this .mergeSort (m + 1, hi); // Recursion
				this .merge (lo, m, hi);
			}
		},
		merge: function (lo, m, hi)
		{
			var i, j, k;

			i = 0, j = lo;
			// Copy first half of array a to auxiliary array b.
			while (j <= m)
				this .auxiliary [i++] = this .array [j++];

			i = 0; k = lo;
			// Copy back next-greatest element at each time.
			while (k < j && j <= hi)
			{
				if (this .compare (this .array [j], this .auxiliary [i]))
					this .array [k++] = this .array [j++];
				else
					this .array [k++] = this .auxiliary [i++];
			}

			// Copy back remaining elements of first half (if any).
			while (k < j)
				this .array [k++] = this .auxiliary [i++];
		}
	};

	return MergeSort;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/PointingDeviceSensor/X3DPointingDeviceSensorContext',[
	"jquery",
	"x_ite/Browser/PointingDeviceSensor/PointingDevice",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Line3",
	"standard/Math/Geometry/ViewVolume",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Algorithms/MergeSort",
	"standard/Math/Algorithm",
],
function ($,
          PointingDevice,
          TraverseType,
          X3DConstants,
          Line3,
          ViewVolume,
          Vector2,
          Vector3,
          Matrix4,
          MergeSort,
          Algorithm)
{
"use strict";
	
	var line = new Line3 (Vector3 .Zero, Vector3 .Zero);

	function X3DPointingDeviceSensorContext ()
	{
		this .pointingDevice = new PointingDevice (this);

		this .pointer        = new Vector2 (0, 0);
		this .hitRay         = new Line3 (Vector3 .Zero, Vector3 .Zero);
		this .hits           = [ ];
		this .enabledSensors = [{ }];
		this .selectedLayer  = null;
		this .overSensors    = { };
		this .activeSensors  = { };

		this .hitPointSorter = new MergeSort (this .hits, function (lhs, rhs) { return lhs .intersection .point .z < rhs .intersection .point .z; });
		this .layerSorter    = new MergeSort (this .hits, function (lhs, rhs) { return lhs .layerNumber < rhs .layerNumber; });

		this .pointerTime = 0;
	}

	X3DPointingDeviceSensorContext .prototype =
	{
		initialize: function ()
		{
			this .getElement () .attr ("tabindex", this .getElement () .attr ("tabindex") || 0);
			this .setCursor ("DEFAULT");

			this .pointingDevice .setup ();
		},
		setCursor: function (value)
		{
			this .cursorType = value;

			var div = this .getElement () .find (".x_ite-private-surface");

			switch (value)
			{
				case "HAND": // Hand with finger
					div .css ("cursor", "pointer");
					break;
				case "MOVE": // Hand grabed something
					div .css ("cursor", "move");
					break;
				case "CROSSHAIR":
					div .css ("cursor", "crosshair");
					break;
				default:
				{
					if (this .loadCount_ .getValue ())
						div .css ("cursor", "wait");
					else if (this .pointingDevice && this .pointingDevice .isOver)
						div .css ("cursor", "pointer");
					else
						div .css ("cursor", "default");
					break;
				}
			}
		},
		getCursor: function ()
		{
			return this .cursorType;
		},
		isPointerInRectangle: function (rectangle)
		{
			return this .pointer .x > rectangle .x &&
			       this .pointer .x < rectangle .x + rectangle .z &&
			       this .pointer .y > rectangle .y &&
			       this .pointer .y < rectangle .y + rectangle .w;
		},
		setLayerNumber: function (value)
		{
			this .layerNumber = value;
		},
		getSelectedLayer: function ()
		{
			return this .selectedLayer;
		},
		setHitRay: function (projectionMatrix, viewport)
		{
			try
			{
				ViewVolume .unProjectRay (this .pointer .x, this .pointer .y, Matrix4 .Identity, projectionMatrix, viewport, this .hitRay);
			}
			catch (error)
			{
				this .hitRay .set (Vector3 .Zero, Vector3 .Zero);
			}
		},
		getHitRay: function ()
		{
			return this .hitRay;
		},
		getSensors: function ()
		{
			return this .enabledSensors;
		},
		addHit: function (intersection, layer, shape, modelViewMatrix)
		{
			this .hits .push ({
				pointer:         this .pointer,
				hitRay:          this .hitRay .copy (),
				intersection:    intersection,
				sensors:         this .enabledSensors [this .enabledSensors .length - 1],
				layer:           layer,
				layerNumber:     this .layerNumber,
				shape:           shape,
				modelViewMatrix: modelViewMatrix .copy (),
			});
		},
		getHits: function ()
		{
			return this .hits;
		},
		getNearestHit: function ()
		{
			return this .hits [this .hits .length - 1];
		},
		buttonPressEvent: function (x, y)
		{
			this .touch (x, y);

			if (this .hits .length === 0)
				return false;

			var nearestHit = this .getNearestHit ();

			this .selectedLayer = nearestHit .layer;
			this .activeSensors = nearestHit .sensors;

			for (var key in this .activeSensors)
				this .activeSensors [key] .set_active__ (true, nearestHit);

			return ! $.isEmptyObject (nearestHit .sensors);
		},
		buttonReleaseEvent: function ()
		{
			this .selectedLayer = null;

			for (var key in this .activeSensors)
				this .activeSensors [key] .set_active__ (false, null);

			this .activeSensors = { };

			// Selection

			return true;
		},
		motionNotifyEvent: function (x, y)
		{
			this .touch (x, y);

			this .motion ();

			return this .hits .length && ! $.isEmptyObject (this .hits [this .hits .length - 1] .sensors);
		},
		leaveNotifyEvent: function ()
		{
		},
		touch: function (x, y)
		{
			if (this .getViewer () .isActive_ .getValue ())
			{
				this .pointerTime = 0;
				return;
			}

			var t0 = performance .now ();
		
			this .pointer .set (x, y);

			// Clear hits.

			this .hits .length = 0;

			// Pick.
			
			this .getWorld () .traverse (TraverseType .POINTER, null);

			// Picking end.

			this .hitPointSorter .sort (0, this .hits .length);
			this .layerSorter    .sort (0, this .hits .length);

			this .addBrowserEvent ();
			this .pointerTime = performance .now () - t0;
		},
		motion: function ()
		{
			if (this .hits .length)
			{
				var nearestHit = this .hits [this .hits .length - 1];
			}
			else
			{
				var hitRay = this .selectedLayer ? this .hitRay : line;

				var nearestHit = {
					pointer:         this .pointer,
					modelViewMatrix: new Matrix4 (),
					hitRay:          hitRay,
					intersection:    null,
					sensors:         { },
					shape:           null,
					layer:           null,
					layerNumber:     0,
				};
			}

			// Set isOver to FALSE for appropriate nodes

			if (this .hits .length)
			{
				var difference = Algorithm .set_difference (this .overSensors, nearestHit .sensors, { }, function (lhs, rhs) {
					return lhs .getNode () < rhs .getNode ();
				});
			}
			else
			{
				var difference = Object .assign ({ }, this .overSensors);
			}

			for (var key in difference)
				difference [key] .set_over__ (false, nearestHit);

			// Set isOver to TRUE for appropriate nodes

			if (this .hits .length)
			{
				this .overSensors = nearestHit .sensors;

				for (var key in this .overSensors)
					this .overSensors [key] .set_over__ (true, nearestHit);
			}
			else
			{
				this .overSensors = { };
			}

			// Forward motion event to active drag sensor nodes

			for (var key in this .activeSensors)
			{
				this .activeSensors [key] .set_motion__ (nearestHit);
			}
		},
	};

	return X3DPointingDeviceSensorContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/X3DViewer',[
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Components/Navigation/OrthoViewpoint",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Box3",
	"standard/Math/Geometry/ViewVolume",
],
function (X3DBaseNode,
          OrthoViewpoint,
          Vector3,
          Matrix4,
          Box3,
          ViewVolume)
{
"use strict";

	var
		axis     = new Vector3 (0, 0, 0),
		distance = new Vector3 (0, 0, 0),
		far      = new Vector3 (0, 0, 0);

	function X3DViewer (executionContext)
	{
		X3DBaseNode .call (this, executionContext);
	}

	X3DViewer .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: X3DViewer,
		getTypeName: function ()
		{
			return "X3DViewer";
		},
		initialize: function ()
		{
		},
		getActiveLayer: function ()
		{
			return this .getBrowser () .getActiveLayer ();
		},
		getViewport: function ()
		{
			return this .getBrowser () .getActiveLayer () .getViewport ();
		},
		getNavigationInfo: function ()
		{
			return this .getBrowser () .getActiveLayer () .getNavigationInfo ();
		},
		getActiveViewpoint: function ()
		{
			return this .getBrowser () .getActiveLayer () .getViewpoint ();
		},
		getButton: function (button)
		{
			// If Alt key is pressed and button 0, then emulate button 1 (middle).
			if (button === 0)
			{
				if (this .getBrowser () .getAltKey ())
				{
					return 1;
				}
			}

			return button;
		},
		getPointOnCenterPlane: function (x, y, result)
		{
			try
			{
				var
					navigationInfo   = this .getNavigationInfo (),
					viewpoint        = this .getActiveViewpoint (),
					viewport         = this .getViewport () .getRectangle (this .getBrowser ()),
					projectionMatrix = viewpoint .getProjectionMatrixWithLimits (navigationInfo .getNearValue (), navigationInfo .getFarValue (viewpoint), viewport);

				// Far plane point
				ViewVolume .unProjectPoint (x, this .getBrowser () .getViewport () [3] - y, 0.9, Matrix4 .Identity, projectionMatrix, viewport, far);

				if (viewpoint instanceof OrthoViewpoint)
					return result .set (far .x, far .y, -this .getDistanceToCenter (distance) .abs ());

				var direction = far .normalize ();

				return result .assign (direction) .multiply (this .getDistanceToCenter (distance) .abs () / direction .dot (axis .set (0, 0, -1)));
			}
			catch (error)
			{
				console .log (error);
				return result .set (0, 0, 0);
			}
		},
		getDistanceToCenter: function (distance, positionOffset)
		{
			var viewpoint = this .getActiveViewpoint ();

			return (distance
				.assign (viewpoint .getPosition ())
				.add (positionOffset || viewpoint .positionOffset_ .getValue ())
				.subtract (viewpoint .getUserCenterOfRotation ()));
		},
		trackballProjectToSphere: function (x, y, vector)
		{
			var viewport = this .getViewport () .getRectangle (this .getBrowser ());

			y = this .getBrowser () .getViewport () [3] - y;

			x = (x - viewport [0]) / viewport [2] - 0.5;
			y = (y - viewport [1]) / viewport [3] - 0.5;

			return vector .set (x, y, tbProjectToSphere (0.5, x, y));
		},
		lookAtPoint: function (x, y, straightenHorizon)
		{
			if (! this .touch (x, y))
				return;

			var hit = this .getBrowser () .getNearestHit ();

			this .getActiveViewpoint () .lookAtPoint (hit .intersection .point, 2 - 1.618034, straightenHorizon);
		},
		lookAtBBox: (function ()
		{
			var bbox = new Box3 ();

			return function (x, y, straightenHorizon)
			{
				if (! this .touch (x, y))
					return;

				var hit = this .getBrowser () .getNearestHit ();

				hit .shape .getBBox (bbox) .multRight (hit .modelViewMatrix);

				this .getActiveViewpoint () .lookAtBBox (bbox, 2 - 1.618034, straightenHorizon);
			};
		})(),
		touch: function (x, y)
		{
			this .getBrowser () .touch (x, y);

			return this .getBrowser () .getHits () .length;
		},
		dispose: function () { },
	});

	function tbProjectToSphere (r, x, y)
	{
		var d = Math .sqrt (x * x + y * y);

		if (d < r * Math .sqrt (0.5)) // Inside sphere
		{
			return Math .sqrt (r * r - d * d);
		}

		// On hyperbola

		var t = r / Math .sqrt (2);
		return t * t / d;
	}

	return X3DViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/X3DFollowerNode',[
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DChildNode,
          X3DConstants)
{
"use strict";

	function X3DFollowerNode (executionContext)
	{
		X3DChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DFollowerNode);

		this .buffer = [ ];

		// Auxillary variables
		this .a      = this .getVector ();
		this .vector = this .getVector ();
	}

	X3DFollowerNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: X3DFollowerNode,
		initialize: function ()
		{
			X3DChildNode .prototype .initialize .call (this);

			this .isLive () .addInterest ("set_live__", this);
		},
		getBuffer: function ()
		{
			return this .buffer;
		},
		getValue: function ()
		{
			return this .set_value_ .getValue ();
		},
		getDestination: function ()
		{
			return this .set_destination_ .getValue ();
		},
		getInitialValue: function ()
		{
			return this .initialValue_ .getValue ();
		},
		getInitialDestination: function ()
		{
			return this .initialDestination_ .getValue ();
		},
		setValue: function (value)
		{
			this .value_changed_ = value;
		},
		setDestination: function (value)
		{
			this .destination .assign (value);
		},
		duplicate: function (value)
		{
			return value .copy ();
		},
		assign: function (buffer, i, value)
		{
			buffer [i] .assign (value);
		},
		equals: function (lhs, rhs, tolerance)
		{
			return this .a .assign (lhs) .subtract (rhs) .abs () < tolerance;
		},
		interpolate: function (source, destination, weight)
		{
			return this .vector .assign (source) .lerp (destination, weight);
		},
		set_live__: function ()
		{
			if ((this .isLive () .getValue () || this .getPrivate ()) && this .isActive_ .getValue ())
			{
				this .getBrowser () .prepareEvents () .addInterest ("prepareEvents", this);
				this .getBrowser () .addBrowserEvent ();
			}
			else
				this .getBrowser () .prepareEvents () .removeInterest ("prepareEvents", this);
		},
		set_active: function (value)
		{
			if (value !== this .isActive_ .getValue ())
			{
				this .isActive_ = value;

				this .set_live__ ();
			}
		},
	});

	return X3DFollowerNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/X3DChaserNode',[
	"x_ite/Components/Followers/X3DFollowerNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DFollowerNode,
          X3DConstants)
{
"use strict";

	function X3DChaserNode (executionContext)
	{
		X3DFollowerNode .call (this, executionContext);

		this .addType (X3DConstants .X3DChaserNode);

		this .destination   = null;
		this .previousValue = null;
		this .bufferEndTime = 0;
		this .stepTime      = 0;

		// Auxillary variables
		this .deltaOut = this .getVector ();
	}

	X3DChaserNode .prototype = Object .assign (Object .create (X3DFollowerNode .prototype),
	{
		constructor: X3DChaserNode,
		initialize: function ()
		{
			X3DFollowerNode .prototype .initialize .call (this);

			this .set_value_       .addInterest ("set_value__",       this);
			this .set_destination_ .addInterest ("set_destination__", this);
			this .duration_        .addInterest ("set_duration__",    this);

			this .set_duration__ ();

			var
				buffer             = this .getBuffer (),
				initialValue       = this .getInitialValue (),
				initialDestination = this .getInitialDestination (),
				numBuffers         = this .getNumBuffers ();

			this .bufferEndTime = this .getBrowser () .getCurrentTime ();
			this .previousValue = this .duplicate (initialValue);

			buffer [0] = this .duplicate (initialDestination);

			for (var i = 1; i < numBuffers; ++ i)
				buffer [i] = this .duplicate (initialValue);

			this .destination = this .duplicate (initialDestination);

			if (this .equals (initialDestination, initialValue, this .getTolerance ()))
				this .setValue (initialDestination);

			else
				this .set_active (true);
		},
		getNumBuffers: function ()
		{
			return 60;
		},
		getTolerance: function ()
		{
			return 1e-8;
		},
		getArray: function ()
		{
			return this .getVector ();
		},
		setPreviousValue: function (value)
		{
			this .previousValue .assign (value);
		},
		step: function (value1, value2, t)
		{
			this .output .add (this .deltaOut .assign (value1) .subtract (value2) .multiply (t));
		},
		stepResponse: function (t)
		{
			if (t <= 0)
				return 0;

			var duration = this .duration_ .getValue ();

			if (t >= duration)
				return 1;

			return 0.5 - 0.5 * Math .cos ((t / duration) * Math .PI);
		},
		set_value__: function ()
		{
			if (! this .isActive_ .getValue ())
				this .bufferEndTime = this .getBrowser () .getCurrentTime ();

			var
				buffer = this .getBuffer (),
				value  = this .getValue ();

			for (var i = 0, length = buffer .length; i < length; ++ i)
				this .assign (buffer, i, value);

			this .setPreviousValue (value);
			this .setValue (value);

			this .set_active (true);
		},
		set_destination__: function ()
		{
			this .setDestination (this .getDestination ());

			if (! this .isActive_ .getValue ())
				this .bufferEndTime = this .getBrowser () .getCurrentTime ();

			this .set_active (true);
		},
		set_duration__: function ()
		{
			this .stepTime = this .duration_ .getValue () / this .getNumBuffers ();
		},
		prepareEvents: function ()
		{
			try
			{
				var
					buffer     = this .getBuffer (),
					numBuffers = buffer .length,
					fraction   = this .updateBuffer ();

				this .output = this .interpolate (this .previousValue,
				                                  buffer [numBuffers - 1],
				                                  this .stepResponse ((numBuffers - 1 + fraction) * this .stepTime));

				for (var i = numBuffers - 2; i >= 0; -- i)
				{
					this .step (buffer [i], buffer [i + 1], this .stepResponse ((i + fraction) * this .stepTime));
				}

				this .setValue (this .output);

				if (this .equals (this .output, this .destination, this .getTolerance ()))
					this .set_active (false);
			}
			catch (error)
			{
				// Catch error from Rotation4.slerp.

				//console .log (error);
			}
		},
		updateBuffer: function ()
		{
			var
				buffer     = this .getBuffer (),
				numBuffers = buffer .length,
				fraction   = (this .getBrowser () .getCurrentTime () - this .bufferEndTime) / this .stepTime;

			if (fraction >= 1)
			{
				var seconds = Math .floor (fraction);

				fraction -= seconds;

				if (seconds < numBuffers)
				{
					this .setPreviousValue (buffer [numBuffers - seconds]);

					for (var i = numBuffers - 1; i >= seconds; -- i)
					{
						this .assign (buffer, i, buffer [i - seconds])
					}

					for (var i = 0; i < seconds; ++ i)
					{
						try
						{
							var alpha = i / seconds;

							this .assign (buffer, i, this .interpolate (this .destination, buffer [seconds], alpha))
						}
						catch (error)
						{ }
		 			}
				}
				else
				{
					this .setPreviousValue (seconds == numBuffers ? buffer [0] : this .destination);

					for (var i = 0; i < numBuffers; ++ i)
						this .assign (buffer, i, this .destination);
				}

				this .bufferEndTime += seconds * this .stepTime;
			}

			return fraction;
		},
	});

	return X3DChaserNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/PositionChaser',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DChaserNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Vector3)
{
"use strict";

	function PositionChaser (executionContext)
	{
		X3DChaserNode .call (this, executionContext);

		this .addType (X3DConstants .PositionChaser);
	}

	PositionChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
	{
		constructor: PositionChaser,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "PositionChaser";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector3 (0, 0, 0);
		},
	});

	return PositionChaser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/OrientationChaser',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DChaserNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Rotation4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Rotation4)
{
"use strict";

	var
		a        = new Rotation4 (0, 0, 1, 0),
		rotation = new Rotation4 (0, 0, 1, 0);

	function OrientationChaser (executionContext)
	{
		X3DChaserNode .call (this, executionContext);

		this .addType (X3DConstants .OrientationChaser);
	}

	OrientationChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
	{
		constructor: OrientationChaser,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFRotation ()),
		]),
		getTypeName: function ()
		{
			return "OrientationChaser";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Rotation4 (0, 0, 1, 0);
		},
		equals: function (lhs, rhs, tolerance)
		{
			a .assign (lhs) .inverse () .multRight (rhs);

			return Math .abs (a .angle) < tolerance;
		},
		interpolate: function (source, destination, weight)
		{
			return rotation .assign (source) .slerp (destination, weight);
		},
		step: function (value1, value2, t)
		{
			this .deltaOut .assign (value2) .inverse () .multRight (value1) .multLeft (this .output);

			this .output .slerp (this .deltaOut, t);
		},
	});

	return OrientationChaser;
});

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define('jquery-mousewheel/jquery.mousewheel',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

define('jquery-mousewheel', ['jquery-mousewheel/jquery.mousewheel'], function (main) { return main; });

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/ExamineViewer',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Navigation/X3DViewer",
	"x_ite/Components/Followers/PositionChaser",
	"x_ite/Components/Followers/OrientationChaser",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"jquery-mousewheel",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DViewer,
          PositionChaser,
          OrientationChaser,
          Vector2,
          Vector3,
          Rotation4)
{
"use strict";

	var macOS = /Mac OS X/i .test (navigator .userAgent)

	var
		MOTION_TIME       = 0.05 * 1000,
		SPIN_RELEASE_TIME = 0.04 * 1000,
		SPIN_ANGLE        = 0.003,
		SPIN_FACTOR       = 0.6,
		SCROLL_FACTOR     = macOS ? 1 / 120 : 1 / 20,
		MOVE_TIME         = 0.2,
		ROTATE_TIME       = 0.2,
		MAX_ANGLE         = 0.97;

	function ExamineViewer (executionContext)
	{
		X3DViewer .call (this, executionContext);

		this .button                   = -1;
		this .orientationOffset        = new Rotation4 (0, 0, 1, 0);
		this .fromVector               = new Vector3 (0, 0, 0);
		this .toVector                 = new Vector3 (0, 0, 0);
		this .fromPoint                = new Vector3 (0, 0, 0);
		this .toPoint                  = new Vector3 (0, 0, 0);
		this .rotation                 = new Rotation4 (0, 0, 1, 0);
		this .pressTime                = 0;
		this .motionTime               = 0;

		this .touchMode                = 0;
		this .touch1                   = new Vector2 (0, 0);
		this .touch2                   = new Vector2 (0, 0);
		this .tapStart                 = 0;
		this .dblTapInterval           = 0.4;

		this .initialPositionOffset    = new Vector3 (0, 0, 0);
		this .initialOrientationOffset = new Rotation4 (0, 0, 1, 0);
		this .positionChaser           = new PositionChaser (executionContext);
		this .centerOfRotationChaser   = new PositionChaser (executionContext);
		this .rotationChaser           = new OrientationChaser (executionContext);
	}

	ExamineViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
	{
		constructor: ExamineViewer,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
		]),
		initialize: function ()
		{
			X3DViewer .prototype .initialize .call (this);

			var
			   browser = this .getBrowser (),
			   element = browser .getElement ();

			// Disconnect from spin.

			this .getNavigationInfo () .transitionStart_ .addInterest ("disconnect", this);
			browser .activeViewpoint_ .addInterest ("set_activeViewpoint__", this);

			// Bind pointing device events.

			element .bind ("mousedown.ExamineViewer",  this .mousedown  .bind (this));
			element .bind ("mouseup.ExamineViewer",    this .mouseup    .bind (this));
			element .bind ("dblclick.ExamineViewer",   this .dblclick   .bind (this));
			element .bind ("mousewheel.ExamineViewer", this .mousewheel .bind (this));

			element .bind ("touchstart.ExamineViewer",  this .touchstart .bind (this));
			element .bind ("touchend.ExamineViewer",    this .touchend   .bind (this));

			// Setup scroll chaser.

			this .positionChaser .duration_ = MOVE_TIME;
			this .positionChaser .setPrivate (true);
			this .positionChaser .setup ();

			this .centerOfRotationChaser .duration_ = MOVE_TIME;
			this .centerOfRotationChaser .setPrivate (true);
			this .centerOfRotationChaser .setup ();

			this .rotationChaser .duration_ = ROTATE_TIME;
			this .rotationChaser .setPrivate (true);
			this .rotationChaser .setup ();

			this .set_activeViewpoint__ ();
		},
		set_activeViewpoint__: function ()
		{
			if (this .getBrowser () .getBrowserOption ("StraightenHorizon"))
			{
				var viewpoint = this .getActiveViewpoint ();

				if (viewpoint)
					viewpoint .orientationOffset_ = this .getOrientationOffset (Rotation4 .Identity, viewpoint .orientationOffset_ .getValue (), false);
			}

			this .disconnect ();
		},
		mousedown: function (event)
		{
			if (this .button >= 0)
				return;

			this .pressTime = performance .now ();

			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = event .pageY - offset .top;

			switch (this .getButton (event .button))
			{
				case 0:
				{
					// Start rotate.

					// Stop event propagation.
					event .preventDefault ();
					event .stopImmediatePropagation ();

					this .button = event .button;

					$(document) .bind ("mouseup.ExamineViewer"   + this .getId (), this .mouseup   .bind (this));
					$(document) .bind ("mousemove.ExamineViewer" + this .getId (), this .mousemove .bind (this));
					$(document) .bind ("touchend.ExamineViewer"  + this .getId (), this .touchend  .bind (this));
					$(document) .bind ("touchmove.ExamineViewer" + this .getId (), this .touchmove .bind (this));

					this .disconnect ();
					this .getActiveViewpoint () .transitionStop ();
					this .getBrowser () .setCursor ("MOVE");

					this .trackballProjectToSphere (x, y, this .fromVector);
					this .rotation .assign (Rotation4 .Identity);

					this .motionTime = 0;

					this .isActive_ = true;
					break;
				}
				case 1:
				{
					// Start pan.

					// Stop event propagation.
					event .preventDefault ();
					event .stopImmediatePropagation ();

					this .button = event .button;

					$(document) .bind ("mouseup.ExamineViewer"   + this .getId (), this .mouseup   .bind (this));
					$(document) .bind ("mousemove.ExamineViewer" + this .getId (), this .mousemove .bind (this));
					$(document) .bind ("touchend.ExamineViewer"  + this .getId (), this .touchend  .bind (this));
					$(document) .bind ("touchmove.ExamineViewer" + this .getId (), this .touchmove .bind (this));

					this .disconnect ();
					this .getActiveViewpoint () .transitionStop ();
					this .getBrowser () .setCursor ("MOVE");

					this .getPointOnCenterPlane (x, y, this .fromPoint);

					this .isActive_ = true;
					break;
				}
			}
		},
		mouseup: function (event)
		{
			if (event .button !== this .button)
				return;

			this .button = -1;

			$(document) .unbind (".ExamineViewer" + this .getId ());

			switch (this .getButton (event .button))
			{
				case 0:
				{
					// End rotate.

					// Stop event propagation.
					event .preventDefault ();
					event .stopImmediatePropagation ();

					var viewpoint = this .getActiveViewpoint ();

					this .getBrowser () .setCursor ("DEFAULT");

					if (Math .abs (this .rotation .angle) > SPIN_ANGLE && performance .now () - this .motionTime < SPIN_RELEASE_TIME)
					{
						if (this .getBrowser () .getBrowserOption ("StraightenHorizon") && viewpoint .getTypeName () !== "GeoViewpoint")
							this .rotation = this .getHorizonRotation (this .rotation);

						this .addSpinning (this .rotation);
					}

					this .isActive_ = false;
					break;
				}
				case 1:
				{
					// End pan.

					// Stop event propagation.
					event .preventDefault ();
					event .stopImmediatePropagation ();

					this .getBrowser () .setCursor ("DEFAULT");

					this .isActive_ = false;
					break;
				}
			}
		},
		dblclick: function (event)
		{
			// Stop event propagation.
			event .preventDefault ();
			event .stopImmediatePropagation ();

			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = this .getBrowser () .getElement () .height () - (event .pageY - offset .top);

			this .disconnect ();
			this .lookAtBBox (x, y, this .getBrowser () .getBrowserOption ("StraightenHorizon"));
		},
		mousemove: (function ()
		{
			var fromPoint = new Vector3 (0, 0, 0);

			return function (event)
			{
				var
					offset = this .getBrowser () .getElement () .offset (),
					x      = event .pageX - offset .left,
					y      = event .pageY - offset .top;

				switch (this .getButton (this .button))
				{
					case 0:
					{
						// Rotate view around Viewpoint.centerOfRotation.

						// Stop event propagation.
						event .preventDefault ();
						event .stopImmediatePropagation ();

						var toVector = this .trackballProjectToSphere (x, y, this .toVector);

						this .rotation .setFromToVec (toVector, this .fromVector);

						if (Math .abs (this .rotation .angle) < SPIN_ANGLE && performance .now () - this .pressTime < MOTION_TIME)
							return;

						this .addRotate (this .rotation);

						this .fromVector .assign (toVector);
						this .motionTime = performance .now ();
						break;
					}
					case 1:
					{
						// Move view along center plane.

						// Stop event propagation.
						event .preventDefault ();
						event .stopImmediatePropagation ();

						var
							viewpoint   = this .getActiveViewpoint (),
							toPoint     = this .getPointOnCenterPlane (x, y, this .toPoint),
							translation = viewpoint .getUserOrientation () .multVecRot (fromPoint .assign (this .fromPoint) .subtract (toPoint));

						this .addMove (translation, translation);

						this .fromPoint .assign (toPoint);
						break;
					}
				}
			};
		})(),
		mousewheel: (function ()
		{
			var
				step        = new Vector3 (0, 0, 0),
				translation = new Vector3 (0, 0, 0);

			return function (event)
			{
				// Stop event propagation.
				event .preventDefault ();
				event .stopImmediatePropagation ();

				// Change viewpoint position.

				var
					browser   = this .getBrowser (),
					viewpoint = this .getActiveViewpoint ();

				browser .prepareEvents () .removeInterest ("spin", this);
				viewpoint .transitionStop ();

				step        = this .getDistanceToCenter (step) .multiply (event .zoomFactor || SCROLL_FACTOR),
				translation = viewpoint .getUserOrientation () .multVecRot (translation .set (0, 0, step .abs ()));

				if (event .deltaY > 0)
					this .addMove (translation .negate (), Vector3 .Zero);

				else if (event .deltaY < 0)
					this .addMove (translation, Vector3 .Zero);
			};
		})(),
		touchstart: function (event)
		{
			var touches = event .originalEvent .touches;

			switch (touches .length)
			{
				case 1:
				{
					// Start rotate (button 0).

					event .button = 0;
					event .pageX  = touches [0] .pageX;
					event .pageY  = touches [0] .pageY;

					this .mousedown (event);

					// Remember tap.

					this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
					break;
				}
				case 2:
				{
					// End rotate (button 0).

					this .touchend (event);

					// Start move (button 1).

					event .button = 1;
					event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
					event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

					this .mousedown (event);

					// Start zoom (mouse wheel).

					this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
					this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
					break;
				}
				case 3:
				{
					// End move (button 1).
					this .touchend (event);
					break;
				}
			}
		},
		touchend: function (event)
		{
			switch (this .button)
			{
				case 0:
				{
					// End rotate (button 0).

					event .button = 0;

					this .mouseup (event);

					// Start dblclick (button 0).

					if (this .getBrowser () .getCurrentTime () - this .tapStart < this .dblTapInterval)
					{
						event .button = 0;
						event .pageX  = this .touch1 .x;
						event .pageY  = this .touch1 .y;

						this .dblclick (event);
					}

					this .tapStart = this .getBrowser () .getCurrentTime ();
					break;
				}
				case 1:
				{
					// End move (button 1).

					this .touchMode = 0;
					event .button   = 1;

					this .mouseup (event);
					break;
				}
			}
		},
		touchmove: (function ()
		{
			var
				MOVE_ANGLE   = 0.7,
				ZOOM_ANGLE   = -0.7,
				touch1Change = new Vector2 (0, 0),
				touch2Change = new Vector2 (0, 0);

			return function (event)
			{
				var touches = event .originalEvent .touches;

				switch (touches .length)
				{
					case 1:
					{
						// Rotate (button 0).

						event .pageX = touches [0] .pageX;
						event .pageY = touches [0] .pageY;

						this .mousemove (event);
						break;
					}
					case 2:
					{
						touch1Change .set (touches [0] .pageX, touches [0] .pageY) .subtract (this .touch1) .normalize ();
						touch2Change .set (touches [1] .pageX, touches [1] .pageY) .subtract (this .touch2) .normalize ();

						var
							move = touch1Change .dot (touch2Change) > MOVE_ANGLE,
							zoom = touch1Change .dot (touch2Change) < ZOOM_ANGLE,
							mode = this .touchMode || (move ? 1 : (zoom ? 2 : 0));

						switch (mode)
						{
							case 1:
							{
								// Move (button 1).

								this .touchMode = 1;

								event .pageX = (touches [0] .pageX + touches [1] .pageX) / 2;
								event .pageY = (touches [0] .pageY + touches [1] .pageY) / 2;

								this .mousemove (event);

								break;
							}
							case 2:
							{
								// Zoom (mouse wheel).

								this .touchMode = 2;

								var distance1 = this .touch1 .distance (this .touch2);

								this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
								this .touch2 .set (touches [1] .pageX, touches [1] .pageY);

								var
									distance2 = this .touch1 .distance (this .touch2),
									delta     = distance2 - distance1;

								event .deltaY     = delta;
								event .zoomFactor = Math .abs (delta) / $(window) .width ();

								this .mousewheel (event);

								break;
							}
						}

						this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
						this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
						break;
					}
				}
			};
		})(),
		spin: function ()
		{
			var viewpoint = this .getActiveViewpoint ();

			this .orientationOffset .assign (viewpoint .orientationOffset_ .getValue ());

			viewpoint .orientationOffset_ = this .getOrientationOffset (this .rotation, this .orientationOffset);
			viewpoint .positionOffset_    = this .getPositionOffset (viewpoint .positionOffset_ .getValue (), this .orientationOffset, viewpoint .orientationOffset_ .getValue ());
		},
		set_positionOffset__: function (value)
		{
			var viewpoint = this .getActiveViewpoint ();

			viewpoint .positionOffset_ = value;
		},
		set_centerOfRotationOffset__: function (value)
		{
			var viewpoint = this .getActiveViewpoint ();

			viewpoint .centerOfRotationOffset_ = value;
		},
		set_rotation__: function (value)
		{
			var viewpoint = this .getActiveViewpoint ();

			viewpoint .orientationOffset_ = this .getOrientationOffset (value .getValue (), this .initialOrientationOffset, false);
			viewpoint .positionOffset_    = this .getPositionOffset (this .initialPositionOffset, this .initialOrientationOffset, viewpoint .orientationOffset_ .getValue ());
		},
		addRotate: (function ()
		{
			var destination = new Rotation4 ();

			return function (rotationChange)
			{
				var viewpoint = this .getActiveViewpoint ();

				if (this .rotationChaser .isActive_ .getValue () && this .rotationChaser .value_changed_ .hasInterest ("set_rotation__", this))
				{
					try
					{
						destination .assign (this .rotationChaser .set_destination_ .getValue ())
							.multLeft (rotationChange);

						// Check for critical angle.
						this .getOrientationOffset (destination, this .initialOrientationOffset, true);

						this .rotationChaser .set_destination_ = destination;
					}
					catch (error)
					{
						// Slide along critical angle.

						rotationChange = this .getHorizonRotation (rotationChange);

						destination .assign (this .rotationChaser .set_destination_ .getValue ())
							.multLeft (rotationChange);

						this .rotationChaser .set_destination_ = destination;
					}
				}
				else
				{
					try
					{
						this .initialOrientationOffset .assign (viewpoint .orientationOffset_ .getValue ());
						this .initialPositionOffset    .assign (viewpoint .positionOffset_    .getValue ());

						// Check for critical angle.
						this .getOrientationOffset (rotationChange, this .initialOrientationOffset, true);

						this .rotationChaser .set_value_       = Rotation4 .Identity;
						this .rotationChaser .set_destination_ = rotationChange;
					}
					catch (error)
					{
						// Slide along critical angle.

						this .rotationChaser .set_value_       = Rotation4 .Identity;
						this .rotationChaser .set_destination_ = this .getHorizonRotation (rotationChange);
					}
				}

				this .disconnect ();
				this .rotationChaser .value_changed_ .addInterest ("set_rotation__", this);
			};
		})(),
		addSpinning: (function ()
		{
			var rotation = new Rotation4 (0, 0, 1, 0);

			return function (rotationChange)
			{
				try
				{
					this .disconnect ();
					this .getBrowser () .prepareEvents () .addInterest ("spin", this);

					this .rotation .assign (rotation .assign (Rotation4 .Identity) .slerp (rotationChange, SPIN_FACTOR));
				}
				catch (error)
				{
					console .log (error);
				}
			};
		})(),
		addMove: (function ()
		{
			var
				positionOffset         = new Vector3 (0, 0, 0),
				centerOfRotationOffset = new Vector3 (0, 0, 0);

			return function (positionOffsetChange, centerOfRotationOffsetChange)
			{
				var viewpoint = this .getActiveViewpoint ();

				if (this .positionChaser .isActive_ .getValue () && this .positionChaser .value_changed_ .hasInterest ("set_positionOffset__", this))
				{
					positionOffset
						.assign (this .positionChaser .set_destination_ .getValue ())
						.add (positionOffsetChange);

					this .positionChaser .set_destination_ = positionOffset;
				}
				else
				{
					positionOffset
						.assign (viewpoint .positionOffset_ .getValue ())
						.add (positionOffsetChange);

					this .positionChaser .set_value_       = viewpoint .positionOffset_;
					this .positionChaser .set_destination_ = positionOffset;
				}

				if (this .centerOfRotationChaser .isActive_ .getValue () && this .centerOfRotationChaser .value_changed_ .hasInterest ("set_centerOfRotationOffset__", this))
				{
					centerOfRotationOffset
						.assign (this .centerOfRotationChaser .set_destination_ .getValue ())
						.add (centerOfRotationOffsetChange);

					this .centerOfRotationChaser .set_destination_ = centerOfRotationOffset;
				}
				else
				{
					centerOfRotationOffset
						.assign (viewpoint .centerOfRotationOffset_ .getValue ())
						.add (centerOfRotationOffsetChange);

					this .centerOfRotationChaser .set_value_       = viewpoint .centerOfRotationOffset_;
					this .centerOfRotationChaser .set_destination_ = centerOfRotationOffset;
				}

				this .disconnect ();
				this .positionChaser         .value_changed_ .addInterest ("set_positionOffset__",         this);
				this .centerOfRotationChaser .value_changed_ .addInterest ("set_centerOfRotationOffset__", this);
			};
		})(),
		getPositionOffset: (function ()
		{
			var
				distance = new Vector3 (0, 0, 0),
				d        = new Vector3 (0, 0, 0),
				oob      = new Rotation4 (0, 0, 1, 0);

			return function (positionOffsetBefore, orientationOffsetBefore, orientationOffsetAfter)
			{
				this .getDistanceToCenter (distance, positionOffsetBefore);

				return (oob
					.assign (orientationOffsetBefore)
					.inverse ()
					.multRight (orientationOffsetAfter)
					.multVecRot (d .assign (distance))
					.subtract (distance)
					.add (positionOffsetBefore));
			};
		})(),
		getOrientationOffset: (function ()
		{
			var
				userOrientation   = new Rotation4 (0, 0, 1, 0),
				orientationOffset = new Rotation4 (0, 0, 1, 0),
				zAxis             = new Vector3 (0, 0, 0);

			return function (rotation, orientationOffsetBefore, _throw)
			{
				var
					viewpoint         = this .getActiveViewpoint (),
					straightenHorizon = this .getBrowser () .getBrowserOption ("StraightenHorizon");

				userOrientation
					.assign (rotation)
					.multRight (viewpoint .getOrientation ())
					.multRight (orientationOffsetBefore);

				if (straightenHorizon && viewpoint .getTypeName () !== "GeoViewpoint")
					viewpoint .straightenHorizon (userOrientation);

				var orientationOffsetAfter = orientationOffset
					.assign (viewpoint .getOrientation ())
					.inverse ()
					.multRight (userOrientation);

				if (straightenHorizon && viewpoint .getTypeName () !== "GeoViewpoint")
				{
					if (! _throw)
						return orientationOffsetAfter;

					var userVector = userOrientation .multVecRot (zAxis .assign (Vector3 .zAxis));

					if (Math .abs (viewpoint .getUpVector () .dot (userVector)) < MAX_ANGLE)
						return orientationOffsetAfter;

					throw new Error ("Critical angle");
				}
				else
				{
					return orientationOffsetAfter;
				}
			};
		})(),
		getHorizonRotation: (function ()
		{
			var zAxis = new Vector3 (0, 0, 0);

			return function (rotation)
			{
				var viewpoint = this .getActiveViewpoint ();

				var
					V = rotation .multVecRot (zAxis .assign (Vector3 .zAxis)) .normalize (),
					N = Vector3 .cross (viewpoint .getUpVector (), V) .normalize (),
					H = Vector3 .cross (N, viewpoint .getUpVector ()) .normalize ();

				return new Rotation4 (Vector3 .zAxis, H);
			};
		})(),
		disconnect: function ()
		{
			var browser = this .getBrowser ();

			this .positionChaser         .value_changed_ .removeInterest ("set_positionOffset__",         this)
			this .centerOfRotationChaser .value_changed_ .removeInterest ("set_centerOfRotationOffset__", this)
			this .rotationChaser         .value_changed_ .removeInterest ("set_rotation__",               this);

			browser .prepareEvents () .removeInterest ("spin", this);
		},
		dispose: function ()
		{
			var browser = this .getBrowser ();

			this .disconnect ();
			browser .activeViewpoint_ .removeInterest ("set_activeViewpoint__", this);
			browser .getElement () .unbind (".ExamineViewer");
			$(document) .unbind (".ExamineViewer" + this .getId ());
		},
	});

	return ExamineViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/X3DFlyViewer',[
	"jquery",
	"x_ite/Browser/Navigation/X3DViewer",
	"x_ite/Components/Followers/OrientationChaser",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Camera",
	"jquery-mousewheel",
],
function ($,
          X3DViewer,
          OrientationChaser,
          Vector3,
          Rotation4,
          Matrix4,
          Camera)
{
"use strict";

	var macOS = /Mac OS X/i .test (navigator .userAgent)

	var
		SPEED_FACTOR           = 0.007,
		SHIFT_SPEED_FACTOR     = 4 * SPEED_FACTOR,
		ROTATION_SPEED_FACTOR  = 1.4,
		ROTATION_LIMIT         = 40,
		PAN_SPEED_FACTOR       = SPEED_FACTOR,
		PAN_SHIFT_SPEED_FACTOR = 1.4 * PAN_SPEED_FACTOR,
		ROLL_ANGLE             = macOS ? Math .PI / 512 : Math .PI / 32,
		ROTATE_TIME            = 0.3;

	var
		MOVE = 0,
		PAN  = 1;

	function X3DFlyViewer (executionContext)
	{
		X3DViewer .call (this, executionContext);

		var gl = this .getBrowser () .getContext ();

		this .button            = -1;
		this .fromVector        = new Vector3 (0, 0, 0);
		this .toVector          = new Vector3 (0, 0, 0);
		this .direction         = new Vector3 (0, 0, 0);
		this .startTime         = 0;
		this .lineBuffer        = gl .createBuffer ();
		this .lineCount         = 2;
		this .lineVertices      = new Array (this .lineCount * 4);
		this .lineArray         = new Float32Array (this .lineVertices);
		this .event             = null;
		this .lookAround        = false;
		this .orientationChaser = new OrientationChaser (executionContext);
	}

	X3DFlyViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
	{
		constructor: X3DFlyViewer,
		initialize: function ()
		{
			X3DViewer .prototype .initialize .call (this);

			var
			   browser = this .getBrowser (),
			   element = browser .getElement ();

			// Bind pointing device events.

			element .bind ("mousedown.X3DFlyViewer",  this .mousedown  .bind (this));
			element .bind ("mouseup.X3DFlyViewer",    this .mouseup    .bind (this));
			element .bind ("mousewheel.X3DFlyViewer", this .mousewheel .bind (this));

			element .bind ("touchstart.X3DFlyViewer", this .touchstart .bind (this));
			element .bind ("touchend.X3DFlyViewer",   this .touchend   .bind (this));

			browser .controlKey_ .addInterest ("set_controlKey_", this);

			// Setup look around chaser.

			this .orientationChaser .duration_ = ROTATE_TIME;
			this .orientationChaser .setPrivate (true);
			this .orientationChaser .setup ();
		},
		addCollision: function () { },
		removeCollision: function () { },
		set_controlKey_: function ()
		{
			if (this .event && this .event .button === 0)
			{
				this .button = -1;
				this .mousedown (this .event);
			}
		},
		mousedown: function (event)
		{
			if (this .button >= 0)
				return;

			this .event = event;

			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = event .pageY - offset .top;

			switch (this .getButton (event .button))
			{
				case 0:
				{
					// Start walk or fly.

					// Stop event propagation.
					event .preventDefault ();
					event .stopImmediatePropagation ();

					this .button = event .button;

					$(document) .bind ("mouseup.X3DFlyViewer"   + this .getId (), this .mouseup   .bind (this));
					$(document) .bind ("mousemove.X3DFlyViewer" + this .getId (), this .mousemove .bind (this));
					$(document) .bind ("touchend.X3DFlyViewer"  + this .getId (), this .touchend  .bind (this));
					$(document) .bind ("touchmove.X3DFlyViewer" + this .getId (), this .touchmove .bind (this));

					this .disconnect ();
					this .getActiveViewpoint () .transitionStop ();
					this .getBrowser () .setCursor ("MOVE");
					this .addCollision ();

					if (this .getBrowser () .getControlKey () || this .lookAround)
					{
						// Look around.

						this .trackballProjectToSphere (x, y, this .fromVector);
					}
					else
					{
						// Move.

						this .fromVector .set (x, 0, y);
						this .toVector   .assign (this .fromVector);

						this .getFlyDirection (this .fromVector, this .toVector, this .direction);
						this .addFly ();

						if (this .getBrowser () .getBrowserOption ("Rubberband"))
							this .getBrowser () .finished () .addInterest ("display", this, MOVE);
					}

					this .isActive_ = true;
					break;
				}
				case 1:
				{
					// Start pan.

					// Stop event propagation.
					event .preventDefault ();
					event .stopImmediatePropagation ();

					this .button = event .button;

					$(document) .bind ("mouseup.X3DFlyViewer"   + this .getId (), this .mouseup   .bind (this));
					$(document) .bind ("mousemove.X3DFlyViewer" + this .getId (), this .mousemove .bind (this));

					this .disconnect ();
					this .getActiveViewpoint () .transitionStop ();
					this .getBrowser () .setCursor ("MOVE");
					this .addCollision ();

					this .fromVector .set (x, -y, 0);
					this .toVector   .assign (this .fromVector);
					this .direction  .set (0, 0, 0);

					this .addPan ();

					if (this .getBrowser () .getBrowserOption ("Rubberband"))
						this .getBrowser () .finished () .addInterest ("display", this, PAN);

					this .isActive_ = true;
					break;
				}
			}
		},
		mouseup: function (event)
		{
			event .preventDefault ();

			if (event .button !== this .button)
				return;

			this .event  = null;
			this .button = -1;

			$(document) .unbind (".X3DFlyViewer" + this .getId ());

			this .disconnect ();
			this .getBrowser () .setCursor ("DEFAULT");
			this .removeCollision ();

			this .isActive_ = false;
		},
		mousemove: function (event)
		{
			this .getBrowser () .addBrowserEvent ();

			this .event = event;

			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = event .pageY - offset .top;

			switch (this .getButton (this .button))
			{
				case 0:
				{
					if (this .getBrowser () .getControlKey () || this .lookAround)
					{
						// Stop event propagation.
						event .preventDefault ();
						event .stopImmediatePropagation ();

						// Look around

						var toVector = this .trackballProjectToSphere (x, y, this .toVector);

						this .addRotation (this .fromVector, toVector);
						this .fromVector .assign (toVector);
						break;
					}
					else
					{
						// Fly

						this .toVector .set (x, 0, y);
						this .getFlyDirection (this .fromVector, this .toVector, this .direction);
						break;
					}
				}
				case 1:
				{
					// Stop event propagation.
					event .preventDefault ();
					event .stopImmediatePropagation ();

					// Pan

					this .toVector  .set (x, -y, 0);
					this .direction .assign (this .toVector) .subtract (this .fromVector);
					break;
				}
			}
		},
		mousewheel: function (event)
		{
			// Stop event propagation.

			event .preventDefault ();
			event .stopImmediatePropagation ();

			// Change viewpoint position.

			var viewpoint = this .getActiveViewpoint ();

			viewpoint .transitionStop ();

			if (event .deltaY > 0)
				this .addRoll (-ROLL_ANGLE);

			else if (event .deltaY < 0)
				this .addRoll (ROLL_ANGLE);
		},
		touchstart: function (event)
		{
			var touches = event .originalEvent .touches;

			switch (touches .length)
			{
				case 1:
				{
					// Start fly or walk (button 0).

					event .button = 0;
					event .pageX  = touches [0] .pageX;
					event .pageY  = touches [0] .pageY;

					this .mousedown (event);
					break;
				}
				case 2:
				{
					// End fly or walk (button 0).

					this .touchend (event);

					// Start look around (button 0).

					this .lookAround = true;
					event .button    = 0;
					event .pageX     = (touches [0] .pageX + touches [1] .pageX) / 2;
					event .pageY     = (touches [0] .pageY + touches [1] .pageY) / 2;

					this .mousedown (event);
					break;
				}
				case 3:
				{
					// End look around (button 0).

					this .touchend (event);
					break;
				}
			}
		},
		touchend: function (event)
		{
			switch (this .button)
			{
				case 0:
				{
					// End move or look around (button 0).
					this .lookAround = false;
					event .button    = 0;

					this .mouseup (event);
					break;
				}
			}
		},
		touchmove: function (event)
		{
			var touches = event .originalEvent .touches;

			switch (touches .length)
			{
				case 1:
				{
					// Fly or walk (button 0).

					event .button = 0;
					event .pageX  = touches [0] .pageX;
					event .pageY  = touches [0] .pageY;

					this .mousemove (event);
					break;
				}
				case 2:
				{
					// Fly or walk (button 0).

					event .button = 0;
					event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
					event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

					this .mousemove (event);
					break;
				}
			}
		},
		fly: (function ()
		{
			var
				upVector           = new Vector3 (0, 0, 0),
				direction          = new Vector3 (0, 0, 0),
				axis               = new Vector3 (0, 0, 0),
				userOrientation    = new Rotation4 (0, 0, 1, 0),
				orientationOffset  = new Rotation4 (0, 0, 1, 0),
				rubberBandRotation = new Rotation4 (0, 0, 1, 0),
				up                 = new Rotation4 (0, 0, 1, 0),
				geoRotation        = new Rotation4 (0, 0, 1, 0);

			return function ()
			{
				var
					navigationInfo = this .getNavigationInfo (),
					viewpoint      = this .getActiveViewpoint (),
					now            = performance .now (),
					dt             = (now - this .startTime) / 1000;

				upVector .assign (viewpoint .getUpVector ());

				// Rubberband values

				up .setFromToVec (Vector3 .yAxis, upVector);

				if (this .direction .z > 0)
					rubberBandRotation .setFromToVec (up .multVecRot (direction .assign (this .direction)), up .multVecRot (axis .set (0, 0, 1)));
				else
					rubberBandRotation .setFromToVec (up .multVecRot (axis .set (0, 0, -1)), up .multVecRot (direction .assign (this .direction)));

				var rubberBandLength = this .direction .abs ();

				// Determine positionOffset.

				var speedFactor = 1 - rubberBandRotation .angle / (Math .PI / 2);

				speedFactor *= navigationInfo .speed_ .getValue ();
				speedFactor *= viewpoint .getSpeedFactor ();
				speedFactor *= this .getBrowser () .getShiftKey () ? SHIFT_SPEED_FACTOR : SPEED_FACTOR;
				speedFactor *= dt;

				var translation = this .getTranslationOffset (direction .assign (this .direction) .multiply (speedFactor));

				this .getActiveLayer () .constrainTranslation (translation, true);

				viewpoint .positionOffset_ = translation .add (viewpoint .positionOffset_ .getValue ());

				// Determine weight for rubberBandRotation.

				var weight = ROTATION_SPEED_FACTOR * dt * Math .pow (rubberBandLength / (rubberBandLength + ROTATION_LIMIT), 2);

				// Determine userOrientation.

				userOrientation
					.assign (Rotation4 .Identity)
					.slerp (rubberBandRotation, weight)
					.multRight (viewpoint .getUserOrientation ());

				// Straighten horizon of userOrientation.

				if (viewpoint .getTypeName () !== "GeoViewpoint")
						viewpoint .straightenHorizon (userOrientation);

				// Determine orientationOffset.

				orientationOffset
					.assign (viewpoint .getOrientation ())
					.inverse ()
					.multRight (userOrientation);

				// Set orientationOffset.

				viewpoint .orientationOffset_ = orientationOffset;

				// GeoRotation

				geoRotation .setFromToVec (upVector, viewpoint .getUpVector ());

				viewpoint .orientationOffset_ = geoRotation .multLeft (viewpoint .orientationOffset_ .getValue ());

				this .startTime = now;
			};
		})(),
		pan: (function ()
		{
			var
				direction = new Vector3 (0, 0, 0),
				axis      = new Vector3 (0, 0, 0);

			return function ()
			{
				var
					navigationInfo = this .getNavigationInfo (),
					viewpoint      = this .getActiveViewpoint (),
					now            = performance .now (),
					dt             = (now - this .startTime) / 1000,
					upVector       = viewpoint .getUpVector ();

				this .constrainPanDirection (direction .assign (this .direction));

				var speedFactor = 1;

				speedFactor *= navigationInfo .speed_ .getValue ();
				speedFactor *= viewpoint .getSpeedFactor ();
				speedFactor *= this .getBrowser () .getShiftKey () ? PAN_SHIFT_SPEED_FACTOR : PAN_SPEED_FACTOR;
				speedFactor *= dt;

				var
					orientation = viewpoint .getUserOrientation () .multRight (new Rotation4 (viewpoint .getUserOrientation () .multVecRot (axis .assign (Vector3 .yAxis)), upVector)),
					translation = orientation .multVecRot (direction .multiply (speedFactor));

				this .getActiveLayer () .constrainTranslation (translation, true);

				viewpoint .positionOffset_ = translation .add (viewpoint .positionOffset_ .getValue ());

				this .startTime = now;
			};
		})(),
		set_orientationOffset__: function (value)
		{
			var viewpoint = this .getActiveViewpoint ();

			viewpoint .orientationOffset_ = value;
		},
		addFly: function ()
		{
			if (this .startTime)
				return;

			this .getBrowser () .prepareEvents () .addInterest ("fly", this);
			this .getBrowser () .addBrowserEvent ();

			this .startTime = performance .now ();
		},
		addPan: function ()
		{
			if (this .startTime)
				return;

			this .disconnect ();
			this .getBrowser () .prepareEvents () .addInterest ("pan", this);
			this .getBrowser () .addBrowserEvent ();

			this .startTime = performance .now ();
		},
		addRoll: (function ()
		{
			var
				orientationOffset = new Rotation4 (0, 0, 1, 0),
				roll              = new Rotation4 (0, 0, 1, 0);

			return function (rollAngle)
			{
				var viewpoint = this .getActiveViewpoint ();

				if (this .orientationChaser .isActive_ .getValue () && this .orientationChaser .value_changed_ .hasInterest ("set_orientationOffset__", this))
				{
					orientationOffset
						.assign (viewpoint .getOrientation ())
						.inverse ()
						.multRight (roll .set (1, 0, 0, rollAngle))
						.multRight (viewpoint .getOrientation ())
						.multRight (this .orientationChaser .set_destination_ .getValue ());

					this .orientationChaser .set_destination_ = orientationOffset;
				}
				else
				{
					orientationOffset
						.assign (viewpoint .getOrientation ())
						.inverse ()
						.multRight (roll .set (1, 0, 0, rollAngle))
						.multRight (viewpoint .getUserOrientation ());

					this .orientationChaser .set_value_       = viewpoint .orientationOffset_;
					this .orientationChaser .set_destination_ = orientationOffset;
				}

				this .disconnect ();
				this .orientationChaser .value_changed_ .addInterest ("set_orientationOffset__", this);
			};
		})(),
		addRotation: (function ()
		{
			var
				userOrientation   = new Rotation4 (0, 0, 1, 0),
				orientationOffset = new Rotation4 (0, 0, 1, 0);

			return function (fromVector, toVector)
			{
				var viewpoint = this .getActiveViewpoint ();

				if (this .orientationChaser .isActive_ .getValue () && this .orientationChaser .value_changed_ .hasInterest ("set_orientationOffset__", this))
				{
					userOrientation
						.setFromToVec (toVector, fromVector)
						.multRight (viewpoint .getOrientation ())
						.multRight (this .orientationChaser .set_destination_ .getValue ());

					if (viewpoint .getTypeName () !== "GeoViewpoint")
						viewpoint .straightenHorizon (userOrientation);

					orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

					this .orientationChaser .set_destination_ = orientationOffset;
				}
				else
				{
					userOrientation
						.setFromToVec (toVector, fromVector)
						.multRight (viewpoint .getUserOrientation ());

					if (viewpoint .getTypeName () !== "GeoViewpoint")
						viewpoint .straightenHorizon (userOrientation);

					orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

					this .orientationChaser .set_value_       = viewpoint .orientationOffset_;
					this .orientationChaser .set_destination_ = orientationOffset;
				}

				this .disconnect ();
				this .orientationChaser .value_changed_ .addInterest ("set_orientationOffset__", this);
			};
		})(),
		display: (function ()
		{
			var
				fromPoint             = new Vector3 (0, 0, 0),
				toPoint               = new Vector3 (0, 0, 0),
				projectionMatrix      = new Matrix4 (),
				projectionMatrixArray = new Float32Array (Matrix4 .Identity),
				modelViewMatrixArray  = new Float32Array (Matrix4 .Identity);

			return function (interest, type)
			{
				// Configure HUD

				var
					browser  = this .getBrowser (),
					viewport = browser .getViewport (),
					width    = viewport [2],
					height   = viewport [3];

				Camera .ortho (0, width, 0, height, -1, 1, projectionMatrix);

				projectionMatrixArray .set (projectionMatrix);

				// Display Rubberband.

				if (type === MOVE)
				{
					fromPoint .set (this .fromVector .x, height - this .fromVector .z, 0);
					toPoint   .set (this .toVector   .x, height - this .toVector   .z, 0);
				}
				else
				{
					fromPoint .set (this .fromVector .x, height + this .fromVector .y, 0);
					toPoint   .set (this .toVector   .x, height + this .toVector   .y, 0);
				}

				this .transfer (fromPoint, toPoint);

				var
					gl         = browser .getContext (),
					shaderNode = browser .getLineShader (),
					lineWidth  = gl .getParameter (gl .LINE_WIDTH);

				if (shaderNode .getValid ())
				{
					shaderNode .enable (gl);
					shaderNode .enableVertexAttribute (gl, this .lineBuffer);

					gl .uniform1i (shaderNode .x3d_NumClipPlanes,         0);
					gl .uniform1i (shaderNode .x3d_FogType,               0);
					gl .uniform1i (shaderNode .x3d_ColorMaterial,         false);
					gl .uniform1i (shaderNode .x3d_LinePropertiesApplied, false);

					gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, projectionMatrixArray);
					gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,  false, modelViewMatrixArray);

					gl .disable (gl .DEPTH_TEST);

					// Draw a black and a white line.
					gl .lineWidth (2);
					gl .uniform3f (shaderNode .x3d_EmissiveColor, 0, 0, 0);
					gl .uniform1f (shaderNode .x3d_Transparency,  0);

					gl .drawArrays (gl .LINES, 0, this .lineCount);

					gl .lineWidth (1);
					gl .uniform3f (shaderNode .x3d_EmissiveColor, 1, 1, 1);

					gl .drawArrays (gl .LINES, 0, this .lineCount);
					gl .enable (gl .DEPTH_TEST);

					gl .lineWidth (lineWidth);
					shaderNode .disable (gl);
				}
			};
		})(),
		transfer: function (fromPoint, toPoint)
		{
			var
				gl           = this .getBrowser () .getContext (),
				lineVertices = this .lineVertices;

			lineVertices [0] = fromPoint .x;
			lineVertices [1] = fromPoint .y;
			lineVertices [2] = fromPoint .z;
			lineVertices [3] = 1;

			lineVertices [4] = toPoint .x;
			lineVertices [5] = toPoint .y;
			lineVertices [6] = toPoint .z;
			lineVertices [7] = 1;

			this .lineArray .set (lineVertices);

			// Transfer line.

			gl .bindBuffer (gl .ARRAY_BUFFER, this .lineBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, this .lineArray, gl .STATIC_DRAW);
		},
		disconnect: function ()
		{
			var browser = this .getBrowser ();

			browser .addBrowserEvent ();

			browser .prepareEvents () .removeInterest ("fly", this);
			browser .prepareEvents () .removeInterest ("pan", this);
			browser .finished ()      .removeInterest ("display", this);

			this .orientationChaser .value_changed_ .removeInterest ("set_orientationOffset__", this);

			this .startTime = 0;
		},
		dispose: function ()
		{
			this .disconnect ();
			this .getBrowser () .controlKey_ .removeInterest ("set_controlKey_", this);
			this .getBrowser () .getElement () .unbind (".X3DFlyViewer");
			$(document) .unbind (".X3DFlyViewer" + this .getId ());
		},
	});

	return X3DFlyViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/WalkViewer',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Browser/Navigation/X3DFlyViewer",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DFlyViewer,
          X3DConstants,
          Vector3,
          Rotation4)
{
"use strict";
	
	function WalkViewer (executionContext)
	{
		X3DFlyViewer .call (this, executionContext);
	}

	WalkViewer .prototype = Object .assign (Object .create (X3DFlyViewer .prototype),
	{
		constructor: WalkViewer,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
		]),
		initialize: function ()
		{
			X3DFlyViewer .prototype .initialize .call (this);
			
			this .getBrowser () .addCollision (this);
		},
		getFlyDirection: function (fromVector, toVector, direction)
		{
			return direction .assign (toVector) .subtract (fromVector);
		},
		getTranslationOffset: (function ()
		{
			var
				localYAxis      = new Vector3 (0, 0, 0),
				userOrientation = new Rotation4 (0, 0, 1, 0),
				rotation        = new Rotation4 (0, 0, 1, 0);

			return function (velocity)
			{
				var
					viewpoint = this .getActiveViewpoint (),
					upVector  = viewpoint .getUpVector ();
	
				userOrientation .assign (viewpoint .getUserOrientation ());
				userOrientation .multVecRot (localYAxis .assign (Vector3 .yAxis));
				rotation        .setFromToVec (localYAxis, upVector);

				var orientation = userOrientation .multRight (rotation);
	
				return orientation .multVecRot (velocity);
			};
		})(),
		constrainPanDirection: function (direction)
		{
			if (direction .y < 0)
				direction .y = 0;

			return direction;
		},
		dispose: function ()
		{
			this .getBrowser () .removeCollision (this);
			
			X3DFlyViewer .prototype .dispose .call (this);
		},
	});

	return WalkViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/FlyViewer',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Navigation/X3DFlyViewer",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DFlyViewer,
          Vector3,
          Rotation4)
{
"use strict";
	
	function FlyViewer (executionContext)
	{
		X3DFlyViewer .call (this, executionContext);
	}

	FlyViewer .prototype = Object .assign (Object .create (X3DFlyViewer .prototype),
	{
		constructor: FlyViewer,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
		]),
		addCollision: function ()
		{
			this .getBrowser () .addCollision (this);
		},
		removeCollision: function ()
		{
			this .getBrowser () .removeCollision (this);
		},
		getFlyDirection: function (fromVector, toVector, direction)
		{
			direction .assign (toVector) .subtract (fromVector);

			direction .x =  direction .x / 20;
			direction .y = -direction .z / 20;
			direction .z = -50;

			return direction;
		},
		getTranslationOffset: function (velocity)
		{
			return this .getActiveViewpoint () .getUserOrientation () .multVecRot (velocity);
		},
		constrainPanDirection: function (direction)
		{
			return direction;
		},
	});

	return FlyViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/Viewpoint',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Navigation/X3DViewpointNode",
	"x_ite/Components/Interpolation/ScalarInterpolator",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Camera",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DViewpointNode,
          ScalarInterpolator,
          X3DConstants,
          Camera,
          Vector2,
          Vector3,
          Matrix4)
{
"use strict";

	function Viewpoint (executionContext)
	{
		X3DViewpointNode .call (this, executionContext);

		this .addType (X3DConstants .Viewpoint);

		this .position_         .setUnit ("length");
		this .centerOfRotation_ .setUnit ("length");
		this .fieldOfView_      .setUnit ("angle");

		this .projectionMatrix        = new Matrix4 ();
		this .fieldOfViewInterpolator = new ScalarInterpolator (this .getBrowser () .getPrivateScene ());
	}

	Viewpoint .prototype = Object .assign (Object .create (X3DViewpointNode .prototype),
	{
		constructor: Viewpoint,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",          new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "description",       new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "position",          new Fields .SFVec3f (0, 0, 10)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "orientation",       new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "centerOfRotation",  new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "fieldOfView",       new Fields .SFFloat (0.7854)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "jump",              new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "retainUserOffsets", new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",          new Fields .SFTime ()),
		]),
		getTypeName: function ()
		{
			return "Viewpoint";
		},
		getComponentName: function ()
		{
			return "Navigation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DViewpointNode .prototype .initialize .call (this);

			this .fieldOfViewInterpolator .key_ = new Fields .MFFloat (0, 1);
			this .fieldOfViewInterpolator .setup ();

			this .getEaseInEaseOut () .modifiedFraction_changed_ .addFieldInterest (this .fieldOfViewInterpolator .set_fraction_);
			this .fieldOfViewInterpolator .value_changed_ .addFieldInterest (this .fieldOfViewScale_);
		},
		setInterpolators: function (fromViewpoint)
		{
			if (fromViewpoint .getType () .indexOf (X3DConstants .Viewpoint) < 0)
			{
				this .fieldOfViewInterpolator .keyValue_ = new Fields .MFFloat (this .fieldOfViewScale_ .getValue (), this .fieldOfViewScale_ .getValue ());
			}
			else
			{
				var scale = fromViewpoint .getFieldOfView () / this .fieldOfView_ .getValue ();

				this .fieldOfViewInterpolator .keyValue_ = new Fields .MFFloat (scale, this .fieldOfViewScale_ .getValue ());

				this .fieldOfViewScale_ = scale;
			}
		},
		getFieldOfView: function ()
		{
			var fov = this .fieldOfView_ .getValue () * this .fieldOfViewScale_ .getValue ();

			return fov > 0 && fov < Math .PI ? fov : Math .PI / 4;
		},
		getScreenScale: (function ()
		{
			var screenScale = new Vector3 (0, 0, 0);

			return function (point, viewport)
			{
			   // Returns the screen scale in meter/pixel for on pixel.

				var
					width  = viewport [2],
					height = viewport [3],
					size   = Math .abs (point .z) * Math .tan (this .getFieldOfView () / 2) * 2;

				if (width > height)
					size /= height;
				else
					size /= width;

				return screenScale .set (size, size, size);
			};
		})(),
		getViewportSize: (function ()
		{
			var viewportSize = new Vector2 (0, 0);

			return function (viewport, nearValue)
			{
				// Returns viewport size in meters.

				var
					width  = viewport [2],
					height = viewport [3],
					size   = nearValue * Math .tan (this .getFieldOfView () / 2) * 2,
					aspect = width / height;

				if (aspect > 1)
					return viewportSize .set (size * aspect, size);

				return viewportSize .set (size, size / aspect);
			};
		})(),
		getLookAtDistance: function (bbox)
		{
			return (bbox .size .abs () / 2) / Math .tan (this .getFieldOfView () / 2);
		},
		getProjectionMatrixWithLimits: function (nearValue, farValue, viewport)
		{
			return Camera .perspective (this .getFieldOfView (), nearValue, farValue, viewport [2], viewport [3], this .projectionMatrix);
		},
	});

	return Viewpoint;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/PlaneViewer',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Navigation/X3DViewer",
	"x_ite/Components/Navigation/Viewpoint",
	"standard/Math/Numbers/Vector3",
	"jquery-mousewheel",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DViewer,
          Viewpoint,
          Vector3)
{
"use strict";

	var macOS = /Mac OS X/i .test (navigator .userAgent)

	var SCROLL_FACTOR = macOS ? 1 / 160 : 1 / 20;

	var
		vector                 = new Vector3 (0 ,0, 0),
		positionOffset         = new Vector3 (0 ,0, 0),
		centerOfRotationOffset = new Vector3 (0, 0, 0);

	function PlaneViewer (executionContext)
	{
		X3DViewer .call (this, executionContext);

		this .button    = -1;
		this .fromPoint = new Vector3 (0, 0, 0);
		this .toPoint   = new Vector3 (0, 0, 0);
	}

	PlaneViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
	{
		constructor: PlaneViewer,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
		]),
		initialize: function ()
		{
			X3DViewer .prototype .initialize .call (this);

			var
			   browser = this .getBrowser (),
			   element = browser .getElement ();

			element .bind ("mousedown.PlaneViewer",  this .mousedown  .bind (this));
			element .bind ("mouseup.PlaneViewer",    this .mouseup    .bind (this));
			element .bind ("mousemove.PlaneViewer",  this .mousemove  .bind (this));
			element .bind ("mousewheel.PlaneViewer", this .mousewheel .bind (this));
		},
		mousedown: function (event)
		{
			if (this .button >= 0)
				return;

			this .pressTime = performance .now ();

			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = event .pageY - offset .top;

			switch (this .getButton (event .button))
			{
				case 1:
				{
					// Stop event propagation.

					event .preventDefault ();
					event .stopImmediatePropagation ();

					this .button = event .button;

					this .getBrowser () .getElement () .unbind ("mousemove.PlaneViewer");
					$(document) .bind ("mouseup.PlaneViewer"   + this .getId (), this .mouseup .bind (this));
					$(document) .bind ("mousemove.PlaneViewer" + this .getId (), this .mousemove .bind (this));

					this .getActiveViewpoint () .transitionStop ();
					this .getBrowser () .setCursor ("MOVE");

					this .getPointOnCenterPlane (x, y, this .fromPoint);

					this .isActive_ = true;
					break;
				}
			}
		},
		mouseup: function (event)
		{
			// Stop event propagation.

			event .preventDefault ();
			event .stopImmediatePropagation ();

			if (event .button !== this .button)
				return;

			this .button = -1;

			$(document) .unbind (".PlaneViewer" + this .getId ());
			this .getBrowser () .getElement () .bind ("mousemove.PlaneViewer", this .mousemove .bind (this));

			this .getBrowser () .setCursor ("DEFAULT");

			this .isActive_ = false;
		},
		mousemove: function (event)
		{
			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = event .pageY - offset .top;

			switch (this .getButton (this .button))
			{
				case 1:
				{
					// Stop event propagation.

					event .preventDefault ();
					event .stopImmediatePropagation ();

					// Move.

					var
						viewpoint   = this .getActiveViewpoint (),
						toPoint     = this .getPointOnCenterPlane (x, y, this .toPoint),
						translation = viewpoint .getUserOrientation () .multVecRot (this .fromPoint .subtract (toPoint));

					viewpoint .positionOffset_         = positionOffset         .assign (viewpoint .positionOffset_         .getValue ()) .add (translation);
					viewpoint .centerOfRotationOffset_ = centerOfRotationOffset .assign (viewpoint .centerOfRotationOffset_ .getValue ()) .add (translation);

					this .fromPoint .assign (toPoint);
					break;
				}
			}
		},
		mousewheel: function (event)
		{
			// Stop event propagation.

			event .preventDefault ();
			event .stopImmediatePropagation ();

			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = event .pageY - offset .top;

			// Change viewpoint position.

			var
				viewpoint = this .getActiveViewpoint (),
				fromPoint = this .getPointOnCenterPlane (x, y, this .fromPoint);

			viewpoint .transitionStop ();

			if (event .deltaY > 0) // Move backwards.
			{
				viewpoint .fieldOfViewScale_ = Math .max (0.00001, viewpoint .fieldOfViewScale_ .getValue () * (1 - SCROLL_FACTOR));
			}
			else if (event .deltaY < 0) // Move forwards.
			{
				viewpoint .fieldOfViewScale_ = viewpoint .fieldOfViewScale_ .getValue () * (1 + SCROLL_FACTOR);

				this .constrainFieldOfViewScale ();
			}

			if (viewpoint .set_fieldOfView___)
				viewpoint .set_fieldOfView___ (); // XXX: Immediately apply fieldOfViewScale;

			var
				toPoint     = this .getPointOnCenterPlane (x, y, this .toPoint),
				translation = viewpoint .getUserOrientation () .multVecRot (vector .assign (fromPoint) .subtract (toPoint));

			viewpoint .positionOffset_         = positionOffset         .assign (viewpoint .positionOffset_         .getValue ()) .add (translation);
			viewpoint .centerOfRotationOffset_ = centerOfRotationOffset .assign (viewpoint .centerOfRotationOffset_ .getValue ()) .add (translation);
		},
		constrainFieldOfViewScale: function ()
		{
			var viewpoint = this .getActiveViewpoint ();

			if (viewpoint instanceof Viewpoint || viewpoint .getTypeName () === "GeoViewpoint")
			{
				if (viewpoint .fieldOfView_ .getValue () * viewpoint .fieldOfViewScale_ .getValue () >= Math .PI)
					viewpoint .fieldOfViewScale_ = (Math .PI - 0.001) / viewpoint .fieldOfView_ .getValue ();
			}
		},
		dispose: function ()
		{
			this .getBrowser () .getElement () .unbind (".PlaneViewer");
			$(document) .unbind (".PlaneViewer" + this .getId ());
		},
	});

	return PlaneViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/NoneViewer',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Navigation/X3DViewer",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DViewer)
{
"use strict";
	
	function NoneViewer (executionContext)
	{
		X3DViewer .call (this, executionContext);
	}

	NoneViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
	{
		constructor: NoneViewer,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
		]),
	});

	return NoneViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/LookAtViewer',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Navigation/X3DViewer",
	"x_ite/Components/Followers/PositionChaser",
	"x_ite/Components/Followers/OrientationChaser",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DConstants,
          X3DViewer,
          PositionChaser,
          OrientationChaser,
          Vector2,
          Vector3,
          Rotation4)
{
"use strict";

	var macOS = /Mac OS X/i .test (navigator .userAgent)

	var
		SCROLL_FACTOR = macOS ? 1 / 120 : 1 / 20,
		MOVE_TIME     = 0.3,
		ROTATE_TIME   = 0.3;

	function LookAtViewer (executionContext)
	{
		X3DViewer .call (this, executionContext);

		this .button                 = -1;
		this .fromVector             = new Vector3 (0, 0, 0);
		this .toVector               = new Vector3 (0, 0, 0);

		this .touch1                 = new Vector2 (0, 0);
		this .touch2                 = new Vector2 (0, 0);
		this .tapStart               = 0;
		this .dblTapInterval         = 0.4;

		this .positionChaser         = new PositionChaser (executionContext);
		this .centerOfRotationChaser = new PositionChaser (executionContext);
		this .orientationChaser      = new OrientationChaser (executionContext);
	}

	LookAtViewer .prototype = Object .assign (Object .create (X3DViewer .prototype),
	{
		constructor: LookAtViewer,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .outputOnly, "isActive", new Fields .SFBool ()),
		]),
		initialize: function ()
		{
			X3DViewer .prototype .initialize .call (this);

			var
			   browser = this .getBrowser (),
			   element = browser .getElement ();

			// Bind pointing device events.

			element .bind ("mousedown.LookAtViewer",  this .mousedown  .bind (this));
			element .bind ("mouseup.LookAtViewer",    this .mouseup    .bind (this));
			element .bind ("dblclick.LookAtViewer",   this .dblclick   .bind (this));
			element .bind ("mousewheel.LookAtViewer", this .mousewheel .bind (this));

			element .bind ("touchstart.LookAtViewer", this .touchstart .bind (this));
			element .bind ("touchend.LookAtViewer",   this .touchend   .bind (this));

			// Setup chaser.

			this .positionChaser .duration_ = MOVE_TIME;
			this .positionChaser .setPrivate (true);
			this .positionChaser .setup ();

			this .centerOfRotationChaser .duration_ = MOVE_TIME;
			this .centerOfRotationChaser .setPrivate (true);
			this .centerOfRotationChaser .setup ();

			this .orientationChaser .duration_ = ROTATE_TIME;
			this .orientationChaser .setPrivate (true);
			this .orientationChaser .setup ();
		},
		mousedown: function (event)
		{
			if (this .button >= 0)
				return;

			this .pressTime = performance .now ();

			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = event .pageY - offset .top;

			switch (event .button)
			{
				case 0:
				{
					// Stop event propagation.

					event .preventDefault ();
					event .stopImmediatePropagation ();

					this .button = event .button;

					$(document) .bind ("mouseup.LookAtViewer"   + this .getId (), this .mouseup   .bind (this));
					$(document) .bind ("mousemove.LookAtViewer" + this .getId (), this .mousemove .bind (this));
					$(document) .bind ("touchend.LookAtViewer"  + this .getId (), this .mouseup   .bind (this));
					$(document) .bind ("touchmove.LookAtViewer" + this .getId (), this .touchmove .bind (this));

					this .getActiveViewpoint () .transitionStop ();

					// Look around.

					this .trackballProjectToSphere (x, y, this .fromVector);

					this .isActive_ = true;
					break;
				}
			}
		},
		mouseup: function (event)
		{
			if (event .button !== this .button)
				return;

			this .button = -1;

			$(document) .unbind (".LookAtViewer" + this .getId ());

			switch (event .button)
			{
				case 0:
				{
					// Stop event propagation.

					event .preventDefault ();
					event .stopImmediatePropagation ();

					this .isActive_ = false;
					break;
				}
			}
		},
		dblclick: function (event)
		{
			// Stop event propagation.
			event .preventDefault ();
			event .stopImmediatePropagation ();

			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = this .getBrowser () .getElement () .height () - (event .pageY - offset .top);

			this .disconnect ();
			this .lookAtPoint (x, y, this .getBrowser () .getBrowserOption ("StraightenHorizon"));
		},
		mousemove: function (event)
		{
			this .getBrowser () .addBrowserEvent ();

			this .event = event;

			var
				offset = this .getBrowser () .getElement () .offset (),
				x      = event .pageX - offset .left,
				y      = event .pageY - offset .top;

			switch (this .button)
			{
				case 0:
				{
					// Stop event propagation.
					event .preventDefault ();
					event .stopImmediatePropagation ();

					// Look around

					var toVector  = this .trackballProjectToSphere (x, y, this .toVector);

					this .addRotation (this .fromVector, toVector);
					this .fromVector .assign (toVector);
					break;
				}
			}
		},
		mousewheel: (function ()
		{
			var
				step        = new Vector3 (0, 0, 0),
				translation = new Vector3 (0, 0, 0);

			return function (event)
			{
				// Stop event propagation.
				event .preventDefault ();
				event .stopImmediatePropagation ();

				// Change viewpoint position.

				var viewpoint = this .getActiveViewpoint ();

				viewpoint .transitionStop ();

				step        = this .getDistanceToCenter (step) .multiply (event .zoomFactor || SCROLL_FACTOR),
				translation = viewpoint .getUserOrientation () .multVecRot (translation .set (0, 0, step .abs ()));

				if (event .deltaY > 0)
					this .addMove (translation .negate (), Vector3 .Zero);

				else if (event .deltaY < 0)
					this .addMove (translation, Vector3 .Zero);
			};
		})(),
		touchstart: function (event)
		{
			var touches = event .originalEvent .touches;

			switch (touches .length)
			{
				case 1:
				{
					// Start move (button 0).

					this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
					break;
				}
				case 2:
				{
					// End move (button 0).

					this .touchend (event);

					// Start look around (button 0).

					event .button = 0;
					event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
					event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

					this .mousedown (event);

					// Start zoom (mouse wheel).

					this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
					this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
					break;
				}
				case 3:
				{
					this .touchend (event);
					break;
				}
			}
		},
		touchend: function (event)
		{
			switch (this .button)
			{
				case 0:
				{
					// End look around (button 0).
					this .mouseup (event);
					break;
				}
			}

			// Start dblclick (button 0).

			if (this .getBrowser () .getCurrentTime () - this .tapStart < this .dblTapInterval)
			{
				event .button = 1;
				event .pageX  = this .touch1 .x;
				event .pageY  = this .touch1 .y;

				this .dblclick (event);
			}

			this .tapStart = this .getBrowser () .getCurrentTime ();
		},
		touchmove: (function ()
		{
			var
				MOVE_ANGLE   = 0.7,
				ZOOM_ANGLE   = -0.7,
				touch1Change = new Vector2 (0, 0),
				touch2Change = new Vector2 (0, 0);

			return function (event)
			{
				var touches = event .originalEvent .touches;

				switch (touches .length)
				{
					case 1:
					{
						// Move (button 0).
						break;
					}
					case 2:
					{
						touch1Change .set (touches [0] .pageX, touches [0] .pageY) .subtract (this .touch1) .normalize ();
						touch2Change .set (touches [1] .pageX, touches [1] .pageY) .subtract (this .touch2) .normalize ();

						var
							move = touch1Change .dot (touch2Change) > MOVE_ANGLE,
							zoom = touch1Change .dot (touch2Change) < ZOOM_ANGLE;

						if (move)
						{
							// Look around (button 0).

							event .button = 0;
							event .pageX  = (touches [0] .pageX + touches [1] .pageX) / 2;
							event .pageY  = (touches [0] .pageY + touches [1] .pageY) / 2;

							this .mousemove (event);
						}
						else if (zoom)
						{
							// Zoom (mouse wheel).

							var distance1 = this .touch1 .distance (this .touch2);

							this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
							this .touch2 .set (touches [1] .pageX, touches [1] .pageY);

							var
								distance2 = this .touch1 .distance (this .touch2),
								delta     = distance2 - distance1;

							event .deltaY     = delta;
							event .zoomFactor = Math .abs (delta) / $(window) .width ();

							this .mousewheel (event);
						}

						this .touch1 .set (touches [0] .pageX, touches [0] .pageY);
						this .touch2 .set (touches [1] .pageX, touches [1] .pageY);
						break;
					}
				}
			};
		})(),
		set_positionOffset__: function (value)
		{
			var viewpoint = this .getActiveViewpoint ();

			viewpoint .positionOffset_ = value;
		},
		set_centerOfRotationOffset__: function (value)
		{
			var viewpoint = this .getActiveViewpoint ();

			viewpoint .centerOfRotationOffset_ = value;
		},
		set_orientationOffset__: function (value)
		{
			var viewpoint = this .getActiveViewpoint ();

			viewpoint .orientationOffset_ = value;
		},
		addMove: (function ()
		{
			var
				positionOffset         = new Vector3 (0, 0, 0),
				centerOfRotationOffset = new Vector3 (0, 0, 0);

			return function (positionOffsetChange, centerOfRotationOffsetChange)
			{
				var viewpoint = this .getActiveViewpoint ();

				if (this .positionChaser .isActive_ .getValue () && this .positionChaser .value_changed_ .hasInterest ("set_positionOffset__", this))
				{
					positionOffset
						.assign (this .positionChaser .set_destination_ .getValue ())
						.add (positionOffsetChange);

					this .positionChaser .set_destination_ = positionOffset;
				}
				else
				{
					positionOffset
						.assign (viewpoint .positionOffset_ .getValue ())
						.add (positionOffsetChange);

					this .positionChaser .set_value_       = viewpoint .positionOffset_;
					this .positionChaser .set_destination_ = positionOffset;
				}

				if (this .centerOfRotationChaser .isActive_ .getValue () && this .centerOfRotationChaser .value_changed_ .hasInterest ("set_centerOfRotationOffset__", this))
				{
					centerOfRotationOffset
						.assign (this .centerOfRotationChaser .set_destination_ .getValue ())
						.add (centerOfRotationOffsetChange);

					this .centerOfRotationChaser .set_destination_ = centerOfRotationOffset;
				}
				else
				{
					centerOfRotationOffset
						.assign (viewpoint .centerOfRotationOffset_ .getValue ())
						.add (centerOfRotationOffsetChange);

					this .centerOfRotationChaser .set_value_       = viewpoint .centerOfRotationOffset_;
					this .centerOfRotationChaser .set_destination_ = centerOfRotationOffset;
				}

				this .disconnect ();
				this .positionChaser         .value_changed_ .addInterest ("set_positionOffset__",         this);
				this .centerOfRotationChaser .value_changed_ .addInterest ("set_centerOfRotationOffset__", this);
			};
		})(),
		addRotation: (function ()
		{
			var
				userOrientation   = new Rotation4 (0, 0, 1, 0),
				orientationOffset = new Rotation4 (0, 0, 1, 0);

			return function (fromVector, toVector)
			{
				var viewpoint = this .getActiveViewpoint ();

				if (this .orientationChaser .isActive_ .getValue () && this .orientationChaser .value_changed_ .hasInterest ("set_orientationOffset__", this))
				{
					userOrientation
						.setFromToVec (toVector, fromVector)
						.multRight (viewpoint .getOrientation ())
						.multRight (this .orientationChaser .set_destination_ .getValue ());

					viewpoint .straightenHorizon (userOrientation);

					orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

					this .orientationChaser .set_destination_ = orientationOffset;
				}
				else
				{
					userOrientation
						.setFromToVec (toVector, fromVector)
						.multRight (viewpoint .getUserOrientation ());

					viewpoint .straightenHorizon (userOrientation);

					orientationOffset .assign (viewpoint .getOrientation ()) .inverse () .multRight (userOrientation);

					this .orientationChaser .set_value_       = viewpoint .orientationOffset_;
					this .orientationChaser .set_destination_ = orientationOffset;
				}

				this .disconnect ();
				this .orientationChaser .value_changed_ .addInterest ("set_orientationOffset__", this);
			};
		})(),
		disconnect: function ()
		{
			this .orientationChaser      .value_changed_ .removeInterest ("set_orientationOffset__", this);
			this .positionChaser         .value_changed_ .removeInterest ("set_positionOffset__",         this)
			this .centerOfRotationChaser .value_changed_ .removeInterest ("set_centerOfRotationOffset__", this)
		},
		dispose: function ()
		{
			this .getBrowser () .getElement () .unbind (".LookAtViewer");
			$(document) .unbind (".LookAtViewer" + this .getId ());
		},
	});

	return LookAtViewer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting/X3DLightNode',[
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Algorithm",
],
function (X3DChildNode,
          TraverseType,
          X3DConstants,
          Matrix4,
          Algorithm)
{
"use strict";

	function X3DLightNode (executionContext)
	{
		X3DChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DLightNode);
	}

	X3DLightNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: X3DLightNode,
		initialize: function ()
		{
			X3DChildNode .prototype .initialize .call (this);

			this .on_ .addInterest ("set_on__", this);

			this .set_on__ ();
		},
		set_on__: function ()
		{
			if (this .on_ .getValue ())
			{
				delete this .push;
				delete this .pop;
			}
			else
			{
				this .push = Function .prototype;
				this .pop  = Function .prototype;
			}
		},
		getGlobal: function ()
		{
			return this .global_ .getValue ();
		},
		getColor: function ()
		{
			return this .color_ .getValue ();
		},
		getIntensity: function ()
		{
			return Algorithm .clamp (this .intensity_ .getValue (), 0, 1);
		},
		getAmbientIntensity: function ()
		{
			return Algorithm .clamp (this .ambientIntensity_ .getValue (), 0, 1);
		},
		getDirection: function ()
		{
			return this .direction_ .getValue ();
		},
		getShadowColor: function ()
		{
			return this .shadowColor_ .getValue ();
		},
		getShadowIntensity: function ()
		{
			return Algorithm .clamp (this .shadowIntensity_ .getValue (), 0, 1);
		},
		getShadowBias: function ()
		{
			return Algorithm .clamp (this .shadowBias_ .getValue (), 0, 1);
		},
		getShadowMapSize: function ()
		{
			return Math .min (this .shadowMapSize_ .getValue (), this .getBrowser () .getMaxTextureSize ());
		},
		getBiasMatrix: (function ()
		{
			// Transforms normalized coords from range (-1, 1) to (0, 1).
			var biasMatrix = new Matrix4 (0.5, 0.0, 0.0, 0.0,
			                              0.0, 0.5, 0.0, 0.0,
			                              0.0, 0.0, 0.5, 0.0,
			                              0.5, 0.5, 0.5, 1.0);

			return function ()
			{
				return biasMatrix;
			};
		})(),
		push: function (renderObject, group)
		{
			if (renderObject .isIndependent ())
			{
				var lightContainer = this .getLights () .pop ();

				if (this .global_ .getValue ())
				{
					lightContainer .set (renderObject .getBrowser (),
												this,
												renderObject .getLayer () .getGroup (),
												renderObject .getModelViewMatrix () .get ());

					renderObject .getGlobalObjects () .push (lightContainer);
					renderObject .getLights ()        .push (lightContainer);
				}
				else
				{
					lightContainer .set (renderObject .getBrowser (),
												this,
												group,
												renderObject .getModelViewMatrix () .get ());

					renderObject .getLocalObjects () .push (lightContainer);
					renderObject .getLights ()       .push (lightContainer);
				}
			}
			else
			{
				var lightContainer = renderObject .getLightContainer ();

				if (this .global_ .getValue ())
				{
					lightContainer .getModelViewMatrix () .pushMatrix (renderObject .getModelViewMatrix () .get ());

					renderObject .getGlobalObjects () .push (lightContainer);
					renderObject .getLights ()        .push (lightContainer);
				}
				else
				{
					lightContainer .getModelViewMatrix () .pushMatrix (renderObject .getModelViewMatrix () .get ());

					renderObject .getLocalObjects () .push (lightContainer);
					renderObject .getLights ()       .push (lightContainer);
				}
			}

			renderObject .pushShadow (this .shadowIntensity_ .getValue () > 0);
		},
		pop: function (renderObject)
		{
			if (this .global_ .getValue ())
				return;

			if (renderObject .isIndependent ())
				renderObject .getBrowser () .getLocalObjects () .push (renderObject .getLocalObjects () .pop ());
			else
				renderObject .getLocalObjects () .pop ();

			renderObject .popShadow ();
		},
	});

	return X3DLightNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/X3DBoundedObject',[
	"x_ite/Fields",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Geometry/Box3",
],
function (Fields,
          X3DCast,
          X3DConstants,
          Vector3,
          Box3)
{
"use strict";

	function X3DBoundedObject (executionContext)
	{
		this .addType (X3DConstants .X3DBoundedObject);

		this .addChildObjects ("transformSensors_changed", new Fields .SFTime ());

		this .bboxSize_   .setUnit ("length");
		this .bboxCenter_ .setUnit ("length");

		this .childBBox            = new Box3 (); // Must be unique for each X3DBoundedObject.
		this .transformSensorNodes = new Set ();
	}

	X3DBoundedObject .prototype =
	{
		constructor: X3DBoundedObject,
		initialize: function () { },
		getDefaultBBoxSize: (function ()
		{
			var defaultBBoxSize = new Vector3 (-1, -1, -1);

			return function ()
			{
				return defaultBBoxSize;
			};
		})(),
		getBBox: function (nodes, bbox)
		{
			bbox .set ();
	
			// Add bounding boxes

			for (var i = 0, length = nodes .length; i < length; ++ i)
			{
				var boundedObject = X3DCast (X3DConstants .X3DBoundedObject, nodes [i]);

				if (boundedObject)
					bbox .add (boundedObject .getBBox (this .childBBox));
			}

			return bbox;
		},
		addTransformSensor: function (transformSensorNode)
		{
			this .transformSensorNodes .add (transformSensorNode);

			this .transformSensors_changed_ = this .getBrowser () .getCurrentTime ();
		},
		removeTransformSensor: function (transformSensorNode)
		{
			this .transformSensorNodes .delete (transformSensorNode);

			this .transformSensors_changed_ = this .getBrowser () .getCurrentTime ();
		},
		getTransformSensors: function ()
		{
			return this .transformSensorNodes;
		},
	};

	return X3DBoundedObject;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/X3DGroupingNode',[
	"x_ite/Fields",
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Components/Grouping/X3DBoundedObject",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Box3",
],
function (Fields,
          X3DChildNode,
          X3DBoundedObject,
          TraverseType,
          X3DConstants,
          Box3)
{
"use strict";

	function getId (value) { return value ? value .getValue () .getId () : -1; }

	function remove (array, first, last, range, rfirst, rlast)
	{
		var set = { };

		for (var i = rfirst; i < rlast; ++ i)
			set [getId (range [i])] = true;

		function compare (value) { return set [getId (value)]; }

		return array .remove (first, last, compare);
	}

	var visible = new Fields .MFBool ();

	function X3DGroupingNode (executionContext)
	{
		X3DChildNode     .call (this, executionContext);
		X3DBoundedObject .call (this, executionContext);

		this .addType (X3DConstants .X3DGroupingNode);

		this .hidden                    = false;
		this .allowedTypes              = new Set ();
		this .pointingDeviceSensorNodes = [ ];
		this .maybeCameraObjects        = [ ];
		this .cameraObjects             = [ ];
		this .maybePickableSensorNodes  = [ ];
		this .pickableSensorNodes       = [ ];
		this .pickableObjects           = [ ];
		this .clipPlaneNodes            = [ ];
		this .localFogNodes             = [ ];
		this .lightNodes                = [ ];
		this .textureProjectorNodes     = [ ];
		this .displayNodes              = [ ];
		this .childNodes                = [ ];
	}

	X3DGroupingNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
		X3DBoundedObject .prototype,
	{
		constructor: X3DGroupingNode,
		initialize: function ()
		{
			X3DChildNode     .prototype .initialize .call (this);
			X3DBoundedObject .prototype .initialize .call (this);

			this .transformSensors_changed_ .addInterest ("set_pickableObjects__", this);

			this .addChildren_    .addInterest ("set_addChildren__",    this);
			this .removeChildren_ .addInterest ("set_removeChildren__", this);
			this .children_       .addInterest ("set_children__",       this);

			this .set_children__ ();
		},
		getBBox: function (bbox)
		{
			if (this .bboxSize_ .getValue () .equals (this .getDefaultBBoxSize ()))
				return X3DBoundedObject .prototype .getBBox .call (this, this .childNodes, bbox);

			return bbox .set (this .bboxSize_ .getValue (), this .bboxCenter_ .getValue ());
		},
		getSubBBox: function (bbox)
		{
			return X3DGroupingNode .prototype .getBBox .call (this, bbox);
		},
		setHidden: function (value)
		{
			if (value !== this .hidden)
			{
				this .hidden = value;

				this .set_children__ ();
			}
		},
		getVisible: function ()
		{
			return visible;
		},
		setAllowedTypes: function (type)
		{
			var allowedTypes = this .allowedTypes;

			allowedTypes .clear ();

			for (var i = 0, length = arguments .length; i < length; ++ i)
				allowedTypes .add (arguments [i]);
		},
		getChild: function (index)
		{
			// Used in LOD and Switch.

			try
			{
				if (index >= 0 && index < this .children_ .length)
				{
					var child = this .children_ [index];

					if (child)
						return child .getValue () .getInnerNode ();
				}
			}
			catch (error)
			{ }

			return null;
		},
		set_addChildren__: function ()
		{
			if (this .addChildren_ .length === 0)
				return;

			this .addChildren_ .setTainted (true);
			this .addChildren_ .erase (remove (this .addChildren_, 0, this .addChildren_ .length,
			                                   this .children_,    0, this .children_    .length),
			                           this .addChildren_ .length);

			if (! this .children_ .getTainted ())
			{
				this .children_ .removeInterest ("set_children__", this);
				this .children_ .addInterest ("connectChildren", this);
			}

			var first = this .children_ .length;

			this .children_ .insert (this .children_ .length, this .addChildren_, 0, this .addChildren_ .length);
			this .add (first, this .addChildren_);

			this .addChildren_ .set ([ ]);
			this .addChildren_ .setTainted (false);
		},
		set_removeChildren__: function ()
		{
			if (this .removeChildren_ .length === 0)
				return;

			if (this .children_ .length === 0)
				return;

			if (! this .children_ .getTainted ())
			{
				this .children_ .removeInterest ("set_children__", this);
				this .children_ .addInterest ("connectChildren", this);
			}

			this .children_ .erase (remove (this .children_,       0, this .children_ .length,
			                                this .removeChildren_, 0, this .removeChildren_ .length),
			                        this .children_ .length);

			this .remove (this .removeChildren_);

			this .removeChildren_ .set ([ ]);
		},
		set_children__: function ()
		{
			this .clear ();
			this .add (0, this .children_);
		},
		connectChildren: function ()
		{
			this .children_ .removeInterest ("connectChildren", this);
			this .children_ .addInterest ("set_children__", this);
		},
		add: function (first, children)
		{
			if (this .hidden)
				return;

			var
				visible    = this .getVisible (),
				numVisible = visible .length;

			for (var i = 0, v = first, length = children .length; i < length; ++ i, ++ v)
			{
				var child = children [i];

				if (child && (v >= numVisible || visible [v]))
				{
					try
					{
						var
							innerNode = child .getValue () .getInnerNode (),
							type      = innerNode .getType ();

						for (var t = type .length - 1; t >= 0; -- t)
						{
//							if (this .allowedTypes .size)
//							{
//								if (! innerNode .isType (this .allowedTypes))
//									continue;
//							}

							switch (type [t])
							{
								case X3DConstants .X3DPointingDeviceSensorNode:
								{
									this .pointingDeviceSensorNodes .push (innerNode);
									break;
								}
								case X3DConstants .ClipPlane:
								{
									this .clipPlaneNodes .push (innerNode);
									break;
								}
								case X3DConstants .LocalFog:
								{
									this .localFogNodes .push (innerNode);
									break;
								}
								case X3DConstants .X3DTextureProjectorNode:
								{
									this .textureProjectorNodes .push (innerNode);
									break;
								}
								case X3DConstants .X3DLightNode:
								{
									this .lightNodes .push (innerNode);
									break;
								}
								case X3DConstants .X3DBindableNode:
								{
									this .maybeCameraObjects .push (innerNode);
									break;
								}
								case X3DConstants .TransformSensor:
								case X3DConstants .X3DPickSensorNode:
								{
									innerNode .isPickableObject_ .addInterest ("set_pickableObjects__", this);

									this .maybePickableSensorNodes .push (innerNode);
									break;
								}
								case X3DConstants .X3DBackgroundNode:
								case X3DConstants .X3DChildNode:
								{
									innerNode .isCameraObject_   .addInterest ("set_cameraObjects__",   this);
									innerNode .isPickableObject_ .addInterest ("set_pickableObjects__", this);

									this .maybeCameraObjects .push (innerNode);
									this .childNodes .push (innerNode);
									break;
								}
								case X3DConstants .BooleanFilter:
								case X3DConstants .BooleanToggle:
								case X3DConstants .NurbsOrientationInterpolator:
								case X3DConstants .NurbsPositionInterpolator:
								case X3DConstants .NurbsSurfaceInterpolator:
								case X3DConstants .TimeSensor:
								case X3DConstants .X3DFollowerNode:
								case X3DConstants .X3DInfoNode:
								case X3DConstants .X3DInterpolatorNode:
								case X3DConstants .X3DKeyDeviceSensorNode:
								case X3DConstants .X3DLayoutNode:
								case X3DConstants .X3DScriptNode:
								case X3DConstants .X3DSequencerNode:
								case X3DConstants .X3DTriggerNode:
									break;
								default:
									continue;
							}

							break;
						}
					}
					catch (error)
					{ }
				}
			}

			this .set_cameraObjects__ ();
			this .set_pickableObjects__ ();
			this .set_display_nodes ();
		},
		remove: function (children)
		{
			for (var i = 0, length = children .length; i < length; ++ i)
			{
				var child = children [i];

				if (child)
				{
					try
					{
						var
							innerNode = child .getValue () .getInnerNode (),
							type      = innerNode .getType ();

						for (var t = type .length - 1; t >= 0; -- t)
						{
							switch (type [t])
							{
								case X3DConstants .X3DPointingDeviceSensorNode:
								{
									var index = this .pointingDeviceSensorNodes .indexOf (innerNode);

									if (index >= 0)
										this .pointingDeviceSensorNodes .splice (index, 1);

									break;
								}
								case X3DConstants .ClipPlane:
								{
									var index = this .clipPlaneNodes .indexOf (innerNode);

									if (index >= 0)
										this .clipPlaneNodes .splice (index, 1);

									break;
								}
								case X3DConstants .LocalFog:
								{
									var index = this .localFogNodes .indexOf (innerNode);

									if (index >= 0)
										this .localFogNodes .splice (index, 1);

									break;
								}
								case X3DConstants .X3DTextureProjectorNode:
								{
									var index = this .textureProjectorNodes .indexOf (innerNode);

									if (index >= 0)
										this .textureProjectorNodes .splice (index, 1);

									break;
								}
								case X3DConstants .X3DLightNode:
								{
									var index = this .lightNodes .indexOf (innerNode);

									if (index >= 0)
										this .lightNodes .splice (index, 1);

									break;
								}
								case X3DConstants .X3DBindableNode:
								{
									var index = this .maybeCameraObjects .indexOf (innerNode);

									if (index >= 0)
										this .maybeCameraObjects .splice (index, 1);

									break;
								}
								case X3DConstants .TransformSensor:
								case X3DConstants .X3DPickSensorNode:
								{
									innerNode .isPickableObject_ .removeInterest ("set_pickableObjects__", this);

									var index = this .maybePickableSensorNodes .indexOf (innerNode);

									if (index >= 0)
										this .maybePickableSensorNodes .splice (index, 1);

									break;
								}
								case X3DConstants .X3DBackgroundNode:
								case X3DConstants .X3DChildNode:
								{
									innerNode .isCameraObject_   .removeInterest ("set_cameraObjects__",   this);
									innerNode .isPickableObject_ .removeInterest ("set_pickableObjects__", this);

									var index = this .maybeCameraObjects .indexOf (innerNode);

									if (index >= 0)
										this .maybeCameraObjects .splice (index, 1);

									var index = this .childNodes .indexOf (innerNode);

									if (index >= 0)
										this .childNodes .splice (index, 1);

									break;
								}
								case X3DConstants .BooleanFilter:
								case X3DConstants .BooleanToggle:
								case X3DConstants .NurbsOrientationInterpolator:
								case X3DConstants .NurbsPositionInterpolator:
								case X3DConstants .NurbsSurfaceInterpolator:
								case X3DConstants .TimeSensor:
								case X3DConstants .X3DFollowerNode:
								case X3DConstants .X3DInfoNode:
								case X3DConstants .X3DInterpolatorNode:
								case X3DConstants .X3DKeyDeviceSensorNode:
								case X3DConstants .X3DLayoutNode:
								case X3DConstants .X3DScriptNode:
								case X3DConstants .X3DSequencerNode:
								case X3DConstants .X3DTriggerNode:
									break;
								default:
									continue;
							}

							break;
						}
					}
					catch (error)
					{ }
				}
			}

			this .set_cameraObjects__ ();
			this .set_pickableObjects__ ();
			this .set_display_nodes ();
		},
		clear: function ()
		{
			var
				maybePickableSensorNodes = this .maybePickableSensorNodes,
				childNodes               = this .childNodes;

			for (var i = 0, length = maybePickableSensorNodes .length; i < length; ++ i)
				maybePickableSensorNodes [i] .isPickableObject_ .removeInterest ("set_pickableObjects__", this);

			for (var i = 0, length = childNodes .length; i < length; ++ i)
			{
				var childNode = childNodes [i];

				childNode .isCameraObject_   .removeInterest ("set_cameraObjects__",   this);
				childNode .isPickableObject_ .removeInterest ("set_pickableObjects__", this);
			}

			this .pointingDeviceSensorNodes .length = 0;
			this .maybeCameraObjects        .length = 0;
			this .clipPlaneNodes            .length = 0;
			this .localFogNodes             .length = 0;
			this .lightNodes                .length = 0;
			this .textureProjectorNodes     .length = 0;
			this .maybePickableSensorNodes  .length = 0;
			this .childNodes                .length = 0;
		},
		set_cameraObjects__: function ()
		{
			var
				maybeCameraObjects = this .maybeCameraObjects,
				cameraObjects      = this .cameraObjects;

			cameraObjects .length = 0;

			for (var i = 0, length = maybeCameraObjects .length; i < length; ++ i)
			{
				var childNode = maybeCameraObjects [i];

				if (childNode .getCameraObject ())
					cameraObjects .push (childNode);
			}

			this .setCameraObject (Boolean (cameraObjects .length));
		},
		set_pickableObjects__: function ()
		{
			var
				maybePickableSensorNodes = this .maybePickableSensorNodes,
				pickableSensorNodes      = this .pickableSensorNodes,
				pickableObjects          = this .pickableObjects,
				childNodes               = this .childNodes;

			pickableSensorNodes .length = 0;
			pickableObjects     .length = 0;

			for (var i = 0, length = maybePickableSensorNodes .length; i < length; ++ i)
			{
				var sensorNode = maybePickableSensorNodes [i];

				if (sensorNode .getPickableObject ())
					pickableSensorNodes .push (sensorNode);
			}

			for (var i = 0, length = childNodes .length; i < length; ++ i)
			{
				var childNode = childNodes [i];

				if (childNode .getPickableObject ())
					pickableObjects .push (childNode);
			}

			this .setPickableObject (Boolean (this .getTransformSensors () .size || pickableSensorNodes .length || pickableObjects .length));
		},
		set_display_nodes: function ()
		{
			var
				clipPlaneNodes        = this .clipPlaneNodes,
				localFogNodes         = this .localFogNodes,
				lightNodes            = this .lightNodes,
				textureProjectorNodes = this .textureProjectorNodes,
				displayNodes          = this .displayNodes;

			displayNodes .length = 0;

			for (var i = 0, length = clipPlaneNodes .length; i < length; ++ i)
				displayNodes .push (clipPlaneNodes [i]);

			for (var i = 0, length = localFogNodes .length; i < length; ++ i)
				displayNodes .push (localFogNodes [i]);

			for (var i = 0, length = lightNodes .length; i < length; ++ i)
				displayNodes .push (lightNodes [i]);

			for (var i = 0, length = textureProjectorNodes .length; i < length; ++ i)
				displayNodes .push (textureProjectorNodes [i]);
		},
		traverse: (function ()
		{
			var bbox = new Box3 ();

			return function (type, renderObject)
			{
				switch (type)
				{
					case TraverseType .POINTER:
					{
						var
							pointingDeviceSensorNodes = this .pointingDeviceSensorNodes,
							clipPlaneNodes            = this .clipPlaneNodes,
							childNodes                = this .childNodes;

						if (pointingDeviceSensorNodes .length)
						{
							var sensors = { };

							renderObject .getBrowser () .getSensors () .push (sensors);

							for (var i = 0, length = pointingDeviceSensorNodes .length; i < length; ++ i)
								pointingDeviceSensorNodes [i] .push (renderObject, sensors);
						}

						for (var i = 0, length = clipPlaneNodes .length; i < length; ++ i)
							clipPlaneNodes [i] .push (renderObject);

						for (var i = 0, length = childNodes .length; i < length; ++ i)
							childNodes [i] .traverse (type, renderObject);

						for (var i = clipPlaneNodes .length - 1; i >= 0; -- i)
							clipPlaneNodes [i] .pop (renderObject);

						if (pointingDeviceSensorNodes .length)
							renderObject .getBrowser () .getSensors () .pop ();

						return;
					}
					case TraverseType .CAMERA:
					{
						var cameraObjects = this .cameraObjects;

						for (var i = 0, length = cameraObjects .length; i < length; ++ i)
							cameraObjects [i] .traverse (type, renderObject);

						return;
					}
					case TraverseType .PICKING:
					{
						if (this .getTransformSensors () .size)
						{
							this .getSubBBox (bbox) .multRight (renderObject .getModelViewMatrix () .get ());

							this .getTransformSensors () .forEach (function (transformSensorNode)
							{
								transformSensorNode .collect (bbox);
							});
						}

						var pickableSensorNodes = this .pickableSensorNodes;

						for (var i = 0, length = pickableSensorNodes .length; i < length; ++ i)
							pickableSensorNodes [i] .traverse (type, renderObject);

						var
							browser          = renderObject .getBrowser (),
							pickingHierarchy = browser .getPickingHierarchy (),
							pickableStack    = browser .getPickable ();

						pickingHierarchy .push (this);

						if (pickableStack [pickableStack .length - 1])
						{
							var childNodes = this .childNodes;

							for (var i = 0, length = childNodes .length; i < length; ++ i)
								childNodes [i] .traverse (type, renderObject);
						}
						else
						{
							var pickableObjects = this .pickableObjects;

							for (var i = 0, length = pickableObjects .length; i < length; ++ i)
								pickableObjects [i] .traverse (type, renderObject);
						}

						pickingHierarchy .pop ();
						return;
					}
					case TraverseType .COLLISION:
					case TraverseType .DEPTH:
					{
						var
							clipPlaneNodes = this .clipPlaneNodes,
							childNodes     = this .childNodes;

						for (var i = 0, length = clipPlaneNodes .length; i < length; ++ i)
							clipPlaneNodes [i] .push (renderObject);

						for (var i = 0, length = childNodes .length; i < length; ++ i)
							childNodes [i] .traverse (type, renderObject);

						for (var i = clipPlaneNodes .length - 1; i >= 0; -- i)
							clipPlaneNodes [i] .pop (renderObject);

						return;
					}
					case TraverseType .DISPLAY:
					{

						var
							displayNodes = this .displayNodes,
							childNodes   = this .childNodes;

						for (var i = 0, length = displayNodes .length; i < length; ++ i)
							displayNodes [i] .push (renderObject, this);

						for (var i = 0, length = childNodes .length; i < length; ++ i)
							childNodes [i] .traverse (type, renderObject);

						for (var i = displayNodes .length - 1; i >= 0; -- i)
							displayNodes [i] .pop (renderObject);

						return;
					}
				}
			};
		})(),
	});

	return X3DGroupingNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Utility/MatrixStack',[],function ()
{
"use strict";

	function MatrixStack (Type)
	{
		return Object .assign ([ new Type () ],
		{
			top: 0,
			set: function (matrix)
			{
				this [this .top] .assign (matrix);
			},
			get: function (matrix)
			{
				return this [this .top];
			},
			push: function ()
			{
				var top = ++ this .top;
			
				if (top < this .length)
					this [top] .assign (this [top - 1]);
				else
					this [top] = this [top - 1] .copy ();
			},
			pushMatrix: function (matrix)
			{
				var top = ++ this .top;

				if (top < this .length)
					this [top] .assign (matrix);
				else
					this [top] = matrix .copy ();
			},
			pop: function ()
			{
				-- this .top;
			},
			clear: function ()
			{
				this .top = 0;
			},
			size: function ()
			{
				return this .top + 1;
			},
			identity: function ()
			{
				this [this .top] .identity ();
			},
			multLeft: function (matrix)
			{
				this [this .top] .multLeft (matrix);
			},
			translate: function (vector)
			{
				this [this .top] .translate (vector);
			},
			rotate: function (rotation)
			{
				this [this .top] .rotate (rotation);
			},
			scale: function (vector)
			{
				this [this .top] .scale (vector);
			},
		});
	}

	return MatrixStack;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Utility/ObjectCache',[],function ()
{
"use strict";

   return function (Type)
   {
	   return {
	      stack: [ ],
	      last: -1,
	      pop: function ()
	      {
				if (this .last > -1)
				{
					var object = this .stack [this .last];
				
					this .last --;

	            return object;
				}

				return new Type ();
	      },
			push: function (object)
	      {
	         this .last ++;
	         return this .stack [this .last] = object;
	      },
			clear: function ()
			{
			   this .stack .length = 0;
			   this .last          = -1;
			},
	   };
   };
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting/DirectionalLight',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Lighting/X3DLightNode",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Box3",
	"standard/Math/Geometry/Camera",
	"standard/Math/Geometry/ViewVolume",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Utility/MatrixStack",
	"standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLightNode,
          X3DGroupingNode,
          TraverseType,
          X3DConstants,
          Box3,
          Camera,
          ViewVolume,
          Vector3,
          Vector4,
          Rotation4,
          Matrix4,
          MatrixStack,
          ObjectCache)
{
"use strict";

	var DirectionalLights = ObjectCache (DirectionalLightContainer);
	
	function DirectionalLightContainer ()
	{
		this .direction                     = new Vector3 (0, 0, 0);
		this .shadowBuffer                  = null;
		this .bbox                          = new Box3 ();
		this .viewVolume                    = new ViewVolume ();
		this .viewport                      = new Vector4 (0, 0, 0, 0);
		this .projectionMatrix              = new Matrix4 ();
		this .modelViewMatrix               = new MatrixStack (Matrix4);
		this .modelMatrix                   = new Matrix4 ();
		this .invLightSpaceMatrix           = new Matrix4 ();
		this .invLightSpaceProjectionMatrix = new Matrix4 ();
		this .shadowMatrix                  = new Matrix4 ();
		this .shadowMatrixArray             = new Float32Array (16);
		this .rotation                      = new Rotation4 ();
		this .textureUnit                   = 0;
	}

	DirectionalLightContainer .prototype =
	{
		constructor: DirectionalLightContainer,
		getModelViewMatrix: function ()
		{
			return this .modelViewMatrix;
		},
		set: function (browser, lightNode, groupNode, modelViewMatrix)
		{
			var
				gl            = browser .getContext (),
				shadowMapSize = lightNode .getShadowMapSize ();

			this .browser   = browser;
			this .lightNode = lightNode;
			this .groupNode = groupNode;

			this .modelViewMatrix .pushMatrix (modelViewMatrix);

			// Get shadow buffer from browser.

			if (lightNode .getShadowIntensity () > 0 && shadowMapSize > 0)
			{
				this .shadowBuffer = browser .popShadowBuffer (shadowMapSize);

				if (this .shadowBuffer)
				{
					if (browser .getCombinedTextureUnits () .length)
					{
						this .textureUnit = browser .getCombinedTextureUnits () .pop ();

						gl .activeTexture (gl .TEXTURE0 + this .textureUnit);

						if (gl .getVersion () >= 2 || browser .getExtension ("WEBGL_depth_texture"))
							gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getDepthTexture ());
						else
							gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getColorTexture ());

						gl .activeTexture (gl .TEXTURE0);
					}
					else
					{
						console .warn ("Not enough combined texture units for shadow map available.");
					}
				}
				else
				{
					console .warn ("Couldn't create shadow buffer.");
				}
			}
		},
		renderShadowMap: function (renderObject)
		{
			try
			{
				if (! this .shadowBuffer)
					return;

				var
					lightNode            = this .lightNode,
					cameraSpaceMatrix    = renderObject .getCameraSpaceMatrix () .get (),
					modelMatrix          = this .modelMatrix .assign (this .modelViewMatrix .get ()) .multRight (cameraSpaceMatrix),
					invLightSpaceMatrix  = this .invLightSpaceMatrix .assign (lightNode .getGlobal () ? modelMatrix : Matrix4 .Identity);

				invLightSpaceMatrix .rotate (this .rotation .setFromToVec (Vector3 .zAxis, this .direction .assign (lightNode .getDirection ()) .negate ()));
				invLightSpaceMatrix .inverse ();

				var
					groupBBox        = X3DGroupingNode .prototype .getBBox .call (this .groupNode, this .bbox), // Group bbox.
					lightBBox        = groupBBox .multRight (invLightSpaceMatrix),                              // Group bbox from the perspective of the light.
					shadowMapSize    = lightNode .getShadowMapSize (),
					viewport         = this .viewport .set (0, 0, shadowMapSize, shadowMapSize),
					projectionMatrix = Camera .orthoBox (lightBBox, this .projectionMatrix);

				this .shadowBuffer .bind ();

				renderObject .getViewVolumes      () .push (this .viewVolume .set (projectionMatrix, viewport, viewport));
				renderObject .getProjectionMatrix () .pushMatrix (projectionMatrix);
				renderObject .getModelViewMatrix  () .pushMatrix (invLightSpaceMatrix);

				renderObject .render (TraverseType .DEPTH, X3DGroupingNode .prototype .traverse, this .groupNode);

				renderObject .getModelViewMatrix  () .pop ();
				renderObject .getProjectionMatrix () .pop ();
				renderObject .getViewVolumes      () .pop ();

				this .shadowBuffer .unbind ();
	
				if (! lightNode .getGlobal ())
					invLightSpaceMatrix .multLeft (modelMatrix .inverse ());

				this .invLightSpaceProjectionMatrix .assign (invLightSpaceMatrix) .multRight (projectionMatrix) .multRight (lightNode .getBiasMatrix ());
			}
			catch (error)
			{
				// Catch error from matrix inverse.
				console .log (error);
			}
		},
		setGlobalVariables: function (renderObject)
		{
			this .modelViewMatrix .get () .multDirMatrix (this .direction .assign (this .lightNode .getDirection ())) .normalize ();

			this .shadowMatrix .assign (renderObject .getCameraSpaceMatrix () .get ()) .multRight (this .invLightSpaceProjectionMatrix);
			this .shadowMatrixArray .set (this .shadowMatrix);
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			var i = shaderObject .numLights ++;

			if (shaderObject .hasLight (i, this))
				return;

			var
				lightNode = this .lightNode,
				color     = lightNode .getColor (),
				direction = this .direction;

			gl .uniform1i (shaderObject .x3d_LightType [i],             1);
			gl .uniform3f (shaderObject .x3d_LightColor [i],            color .r, color .g, color .b);
			gl .uniform1f (shaderObject .x3d_LightIntensity [i],        lightNode .getIntensity ());
			gl .uniform1f (shaderObject .x3d_LightAmbientIntensity [i], lightNode .getAmbientIntensity ());
			gl .uniform3f (shaderObject .x3d_LightDirection [i],        direction .x, direction .y, direction .z);

			if (this .textureUnit)
			{
				var shadowColor = lightNode .getShadowColor ();

				gl .uniform3f        (shaderObject .x3d_ShadowColor [i],         shadowColor .r, shadowColor .g, shadowColor .b);
				gl .uniform1f        (shaderObject .x3d_ShadowIntensity [i],     lightNode .getShadowIntensity ());
				gl .uniform1f        (shaderObject .x3d_ShadowBias [i],          lightNode .getShadowBias ());
				gl .uniformMatrix4fv (shaderObject .x3d_ShadowMatrix [i], false, this .shadowMatrixArray);
				gl .uniform1i        (shaderObject .x3d_ShadowMapSize [i],       lightNode .getShadowMapSize ());
				gl .uniform1i        (shaderObject .x3d_ShadowMap [i],           this .textureUnit);
			}
			else
			{
				// Must be set to zero in case of multiple lights.
				gl .uniform1f (shaderObject .x3d_ShadowIntensity [i], 0);			
			}
		},
		dispose: function ()
		{
			// Return shadowBuffer and textureUnit.

			if (this .textureUnit)
				this .browser .getCombinedTextureUnits () .push (this .textureUnit);

			this .browser .pushShadowBuffer (this .shadowBuffer);
			this .modelViewMatrix .clear ();

			this .browser      = null;
			this .lightNode    = null;
			this .groupNode    = null;
			this .shadowBuffer = null;
			this .textureUnit  = 0;

			// Return container

		   DirectionalLights .push (this);
		},
	};

	function DirectionalLight (executionContext)
	{
		X3DLightNode .call (this, executionContext);

		this .addType (X3DConstants .DirectionalLight);

		this .global_ = false;
	}

	DirectionalLight .prototype = Object .assign (Object .create (X3DLightNode .prototype),
	{
		constructor: DirectionalLight,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "global",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "on",               new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",            new Fields .SFColor (1, 1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "intensity",        new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "ambientIntensity", new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "direction",        new Fields .SFVec3f (0, 0, -1)),

			new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowColor",     new  Fields .SFColor ()),        // Color of shadow.
			new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowIntensity", new  Fields .SFFloat ()),        // Intensity of shadow color in the range (0, 1).
			new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowBias",      new  Fields .SFFloat (0.005)),   // Bias of the shadow.
			new X3DFieldDefinition (X3DConstants .initializeOnly, "shadowMapSize",   new  Fields .SFInt32 (1024)),    // Size of the shadow map in pixels in the range (0, inf).
		]),
		getTypeName: function ()
		{
			return "DirectionalLight";
		},
		getComponentName: function ()
		{
			return "Lighting";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getLights: function ()
		{
			return DirectionalLights;
		},
	});

	return DirectionalLight;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Navigation/X3DNavigationContext',[
	"x_ite/Fields",
	"x_ite/Browser/Navigation/ExamineViewer",
	"x_ite/Browser/Navigation/WalkViewer",
	"x_ite/Browser/Navigation/FlyViewer",
	"x_ite/Browser/Navigation/PlaneViewer",
	"x_ite/Browser/Navigation/NoneViewer",
	"x_ite/Browser/Navigation/LookAtViewer",
	"x_ite/Components/Lighting/DirectionalLight",
	"standard/Math/Numbers/Matrix4",
],
function (Fields,
          ExamineViewer,
          WalkViewer,
          FlyViewer,
          PlaneViewer,
          NoneViewer,
          LookAtViewer,
          DirectionalLight,
          Matrix4)
{
"use strict";
	
	function getHeadLight (browser)
	{
		var headlight = new DirectionalLight (browser .getPrivateScene ());

		headlight .setup ();

		var headlightContainer = headlight .getLights () .pop ();

		headlightContainer .set (browser, headlight, null, Matrix4 .Identity);
		headlightContainer .dispose = function () { };

		return headlightContainer;
	};

	function X3DNavigationContext ()
	{
		this .addChildObjects ("activeLayer",          new Fields .SFNode (),
		                       "activeNavigationInfo", new Fields .SFNode (),
		                       "activeViewpoint",      new Fields .SFNode (),
		                       "availableViewers",     new Fields .MFString (),
		                       "viewer",               new Fields .SFString ("EXAMINE"));
		
		this .activeCollisions = new Set ();
		this .viewerNode       = new NoneViewer (this);
	}

	X3DNavigationContext .prototype =
	{
		initialize: function ()
		{
			this .viewer_ .addInterest ("set_viewer__", this);

			this .initialized () .addInterest ("set_world__",    this);
			this .shutdown ()    .addInterest ("remove_world__", this);

			this .headlightContainer = getHeadLight (this);
			this .viewerNode .setup ();
		},
		getHeadlight: function ()
		{
			return this .headlightContainer;
		},
		getActiveLayer: function ()
		{
			return this .activeLayer_ .getValue ();
		},
		getActiveNavigationInfo: function ()
		{
			return this .activeNavigationInfo_ .getValue ();
		},
		getActiveViewpoint: function ()
		{
			return this .activeViewpoint_ .getValue ();
		},
		getCurrentViewer: function ()
		{
			return this .viewer_ .getValue ();
		},
		getViewer: function ()
		{
			return this .viewerNode;
		},
		addCollision: function (object)
		{
			this .activeCollisions .add (object);
		},
		removeCollision: function (object)
		{
			this .activeCollisions .delete (object);
		},
		getCollisionCount: function ()
		{
			return this .activeCollisions .size;
		},
		remove_world__: function ()
		{
			this .getWorld () .activeLayer_ .removeInterest ("set_activeLayer__", this);
		},
		set_world__: function ()
		{
			this .getWorld () .activeLayer_ .addInterest ("set_activeLayer__", this);

			this .set_activeLayer__ ();
		},
		set_activeLayer__: function ()
		{
			if (this .activeLayer_ .getValue ())
			{
				this .activeLayer_ .getValue () .getNavigationInfoStack () .removeInterest ("set_activeNavigationInfo__", this);
				this .activeLayer_ .getValue () .getViewpointStack ()      .removeInterest ("set_activeViewpoint__",      this);
			}

			this .activeLayer_ = this .getWorld () .getActiveLayer ();

			if (this .activeLayer_ .getValue ())
			{
				this .activeLayer_ .getValue () .getNavigationInfoStack () .addInterest ("set_activeNavigationInfo__", this);
				this .activeLayer_ .getValue () .getViewpointStack ()      .addInterest ("set_activeViewpoint__",      this);
			}

			this .set_activeNavigationInfo__ ();
			this .set_activeViewpoint__ ();
		},
		set_activeNavigationInfo__: function ()
		{
			if (this .activeNavigationInfo_ .getValue ())
				this .activeNavigationInfo_ .getValue () .viewer_ .removeFieldInterest (this .viewer_);

			if (this .activeLayer_ .getValue ())
			{
				this .activeNavigationInfo_ = this .activeLayer_ .getValue () .getNavigationInfo ();
	
				this .activeNavigationInfo_ .getValue () .viewer_ .addFieldInterest (this .viewer_);
	
				this .viewer_ = this .activeNavigationInfo_ .getValue () .viewer_;
			}
			else
			{
				this .activeNavigationInfo_ = null;
				this .viewer_               = "NONE";
			}
		},
		set_activeViewpoint__: function ()
		{
			if (this .activeLayer_ .getValue ())
				this .activeViewpoint_ = this .activeLayer_ .getValue () .getViewpoint ();
			else
				this .activeViewpoint_ = null;
		},
		set_viewer__: function (viewer)
		{
			if (this .activeNavigationInfo_ .getValue ())
				this .availableViewers_ = this .activeNavigationInfo_ .getValue () .availableViewers_;
			else
				this .availableViewers_ .length = 0;

			// Create viewer node.

			if (this .viewerNode)
				this .viewerNode .dispose ();

			switch (viewer .getValue ())
			{
				case "EXAMINE":
					this .viewerNode = new ExamineViewer (this);
					break;
				case "WALK":
					this .viewerNode = new WalkViewer (this);
					break;
				case "FLY":
					this .viewerNode = new FlyViewer (this);
					break;
				case "PLANE":
				case "PLANE_create3000.de":
					this .viewerNode = new PlaneViewer (this);
					break;
				case "NONE":
					this .viewerNode = new NoneViewer (this);
					break;
				case "LOOKAT":
					this .viewerNode = new LookAtViewer (this);
					break;
				default:
					this .viewerNode = new ExamineViewer (this);
					break;
			}

			this .viewerNode .setup ();
		},
	};

	return X3DNavigationContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/X3DViewportNode',[
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DGroupingNode, 
          X3DConstants)
{
"use strict";

	function X3DViewportNode (executionContext)
	{
		X3DGroupingNode .call (this, executionContext);

		this .addType (X3DConstants .X3DViewportNode);
	}

	X3DViewportNode .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
	{
		constructor: X3DViewportNode,
	});

	return X3DViewportNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/Viewport',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Layering/X3DViewportNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Bits/TraverseType",
	"standard/Utility/ObjectCache",
	"standard/Math/Geometry/ViewVolume",
	"standard/Math/Numbers/Vector4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DViewportNode, 
          X3DConstants,
          TraverseType,
          ObjectCache,
          ViewVolume,
          Vector4)
{
"use strict";

	var ViewVolumes = ObjectCache (ViewVolume);

	function Viewport (executionContext)
	{
		X3DViewportNode .call (this, executionContext);

		this .addType (X3DConstants .Viewport);

		this .rectangle = new Vector4 (0, 0, 0, 0);
	}

	Viewport .prototype = Object .assign (Object .create (X3DViewportNode .prototype),
	{
		constructor: Viewport,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "clipBoundary",   new Fields .MFFloat (0, 1, 0, 1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "Viewport";
		},
		getComponentName: function ()
		{
			return "Layering";
		},
		getContainerField: function ()
		{
			return "viewport";
		},
		getRectangle: function (browser)
		{
			var viewport = browser .getViewport ();

			var
				left   = Math .floor (viewport [2] * this .getLeft ()),
				right  = Math .floor (viewport [2] * this .getRight ()),
				bottom = Math .floor (viewport [3] * this .getBottom ()),
				top    = Math .floor (viewport [3] * this .getTop ());

			this .rectangle .set (left,
			                      bottom,
			                      Math .max (0, right - left),
			                      Math .max (0, top - bottom));

			return this .rectangle;
		},
		getLeft: function ()
		{
			return this .clipBoundary_ .length > 0 ? this .clipBoundary_ [0] : 0;
		},
		getRight: function ()
		{
			return this .clipBoundary_ .length > 1 ? this .clipBoundary_ [1] : 1;
		},
		getBottom: function ()
		{
			return this .clipBoundary_ .length > 2 ? this .clipBoundary_ [2] : 0;
		},
		getTop: function ()
		{
			return this .clipBoundary_ .length > 3 ? this .clipBoundary_ [3] : 1;
		},
		traverse: function (type, renderObject)
		{
			this .push (renderObject);

			switch (type)
			{
				case TraverseType .POINTER:
				{
					if (renderObject .getBrowser () .isPointerInRectangle (this .rectangle))
						X3DViewportNode .prototype .traverse .call (this, type, renderObject);

					break;
				}
				default:
					X3DViewportNode .prototype .traverse .call (this, type, renderObject);
					break;
			}

			this .pop (renderObject);
		},
		push: function (renderObject)
		{
			var
				viewVolumes = renderObject .getViewVolumes (),
				rectangle   = this .getRectangle (renderObject .getBrowser ()),
				viewport    = viewVolumes .length ? viewVolumes [viewVolumes .length - 1] .getViewport () : rectangle,
				viewVolume  = ViewVolumes .pop ();

			viewVolume .set (renderObject .getProjectionMatrix () .get (), viewport, rectangle);

			viewVolumes .push (viewVolume);
		},
		pop: function (renderObject)
		{
			ViewVolumes .push (renderObject .getViewVolumes () .pop ());
		},
	});

	return Viewport;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Layering/X3DLayeringContext',[
	"x_ite/Components/Layering/Viewport",
],
function (Viewport)
{
"use strict";
	
	function X3DLayeringContext ()
	{
		this .defaultViewport = new Viewport (this .getPrivateScene ());
	}

	X3DLayeringContext .prototype =
	{
		initialize: function ()
		{
			this .defaultViewport .setup ();
		},
		getDefaultViewport: function ()
		{
			return this .defaultViewport;
		},
	};

	return X3DLayeringContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/EnvironmentalEffects/X3DEnvironmentalEffectsContext',[
	"x_ite/Components/Texturing/TextureProperties",
],
function (TextureProperties)
{
"use strict";

	function X3DEnvironmentalEffectsContext ()
	{ }

	X3DEnvironmentalEffectsContext .prototype =
	{
		initialize: function () { },
		getBackgroundSphereShader: function ()
		{
			if (this .backgroundSphereShader)
				return this .backgroundSphereShader;

			this .backgroundSphereShader = this .createShader ("BackgroundSphereShader", "Background", false);

			return this .backgroundSphereShader;
		},
		getBackgroundTextureProperties: function ()
		{
			if (this .backgroundTextureProperties)
				return this .backgroundTextureProperties;

			this .backgroundTextureProperties = new TextureProperties (this .getPrivateScene ());

			this .backgroundTextureProperties .boundaryModeS_       = "CLAMP_TO_EDGE";
			this .backgroundTextureProperties .boundaryModeT_       = "CLAMP_TO_EDGE";
			this .backgroundTextureProperties .boundaryModeR_       = "CLAMP_TO_EDGE";
			this .backgroundTextureProperties .minificationFilter_  = "NICEST";
			this .backgroundTextureProperties .magnificationFilter_ = "NICEST";
			this .backgroundTextureProperties .setup ();

			return this .backgroundTextureProperties;
		},
	};

	return X3DEnvironmentalEffectsContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Lighting/X3DLightingContext',[
	"x_ite/Rendering/TextureBuffer",
],
function (TextureBuffer)
{
"use strict";

	function X3DLightingContext ()
	{
		var
			gl                    = this .getContext (),
			maxVertexTextureUnits = gl .getParameter (gl .MAX_VERTEX_TEXTURE_IMAGE_UNITS);

		if (maxVertexTextureUnits > 16)
			this .maxLights = 8;
		else if (maxVertexTextureUnits > 8)
			this .maxLights = 4;
		else
			this .maxLights = 2;

		this .shadowBuffers = [ ]; // Shadow buffer cache
	}

	X3DLightingContext .prototype =
	{
		initialize: function ()
		{ },
		getMaxLights: function ()
		{
			return this .maxLights;
		},
		popShadowBuffer: function (shadowMapSize)
		{
			try
			{
				var shadowBuffers = this .shadowBuffers [shadowMapSize];

				if (shadowBuffers)
				{
					if (shadowBuffers .length)
						return shadowBuffers .pop ();
				}
				else
					this .shadowBuffers [shadowMapSize] = [ ];

				return new TextureBuffer (this, shadowMapSize, shadowMapSize);
			}
			catch (error)
			{
				// Couldn't create texture buffer.
				console .log (error);

				return null;
			}
		},
		pushShadowBuffer: function (buffer)
		{
			if (buffer)
				this .shadowBuffers [buffer .getWidth ()] .push (buffer);
		},
	};

	return X3DLightingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Picking/X3DPickingContext',[
	"x_ite/Bits/TraverseType",
],
function (TraverseType)
{
"use strict";

	function X3DPickingContext ()
	{
		this .transformSensorNodes = new Set ();
		this .pickSensorNodes      = [ new Set () ];
		this .pickingHierarchy     = [ ];
		this .pickable             = [ false ];
		this .pickingTime          = 0;
	}

	X3DPickingContext .prototype =
	{
		initialize: function ()
		{ },
		addTransformSensor: function (transformSensorNode)
		{
			this .transformSensorNodes .add (transformSensorNode);
			this .enablePicking ();
		},
		removeTransformSensor: function (transformSensorNode)
		{
			this .transformSensorNodes .delete (transformSensorNode);
			this .enablePicking ();
		},
		addPickSensor: function (pickSensorNode)
		{
			this .pickSensorNodes [0] .add (pickSensorNode);
			this .enablePicking ();
		},
		removePickSensor: function (pickSensorNode)
		{
			this .pickSensorNodes [0] .delete (pickSensorNode);
			this .enablePicking ();
		},
		getPickSensors: function ()
		{
			return this .pickSensorNodes;
		},
		getPickingHierarchy: function ()
		{
			return this .pickingHierarchy;
		},
		getPickable: function ()
		{
			return this .pickable;
		},
		enablePicking: function ()
		{
			if (this .transformSensorNodes .size || this .pickSensorNodes [0] .size)
				this .sensorEvents_ .addInterest ("picking", this);
			else
				this .sensorEvents_ .removeInterest ("picking", this);
		},
		picking: function ()
		{
			var t0 = performance .now ();
		
			this .getWorld () .traverse (TraverseType .PICKING, null);

			this .transformSensorNodes .forEach (function (transformSensorNode)
			{
				transformSensorNode .process ();
			});

			this .pickSensorNodes [0] .forEach (function (pickSensorNode)
			{
				pickSensorNode .process ();
			});

			this .pickingTime = performance .now () - t0;
		},
	};

	return X3DPickingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Sound/X3DSoundContext',[
	"x_ite/Fields",
],
function (Fields)
{
"use strict";

	function X3DSoundContext ()
	{
		this .addChildObjects ("volume", new Fields .SFFloat (1),
		                       "mute",   new Fields .SFBool ());
	}

	X3DSoundContext .prototype =
	{
		initialize: function () { },
	};

	return X3DSoundContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Text/TextAlignment',[],function ()
{
"use strict";
	
	var i = 0;

	var TextAlignment =
	{
	   BEGIN:  ++ i,
	   FIRST:  ++ i,
	   MIDDLE: ++ i,
	   END:    ++ i,
	};

	Object .preventExtensions (TextAlignment);
	Object .freeze (TextAlignment);
	Object .seal (TextAlignment);

	return TextAlignment;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Text/X3DFontStyleNode',[
	"x_ite/Fields",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Networking/X3DUrlObject",
	"x_ite/Browser/Text/TextAlignment",
	"x_ite/InputOutput/FileLoader",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Networking/urls",
],
function (Fields,
          X3DNode,
          X3DUrlObject,
          TextAlignment,
          FileLoader,
          X3DConstants,
          urls)
{
"use strict";

	/*
	 * Font paths for default SERIF, SANS and TYPWRITER families.
	 */

	var Fonts =
	{
		SERIF: {
			PLAIN:      urls .getFontsUrl ("DroidSerif-Regular.ttf"),
			ITALIC:     urls .getFontsUrl ("DroidSerif-Italic.ttf"),
			BOLD:       urls .getFontsUrl ("DroidSerif-Bold.ttf"),
			BOLDITALIC: urls .getFontsUrl ("DroidSerif-BoldItalic.ttf"),
		},
		SANS: {
			PLAIN:      urls .getFontsUrl ("Ubuntu-R.ttf"),
			ITALIC:     urls .getFontsUrl ("Ubuntu-RI.ttf"),
			BOLD:       urls .getFontsUrl ("Ubuntu-B.ttf"),
			BOLDITALIC: urls .getFontsUrl ("Ubuntu-BI.ttf"),
		},
		TYPEWRITER: {
			PLAIN:      urls .getFontsUrl ("UbuntuMono-R.ttf"),
			ITALIC:     urls .getFontsUrl ("UbuntuMono-RI.ttf"),
			BOLD:       urls .getFontsUrl ("UbuntuMono-B.ttf"),
			BOLDITALIC: urls .getFontsUrl ("UbuntuMono-BI.ttf"),
		},
	};

	function X3DFontStyleNode (executionContext)
	{
		X3DNode .call (this, executionContext);

		this .addType (X3DConstants .X3DFontStyleNode);
		
		this .addChildObjects ("loadState", new Fields .SFInt32 (X3DConstants .NOT_STARTED_STATE));

		this .familyStack = [ ];
		this .alignments  = [ ];
		this .loader      = new FileLoader (this);
	}

	X3DFontStyleNode .prototype = Object .assign (Object .create (X3DNode .prototype),
	{
		constructor: X3DFontStyleNode,
		initialize: function ()
		{
			X3DNode .prototype .initialize .call (this);

			this .style_   .addInterest ("set_style__", this);
			this .justify_ .addInterest ("set_justify__", this);

			this .font        = null;
			this .familyIndex = 0;

			this .set_justify__ ();
			this .set_style__ ();

			this .requestAsyncLoad ();
		},
		setLoadState: X3DUrlObject .prototype .setLoadState,
		checkLoadState: X3DUrlObject .prototype .checkLoadState,
		getMajorAlignment: function ()
		{
			return this .alignments [0];
		},
		getMinorAlignment: function ()
		{
			return this .alignments [1];
		},
		set_style__: function ()
		{
			this .setLoadState (X3DConstants .NOT_STARTED_STATE);

			this .requestAsyncLoad ();
		},
		set_justify__: function ()
		{
			var majorNormal = this .horizontal_ .getValue () ? this .leftToRight_ .getValue () : this .topToBottom_ .getValue ();

			this .alignments [0] = this .justify_ .length > 0
			                       ? this .getAlignment (0, majorNormal)
			                       : majorNormal ? TextAlignment .BEGIN : TextAlignment .END;

			var minorNormal = this .horizontal_ .getValue () ? this .topToBottom_ .getValue () : this .leftToRight_ .getValue ();

			this .alignments [1] = this .justify_ .length > 1
			                       ? this .getAlignment (1, minorNormal)
			                       : minorNormal ? TextAlignment .FIRST : TextAlignment .END;
		},
		getAlignment: function (index, normal)
		{
			if (normal)
			{
				// Return for west-european normal alignment.

				switch (this .justify_ [index])
				{
					case "FIRST":  return TextAlignment .FIRST;
					case "BEGIN":  return TextAlignment .BEGIN;
					case "MIDDLE": return TextAlignment .MIDDLE;
					case "END":    return TextAlignment .END;
				}
			}
			else
			{
				// Return appropriate alignment if topToBottom or leftToRight are FALSE.

				switch (this .justify_ [index])
				{
					case "FIRST":  return TextAlignment .END;
					case "BEGIN":  return TextAlignment .END;
					case "MIDDLE": return TextAlignment .MIDDLE;
					case "END":    return TextAlignment .BEGIN;
				}
			}

			return index ? TextAlignment .FIRST : TextAlignment .BEGIN;
		},
		requestAsyncLoad: function ()
		{
			if (this .checkLoadState () === X3DConstants .COMPLETE_STATE || this .checkLoadState () === X3DConstants .IN_PROGRESS_STATE)
				return;

			this .setLoadState (X3DConstants .IN_PROGRESS_STATE);

			// Add default font to family array.

			var family = this .family_ .copy ();

			family .push ("SERIF");

			// Build family stack.

			this .familyStack .length = 0;

			for (var i = 0, length = family .length; i < length; ++ i)
			{
				var
					familyName  = family [i],
					defaultFont = this .getDefaultFont (familyName);
				
				if (defaultFont)
					this .familyStack .push (defaultFont);
				else
					this .familyStack .push (familyName);
			}

			this .loadNext ();
		},
		getDefaultFont: function (familyName)
		{
			var family = Fonts [familyName];

			if (family)
			{
				var style = family [this .style_ .getValue ()];

				if (style)
					return style;

				return family .PLAIN;
			}

			return;
		},
		loadNext: function ()
		{
			try
			{
				if (this .familyStack .length === 0)
				{
					this .setLoadState (X3DConstants .FAILED_STATE);
					this .font = null;
					return;
				}

				this .family = this .familyStack .shift ();
				this .URL    = this .loader .transform (this .family);

				this .getBrowser () .getFont (this .URL)
					.done (this .setFont .bind (this))
					.fail (this .setError .bind (this));
			}
			catch (error)
			{
				this .setError (error .message);
			}
		},
		setError: function (error)
		{
			if (this .URL .scheme !== "data")
				console .warn ("Error loading font '" + this .URL .toString () + "':", error);

			this .loadNext ();
		},
		setFont: function (font)
		{
			this .font = font;

			this .setLoadState (X3DConstants .COMPLETE_STATE);
			this .addNodeEvent ();
		},
		getFont: function ()
		{
			return this .font;
		},
	});

	return X3DFontStyleNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Box2',[
	"standard/Math/Numbers/Matrix3",
	"standard/Math/Numbers/Vector2",
],
function (Matrix3, Vector2)
{
"use strict";

	function Box2 (size, center)
	{
		switch (arguments .length)
		{
			case 0:
			{
				this .matrix = new Matrix3 (0, 0, 0,
				                            0, 0, 0,
				                            0, 0, 0);
				return;
			}
			case 2:
			{
				this .matrix = new Matrix3 (size .x / 2, 0, 0,
				                            0, size .y / 2, 0,
				                            center .x, center .y, 1);
				return;
			}
			case 3:
			{
				var
					min = arguments [0],
					max = arguments [1],
					sx  = (max .x - min .x) / 2,
					sy  = (max .y - min .y) / 2,
					cx  = (max .x + min .x) / 2,
					cy  = (max .y + min .y) / 2;

				this .matrix = new Matrix3 (sx, 0,  0,
				                            0,  sy, 0,
				                            cx, cy, 1);
				return;
			}
		}
	}

	Box2 .prototype =
	{
		constructor: Box2,
		copy: function ()
		{
			var copy = Object .create (Box2 .prototype);
			copy .matrix = this .matrix .copy ();
			return copy;
		},
		assign: function (box)
		{
			this .matrix .assign (box .matrix);
			return this;
		},
		equals: function (box)
		{
			return this .matrix .equals (box .matrix);
		},
		set: function (size, center)
		{
			var m = this .matrix;

			switch (arguments .length)
			{
				case 0:
				{
					m [0] = 0.5; m [1] = 0;   m [2] = 0;
					m [3] = 0;   m [4] = 0.5; m [5] = 0;
					m [6] = 0;   m [7] = 0;   m [8] = 0;
					return this;
				}
				case 2:
				{
					// size, center
					m [0] = size .x / 2; m [1] = 0;           m [2] = 0;
					m [3] = 0;           m [4] = size .y / 2; m [5] = 0;
					m [6] = center .x;   m [7] = center .y;   m [8] = 1;
					return this;
				}
				case 3:
				{
					var
						min = arguments [0],
						max = arguments [1],
						sx  = (max .x - min .x) / 2,
						sy  = (max .y - min .y) / 2,
						cx  = (max .x + min .x) / 2,
						cy  = (max .y + min .y) / 2;

					this .matrix .set (sx, 0,  0,
					                   0,  sy, 0,
					                   cx, cy, 1);
					return this;
				}
			}
		},
		setExtents: function (min, max)
		{
			var
				m  = this .matrix,
				sx = (max .x - min .x) / 2,
				sy = (max .y - min .y) / 2,
				cx = (max .x + min .x) / 2,
				cy = (max .y + min .y) / 2;

			m [0] = sx; m [1] = 0;  m [2] = 0;
			m [3] = 0;  m [4] = sy; m [5] = 0;
			m [6] = cx; m [7] = cy; m [8] = 1;
			return this;
		},
		isEmpty: function ()
		{
			return this .matrix [8] === 0;
		},
		add: (function ()
		{
			var
				lhs_min = new Vector2 (0, 0),
				lhs_max = new Vector2 (0, 0),
				rhs_min = new Vector2 (0, 0),
				rhs_max = new Vector2 (0, 0);

			return function (box)
			{
				if (this .isEmpty ())
					return this .assign (box);

				if (box .isEmpty ())
					return this;

				this .getExtents (lhs_min, lhs_max);
				box  .getExtents (rhs_min, rhs_max);

				return this .set (lhs_min .min (rhs_min), lhs_max .max (rhs_max), true);
			};
		})(),
		multLeft: function (matrix)
		{
			this .matrix .multLeft (matrix);
			return this;
		},
		multRight: function (matrix)
		{
			this .matrix .multRight (matrix);
			return this;
		},
		getExtents: function (min, max)
		{
			this .getAbsoluteExtents (min, max);

			min .add (this .center);
			max .add (this .center);
		},
		getAbsoluteExtents: (function ()
		{
			var p1 = new Vector2 (0, 0);

			return function (min, max)
			{
			   var
					m = this .matrix,
					x = m .xAxis,
					y = m .yAxis;

				p1 .assign (x) .add (y);

				var p2 = y .subtract (x);

				min .assign (p1) .min (p2);
				max .assign (p1) .max (p2);

				p1 .negate ();
				p2 .negate ();

				min .min (p1, p2);
				max .max (p1, p2);
			};
		})(),
		intersectsPoint: (function ()
		{
			var
				min = new Vector2 (0, 0),
				max = new Vector2 (0, 0);

			return function (point)
			{
				this .getExtents (min, max);

				return min .x <= point .x &&
				       max .x >= point .x &&
				       min .y <= point .y &&
				       max .y >= point .y;
			};
		})(),
		toString: function ()
		{
			return this .size + ", " + this .center;
		},
	};

	Object .defineProperty (Box2 .prototype, "size",
	{
		get: (function ()
		{
			var
				min = new Vector2 (0, 0),
				max = new Vector2 (0, 0);

			return function ()
			{
				this .getAbsoluteExtents (min, max);

				return max .subtract (min);
			};
		})(),
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (Box2 .prototype, "center",
	{
		get: function ()
		{
			return this .matrix .origin;
		},
		enumerable: true,
		configurable: false
	});

	return Box2;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Text/X3DTextGeometry',[
	"x_ite/Browser/Text/TextAlignment",
	"standard/Math/Geometry/Box2",
	"standard/Math/Geometry/Box3",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
],
function (TextAlignment,
          Box2,
          Box3,
          Vector2,
          Vector3)
{
"use strict";

	var
		bbox        = new Box2 (),
		lineBBox    = new Box2 (),
		min         = new Vector2 (0, 0),
		max         = new Vector2 (0, 0),
		glyphMin    = new Vector2 (0, 0),
		glyphMax    = new Vector2 (0, 0),
		min3        = new Vector3 (0, 0, 0),
		max3        = new Vector3 (0, 0, 0),
		size        = new Vector2 (0, 0),
		center      = new Vector2 (0, 0),
		size1_2     = new Vector2 (0, 0),
		translation = new Vector2 (0, 0),
		lineBound   = new Vector2 (0, 0),
		origin      = new Vector3 (0, 0, 0),
		vector      = new Vector2 (0, 0),
		box2        = new Box2 (),
		zero2       = new Vector2 (0, 0),
		zero3       = new Vector3 (0, 0, 0);

	function X3DTextGeometry (text, fontStyle)
	{
		this .text           = text;
		this .fontStyle      = fontStyle;
		this .glyphs         = [ ];
		this .minorAlignment = new Vector2 (0, 0);
		this .translations   = [ ];
		this .charSpacings   = [ ];
		this .bearing        = new Vector2 (0, 0);
		this .yPad           = [ ];
		this .bbox           = new Box3 ();
	}

	X3DTextGeometry .prototype =
	{
		constructor: X3DTextGeometry,
		getBrowser: function ()
		{
			return this .text .getBrowser ();
		},
		getText: function ()
		{
			return this .text;
		},
		getFontStyle: function ()
		{
			return this .fontStyle;
		},
		getGlyphs: function ()
		{
			return this .glyphs;
		},
		getMinorAlignment: function ()
		{
			return this .minorAlignment;
		},
		getTranslations: function ()
		{
			return this .translations;
		},
		getCharSpacings: function ()
		{
			return this .charSpacings;
		},
		getBearing: function ()
		{
			return this .bearing;
		},
		getBBox: function ()
		{
			return this .bbox;
		},
		update: function ()
		{
			var
				text      = this .text,
				fontStyle = this .fontStyle,
				numLines  = text .string_ .length;

			text .lineBounds_ .length = numLines;
			this .glyphs      .length = 0;

			if (numLines === 0 || ! fontStyle .getFont ())
			{
				text .origin_     .setValue (zero3);
				text .textBounds_ .setValue (zero2);

				this .bbox .set ();
				return;
			}

			if (fontStyle .horizontal_ .getValue ())
			{
				this .resizeArray (this .translations, numLines);
				this .resizeArray (this .charSpacings, numLines);

				this .horizontal (text, fontStyle);
			}
			else
			{
				var
					string   = text .string_,
					numChars = 0;

				for (var i = 0, length = string .length; i < length; ++ i)
					numChars += string [i] .length;

				this .resizeArray (this .translations, numChars);
				this .resizeArray (this .charSpacings, numChars);

				this .vertical (text, fontStyle);
			}
		},
		resizeArray: function (array, size)
		{
			// Resize array in grow only fashion.

			for (var i = array .length; i < size; ++ i)
				array .push (new Vector2 (0, 0));

			array .length = size;
		},
		horizontal: function (text, fontStyle)
		{
			var
				font        = fontStyle .getFont (),
				string      = text .string_,
				numLines    = string .length,
				maxExtent   = Math .max (0, text .maxExtent_ .getValue ()),
				topToBottom = fontStyle .topToBottom_ .getValue (),
				scale       = fontStyle .getScale (),
				spacing     = fontStyle .spacing_ .getValue ();

			bbox .set ();

			// Calculate bboxes.

			var
				first = topToBottom ? 0 : numLines - 1,
				last  = topToBottom ? numLines : -1,
				step  = topToBottom ? 1 : -1;

			for (var l = first, ll = 0; l !== last; l += step, ++ ll)
			{
				var line = string [l];

				// Get line extents.

				var glyphs = this .getHorizontalLineExtents (fontStyle, line, min, max, ll);

				size .assign (max) .subtract (min);

				// Calculate charSpacing and lineBounds.

				var
					charSpacing = 0,
					length      = text .getLength (l);

				lineBound .set (size .x * scale, ll == 0 ? max .y - font .descender / font .unitsPerEm * scale : spacing);

				if (maxExtent)
				{
					if (length)
						length = Math .min (maxExtent, length);

					else
						length = Math .min (maxExtent, size .x * scale);
				}

				if (length)
				{
					charSpacing  = (length - lineBound .x) / (glyphs .length - 1);
					lineBound .x = length;
					size .x      = length / scale;
				}

				this .charSpacings [ll] = charSpacing;
				text .lineBounds_ [l]   = lineBound;

				// Calculate line translation.

				switch (fontStyle .getMajorAlignment ())
				{
					case TextAlignment .BEGIN:
					case TextAlignment .FIRST:
						this .translations [ll] .set (0, -ll * spacing);
						break;
					case TextAlignment .MIDDLE:
						this .translations [ll] .set (-min .x - size .x / 2, -ll * spacing);
						break;
					case TextAlignment .END:
						this .translations [ll] .set (-min .x - size .x, -ll * spacing);
						break;
				}

				this .translations [ll] .multiply (scale);

				// Calculate center.

				center .assign (min) .add (size1_2 .assign (size) .divide (2));

				// Add bbox.

				bbox .add (box2 .set (size .multiply (scale), center .multiply (scale) .add (this .translations [ll])));
			}

			//console .log ("size", bbox .size, "center", bbox .center);

			// Get text extents.

			bbox .getExtents (min, max);

			size .assign (max) .subtract (min);

			// Calculate text position

			text .textBounds_ = size;
			this .bearing .set (0, -max .y);

			switch (fontStyle .getMinorAlignment ())
			{
				case TextAlignment .BEGIN:
					this .minorAlignment .assign (this .bearing);
					break;
				case TextAlignment .FIRST:
					this .minorAlignment .set (0, 0);
					break;
				case TextAlignment .MIDDLE:
					this .minorAlignment .set (0, size .y / 2 - max .y);
					break;
				case TextAlignment .END:
					this .minorAlignment .set (0, (numLines - 1) * spacing * scale);
					break;
			}

			// Translate bbox by minorAlignment.

			min .add (this .minorAlignment);
			max .add (this .minorAlignment);

			// The value of the origin field represents the upper left corner of the textBounds.

			text .origin_ .setValue (origin .set (min .x, max .y, 0));

			this .bbox .setExtents (min3 .set (min .x, min .y, 0),
			                        max3 .set (max .x, max .y, 0));
		},
		vertical: function (text, fontStyle)
		{
			var
				font             = fontStyle .getFont (),
				string           = text .string_,
				numLines         = string .length,
				maxExtent        = Math .max (0, text .maxExtent_ .getValue ()),
				leftToRight      = fontStyle .leftToRight_ .getValue (),
				topToBottom      = fontStyle .topToBottom_ .getValue (),
				scale            = fontStyle .getScale (),
				spacing          = fontStyle .spacing_ .getValue (),
				yPad             = this .yPad,
				primitiveQuality = this .getBrowser () .getBrowserOptions () .getPrimitiveQuality ();

			bbox .set ();

			// Calculate bboxes.

			var
				firstL = leftToRight ? 0 : numLines - 1,
				lastL  = leftToRight ? numLines : -1,
				stepL  = leftToRight ? 1 : -1,
				t      = 0; // Translation index

			for (var l = firstL; l !== lastL; l += stepL)
			{
				var glyphs = this .stringToGlyphs (font, string [l], true, l);

				var
					t0       = t,
					numChars = glyphs .length;

				// Calculate line bbox

				lineBBox .set ();

				var
					firstG = topToBottom ? 0 : numChars - 1,
					lastG  = topToBottom ? numChars : -1,
					stepG  = topToBottom ? 1 : -1;

				for (var g = firstG; g !== lastG; g += stepG, ++ t)
				{
					var glyph = glyphs [g];

					// Get glyph extents.

					this .getGlyphExtents (font, glyph, primitiveQuality, min, max);

					size .assign (max) .subtract (min);

					// Calculate glyph translation

					var glyphNumber = topToBottom ? g : numChars - g - 1;

					this .translations [t] .set ((spacing - size .x - min .x) / 2, -glyphNumber);

					// Calculate center.

					center .assign (min) .add (size1_2 .assign (size) .divide (2)) .add (this .translations [t]);

					// Add bbox.

					lineBBox .add (box2 .set (size, center));
				}

				// Get line extents.

				lineBBox .getExtents (min, max);

				size .assign (max) .subtract (min);

				// Calculate charSpacing and lineBounds.

				var
					lineNumber  = leftToRight ? l : numLines - l - 1,
					padding     = (spacing - size .x) / 2,
					charSpacing = 0,
					length      = text .getLength (l);

				lineBound .set (l === 0 ? spacing - padding: spacing, numChars ? size .y : 0) .multiply (scale);

				if (maxExtent)
				{
					if (length)
						length = Math .min (maxExtent, length);

					else
						length = Math .min (maxExtent, size .y * scale);
				}

				if (length)
				{
					charSpacing  = (length - lineBound .y) / (glyphs .length - 1) / scale;
					lineBound .y = length;
					size .y      = length / scale;
					min .y       = max .y  - size .y;
				}

				text .lineBounds_ [l] = lineBound;

				// Calculate line translation.

				switch (fontStyle .getMajorAlignment ())
				{
					case TextAlignment .BEGIN:
					case TextAlignment .FIRST:
						translation .set (lineNumber * spacing, -1);
						break;
					case TextAlignment .MIDDLE:
						translation .set (lineNumber * spacing, (size .y / 2 - max .y));
						break;
					case TextAlignment .END:
					{
						// This is needed to make maxExtend and charSpacing work.
						if (numChars)
							this .getGlyphExtents (font, glyphs [topToBottom ? numChars - 1 : 0], primitiveQuality, glyphMin .assign (Vector2 .Zero), vector);

						translation .set (lineNumber * spacing, (size .y - max .y + glyphMin .y));
						break;
					}
				}

				// Calculate glyph translation

				var space = 0;

				for (var tt = t0; tt < t; ++ tt)
				{
					this .translations [tt] .add (translation);

					this .translations [tt] .y -= space;

					this .translations [tt] .multiply (scale);

					space += charSpacing;
				}

				// Calculate ypad to extend line bounds.

				switch (fontStyle .getMajorAlignment ())
				{
					case TextAlignment .BEGIN:
					case TextAlignment .FIRST:
						yPad [l] = max .y + translation .y;
						break;
					case TextAlignment .MIDDLE:
						yPad [l] = 0;
						break;
					case TextAlignment .END:
						yPad [l] = min .y + translation .y;
						break;
				}

				// Calculate center.

				center .assign (min) .add (size1_2 .assign (size) .divide (2));

				// Add bbox.

				bbox .add (box2 .set (size .multiply (scale), center .add (translation) .multiply (scale)));
			}

			// Get text extents.

			bbox .getExtents (min, max);

			size .assign (max) .subtract (min);

			// Extend lineBounds.

			switch (fontStyle .getMajorAlignment ())
			{
				case TextAlignment .BEGIN:
				case TextAlignment .FIRST:
				{
					var lineBounds = text .lineBounds_;

					for (var i = 0, length = lineBounds .length; i < length; ++ i)
						lineBounds [i] .y += max .y - yPad [i] * scale;

					break;
				}
				case TextAlignment .MIDDLE:
					break;
				case TextAlignment .END:
				{
					var lineBounds = text .lineBounds_;

					for (var i = 0, length = lineBounds .length; i < length; ++ i)
						lineBounds [i] .y += yPad [i] * scale - min .y;

					break;
				}
			}

			// Calculate text position

			text .textBounds_ = size;

			switch (fontStyle .getMajorAlignment ())
			{
				case TextAlignment .BEGIN:
				case TextAlignment .FIRST:
					this .bearing .set (-min .x, max .y);
					break;
				case TextAlignment .MIDDLE:
					this .bearing .set (-min .x, 0);
					break;
				case TextAlignment .END:
					this .bearing .set (-min .x, min .y);
					break;
			}

			switch (fontStyle .getMinorAlignment ())
			{
				case TextAlignment .BEGIN:
				case TextAlignment .FIRST:
					this .minorAlignment .set (-min .x, 0);
					break;
				case TextAlignment .MIDDLE:
					this .minorAlignment .set (-min .x - size .x / 2, 0);
					break;
				case TextAlignment .END:
					this .minorAlignment .set (-min .x - size .x, 0);
					break;
			}

			// Translate bbox by minorAlignment.

			min .add (this .minorAlignment);
			max .add (this .minorAlignment);

			// The value of the origin field represents the upper left corner of the textBounds.

			text .origin_ .setValue (origin .set (min .x, max .y, 0));

			this .bbox .set (min3 .set (min .x, min .y, 0),
			                 max3 .set (max .x, max .y, 0),
			                 true);
		},
		stringToGlyphs: function (font, line, normal, lineNumber)
		{
			var glypes = this .glyphs [lineNumber];

			if (! glypes)
				glypes = this .glyphs [lineNumber] = [ ];

			glypes .length = line .length;

			var
				first = normal ? 0 : line .length - 1,
				last  = normal ? line .length : -1,
				step  = normal ? 1 : -1;

			for (var c = first, g = 0; c !== last; c += step, ++ g)
				glypes [g] = font .charToGlyph (line [c]);

			return glypes;
		},
		getHorizontalLineExtents: function (fontStyle, line, min, max, lineNumber)
		{
			var
				font             = fontStyle .getFont (),
				normal           = fontStyle .horizontal_ .getValue () ? fontStyle .leftToRight_ .getValue () : fontStyle .topToBottom_ .getValue (),
				glyphs           = this .stringToGlyphs (font, line, normal, lineNumber),
				primitiveQuality = this .getBrowser () .getBrowserOptions () .getPrimitiveQuality (),
				xMin             = 0,
				xMax             = 0,
				yMin             = Number .POSITIVE_INFINITY,
				yMax             = Number .NEGATIVE_INFINITY;

			for (var g = 0, length = glyphs .length; g < length; ++ g)
			{
				var
					glyph   = glyphs [g],
					kerning = g + 1 < length ? font .getKerningValue (glyph, glyphs [g + 1]) : 0;

				this .getGlyphExtents (font, glyph, primitiveQuality, glyphMin, glyphMax);

				xMax += glyph .advanceWidth + kerning;
				yMin  = Math .min (yMin, glyphMin .y);
				yMax  = Math .max (yMax, glyphMax .y);
			}

			if (glyphs .length)
			{
				this .getGlyphExtents (font, glyphs [0], primitiveQuality, glyphMin, glyphMax);

				xMin  = glyphMin .x;
			}
			else
			{
				yMin = 0;
				yMax = 0;
			}

			min .set (xMin, yMin);
			max .set (xMax / font .unitsPerEm, yMax);

			switch (fontStyle .getMajorAlignment ())
			{
				case TextAlignment .BEGIN:
				case TextAlignment .FIRST:
					min .x = 0;
					break;
			}

			return glyphs;
		},
		traverse: function (type, renderObject)
		{ },
	};

	return X3DTextGeometry;
});

var Bezier=function(t){function r(i){if(n[i])return n[i].exports;var e=n[i]={exports:{},id:i,loaded:!1};return t[i].call(e.exports,e,e.exports,r),e.loaded=!0,e.exports}var n={};return r.m=t,r.c=n,r.p="",r(0)}([function(t,r,n){"use strict";t.exports=n(1)},function(t,r,n){"use strict";var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};!function(){function r(t,r,n,i,e){"undefined"==typeof e&&(e=.5);var o=y.projectionratio(e,t),s=1-o,u={x:o*r.x+s*i.x,y:o*r.y+s*i.y},a=y.abcratio(e,t),f={x:n.x+(n.x-u.x)/a,y:n.y+(n.y-u.y)/a};return{A:f,B:n,C:u}}var e=Math.abs,o=Math.min,s=Math.max,u=Math.cos,a=Math.sin,f=Math.acos,c=Math.sqrt,h=Math.PI,x={x:0,y:0,z:0},y=n(2),l=n(3),p=function(t){var r=t&&t.forEach?t:[].slice.call(arguments),n=!1;if("object"===i(r[0])){n=r.length;var o=[];r.forEach(function(t){["x","y","z"].forEach(function(r){"undefined"!=typeof t[r]&&o.push(t[r])})}),r=o}var s=!1,u=r.length;if(n){if(n>4){if(1!==arguments.length)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");s=!0}}else if(6!==u&&8!==u&&9!==u&&12!==u&&1!==arguments.length)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");var a=!s&&(9===u||12===u)||t&&t[0]&&"undefined"!=typeof t[0].z;this._3d=a;for(var f=[],c=0,h=a?3:2;c<u;c+=h){var x={x:r[c],y:r[c+1]};a&&(x.z=r[c+2]),f.push(x)}this.order=f.length-1,this.points=f;var l=["x","y"];a&&l.push("z"),this.dims=l,this.dimlen=l.length,function(t){for(var r=t.order,n=t.points,i=y.align(n,{p1:n[0],p2:n[r]}),o=0;o<i.length;o++)if(e(i[o].y)>1e-4)return void(t._linear=!1);t._linear=!0}(this),this._t1=0,this._t2=1,this.update()},v=n(4);p.SVGtoBeziers=function(t){return v(p,t)},p.quadraticFromPoints=function(t,n,i,e){if("undefined"==typeof e&&(e=.5),0===e)return new p(n,n,i);if(1===e)return new p(t,n,n);var o=r(2,t,n,i,e);return new p(t,o.A,i)},p.cubicFromPoints=function(t,n,i,e,o){"undefined"==typeof e&&(e=.5);var s=r(3,t,n,i,e);"undefined"==typeof o&&(o=y.dist(n,s.C));var u=o*(1-e)/e,a=y.dist(t,i),f=(i.x-t.x)/a,c=(i.y-t.y)/a,h=o*f,x=o*c,l=u*f,v=u*c,d={x:n.x-h,y:n.y-x},m={x:n.x+l,y:n.y+v},z=s.A,g={x:z.x+(d.x-z.x)/(1-e),y:z.y+(d.y-z.y)/(1-e)},b={x:z.x+(m.x-z.x)/e,y:z.y+(m.y-z.y)/e},_={x:t.x+(g.x-t.x)/e,y:t.y+(g.y-t.y)/e},w={x:i.x+(b.x-i.x)/(1-e),y:i.y+(b.y-i.y)/(1-e)};return new p(t,_,w,i)};var d=function(){return y};p.getUtils=d,p.PolyBezier=l,p.prototype={getUtils:d,valueOf:function(){return this.toString()},toString:function(){return y.pointsToString(this.points)},toSVG:function(t){if(this._3d)return!1;for(var r=this.points,n=r[0].x,i=r[0].y,e=["M",n,i,2===this.order?"Q":"C"],o=1,s=r.length;o<s;o++)e.push(r[o].x),e.push(r[o].y);return e.join(" ")},setRatios:function(t){if(t.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=t,this._lut=[]},verify:function(){var t=this.coordDigest();t!==this._print&&(this._print=t,this.update())},coordDigest:function(){return this.points.map(function(t,r){return""+r+t.x+t.y+(t.z?t.z:0)}).join("")},update:function(t){this._lut=[],this.dpoints=y.derive(this.points,this._3d),this.computedirection()},computedirection:function(){var t=this.points,r=y.angle(t[0],t[this.order],t[1]);this.clockwise=r>0},length:function(){return y.length(this.derivative.bind(this))},_lut:[],getLUT:function(t){if(this.verify(),t=t||100,this._lut.length===t)return this._lut;this._lut=[],t--;for(var r=0;r<=t;r++)this._lut.push(this.compute(r/t));return this._lut},on:function(t,r){r=r||5;for(var n,i=this.getLUT(),e=[],o=0,s=0;s<i.length;s++)n=i[s],y.dist(n,t)<r&&(e.push(n),o+=s/i.length);return!!e.length&&(o/=e.length)},project:function(t){var r,n,i,e,o=this.getLUT(),s=o.length-1,u=y.closest(o,t),a=u.mdist,f=u.mpos,c=(f-1)/s,h=(f+1)/s,x=.1/s;for(a+=1,n=c,r=n;n<h+x;n+=x)i=this.compute(n),e=y.dist(t,i),e<a&&(a=e,r=n);return i=this.compute(r),i.t=r,i.d=a,i},get:function(t){return this.compute(t)},point:function(t){return this.points[t]},compute:function(t){return this.ratios?y.computeWithRatios(t,this.points,this.ratios,this._3d):y.compute(t,this.points,this._3d,this.ratios)},raise:function(){for(var t,r,n,i=this.points,e=[i[0]],o=i.length,t=1;t<o;t++)r=i[t],n=i[t-1],e[t]={x:(o-t)/o*r.x+t/o*n.x,y:(o-t)/o*r.y+t/o*n.y};return e[o]=i[o-1],new p(e)},derivative:function(t){var r,n,i=1-t,e=0,o=this.dpoints[0];2===this.order&&(o=[o[0],o[1],x],r=i,n=t),3===this.order&&(r=i*i,n=i*t*2,e=t*t);var s={x:r*o[0].x+n*o[1].x+e*o[2].x,y:r*o[0].y+n*o[1].y+e*o[2].y};return this._3d&&(s.z=r*o[0].z+n*o[1].z+e*o[2].z),s},curvature:function(t){return y.curvature(t,this.points,this._3d)},inflections:function(){return y.inflections(this.points)},normal:function(t){return this._3d?this.__normal3(t):this.__normal2(t)},__normal2:function(t){var r=this.derivative(t),n=c(r.x*r.x+r.y*r.y);return{x:-r.y/n,y:r.x/n}},__normal3:function(t){var r=this.derivative(t),n=this.derivative(t+.01),i=c(r.x*r.x+r.y*r.y+r.z*r.z),e=c(n.x*n.x+n.y*n.y+n.z*n.z);r.x/=i,r.y/=i,r.z/=i,n.x/=e,n.y/=e,n.z/=e;var o={x:n.y*r.z-n.z*r.y,y:n.z*r.x-n.x*r.z,z:n.x*r.y-n.y*r.x},s=c(o.x*o.x+o.y*o.y+o.z*o.z);o.x/=s,o.y/=s,o.z/=s;var u=[o.x*o.x,o.x*o.y-o.z,o.x*o.z+o.y,o.x*o.y+o.z,o.y*o.y,o.y*o.z-o.x,o.x*o.z-o.y,o.y*o.z+o.x,o.z*o.z],a={x:u[0]*r.x+u[1]*r.y+u[2]*r.z,y:u[3]*r.x+u[4]*r.y+u[5]*r.z,z:u[6]*r.x+u[7]*r.y+u[8]*r.z};return a},hull:function(t){var r,n=this.points,i=[],e=[],o=0,s=0,u=0;for(e[o++]=n[0],e[o++]=n[1],e[o++]=n[2],3===this.order&&(e[o++]=n[3]);n.length>1;){for(i=[],s=0,u=n.length-1;s<u;s++)r=y.lerp(t,n[s],n[s+1]),e[o++]=r,i.push(r);n=i}return e},split:function(t,r){if(0===t&&r)return this.split(r).left;if(1===r)return this.split(t).right;var n=this.hull(t),i={left:new p(2===this.order?[n[0],n[3],n[5]]:[n[0],n[4],n[7],n[9]]),right:new p(2===this.order?[n[5],n[4],n[2]]:[n[9],n[8],n[6],n[3]]),span:n};if(i.left._t1=y.map(0,0,1,this._t1,this._t2),i.left._t2=y.map(t,0,1,this._t1,this._t2),i.right._t1=y.map(t,0,1,this._t1,this._t2),i.right._t2=y.map(1,0,1,this._t1,this._t2),!r)return i;r=y.map(r,t,1,0,1);var e=i.right.split(r);return e.left},extrema:function(){var t,r,n=this.dims,i={},e=[];return n.forEach(function(n){r=function(t){return t[n]},t=this.dpoints[0].map(r),i[n]=y.droots(t),3===this.order&&(t=this.dpoints[1].map(r),i[n]=i[n].concat(y.droots(t))),i[n]=i[n].filter(function(t){return t>=0&&t<=1}),e=e.concat(i[n].sort(y.numberSort))}.bind(this)),e=e.sort(y.numberSort).filter(function(t,r){return e.indexOf(t)===r}),i.values=e,i},bbox:function(){var t=this.extrema(),r={};return this.dims.forEach(function(n){r[n]=y.getminmax(this,n,t[n])}.bind(this)),r},overlaps:function(t){var r=this.bbox(),n=t.bbox();return y.bboxoverlap(r,n)},offset:function(t,r){if("undefined"!=typeof r){var n=this.get(t),i=this.normal(t),e={c:n,n:i,x:n.x+i.x*r,y:n.y+i.y*r};return this._3d&&(e.z=n.z+i.z*r),e}if(this._linear){var o=this.normal(0),s=this.points.map(function(r){var n={x:r.x+t*o.x,y:r.y+t*o.y};return r.z&&i.z&&(n.z=r.z+t*o.z),n});return[new p(s)]}var u=this.reduce();return u.map(function(r){return r._linear?r.offset(t)[0]:r.scale(t)})},simple:function(){if(3===this.order){var t=y.angle(this.points[0],this.points[3],this.points[1]),r=y.angle(this.points[0],this.points[3],this.points[2]);if(t>0&&r<0||t<0&&r>0)return!1}var n=this.normal(0),i=this.normal(1),o=n.x*i.x+n.y*i.y;this._3d&&(o+=n.z*i.z);var s=e(f(o));return s<h/3},reduce:function(){var t,r,n=0,i=0,o=.01,s=[],u=[],a=this.extrema().values;for(a.indexOf(0)===-1&&(a=[0].concat(a)),a.indexOf(1)===-1&&a.push(1),n=a[0],t=1;t<a.length;t++)i=a[t],r=this.split(n,i),r._t1=n,r._t2=i,s.push(r),n=i;return s.forEach(function(t){for(n=0,i=0;i<=1;)for(i=n+o;i<=1+o;i+=o)if(r=t.split(n,i),!r.simple()){if(i-=o,e(n-i)<o)return[];r=t.split(n,i),r._t1=y.map(n,0,1,t._t1,t._t2),r._t2=y.map(i,0,1,t._t1,t._t2),u.push(r),n=i;break}n<1&&(r=t.split(n,1),r._t1=y.map(n,0,1,t._t1,t._t2),r._t2=t._t2,u.push(r))}),u},scale:function(t){var r=this.order,n=!1;if("function"==typeof t&&(n=t),n&&2===r)return this.raise().scale(n);var i=this.clockwise,e=n?n(0):t,o=n?n(1):t,s=[this.offset(0,10),this.offset(1,10)],u=y.lli4(s[0],s[0].c,s[1],s[1].c);if(!u)throw new Error("cannot scale this curve. Try reducing it first.");var a=this.points,f=[];return[0,1].forEach(function(t){var n=f[t*r]=y.copy(a[t*r]);n.x+=(t?o:e)*s[t].n.x,n.y+=(t?o:e)*s[t].n.y}.bind(this)),n?([0,1].forEach(function(e){if(2!==this.order||!e){var o=a[e+1],s={x:o.x-u.x,y:o.y-u.y},h=n?n((e+1)/r):t;n&&!i&&(h=-h);var x=c(s.x*s.x+s.y*s.y);s.x/=x,s.y/=x,f[e+1]={x:o.x+h*s.x,y:o.y+h*s.y}}}.bind(this)),new p(f)):([0,1].forEach(function(t){if(2!==this.order||!t){var n=f[t*r],i=this.derivative(t),e={x:n.x+i.x,y:n.y+i.y};f[t+1]=y.lli4(n,e,u,a[t+1])}}.bind(this)),new p(f))},outline:function(t,r,n,i){function e(t,r,n,i,e){return function(o){var s=i/n,u=(i+e)/n,a=r-t;return y.map(o,0,1,t+s*a,t+u*a)}}r="undefined"==typeof r?t:r;var o,s=this.reduce(),u=s.length,a=[],f=[],c=0,h=this.length(),x="undefined"!=typeof n&&"undefined"!=typeof i;s.forEach(function(o){_=o.length(),x?(a.push(o.scale(e(t,n,h,c,_))),f.push(o.scale(e(-r,-i,h,c,_)))):(a.push(o.scale(t)),f.push(o.scale(-r))),c+=_}),f=f.map(function(t){return o=t.points,o[3]?t.points=[o[3],o[2],o[1],o[0]]:t.points=[o[2],o[1],o[0]],t}).reverse();var p=a[0].points[0],v=a[u-1].points[a[u-1].points.length-1],d=f[u-1].points[f[u-1].points.length-1],m=f[0].points[0],z=y.makeline(d,p),g=y.makeline(v,m),b=[z].concat(a).concat([g]).concat(f),_=b.length;return new l(b)},outlineshapes:function(t,r,n){r=r||t;for(var i=this.outline(t,r).curves,e=[],o=1,s=i.length;o<s/2;o++){var u=y.makeshape(i[o],i[s-o],n);u.startcap.virtual=o>1,u.endcap.virtual=o<s/2-1,e.push(u)}return e},intersects:function(t,r){return t?t.p1&&t.p2?this.lineIntersects(t):(t instanceof p&&(t=t.reduce()),this.curveintersects(this.reduce(),t,r)):this.selfintersects(r)},lineIntersects:function(t){var r=o(t.p1.x,t.p2.x),n=o(t.p1.y,t.p2.y),i=s(t.p1.x,t.p2.x),e=s(t.p1.y,t.p2.y),u=this;return y.roots(this.points,t).filter(function(t){var o=u.get(t);return y.between(o.x,r,i)&&y.between(o.y,n,e)})},selfintersects:function(t){var r,n,i,e,o=this.reduce(),s=o.length-2,u=[];for(r=0;r<s;r++)i=o.slice(r,r+1),e=o.slice(r+2),n=this.curveintersects(i,e,t),u=u.concat(n);return u},curveintersects:function(t,r,n){var i=[];t.forEach(function(t){r.forEach(function(r){t.overlaps(r)&&i.push({left:t,right:r})})});var e=[];return i.forEach(function(t){var r=y.pairiteration(t.left,t.right,n);r.length>0&&(e=e.concat(r))}),e},arcs:function(t){t=t||.5;var r=[];return this._iterate(t,r)},_error:function(t,r,n,i){var o=(i-n)/4,s=this.get(n+o),u=this.get(i-o),a=y.dist(t,r),f=y.dist(t,s),c=y.dist(t,u);return e(f-a)+e(c-a)},_iterate:function(t,r){var n,i=0,e=1;do{n=0,e=1;var o,s,f,c,h,x=this.get(i),l=!1,p=!1,v=e,d=1,m=0;do{p=l,c=f,v=(i+e)/2,m++,o=this.get(v),s=this.get(e),f=y.getccenter(x,o,s),f.interval={start:i,end:e};var z=this._error(f,x,i,e);if(l=z<=t,h=p&&!l,h||(d=e),l){if(e>=1){if(f.interval.end=d=1,c=f,e>1){var g={x:f.x+f.r*u(f.e),y:f.y+f.r*a(f.e)};f.e+=y.angle({x:f.x,y:f.y},g,this.get(1))}break}e+=(e-i)/2}else e=v}while(!h&&n++<100);if(n>=100)break;c=c?c:f,r.push(c),i=d}while(e<1);return r}},t.exports=p}()},function(t,r,n){"use strict";!function(){var r=Math.abs,i=Math.cos,e=Math.sin,o=Math.acos,s=Math.atan2,u=Math.sqrt,a=Math.pow,f=function(t){return t<0?-a(-t,1/3):a(t,1/3)},c=Math.PI,h=2*c,x=c/2,y=1e-6,l=Number.MAX_SAFE_INTEGER||9007199254740991,p=Number.MIN_SAFE_INTEGER||-9007199254740991,v={x:0,y:0,z:0},d={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(t,r){var n=r(t),i=n.x*n.x+n.y*n.y;return"undefined"!=typeof n.z&&(i+=n.z*n.z),u(i)},compute:function(t,r,n){if(0===t)return r[0];var i=r.length-1;if(1===t)return r[i];var e=r,o=1-t;if(0===i)return r[0];if(1===i)return x={x:o*e[0].x+t*e[1].x,y:o*e[0].y+t*e[1].y},n&&(x.z=o*e[0].z+t*e[1].z),x;if(i<4){var s,u,a,f=o*o,c=t*t,h=0;2===i?(e=[e[0],e[1],e[2],v],s=f,u=o*t*2,a=c):3===i&&(s=f*o,u=f*t*3,a=o*c*3,h=t*c);var x={x:s*e[0].x+u*e[1].x+a*e[2].x+h*e[3].x,y:s*e[0].y+u*e[1].y+a*e[2].y+h*e[3].y};return n&&(x.z=s*e[0].z+u*e[1].z+a*e[2].z+h*e[3].z),x}for(var y=JSON.parse(JSON.stringify(r));y.length>1;){for(var l=0;l<y.length-1;l++)y[l]={x:y[l].x+(y[l+1].x-y[l].x)*t,y:y[l].y+(y[l+1].y-y[l].y)*t},"undefined"!=typeof y[l].z&&(y[l]=y[l].z+(y[l+1].z-y[l].z)*t);y.splice(y.length-1,1)}return y[0]},computeWithRatios:function(t,r,n,i){var e,o=1-t,s=n,u=r,a=s[0],f=s[1],c=s[2],h=s[3];return a*=o,f*=t,2===u.length?(e=a+f,{x:(a*u[0].x+f*u[1].x)/e,y:(a*u[0].y+f*u[1].y)/e,z:!!i&&(a*u[0].z+f*u[1].z)/e}):(a*=o,f*=2*o,c*=t*t,3===u.length?(e=a+f+c,{x:(a*u[0].x+f*u[1].x+c*u[2].x)/e,y:(a*u[0].y+f*u[1].y+c*u[2].y)/e,z:!!i&&(a*u[0].z+f*u[1].z+c*u[2].z)/e}):(a*=o,f*=1.5*o,c*=3*o,h*=t*t*t,4===u.length?(e=a+f+c+h,{x:(a*u[0].x+f*u[1].x+c*u[2].x+h*u[3].x)/e,y:(a*u[0].y+f*u[1].y+c*u[2].y+h*u[3].y)/e,z:!!i&&(a*u[0].z+f*u[1].z+c*u[2].z+h*u[3].z)/e}):void 0))},derive:function(t,r){for(var n=[],i=t,e=i.length,o=e-1;e>1;e--,o--){for(var s,u=[],a=0;a<o;a++)s={x:o*(i[a+1].x-i[a].x),y:o*(i[a+1].y-i[a].y)},r&&(s.z=o*(i[a+1].z-i[a].z)),u.push(s);n.push(u),i=u}return n},between:function(t,r,n){return r<=t&&t<=n||d.approximately(t,r)||d.approximately(t,n)},approximately:function(t,n,i){return r(t-n)<=(i||y)},length:function(t){var r,n,i=.5,e=0,o=d.Tvalues.length;for(r=0;r<o;r++)n=i*d.Tvalues[r]+i,e+=d.Cvalues[r]*d.arcfn(n,t);return i*e},map:function(t,r,n,i,e){var o=n-r,s=e-i,u=t-r,a=u/o;return i+s*a},lerp:function(t,r,n){var i={x:r.x+t*(n.x-r.x),y:r.y+t*(n.y-r.y)};return r.z&&n.z&&(i.z=r.z+t*(n.z-r.z)),i},pointToString:function(t){var r=t.x+"/"+t.y;return"undefined"!=typeof t.z&&(r+="/"+t.z),r},pointsToString:function(t){return"["+t.map(d.pointToString).join(", ")+"]"},copy:function(t){return JSON.parse(JSON.stringify(t))},angle:function(t,r,n){var i=r.x-t.x,e=r.y-t.y,o=n.x-t.x,u=n.y-t.y,a=i*u-e*o,f=i*o+e*u;return s(a,f)},round:function(t,r){var n=""+t,i=n.indexOf(".");return parseFloat(n.substring(0,i+1+r))},dist:function(t,r){var n=t.x-r.x,i=t.y-r.y;return u(n*n+i*i)},closest:function(t,r){var n,i,e=a(2,63);return t.forEach(function(t,o){i=d.dist(r,t),i<e&&(e=i,n=o)}),{mdist:e,mpos:n}},abcratio:function(t,n){if(2!==n&&3!==n)return!1;if("undefined"==typeof t)t=.5;else if(0===t||1===t)return t;var i=a(t,n)+a(1-t,n),e=i-1;return r(e/i)},projectionratio:function(t,r){if(2!==r&&3!==r)return!1;if("undefined"==typeof t)t=.5;else if(0===t||1===t)return t;var n=a(1-t,r),i=a(t,r)+n;return n/i},lli8:function(t,r,n,i,e,o,s,u){var a=(t*i-r*n)*(e-s)-(t-n)*(e*u-o*s),f=(t*i-r*n)*(o-u)-(r-i)*(e*u-o*s),c=(t-n)*(o-u)-(r-i)*(e-s);return 0!=c&&{x:a/c,y:f/c}},lli4:function(t,r,n,i){var e=t.x,o=t.y,s=r.x,u=r.y,a=n.x,f=n.y,c=i.x,h=i.y;return d.lli8(e,o,s,u,a,f,c,h)},lli:function(t,r){return d.lli4(t,t.c,r,r.c)},makeline:function(t,r){var i=n(1),e=t.x,o=t.y,s=r.x,u=r.y,a=(s-e)/3,f=(u-o)/3;return new i(e,o,e+a,o+f,e+2*a,o+2*f,s,u)},findbbox:function(t){var r=l,n=l,i=p,e=p;return t.forEach(function(t){var o=t.bbox();r>o.x.min&&(r=o.x.min),n>o.y.min&&(n=o.y.min),i<o.x.max&&(i=o.x.max),e<o.y.max&&(e=o.y.max)}),{x:{min:r,mid:(r+i)/2,max:i,size:i-r},y:{min:n,mid:(n+e)/2,max:e,size:e-n}}},shapeintersections:function(t,r,n,i,e){if(!d.bboxoverlap(r,i))return[];var o=[],s=[t.startcap,t.forward,t.back,t.endcap],u=[n.startcap,n.forward,n.back,n.endcap];return s.forEach(function(r){r.virtual||u.forEach(function(i){if(!i.virtual){var s=r.intersects(i,e);s.length>0&&(s.c1=r,s.c2=i,s.s1=t,s.s2=n,o.push(s))}})}),o},makeshape:function(t,r,n){var i=r.points.length,e=t.points.length,o=d.makeline(r.points[i-1],t.points[0]),s=d.makeline(t.points[e-1],r.points[0]),u={startcap:o,forward:t,back:r,endcap:s,bbox:d.findbbox([o,t,r,s])},a=d;return u.intersections=function(t){return a.shapeintersections(u,u.bbox,t,t.bbox,n)},u},getminmax:function(t,r,n){if(!n)return{min:0,max:0};var i,e,o=l,s=p;n.indexOf(0)===-1&&(n=[0].concat(n)),n.indexOf(1)===-1&&n.push(1);for(var u=0,a=n.length;u<a;u++)i=n[u],e=t.get(i),e[r]<o&&(o=e[r]),e[r]>s&&(s=e[r]);return{min:o,mid:(o+s)/2,max:s,size:s-o}},align:function(t,r){var n=r.p1.x,o=r.p1.y,u=-s(r.p2.y-o,r.p2.x-n),a=function(t){return{x:(t.x-n)*i(u)-(t.y-o)*e(u),y:(t.x-n)*e(u)+(t.y-o)*i(u)}};return t.map(a)},roots:function(t,r){r=r||{p1:{x:0,y:0},p2:{x:1,y:0}};var n=t.length-1,e=d.align(t,r),s=function(t){return 0<=t&&t<=1};if(2===n){var a=e[0].y,c=e[1].y,x=e[2].y,y=a-2*c+x;if(0!==y){var l=-u(c*c-a*x),p=-a+c,v=-(l+p)/y,m=-(-l+p)/y;return[v,m].filter(s)}return c!==x&&0===y?[(2*c-x)/(2*c-2*x)].filter(s):[]}var z=e[0].y,g=e[1].y,b=e[2].y,_=e[3].y,y=-z+3*g-3*b+_,a=3*z-6*g+3*b,c=-3*z+3*g,x=z;if(d.approximately(y,0)){if(d.approximately(a,0))return d.approximately(c,0)?[]:[-x/c].filter(s);var w=u(c*c-4*a*x),E=2*a;return[(w-c)/E,(-c-w)/E].filter(s)}a/=y,c/=y,x/=y;var S,v,M,k,j,e=(3*c-a*a)/3,O=e/3,w=(2*a*a*a-9*a*c+27*x)/27,T=w/2,C=T*T+O*O*O;if(C<0){var L=-e/3,N=L*L*L,A=u(N),B=-w/(2*A),F=B<-1?-1:B>1?1:B,I=o(F),q=f(A),P=2*q;return M=P*i(I/3)-a/3,k=P*i((I+h)/3)-a/3,j=P*i((I+2*h)/3)-a/3,[M,k,j].filter(s)}if(0===C)return S=T<0?f(-T):-f(T),M=2*S-a/3,k=-S-a/3,[M,k].filter(s);var R=u(C);return S=f(-T+R),v=f(T+R),[S-v-a/3].filter(s)},droots:function(t){if(3===t.length){var r=t[0],n=t[1],i=t[2],e=r-2*n+i;if(0!==e){var o=-u(n*n-r*i),s=-r+n,a=-(o+s)/e,f=-(-o+s)/e;return[a,f]}return n!==i&&0===e?[(2*n-i)/(2*(n-i))]:[]}if(2===t.length){var r=t[0],n=t[1];return r!==n?[r/(r-n)]:[]}},curvature:function(t,n,i,e){var o,s,f,c,h=d.derive(n),x=h[0],y=h[1],l=0,p=0,v=d.compute(t,x),m=d.compute(t,y),z=v.x*v.x+v.y*v.y;if(i?(o=u(a(v.y*m.z-m.y*v.z,2)+a(v.z*m.x-m.z*v.x,2)+a(v.x*m.y-m.x*v.y,2)),s=a(z+v.z*v.z,1.5)):(o=v.x*m.y-v.y*m.x,s=a(z,1.5)),0===o||0===s)return{k:0,r:0};if(l=o/s,p=s/o,!e){var g=d.curvature(t-.001,n,i,!0).k,b=d.curvature(t+.001,n,i,!0).k;c=(b-l+(l-g))/2,f=(r(b-l)+r(l-g))/2}return{k:l,r:p,dk:c,adk:f}},inflections:function(t){if(t.length<4)return[];var r=d.align(t,{p1:t[0],p2:t.slice(-1)[0]}),n=r[2].x*r[1].y,i=r[3].x*r[1].y,e=r[1].x*r[2].y,o=r[3].x*r[2].y,s=18*(-3*n+2*i+3*e-o),u=18*(3*n-i-3*e),a=18*(e-n);if(d.approximately(s,0)){if(!d.approximately(u,0)){var f=-a/u;if(0<=f&&f<=1)return[f]}return[]}var c=u*u-4*s*a,h=Math.sqrt(c),o=2*s;return d.approximately(o,0)?[]:[(h-u)/o,-(u+h)/o].filter(function(t){return 0<=t&&t<=1})},bboxoverlap:function(t,n){var i,e,o,s,u,a=["x","y"],f=a.length;for(i=0;i<f;i++)if(e=a[i],o=t[e].mid,s=n[e].mid,u=(t[e].size+n[e].size)/2,r(o-s)>=u)return!1;return!0},expandbox:function(t,r){r.x.min<t.x.min&&(t.x.min=r.x.min),r.y.min<t.y.min&&(t.y.min=r.y.min),r.z&&r.z.min<t.z.min&&(t.z.min=r.z.min),r.x.max>t.x.max&&(t.x.max=r.x.max),r.y.max>t.y.max&&(t.y.max=r.y.max),r.z&&r.z.max>t.z.max&&(t.z.max=r.z.max),t.x.mid=(t.x.min+t.x.max)/2,t.y.mid=(t.y.min+t.y.max)/2,t.z&&(t.z.mid=(t.z.min+t.z.max)/2),t.x.size=t.x.max-t.x.min,t.y.size=t.y.max-t.y.min,t.z&&(t.z.size=t.z.max-t.z.min)},pairiteration:function(t,r,n){var i=t.bbox(),e=r.bbox(),o=1e5,s=n||.5;if(i.x.size+i.y.size<s&&e.x.size+e.y.size<s)return[(o*(t._t1+t._t2)/2|0)/o+"/"+(o*(r._t1+r._t2)/2|0)/o];var u=t.split(.5),a=r.split(.5),f=[{left:u.left,right:a.left},{left:u.left,right:a.right},{left:u.right,right:a.right},{left:u.right,right:a.left}];f=f.filter(function(t){return d.bboxoverlap(t.left.bbox(),t.right.bbox())});var c=[];return 0===f.length?c:(f.forEach(function(t){c=c.concat(d.pairiteration(t.left,t.right,s))}),c=c.filter(function(t,r){return c.indexOf(t)===r}))},getccenter:function(t,r,n){var o,u=r.x-t.x,a=r.y-t.y,f=n.x-r.x,c=n.y-r.y,y=u*i(x)-a*e(x),l=u*e(x)+a*i(x),p=f*i(x)-c*e(x),v=f*e(x)+c*i(x),m=(t.x+r.x)/2,z=(t.y+r.y)/2,g=(r.x+n.x)/2,b=(r.y+n.y)/2,_=m+y,w=z+l,E=g+p,S=b+v,M=d.lli8(m,z,_,w,g,b,E,S),k=d.dist(M,t),j=s(t.y-M.y,t.x-M.x),O=s(r.y-M.y,r.x-M.x),T=s(n.y-M.y,n.x-M.x);return j<T?((j>O||O>T)&&(j+=h),j>T&&(o=T,T=j,j=o)):T<O&&O<j?(o=T,T=j,j=o):T+=h,M.s=j,M.e=T,M.r=k,M},numberSort:function(t,r){return t-r}};t.exports=d}()},function(t,r,n){"use strict";!function(){var r=n(2),i=function(t){this.curves=[],this._3d=!1,t&&(this.curves=t,this._3d=this.curves[0]._3d)};i.prototype={valueOf:function(){return this.toString()},toString:function(){return"["+this.curves.map(function(t){return r.pointsToString(t.points)}).join(", ")+"]"},addCurve:function(t){this.curves.push(t),this._3d=this._3d||t._3d},length:function(){return this.curves.map(function(t){return t.length()}).reduce(function(t,r){return t+r})},curve:function(t){return this.curves[t]},bbox:function t(){for(var n=this.curves,t=n[0].bbox(),i=1;i<n.length;i++)r.expandbox(t,n[i].bbox());return t},offset:function t(r){var t=[];return this.curves.forEach(function(n){t=t.concat(n.offset(r))}),new i(t)}},t.exports=i}()},function(t,r,n){"use strict";function i(t,r,n){if("Z"!==r){if("M"===r)return void(s={x:n[0],y:n[1]});var i=[!1,s.x,s.y].concat(n),e=t.bind.apply(t,i),o=new e,u=n.slice(-2);return s={x:u[0],y:u[1]},o}}function e(t,r){for(var n,e,s,u=o(r).split(" "),a=new RegExp("[MLCQZ]",""),f=[],c={C:6,Q:4,L:2,M:2};u.length;)n=u.splice(0,1)[0],a.test(n)&&(s=u.splice(0,c[n]).map(parseFloat),e=i(t,n,s),e&&f.push(e));return new t.PolyBezier(f)}var o=n(5),s={x:!1,y:!1};t.exports=e},function(t,r){"use strict";function n(t){t=t.replace(/,/g," ").replace(/-/g," - ").replace(/-\s+/g,"-").replace(/([a-zA-Z])/g," $1 ");var r,n,i,e,o,s,u=t.replace(/([a-zA-Z])\s?/g,"|$1").split("|"),a=u.length,f=[],c=0,h=0,x=0,y=0,l=0,p=0,v=0,d=0,m="";for(r=1;r<a;r++)if(n=u[r],i=n.substring(0,1),e=i.toLowerCase(),f=n.replace(i,"").trim().split(" "),f=f.filter(function(t){return""!==t}).map(parseFloat),o=f.length,"m"===e){if(m+="M ","m"===i?(x+=f[0],y+=f[1]):(x=f[0],y=f[1]),c=x,h=y,m+=x+" "+y+" ",o>2)for(s=0;s<o;s+=2)"m"===i?(x+=f[s],y+=f[s+1]):(x=f[s],y=f[s+1]),m+=["L",x,y,""].join(" ")}else if("l"===e)for(s=0;s<o;s+=2)"l"===i?(x+=f[s],y+=f[s+1]):(x=f[s],y=f[s+1]),m+=["L",x,y,""].join(" ");else if("h"===e)for(s=0;s<o;s++)"h"===i?x+=f[s]:x=f[s],m+=["L",x,y,""].join(" ");else if("v"===e)for(s=0;s<o;s++)"v"===i?y+=f[s]:y=f[s],m+=["L",x,y,""].join(" ");else if("q"===e)for(s=0;s<o;s+=4)"q"===i?(l=x+f[s],p=y+f[s+1],x+=f[s+2],y+=f[s+3]):(l=f[s],p=f[s+1],x=f[s+2],y=f[s+3]),m+=["Q",l,p,x,y,""].join(" ");else if("t"===e)for(s=0;s<o;s+=2)l=x+(x-l),p=y+(y-p),"t"===i?(x+=f[s],y+=f[s+1]):(x=f[s],y=f[s+1]),m+=["Q",l,p,x,y,""].join(" ");else if("c"===e)for(s=0;s<o;s+=6)"c"===i?(l=x+f[s],p=y+f[s+1],v=x+f[s+2],d=y+f[s+3],x+=f[s+4],y+=f[s+5]):(l=f[s],p=f[s+1],v=f[s+2],d=f[s+3],x=f[s+4],y=f[s+5]),m+=["C",l,p,v,d,x,y,""].join(" ");else if("s"===e)for(s=0;s<o;s+=4)l=x+(x-v),p=y+(y-d),"s"===i?(v=x+f[s],d=y+f[s+1],x+=f[s+2],y+=f[s+3]):(v=f[s],d=f[s+1],x=f[s+2],y=f[s+3]),m+=["C",l,p,v,d,x,y,""].join(" ");else"z"===e&&(m+="Z ",x=c,y=h);return m.trim()}t.exports=n}]);
define('bezier', ['bezier/bezier'], function (main) { return main; });

define("bezier/bezier", function(){});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Text/PolygonText',[
	"x_ite/Fields",
	"x_ite/Browser/Core/PrimitiveQuality",
	"x_ite/Browser/Text/X3DTextGeometry",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Triangle3",
	"bezier",
],
function (Fields,
          PrimitiveQuality,
          X3DTextGeometry,
          X3DGeometryNode,
          Vector3,
          Matrix4,
          Triangle3,
          bezier)
{
"use strict";

	function PolygonText (text, fontStyle)
	{
		X3DTextGeometry .call (this, text, fontStyle);

		text .transparent_ = false;

		this .texCoordArray = X3DGeometryNode .createArray ();
	}

	PolygonText .prototype = Object .assign (Object .create (X3DTextGeometry .prototype),
	{
		constructor: PolygonText,
		getTransparent: function ()
		{
			return false;
		},
		getMatrix: function ()
		{
			return Matrix4 .Identity;
		},
		build: (function ()
		{
			var
				min = new Vector3 (0, 0, 0),
				max = new Vector3 (0, 0, 0);

			return function ()
			{
				var
					fontStyle = this .getFontStyle (),
					font      = fontStyle .getFont ();

				if (! font)
					return;

				var
					text             = this .getText (),
					glyphs           = this .getGlyphs (),
					minorAlignment   = this .getMinorAlignment (),
					translations     = this .getTranslations (),
					charSpacings     = this .getCharSpacings (),
					size             = fontStyle .getScale (),
					spacing          = fontStyle .spacing_ .getValue (),
					origin           = text .origin_ .getValue (),
					sizeUnitsPerEm   = size / font .unitsPerEm,
					primitiveQuality = this .getBrowser () .getBrowserOptions () .getPrimitiveQuality (),
					texCoordArray    = this .texCoordArray,
					normalArray      = text .getNormals (),
					vertexArray      = text .getVertices ();

				// Set texCoords.

				text .getMultiTexCoords () .push (texCoordArray);

				this .getBBox () .getExtents (min, max);
				text .getMin () .assign (min);
				text .getMax () .assign (max);

				if (fontStyle .horizontal_ .getValue ())
				{
					for (var l = 0, length = glyphs .length; l < length; ++ l)
					{
						var
							line         = glyphs [l],
							charSpacing  = charSpacings [l],
							translation  = translations [l],
							advanceWidth = 0;

						for (var g = 0, gl = line .length; g < gl; ++ g)
						{
							var
								glyph         = line [g],
								glyphVertices = this .getGlyphGeometry (font, glyph, primitiveQuality),
								xOffset       = minorAlignment .x + translation .x + advanceWidth + g * charSpacing,
								yOffset       = minorAlignment .y + translation .y;

							for (var v = 0, vl = glyphVertices .length; v < vl; ++ v)
							{
								var
									x = glyphVertices [v] .x * size + xOffset,
									y = glyphVertices [v] .y * size + yOffset;

								texCoordArray .push ((x - origin .x) / spacing, (y - origin .y) / spacing, 0, 1);
								normalArray   .push (0, 0, 1);
								vertexArray   .push (x, y, 0, 1);
							}

							// Calculate advanceWidth.

							var kerning = 0;

							if (g + 1 < line .length)
								kerning = font .getKerningValue (glyph, line [g + 1]);

							advanceWidth += (glyph .advanceWidth + kerning) * sizeUnitsPerEm;
						}
					}
				}
				else
				{
					var
						leftToRight = fontStyle .leftToRight_ .getValue (),
						topToBottom = fontStyle .topToBottom_ .getValue (),
						first       = leftToRight ? 0 : text .string_ .length - 1,
						last        = leftToRight ? text .string_ .length  : -1,
						step        = leftToRight ? 1 : -1;

					for (var l = first, t = 0; l !== last; l += step)
					{
						var line = glyphs [l];

						var
						   numChars = line .length,
							firstG   = topToBottom ? 0 : numChars - 1,
							lastG    = topToBottom ? numChars : -1,
							stepG    = topToBottom ? 1 : -1;

						for (var g = firstG; g !== lastG; g += stepG, ++ t)
						{
							var
								translation   = translations [t],
								glyphVertices = this .getGlyphGeometry (font, line [g], primitiveQuality);

							for (var v = 0, vl = glyphVertices .length; v < vl; ++ v)
							{
								var
									x = glyphVertices [v] .x * size + minorAlignment .x + translation .x,
									y = glyphVertices [v] .y * size + minorAlignment .y + translation .y;

								texCoordArray .push ((x - origin .x) / spacing, (y - origin .y) / spacing, 0, 1);
								normalArray   .push (0, 0, 1);
								vertexArray   .push (x, y, 0, 1);
							}
						}
					}
				}
			};
		})(),
		getGlyphExtents: function (font, glyph, primitiveQuality, min, max)
		{
			var
				glyphCache = this .getBrowser () .getGlyph (font, primitiveQuality, glyph .index),
				extents    = glyphCache .extents;

			if (extents)
			{
				min .assign (extents .min);
				max .assign (extents .max);
				return;
			}

			var vertices = this .getGlyphGeometry (font, glyph, primitiveQuality);

			if (vertices .length)
			{
				var vertex = vertices [0];

				min .assign (vertex);
				max .assign (vertex);

				for (var i = 1, length = vertices .length; i < length; ++ i)
				{
					var vertex = vertices [i];

					min .min (vertex);
					max .max (vertex);
				}
			}
			else
			{
				min .set (0, 0, 0);
				max .set (0, 0, 0);
			}

			var extents = glyphCache .extents = { };

			extents .min = min .copy ();
			extents .max = max .copy ();
		},
		getGlyphGeometry: function (font, glyph, primitiveQuality)
		{
			var
				glyphCache    = this .getBrowser () .getGlyph (font, primitiveQuality, glyph .index),
				glyphGeometry = glyphCache .geometry;

			if (glyphGeometry)
				return glyphGeometry;

			glyphGeometry = glyphCache .geometry = [ ];

			this .createGlyphGeometry (glyph, glyphGeometry, primitiveQuality);

		   return glyphGeometry;
		},
		createGlyphGeometry: (function ()
		{
			var
				points = [ ],
				curves = [ ],
				normal = new Vector3 (0, 0, 0);

			return function (glyph, vertices, primitiveQuality)
			{
				// Get curves for the current glyph.

				var
					dimension  = this .getBezierDimension (primitiveQuality),
					path       = glyph .getPath (0, 0, 1),
					commands   = path .commands,
					x          = 0,
					y          = 0;

				points .length = 0;
				curves .length = 0;

				for (var i = 0, cl = commands .length; i < cl; ++ i)
				{
					var command = commands [i];

					switch (command .type)
					{
						case "M": // Start
						case "Z": // End
						{
							if (points .length > 2)
							{
								if (points [0] .x === points [points .length - 1] .x && points [0] .y === points [points .length - 1] .y)
									points .pop ();

								curves .push (points);
							}

							points = [ ];

							if (command .type === "M")
								points .push (new Vector3 (command .x, -command .y, 0));

							break;
						}
						case "L": // Linear
						{
							points .push (new Vector3 (command .x, -command .y, 0));
							break;
						}
						case "C": // Cubic
						{
							var
								curve = new Bezier (x, -y, command .x1, -command .y1, command .x2, -command .y2, command .x, -command .y),
								lut   = curve .getLUT (dimension);

							for (var l = 1, ll = lut .length; l < ll; ++ l)
								points .push (new Vector3 (lut [l] .x, lut [l] .y, 0));

							break;
						}
						case "Q": // Quadric
						{
							var
								curve = new Bezier (x, -y, command .x1, -command .y1, command .x, -command .y),
								lut   = curve .getLUT (dimension);

							for (var l = 1, ll = lut .length; l < ll; ++ l)
								points .push (new Vector3 (lut [l] .x, lut [l] .y, 0));

							break;
						}
						default:
						   continue;
					}

					x = command .x;
					y = command .y;
				}

				// Triangulate contours.

				curves = curves .map (function (curve)
				{
					Triangle3 .getPolygonNormal (curve, normal);

					if (normal .dot (Vector3 .zAxis) > 0)
						return curve;

					return curve .reverse ();
				});

				curves .push (vertices);

				Triangle3 .triangulatePolygon .apply (Triangle3, curves);
			};
		})(),
		getBezierDimension: function (primitiveQuality)
		{
			switch (primitiveQuality)
			{
				case PrimitiveQuality .LOW:
					return 3;
				case PrimitiveQuality .HIGH:
					return 7;
				default:
					return 5;
			}
		},
		display: function (gl, context)
		{ },
		transformLine: function (line)
		{ },
		transformMatrix: function (matrix)
		{ },
	});

	return PolygonText;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Text/FontStyle',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Text/X3DFontStyleNode",
	"x_ite/Browser/Text/PolygonText",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DFontStyleNode,
          PolygonText,
          X3DConstants)
{
"use strict";

	function FontStyle (executionContext)
	{
		X3DFontStyleNode .call (this, executionContext);

		this .addType (X3DConstants .FontStyle);

		this .size_ .setUnit ("length");
	}

	FontStyle .prototype = Object .assign (Object .create (X3DFontStyleNode .prototype),
	{
		constructor: FontStyle,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",    new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "language",    new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "family",      new Fields .MFString ("SERIF")),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "style",       new Fields .SFString ("PLAIN")),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "size",        new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "spacing",     new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "horizontal",  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "leftToRight", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "topToBottom", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "justify",     new Fields .MFString ("BEGIN")),
		]),
		getTypeName: function ()
		{
			return "FontStyle";
		},
		getComponentName: function ()
		{
			return "Text";
		},
		getContainerField: function ()
		{
			return "fontStyle";
		},
		getTextGeometry: function (text)
		{
			return new PolygonText (text, this);
		},
		getScale: function ()
		{
			return this .size_ .getValue ();
		},
	});

	return FontStyle;
});

/**
 * https://opentype.js.org v0.11.0 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define('opentype/dist/opentype',['exports'], factory) :
	(factory((global.opentype = {})));
}(this, (function (exports) { 'use strict';

	/*! https://mths.be/codepointat v0.2.0 by @mathias */
	if (!String.prototype.codePointAt) {
		(function() {
			var defineProperty = (function() {
				// IE 8 only supports `Object.defineProperty` on DOM elements
				try {
					var object = {};
					var $defineProperty = Object.defineProperty;
					var result = $defineProperty(object, object, object) && $defineProperty;
				} catch(error) {}
				return result;
			}());
			var codePointAt = function(position) {
				if (this == null) {
					throw TypeError();
				}
				var string = String(this);
				var size = string.length;
				// `ToInteger`
				var index = position ? Number(position) : 0;
				if (index != index) { // better `isNaN`
					index = 0;
				}
				// Account for out-of-bounds indices:
				if (index < 0 || index >= size) {
					return undefined;
				}
				// Get the first code unit
				var first = string.charCodeAt(index);
				var second;
				if ( // check if it’s the start of a surrogate pair
					first >= 0xD800 && first <= 0xDBFF && // high surrogate
					size > index + 1 // there is a next code unit
				) {
					second = string.charCodeAt(index + 1);
					if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
						return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
					}
				}
				return first;
			};
			if (defineProperty) {
				defineProperty(String.prototype, 'codePointAt', {
					'value': codePointAt,
					'configurable': true,
					'writable': true
				});
			} else {
				String.prototype.codePointAt = codePointAt;
			}
		}());
	}

	var TINF_OK = 0;
	var TINF_DATA_ERROR = -3;

	function Tree() {
	  this.table = new Uint16Array(16);   /* table of code length counts */
	  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
	}

	function Data(source, dest) {
	  this.source = source;
	  this.sourceIndex = 0;
	  this.tag = 0;
	  this.bitcount = 0;
	  
	  this.dest = dest;
	  this.destLen = 0;
	  
	  this.ltree = new Tree();  /* dynamic length/symbol tree */
	  this.dtree = new Tree();  /* dynamic distance tree */
	}

	/* --------------------------------------------------- *
	 * -- uninitialized global data (static structures) -- *
	 * --------------------------------------------------- */

	var sltree = new Tree();
	var sdtree = new Tree();

	/* extra bits and base tables for length codes */
	var length_bits = new Uint8Array(30);
	var length_base = new Uint16Array(30);

	/* extra bits and base tables for distance codes */
	var dist_bits = new Uint8Array(30);
	var dist_base = new Uint16Array(30);

	/* special ordering of code length codes */
	var clcidx = new Uint8Array([
	  16, 17, 18, 0, 8, 7, 9, 6,
	  10, 5, 11, 4, 12, 3, 13, 2,
	  14, 1, 15
	]);

	/* used by tinf_decode_trees, avoids allocations every call */
	var code_tree = new Tree();
	var lengths = new Uint8Array(288 + 32);

	/* ----------------------- *
	 * -- utility functions -- *
	 * ----------------------- */

	/* build extra bits and base tables */
	function tinf_build_bits_base(bits, base, delta, first) {
	  var i, sum;

	  /* build bits table */
	  for (i = 0; i < delta; ++i) { bits[i] = 0; }
	  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }

	  /* build base table */
	  for (sum = first, i = 0; i < 30; ++i) {
	    base[i] = sum;
	    sum += 1 << bits[i];
	  }
	}

	/* build the fixed huffman trees */
	function tinf_build_fixed_trees(lt, dt) {
	  var i;

	  /* build fixed length tree */
	  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }

	  lt.table[7] = 24;
	  lt.table[8] = 152;
	  lt.table[9] = 112;

	  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
	  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
	  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
	  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }

	  /* build fixed distance tree */
	  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }

	  dt.table[5] = 32;

	  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
	}

	/* given an array of code lengths, build a tree */
	var offs = new Uint16Array(16);

	function tinf_build_tree(t, lengths, off, num) {
	  var i, sum;

	  /* clear code length count table */
	  for (i = 0; i < 16; ++i) { t.table[i] = 0; }

	  /* scan symbol lengths, and sum code length counts */
	  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }

	  t.table[0] = 0;

	  /* compute offset table for distribution sort */
	  for (sum = 0, i = 0; i < 16; ++i) {
	    offs[i] = sum;
	    sum += t.table[i];
	  }

	  /* create code->symbol translation table (symbols sorted by code) */
	  for (i = 0; i < num; ++i) {
	    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
	  }
	}

	/* ---------------------- *
	 * -- decode functions -- *
	 * ---------------------- */

	/* get one bit from source stream */
	function tinf_getbit(d) {
	  /* check if tag is empty */
	  if (!d.bitcount--) {
	    /* load next tag */
	    d.tag = d.source[d.sourceIndex++];
	    d.bitcount = 7;
	  }

	  /* shift bit out of tag */
	  var bit = d.tag & 1;
	  d.tag >>>= 1;

	  return bit;
	}

	/* read a num bit value from a stream and add base */
	function tinf_read_bits(d, num, base) {
	  if (!num)
	    { return base; }

	  while (d.bitcount < 24) {
	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
	    d.bitcount += 8;
	  }

	  var val = d.tag & (0xffff >>> (16 - num));
	  d.tag >>>= num;
	  d.bitcount -= num;
	  return val + base;
	}

	/* given a data stream and a tree, decode a symbol */
	function tinf_decode_symbol(d, t) {
	  while (d.bitcount < 24) {
	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
	    d.bitcount += 8;
	  }
	  
	  var sum = 0, cur = 0, len = 0;
	  var tag = d.tag;

	  /* get more bits while code value is above sum */
	  do {
	    cur = 2 * cur + (tag & 1);
	    tag >>>= 1;
	    ++len;

	    sum += t.table[len];
	    cur -= t.table[len];
	  } while (cur >= 0);
	  
	  d.tag = tag;
	  d.bitcount -= len;

	  return t.trans[sum + cur];
	}

	/* given a data stream, decode dynamic trees from it */
	function tinf_decode_trees(d, lt, dt) {
	  var hlit, hdist, hclen;
	  var i, num, length;

	  /* get 5 bits HLIT (257-286) */
	  hlit = tinf_read_bits(d, 5, 257);

	  /* get 5 bits HDIST (1-32) */
	  hdist = tinf_read_bits(d, 5, 1);

	  /* get 4 bits HCLEN (4-19) */
	  hclen = tinf_read_bits(d, 4, 4);

	  for (i = 0; i < 19; ++i) { lengths[i] = 0; }

	  /* read code lengths for code length alphabet */
	  for (i = 0; i < hclen; ++i) {
	    /* get 3 bits code length (0-7) */
	    var clen = tinf_read_bits(d, 3, 0);
	    lengths[clcidx[i]] = clen;
	  }

	  /* build code length tree */
	  tinf_build_tree(code_tree, lengths, 0, 19);

	  /* decode code lengths for the dynamic trees */
	  for (num = 0; num < hlit + hdist;) {
	    var sym = tinf_decode_symbol(d, code_tree);

	    switch (sym) {
	      case 16:
	        /* copy previous code length 3-6 times (read 2 bits) */
	        var prev = lengths[num - 1];
	        for (length = tinf_read_bits(d, 2, 3); length; --length) {
	          lengths[num++] = prev;
	        }
	        break;
	      case 17:
	        /* repeat code length 0 for 3-10 times (read 3 bits) */
	        for (length = tinf_read_bits(d, 3, 3); length; --length) {
	          lengths[num++] = 0;
	        }
	        break;
	      case 18:
	        /* repeat code length 0 for 11-138 times (read 7 bits) */
	        for (length = tinf_read_bits(d, 7, 11); length; --length) {
	          lengths[num++] = 0;
	        }
	        break;
	      default:
	        /* values 0-15 represent the actual code lengths */
	        lengths[num++] = sym;
	        break;
	    }
	  }

	  /* build dynamic trees */
	  tinf_build_tree(lt, lengths, 0, hlit);
	  tinf_build_tree(dt, lengths, hlit, hdist);
	}

	/* ----------------------------- *
	 * -- block inflate functions -- *
	 * ----------------------------- */

	/* given a stream and two trees, inflate a block of data */
	function tinf_inflate_block_data(d, lt, dt) {
	  while (1) {
	    var sym = tinf_decode_symbol(d, lt);

	    /* check for end of block */
	    if (sym === 256) {
	      return TINF_OK;
	    }

	    if (sym < 256) {
	      d.dest[d.destLen++] = sym;
	    } else {
	      var length, dist, offs;
	      var i;

	      sym -= 257;

	      /* possibly get more bits from length code */
	      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

	      dist = tinf_decode_symbol(d, dt);

	      /* possibly get more bits from distance code */
	      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

	      /* copy match */
	      for (i = offs; i < offs + length; ++i) {
	        d.dest[d.destLen++] = d.dest[i];
	      }
	    }
	  }
	}

	/* inflate an uncompressed block of data */
	function tinf_inflate_uncompressed_block(d) {
	  var length, invlength;
	  var i;
	  
	  /* unread from bitbuffer */
	  while (d.bitcount > 8) {
	    d.sourceIndex--;
	    d.bitcount -= 8;
	  }

	  /* get length */
	  length = d.source[d.sourceIndex + 1];
	  length = 256 * length + d.source[d.sourceIndex];

	  /* get one's complement of length */
	  invlength = d.source[d.sourceIndex + 3];
	  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

	  /* check length */
	  if (length !== (~invlength & 0x0000ffff))
	    { return TINF_DATA_ERROR; }

	  d.sourceIndex += 4;

	  /* copy block */
	  for (i = length; i; --i)
	    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }

	  /* make sure we start next block on a byte boundary */
	  d.bitcount = 0;

	  return TINF_OK;
	}

	/* inflate stream from source to dest */
	function tinf_uncompress(source, dest) {
	  var d = new Data(source, dest);
	  var bfinal, btype, res;

	  do {
	    /* read final block flag */
	    bfinal = tinf_getbit(d);

	    /* read block type (2 bits) */
	    btype = tinf_read_bits(d, 2, 0);

	    /* decompress block */
	    switch (btype) {
	      case 0:
	        /* decompress uncompressed block */
	        res = tinf_inflate_uncompressed_block(d);
	        break;
	      case 1:
	        /* decompress block with fixed huffman trees */
	        res = tinf_inflate_block_data(d, sltree, sdtree);
	        break;
	      case 2:
	        /* decompress block with dynamic huffman trees */
	        tinf_decode_trees(d, d.ltree, d.dtree);
	        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
	        break;
	      default:
	        res = TINF_DATA_ERROR;
	    }

	    if (res !== TINF_OK)
	      { throw new Error('Data error'); }

	  } while (!bfinal);

	  if (d.destLen < d.dest.length) {
	    if (typeof d.dest.slice === 'function')
	      { return d.dest.slice(0, d.destLen); }
	    else
	      { return d.dest.subarray(0, d.destLen); }
	  }
	  
	  return d.dest;
	}

	/* -------------------- *
	 * -- initialization -- *
	 * -------------------- */

	/* build fixed huffman trees */
	tinf_build_fixed_trees(sltree, sdtree);

	/* build extra bits and base tables */
	tinf_build_bits_base(length_bits, length_base, 4, 3);
	tinf_build_bits_base(dist_bits, dist_base, 2, 1);

	/* fix a special case */
	length_bits[28] = 0;
	length_base[28] = 258;

	var tinyInflate = tinf_uncompress;

	// The Bounding Box object

	function derive(v0, v1, v2, v3, t) {
	    return Math.pow(1 - t, 3) * v0 +
	        3 * Math.pow(1 - t, 2) * t * v1 +
	        3 * (1 - t) * Math.pow(t, 2) * v2 +
	        Math.pow(t, 3) * v3;
	}
	/**
	 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
	 * It is used to calculate the bounding box of a glyph or text path.
	 *
	 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
	 *
	 * @exports opentype.BoundingBox
	 * @class
	 * @constructor
	 */
	function BoundingBox() {
	    this.x1 = Number.NaN;
	    this.y1 = Number.NaN;
	    this.x2 = Number.NaN;
	    this.y2 = Number.NaN;
	}

	/**
	 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
	 */
	BoundingBox.prototype.isEmpty = function() {
	    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
	};

	/**
	 * Add the point to the bounding box.
	 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
	 * @param {number} x - The X coordinate of the point.
	 * @param {number} y - The Y coordinate of the point.
	 */
	BoundingBox.prototype.addPoint = function(x, y) {
	    if (typeof x === 'number') {
	        if (isNaN(this.x1) || isNaN(this.x2)) {
	            this.x1 = x;
	            this.x2 = x;
	        }
	        if (x < this.x1) {
	            this.x1 = x;
	        }
	        if (x > this.x2) {
	            this.x2 = x;
	        }
	    }
	    if (typeof y === 'number') {
	        if (isNaN(this.y1) || isNaN(this.y2)) {
	            this.y1 = y;
	            this.y2 = y;
	        }
	        if (y < this.y1) {
	            this.y1 = y;
	        }
	        if (y > this.y2) {
	            this.y2 = y;
	        }
	    }
	};

	/**
	 * Add a X coordinate to the bounding box.
	 * This extends the bounding box to include the X coordinate.
	 * This function is used internally inside of addBezier.
	 * @param {number} x - The X coordinate of the point.
	 */
	BoundingBox.prototype.addX = function(x) {
	    this.addPoint(x, null);
	};

	/**
	 * Add a Y coordinate to the bounding box.
	 * This extends the bounding box to include the Y coordinate.
	 * This function is used internally inside of addBezier.
	 * @param {number} y - The Y coordinate of the point.
	 */
	BoundingBox.prototype.addY = function(y) {
	    this.addPoint(null, y);
	};

	/**
	 * Add a Bézier curve to the bounding box.
	 * This extends the bounding box to include the entire Bézier.
	 * @param {number} x0 - The starting X coordinate.
	 * @param {number} y0 - The starting Y coordinate.
	 * @param {number} x1 - The X coordinate of the first control point.
	 * @param {number} y1 - The Y coordinate of the first control point.
	 * @param {number} x2 - The X coordinate of the second control point.
	 * @param {number} y2 - The Y coordinate of the second control point.
	 * @param {number} x - The ending X coordinate.
	 * @param {number} y - The ending Y coordinate.
	 */
	BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
	    var this$1 = this;

	    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
	    // and https://github.com/icons8/svg-path-bounding-box

	    var p0 = [x0, y0];
	    var p1 = [x1, y1];
	    var p2 = [x2, y2];
	    var p3 = [x, y];

	    this.addPoint(x0, y0);
	    this.addPoint(x, y);

	    for (var i = 0; i <= 1; i++) {
	        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
	        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
	        var c = 3 * p1[i] - 3 * p0[i];

	        if (a === 0) {
	            if (b === 0) { continue; }
	            var t = -c / b;
	            if (0 < t && t < 1) {
	                if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
	                if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
	            }
	            continue;
	        }

	        var b2ac = Math.pow(b, 2) - 4 * c * a;
	        if (b2ac < 0) { continue; }
	        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
	        if (0 < t1 && t1 < 1) {
	            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
	            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
	        }
	        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
	        if (0 < t2 && t2 < 1) {
	            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
	            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
	        }
	    }
	};

	/**
	 * Add a quadratic curve to the bounding box.
	 * This extends the bounding box to include the entire quadratic curve.
	 * @param {number} x0 - The starting X coordinate.
	 * @param {number} y0 - The starting Y coordinate.
	 * @param {number} x1 - The X coordinate of the control point.
	 * @param {number} y1 - The Y coordinate of the control point.
	 * @param {number} x - The ending X coordinate.
	 * @param {number} y - The ending Y coordinate.
	 */
	BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
	    var cp1x = x0 + 2 / 3 * (x1 - x0);
	    var cp1y = y0 + 2 / 3 * (y1 - y0);
	    var cp2x = cp1x + 1 / 3 * (x - x0);
	    var cp2y = cp1y + 1 / 3 * (y - y0);
	    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
	};

	// Geometric objects

	/**
	 * A bézier path containing a set of path commands similar to a SVG path.
	 * Paths can be drawn on a context using `draw`.
	 * @exports opentype.Path
	 * @class
	 * @constructor
	 */
	function Path() {
	    this.commands = [];
	    this.fill = 'black';
	    this.stroke = null;
	    this.strokeWidth = 1;
	}

	/**
	 * @param  {number} x
	 * @param  {number} y
	 */
	Path.prototype.moveTo = function(x, y) {
	    this.commands.push({
	        type: 'M',
	        x: x,
	        y: y
	    });
	};

	/**
	 * @param  {number} x
	 * @param  {number} y
	 */
	Path.prototype.lineTo = function(x, y) {
	    this.commands.push({
	        type: 'L',
	        x: x,
	        y: y
	    });
	};

	/**
	 * Draws cubic curve
	 * @function
	 * curveTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control 1
	 * @param  {number} y1 - y of control 1
	 * @param  {number} x2 - x of control 2
	 * @param  {number} y2 - y of control 2
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 */

	/**
	 * Draws cubic curve
	 * @function
	 * bezierCurveTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control 1
	 * @param  {number} y1 - y of control 1
	 * @param  {number} x2 - x of control 2
	 * @param  {number} y2 - y of control 2
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 * @see curveTo
	 */
	Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
	    this.commands.push({
	        type: 'C',
	        x1: x1,
	        y1: y1,
	        x2: x2,
	        y2: y2,
	        x: x,
	        y: y
	    });
	};

	/**
	 * Draws quadratic curve
	 * @function
	 * quadraticCurveTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control
	 * @param  {number} y1 - y of control
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 */

	/**
	 * Draws quadratic curve
	 * @function
	 * quadTo
	 * @memberof opentype.Path.prototype
	 * @param  {number} x1 - x of control
	 * @param  {number} y1 - y of control
	 * @param  {number} x - x of path point
	 * @param  {number} y - y of path point
	 */
	Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
	    this.commands.push({
	        type: 'Q',
	        x1: x1,
	        y1: y1,
	        x: x,
	        y: y
	    });
	};

	/**
	 * Closes the path
	 * @function closePath
	 * @memberof opentype.Path.prototype
	 */

	/**
	 * Close the path
	 * @function close
	 * @memberof opentype.Path.prototype
	 */
	Path.prototype.close = Path.prototype.closePath = function() {
	    this.commands.push({
	        type: 'Z'
	    });
	};

	/**
	 * Add the given path or list of commands to the commands of this path.
	 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
	 */
	Path.prototype.extend = function(pathOrCommands) {
	    if (pathOrCommands.commands) {
	        pathOrCommands = pathOrCommands.commands;
	    } else if (pathOrCommands instanceof BoundingBox) {
	        var box = pathOrCommands;
	        this.moveTo(box.x1, box.y1);
	        this.lineTo(box.x2, box.y1);
	        this.lineTo(box.x2, box.y2);
	        this.lineTo(box.x1, box.y2);
	        this.close();
	        return;
	    }

	    Array.prototype.push.apply(this.commands, pathOrCommands);
	};

	/**
	 * Calculate the bounding box of the path.
	 * @returns {opentype.BoundingBox}
	 */
	Path.prototype.getBoundingBox = function() {
	    var this$1 = this;

	    var box = new BoundingBox();

	    var startX = 0;
	    var startY = 0;
	    var prevX = 0;
	    var prevY = 0;
	    for (var i = 0; i < this.commands.length; i++) {
	        var cmd = this$1.commands[i];
	        switch (cmd.type) {
	            case 'M':
	                box.addPoint(cmd.x, cmd.y);
	                startX = prevX = cmd.x;
	                startY = prevY = cmd.y;
	                break;
	            case 'L':
	                box.addPoint(cmd.x, cmd.y);
	                prevX = cmd.x;
	                prevY = cmd.y;
	                break;
	            case 'Q':
	                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
	                prevX = cmd.x;
	                prevY = cmd.y;
	                break;
	            case 'C':
	                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	                prevX = cmd.x;
	                prevY = cmd.y;
	                break;
	            case 'Z':
	                prevX = startX;
	                prevY = startY;
	                break;
	            default:
	                throw new Error('Unexpected path command ' + cmd.type);
	        }
	    }
	    if (box.isEmpty()) {
	        box.addPoint(0, 0);
	    }
	    return box;
	};

	/**
	 * Draw the path to a 2D context.
	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
	 */
	Path.prototype.draw = function(ctx) {
	    var this$1 = this;

	    ctx.beginPath();
	    for (var i = 0; i < this.commands.length; i += 1) {
	        var cmd = this$1.commands[i];
	        if (cmd.type === 'M') {
	            ctx.moveTo(cmd.x, cmd.y);
	        } else if (cmd.type === 'L') {
	            ctx.lineTo(cmd.x, cmd.y);
	        } else if (cmd.type === 'C') {
	            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	        } else if (cmd.type === 'Q') {
	            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
	        } else if (cmd.type === 'Z') {
	            ctx.closePath();
	        }
	    }

	    if (this.fill) {
	        ctx.fillStyle = this.fill;
	        ctx.fill();
	    }

	    if (this.stroke) {
	        ctx.strokeStyle = this.stroke;
	        ctx.lineWidth = this.strokeWidth;
	        ctx.stroke();
	    }
	};

	/**
	 * Convert the Path to a string of path data instructions
	 * See http://www.w3.org/TR/SVG/paths.html#PathData
	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
	 * @return {string}
	 */
	Path.prototype.toPathData = function(decimalPlaces) {
	    var this$1 = this;

	    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

	    function floatToString(v) {
	        if (Math.round(v) === v) {
	            return '' + Math.round(v);
	        } else {
	            return v.toFixed(decimalPlaces);
	        }
	    }

	    function packValues() {
	        var arguments$1 = arguments;

	        var s = '';
	        for (var i = 0; i < arguments.length; i += 1) {
	            var v = arguments$1[i];
	            if (v >= 0 && i > 0) {
	                s += ' ';
	            }

	            s += floatToString(v);
	        }

	        return s;
	    }

	    var d = '';
	    for (var i = 0; i < this.commands.length; i += 1) {
	        var cmd = this$1.commands[i];
	        if (cmd.type === 'M') {
	            d += 'M' + packValues(cmd.x, cmd.y);
	        } else if (cmd.type === 'L') {
	            d += 'L' + packValues(cmd.x, cmd.y);
	        } else if (cmd.type === 'C') {
	            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	        } else if (cmd.type === 'Q') {
	            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
	        } else if (cmd.type === 'Z') {
	            d += 'Z';
	        }
	    }

	    return d;
	};

	/**
	 * Convert the path to an SVG <path> element, as a string.
	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
	 * @return {string}
	 */
	Path.prototype.toSVG = function(decimalPlaces) {
	    var svg = '<path d="';
	    svg += this.toPathData(decimalPlaces);
	    svg += '"';
	    if (this.fill && this.fill !== 'black') {
	        if (this.fill === null) {
	            svg += ' fill="none"';
	        } else {
	            svg += ' fill="' + this.fill + '"';
	        }
	    }

	    if (this.stroke) {
	        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
	    }

	    svg += '/>';
	    return svg;
	};

	/**
	 * Convert the path to a DOM element.
	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
	 * @return {SVGPathElement}
	 */
	Path.prototype.toDOMElement = function(decimalPlaces) {
	    var temporaryPath = this.toPathData(decimalPlaces);
	    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

	    newPath.setAttribute('d', temporaryPath);

	    return newPath;
	};

	// Run-time checking of preconditions.

	function fail(message) {
	    throw new Error(message);
	}

	// Precondition function that checks if the given predicate is true.
	// If not, it will throw an error.
	function argument(predicate, message) {
	    if (!predicate) {
	        fail(message);
	    }
	}
	var check = { fail: fail, argument: argument, assert: argument };

	// Data types used in the OpenType font file.

	var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
	var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

	/**
	 * @exports opentype.decode
	 * @class
	 */
	var decode = {};
	/**
	 * @exports opentype.encode
	 * @class
	 */
	var encode = {};
	/**
	 * @exports opentype.sizeOf
	 * @class
	 */
	var sizeOf = {};

	// Return a function that always returns the same value.
	function constant(v) {
	    return function() {
	        return v;
	    };
	}

	// OpenType data types //////////////////////////////////////////////////////

	/**
	 * Convert an 8-bit unsigned integer to a list of 1 byte.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.BYTE = function(v) {
	    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
	    return [v];
	};
	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.BYTE = constant(1);

	/**
	 * Convert a 8-bit signed integer to a list of 1 byte.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.CHAR = function(v) {
	    return [v.charCodeAt(0)];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.CHAR = constant(1);

	/**
	 * Convert an ASCII string to a list of bytes.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.CHARARRAY = function(v) {
	    var b = [];
	    for (var i = 0; i < v.length; i += 1) {
	        b[i] = v.charCodeAt(i);
	    }

	    return b;
	};

	/**
	 * @param {Array}
	 * @returns {number}
	 */
	sizeOf.CHARARRAY = function(v) {
	    return v.length;
	};

	/**
	 * Convert a 16-bit unsigned integer to a list of 2 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.USHORT = function(v) {
	    return [(v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.USHORT = constant(2);

	/**
	 * Convert a 16-bit signed integer to a list of 2 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.SHORT = function(v) {
	    // Two's complement
	    if (v >= LIMIT16) {
	        v = -(2 * LIMIT16 - v);
	    }

	    return [(v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.SHORT = constant(2);

	/**
	 * Convert a 24-bit unsigned integer to a list of 3 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.UINT24 = function(v) {
	    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.UINT24 = constant(3);

	/**
	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.ULONG = function(v) {
	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.ULONG = constant(4);

	/**
	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.LONG = function(v) {
	    // Two's complement
	    if (v >= LIMIT32) {
	        v = -(2 * LIMIT32 - v);
	    }

	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.LONG = constant(4);

	encode.FIXED = encode.ULONG;
	sizeOf.FIXED = sizeOf.ULONG;

	encode.FWORD = encode.SHORT;
	sizeOf.FWORD = sizeOf.SHORT;

	encode.UFWORD = encode.USHORT;
	sizeOf.UFWORD = sizeOf.USHORT;

	/**
	 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.LONGDATETIME = function(v) {
	    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.LONGDATETIME = constant(8);

	/**
	 * Convert a 4-char tag to a list of 4 bytes.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.TAG = function(v) {
	    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
	    return [v.charCodeAt(0),
	            v.charCodeAt(1),
	            v.charCodeAt(2),
	            v.charCodeAt(3)];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.TAG = constant(4);

	// CFF data types ///////////////////////////////////////////////////////////

	encode.Card8 = encode.BYTE;
	sizeOf.Card8 = sizeOf.BYTE;

	encode.Card16 = encode.USHORT;
	sizeOf.Card16 = sizeOf.USHORT;

	encode.OffSize = encode.BYTE;
	sizeOf.OffSize = sizeOf.BYTE;

	encode.SID = encode.USHORT;
	sizeOf.SID = sizeOf.USHORT;

	// Convert a numeric operand or charstring number to a variable-size list of bytes.
	/**
	 * Convert a numeric operand or charstring number to a variable-size list of bytes.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.NUMBER = function(v) {
	    if (v >= -107 && v <= 107) {
	        return [v + 139];
	    } else if (v >= 108 && v <= 1131) {
	        v = v - 108;
	        return [(v >> 8) + 247, v & 0xFF];
	    } else if (v >= -1131 && v <= -108) {
	        v = -v - 108;
	        return [(v >> 8) + 251, v & 0xFF];
	    } else if (v >= -32768 && v <= 32767) {
	        return encode.NUMBER16(v);
	    } else {
	        return encode.NUMBER32(v);
	    }
	};

	/**
	 * @param {number}
	 * @returns {number}
	 */
	sizeOf.NUMBER = function(v) {
	    return encode.NUMBER(v).length;
	};

	/**
	 * Convert a signed number between -32768 and +32767 to a three-byte value.
	 * This ensures we always use three bytes, but is not the most compact format.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.NUMBER16 = function(v) {
	    return [28, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.NUMBER16 = constant(3);

	/**
	 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
	 * This is useful if you want to be sure you always use four bytes,
	 * at the expense of wasting a few bytes for smaller numbers.
	 * @param {number}
	 * @returns {Array}
	 */
	encode.NUMBER32 = function(v) {
	    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
	};

	/**
	 * @constant
	 * @type {number}
	 */
	sizeOf.NUMBER32 = constant(5);

	/**
	 * @param {number}
	 * @returns {Array}
	 */
	encode.REAL = function(v) {
	    var value = v.toString();

	    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
	    // This code converts it back to a number without the epsilon.
	    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
	    if (m) {
	        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
	        value = (Math.round(v * epsilon) / epsilon).toString();
	    }

	    var nibbles = '';
	    for (var i = 0, ii = value.length; i < ii; i += 1) {
	        var c = value[i];
	        if (c === 'e') {
	            nibbles += value[++i] === '-' ? 'c' : 'b';
	        } else if (c === '.') {
	            nibbles += 'a';
	        } else if (c === '-') {
	            nibbles += 'e';
	        } else {
	            nibbles += c;
	        }
	    }

	    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
	    var out = [30];
	    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
	        out.push(parseInt(nibbles.substr(i$1, 2), 16));
	    }

	    return out;
	};

	/**
	 * @param {number}
	 * @returns {number}
	 */
	sizeOf.REAL = function(v) {
	    return encode.REAL(v).length;
	};

	encode.NAME = encode.CHARARRAY;
	sizeOf.NAME = sizeOf.CHARARRAY;

	encode.STRING = encode.CHARARRAY;
	sizeOf.STRING = sizeOf.CHARARRAY;

	/**
	 * @param {DataView} data
	 * @param {number} offset
	 * @param {number} numBytes
	 * @returns {string}
	 */
	decode.UTF8 = function(data, offset, numBytes) {
	    var codePoints = [];
	    var numChars = numBytes;
	    for (var j = 0; j < numChars; j++, offset += 1) {
	        codePoints[j] = data.getUint8(offset);
	    }

	    return String.fromCharCode.apply(null, codePoints);
	};

	/**
	 * @param {DataView} data
	 * @param {number} offset
	 * @param {number} numBytes
	 * @returns {string}
	 */
	decode.UTF16 = function(data, offset, numBytes) {
	    var codePoints = [];
	    var numChars = numBytes / 2;
	    for (var j = 0; j < numChars; j++, offset += 2) {
	        codePoints[j] = data.getUint16(offset);
	    }

	    return String.fromCharCode.apply(null, codePoints);
	};

	/**
	 * Convert a JavaScript string to UTF16-BE.
	 * @param {string}
	 * @returns {Array}
	 */
	encode.UTF16 = function(v) {
	    var b = [];
	    for (var i = 0; i < v.length; i += 1) {
	        var codepoint = v.charCodeAt(i);
	        b[b.length] = (codepoint >> 8) & 0xFF;
	        b[b.length] = codepoint & 0xFF;
	    }

	    return b;
	};

	/**
	 * @param {string}
	 * @returns {number}
	 */
	sizeOf.UTF16 = function(v) {
	    return v.length * 2;
	};

	// Data for converting old eight-bit Macintosh encodings to Unicode.
	// This representation is optimized for decoding; encoding is slower
	// and needs more memory. The assumption is that all opentype.js users
	// want to open fonts, but saving a font will be comparatively rare
	// so it can be more expensive. Keyed by IANA character set name.
	//
	// Python script for generating these strings:
	//
	//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
	//     print(s.encode('utf-8'))
	/**
	 * @private
	 */
	var eightBitMacEncodings = {
	    'x-mac-croatian':  // Python: 'mac_croatian'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +
	    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',
	    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
	    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +
	    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',
	    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +
	    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',
	    'x-mac-greek':  // Python: 'mac_greek'
	    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +
	    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\u00AD',
	    'x-mac-icelandic':  // Python: 'mac_iceland'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
	    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
	    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +
	    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',
	    'x-mac-ce':  // Python: 'mac_latin2'
	    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +
	    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',
	    macintosh:  // Python: 'mac_roman'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
	    'x-mac-romanian':  // Python: 'mac_romanian'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
	    'x-mac-turkish':  // Python: 'mac_turkish'
	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'
	};

	/**
	 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
	 * string, or 'undefined' if the encoding is unsupported. For example, we do
	 * not support Chinese, Japanese or Korean because these would need large
	 * mapping tables.
	 * @param {DataView} dataView
	 * @param {number} offset
	 * @param {number} dataLength
	 * @param {string} encoding
	 * @returns {string}
	 */
	decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
	    var table = eightBitMacEncodings[encoding];
	    if (table === undefined) {
	        return undefined;
	    }

	    var result = '';
	    for (var i = 0; i < dataLength; i++) {
	        var c = dataView.getUint8(offset + i);
	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
	        // mapped to U+0000..U+007F; we only need to look up the others.
	        if (c <= 0x7F) {
	            result += String.fromCharCode(c);
	        } else {
	            result += table[c & 0x7F];
	        }
	    }

	    return result;
	};

	// Helper function for encode.MACSTRING. Returns a dictionary for mapping
	// Unicode character codes to their 8-bit MacOS equivalent. This table
	// is not exactly a super cheap data structure, but we do not care because
	// encoding Macintosh strings is only rarely needed in typical applications.
	var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
	var macEncodingCacheKeys;
	var getMacEncodingTable = function (encoding) {
	    // Since we use encoding as a cache key for WeakMap, it has to be
	    // a String object and not a literal. And at least on NodeJS 2.10.1,
	    // WeakMap requires that the same String instance is passed for cache hits.
	    if (!macEncodingCacheKeys) {
	        macEncodingCacheKeys = {};
	        for (var e in eightBitMacEncodings) {
	            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
	            macEncodingCacheKeys[e] = new String(e);
	        }
	    }

	    var cacheKey = macEncodingCacheKeys[encoding];
	    if (cacheKey === undefined) {
	        return undefined;
	    }

	    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
	    // since garbage collection may run at any time, it could also kick in
	    // between the calls to cache.has() and cache.get(). In that case,
	    // we would return 'undefined' even though we do support the encoding.
	    if (macEncodingTableCache) {
	        var cachedTable = macEncodingTableCache.get(cacheKey);
	        if (cachedTable !== undefined) {
	            return cachedTable;
	        }
	    }

	    var decodingTable = eightBitMacEncodings[encoding];
	    if (decodingTable === undefined) {
	        return undefined;
	    }

	    var encodingTable = {};
	    for (var i = 0; i < decodingTable.length; i++) {
	        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
	    }

	    if (macEncodingTableCache) {
	        macEncodingTableCache.set(cacheKey, encodingTable);
	    }

	    return encodingTable;
	};

	/**
	 * Encodes an old-style Macintosh string. Returns a byte array upon success.
	 * If the requested encoding is unsupported, or if the input string contains
	 * a character that cannot be expressed in the encoding, the function returns
	 * 'undefined'.
	 * @param {string} str
	 * @param {string} encoding
	 * @returns {Array}
	 */
	encode.MACSTRING = function(str, encoding) {
	    var table = getMacEncodingTable(encoding);
	    if (table === undefined) {
	        return undefined;
	    }

	    var result = [];
	    for (var i = 0; i < str.length; i++) {
	        var c = str.charCodeAt(i);

	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
	        // mapped to U+0000..U+007F; we only need to look up the others.
	        if (c >= 0x80) {
	            c = table[c];
	            if (c === undefined) {
	                // str contains a Unicode character that cannot be encoded
	                // in the requested encoding.
	                return undefined;
	            }
	        }
	        result[i] = c;
	        // result.push(c);
	    }

	    return result;
	};

	/**
	 * @param {string} str
	 * @param {string} encoding
	 * @returns {number}
	 */
	sizeOf.MACSTRING = function(str, encoding) {
	    var b = encode.MACSTRING(str, encoding);
	    if (b !== undefined) {
	        return b.length;
	    } else {
	        return 0;
	    }
	};

	// Helper for encode.VARDELTAS
	function isByteEncodable(value) {
	    return value >= -128 && value <= 127;
	}

	// Helper for encode.VARDELTAS
	function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
	    var runLength = 0;
	    var numDeltas = deltas.length;
	    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
	        ++pos;
	        ++runLength;
	    }
	    result.push(0x80 | (runLength - 1));
	    return pos;
	}

	// Helper for encode.VARDELTAS
	function encodeVarDeltaRunAsBytes(deltas, offset, result) {
	    var runLength = 0;
	    var numDeltas = deltas.length;
	    var pos = offset;
	    while (pos < numDeltas && runLength < 64) {
	        var value = deltas[pos];
	        if (!isByteEncodable(value)) {
	            break;
	        }

	        // Within a byte-encoded run of deltas, a single zero is best
	        // stored literally as 0x00 value. However, if we have two or
	        // more zeroes in a sequence, it is better to start a new run.
	        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
	        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
	        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
	        // when starting a new run.
	        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
	            break;
	        }

	        ++pos;
	        ++runLength;
	    }
	    result.push(runLength - 1);
	    for (var i = offset; i < pos; ++i) {
	        result.push((deltas[i] + 256) & 0xff);
	    }
	    return pos;
	}

	// Helper for encode.VARDELTAS
	function encodeVarDeltaRunAsWords(deltas, offset, result) {
	    var runLength = 0;
	    var numDeltas = deltas.length;
	    var pos = offset;
	    while (pos < numDeltas && runLength < 64) {
	        var value = deltas[pos];

	        // Within a word-encoded run of deltas, it is easiest to start
	        // a new run (with a different encoding) whenever we encounter
	        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
	        // needs 7 bytes when storing the zero inside the current run
	        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
	        // new run (40 66 66 80 40 77 77).
	        if (value === 0) {
	            break;
	        }

	        // Within a word-encoded run of deltas, a single value in the
	        // range (-128..127) should be encoded within the current run
	        // because it is more compact. For example, the sequence
	        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
	        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
	        // a new run (40 66 66 00 02 40 77 77).
	        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
	            break;
	        }

	        ++pos;
	        ++runLength;
	    }
	    result.push(0x40 | (runLength - 1));
	    for (var i = offset; i < pos; ++i) {
	        var val = deltas[i];
	        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
	    }
	    return pos;
	}

	/**
	 * Encode a list of variation adjustment deltas.
	 *
	 * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.
	 * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted
	 * when generating instances of variation fonts.
	 *
	 * @see https://www.microsoft.com/typography/otspec/gvar.htm
	 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
	 * @param {Array}
	 * @return {Array}
	 */
	encode.VARDELTAS = function(deltas) {
	    var pos = 0;
	    var result = [];
	    while (pos < deltas.length) {
	        var value = deltas[pos];
	        if (value === 0) {
	            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
	        } else if (value >= -128 && value <= 127) {
	            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
	        } else {
	            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
	        }
	    }
	    return result;
	};

	// Convert a list of values to a CFF INDEX structure.
	// The values should be objects containing name / type / value.
	/**
	 * @param {Array} l
	 * @returns {Array}
	 */
	encode.INDEX = function(l) {
	    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
	    //    i, v;
	    // Because we have to know which data type to use to encode the offsets,
	    // we have to go through the values twice: once to encode the data and
	    // calculate the offsets, then again to encode the offsets using the fitting data type.
	    var offset = 1; // First offset is always 1.
	    var offsets = [offset];
	    var data = [];
	    for (var i = 0; i < l.length; i += 1) {
	        var v = encode.OBJECT(l[i]);
	        Array.prototype.push.apply(data, v);
	        offset += v.length;
	        offsets.push(offset);
	    }

	    if (data.length === 0) {
	        return [0, 0];
	    }

	    var encodedOffsets = [];
	    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
	    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
	    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
	        var encodedOffset = offsetEncoder(offsets[i$1]);
	        Array.prototype.push.apply(encodedOffsets, encodedOffset);
	    }

	    return Array.prototype.concat(encode.Card16(l.length),
	                           encode.OffSize(offSize),
	                           encodedOffsets,
	                           data);
	};

	/**
	 * @param {Array}
	 * @returns {number}
	 */
	sizeOf.INDEX = function(v) {
	    return encode.INDEX(v).length;
	};

	/**
	 * Convert an object to a CFF DICT structure.
	 * The keys should be numeric.
	 * The values should be objects containing name / type / value.
	 * @param {Object} m
	 * @returns {Array}
	 */
	encode.DICT = function(m) {
	    var d = [];
	    var keys = Object.keys(m);
	    var length = keys.length;

	    for (var i = 0; i < length; i += 1) {
	        // Object.keys() return string keys, but our keys are always numeric.
	        var k = parseInt(keys[i], 0);
	        var v = m[k];
	        // Value comes before the key.
	        d = d.concat(encode.OPERAND(v.value, v.type));
	        d = d.concat(encode.OPERATOR(k));
	    }

	    return d;
	};

	/**
	 * @param {Object}
	 * @returns {number}
	 */
	sizeOf.DICT = function(m) {
	    return encode.DICT(m).length;
	};

	/**
	 * @param {number}
	 * @returns {Array}
	 */
	encode.OPERATOR = function(v) {
	    if (v < 1200) {
	        return [v];
	    } else {
	        return [12, v - 1200];
	    }
	};

	/**
	 * @param {Array} v
	 * @param {string}
	 * @returns {Array}
	 */
	encode.OPERAND = function(v, type) {
	    var d = [];
	    if (Array.isArray(type)) {
	        for (var i = 0; i < type.length; i += 1) {
	            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
	            d = d.concat(encode.OPERAND(v[i], type[i]));
	        }
	    } else {
	        if (type === 'SID') {
	            d = d.concat(encode.NUMBER(v));
	        } else if (type === 'offset') {
	            // We make it easy for ourselves and always encode offsets as
	            // 4 bytes. This makes offset calculation for the top dict easier.
	            d = d.concat(encode.NUMBER32(v));
	        } else if (type === 'number') {
	            d = d.concat(encode.NUMBER(v));
	        } else if (type === 'real') {
	            d = d.concat(encode.REAL(v));
	        } else {
	            throw new Error('Unknown operand type ' + type);
	            // FIXME Add support for booleans
	        }
	    }

	    return d;
	};

	encode.OP = encode.BYTE;
	sizeOf.OP = sizeOf.BYTE;

	// memoize charstring encoding using WeakMap if available
	var wmm = typeof WeakMap === 'function' && new WeakMap();

	/**
	 * Convert a list of CharString operations to bytes.
	 * @param {Array}
	 * @returns {Array}
	 */
	encode.CHARSTRING = function(ops) {
	    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
	    if (wmm) {
	        var cachedValue = wmm.get(ops);
	        if (cachedValue !== undefined) {
	            return cachedValue;
	        }
	    }

	    var d = [];
	    var length = ops.length;

	    for (var i = 0; i < length; i += 1) {
	        var op = ops[i];
	        d = d.concat(encode[op.type](op.value));
	    }

	    if (wmm) {
	        wmm.set(ops, d);
	    }

	    return d;
	};

	/**
	 * @param {Array}
	 * @returns {number}
	 */
	sizeOf.CHARSTRING = function(ops) {
	    return encode.CHARSTRING(ops).length;
	};

	// Utility functions ////////////////////////////////////////////////////////

	/**
	 * Convert an object containing name / type / value to bytes.
	 * @param {Object}
	 * @returns {Array}
	 */
	encode.OBJECT = function(v) {
	    var encodingFunction = encode[v.type];
	    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
	    return encodingFunction(v.value);
	};

	/**
	 * @param {Object}
	 * @returns {number}
	 */
	sizeOf.OBJECT = function(v) {
	    var sizeOfFunction = sizeOf[v.type];
	    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
	    return sizeOfFunction(v.value);
	};

	/**
	 * Convert a table object to bytes.
	 * A table contains a list of fields containing the metadata (name, type and default value).
	 * The table itself has the field values set as attributes.
	 * @param {opentype.Table}
	 * @returns {Array}
	 */
	encode.TABLE = function(table) {
	    var d = [];
	    var length = table.fields.length;
	    var subtables = [];
	    var subtableOffsets = [];

	    for (var i = 0; i < length; i += 1) {
	        var field = table.fields[i];
	        var encodingFunction = encode[field.type];
	        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
	        var value = table[field.name];
	        if (value === undefined) {
	            value = field.value;
	        }

	        var bytes = encodingFunction(value);

	        if (field.type === 'TABLE') {
	            subtableOffsets.push(d.length);
	            d = d.concat([0, 0]);
	            subtables.push(bytes);
	        } else {
	            d = d.concat(bytes);
	        }
	    }

	    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
	        var o = subtableOffsets[i$1];
	        var offset = d.length;
	        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
	        d[o] = offset >> 8;
	        d[o + 1] = offset & 0xff;
	        d = d.concat(subtables[i$1]);
	    }

	    return d;
	};

	/**
	 * @param {opentype.Table}
	 * @returns {number}
	 */
	sizeOf.TABLE = function(table) {
	    var numBytes = 0;
	    var length = table.fields.length;

	    for (var i = 0; i < length; i += 1) {
	        var field = table.fields[i];
	        var sizeOfFunction = sizeOf[field.type];
	        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
	        var value = table[field.name];
	        if (value === undefined) {
	            value = field.value;
	        }

	        numBytes += sizeOfFunction(value);

	        // Subtables take 2 more bytes for offsets.
	        if (field.type === 'TABLE') {
	            numBytes += 2;
	        }
	    }

	    return numBytes;
	};

	encode.RECORD = encode.TABLE;
	sizeOf.RECORD = sizeOf.TABLE;

	// Merge in a list of bytes.
	encode.LITERAL = function(v) {
	    return v;
	};

	sizeOf.LITERAL = function(v) {
	    return v.length;
	};

	// Table metadata

	/**
	 * @exports opentype.Table
	 * @class
	 * @param {string} tableName
	 * @param {Array} fields
	 * @param {Object} options
	 * @constructor
	 */
	function Table(tableName, fields, options) {
	    var this$1 = this;

	    for (var i = 0; i < fields.length; i += 1) {
	        var field = fields[i];
	        this$1[field.name] = field.value;
	    }

	    this.tableName = tableName;
	    this.fields = fields;
	    if (options) {
	        var optionKeys = Object.keys(options);
	        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
	            var k = optionKeys[i$1];
	            var v = options[k];
	            if (this$1[k] !== undefined) {
	                this$1[k] = v;
	            }
	        }
	    }
	}

	/**
	 * Encodes the table and returns an array of bytes
	 * @return {Array}
	 */
	Table.prototype.encode = function() {
	    return encode.TABLE(this);
	};

	/**
	 * Get the size of the table.
	 * @return {number}
	 */
	Table.prototype.sizeOf = function() {
	    return sizeOf.TABLE(this);
	};

	/**
	 * @private
	 */
	function ushortList(itemName, list, count) {
	    if (count === undefined) {
	        count = list.length;
	    }
	    var fields = new Array(list.length + 1);
	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
	    for (var i = 0; i < list.length; i++) {
	        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
	    }
	    return fields;
	}

	/**
	 * @private
	 */
	function tableList(itemName, records, itemCallback) {
	    var count = records.length;
	    var fields = new Array(count + 1);
	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
	    for (var i = 0; i < count; i++) {
	        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
	    }
	    return fields;
	}

	/**
	 * @private
	 */
	function recordList(itemName, records, itemCallback) {
	    var count = records.length;
	    var fields = [];
	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
	    for (var i = 0; i < count; i++) {
	        fields = fields.concat(itemCallback(records[i], i));
	    }
	    return fields;
	}

	// Common Layout Tables

	/**
	 * @exports opentype.Coverage
	 * @class
	 * @param {opentype.Table}
	 * @constructor
	 * @extends opentype.Table
	 */
	function Coverage(coverageTable) {
	    if (coverageTable.format === 1) {
	        Table.call(this, 'coverageTable',
	            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
	            .concat(ushortList('glyph', coverageTable.glyphs))
	        );
	    } else {
	        check.assert(false, 'Can\'t create coverage table format 2 yet.');
	    }
	}
	Coverage.prototype = Object.create(Table.prototype);
	Coverage.prototype.constructor = Coverage;

	function ScriptList(scriptListTable) {
	    Table.call(this, 'scriptListTable',
	        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
	            var script = scriptRecord.script;
	            var defaultLangSys = script.defaultLangSys;
	            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
	            return [
	                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
	                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
	                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
	                        {name: 'lookupOrder', type: 'USHORT', value: 0},
	                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
	                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
	                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
	                        var langSys = langSysRecord.langSys;
	                        return [
	                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
	                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
	                                {name: 'lookupOrder', type: 'USHORT', value: 0},
	                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
	                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
	                        ];
	                    })))}
	            ];
	        })
	    );
	}
	ScriptList.prototype = Object.create(Table.prototype);
	ScriptList.prototype.constructor = ScriptList;

	/**
	 * @exports opentype.FeatureList
	 * @class
	 * @param {opentype.Table}
	 * @constructor
	 * @extends opentype.Table
	 */
	function FeatureList(featureListTable) {
	    Table.call(this, 'featureListTable',
	        recordList('featureRecord', featureListTable, function(featureRecord, i) {
	            var feature = featureRecord.feature;
	            return [
	                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
	                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
	                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
	            ];
	        })
	    );
	}
	FeatureList.prototype = Object.create(Table.prototype);
	FeatureList.prototype.constructor = FeatureList;

	/**
	 * @exports opentype.LookupList
	 * @class
	 * @param {opentype.Table}
	 * @param {Object}
	 * @constructor
	 * @extends opentype.Table
	 */
	function LookupList(lookupListTable, subtableMakers) {
	    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
	        var subtableCallback = subtableMakers[lookupTable.lookupType];
	        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
	        return new Table('lookupTable', [
	            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
	            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
	        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
	    }));
	}
	LookupList.prototype = Object.create(Table.prototype);
	LookupList.prototype.constructor = LookupList;

	// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
	// Don't use offsets inside Records (probable bug), only in Tables.
	var table = {
	    Table: Table,
	    Record: Table,
	    Coverage: Coverage,
	    ScriptList: ScriptList,
	    FeatureList: FeatureList,
	    LookupList: LookupList,
	    ushortList: ushortList,
	    tableList: tableList,
	    recordList: recordList,
	};

	// Parsing utility functions

	// Retrieve an unsigned byte from the DataView.
	function getByte(dataView, offset) {
	    return dataView.getUint8(offset);
	}

	// Retrieve an unsigned 16-bit short from the DataView.
	// The value is stored in big endian.
	function getUShort(dataView, offset) {
	    return dataView.getUint16(offset, false);
	}

	// Retrieve a signed 16-bit short from the DataView.
	// The value is stored in big endian.
	function getShort(dataView, offset) {
	    return dataView.getInt16(offset, false);
	}

	// Retrieve an unsigned 32-bit long from the DataView.
	// The value is stored in big endian.
	function getULong(dataView, offset) {
	    return dataView.getUint32(offset, false);
	}

	// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
	// The value is stored in big endian.
	function getFixed(dataView, offset) {
	    var decimal = dataView.getInt16(offset, false);
	    var fraction = dataView.getUint16(offset + 2, false);
	    return decimal + fraction / 65535;
	}

	// Retrieve a 4-character tag from the DataView.
	// Tags are used to identify tables.
	function getTag(dataView, offset) {
	    var tag = '';
	    for (var i = offset; i < offset + 4; i += 1) {
	        tag += String.fromCharCode(dataView.getInt8(i));
	    }

	    return tag;
	}

	// Retrieve an offset from the DataView.
	// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
	function getOffset(dataView, offset, offSize) {
	    var v = 0;
	    for (var i = 0; i < offSize; i += 1) {
	        v <<= 8;
	        v += dataView.getUint8(offset + i);
	    }

	    return v;
	}

	// Retrieve a number of bytes from start offset to the end offset from the DataView.
	function getBytes(dataView, startOffset, endOffset) {
	    var bytes = [];
	    for (var i = startOffset; i < endOffset; i += 1) {
	        bytes.push(dataView.getUint8(i));
	    }

	    return bytes;
	}

	// Convert the list of bytes to a string.
	function bytesToString(bytes) {
	    var s = '';
	    for (var i = 0; i < bytes.length; i += 1) {
	        s += String.fromCharCode(bytes[i]);
	    }

	    return s;
	}

	var typeOffsets = {
	    byte: 1,
	    uShort: 2,
	    short: 2,
	    uLong: 4,
	    fixed: 4,
	    longDateTime: 8,
	    tag: 4
	};

	// A stateful parser that changes the offset whenever a value is retrieved.
	// The data is a DataView.
	function Parser(data, offset) {
	    this.data = data;
	    this.offset = offset;
	    this.relativeOffset = 0;
	}

	Parser.prototype.parseByte = function() {
	    var v = this.data.getUint8(this.offset + this.relativeOffset);
	    this.relativeOffset += 1;
	    return v;
	};

	Parser.prototype.parseChar = function() {
	    var v = this.data.getInt8(this.offset + this.relativeOffset);
	    this.relativeOffset += 1;
	    return v;
	};

	Parser.prototype.parseCard8 = Parser.prototype.parseByte;

	Parser.prototype.parseUShort = function() {
	    var v = this.data.getUint16(this.offset + this.relativeOffset);
	    this.relativeOffset += 2;
	    return v;
	};

	Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
	Parser.prototype.parseSID = Parser.prototype.parseUShort;
	Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

	Parser.prototype.parseShort = function() {
	    var v = this.data.getInt16(this.offset + this.relativeOffset);
	    this.relativeOffset += 2;
	    return v;
	};

	Parser.prototype.parseF2Dot14 = function() {
	    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
	    this.relativeOffset += 2;
	    return v;
	};

	Parser.prototype.parseULong = function() {
	    var v = getULong(this.data, this.offset + this.relativeOffset);
	    this.relativeOffset += 4;
	    return v;
	};

	Parser.prototype.parseOffset32 = Parser.prototype.parseULong;

	Parser.prototype.parseFixed = function() {
	    var v = getFixed(this.data, this.offset + this.relativeOffset);
	    this.relativeOffset += 4;
	    return v;
	};

	Parser.prototype.parseString = function(length) {
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    var string = '';
	    this.relativeOffset += length;
	    for (var i = 0; i < length; i++) {
	        string += String.fromCharCode(dataView.getUint8(offset + i));
	    }

	    return string;
	};

	Parser.prototype.parseTag = function() {
	    return this.parseString(4);
	};

	// LONGDATETIME is a 64-bit integer.
	// JavaScript and unix timestamps traditionally use 32 bits, so we
	// only take the last 32 bits.
	// + Since until 2038 those bits will be filled by zeros we can ignore them.
	Parser.prototype.parseLongDateTime = function() {
	    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
	    // Subtract seconds between 01/01/1904 and 01/01/1970
	    // to convert Apple Mac timestamp to Standard Unix timestamp
	    v -= 2082844800;
	    this.relativeOffset += 8;
	    return v;
	};

	Parser.prototype.parseVersion = function(minorBase) {
	    var major = getUShort(this.data, this.offset + this.relativeOffset);

	    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
	    // Default returns the correct number if minor = 0xN000 where N is 0-9
	    // Set minorBase to 1 for tables that use minor = N where N is 0-9
	    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
	    this.relativeOffset += 4;
	    if (minorBase === undefined) { minorBase = 0x1000; }
	    return major + minor / minorBase / 10;
	};

	Parser.prototype.skip = function(type, amount) {
	    if (amount === undefined) {
	        amount = 1;
	    }

	    this.relativeOffset += typeOffsets[type] * amount;
	};

	///// Parsing lists and records ///////////////////////////////

	// Parse a list of 32 bit unsigned integers.
	Parser.prototype.parseULongList = function(count) {
	    if (count === undefined) { count = this.parseULong(); }
	    var offsets = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        offsets[i] = dataView.getUint32(offset);
	        offset += 4;
	    }

	    this.relativeOffset += count * 4;
	    return offsets;
	};

	// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
	// or provided as an argument.
	Parser.prototype.parseOffset16List =
	Parser.prototype.parseUShortList = function(count) {
	    if (count === undefined) { count = this.parseUShort(); }
	    var offsets = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        offsets[i] = dataView.getUint16(offset);
	        offset += 2;
	    }

	    this.relativeOffset += count * 2;
	    return offsets;
	};

	// Parses a list of 16 bit signed integers.
	Parser.prototype.parseShortList = function(count) {
	    var list = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        list[i] = dataView.getInt16(offset);
	        offset += 2;
	    }

	    this.relativeOffset += count * 2;
	    return list;
	};

	// Parses a list of bytes.
	Parser.prototype.parseByteList = function(count) {
	    var list = new Array(count);
	    var dataView = this.data;
	    var offset = this.offset + this.relativeOffset;
	    for (var i = 0; i < count; i++) {
	        list[i] = dataView.getUint8(offset++);
	    }

	    this.relativeOffset += count;
	    return list;
	};

	/**
	 * Parse a list of items.
	 * Record count is optional, if omitted it is read from the stream.
	 * itemCallback is one of the Parser methods.
	 */
	Parser.prototype.parseList = function(count, itemCallback) {
	    var this$1 = this;

	    if (!itemCallback) {
	        itemCallback = count;
	        count = this.parseUShort();
	    }
	    var list = new Array(count);
	    for (var i = 0; i < count; i++) {
	        list[i] = itemCallback.call(this$1);
	    }
	    return list;
	};

	Parser.prototype.parseList32 = function(count, itemCallback) {
	    var this$1 = this;

	    if (!itemCallback) {
	        itemCallback = count;
	        count = this.parseULong();
	    }
	    var list = new Array(count);
	    for (var i = 0; i < count; i++) {
	        list[i] = itemCallback.call(this$1);
	    }
	    return list;
	};

	/**
	 * Parse a list of records.
	 * Record count is optional, if omitted it is read from the stream.
	 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
	 */
	Parser.prototype.parseRecordList = function(count, recordDescription) {
	    var this$1 = this;

	    // If the count argument is absent, read it in the stream.
	    if (!recordDescription) {
	        recordDescription = count;
	        count = this.parseUShort();
	    }
	    var records = new Array(count);
	    var fields = Object.keys(recordDescription);
	    for (var i = 0; i < count; i++) {
	        var rec = {};
	        for (var j = 0; j < fields.length; j++) {
	            var fieldName = fields[j];
	            var fieldType = recordDescription[fieldName];
	            rec[fieldName] = fieldType.call(this$1);
	        }
	        records[i] = rec;
	    }
	    return records;
	};

	Parser.prototype.parseRecordList32 = function(count, recordDescription) {
	    var this$1 = this;

	    // If the count argument is absent, read it in the stream.
	    if (!recordDescription) {
	        recordDescription = count;
	        count = this.parseULong();
	    }
	    var records = new Array(count);
	    var fields = Object.keys(recordDescription);
	    for (var i = 0; i < count; i++) {
	        var rec = {};
	        for (var j = 0; j < fields.length; j++) {
	            var fieldName = fields[j];
	            var fieldType = recordDescription[fieldName];
	            rec[fieldName] = fieldType.call(this$1);
	        }
	        records[i] = rec;
	    }
	    return records;
	};

	// Parse a data structure into an object
	// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
	Parser.prototype.parseStruct = function(description) {
	    var this$1 = this;

	    if (typeof description === 'function') {
	        return description.call(this);
	    } else {
	        var fields = Object.keys(description);
	        var struct = {};
	        for (var j = 0; j < fields.length; j++) {
	            var fieldName = fields[j];
	            var fieldType = description[fieldName];
	            struct[fieldName] = fieldType.call(this$1);
	        }
	        return struct;
	    }
	};

	/**
	 * Parse a GPOS valueRecord
	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
	 * valueFormat is optional, if omitted it is read from the stream.
	 */
	Parser.prototype.parseValueRecord = function(valueFormat) {
	    if (valueFormat === undefined) {
	        valueFormat = this.parseUShort();
	    }
	    if (valueFormat === 0) {
	        // valueFormat2 in kerning pairs is most often 0
	        // in this case return undefined instead of an empty object, to save space
	        return;
	    }
	    var valueRecord = {};

	    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
	    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
	    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
	    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }

	    // Device table (non-variable font) / VariationIndex table (variable font) not supported
	    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
	    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
	    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
	    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
	    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }

	    return valueRecord;
	};

	/**
	 * Parse a list of GPOS valueRecords
	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
	 * valueFormat and valueCount are read from the stream.
	 */
	Parser.prototype.parseValueRecordList = function() {
	    var this$1 = this;

	    var valueFormat = this.parseUShort();
	    var valueCount = this.parseUShort();
	    var values = new Array(valueCount);
	    for (var i = 0; i < valueCount; i++) {
	        values[i] = this$1.parseValueRecord(valueFormat);
	    }
	    return values;
	};

	Parser.prototype.parsePointer = function(description) {
	    var structOffset = this.parseOffset16();
	    if (structOffset > 0) {
	        // NULL offset => return undefined
	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
	    }
	    return undefined;
	};

	Parser.prototype.parsePointer32 = function(description) {
	    var structOffset = this.parseOffset32();
	    if (structOffset > 0) {
	        // NULL offset => return undefined
	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
	    }
	    return undefined;
	};

	/**
	 * Parse a list of offsets to lists of 16-bit integers,
	 * or a list of offsets to lists of offsets to any kind of items.
	 * If itemCallback is not provided, a list of list of UShort is assumed.
	 * If provided, itemCallback is called on each item and must parse the item.
	 * See examples in tables/gsub.js
	 */
	Parser.prototype.parseListOfLists = function(itemCallback) {
	    var this$1 = this;

	    var offsets = this.parseOffset16List();
	    var count = offsets.length;
	    var relativeOffset = this.relativeOffset;
	    var list = new Array(count);
	    for (var i = 0; i < count; i++) {
	        var start = offsets[i];
	        if (start === 0) {
	            // NULL offset
	            // Add i as owned property to list. Convenient with assert.
	            list[i] = undefined;
	            continue;
	        }
	        this$1.relativeOffset = start;
	        if (itemCallback) {
	            var subOffsets = this$1.parseOffset16List();
	            var subList = new Array(subOffsets.length);
	            for (var j = 0; j < subOffsets.length; j++) {
	                this$1.relativeOffset = start + subOffsets[j];
	                subList[j] = itemCallback.call(this$1);
	            }
	            list[i] = subList;
	        } else {
	            list[i] = this$1.parseUShortList();
	        }
	    }
	    this.relativeOffset = relativeOffset;
	    return list;
	};

	///// Complex tables parsing //////////////////////////////////

	// Parse a coverage table in a GSUB, GPOS or GDEF table.
	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
	// parser.offset must point to the start of the table containing the coverage.
	Parser.prototype.parseCoverage = function() {
	    var this$1 = this;

	    var startOffset = this.offset + this.relativeOffset;
	    var format = this.parseUShort();
	    var count = this.parseUShort();
	    if (format === 1) {
	        return {
	            format: 1,
	            glyphs: this.parseUShortList(count)
	        };
	    } else if (format === 2) {
	        var ranges = new Array(count);
	        for (var i = 0; i < count; i++) {
	            ranges[i] = {
	                start: this$1.parseUShort(),
	                end: this$1.parseUShort(),
	                index: this$1.parseUShort()
	            };
	        }
	        return {
	            format: 2,
	            ranges: ranges
	        };
	    }
	    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
	};

	// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
	Parser.prototype.parseClassDef = function() {
	    var startOffset = this.offset + this.relativeOffset;
	    var format = this.parseUShort();
	    if (format === 1) {
	        return {
	            format: 1,
	            startGlyph: this.parseUShort(),
	            classes: this.parseUShortList()
	        };
	    } else if (format === 2) {
	        return {
	            format: 2,
	            ranges: this.parseRecordList({
	                start: Parser.uShort,
	                end: Parser.uShort,
	                classId: Parser.uShort
	            })
	        };
	    }
	    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
	};

	///// Static methods ///////////////////////////////////
	// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

	Parser.list = function(count, itemCallback) {
	    return function() {
	        return this.parseList(count, itemCallback);
	    };
	};

	Parser.list32 = function(count, itemCallback) {
	    return function() {
	        return this.parseList32(count, itemCallback);
	    };
	};

	Parser.recordList = function(count, recordDescription) {
	    return function() {
	        return this.parseRecordList(count, recordDescription);
	    };
	};

	Parser.recordList32 = function(count, recordDescription) {
	    return function() {
	        return this.parseRecordList32(count, recordDescription);
	    };
	};

	Parser.pointer = function(description) {
	    return function() {
	        return this.parsePointer(description);
	    };
	};

	Parser.pointer32 = function(description) {
	    return function() {
	        return this.parsePointer32(description);
	    };
	};

	Parser.tag = Parser.prototype.parseTag;
	Parser.byte = Parser.prototype.parseByte;
	Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
	Parser.uShortList = Parser.prototype.parseUShortList;
	Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
	Parser.uLongList = Parser.prototype.parseULongList;
	Parser.struct = Parser.prototype.parseStruct;
	Parser.coverage = Parser.prototype.parseCoverage;
	Parser.classDef = Parser.prototype.parseClassDef;

	///// Script, Feature, Lookup lists ///////////////////////////////////////////////
	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

	var langSysTable = {
	    reserved: Parser.uShort,
	    reqFeatureIndex: Parser.uShort,
	    featureIndexes: Parser.uShortList
	};

	Parser.prototype.parseScriptList = function() {
	    return this.parsePointer(Parser.recordList({
	        tag: Parser.tag,
	        script: Parser.pointer({
	            defaultLangSys: Parser.pointer(langSysTable),
	            langSysRecords: Parser.recordList({
	                tag: Parser.tag,
	                langSys: Parser.pointer(langSysTable)
	            })
	        })
	    })) || [];
	};

	Parser.prototype.parseFeatureList = function() {
	    return this.parsePointer(Parser.recordList({
	        tag: Parser.tag,
	        feature: Parser.pointer({
	            featureParams: Parser.offset16,
	            lookupListIndexes: Parser.uShortList
	        })
	    })) || [];
	};

	Parser.prototype.parseLookupList = function(lookupTableParsers) {
	    return this.parsePointer(Parser.list(Parser.pointer(function() {
	        var lookupType = this.parseUShort();
	        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
	        var lookupFlag = this.parseUShort();
	        var useMarkFilteringSet = lookupFlag & 0x10;
	        return {
	            lookupType: lookupType,
	            lookupFlag: lookupFlag,
	            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
	            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
	        };
	    }))) || [];
	};

	Parser.prototype.parseFeatureVariationsList = function() {
	    return this.parsePointer32(function() {
	        var majorVersion = this.parseUShort();
	        var minorVersion = this.parseUShort();
	        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
	        var featureVariations = this.parseRecordList32({
	            conditionSetOffset: Parser.offset32,
	            featureTableSubstitutionOffset: Parser.offset32
	        });
	        return featureVariations;
	    }) || [];
	};

	var parse = {
	    getByte: getByte,
	    getCard8: getByte,
	    getUShort: getUShort,
	    getCard16: getUShort,
	    getShort: getShort,
	    getULong: getULong,
	    getFixed: getFixed,
	    getTag: getTag,
	    getOffset: getOffset,
	    getBytes: getBytes,
	    bytesToString: bytesToString,
	    Parser: Parser,
	};

	// The `cmap` table stores the mappings from characters to glyphs.

	function parseCmapTableFormat12(cmap, p) {
	    //Skip reserved.
	    p.parseUShort();

	    // Length in bytes of the sub-tables.
	    cmap.length = p.parseULong();
	    cmap.language = p.parseULong();

	    var groupCount;
	    cmap.groupCount = groupCount = p.parseULong();
	    cmap.glyphIndexMap = {};

	    for (var i = 0; i < groupCount; i += 1) {
	        var startCharCode = p.parseULong();
	        var endCharCode = p.parseULong();
	        var startGlyphId = p.parseULong();

	        for (var c = startCharCode; c <= endCharCode; c += 1) {
	            cmap.glyphIndexMap[c] = startGlyphId;
	            startGlyphId++;
	        }
	    }
	}

	function parseCmapTableFormat4(cmap, p, data, start, offset) {
	    // Length in bytes of the sub-tables.
	    cmap.length = p.parseUShort();
	    cmap.language = p.parseUShort();

	    // segCount is stored x 2.
	    var segCount;
	    cmap.segCount = segCount = p.parseUShort() >> 1;

	    // Skip searchRange, entrySelector, rangeShift.
	    p.skip('uShort', 3);

	    // The "unrolled" mapping from character codes to glyph indices.
	    cmap.glyphIndexMap = {};
	    var endCountParser = new parse.Parser(data, start + offset + 14);
	    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
	    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
	    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
	    var glyphIndexOffset = start + offset + 16 + segCount * 8;
	    for (var i = 0; i < segCount - 1; i += 1) {
	        var glyphIndex = (void 0);
	        var endCount = endCountParser.parseUShort();
	        var startCount = startCountParser.parseUShort();
	        var idDelta = idDeltaParser.parseShort();
	        var idRangeOffset = idRangeOffsetParser.parseUShort();
	        for (var c = startCount; c <= endCount; c += 1) {
	            if (idRangeOffset !== 0) {
	                // The idRangeOffset is relative to the current position in the idRangeOffset array.
	                // Take the current offset in the idRangeOffset array.
	                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

	                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
	                glyphIndexOffset += idRangeOffset;

	                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
	                glyphIndexOffset += (c - startCount) * 2;
	                glyphIndex = parse.getUShort(data, glyphIndexOffset);
	                if (glyphIndex !== 0) {
	                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
	                }
	            } else {
	                glyphIndex = (c + idDelta) & 0xFFFF;
	            }

	            cmap.glyphIndexMap[c] = glyphIndex;
	        }
	    }
	}

	// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
	// There are many available formats, but we only support the Windows format 4 and 12.
	// This function returns a `CmapEncoding` object or null if no supported format could be found.
	function parseCmapTable(data, start) {
	    var cmap = {};
	    cmap.version = parse.getUShort(data, start);
	    check.argument(cmap.version === 0, 'cmap table version should be 0.');

	    // The cmap table can contain many sub-tables, each with their own format.
	    // We're only interested in a "platform 0" (Unicode format) and "platform 3" (Windows format) table.
	    cmap.numTables = parse.getUShort(data, start + 2);
	    var offset = -1;
	    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
	        var platformId = parse.getUShort(data, start + 4 + (i * 8));
	        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
	        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||
	            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {
	            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
	            break;
	        }
	    }

	    if (offset === -1) {
	        // There is no cmap table in the font that we support.
	        throw new Error('No valid cmap sub-tables found.');
	    }

	    var p = new parse.Parser(data, start + offset);
	    cmap.format = p.parseUShort();

	    if (cmap.format === 12) {
	        parseCmapTableFormat12(cmap, p);
	    } else if (cmap.format === 4) {
	        parseCmapTableFormat4(cmap, p, data, start, offset);
	    } else {
	        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
	    }

	    return cmap;
	}

	function addSegment(t, code, glyphIndex) {
	    t.segments.push({
	        end: code,
	        start: code,
	        delta: -(code - glyphIndex),
	        offset: 0,
	        glyphIndex: glyphIndex
	    });
	}

	function addTerminatorSegment(t) {
	    t.segments.push({
	        end: 0xFFFF,
	        start: 0xFFFF,
	        delta: 1,
	        offset: 0
	    });
	}

	// Make cmap table, format 4 by default, 12 if needed only
	function makeCmapTable(glyphs) {
	    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
	    var isPlan0Only = true;
	    var i;

	    // Check if we need to add cmap format 12 or if format 4 only is fine
	    for (i = glyphs.length - 1; i > 0; i -= 1) {
	        var g = glyphs.get(i);
	        if (g.unicode > 65535) {
	            console.log('Adding CMAP format 12 (needed!)');
	            isPlan0Only = false;
	            break;
	        }
	    }

	    var cmapTable = [
	        {name: 'version', type: 'USHORT', value: 0},
	        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},

	        // CMAP 4 header
	        {name: 'platformID', type: 'USHORT', value: 3},
	        {name: 'encodingID', type: 'USHORT', value: 1},
	        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
	    ];

	    if (!isPlan0Only)
	        { cmapTable = cmapTable.concat([
	            // CMAP 12 header
	            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
	            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
	            {name: 'cmap12Offset', type: 'ULONG', value: 0}
	        ]); }

	    cmapTable = cmapTable.concat([
	        // CMAP 4 Subtable
	        {name: 'format', type: 'USHORT', value: 4},
	        {name: 'cmap4Length', type: 'USHORT', value: 0},
	        {name: 'language', type: 'USHORT', value: 0},
	        {name: 'segCountX2', type: 'USHORT', value: 0},
	        {name: 'searchRange', type: 'USHORT', value: 0},
	        {name: 'entrySelector', type: 'USHORT', value: 0},
	        {name: 'rangeShift', type: 'USHORT', value: 0}
	    ]);

	    var t = new table.Table('cmap', cmapTable);

	    t.segments = [];
	    for (i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs.get(i);
	        for (var j = 0; j < glyph.unicodes.length; j += 1) {
	            addSegment(t, glyph.unicodes[j], i);
	        }

	        t.segments = t.segments.sort(function (a, b) {
	            return a.start - b.start;
	        });
	    }

	    addTerminatorSegment(t);

	    var segCount = t.segments.length;
	    var segCountToRemove = 0;

	    // CMAP 4
	    // Set up parallel segment arrays.
	    var endCounts = [];
	    var startCounts = [];
	    var idDeltas = [];
	    var idRangeOffsets = [];
	    var glyphIds = [];

	    // CMAP 12
	    var cmap12Groups = [];

	    // Reminder this loop is not following the specification at 100%
	    // The specification -> find suites of characters and make a group
	    // Here we're doing one group for each letter
	    // Doing as the spec can save 8 times (or more) space
	    for (i = 0; i < segCount; i += 1) {
	        var segment = t.segments[i];

	        // CMAP 4
	        if (segment.end <= 65535 && segment.start <= 65535) {
	            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
	            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
	            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
	            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
	            if (segment.glyphId !== undefined) {
	                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
	            }
	        } else {
	            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
	            segCountToRemove += 1;
	        }

	        // CMAP 12
	        // Skip Terminator Segment
	        if (!isPlan0Only && segment.glyphIndex !== undefined) {
	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
	            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
	        }
	    }

	    // CMAP 4 Subtable
	    t.segCountX2 = (segCount - segCountToRemove) * 2;
	    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
	    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
	    t.rangeShift = t.segCountX2 - t.searchRange;

	    t.fields = t.fields.concat(endCounts);
	    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
	    t.fields = t.fields.concat(startCounts);
	    t.fields = t.fields.concat(idDeltas);
	    t.fields = t.fields.concat(idRangeOffsets);
	    t.fields = t.fields.concat(glyphIds);

	    t.cmap4Length = 14 + // Subtable header
	        endCounts.length * 2 +
	        2 + // reservedPad
	        startCounts.length * 2 +
	        idDeltas.length * 2 +
	        idRangeOffsets.length * 2 +
	        glyphIds.length * 2;

	    if (!isPlan0Only) {
	        // CMAP 12 Subtable
	        var cmap12Length = 16 + // Subtable header
	            cmap12Groups.length * 4;

	        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
	        t.fields = t.fields.concat([
	            {name: 'cmap12Format', type: 'USHORT', value: 12},
	            {name: 'cmap12Reserved', type: 'USHORT', value: 0},
	            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
	            {name: 'cmap12Language', type: 'ULONG', value: 0},
	            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
	        ]);

	        t.fields = t.fields.concat(cmap12Groups);
	    }

	    return t;
	}

	var cmap = { parse: parseCmapTable, make: makeCmapTable };

	// Glyph encoding

	var cffStandardStrings = [
	    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
	    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
	    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
	    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
	    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
	    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
	    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
	    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
	    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
	    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
	    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
	    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
	    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
	    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
	    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
	    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
	    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
	    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
	    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
	    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
	    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
	    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
	    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
	    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
	    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
	    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
	    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
	    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
	    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
	    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
	    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
	    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

	var cffStandardEncoding = [
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
	    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
	    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
	    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
	    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
	    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
	    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
	    'lslash', 'oslash', 'oe', 'germandbls'];

	var cffExpertEncoding = [
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
	    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
	    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
	    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
	    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
	    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
	    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
	    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
	    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
	    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
	    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
	    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
	    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
	    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
	    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
	    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
	    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
	    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
	    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

	var standardNames = [
	    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
	    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
	    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
	    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
	    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
	    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
	    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
	    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
	    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
	    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
	    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
	    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
	    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
	    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
	    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
	    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
	    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
	    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
	    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
	    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
	    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
	    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
	    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
	    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
	    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

	/**
	 * This is the encoding used for fonts created from scratch.
	 * It loops through all glyphs and finds the appropriate unicode value.
	 * Since it's linear time, other encodings will be faster.
	 * @exports opentype.DefaultEncoding
	 * @class
	 * @constructor
	 * @param {opentype.Font}
	 */
	function DefaultEncoding(font) {
	    this.font = font;
	}

	DefaultEncoding.prototype.charToGlyphIndex = function(c) {
	    var code = c.codePointAt(0);
	    var glyphs = this.font.glyphs;
	    if (glyphs) {
	        for (var i = 0; i < glyphs.length; i += 1) {
	            var glyph = glyphs.get(i);
	            for (var j = 0; j < glyph.unicodes.length; j += 1) {
	                if (glyph.unicodes[j] === code) {
	                    return i;
	                }
	            }
	        }
	    }
	    return null;
	};

	/**
	 * @exports opentype.CmapEncoding
	 * @class
	 * @constructor
	 * @param {Object} cmap - a object with the cmap encoded data
	 */
	function CmapEncoding(cmap) {
	    this.cmap = cmap;
	}

	/**
	 * @param  {string} c - the character
	 * @return {number} The glyph index.
	 */
	CmapEncoding.prototype.charToGlyphIndex = function(c) {
	    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
	};

	/**
	 * @exports opentype.CffEncoding
	 * @class
	 * @constructor
	 * @param {string} encoding - The encoding
	 * @param {Array} charset - The character set.
	 */
	function CffEncoding(encoding, charset) {
	    this.encoding = encoding;
	    this.charset = charset;
	}

	/**
	 * @param  {string} s - The character
	 * @return {number} The index.
	 */
	CffEncoding.prototype.charToGlyphIndex = function(s) {
	    var code = s.codePointAt(0);
	    var charName = this.encoding[code];
	    return this.charset.indexOf(charName);
	};

	/**
	 * @exports opentype.GlyphNames
	 * @class
	 * @constructor
	 * @param {Object} post
	 */
	function GlyphNames(post) {
	    var this$1 = this;

	    switch (post.version) {
	        case 1:
	            this.names = standardNames.slice();
	            break;
	        case 2:
	            this.names = new Array(post.numberOfGlyphs);
	            for (var i = 0; i < post.numberOfGlyphs; i++) {
	                if (post.glyphNameIndex[i] < standardNames.length) {
	                    this$1.names[i] = standardNames[post.glyphNameIndex[i]];
	                } else {
	                    this$1.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
	                }
	            }

	            break;
	        case 2.5:
	            this.names = new Array(post.numberOfGlyphs);
	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
	                this$1.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
	            }

	            break;
	        case 3:
	            this.names = [];
	            break;
	        default:
	            this.names = [];
	            break;
	    }
	}

	/**
	 * Gets the index of a glyph by name.
	 * @param  {string} name - The glyph name
	 * @return {number} The index
	 */
	GlyphNames.prototype.nameToGlyphIndex = function(name) {
	    return this.names.indexOf(name);
	};

	/**
	 * @param  {number} gid
	 * @return {string}
	 */
	GlyphNames.prototype.glyphIndexToName = function(gid) {
	    return this.names[gid];
	};

	/**
	 * @alias opentype.addGlyphNames
	 * @param {opentype.Font}
	 */
	function addGlyphNames(font) {
	    var glyph;
	    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
	    var charCodes = Object.keys(glyphIndexMap);

	    for (var i = 0; i < charCodes.length; i += 1) {
	        var c = charCodes[i];
	        var glyphIndex = glyphIndexMap[c];
	        glyph = font.glyphs.get(glyphIndex);
	        glyph.addUnicode(parseInt(c));
	    }

	    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
	        glyph = font.glyphs.get(i$1);
	        if (font.cffEncoding) {
	            if (font.isCIDFont) {
	                glyph.name = 'gid' + i$1;
	            } else {
	                glyph.name = font.cffEncoding.charset[i$1];
	            }
	        } else if (font.glyphNames.names) {
	            glyph.name = font.glyphNames.glyphIndexToName(i$1);
	        }
	    }
	}

	// Drawing utility functions.

	// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
	function line(ctx, x1, y1, x2, y2) {
	    ctx.beginPath();
	    ctx.moveTo(x1, y1);
	    ctx.lineTo(x2, y2);
	    ctx.stroke();
	}

	var draw = { line: line };

	// The Glyph object
	// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency

	function getPathDefinition(glyph, path) {
	    var _path = path || new Path();
	    return {
	        configurable: true,

	        get: function() {
	            if (typeof _path === 'function') {
	                _path = _path();
	            }

	            return _path;
	        },

	        set: function(p) {
	            _path = p;
	        }
	    };
	}
	/**
	 * @typedef GlyphOptions
	 * @type Object
	 * @property {string} [name] - The glyph name
	 * @property {number} [unicode]
	 * @property {Array} [unicodes]
	 * @property {number} [xMin]
	 * @property {number} [yMin]
	 * @property {number} [xMax]
	 * @property {number} [yMax]
	 * @property {number} [advanceWidth]
	 */

	// A Glyph is an individual mark that often corresponds to a character.
	// Some glyphs, such as ligatures, are a combination of many characters.
	// Glyphs are the basic building blocks of a font.
	//
	// The `Glyph` class contains utility methods for drawing the path and its points.
	/**
	 * @exports opentype.Glyph
	 * @class
	 * @param {GlyphOptions}
	 * @constructor
	 */
	function Glyph(options) {
	    // By putting all the code on a prototype function (which is only declared once)
	    // we reduce the memory requirements for larger fonts by some 2%
	    this.bindConstructorValues(options);
	}

	/**
	 * @param  {GlyphOptions}
	 */
	Glyph.prototype.bindConstructorValues = function(options) {
	    this.index = options.index || 0;

	    // These three values cannot be deferred for memory optimization:
	    this.name = options.name || null;
	    this.unicode = options.unicode || undefined;
	    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

	    // But by binding these values only when necessary, we reduce can
	    // the memory requirements by almost 3% for larger fonts.
	    if (options.xMin) {
	        this.xMin = options.xMin;
	    }

	    if (options.yMin) {
	        this.yMin = options.yMin;
	    }

	    if (options.xMax) {
	        this.xMax = options.xMax;
	    }

	    if (options.yMax) {
	        this.yMax = options.yMax;
	    }

	    if (options.advanceWidth) {
	        this.advanceWidth = options.advanceWidth;
	    }

	    // The path for a glyph is the most memory intensive, and is bound as a value
	    // with a getter/setter to ensure we actually do path parsing only once the
	    // path is actually needed by anything.
	    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
	};

	/**
	 * @param {number}
	 */
	Glyph.prototype.addUnicode = function(unicode) {
	    if (this.unicodes.length === 0) {
	        this.unicode = unicode;
	    }

	    this.unicodes.push(unicode);
	};

	/**
	 * Calculate the minimum bounding box for this glyph.
	 * @return {opentype.BoundingBox}
	 */
	Glyph.prototype.getBoundingBox = function() {
	    return this.path.getBoundingBox();
	};

	/**
	 * Convert the glyph to a Path we can draw on a drawing context.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
	 * @param  {opentype.Font} if hinting is to be used, the font
	 * @return {opentype.Path}
	 */
	Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 72;
	    var commands;
	    var hPoints;
	    if (!options) { options = { }; }
	    var xScale = options.xScale;
	    var yScale = options.yScale;

	    if (options.hinting && font && font.hinting) {
	        // in case of hinting, the hinting engine takes care
	        // of scaling the points (not the path) before hinting.
	        hPoints = this.path && font.hinting.exec(this, fontSize);
	        // in case the hinting engine failed hPoints is undefined
	        // and thus reverts to plain rending
	    }

	    if (hPoints) {
	        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency
	        commands = font.hinting.getCommands(hPoints);
	        x = Math.round(x);
	        y = Math.round(y);
	        // TODO in case of hinting xyScaling is not yet supported
	        xScale = yScale = 1;
	    } else {
	        commands = this.path.commands;
	        var scale = 1 / this.path.unitsPerEm * fontSize;
	        if (xScale === undefined) { xScale = scale; }
	        if (yScale === undefined) { yScale = scale; }
	    }

	    var p = new Path();
	    for (var i = 0; i < commands.length; i += 1) {
	        var cmd = commands[i];
	        if (cmd.type === 'M') {
	            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'L') {
	            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'Q') {
	            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
	                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'C') {
	            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
	                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
	                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
	        } else if (cmd.type === 'Z') {
	            p.closePath();
	        }
	    }

	    return p;
	};

	/**
	 * Split the glyph into contours.
	 * This function is here for backwards compatibility, and to
	 * provide raw access to the TrueType glyph outlines.
	 * @return {Array}
	 */
	Glyph.prototype.getContours = function() {
	    var this$1 = this;

	    if (this.points === undefined) {
	        return [];
	    }

	    var contours = [];
	    var currentContour = [];
	    for (var i = 0; i < this.points.length; i += 1) {
	        var pt = this$1.points[i];
	        currentContour.push(pt);
	        if (pt.lastPointOfContour) {
	            contours.push(currentContour);
	            currentContour = [];
	        }
	    }

	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
	    return contours;
	};

	/**
	 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
	 * @return {Object}
	 */
	Glyph.prototype.getMetrics = function() {
	    var commands = this.path.commands;
	    var xCoords = [];
	    var yCoords = [];
	    for (var i = 0; i < commands.length; i += 1) {
	        var cmd = commands[i];
	        if (cmd.type !== 'Z') {
	            xCoords.push(cmd.x);
	            yCoords.push(cmd.y);
	        }

	        if (cmd.type === 'Q' || cmd.type === 'C') {
	            xCoords.push(cmd.x1);
	            yCoords.push(cmd.y1);
	        }

	        if (cmd.type === 'C') {
	            xCoords.push(cmd.x2);
	            yCoords.push(cmd.y2);
	        }
	    }

	    var metrics = {
	        xMin: Math.min.apply(null, xCoords),
	        yMin: Math.min.apply(null, yCoords),
	        xMax: Math.max.apply(null, xCoords),
	        yMax: Math.max.apply(null, yCoords),
	        leftSideBearing: this.leftSideBearing
	    };

	    if (!isFinite(metrics.xMin)) {
	        metrics.xMin = 0;
	    }

	    if (!isFinite(metrics.xMax)) {
	        metrics.xMax = this.advanceWidth;
	    }

	    if (!isFinite(metrics.yMin)) {
	        metrics.yMin = 0;
	    }

	    if (!isFinite(metrics.yMax)) {
	        metrics.yMax = 0;
	    }

	    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
	    return metrics;
	};

	/**
	 * Draw the glyph on the given context.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
	 */
	Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
	    this.getPath(x, y, fontSize, options).draw(ctx);
	};

	/**
	 * Draw the points of the glyph.
	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 */
	Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
	    function drawCircles(l, x, y, scale) {
	        var PI_SQ = Math.PI * 2;
	        ctx.beginPath();
	        for (var j = 0; j < l.length; j += 1) {
	            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
	            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
	        }

	        ctx.closePath();
	        ctx.fill();
	    }

	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 24;
	    var scale = 1 / this.path.unitsPerEm * fontSize;

	    var blueCircles = [];
	    var redCircles = [];
	    var path = this.path;
	    for (var i = 0; i < path.commands.length; i += 1) {
	        var cmd = path.commands[i];
	        if (cmd.x !== undefined) {
	            blueCircles.push({x: cmd.x, y: -cmd.y});
	        }

	        if (cmd.x1 !== undefined) {
	            redCircles.push({x: cmd.x1, y: -cmd.y1});
	        }

	        if (cmd.x2 !== undefined) {
	            redCircles.push({x: cmd.x2, y: -cmd.y2});
	        }
	    }

	    ctx.fillStyle = 'blue';
	    drawCircles(blueCircles, x, y, scale);
	    ctx.fillStyle = 'red';
	    drawCircles(redCircles, x, y, scale);
	};

	/**
	 * Draw lines indicating important font measurements.
	 * Black lines indicate the origin of the coordinate system (point 0,0).
	 * Blue lines indicate the glyph bounding box.
	 * Green line indicates the advance width of the glyph.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 */
	Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
	    var scale;
	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 24;
	    scale = 1 / this.path.unitsPerEm * fontSize;
	    ctx.lineWidth = 1;

	    // Draw the origin
	    ctx.strokeStyle = 'black';
	    draw.line(ctx, x, -10000, x, 10000);
	    draw.line(ctx, -10000, y, 10000, y);

	    // This code is here due to memory optimization: by not using
	    // defaults in the constructor, we save a notable amount of memory.
	    var xMin = this.xMin || 0;
	    var yMin = this.yMin || 0;
	    var xMax = this.xMax || 0;
	    var yMax = this.yMax || 0;
	    var advanceWidth = this.advanceWidth || 0;

	    // Draw the glyph box
	    ctx.strokeStyle = 'blue';
	    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
	    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
	    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
	    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

	    // Draw the advance width
	    ctx.strokeStyle = 'green';
	    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
	};

	// The GlyphSet object

	// Define a property on the glyph that depends on the path being loaded.
	function defineDependentProperty(glyph, externalName, internalName) {
	    Object.defineProperty(glyph, externalName, {
	        get: function() {
	            // Request the path property to make sure the path is loaded.
	            glyph.path; // jshint ignore:line
	            return glyph[internalName];
	        },
	        set: function(newValue) {
	            glyph[internalName] = newValue;
	        },
	        enumerable: true,
	        configurable: true
	    });
	}

	/**
	 * A GlyphSet represents all glyphs available in the font, but modelled using
	 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
	 * necessary, to keep the memory footprint down.
	 * @exports opentype.GlyphSet
	 * @class
	 * @param {opentype.Font}
	 * @param {Array}
	 */
	function GlyphSet(font, glyphs) {
	    var this$1 = this;

	    this.font = font;
	    this.glyphs = {};
	    if (Array.isArray(glyphs)) {
	        for (var i = 0; i < glyphs.length; i++) {
	            this$1.glyphs[i] = glyphs[i];
	        }
	    }

	    this.length = (glyphs && glyphs.length) || 0;
	}

	/**
	 * @param  {number} index
	 * @return {opentype.Glyph}
	 */
	GlyphSet.prototype.get = function(index) {
	    if (typeof this.glyphs[index] === 'function') {
	        this.glyphs[index] = this.glyphs[index]();
	    }

	    return this.glyphs[index];
	};

	/**
	 * @param  {number} index
	 * @param  {Object}
	 */
	GlyphSet.prototype.push = function(index, loader) {
	    this.glyphs[index] = loader;
	    this.length++;
	};

	/**
	 * @alias opentype.glyphLoader
	 * @param  {opentype.Font} font
	 * @param  {number} index
	 * @return {opentype.Glyph}
	 */
	function glyphLoader(font, index) {
	    return new Glyph({index: index, font: font});
	}

	/**
	 * Generate a stub glyph that can be filled with all metadata *except*
	 * the "points" and "path" properties, which must be loaded only once
	 * the glyph's path is actually requested for text shaping.
	 * @alias opentype.ttfGlyphLoader
	 * @param  {opentype.Font} font
	 * @param  {number} index
	 * @param  {Function} parseGlyph
	 * @param  {Object} data
	 * @param  {number} position
	 * @param  {Function} buildPath
	 * @return {opentype.Glyph}
	 */
	function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
	    return function() {
	        var glyph = new Glyph({index: index, font: font});

	        glyph.path = function() {
	            parseGlyph(glyph, data, position);
	            var path = buildPath(font.glyphs, glyph);
	            path.unitsPerEm = font.unitsPerEm;
	            return path;
	        };

	        defineDependentProperty(glyph, 'xMin', '_xMin');
	        defineDependentProperty(glyph, 'xMax', '_xMax');
	        defineDependentProperty(glyph, 'yMin', '_yMin');
	        defineDependentProperty(glyph, 'yMax', '_yMax');

	        return glyph;
	    };
	}
	/**
	 * @alias opentype.cffGlyphLoader
	 * @param  {opentype.Font} font
	 * @param  {number} index
	 * @param  {Function} parseCFFCharstring
	 * @param  {string} charstring
	 * @return {opentype.Glyph}
	 */
	function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
	    return function() {
	        var glyph = new Glyph({index: index, font: font});

	        glyph.path = function() {
	            var path = parseCFFCharstring(font, glyph, charstring);
	            path.unitsPerEm = font.unitsPerEm;
	            return path;
	        };

	        return glyph;
	    };
	}

	var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

	// The `CFF` table contains the glyph outlines in PostScript format.

	// Custom equals function that can also check lists.
	function equals(a, b) {
	    if (a === b) {
	        return true;
	    } else if (Array.isArray(a) && Array.isArray(b)) {
	        if (a.length !== b.length) {
	            return false;
	        }

	        for (var i = 0; i < a.length; i += 1) {
	            if (!equals(a[i], b[i])) {
	                return false;
	            }
	        }

	        return true;
	    } else {
	        return false;
	    }
	}

	// Subroutines are encoded using the negative half of the number space.
	// See type 2 chapter 4.7 "Subroutine operators".
	function calcCFFSubroutineBias(subrs) {
	    var bias;
	    if (subrs.length < 1240) {
	        bias = 107;
	    } else if (subrs.length < 33900) {
	        bias = 1131;
	    } else {
	        bias = 32768;
	    }

	    return bias;
	}

	// Parse a `CFF` INDEX array.
	// An index array consists of a list of offsets, then a list of objects at those offsets.
	function parseCFFIndex(data, start, conversionFn) {
	    var offsets = [];
	    var objects = [];
	    var count = parse.getCard16(data, start);
	    var objectOffset;
	    var endOffset;
	    if (count !== 0) {
	        var offsetSize = parse.getByte(data, start + 2);
	        objectOffset = start + ((count + 1) * offsetSize) + 2;
	        var pos = start + 3;
	        for (var i = 0; i < count + 1; i += 1) {
	            offsets.push(parse.getOffset(data, pos, offsetSize));
	            pos += offsetSize;
	        }

	        // The total size of the index array is 4 header bytes + the value of the last offset.
	        endOffset = objectOffset + offsets[count];
	    } else {
	        endOffset = start + 2;
	    }

	    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
	        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
	        if (conversionFn) {
	            value = conversionFn(value);
	        }

	        objects.push(value);
	    }

	    return {objects: objects, startOffset: start, endOffset: endOffset};
	}

	// Parse a `CFF` DICT real value.
	function parseFloatOperand(parser) {
	    var s = '';
	    var eof = 15;
	    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
	    while (true) {
	        var b = parser.parseByte();
	        var n1 = b >> 4;
	        var n2 = b & 15;

	        if (n1 === eof) {
	            break;
	        }

	        s += lookup[n1];

	        if (n2 === eof) {
	            break;
	        }

	        s += lookup[n2];
	    }

	    return parseFloat(s);
	}

	// Parse a `CFF` DICT operand.
	function parseOperand(parser, b0) {
	    var b1;
	    var b2;
	    var b3;
	    var b4;
	    if (b0 === 28) {
	        b1 = parser.parseByte();
	        b2 = parser.parseByte();
	        return b1 << 8 | b2;
	    }

	    if (b0 === 29) {
	        b1 = parser.parseByte();
	        b2 = parser.parseByte();
	        b3 = parser.parseByte();
	        b4 = parser.parseByte();
	        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
	    }

	    if (b0 === 30) {
	        return parseFloatOperand(parser);
	    }

	    if (b0 >= 32 && b0 <= 246) {
	        return b0 - 139;
	    }

	    if (b0 >= 247 && b0 <= 250) {
	        b1 = parser.parseByte();
	        return (b0 - 247) * 256 + b1 + 108;
	    }

	    if (b0 >= 251 && b0 <= 254) {
	        b1 = parser.parseByte();
	        return -(b0 - 251) * 256 - b1 - 108;
	    }

	    throw new Error('Invalid b0 ' + b0);
	}

	// Convert the entries returned by `parseDict` to a proper dictionary.
	// If a value is a list of one, it is unpacked.
	function entriesToObject(entries) {
	    var o = {};
	    for (var i = 0; i < entries.length; i += 1) {
	        var key = entries[i][0];
	        var values = entries[i][1];
	        var value = (void 0);
	        if (values.length === 1) {
	            value = values[0];
	        } else {
	            value = values;
	        }

	        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
	            throw new Error('Object ' + o + ' already has key ' + key);
	        }

	        o[key] = value;
	    }

	    return o;
	}

	// Parse a `CFF` DICT object.
	// A dictionary contains key-value pairs in a compact tokenized format.
	function parseCFFDict(data, start, size) {
	    start = start !== undefined ? start : 0;
	    var parser = new parse.Parser(data, start);
	    var entries = [];
	    var operands = [];
	    size = size !== undefined ? size : data.length;

	    while (parser.relativeOffset < size) {
	        var op = parser.parseByte();

	        // The first byte for each dict item distinguishes between operator (key) and operand (value).
	        // Values <= 21 are operators.
	        if (op <= 21) {
	            // Two-byte operators have an initial escape byte of 12.
	            if (op === 12) {
	                op = 1200 + parser.parseByte();
	            }

	            entries.push([op, operands]);
	            operands = [];
	        } else {
	            // Since the operands (values) come before the operators (keys), we store all operands in a list
	            // until we encounter an operator.
	            operands.push(parseOperand(parser, op));
	        }
	    }

	    return entriesToObject(entries);
	}

	// Given a String Index (SID), return the value of the string.
	// Strings below index 392 are standard CFF strings and are not encoded in the font.
	function getCFFString(strings, index) {
	    if (index <= 390) {
	        index = cffStandardStrings[index];
	    } else {
	        index = strings[index - 391];
	    }

	    return index;
	}

	// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
	// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
	function interpretDict(dict, meta, strings) {
	    var newDict = {};
	    var value;

	    // Because we also want to include missing values, we start out from the meta list
	    // and lookup values in the dict.
	    for (var i = 0; i < meta.length; i += 1) {
	        var m = meta[i];

	        if (Array.isArray(m.type)) {
	            var values = [];
	            values.length = m.type.length;
	            for (var j = 0; j < m.type.length; j++) {
	                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
	                if (value === undefined) {
	                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
	                }
	                if (m.type[j] === 'SID') {
	                    value = getCFFString(strings, value);
	                }
	                values[j] = value;
	            }
	            newDict[m.name] = values;
	        } else {
	            value = dict[m.op];
	            if (value === undefined) {
	                value = m.value !== undefined ? m.value : null;
	            }

	            if (m.type === 'SID') {
	                value = getCFFString(strings, value);
	            }
	            newDict[m.name] = value;
	        }
	    }

	    return newDict;
	}

	// Parse the CFF header.
	function parseCFFHeader(data, start) {
	    var header = {};
	    header.formatMajor = parse.getCard8(data, start);
	    header.formatMinor = parse.getCard8(data, start + 1);
	    header.size = parse.getCard8(data, start + 2);
	    header.offsetSize = parse.getCard8(data, start + 3);
	    header.startOffset = start;
	    header.endOffset = start + 4;
	    return header;
	}

	var TOP_DICT_META = [
	    {name: 'version', op: 0, type: 'SID'},
	    {name: 'notice', op: 1, type: 'SID'},
	    {name: 'copyright', op: 1200, type: 'SID'},
	    {name: 'fullName', op: 2, type: 'SID'},
	    {name: 'familyName', op: 3, type: 'SID'},
	    {name: 'weight', op: 4, type: 'SID'},
	    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
	    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
	    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
	    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
	    {name: 'paintType', op: 1205, type: 'number', value: 0},
	    {name: 'charstringType', op: 1206, type: 'number', value: 2},
	    {
	        name: 'fontMatrix',
	        op: 1207,
	        type: ['real', 'real', 'real', 'real', 'real', 'real'],
	        value: [0.001, 0, 0, 0.001, 0, 0]
	    },
	    {name: 'uniqueId', op: 13, type: 'number'},
	    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
	    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
	    {name: 'xuid', op: 14, type: [], value: null},
	    {name: 'charset', op: 15, type: 'offset', value: 0},
	    {name: 'encoding', op: 16, type: 'offset', value: 0},
	    {name: 'charStrings', op: 17, type: 'offset', value: 0},
	    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
	    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
	    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
	    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
	    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
	    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
	    {name: 'uidBase', op: 1235, type: 'number'},
	    {name: 'fdArray', op: 1236, type: 'offset'},
	    {name: 'fdSelect', op: 1237, type: 'offset'},
	    {name: 'fontName', op: 1238, type: 'SID'}
	];

	var PRIVATE_DICT_META = [
	    {name: 'subrs', op: 19, type: 'offset', value: 0},
	    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
	    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
	];

	// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
	// The top dictionary contains the essential metadata for the font, together with the private dictionary.
	function parseCFFTopDict(data, strings) {
	    var dict = parseCFFDict(data, 0, data.byteLength);
	    return interpretDict(dict, TOP_DICT_META, strings);
	}

	// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
	function parseCFFPrivateDict(data, start, size, strings) {
	    var dict = parseCFFDict(data, start, size);
	    return interpretDict(dict, PRIVATE_DICT_META, strings);
	}

	// Returns a list of "Top DICT"s found using an INDEX list.
	// Used to read both the usual high-level Top DICTs and also the FDArray
	// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
	// a Private DICT that is read and saved into the Top DICT.
	//
	// In addition to the expected/optional values as outlined in TOP_DICT_META
	// the following values might be saved into the Top DICT.
	//
	//    _subrs []        array of local CFF subroutines from Private DICT
	//    _subrsBias       bias value computed from number of subroutines
	//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
	//    _defaultWidthX   default widths for CFF characters
	//    _nominalWidthX   bias added to width embedded within glyph description
	//
	//    _privateDict     saved copy of parsed Private DICT from Top DICT
	function gatherCFFTopDicts(data, start, cffIndex, strings) {
	    var topDictArray = [];
	    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
	        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
	        var topDict = parseCFFTopDict(topDictData, strings);
	        topDict._subrs = [];
	        topDict._subrsBias = 0;
	        var privateSize = topDict.private[0];
	        var privateOffset = topDict.private[1];
	        if (privateSize !== 0 && privateOffset !== 0) {
	            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
	            topDict._defaultWidthX = privateDict.defaultWidthX;
	            topDict._nominalWidthX = privateDict.nominalWidthX;
	            if (privateDict.subrs !== 0) {
	                var subrOffset = privateOffset + privateDict.subrs;
	                var subrIndex = parseCFFIndex(data, subrOffset + start);
	                topDict._subrs = subrIndex.objects;
	                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
	            }
	            topDict._privateDict = privateDict;
	        }
	        topDictArray.push(topDict);
	    }
	    return topDictArray;
	}

	// Parse the CFF charset table, which contains internal names for all the glyphs.
	// This function will return a list of glyph names.
	// See Adobe TN #5176 chapter 13, "Charsets".
	function parseCFFCharset(data, start, nGlyphs, strings) {
	    var sid;
	    var count;
	    var parser = new parse.Parser(data, start);

	    // The .notdef glyph is not included, so subtract 1.
	    nGlyphs -= 1;
	    var charset = ['.notdef'];

	    var format = parser.parseCard8();
	    if (format === 0) {
	        for (var i = 0; i < nGlyphs; i += 1) {
	            sid = parser.parseSID();
	            charset.push(getCFFString(strings, sid));
	        }
	    } else if (format === 1) {
	        while (charset.length <= nGlyphs) {
	            sid = parser.parseSID();
	            count = parser.parseCard8();
	            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
	                charset.push(getCFFString(strings, sid));
	                sid += 1;
	            }
	        }
	    } else if (format === 2) {
	        while (charset.length <= nGlyphs) {
	            sid = parser.parseSID();
	            count = parser.parseCard16();
	            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
	                charset.push(getCFFString(strings, sid));
	                sid += 1;
	            }
	        }
	    } else {
	        throw new Error('Unknown charset format ' + format);
	    }

	    return charset;
	}

	// Parse the CFF encoding data. Only one encoding can be specified per font.
	// See Adobe TN #5176 chapter 12, "Encodings".
	function parseCFFEncoding(data, start, charset) {
	    var code;
	    var enc = {};
	    var parser = new parse.Parser(data, start);
	    var format = parser.parseCard8();
	    if (format === 0) {
	        var nCodes = parser.parseCard8();
	        for (var i = 0; i < nCodes; i += 1) {
	            code = parser.parseCard8();
	            enc[code] = i;
	        }
	    } else if (format === 1) {
	        var nRanges = parser.parseCard8();
	        code = 1;
	        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
	            var first = parser.parseCard8();
	            var nLeft = parser.parseCard8();
	            for (var j = first; j <= first + nLeft; j += 1) {
	                enc[j] = code;
	                code += 1;
	            }
	        }
	    } else {
	        throw new Error('Unknown encoding format ' + format);
	    }

	    return new CffEncoding(enc, charset);
	}

	// Take in charstring code and return a Glyph object.
	// The encoding is described in the Type 2 Charstring Format
	// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
	function parseCFFCharstring(font, glyph, code) {
	    var c1x;
	    var c1y;
	    var c2x;
	    var c2y;
	    var p = new Path();
	    var stack = [];
	    var nStems = 0;
	    var haveWidth = false;
	    var open = false;
	    var x = 0;
	    var y = 0;
	    var subrs;
	    var subrsBias;
	    var defaultWidthX;
	    var nominalWidthX;
	    if (font.isCIDFont) {
	        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
	        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
	        subrs = fdDict._subrs;
	        subrsBias = fdDict._subrsBias;
	        defaultWidthX = fdDict._defaultWidthX;
	        nominalWidthX = fdDict._nominalWidthX;
	    } else {
	        subrs = font.tables.cff.topDict._subrs;
	        subrsBias = font.tables.cff.topDict._subrsBias;
	        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
	        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
	    }
	    var width = defaultWidthX;

	    function newContour(x, y) {
	        if (open) {
	            p.closePath();
	        }

	        p.moveTo(x, y);
	        open = true;
	    }

	    function parseStems() {
	        var hasWidthArg;

	        // The number of stem operators on the stack is always even.
	        // If the value is uneven, that means a width is specified.
	        hasWidthArg = stack.length % 2 !== 0;
	        if (hasWidthArg && !haveWidth) {
	            width = stack.shift() + nominalWidthX;
	        }

	        nStems += stack.length >> 1;
	        stack.length = 0;
	        haveWidth = true;
	    }

	    function parse$$1(code) {
	        var b1;
	        var b2;
	        var b3;
	        var b4;
	        var codeIndex;
	        var subrCode;
	        var jpx;
	        var jpy;
	        var c3x;
	        var c3y;
	        var c4x;
	        var c4y;

	        var i = 0;
	        while (i < code.length) {
	            var v = code[i];
	            i += 1;
	            switch (v) {
	                case 1: // hstem
	                    parseStems();
	                    break;
	                case 3: // vstem
	                    parseStems();
	                    break;
	                case 4: // vmoveto
	                    if (stack.length > 1 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    y += stack.pop();
	                    newContour(x, y);
	                    break;
	                case 5: // rlineto
	                    while (stack.length > 0) {
	                        x += stack.shift();
	                        y += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    break;
	                case 6: // hlineto
	                    while (stack.length > 0) {
	                        x += stack.shift();
	                        p.lineTo(x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        y += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    break;
	                case 7: // vlineto
	                    while (stack.length > 0) {
	                        y += stack.shift();
	                        p.lineTo(x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        x += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    break;
	                case 8: // rrcurveto
	                    while (stack.length > 0) {
	                        c1x = x + stack.shift();
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + stack.shift();
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 10: // callsubr
	                    codeIndex = stack.pop() + subrsBias;
	                    subrCode = subrs[codeIndex];
	                    if (subrCode) {
	                        parse$$1(subrCode);
	                    }

	                    break;
	                case 11: // return
	                    return;
	                case 12: // flex operators
	                    v = code[i];
	                    i += 1;
	                    switch (v) {
	                        case 35: // flex
	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y   + stack.shift();    // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y + stack.shift();    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = jpy + stack.shift();    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = c3y + stack.shift();    // dy5
	                            x = c4x   + stack.shift();    // dx6
	                            y = c4y   + stack.shift();    // dy6
	                            stack.shift();                // flex depth
	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        case 34: // hflex
	                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y;                      // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y;                    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = c2y;                    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = y;                      // dy5
	                            x = c4x + stack.shift();      // dx6
	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        case 36: // hflex1
	                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y   + stack.shift();    // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y;                    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = c2y;                    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = c3y + stack.shift();    // dy5
	                            x = c4x + stack.shift();      // dx6
	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        case 37: // flex1
	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
	                            c1x = x   + stack.shift();    // dx1
	                            c1y = y   + stack.shift();    // dy1
	                            c2x = c1x + stack.shift();    // dx2
	                            c2y = c1y + stack.shift();    // dy2
	                            jpx = c2x + stack.shift();    // dx3
	                            jpy = c2y + stack.shift();    // dy3
	                            c3x = jpx + stack.shift();    // dx4
	                            c3y = jpy + stack.shift();    // dy4
	                            c4x = c3x + stack.shift();    // dx5
	                            c4y = c3y + stack.shift();    // dy5
	                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
	                                x = c4x + stack.shift();
	                            } else {
	                                y = c4y + stack.shift();
	                            }

	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
	                            break;
	                        default:
	                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
	                            stack.length = 0;
	                    }
	                    break;
	                case 14: // endchar
	                    if (stack.length > 0 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    if (open) {
	                        p.closePath();
	                        open = false;
	                    }

	                    break;
	                case 18: // hstemhm
	                    parseStems();
	                    break;
	                case 19: // hintmask
	                case 20: // cntrmask
	                    parseStems();
	                    i += (nStems + 7) >> 3;
	                    break;
	                case 21: // rmoveto
	                    if (stack.length > 2 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    y += stack.pop();
	                    x += stack.pop();
	                    newContour(x, y);
	                    break;
	                case 22: // hmoveto
	                    if (stack.length > 1 && !haveWidth) {
	                        width = stack.shift() + nominalWidthX;
	                        haveWidth = true;
	                    }

	                    x += stack.pop();
	                    newContour(x, y);
	                    break;
	                case 23: // vstemhm
	                    parseStems();
	                    break;
	                case 24: // rcurveline
	                    while (stack.length > 2) {
	                        c1x = x + stack.shift();
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + stack.shift();
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    x += stack.shift();
	                    y += stack.shift();
	                    p.lineTo(x, y);
	                    break;
	                case 25: // rlinecurve
	                    while (stack.length > 6) {
	                        x += stack.shift();
	                        y += stack.shift();
	                        p.lineTo(x, y);
	                    }

	                    c1x = x + stack.shift();
	                    c1y = y + stack.shift();
	                    c2x = c1x + stack.shift();
	                    c2y = c1y + stack.shift();
	                    x = c2x + stack.shift();
	                    y = c2y + stack.shift();
	                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    break;
	                case 26: // vvcurveto
	                    if (stack.length % 2) {
	                        x += stack.shift();
	                    }

	                    while (stack.length > 0) {
	                        c1x = x;
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x;
	                        y = c2y + stack.shift();
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 27: // hhcurveto
	                    if (stack.length % 2) {
	                        y += stack.shift();
	                    }

	                    while (stack.length > 0) {
	                        c1x = x + stack.shift();
	                        c1y = y;
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y;
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 28: // shortint
	                    b1 = code[i];
	                    b2 = code[i + 1];
	                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
	                    i += 2;
	                    break;
	                case 29: // callgsubr
	                    codeIndex = stack.pop() + font.gsubrsBias;
	                    subrCode = font.gsubrs[codeIndex];
	                    if (subrCode) {
	                        parse$$1(subrCode);
	                    }

	                    break;
	                case 30: // vhcurveto
	                    while (stack.length > 0) {
	                        c1x = x;
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        c1x = x + stack.shift();
	                        c1y = y;
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        y = c2y + stack.shift();
	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                case 31: // hvcurveto
	                    while (stack.length > 0) {
	                        c1x = x + stack.shift();
	                        c1y = y;
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        y = c2y + stack.shift();
	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                        if (stack.length === 0) {
	                            break;
	                        }

	                        c1x = x;
	                        c1y = y + stack.shift();
	                        c2x = c1x + stack.shift();
	                        c2y = c1y + stack.shift();
	                        x = c2x + stack.shift();
	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
	                    }

	                    break;
	                default:
	                    if (v < 32) {
	                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
	                    } else if (v < 247) {
	                        stack.push(v - 139);
	                    } else if (v < 251) {
	                        b1 = code[i];
	                        i += 1;
	                        stack.push((v - 247) * 256 + b1 + 108);
	                    } else if (v < 255) {
	                        b1 = code[i];
	                        i += 1;
	                        stack.push(-(v - 251) * 256 - b1 - 108);
	                    } else {
	                        b1 = code[i];
	                        b2 = code[i + 1];
	                        b3 = code[i + 2];
	                        b4 = code[i + 3];
	                        i += 4;
	                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
	                    }
	            }
	        }
	    }

	    parse$$1(code);

	    glyph.advanceWidth = width;
	    return p;
	}

	function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
	    var fdSelect = [];
	    var fdIndex;
	    var parser = new parse.Parser(data, start);
	    var format = parser.parseCard8();
	    if (format === 0) {
	        // Simple list of nGlyphs elements
	        for (var iGid = 0; iGid < nGlyphs; iGid++) {
	            fdIndex = parser.parseCard8();
	            if (fdIndex >= fdArrayCount) {
	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
	            }
	            fdSelect.push(fdIndex);
	        }
	    } else if (format === 3) {
	        // Ranges
	        var nRanges = parser.parseCard16();
	        var first = parser.parseCard16();
	        if (first !== 0) {
	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
	        }
	        var next;
	        for (var iRange = 0; iRange < nRanges; iRange++) {
	            fdIndex = parser.parseCard8();
	            next = parser.parseCard16();
	            if (fdIndex >= fdArrayCount) {
	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
	            }
	            if (next > nGlyphs) {
	                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
	            }
	            for (; first < next; first++) {
	                fdSelect.push(fdIndex);
	            }
	            first = next;
	        }
	        if (next !== nGlyphs) {
	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
	        }
	    } else {
	        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
	    }
	    return fdSelect;
	}

	// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
	function parseCFFTable(data, start, font) {
	    font.tables.cff = {};
	    var header = parseCFFHeader(data, start);
	    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
	    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
	    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
	    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
	    font.gsubrs = globalSubrIndex.objects;
	    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

	    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
	    if (topDictArray.length !== 1) {
	        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
	    }

	    var topDict = topDictArray[0];
	    font.tables.cff.topDict = topDict;

	    if (topDict._privateDict) {
	        font.defaultWidthX = topDict._privateDict.defaultWidthX;
	        font.nominalWidthX = topDict._privateDict.nominalWidthX;
	    }

	    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
	        font.isCIDFont = true;
	    }

	    if (font.isCIDFont) {
	        var fdArrayOffset = topDict.fdArray;
	        var fdSelectOffset = topDict.fdSelect;
	        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
	            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
	        }
	        fdArrayOffset += start;
	        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
	        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
	        topDict._fdArray = fdArray;
	        fdSelectOffset += start;
	        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
	    }

	    var privateDictOffset = start + topDict.private[1];
	    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
	    font.defaultWidthX = privateDict.defaultWidthX;
	    font.nominalWidthX = privateDict.nominalWidthX;

	    if (privateDict.subrs !== 0) {
	        var subrOffset = privateDictOffset + privateDict.subrs;
	        var subrIndex = parseCFFIndex(data, subrOffset);
	        font.subrs = subrIndex.objects;
	        font.subrsBias = calcCFFSubroutineBias(font.subrs);
	    } else {
	        font.subrs = [];
	        font.subrsBias = 0;
	    }

	    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
	    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
	    font.nGlyphs = charStringsIndex.objects.length;

	    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
	    if (topDict.encoding === 0) {
	        // Standard encoding
	        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
	    } else if (topDict.encoding === 1) {
	        // Expert encoding
	        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
	    } else {
	        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
	    }

	    // Prefer the CMAP encoding to the CFF encoding.
	    font.encoding = font.encoding || font.cffEncoding;

	    font.glyphs = new glyphset.GlyphSet(font);
	    for (var i = 0; i < font.nGlyphs; i += 1) {
	        var charString = charStringsIndex.objects[i];
	        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
	    }
	}

	// Convert a string to a String ID (SID).
	// The list of strings is modified in place.
	function encodeString(s, strings) {
	    var sid;

	    // Is the string in the CFF standard strings?
	    var i = cffStandardStrings.indexOf(s);
	    if (i >= 0) {
	        sid = i;
	    }

	    // Is the string already in the string index?
	    i = strings.indexOf(s);
	    if (i >= 0) {
	        sid = i + cffStandardStrings.length;
	    } else {
	        sid = cffStandardStrings.length + strings.length;
	        strings.push(s);
	    }

	    return sid;
	}

	function makeHeader() {
	    return new table.Record('Header', [
	        {name: 'major', type: 'Card8', value: 1},
	        {name: 'minor', type: 'Card8', value: 0},
	        {name: 'hdrSize', type: 'Card8', value: 4},
	        {name: 'major', type: 'Card8', value: 1}
	    ]);
	}

	function makeNameIndex(fontNames) {
	    var t = new table.Record('Name INDEX', [
	        {name: 'names', type: 'INDEX', value: []}
	    ]);
	    t.names = [];
	    for (var i = 0; i < fontNames.length; i += 1) {
	        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
	    }

	    return t;
	}

	// Given a dictionary's metadata, create a DICT structure.
	function makeDict(meta, attrs, strings) {
	    var m = {};
	    for (var i = 0; i < meta.length; i += 1) {
	        var entry = meta[i];
	        var value = attrs[entry.name];
	        if (value !== undefined && !equals(value, entry.value)) {
	            if (entry.type === 'SID') {
	                value = encodeString(value, strings);
	            }

	            m[entry.op] = {name: entry.name, type: entry.type, value: value};
	        }
	    }

	    return m;
	}

	// The Top DICT houses the global font attributes.
	function makeTopDict(attrs, strings) {
	    var t = new table.Record('Top DICT', [
	        {name: 'dict', type: 'DICT', value: {}}
	    ]);
	    t.dict = makeDict(TOP_DICT_META, attrs, strings);
	    return t;
	}

	function makeTopDictIndex(topDict) {
	    var t = new table.Record('Top DICT INDEX', [
	        {name: 'topDicts', type: 'INDEX', value: []}
	    ]);
	    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
	    return t;
	}

	function makeStringIndex(strings) {
	    var t = new table.Record('String INDEX', [
	        {name: 'strings', type: 'INDEX', value: []}
	    ]);
	    t.strings = [];
	    for (var i = 0; i < strings.length; i += 1) {
	        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
	    }

	    return t;
	}

	function makeGlobalSubrIndex() {
	    // Currently we don't use subroutines.
	    return new table.Record('Global Subr INDEX', [
	        {name: 'subrs', type: 'INDEX', value: []}
	    ]);
	}

	function makeCharsets(glyphNames, strings) {
	    var t = new table.Record('Charsets', [
	        {name: 'format', type: 'Card8', value: 0}
	    ]);
	    for (var i = 0; i < glyphNames.length; i += 1) {
	        var glyphName = glyphNames[i];
	        var glyphSID = encodeString(glyphName, strings);
	        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
	    }

	    return t;
	}

	function glyphToOps(glyph) {
	    var ops = [];
	    var path = glyph.path;
	    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
	    var x = 0;
	    var y = 0;
	    for (var i = 0; i < path.commands.length; i += 1) {
	        var dx = (void 0);
	        var dy = (void 0);
	        var cmd = path.commands[i];
	        if (cmd.type === 'Q') {
	            // CFF only supports bézier curves, so convert the quad to a bézier.
	            var _13 = 1 / 3;
	            var _23 = 2 / 3;

	            // We're going to create a new command so we don't change the original path.
	            cmd = {
	                type: 'C',
	                x: cmd.x,
	                y: cmd.y,
	                x1: _13 * x + _23 * cmd.x1,
	                y1: _13 * y + _23 * cmd.y1,
	                x2: _13 * cmd.x + _23 * cmd.x1,
	                y2: _13 * cmd.y + _23 * cmd.y1
	            };
	        }

	        if (cmd.type === 'M') {
	            dx = Math.round(cmd.x - x);
	            dy = Math.round(cmd.y - y);
	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
	            ops.push({name: 'rmoveto', type: 'OP', value: 21});
	            x = Math.round(cmd.x);
	            y = Math.round(cmd.y);
	        } else if (cmd.type === 'L') {
	            dx = Math.round(cmd.x - x);
	            dy = Math.round(cmd.y - y);
	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
	            ops.push({name: 'rlineto', type: 'OP', value: 5});
	            x = Math.round(cmd.x);
	            y = Math.round(cmd.y);
	        } else if (cmd.type === 'C') {
	            var dx1 = Math.round(cmd.x1 - x);
	            var dy1 = Math.round(cmd.y1 - y);
	            var dx2 = Math.round(cmd.x2 - cmd.x1);
	            var dy2 = Math.round(cmd.y2 - cmd.y1);
	            dx = Math.round(cmd.x - cmd.x2);
	            dy = Math.round(cmd.y - cmd.y2);
	            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
	            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
	            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
	            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
	            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
	            x = Math.round(cmd.x);
	            y = Math.round(cmd.y);
	        }

	        // Contours are closed automatically.
	    }

	    ops.push({name: 'endchar', type: 'OP', value: 14});
	    return ops;
	}

	function makeCharStringsIndex(glyphs) {
	    var t = new table.Record('CharStrings INDEX', [
	        {name: 'charStrings', type: 'INDEX', value: []}
	    ]);

	    for (var i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs.get(i);
	        var ops = glyphToOps(glyph);
	        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
	    }

	    return t;
	}

	function makePrivateDict(attrs, strings) {
	    var t = new table.Record('Private DICT', [
	        {name: 'dict', type: 'DICT', value: {}}
	    ]);
	    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
	    return t;
	}

	function makeCFFTable(glyphs, options) {
	    var t = new table.Table('CFF ', [
	        {name: 'header', type: 'RECORD'},
	        {name: 'nameIndex', type: 'RECORD'},
	        {name: 'topDictIndex', type: 'RECORD'},
	        {name: 'stringIndex', type: 'RECORD'},
	        {name: 'globalSubrIndex', type: 'RECORD'},
	        {name: 'charsets', type: 'RECORD'},
	        {name: 'charStringsIndex', type: 'RECORD'},
	        {name: 'privateDict', type: 'RECORD'}
	    ]);

	    var fontScale = 1 / options.unitsPerEm;
	    // We use non-zero values for the offsets so that the DICT encodes them.
	    // This is important because the size of the Top DICT plays a role in offset calculation,
	    // and the size shouldn't change after we've written correct offsets.
	    var attrs = {
	        version: options.version,
	        fullName: options.fullName,
	        familyName: options.familyName,
	        weight: options.weightName,
	        fontBBox: options.fontBBox || [0, 0, 0, 0],
	        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
	        charset: 999,
	        encoding: 0,
	        charStrings: 999,
	        private: [0, 999]
	    };

	    var privateAttrs = {};

	    var glyphNames = [];
	    var glyph;

	    // Skip first glyph (.notdef)
	    for (var i = 1; i < glyphs.length; i += 1) {
	        glyph = glyphs.get(i);
	        glyphNames.push(glyph.name);
	    }

	    var strings = [];

	    t.header = makeHeader();
	    t.nameIndex = makeNameIndex([options.postScriptName]);
	    var topDict = makeTopDict(attrs, strings);
	    t.topDictIndex = makeTopDictIndex(topDict);
	    t.globalSubrIndex = makeGlobalSubrIndex();
	    t.charsets = makeCharsets(glyphNames, strings);
	    t.charStringsIndex = makeCharStringsIndex(glyphs);
	    t.privateDict = makePrivateDict(privateAttrs, strings);

	    // Needs to come at the end, to encode all custom strings used in the font.
	    t.stringIndex = makeStringIndex(strings);

	    var startOffset = t.header.sizeOf() +
	        t.nameIndex.sizeOf() +
	        t.topDictIndex.sizeOf() +
	        t.stringIndex.sizeOf() +
	        t.globalSubrIndex.sizeOf();
	    attrs.charset = startOffset;

	    // We use the CFF standard encoding; proper encoding will be handled in cmap.
	    attrs.encoding = 0;
	    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
	    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

	    // Recreate the Top DICT INDEX with the correct offsets.
	    topDict = makeTopDict(attrs, strings);
	    t.topDictIndex = makeTopDictIndex(topDict);

	    return t;
	}

	var cff = { parse: parseCFFTable, make: makeCFFTable };

	// The `head` table contains global information about the font.

	// Parse the header `head` table
	function parseHeadTable(data, start) {
	    var head = {};
	    var p = new parse.Parser(data, start);
	    head.version = p.parseVersion();
	    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
	    head.checkSumAdjustment = p.parseULong();
	    head.magicNumber = p.parseULong();
	    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
	    head.flags = p.parseUShort();
	    head.unitsPerEm = p.parseUShort();
	    head.created = p.parseLongDateTime();
	    head.modified = p.parseLongDateTime();
	    head.xMin = p.parseShort();
	    head.yMin = p.parseShort();
	    head.xMax = p.parseShort();
	    head.yMax = p.parseShort();
	    head.macStyle = p.parseUShort();
	    head.lowestRecPPEM = p.parseUShort();
	    head.fontDirectionHint = p.parseShort();
	    head.indexToLocFormat = p.parseShort();
	    head.glyphDataFormat = p.parseShort();
	    return head;
	}

	function makeHeadTable(options) {
	    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
	    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
	    var createdTimestamp = timestamp;

	    if (options.createdTimestamp) {
	        createdTimestamp = options.createdTimestamp + 2082844800;
	    }

	    return new table.Table('head', [
	        {name: 'version', type: 'FIXED', value: 0x00010000},
	        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
	        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
	        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
	        {name: 'flags', type: 'USHORT', value: 0},
	        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
	        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
	        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
	        {name: 'xMin', type: 'SHORT', value: 0},
	        {name: 'yMin', type: 'SHORT', value: 0},
	        {name: 'xMax', type: 'SHORT', value: 0},
	        {name: 'yMax', type: 'SHORT', value: 0},
	        {name: 'macStyle', type: 'USHORT', value: 0},
	        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
	        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
	        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
	        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
	    ], options);
	}

	var head = { parse: parseHeadTable, make: makeHeadTable };

	// The `hhea` table contains information for horizontal layout.

	// Parse the horizontal header `hhea` table
	function parseHheaTable(data, start) {
	    var hhea = {};
	    var p = new parse.Parser(data, start);
	    hhea.version = p.parseVersion();
	    hhea.ascender = p.parseShort();
	    hhea.descender = p.parseShort();
	    hhea.lineGap = p.parseShort();
	    hhea.advanceWidthMax = p.parseUShort();
	    hhea.minLeftSideBearing = p.parseShort();
	    hhea.minRightSideBearing = p.parseShort();
	    hhea.xMaxExtent = p.parseShort();
	    hhea.caretSlopeRise = p.parseShort();
	    hhea.caretSlopeRun = p.parseShort();
	    hhea.caretOffset = p.parseShort();
	    p.relativeOffset += 8;
	    hhea.metricDataFormat = p.parseShort();
	    hhea.numberOfHMetrics = p.parseUShort();
	    return hhea;
	}

	function makeHheaTable(options) {
	    return new table.Table('hhea', [
	        {name: 'version', type: 'FIXED', value: 0x00010000},
	        {name: 'ascender', type: 'FWORD', value: 0},
	        {name: 'descender', type: 'FWORD', value: 0},
	        {name: 'lineGap', type: 'FWORD', value: 0},
	        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
	        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
	        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
	        {name: 'xMaxExtent', type: 'FWORD', value: 0},
	        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
	        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
	        {name: 'caretOffset', type: 'SHORT', value: 0},
	        {name: 'reserved1', type: 'SHORT', value: 0},
	        {name: 'reserved2', type: 'SHORT', value: 0},
	        {name: 'reserved3', type: 'SHORT', value: 0},
	        {name: 'reserved4', type: 'SHORT', value: 0},
	        {name: 'metricDataFormat', type: 'SHORT', value: 0},
	        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
	    ], options);
	}

	var hhea = { parse: parseHheaTable, make: makeHheaTable };

	// The `hmtx` table contains the horizontal metrics for all glyphs.

	// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
	// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
	function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
	    var advanceWidth;
	    var leftSideBearing;
	    var p = new parse.Parser(data, start);
	    for (var i = 0; i < numGlyphs; i += 1) {
	        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
	        if (i < numMetrics) {
	            advanceWidth = p.parseUShort();
	            leftSideBearing = p.parseShort();
	        }

	        var glyph = glyphs.get(i);
	        glyph.advanceWidth = advanceWidth;
	        glyph.leftSideBearing = leftSideBearing;
	    }
	}

	function makeHmtxTable(glyphs) {
	    var t = new table.Table('hmtx', []);
	    for (var i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs.get(i);
	        var advanceWidth = glyph.advanceWidth || 0;
	        var leftSideBearing = glyph.leftSideBearing || 0;
	        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
	        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
	    }

	    return t;
	}

	var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };

	// The `ltag` table stores IETF BCP-47 language tags. It allows supporting

	function makeLtagTable(tags) {
	    var result = new table.Table('ltag', [
	        {name: 'version', type: 'ULONG', value: 1},
	        {name: 'flags', type: 'ULONG', value: 0},
	        {name: 'numTags', type: 'ULONG', value: tags.length}
	    ]);

	    var stringPool = '';
	    var stringPoolOffset = 12 + tags.length * 4;
	    for (var i = 0; i < tags.length; ++i) {
	        var pos = stringPool.indexOf(tags[i]);
	        if (pos < 0) {
	            pos = stringPool.length;
	            stringPool += tags[i];
	        }

	        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
	        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
	    }

	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
	    return result;
	}

	function parseLtagTable(data, start) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseULong();
	    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
	    // The 'ltag' specification does not define any flags; skip the field.
	    p.skip('uLong', 1);
	    var numTags = p.parseULong();

	    var tags = [];
	    for (var i = 0; i < numTags; i++) {
	        var tag = '';
	        var offset = start + p.parseUShort();
	        var length = p.parseUShort();
	        for (var j = offset; j < offset + length; ++j) {
	            tag += String.fromCharCode(data.getInt8(j));
	        }

	        tags.push(tag);
	    }

	    return tags;
	}

	var ltag = { make: makeLtagTable, parse: parseLtagTable };

	// The `maxp` table establishes the memory requirements for the font.

	// Parse the maximum profile `maxp` table.
	function parseMaxpTable(data, start) {
	    var maxp = {};
	    var p = new parse.Parser(data, start);
	    maxp.version = p.parseVersion();
	    maxp.numGlyphs = p.parseUShort();
	    if (maxp.version === 1.0) {
	        maxp.maxPoints = p.parseUShort();
	        maxp.maxContours = p.parseUShort();
	        maxp.maxCompositePoints = p.parseUShort();
	        maxp.maxCompositeContours = p.parseUShort();
	        maxp.maxZones = p.parseUShort();
	        maxp.maxTwilightPoints = p.parseUShort();
	        maxp.maxStorage = p.parseUShort();
	        maxp.maxFunctionDefs = p.parseUShort();
	        maxp.maxInstructionDefs = p.parseUShort();
	        maxp.maxStackElements = p.parseUShort();
	        maxp.maxSizeOfInstructions = p.parseUShort();
	        maxp.maxComponentElements = p.parseUShort();
	        maxp.maxComponentDepth = p.parseUShort();
	    }

	    return maxp;
	}

	function makeMaxpTable(numGlyphs) {
	    return new table.Table('maxp', [
	        {name: 'version', type: 'FIXED', value: 0x00005000},
	        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
	    ]);
	}

	var maxp = { parse: parseMaxpTable, make: makeMaxpTable };

	// The `name` naming table.

	// NameIDs for the name table.
	var nameTableNames = [
	    'copyright',              // 0
	    'fontFamily',             // 1
	    'fontSubfamily',          // 2
	    'uniqueID',               // 3
	    'fullName',               // 4
	    'version',                // 5
	    'postScriptName',         // 6
	    'trademark',              // 7
	    'manufacturer',           // 8
	    'designer',               // 9
	    'description',            // 10
	    'manufacturerURL',        // 11
	    'designerURL',            // 12
	    'license',                // 13
	    'licenseURL',             // 14
	    'reserved',               // 15
	    'preferredFamily',        // 16
	    'preferredSubfamily',     // 17
	    'compatibleFullName',     // 18
	    'sampleText',             // 19
	    'postScriptFindFontName', // 20
	    'wwsFamily',              // 21
	    'wwsSubfamily'            // 22
	];

	var macLanguages = {
	    0: 'en',
	    1: 'fr',
	    2: 'de',
	    3: 'it',
	    4: 'nl',
	    5: 'sv',
	    6: 'es',
	    7: 'da',
	    8: 'pt',
	    9: 'no',
	    10: 'he',
	    11: 'ja',
	    12: 'ar',
	    13: 'fi',
	    14: 'el',
	    15: 'is',
	    16: 'mt',
	    17: 'tr',
	    18: 'hr',
	    19: 'zh-Hant',
	    20: 'ur',
	    21: 'hi',
	    22: 'th',
	    23: 'ko',
	    24: 'lt',
	    25: 'pl',
	    26: 'hu',
	    27: 'es',
	    28: 'lv',
	    29: 'se',
	    30: 'fo',
	    31: 'fa',
	    32: 'ru',
	    33: 'zh',
	    34: 'nl-BE',
	    35: 'ga',
	    36: 'sq',
	    37: 'ro',
	    38: 'cz',
	    39: 'sk',
	    40: 'si',
	    41: 'yi',
	    42: 'sr',
	    43: 'mk',
	    44: 'bg',
	    45: 'uk',
	    46: 'be',
	    47: 'uz',
	    48: 'kk',
	    49: 'az-Cyrl',
	    50: 'az-Arab',
	    51: 'hy',
	    52: 'ka',
	    53: 'mo',
	    54: 'ky',
	    55: 'tg',
	    56: 'tk',
	    57: 'mn-CN',
	    58: 'mn',
	    59: 'ps',
	    60: 'ks',
	    61: 'ku',
	    62: 'sd',
	    63: 'bo',
	    64: 'ne',
	    65: 'sa',
	    66: 'mr',
	    67: 'bn',
	    68: 'as',
	    69: 'gu',
	    70: 'pa',
	    71: 'or',
	    72: 'ml',
	    73: 'kn',
	    74: 'ta',
	    75: 'te',
	    76: 'si',
	    77: 'my',
	    78: 'km',
	    79: 'lo',
	    80: 'vi',
	    81: 'id',
	    82: 'tl',
	    83: 'ms',
	    84: 'ms-Arab',
	    85: 'am',
	    86: 'ti',
	    87: 'om',
	    88: 'so',
	    89: 'sw',
	    90: 'rw',
	    91: 'rn',
	    92: 'ny',
	    93: 'mg',
	    94: 'eo',
	    128: 'cy',
	    129: 'eu',
	    130: 'ca',
	    131: 'la',
	    132: 'qu',
	    133: 'gn',
	    134: 'ay',
	    135: 'tt',
	    136: 'ug',
	    137: 'dz',
	    138: 'jv',
	    139: 'su',
	    140: 'gl',
	    141: 'af',
	    142: 'br',
	    143: 'iu',
	    144: 'gd',
	    145: 'gv',
	    146: 'ga',
	    147: 'to',
	    148: 'el-polyton',
	    149: 'kl',
	    150: 'az',
	    151: 'nn'
	};

	// MacOS language ID → MacOS script ID
	//
	// Note that the script ID is not sufficient to determine what encoding
	// to use in TrueType files. For some languages, MacOS used a modification
	// of a mainstream script. For example, an Icelandic name would be stored
	// with smRoman in the TrueType naming table, but the actual encoding
	// is a special Icelandic version of the normal Macintosh Roman encoding.
	// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
	// Syllables but MacOS had run out of available script codes, so this was
	// done as a (pretty radical) "modification" of Ethiopic.
	//
	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
	var macLanguageToScript = {
	    0: 0,  // langEnglish → smRoman
	    1: 0,  // langFrench → smRoman
	    2: 0,  // langGerman → smRoman
	    3: 0,  // langItalian → smRoman
	    4: 0,  // langDutch → smRoman
	    5: 0,  // langSwedish → smRoman
	    6: 0,  // langSpanish → smRoman
	    7: 0,  // langDanish → smRoman
	    8: 0,  // langPortuguese → smRoman
	    9: 0,  // langNorwegian → smRoman
	    10: 5,  // langHebrew → smHebrew
	    11: 1,  // langJapanese → smJapanese
	    12: 4,  // langArabic → smArabic
	    13: 0,  // langFinnish → smRoman
	    14: 6,  // langGreek → smGreek
	    15: 0,  // langIcelandic → smRoman (modified)
	    16: 0,  // langMaltese → smRoman
	    17: 0,  // langTurkish → smRoman (modified)
	    18: 0,  // langCroatian → smRoman (modified)
	    19: 2,  // langTradChinese → smTradChinese
	    20: 4,  // langUrdu → smArabic
	    21: 9,  // langHindi → smDevanagari
	    22: 21,  // langThai → smThai
	    23: 3,  // langKorean → smKorean
	    24: 29,  // langLithuanian → smCentralEuroRoman
	    25: 29,  // langPolish → smCentralEuroRoman
	    26: 29,  // langHungarian → smCentralEuroRoman
	    27: 29,  // langEstonian → smCentralEuroRoman
	    28: 29,  // langLatvian → smCentralEuroRoman
	    29: 0,  // langSami → smRoman
	    30: 0,  // langFaroese → smRoman (modified)
	    31: 4,  // langFarsi → smArabic (modified)
	    32: 7,  // langRussian → smCyrillic
	    33: 25,  // langSimpChinese → smSimpChinese
	    34: 0,  // langFlemish → smRoman
	    35: 0,  // langIrishGaelic → smRoman (modified)
	    36: 0,  // langAlbanian → smRoman
	    37: 0,  // langRomanian → smRoman (modified)
	    38: 29,  // langCzech → smCentralEuroRoman
	    39: 29,  // langSlovak → smCentralEuroRoman
	    40: 0,  // langSlovenian → smRoman (modified)
	    41: 5,  // langYiddish → smHebrew
	    42: 7,  // langSerbian → smCyrillic
	    43: 7,  // langMacedonian → smCyrillic
	    44: 7,  // langBulgarian → smCyrillic
	    45: 7,  // langUkrainian → smCyrillic (modified)
	    46: 7,  // langByelorussian → smCyrillic
	    47: 7,  // langUzbek → smCyrillic
	    48: 7,  // langKazakh → smCyrillic
	    49: 7,  // langAzerbaijani → smCyrillic
	    50: 4,  // langAzerbaijanAr → smArabic
	    51: 24,  // langArmenian → smArmenian
	    52: 23,  // langGeorgian → smGeorgian
	    53: 7,  // langMoldavian → smCyrillic
	    54: 7,  // langKirghiz → smCyrillic
	    55: 7,  // langTajiki → smCyrillic
	    56: 7,  // langTurkmen → smCyrillic
	    57: 27,  // langMongolian → smMongolian
	    58: 7,  // langMongolianCyr → smCyrillic
	    59: 4,  // langPashto → smArabic
	    60: 4,  // langKurdish → smArabic
	    61: 4,  // langKashmiri → smArabic
	    62: 4,  // langSindhi → smArabic
	    63: 26,  // langTibetan → smTibetan
	    64: 9,  // langNepali → smDevanagari
	    65: 9,  // langSanskrit → smDevanagari
	    66: 9,  // langMarathi → smDevanagari
	    67: 13,  // langBengali → smBengali
	    68: 13,  // langAssamese → smBengali
	    69: 11,  // langGujarati → smGujarati
	    70: 10,  // langPunjabi → smGurmukhi
	    71: 12,  // langOriya → smOriya
	    72: 17,  // langMalayalam → smMalayalam
	    73: 16,  // langKannada → smKannada
	    74: 14,  // langTamil → smTamil
	    75: 15,  // langTelugu → smTelugu
	    76: 18,  // langSinhalese → smSinhalese
	    77: 19,  // langBurmese → smBurmese
	    78: 20,  // langKhmer → smKhmer
	    79: 22,  // langLao → smLao
	    80: 30,  // langVietnamese → smVietnamese
	    81: 0,  // langIndonesian → smRoman
	    82: 0,  // langTagalog → smRoman
	    83: 0,  // langMalayRoman → smRoman
	    84: 4,  // langMalayArabic → smArabic
	    85: 28,  // langAmharic → smEthiopic
	    86: 28,  // langTigrinya → smEthiopic
	    87: 28,  // langOromo → smEthiopic
	    88: 0,  // langSomali → smRoman
	    89: 0,  // langSwahili → smRoman
	    90: 0,  // langKinyarwanda → smRoman
	    91: 0,  // langRundi → smRoman
	    92: 0,  // langNyanja → smRoman
	    93: 0,  // langMalagasy → smRoman
	    94: 0,  // langEsperanto → smRoman
	    128: 0,  // langWelsh → smRoman (modified)
	    129: 0,  // langBasque → smRoman
	    130: 0,  // langCatalan → smRoman
	    131: 0,  // langLatin → smRoman
	    132: 0,  // langQuechua → smRoman
	    133: 0,  // langGuarani → smRoman
	    134: 0,  // langAymara → smRoman
	    135: 7,  // langTatar → smCyrillic
	    136: 4,  // langUighur → smArabic
	    137: 26,  // langDzongkha → smTibetan
	    138: 0,  // langJavaneseRom → smRoman
	    139: 0,  // langSundaneseRom → smRoman
	    140: 0,  // langGalician → smRoman
	    141: 0,  // langAfrikaans → smRoman
	    142: 0,  // langBreton → smRoman (modified)
	    143: 28,  // langInuktitut → smEthiopic (modified)
	    144: 0,  // langScottishGaelic → smRoman (modified)
	    145: 0,  // langManxGaelic → smRoman (modified)
	    146: 0,  // langIrishGaelicScript → smRoman (modified)
	    147: 0,  // langTongan → smRoman
	    148: 6,  // langGreekAncient → smRoman
	    149: 0,  // langGreenlandic → smRoman
	    150: 0,  // langAzerbaijanRoman → smRoman
	    151: 0   // langNynorsk → smRoman
	};

	// While Microsoft indicates a region/country for all its language
	// IDs, we omit the region code if it's equal to the "most likely
	// region subtag" according to Unicode CLDR. For scripts, we omit
	// the subtag if it is equal to the Suppress-Script entry in the
	// IANA language subtag registry for IETF BCP 47.
	//
	// For example, Microsoft states that its language code 0x041A is
	// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
	// and not 'hr-HR' because Croatia is the default country for Croatian,
	// according to Unicode CLDR. As another example, Microsoft states
	// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
	// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
	// for the Croatian language, according to IANA.
	//
	// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
	// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
	var windowsLanguages = {
	    0x0436: 'af',
	    0x041C: 'sq',
	    0x0484: 'gsw',
	    0x045E: 'am',
	    0x1401: 'ar-DZ',
	    0x3C01: 'ar-BH',
	    0x0C01: 'ar',
	    0x0801: 'ar-IQ',
	    0x2C01: 'ar-JO',
	    0x3401: 'ar-KW',
	    0x3001: 'ar-LB',
	    0x1001: 'ar-LY',
	    0x1801: 'ary',
	    0x2001: 'ar-OM',
	    0x4001: 'ar-QA',
	    0x0401: 'ar-SA',
	    0x2801: 'ar-SY',
	    0x1C01: 'aeb',
	    0x3801: 'ar-AE',
	    0x2401: 'ar-YE',
	    0x042B: 'hy',
	    0x044D: 'as',
	    0x082C: 'az-Cyrl',
	    0x042C: 'az',
	    0x046D: 'ba',
	    0x042D: 'eu',
	    0x0423: 'be',
	    0x0845: 'bn',
	    0x0445: 'bn-IN',
	    0x201A: 'bs-Cyrl',
	    0x141A: 'bs',
	    0x047E: 'br',
	    0x0402: 'bg',
	    0x0403: 'ca',
	    0x0C04: 'zh-HK',
	    0x1404: 'zh-MO',
	    0x0804: 'zh',
	    0x1004: 'zh-SG',
	    0x0404: 'zh-TW',
	    0x0483: 'co',
	    0x041A: 'hr',
	    0x101A: 'hr-BA',
	    0x0405: 'cs',
	    0x0406: 'da',
	    0x048C: 'prs',
	    0x0465: 'dv',
	    0x0813: 'nl-BE',
	    0x0413: 'nl',
	    0x0C09: 'en-AU',
	    0x2809: 'en-BZ',
	    0x1009: 'en-CA',
	    0x2409: 'en-029',
	    0x4009: 'en-IN',
	    0x1809: 'en-IE',
	    0x2009: 'en-JM',
	    0x4409: 'en-MY',
	    0x1409: 'en-NZ',
	    0x3409: 'en-PH',
	    0x4809: 'en-SG',
	    0x1C09: 'en-ZA',
	    0x2C09: 'en-TT',
	    0x0809: 'en-GB',
	    0x0409: 'en',
	    0x3009: 'en-ZW',
	    0x0425: 'et',
	    0x0438: 'fo',
	    0x0464: 'fil',
	    0x040B: 'fi',
	    0x080C: 'fr-BE',
	    0x0C0C: 'fr-CA',
	    0x040C: 'fr',
	    0x140C: 'fr-LU',
	    0x180C: 'fr-MC',
	    0x100C: 'fr-CH',
	    0x0462: 'fy',
	    0x0456: 'gl',
	    0x0437: 'ka',
	    0x0C07: 'de-AT',
	    0x0407: 'de',
	    0x1407: 'de-LI',
	    0x1007: 'de-LU',
	    0x0807: 'de-CH',
	    0x0408: 'el',
	    0x046F: 'kl',
	    0x0447: 'gu',
	    0x0468: 'ha',
	    0x040D: 'he',
	    0x0439: 'hi',
	    0x040E: 'hu',
	    0x040F: 'is',
	    0x0470: 'ig',
	    0x0421: 'id',
	    0x045D: 'iu',
	    0x085D: 'iu-Latn',
	    0x083C: 'ga',
	    0x0434: 'xh',
	    0x0435: 'zu',
	    0x0410: 'it',
	    0x0810: 'it-CH',
	    0x0411: 'ja',
	    0x044B: 'kn',
	    0x043F: 'kk',
	    0x0453: 'km',
	    0x0486: 'quc',
	    0x0487: 'rw',
	    0x0441: 'sw',
	    0x0457: 'kok',
	    0x0412: 'ko',
	    0x0440: 'ky',
	    0x0454: 'lo',
	    0x0426: 'lv',
	    0x0427: 'lt',
	    0x082E: 'dsb',
	    0x046E: 'lb',
	    0x042F: 'mk',
	    0x083E: 'ms-BN',
	    0x043E: 'ms',
	    0x044C: 'ml',
	    0x043A: 'mt',
	    0x0481: 'mi',
	    0x047A: 'arn',
	    0x044E: 'mr',
	    0x047C: 'moh',
	    0x0450: 'mn',
	    0x0850: 'mn-CN',
	    0x0461: 'ne',
	    0x0414: 'nb',
	    0x0814: 'nn',
	    0x0482: 'oc',
	    0x0448: 'or',
	    0x0463: 'ps',
	    0x0415: 'pl',
	    0x0416: 'pt',
	    0x0816: 'pt-PT',
	    0x0446: 'pa',
	    0x046B: 'qu-BO',
	    0x086B: 'qu-EC',
	    0x0C6B: 'qu',
	    0x0418: 'ro',
	    0x0417: 'rm',
	    0x0419: 'ru',
	    0x243B: 'smn',
	    0x103B: 'smj-NO',
	    0x143B: 'smj',
	    0x0C3B: 'se-FI',
	    0x043B: 'se',
	    0x083B: 'se-SE',
	    0x203B: 'sms',
	    0x183B: 'sma-NO',
	    0x1C3B: 'sms',
	    0x044F: 'sa',
	    0x1C1A: 'sr-Cyrl-BA',
	    0x0C1A: 'sr',
	    0x181A: 'sr-Latn-BA',
	    0x081A: 'sr-Latn',
	    0x046C: 'nso',
	    0x0432: 'tn',
	    0x045B: 'si',
	    0x041B: 'sk',
	    0x0424: 'sl',
	    0x2C0A: 'es-AR',
	    0x400A: 'es-BO',
	    0x340A: 'es-CL',
	    0x240A: 'es-CO',
	    0x140A: 'es-CR',
	    0x1C0A: 'es-DO',
	    0x300A: 'es-EC',
	    0x440A: 'es-SV',
	    0x100A: 'es-GT',
	    0x480A: 'es-HN',
	    0x080A: 'es-MX',
	    0x4C0A: 'es-NI',
	    0x180A: 'es-PA',
	    0x3C0A: 'es-PY',
	    0x280A: 'es-PE',
	    0x500A: 'es-PR',

	    // Microsoft has defined two different language codes for
	    // “Spanish with modern sorting” and “Spanish with traditional
	    // sorting”. This makes sense for collation APIs, and it would be
	    // possible to express this in BCP 47 language tags via Unicode
	    // extensions (eg., es-u-co-trad is Spanish with traditional
	    // sorting). However, for storing names in fonts, the distinction
	    // does not make sense, so we give “es” in both cases.
	    0x0C0A: 'es',
	    0x040A: 'es',

	    0x540A: 'es-US',
	    0x380A: 'es-UY',
	    0x200A: 'es-VE',
	    0x081D: 'sv-FI',
	    0x041D: 'sv',
	    0x045A: 'syr',
	    0x0428: 'tg',
	    0x085F: 'tzm',
	    0x0449: 'ta',
	    0x0444: 'tt',
	    0x044A: 'te',
	    0x041E: 'th',
	    0x0451: 'bo',
	    0x041F: 'tr',
	    0x0442: 'tk',
	    0x0480: 'ug',
	    0x0422: 'uk',
	    0x042E: 'hsb',
	    0x0420: 'ur',
	    0x0843: 'uz-Cyrl',
	    0x0443: 'uz',
	    0x042A: 'vi',
	    0x0452: 'cy',
	    0x0488: 'wo',
	    0x0485: 'sah',
	    0x0478: 'ii',
	    0x046A: 'yo'
	};

	// Returns a IETF BCP 47 language code, for example 'zh-Hant'
	// for 'Chinese in the traditional script'.
	function getLanguageCode(platformID, languageID, ltag) {
	    switch (platformID) {
	        case 0:  // Unicode
	            if (languageID === 0xFFFF) {
	                return 'und';
	            } else if (ltag) {
	                return ltag[languageID];
	            }

	            break;

	        case 1:  // Macintosh
	            return macLanguages[languageID];

	        case 3:  // Windows
	            return windowsLanguages[languageID];
	    }

	    return undefined;
	}

	var utf16 = 'utf-16';

	// MacOS script ID → encoding. This table stores the default case,
	// which can be overridden by macLanguageEncodings.
	var macScriptEncodings = {
	    0: 'macintosh',           // smRoman
	    1: 'x-mac-japanese',      // smJapanese
	    2: 'x-mac-chinesetrad',   // smTradChinese
	    3: 'x-mac-korean',        // smKorean
	    6: 'x-mac-greek',         // smGreek
	    7: 'x-mac-cyrillic',      // smCyrillic
	    9: 'x-mac-devanagai',     // smDevanagari
	    10: 'x-mac-gurmukhi',     // smGurmukhi
	    11: 'x-mac-gujarati',     // smGujarati
	    12: 'x-mac-oriya',        // smOriya
	    13: 'x-mac-bengali',      // smBengali
	    14: 'x-mac-tamil',        // smTamil
	    15: 'x-mac-telugu',       // smTelugu
	    16: 'x-mac-kannada',      // smKannada
	    17: 'x-mac-malayalam',    // smMalayalam
	    18: 'x-mac-sinhalese',    // smSinhalese
	    19: 'x-mac-burmese',      // smBurmese
	    20: 'x-mac-khmer',        // smKhmer
	    21: 'x-mac-thai',         // smThai
	    22: 'x-mac-lao',          // smLao
	    23: 'x-mac-georgian',     // smGeorgian
	    24: 'x-mac-armenian',     // smArmenian
	    25: 'x-mac-chinesesimp',  // smSimpChinese
	    26: 'x-mac-tibetan',      // smTibetan
	    27: 'x-mac-mongolian',    // smMongolian
	    28: 'x-mac-ethiopic',     // smEthiopic
	    29: 'x-mac-ce',           // smCentralEuroRoman
	    30: 'x-mac-vietnamese',   // smVietnamese
	    31: 'x-mac-extarabic'     // smExtArabic
	};

	// MacOS language ID → encoding. This table stores the exceptional
	// cases, which override macScriptEncodings. For writing MacOS naming
	// tables, we need to emit a MacOS script ID. Therefore, we cannot
	// merge macScriptEncodings into macLanguageEncodings.
	//
	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
	var macLanguageEncodings = {
	    15: 'x-mac-icelandic',    // langIcelandic
	    17: 'x-mac-turkish',      // langTurkish
	    18: 'x-mac-croatian',     // langCroatian
	    24: 'x-mac-ce',           // langLithuanian
	    25: 'x-mac-ce',           // langPolish
	    26: 'x-mac-ce',           // langHungarian
	    27: 'x-mac-ce',           // langEstonian
	    28: 'x-mac-ce',           // langLatvian
	    30: 'x-mac-icelandic',    // langFaroese
	    37: 'x-mac-romanian',     // langRomanian
	    38: 'x-mac-ce',           // langCzech
	    39: 'x-mac-ce',           // langSlovak
	    40: 'x-mac-ce',           // langSlovenian
	    143: 'x-mac-inuit',       // langInuktitut
	    146: 'x-mac-gaelic'       // langIrishGaelicScript
	};

	function getEncoding(platformID, encodingID, languageID) {
	    switch (platformID) {
	        case 0:  // Unicode
	            return utf16;

	        case 1:  // Apple Macintosh
	            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

	        case 3:  // Microsoft Windows
	            if (encodingID === 1 || encodingID === 10) {
	                return utf16;
	            }

	            break;
	    }

	    return undefined;
	}

	// Parse the naming `name` table.
	// FIXME: Format 1 additional fields are not supported yet.
	// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
	function parseNameTable(data, start, ltag) {
	    var name = {};
	    var p = new parse.Parser(data, start);
	    var format = p.parseUShort();
	    var count = p.parseUShort();
	    var stringOffset = p.offset + p.parseUShort();
	    for (var i = 0; i < count; i++) {
	        var platformID = p.parseUShort();
	        var encodingID = p.parseUShort();
	        var languageID = p.parseUShort();
	        var nameID = p.parseUShort();
	        var property = nameTableNames[nameID] || nameID;
	        var byteLength = p.parseUShort();
	        var offset = p.parseUShort();
	        var language = getLanguageCode(platformID, languageID, ltag);
	        var encoding = getEncoding(platformID, encodingID, languageID);
	        if (encoding !== undefined && language !== undefined) {
	            var text = (void 0);
	            if (encoding === utf16) {
	                text = decode.UTF16(data, stringOffset + offset, byteLength);
	            } else {
	                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
	            }

	            if (text) {
	                var translations = name[property];
	                if (translations === undefined) {
	                    translations = name[property] = {};
	                }

	                translations[language] = text;
	            }
	        }
	    }

	    var langTagCount = 0;
	    if (format === 1) {
	        // FIXME: Also handle Microsoft's 'name' table 1.
	        langTagCount = p.parseUShort();
	    }

	    return name;
	}

	// {23: 'foo'} → {'foo': 23}
	// ['bar', 'baz'] → {'bar': 0, 'baz': 1}
	function reverseDict(dict) {
	    var result = {};
	    for (var key in dict) {
	        result[dict[key]] = parseInt(key);
	    }

	    return result;
	}

	function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
	    return new table.Record('NameRecord', [
	        {name: 'platformID', type: 'USHORT', value: platformID},
	        {name: 'encodingID', type: 'USHORT', value: encodingID},
	        {name: 'languageID', type: 'USHORT', value: languageID},
	        {name: 'nameID', type: 'USHORT', value: nameID},
	        {name: 'length', type: 'USHORT', value: length},
	        {name: 'offset', type: 'USHORT', value: offset}
	    ]);
	}

	// Finds the position of needle in haystack, or -1 if not there.
	// Like String.indexOf(), but for arrays.
	function findSubArray(needle, haystack) {
	    var needleLength = needle.length;
	    var limit = haystack.length - needleLength + 1;

	    loop:
	    for (var pos = 0; pos < limit; pos++) {
	        for (; pos < limit; pos++) {
	            for (var k = 0; k < needleLength; k++) {
	                if (haystack[pos + k] !== needle[k]) {
	                    continue loop;
	                }
	            }

	            return pos;
	        }
	    }

	    return -1;
	}

	function addStringToPool(s, pool) {
	    var offset = findSubArray(s, pool);
	    if (offset < 0) {
	        offset = pool.length;
	        var i = 0;
	        var len = s.length;
	        for (; i < len; ++i) {
	            pool.push(s[i]);
	        }

	    }

	    return offset;
	}

	function makeNameTable(names, ltag) {
	    var nameID;
	    var nameIDs = [];

	    var namesWithNumericKeys = {};
	    var nameTableIds = reverseDict(nameTableNames);
	    for (var key in names) {
	        var id = nameTableIds[key];
	        if (id === undefined) {
	            id = key;
	        }

	        nameID = parseInt(id);

	        if (isNaN(nameID)) {
	            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
	        }

	        namesWithNumericKeys[nameID] = names[key];
	        nameIDs.push(nameID);
	    }

	    var macLanguageIds = reverseDict(macLanguages);
	    var windowsLanguageIds = reverseDict(windowsLanguages);

	    var nameRecords = [];
	    var stringPool = [];

	    for (var i = 0; i < nameIDs.length; i++) {
	        nameID = nameIDs[i];
	        var translations = namesWithNumericKeys[nameID];
	        for (var lang in translations) {
	            var text = translations[lang];

	            // For MacOS, we try to emit the name in the form that was introduced
	            // in the initial version of the TrueType spec (in the late 1980s).
	            // However, this can fail for various reasons: the requested BCP 47
	            // language code might not have an old-style Mac equivalent;
	            // we might not have a codec for the needed character encoding;
	            // or the name might contain characters that cannot be expressed
	            // in the old-style Macintosh encoding. In case of failure, we emit
	            // the name in a more modern fashion (Unicode encoding with BCP 47
	            // language tags) that is recognized by MacOS 10.5, released in 2009.
	            // If fonts were only read by operating systems, we could simply
	            // emit all names in the modern form; this would be much easier.
	            // However, there are many applications and libraries that read
	            // 'name' tables directly, and these will usually only recognize
	            // the ancient form (silently skipping the unrecognized names).
	            var macPlatform = 1;  // Macintosh
	            var macLanguage = macLanguageIds[lang];
	            var macScript = macLanguageToScript[macLanguage];
	            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
	            var macName = encode.MACSTRING(text, macEncoding);
	            if (macName === undefined) {
	                macPlatform = 0;  // Unicode
	                macLanguage = ltag.indexOf(lang);
	                if (macLanguage < 0) {
	                    macLanguage = ltag.length;
	                    ltag.push(lang);
	                }

	                macScript = 4;  // Unicode 2.0 and later
	                macName = encode.UTF16(text);
	            }

	            var macNameOffset = addStringToPool(macName, stringPool);
	            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
	                                            nameID, macName.length, macNameOffset));

	            var winLanguage = windowsLanguageIds[lang];
	            if (winLanguage !== undefined) {
	                var winName = encode.UTF16(text);
	                var winNameOffset = addStringToPool(winName, stringPool);
	                nameRecords.push(makeNameRecord(3, 1, winLanguage,
	                                                nameID, winName.length, winNameOffset));
	            }
	        }
	    }

	    nameRecords.sort(function(a, b) {
	        return ((a.platformID - b.platformID) ||
	                (a.encodingID - b.encodingID) ||
	                (a.languageID - b.languageID) ||
	                (a.nameID - b.nameID));
	    });

	    var t = new table.Table('name', [
	        {name: 'format', type: 'USHORT', value: 0},
	        {name: 'count', type: 'USHORT', value: nameRecords.length},
	        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
	    ]);

	    for (var r = 0; r < nameRecords.length; r++) {
	        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
	    }

	    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
	    return t;
	}

	var _name = { parse: parseNameTable, make: makeNameTable };

	// The `OS/2` table contains metrics required in OpenType fonts.

	var unicodeRanges = [
	    {begin: 0x0000, end: 0x007F}, // Basic Latin
	    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
	    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
	    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
	    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
	    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
	    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
	    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
	    {begin: 0x2C80, end: 0x2CFF}, // Coptic
	    {begin: 0x0400, end: 0x04FF}, // Cyrillic
	    {begin: 0x0530, end: 0x058F}, // Armenian
	    {begin: 0x0590, end: 0x05FF}, // Hebrew
	    {begin: 0xA500, end: 0xA63F}, // Vai
	    {begin: 0x0600, end: 0x06FF}, // Arabic
	    {begin: 0x07C0, end: 0x07FF}, // NKo
	    {begin: 0x0900, end: 0x097F}, // Devanagari
	    {begin: 0x0980, end: 0x09FF}, // Bengali
	    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
	    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
	    {begin: 0x0B00, end: 0x0B7F}, // Oriya
	    {begin: 0x0B80, end: 0x0BFF}, // Tamil
	    {begin: 0x0C00, end: 0x0C7F}, // Telugu
	    {begin: 0x0C80, end: 0x0CFF}, // Kannada
	    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
	    {begin: 0x0E00, end: 0x0E7F}, // Thai
	    {begin: 0x0E80, end: 0x0EFF}, // Lao
	    {begin: 0x10A0, end: 0x10FF}, // Georgian
	    {begin: 0x1B00, end: 0x1B7F}, // Balinese
	    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
	    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
	    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
	    {begin: 0x2000, end: 0x206F}, // General Punctuation
	    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
	    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
	    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
	    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
	    {begin: 0x2150, end: 0x218F}, // Number Forms
	    {begin: 0x2190, end: 0x21FF}, // Arrows
	    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
	    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
	    {begin: 0x2400, end: 0x243F}, // Control Pictures
	    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
	    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
	    {begin: 0x2500, end: 0x257F}, // Box Drawing
	    {begin: 0x2580, end: 0x259F}, // Block Elements
	    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
	    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
	    {begin: 0x2700, end: 0x27BF}, // Dingbats
	    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
	    {begin: 0x3040, end: 0x309F}, // Hiragana
	    {begin: 0x30A0, end: 0x30FF}, // Katakana
	    {begin: 0x3100, end: 0x312F}, // Bopomofo
	    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
	    {begin: 0xA840, end: 0xA87F}, // Phags-pa
	    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
	    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
	    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
	    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
	    {begin: 0x10900, end: 0x1091F}, // Phoenicia
	    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
	    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
	    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
	    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
	    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
	    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
	    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
	    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
	    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
	    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
	    {begin: 0xFFF0, end: 0xFFFF}, // Specials
	    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
	    {begin: 0x0700, end: 0x074F}, // Syriac
	    {begin: 0x0780, end: 0x07BF}, // Thaana
	    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
	    {begin: 0x1000, end: 0x109F}, // Myanmar
	    {begin: 0x1200, end: 0x137F}, // Ethiopic
	    {begin: 0x13A0, end: 0x13FF}, // Cherokee
	    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
	    {begin: 0x1680, end: 0x169F}, // Ogham
	    {begin: 0x16A0, end: 0x16FF}, // Runic
	    {begin: 0x1780, end: 0x17FF}, // Khmer
	    {begin: 0x1800, end: 0x18AF}, // Mongolian
	    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
	    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
	    {begin: 0x1700, end: 0x171F}, // Tagalog
	    {begin: 0x10300, end: 0x1032F}, // Old Italic
	    {begin: 0x10330, end: 0x1034F}, // Gothic
	    {begin: 0x10400, end: 0x1044F}, // Deseret
	    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
	    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
	    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
	    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
	    {begin: 0xE0000, end: 0xE007F}, // Tags
	    {begin: 0x1900, end: 0x194F}, // Limbu
	    {begin: 0x1950, end: 0x197F}, // Tai Le
	    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
	    {begin: 0x1A00, end: 0x1A1F}, // Buginese
	    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
	    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
	    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
	    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
	    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
	    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
	    {begin: 0x10380, end: 0x1039F}, // Ugaritic
	    {begin: 0x103A0, end: 0x103DF}, // Old Persian
	    {begin: 0x10450, end: 0x1047F}, // Shavian
	    {begin: 0x10480, end: 0x104AF}, // Osmanya
	    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
	    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
	    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
	    {begin: 0x12000, end: 0x123FF}, // Cuneiform
	    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
	    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
	    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
	    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
	    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
	    {begin: 0xA900, end: 0xA92F}, // Kayah Li
	    {begin: 0xA930, end: 0xA95F}, // Rejang
	    {begin: 0xAA00, end: 0xAA5F}, // Cham
	    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
	    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
	    {begin: 0x102A0, end: 0x102DF}, // Carian
	    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
	];

	function getUnicodeRange(unicode) {
	    for (var i = 0; i < unicodeRanges.length; i += 1) {
	        var range = unicodeRanges[i];
	        if (unicode >= range.begin && unicode < range.end) {
	            return i;
	        }
	    }

	    return -1;
	}

	// Parse the OS/2 and Windows metrics `OS/2` table
	function parseOS2Table(data, start) {
	    var os2 = {};
	    var p = new parse.Parser(data, start);
	    os2.version = p.parseUShort();
	    os2.xAvgCharWidth = p.parseShort();
	    os2.usWeightClass = p.parseUShort();
	    os2.usWidthClass = p.parseUShort();
	    os2.fsType = p.parseUShort();
	    os2.ySubscriptXSize = p.parseShort();
	    os2.ySubscriptYSize = p.parseShort();
	    os2.ySubscriptXOffset = p.parseShort();
	    os2.ySubscriptYOffset = p.parseShort();
	    os2.ySuperscriptXSize = p.parseShort();
	    os2.ySuperscriptYSize = p.parseShort();
	    os2.ySuperscriptXOffset = p.parseShort();
	    os2.ySuperscriptYOffset = p.parseShort();
	    os2.yStrikeoutSize = p.parseShort();
	    os2.yStrikeoutPosition = p.parseShort();
	    os2.sFamilyClass = p.parseShort();
	    os2.panose = [];
	    for (var i = 0; i < 10; i++) {
	        os2.panose[i] = p.parseByte();
	    }

	    os2.ulUnicodeRange1 = p.parseULong();
	    os2.ulUnicodeRange2 = p.parseULong();
	    os2.ulUnicodeRange3 = p.parseULong();
	    os2.ulUnicodeRange4 = p.parseULong();
	    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
	    os2.fsSelection = p.parseUShort();
	    os2.usFirstCharIndex = p.parseUShort();
	    os2.usLastCharIndex = p.parseUShort();
	    os2.sTypoAscender = p.parseShort();
	    os2.sTypoDescender = p.parseShort();
	    os2.sTypoLineGap = p.parseShort();
	    os2.usWinAscent = p.parseUShort();
	    os2.usWinDescent = p.parseUShort();
	    if (os2.version >= 1) {
	        os2.ulCodePageRange1 = p.parseULong();
	        os2.ulCodePageRange2 = p.parseULong();
	    }

	    if (os2.version >= 2) {
	        os2.sxHeight = p.parseShort();
	        os2.sCapHeight = p.parseShort();
	        os2.usDefaultChar = p.parseUShort();
	        os2.usBreakChar = p.parseUShort();
	        os2.usMaxContent = p.parseUShort();
	    }

	    return os2;
	}

	function makeOS2Table(options) {
	    return new table.Table('OS/2', [
	        {name: 'version', type: 'USHORT', value: 0x0003},
	        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
	        {name: 'usWeightClass', type: 'USHORT', value: 0},
	        {name: 'usWidthClass', type: 'USHORT', value: 0},
	        {name: 'fsType', type: 'USHORT', value: 0},
	        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
	        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
	        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
	        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
	        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
	        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
	        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
	        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
	        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
	        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
	        {name: 'sFamilyClass', type: 'SHORT', value: 0},
	        {name: 'bFamilyType', type: 'BYTE', value: 0},
	        {name: 'bSerifStyle', type: 'BYTE', value: 0},
	        {name: 'bWeight', type: 'BYTE', value: 0},
	        {name: 'bProportion', type: 'BYTE', value: 0},
	        {name: 'bContrast', type: 'BYTE', value: 0},
	        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
	        {name: 'bArmStyle', type: 'BYTE', value: 0},
	        {name: 'bLetterform', type: 'BYTE', value: 0},
	        {name: 'bMidline', type: 'BYTE', value: 0},
	        {name: 'bXHeight', type: 'BYTE', value: 0},
	        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
	        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
	        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
	        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
	        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
	        {name: 'fsSelection', type: 'USHORT', value: 0},
	        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
	        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
	        {name: 'sTypoAscender', type: 'SHORT', value: 0},
	        {name: 'sTypoDescender', type: 'SHORT', value: 0},
	        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
	        {name: 'usWinAscent', type: 'USHORT', value: 0},
	        {name: 'usWinDescent', type: 'USHORT', value: 0},
	        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
	        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
	        {name: 'sxHeight', type: 'SHORT', value: 0},
	        {name: 'sCapHeight', type: 'SHORT', value: 0},
	        {name: 'usDefaultChar', type: 'USHORT', value: 0},
	        {name: 'usBreakChar', type: 'USHORT', value: 0},
	        {name: 'usMaxContext', type: 'USHORT', value: 0}
	    ], options);
	}

	var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

	// The `post` table stores additional PostScript information, such as glyph names.

	// Parse the PostScript `post` table
	function parsePostTable(data, start) {
	    var post = {};
	    var p = new parse.Parser(data, start);
	    post.version = p.parseVersion();
	    post.italicAngle = p.parseFixed();
	    post.underlinePosition = p.parseShort();
	    post.underlineThickness = p.parseShort();
	    post.isFixedPitch = p.parseULong();
	    post.minMemType42 = p.parseULong();
	    post.maxMemType42 = p.parseULong();
	    post.minMemType1 = p.parseULong();
	    post.maxMemType1 = p.parseULong();
	    switch (post.version) {
	        case 1:
	            post.names = standardNames.slice();
	            break;
	        case 2:
	            post.numberOfGlyphs = p.parseUShort();
	            post.glyphNameIndex = new Array(post.numberOfGlyphs);
	            for (var i = 0; i < post.numberOfGlyphs; i++) {
	                post.glyphNameIndex[i] = p.parseUShort();
	            }

	            post.names = [];
	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
	                if (post.glyphNameIndex[i$1] >= standardNames.length) {
	                    var nameLength = p.parseChar();
	                    post.names.push(p.parseString(nameLength));
	                }
	            }

	            break;
	        case 2.5:
	            post.numberOfGlyphs = p.parseUShort();
	            post.offset = new Array(post.numberOfGlyphs);
	            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
	                post.offset[i$2] = p.parseChar();
	            }

	            break;
	    }
	    return post;
	}

	function makePostTable() {
	    return new table.Table('post', [
	        {name: 'version', type: 'FIXED', value: 0x00030000},
	        {name: 'italicAngle', type: 'FIXED', value: 0},
	        {name: 'underlinePosition', type: 'FWORD', value: 0},
	        {name: 'underlineThickness', type: 'FWORD', value: 0},
	        {name: 'isFixedPitch', type: 'ULONG', value: 0},
	        {name: 'minMemType42', type: 'ULONG', value: 0},
	        {name: 'maxMemType42', type: 'ULONG', value: 0},
	        {name: 'minMemType1', type: 'ULONG', value: 0},
	        {name: 'maxMemType1', type: 'ULONG', value: 0}
	    ]);
	}

	var post = { parse: parsePostTable, make: makePostTable };

	// The `GSUB` table contains ligatures, among other things.

	var subtableParsers = new Array(9);         // subtableParsers[0] is unused

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
	subtableParsers[1] = function parseLookup1() {
	    var start = this.offset + this.relativeOffset;
	    var substFormat = this.parseUShort();
	    if (substFormat === 1) {
	        return {
	            substFormat: 1,
	            coverage: this.parsePointer(Parser.coverage),
	            deltaGlyphId: this.parseUShort()
	        };
	    } else if (substFormat === 2) {
	        return {
	            substFormat: 2,
	            coverage: this.parsePointer(Parser.coverage),
	            substitute: this.parseOffset16List()
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
	subtableParsers[2] = function parseLookup2() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        sequences: this.parseListOfLists()
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
	subtableParsers[3] = function parseLookup3() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        alternateSets: this.parseListOfLists()
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
	subtableParsers[4] = function parseLookup4() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        ligatureSets: this.parseListOfLists(function() {
	            return {
	                ligGlyph: this.parseUShort(),
	                components: this.parseUShortList(this.parseUShort() - 1)
	            };
	        })
	    };
	};

	var lookupRecordDesc = {
	    sequenceIndex: Parser.uShort,
	    lookupListIndex: Parser.uShort
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
	subtableParsers[5] = function parseLookup5() {
	    var start = this.offset + this.relativeOffset;
	    var substFormat = this.parseUShort();

	    if (substFormat === 1) {
	        return {
	            substFormat: substFormat,
	            coverage: this.parsePointer(Parser.coverage),
	            ruleSets: this.parseListOfLists(function() {
	                var glyphCount = this.parseUShort();
	                var substCount = this.parseUShort();
	                return {
	                    input: this.parseUShortList(glyphCount - 1),
	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 2) {
	        return {
	            substFormat: substFormat,
	            coverage: this.parsePointer(Parser.coverage),
	            classDef: this.parsePointer(Parser.classDef),
	            classSets: this.parseListOfLists(function() {
	                var glyphCount = this.parseUShort();
	                var substCount = this.parseUShort();
	                return {
	                    classes: this.parseUShortList(glyphCount - 1),
	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 3) {
	        var glyphCount = this.parseUShort();
	        var substCount = this.parseUShort();
	        return {
	            substFormat: substFormat,
	            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
	            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
	subtableParsers[6] = function parseLookup6() {
	    var start = this.offset + this.relativeOffset;
	    var substFormat = this.parseUShort();
	    if (substFormat === 1) {
	        return {
	            substFormat: 1,
	            coverage: this.parsePointer(Parser.coverage),
	            chainRuleSets: this.parseListOfLists(function() {
	                return {
	                    backtrack: this.parseUShortList(),
	                    input: this.parseUShortList(this.parseShort() - 1),
	                    lookahead: this.parseUShortList(),
	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 2) {
	        return {
	            substFormat: 2,
	            coverage: this.parsePointer(Parser.coverage),
	            backtrackClassDef: this.parsePointer(Parser.classDef),
	            inputClassDef: this.parsePointer(Parser.classDef),
	            lookaheadClassDef: this.parsePointer(Parser.classDef),
	            chainClassSet: this.parseListOfLists(function() {
	                return {
	                    backtrack: this.parseUShortList(),
	                    input: this.parseUShortList(this.parseShort() - 1),
	                    lookahead: this.parseUShortList(),
	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
	                };
	            })
	        };
	    } else if (substFormat === 3) {
	        return {
	            substFormat: 3,
	            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	            lookupRecords: this.parseRecordList(lookupRecordDesc)
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
	subtableParsers[7] = function parseLookup7() {
	    // Extension Substitution subtable
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
	    var extensionLookupType = this.parseUShort();
	    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
	    return {
	        substFormat: 1,
	        lookupType: extensionLookupType,
	        extension: subtableParsers[extensionLookupType].call(extensionParser)
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
	subtableParsers[8] = function parseLookup8() {
	    var substFormat = this.parseUShort();
	    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
	    return {
	        substFormat: substFormat,
	        coverage: this.parsePointer(Parser.coverage),
	        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
	        substitutes: this.parseUShortList()
	    };
	};

	// https://www.microsoft.com/typography/OTSPEC/gsub.htm
	function parseGsubTable(data, start) {
	    start = start || 0;
	    var p = new Parser(data, start);
	    var tableVersion = p.parseVersion(1);
	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
	    if (tableVersion === 1) {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers)
	        };
	    } else {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers),
	            variations: p.parseFeatureVariationsList()
	        };
	    }

	}

	// GSUB Writing //////////////////////////////////////////////
	var subtableMakers = new Array(9);

	subtableMakers[1] = function makeLookup1(subtable) {
	    if (subtable.substFormat === 1) {
	        return new table.Table('substitutionTable', [
	            {name: 'substFormat', type: 'USHORT', value: 1},
	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
	            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
	        ]);
	    } else {
	        return new table.Table('substitutionTable', [
	            {name: 'substFormat', type: 'USHORT', value: 2},
	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	        ].concat(table.ushortList('substitute', subtable.substitute)));
	    }
	    check.fail('Lookup type 1 substFormat must be 1 or 2.');
	};

	subtableMakers[3] = function makeLookup3(subtable) {
	    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
	    return new table.Table('substitutionTable', [
	        {name: 'substFormat', type: 'USHORT', value: 1},
	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
	        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
	    })));
	};

	subtableMakers[4] = function makeLookup4(subtable) {
	    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
	    return new table.Table('substitutionTable', [
	        {name: 'substFormat', type: 'USHORT', value: 1},
	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
	    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
	        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
	            return new table.Table('ligatureTable',
	                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
	                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
	            );
	        }));
	    })));
	};

	function makeGsubTable(gsub) {
	    return new table.Table('GSUB', [
	        {name: 'version', type: 'ULONG', value: 0x10000},
	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
	    ]);
	}

	var gsub = { parse: parseGsubTable, make: makeGsubTable };

	// The `GPOS` table contains kerning pairs, among other things.

	// Parse the metadata `meta` table.
	// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
	function parseMetaTable(data, start) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseULong();
	    check.argument(tableVersion === 1, 'Unsupported META table version.');
	    p.parseULong(); // flags - currently unused and set to 0
	    p.parseULong(); // tableOffset
	    var numDataMaps = p.parseULong();

	    var tags = {};
	    for (var i = 0; i < numDataMaps; i++) {
	        var tag = p.parseTag();
	        var dataOffset = p.parseULong();
	        var dataLength = p.parseULong();
	        var text = decode.UTF8(data, start + dataOffset, dataLength);

	        tags[tag] = text;
	    }
	    return tags;
	}

	function makeMetaTable(tags) {
	    var numTags = Object.keys(tags).length;
	    var stringPool = '';
	    var stringPoolOffset = 16 + numTags * 12;

	    var result = new table.Table('meta', [
	        {name: 'version', type: 'ULONG', value: 1},
	        {name: 'flags', type: 'ULONG', value: 0},
	        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
	        {name: 'numTags', type: 'ULONG', value: numTags}
	    ]);

	    for (var tag in tags) {
	        var pos = stringPool.length;
	        stringPool += tags[tag];

	        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
	        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
	        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
	    }

	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

	    return result;
	}

	var meta = { parse: parseMetaTable, make: makeMetaTable };

	// The `sfnt` wrapper provides organization for the tables in the font.

	function log2(v) {
	    return Math.log(v) / Math.log(2) | 0;
	}

	function computeCheckSum(bytes) {
	    while (bytes.length % 4 !== 0) {
	        bytes.push(0);
	    }

	    var sum = 0;
	    for (var i = 0; i < bytes.length; i += 4) {
	        sum += (bytes[i] << 24) +
	            (bytes[i + 1] << 16) +
	            (bytes[i + 2] << 8) +
	            (bytes[i + 3]);
	    }

	    sum %= Math.pow(2, 32);
	    return sum;
	}

	function makeTableRecord(tag, checkSum, offset, length) {
	    return new table.Record('Table Record', [
	        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
	        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
	        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
	        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
	    ]);
	}

	function makeSfntTable(tables) {
	    var sfnt = new table.Table('sfnt', [
	        {name: 'version', type: 'TAG', value: 'OTTO'},
	        {name: 'numTables', type: 'USHORT', value: 0},
	        {name: 'searchRange', type: 'USHORT', value: 0},
	        {name: 'entrySelector', type: 'USHORT', value: 0},
	        {name: 'rangeShift', type: 'USHORT', value: 0}
	    ]);
	    sfnt.tables = tables;
	    sfnt.numTables = tables.length;
	    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
	    sfnt.searchRange = 16 * highestPowerOf2;
	    sfnt.entrySelector = log2(highestPowerOf2);
	    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

	    var recordFields = [];
	    var tableFields = [];

	    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
	    while (offset % 4 !== 0) {
	        offset += 1;
	        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
	    }

	    for (var i = 0; i < tables.length; i += 1) {
	        var t = tables[i];
	        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
	        var tableLength = t.sizeOf();
	        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
	        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
	        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
	        offset += tableLength;
	        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
	        while (offset % 4 !== 0) {
	            offset += 1;
	            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
	        }
	    }

	    // Table records need to be sorted alphabetically.
	    recordFields.sort(function(r1, r2) {
	        if (r1.value.tag > r2.value.tag) {
	            return 1;
	        } else {
	            return -1;
	        }
	    });

	    sfnt.fields = sfnt.fields.concat(recordFields);
	    sfnt.fields = sfnt.fields.concat(tableFields);
	    return sfnt;
	}

	// Get the metrics for a character. If the string has more than one character
	// this function returns metrics for the first available character.
	// You can provide optional fallback metrics if no characters are available.
	function metricsForChar(font, chars, notFoundMetrics) {
	    for (var i = 0; i < chars.length; i += 1) {
	        var glyphIndex = font.charToGlyphIndex(chars[i]);
	        if (glyphIndex > 0) {
	            var glyph = font.glyphs.get(glyphIndex);
	            return glyph.getMetrics();
	        }
	    }

	    return notFoundMetrics;
	}

	function average(vs) {
	    var sum = 0;
	    for (var i = 0; i < vs.length; i += 1) {
	        sum += vs[i];
	    }

	    return sum / vs.length;
	}

	// Convert the font object to a SFNT data structure.
	// This structure contains all the necessary tables and metadata to create a binary OTF file.
	function fontToSfntTable(font) {
	    var xMins = [];
	    var yMins = [];
	    var xMaxs = [];
	    var yMaxs = [];
	    var advanceWidths = [];
	    var leftSideBearings = [];
	    var rightSideBearings = [];
	    var firstCharIndex;
	    var lastCharIndex = 0;
	    var ulUnicodeRange1 = 0;
	    var ulUnicodeRange2 = 0;
	    var ulUnicodeRange3 = 0;
	    var ulUnicodeRange4 = 0;

	    for (var i = 0; i < font.glyphs.length; i += 1) {
	        var glyph = font.glyphs.get(i);
	        var unicode = glyph.unicode | 0;

	        if (isNaN(glyph.advanceWidth)) {
	            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
	        }

	        if (firstCharIndex > unicode || firstCharIndex === undefined) {
	            // ignore .notdef char
	            if (unicode > 0) {
	                firstCharIndex = unicode;
	            }
	        }

	        if (lastCharIndex < unicode) {
	            lastCharIndex = unicode;
	        }

	        var position = os2.getUnicodeRange(unicode);
	        if (position < 32) {
	            ulUnicodeRange1 |= 1 << position;
	        } else if (position < 64) {
	            ulUnicodeRange2 |= 1 << position - 32;
	        } else if (position < 96) {
	            ulUnicodeRange3 |= 1 << position - 64;
	        } else if (position < 123) {
	            ulUnicodeRange4 |= 1 << position - 96;
	        } else {
	            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
	        }
	        // Skip non-important characters.
	        if (glyph.name === '.notdef') { continue; }
	        var metrics = glyph.getMetrics();
	        xMins.push(metrics.xMin);
	        yMins.push(metrics.yMin);
	        xMaxs.push(metrics.xMax);
	        yMaxs.push(metrics.yMax);
	        leftSideBearings.push(metrics.leftSideBearing);
	        rightSideBearings.push(metrics.rightSideBearing);
	        advanceWidths.push(glyph.advanceWidth);
	    }

	    var globals = {
	        xMin: Math.min.apply(null, xMins),
	        yMin: Math.min.apply(null, yMins),
	        xMax: Math.max.apply(null, xMaxs),
	        yMax: Math.max.apply(null, yMaxs),
	        advanceWidthMax: Math.max.apply(null, advanceWidths),
	        advanceWidthAvg: average(advanceWidths),
	        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
	        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
	        minRightSideBearing: Math.min.apply(null, rightSideBearings)
	    };
	    globals.ascender = font.ascender;
	    globals.descender = font.descender;

	    var headTable = head.make({
	        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
	        unitsPerEm: font.unitsPerEm,
	        xMin: globals.xMin,
	        yMin: globals.yMin,
	        xMax: globals.xMax,
	        yMax: globals.yMax,
	        lowestRecPPEM: 3,
	        createdTimestamp: font.createdTimestamp
	    });

	    var hheaTable = hhea.make({
	        ascender: globals.ascender,
	        descender: globals.descender,
	        advanceWidthMax: globals.advanceWidthMax,
	        minLeftSideBearing: globals.minLeftSideBearing,
	        minRightSideBearing: globals.minRightSideBearing,
	        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
	        numberOfHMetrics: font.glyphs.length
	    });

	    var maxpTable = maxp.make(font.glyphs.length);

	    var os2Table = os2.make({
	        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
	        usWeightClass: font.tables.os2.usWeightClass,
	        usWidthClass: font.tables.os2.usWidthClass,
	        usFirstCharIndex: firstCharIndex,
	        usLastCharIndex: lastCharIndex,
	        ulUnicodeRange1: ulUnicodeRange1,
	        ulUnicodeRange2: ulUnicodeRange2,
	        ulUnicodeRange3: ulUnicodeRange3,
	        ulUnicodeRange4: ulUnicodeRange4,
	        fsSelection: font.tables.os2.fsSelection, // REGULAR
	        // See http://typophile.com/node/13081 for more info on vertical metrics.
	        // We get metrics for typical characters (such as "x" for xHeight).
	        // We provide some fallback characters if characters are unavailable: their
	        // ordering was chosen experimentally.
	        sTypoAscender: globals.ascender,
	        sTypoDescender: globals.descender,
	        sTypoLineGap: 0,
	        usWinAscent: globals.yMax,
	        usWinDescent: Math.abs(globals.yMin),
	        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
	        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
	        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
	        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
	        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
	    });

	    var hmtxTable = hmtx.make(font.glyphs);
	    var cmapTable = cmap.make(font.glyphs);

	    var englishFamilyName = font.getEnglishName('fontFamily');
	    var englishStyleName = font.getEnglishName('fontSubfamily');
	    var englishFullName = englishFamilyName + ' ' + englishStyleName;
	    var postScriptName = font.getEnglishName('postScriptName');
	    if (!postScriptName) {
	        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
	    }

	    var names = {};
	    for (var n in font.names) {
	        names[n] = font.names[n];
	    }

	    if (!names.uniqueID) {
	        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
	    }

	    if (!names.postScriptName) {
	        names.postScriptName = {en: postScriptName};
	    }

	    if (!names.preferredFamily) {
	        names.preferredFamily = font.names.fontFamily;
	    }

	    if (!names.preferredSubfamily) {
	        names.preferredSubfamily = font.names.fontSubfamily;
	    }

	    var languageTags = [];
	    var nameTable = _name.make(names, languageTags);
	    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

	    var postTable = post.make();
	    var cffTable = cff.make(font.glyphs, {
	        version: font.getEnglishName('version'),
	        fullName: englishFullName,
	        familyName: englishFamilyName,
	        weightName: englishStyleName,
	        postScriptName: postScriptName,
	        unitsPerEm: font.unitsPerEm,
	        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
	    });

	    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

	    // The order does not matter because makeSfntTable() will sort them.
	    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
	    if (ltagTable) {
	        tables.push(ltagTable);
	    }
	    // Optional tables
	    if (font.tables.gsub) {
	        tables.push(gsub.make(font.tables.gsub));
	    }
	    if (metaTable) {
	        tables.push(metaTable);
	    }

	    var sfntTable = makeSfntTable(tables);

	    // Compute the font's checkSum and store it in head.checkSumAdjustment.
	    var bytes = sfntTable.encode();
	    var checkSum = computeCheckSum(bytes);
	    var tableFields = sfntTable.fields;
	    var checkSumAdjusted = false;
	    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
	        if (tableFields[i$1].name === 'head table') {
	            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
	            checkSumAdjusted = true;
	            break;
	        }
	    }

	    if (!checkSumAdjusted) {
	        throw new Error('Could not find head table with checkSum to adjust.');
	    }

	    return sfntTable;
	}

	var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

	// The Layout object is the prototype of Substitution objects, and provides

	function searchTag(arr, tag) {
	    /* jshint bitwise: false */
	    var imin = 0;
	    var imax = arr.length - 1;
	    while (imin <= imax) {
	        var imid = (imin + imax) >>> 1;
	        var val = arr[imid].tag;
	        if (val === tag) {
	            return imid;
	        } else if (val < tag) {
	            imin = imid + 1;
	        } else { imax = imid - 1; }
	    }
	    // Not found: return -1-insertion point
	    return -imin - 1;
	}

	function binSearch(arr, value) {
	    /* jshint bitwise: false */
	    var imin = 0;
	    var imax = arr.length - 1;
	    while (imin <= imax) {
	        var imid = (imin + imax) >>> 1;
	        var val = arr[imid];
	        if (val === value) {
	            return imid;
	        } else if (val < value) {
	            imin = imid + 1;
	        } else { imax = imid - 1; }
	    }
	    // Not found: return -1-insertion point
	    return -imin - 1;
	}

	// binary search in a list of ranges (coverage, class definition)
	function searchRange(ranges, value) {
	    // jshint bitwise: false
	    var range;
	    var imin = 0;
	    var imax = ranges.length - 1;
	    while (imin <= imax) {
	        var imid = (imin + imax) >>> 1;
	        range = ranges[imid];
	        var start = range.start;
	        if (start === value) {
	            return range;
	        } else if (start < value) {
	            imin = imid + 1;
	        } else { imax = imid - 1; }
	    }
	    if (imin > 0) {
	        range = ranges[imin - 1];
	        if (value > range.end) { return 0; }
	        return range;
	    }
	}

	/**
	 * @exports opentype.Layout
	 * @class
	 */
	function Layout(font, tableName) {
	    this.font = font;
	    this.tableName = tableName;
	}

	Layout.prototype = {

	    /**
	     * Binary search an object by "tag" property
	     * @instance
	     * @function searchTag
	     * @memberof opentype.Layout
	     * @param  {Array} arr
	     * @param  {string} tag
	     * @return {number}
	     */
	    searchTag: searchTag,

	    /**
	     * Binary search in a list of numbers
	     * @instance
	     * @function binSearch
	     * @memberof opentype.Layout
	     * @param  {Array} arr
	     * @param  {number} value
	     * @return {number}
	     */
	    binSearch: binSearch,

	    /**
	     * Get or create the Layout table (GSUB, GPOS etc).
	     * @param  {boolean} create - Whether to create a new one.
	     * @return {Object} The GSUB or GPOS table.
	     */
	    getTable: function(create) {
	        var layout = this.font.tables[this.tableName];
	        if (!layout && create) {
	            layout = this.font.tables[this.tableName] = this.createDefaultTable();
	        }
	        return layout;
	    },

	    /**
	     * Returns all scripts in the substitution table.
	     * @instance
	     * @return {Array}
	     */
	    getScriptNames: function() {
	        var layout = this.getTable();
	        if (!layout) { return []; }
	        return layout.scripts.map(function(script) {
	            return script.tag;
	        });
	    },

	    /**
	     * Returns the best bet for a script name.
	     * Returns 'DFLT' if it exists.
	     * If not, returns 'latn' if it exists.
	     * If neither exist, returns undefined.
	     */
	    getDefaultScriptName: function() {
	        var layout = this.getTable();
	        if (!layout) { return; }
	        var hasLatn = false;
	        for (var i = 0; i < layout.scripts.length; i++) {
	            var name = layout.scripts[i].tag;
	            if (name === 'DFLT') { return name; }
	            if (name === 'latn') { hasLatn = true; }
	        }
	        if (hasLatn) { return 'latn'; }
	    },

	    /**
	     * Returns all LangSysRecords in the given script.
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
	     * @return {Object} An object with tag and script properties.
	     */
	    getScriptTable: function(script, create) {
	        var layout = this.getTable(create);
	        if (layout) {
	            script = script || 'DFLT';
	            var scripts = layout.scripts;
	            var pos = searchTag(layout.scripts, script);
	            if (pos >= 0) {
	                return scripts[pos].script;
	            } else if (create) {
	                var scr = {
	                    tag: script,
	                    script: {
	                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
	                        langSysRecords: []
	                    }
	                };
	                scripts.splice(-1 - pos, 0, scr);
	                return scr.script;
	            }
	        }
	    },

	    /**
	     * Returns a language system table
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {string} [language='dlft']
	     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
	     * @return {Object}
	     */
	    getLangSysTable: function(script, language, create) {
	        var scriptTable = this.getScriptTable(script, create);
	        if (scriptTable) {
	            if (!language || language === 'dflt' || language === 'DFLT') {
	                return scriptTable.defaultLangSys;
	            }
	            var pos = searchTag(scriptTable.langSysRecords, language);
	            if (pos >= 0) {
	                return scriptTable.langSysRecords[pos].langSys;
	            } else if (create) {
	                var langSysRecord = {
	                    tag: language,
	                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
	                };
	                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
	                return langSysRecord.langSys;
	            }
	        }
	    },

	    /**
	     * Get a specific feature table.
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {string} [language='dlft']
	     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
	     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
	     * @return {Object}
	     */
	    getFeatureTable: function(script, language, feature, create) {
	        var langSysTable = this.getLangSysTable(script, language, create);
	        if (langSysTable) {
	            var featureRecord;
	            var featIndexes = langSysTable.featureIndexes;
	            var allFeatures = this.font.tables[this.tableName].features;
	            // The FeatureIndex array of indices is in arbitrary order,
	            // even if allFeatures is sorted alphabetically by feature tag.
	            for (var i = 0; i < featIndexes.length; i++) {
	                featureRecord = allFeatures[featIndexes[i]];
	                if (featureRecord.tag === feature) {
	                    return featureRecord.feature;
	                }
	            }
	            if (create) {
	                var index = allFeatures.length;
	                // Automatic ordering of features would require to shift feature indexes in the script list.
	                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
	                featureRecord = {
	                    tag: feature,
	                    feature: { params: 0, lookupListIndexes: [] }
	                };
	                allFeatures.push(featureRecord);
	                featIndexes.push(index);
	                return featureRecord.feature;
	            }
	        }
	    },

	    /**
	     * Get the lookup tables of a given type for a script/language/feature.
	     * @instance
	     * @param {string} [script='DFLT']
	     * @param {string} [language='dlft']
	     * @param {string} feature - 4-letter feature code
	     * @param {number} lookupType - 1 to 9
	     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
	     * @return {Object[]}
	     */
	    getLookupTables: function(script, language, feature, lookupType, create) {
	        var featureTable = this.getFeatureTable(script, language, feature, create);
	        var tables = [];
	        if (featureTable) {
	            var lookupTable;
	            var lookupListIndexes = featureTable.lookupListIndexes;
	            var allLookups = this.font.tables[this.tableName].lookups;
	            // lookupListIndexes are in no particular order, so use naive search.
	            for (var i = 0; i < lookupListIndexes.length; i++) {
	                lookupTable = allLookups[lookupListIndexes[i]];
	                if (lookupTable.lookupType === lookupType) {
	                    tables.push(lookupTable);
	                }
	            }
	            if (tables.length === 0 && create) {
	                lookupTable = {
	                    lookupType: lookupType,
	                    lookupFlag: 0,
	                    subtables: [],
	                    markFilteringSet: undefined
	                };
	                var index = allLookups.length;
	                allLookups.push(lookupTable);
	                lookupListIndexes.push(index);
	                return [lookupTable];
	            }
	        }
	        return tables;
	    },

	    /**
	     * Find a glyph in a class definition table
	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
	     * @param {object} classDefTable - an OpenType Layout class definition table
	     * @param {number} glyphIndex - the index of the glyph to find
	     * @returns {number} -1 if not found
	     */
	    getGlyphClass: function(classDefTable, glyphIndex) {
	        switch (classDefTable.format) {
	            case 1:
	                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
	                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
	                }
	                return 0;
	            case 2:
	                var range = searchRange(classDefTable.ranges, glyphIndex);
	                return range ? range.classId : 0;
	        }
	    },

	    /**
	     * Find a glyph in a coverage table
	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
	     * @param {object} coverageTable - an OpenType Layout coverage table
	     * @param {number} glyphIndex - the index of the glyph to find
	     * @returns {number} -1 if not found
	     */
	    getCoverageIndex: function(coverageTable, glyphIndex) {
	        switch (coverageTable.format) {
	            case 1:
	                var index = binSearch(coverageTable.glyphs, glyphIndex);
	                return index >= 0 ? index : -1;
	            case 2:
	                var range = searchRange(coverageTable.ranges, glyphIndex);
	                return range ? range.index + glyphIndex - range.start : -1;
	        }
	    },

	    /**
	     * Returns the list of glyph indexes of a coverage table.
	     * Format 1: the list is stored raw
	     * Format 2: compact list as range records.
	     * @instance
	     * @param  {Object} coverageTable
	     * @return {Array}
	     */
	    expandCoverage: function(coverageTable) {
	        if (coverageTable.format === 1) {
	            return coverageTable.glyphs;
	        } else {
	            var glyphs = [];
	            var ranges = coverageTable.ranges;
	            for (var i = 0; i < ranges.length; i++) {
	                var range = ranges[i];
	                var start = range.start;
	                var end = range.end;
	                for (var j = start; j <= end; j++) {
	                    glyphs.push(j);
	                }
	            }
	            return glyphs;
	        }
	    }

	};

	// The Position object provides utility methods to manipulate

	/**
	 * @exports opentype.Position
	 * @class
	 * @extends opentype.Layout
	 * @param {opentype.Font}
	 * @constructor
	 */
	function Position(font) {
	    Layout.call(this, font, 'gpos');
	}

	Position.prototype = Layout.prototype;

	/**
	 * Init some data for faster and easier access later.
	 */
	Position.prototype.init = function() {
	    var script = this.getDefaultScriptName();
	    this.defaultKerningTables = this.getKerningTables(script);
	};

	/**
	 * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
	 *
	 * @param {integer} leftIndex - left glyph index
	 * @param {integer} rightIndex - right glyph index
	 * @returns {integer}
	 */
	Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
	    var this$1 = this;

	    for (var i = 0; i < kerningLookups.length; i++) {
	        var subtables = kerningLookups[i].subtables;
	        for (var j = 0; j < subtables.length; j++) {
	            var subtable = subtables[j];
	            var covIndex = this$1.getCoverageIndex(subtable.coverage, leftIndex);
	            if (covIndex < 0) { continue; }
	            switch (subtable.posFormat) {
	                case 1:
	                    // Search Pair Adjustment Positioning Format 1
	                    var pairSet = subtable.pairSets[covIndex];
	                    for (var k = 0; k < pairSet.length; k++) {
	                        var pair = pairSet[k];
	                        if (pair.secondGlyph === rightIndex) {
	                            return pair.value1 && pair.value1.xAdvance || 0;
	                        }
	                    }
	                    break;      // left glyph found, not right glyph - try next subtable
	                case 2:
	                    // Search Pair Adjustment Positioning Format 2
	                    var class1 = this$1.getGlyphClass(subtable.classDef1, leftIndex);
	                    var class2 = this$1.getGlyphClass(subtable.classDef2, rightIndex);
	                    var pair$1 = subtable.classRecords[class1][class2];
	                    return pair$1.value1 && pair$1.value1.xAdvance || 0;
	            }
	        }
	    }
	    return 0;
	};

	/**
	 * List all kerning lookup tables.
	 *
	 * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
	 * @param {string} [language='dflt']
	 * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
	 */
	Position.prototype.getKerningTables = function(script, language) {
	    if (this.font.tables.gpos) {
	        return this.getLookupTables(script, language, 'kern', 2);
	    }
	};

	// The Substitution object provides utility methods to manipulate

	/**
	 * @exports opentype.Substitution
	 * @class
	 * @extends opentype.Layout
	 * @param {opentype.Font}
	 * @constructor
	 */
	function Substitution(font) {
	    Layout.call(this, font, 'gsub');
	}

	// Check if 2 arrays of primitives are equal.
	function arraysEqual(ar1, ar2) {
	    var n = ar1.length;
	    if (n !== ar2.length) { return false; }
	    for (var i = 0; i < n; i++) {
	        if (ar1[i] !== ar2[i]) { return false; }
	    }
	    return true;
	}

	// Find the first subtable of a lookup table in a particular format.
	function getSubstFormat(lookupTable, format, defaultSubtable) {
	    var subtables = lookupTable.subtables;
	    for (var i = 0; i < subtables.length; i++) {
	        var subtable = subtables[i];
	        if (subtable.substFormat === format) {
	            return subtable;
	        }
	    }
	    if (defaultSubtable) {
	        subtables.push(defaultSubtable);
	        return defaultSubtable;
	    }
	    return undefined;
	}

	Substitution.prototype = Layout.prototype;

	/**
	 * Create a default GSUB table.
	 * @return {Object} gsub - The GSUB table.
	 */
	Substitution.prototype.createDefaultTable = function() {
	    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
	    return {
	        version: 1,
	        scripts: [{
	            tag: 'DFLT',
	            script: {
	                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
	                langSysRecords: []
	            }
	        }],
	        features: [],
	        lookups: []
	    };
	};

	/**
	 * List all single substitutions (lookup type 1) for a given script, language, and feature.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
	 * @return {Array} substitutions - The list of substitutions.
	 */
	Substitution.prototype.getSingle = function(feature, script, language) {
	    var this$1 = this;

	    var substitutions = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 1);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this$1.expandCoverage(subtable.coverage);
	            var j = (void 0);
	            if (subtable.substFormat === 1) {
	                var delta = subtable.deltaGlyphId;
	                for (j = 0; j < glyphs.length; j++) {
	                    var glyph = glyphs[j];
	                    substitutions.push({ sub: glyph, by: glyph + delta });
	                }
	            } else {
	                var substitute = subtable.substitute;
	                for (j = 0; j < glyphs.length; j++) {
	                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
	                }
	            }
	        }
	    }
	    return substitutions;
	};

	/**
	 * List all alternates (lookup type 3) for a given script, language, and feature.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
	 * @return {Array} alternates - The list of alternates
	 */
	Substitution.prototype.getAlternates = function(feature, script, language) {
	    var this$1 = this;

	    var alternates = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 3);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this$1.expandCoverage(subtable.coverage);
	            var alternateSets = subtable.alternateSets;
	            for (var j = 0; j < glyphs.length; j++) {
	                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
	            }
	        }
	    }
	    return alternates;
	};

	/**
	 * List all ligatures (lookup type 4) for a given script, language, and feature.
	 * The result is an array of ligature objects like { sub: [ids], by: id }
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @return {Array} ligatures - The list of ligatures.
	 */
	Substitution.prototype.getLigatures = function(feature, script, language) {
	    var this$1 = this;

	    var ligatures = [];
	    var lookupTables = this.getLookupTables(script, language, feature, 4);
	    for (var idx = 0; idx < lookupTables.length; idx++) {
	        var subtables = lookupTables[idx].subtables;
	        for (var i = 0; i < subtables.length; i++) {
	            var subtable = subtables[i];
	            var glyphs = this$1.expandCoverage(subtable.coverage);
	            var ligatureSets = subtable.ligatureSets;
	            for (var j = 0; j < glyphs.length; j++) {
	                var startGlyph = glyphs[j];
	                var ligSet = ligatureSets[j];
	                for (var k = 0; k < ligSet.length; k++) {
	                    var lig = ligSet[k];
	                    ligatures.push({
	                        sub: [startGlyph].concat(lig.components),
	                        by: lig.ligGlyph
	                    });
	                }
	            }
	        }
	    }
	    return ligatures;
	};

	/**
	 * Add or modify a single substitution (lookup type 1)
	 * Format 2, more flexible, is always used.
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addSingle = function(feature, substitution, script, language) {
	    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
	    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
	        substFormat: 2,
	        coverage: {format: 1, glyphs: []},
	        substitute: []
	    });
	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = substitution.sub;
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos < 0) {
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.substitute.splice(pos, 0, 0);
	    }
	    subtable.substitute[pos] = substitution.by;
	};

	/**
	 * Add or modify an alternate substitution (lookup type 1)
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {Object} substitution - { sub: id, by: [ids] }
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
	    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
	    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
	        substFormat: 1,
	        coverage: {format: 1, glyphs: []},
	        alternateSets: []
	    });
	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = substitution.sub;
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos < 0) {
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.alternateSets.splice(pos, 0, 0);
	    }
	    subtable.alternateSets[pos] = substitution.by;
	};

	/**
	 * Add a ligature (lookup type 4)
	 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
	 * @param {Object} ligature - { sub: [ids], by: id }
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.addLigature = function(feature, ligature, script, language) {
	    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
	    var subtable = lookupTable.subtables[0];
	    if (!subtable) {
	        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
	            substFormat: 1,
	            coverage: { format: 1, glyphs: [] },
	            ligatureSets: []
	        };
	        lookupTable.subtables[0] = subtable;
	    }
	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
	    var coverageGlyph = ligature.sub[0];
	    var ligComponents = ligature.sub.slice(1);
	    var ligatureTable = {
	        ligGlyph: ligature.by,
	        components: ligComponents
	    };
	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
	    if (pos >= 0) {
	        // ligatureSet already exists
	        var ligatureSet = subtable.ligatureSets[pos];
	        for (var i = 0; i < ligatureSet.length; i++) {
	            // If ligature already exists, return.
	            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
	                return;
	            }
	        }
	        // ligature does not exist: add it.
	        ligatureSet.push(ligatureTable);
	    } else {
	        // Create a new ligatureSet and add coverage for the first glyph.
	        pos = -1 - pos;
	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
	        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
	    }
	};

	/**
	 * List all feature data for a given script and language.
	 * @param {string} feature - 4-letter feature name
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 * @return {Array} substitutions - The list of substitutions.
	 */
	Substitution.prototype.getFeature = function(feature, script, language) {
	    if (/ss\d\d/.test(feature)) {
	        // ss01 - ss20
	        return this.getSingle(feature, script, language);
	    }
	    switch (feature) {
	        case 'aalt':
	        case 'salt':
	            return this.getSingle(feature, script, language)
	                    .concat(this.getAlternates(feature, script, language));
	        case 'dlig':
	        case 'liga':
	        case 'rlig': return this.getLigatures(feature, script, language);
	    }
	    return undefined;
	};

	/**
	 * Add a substitution to a feature for a given script and language.
	 * @param {string} feature - 4-letter feature name
	 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
	 * @param {string} [script='DFLT']
	 * @param {string} [language='dflt']
	 */
	Substitution.prototype.add = function(feature, sub, script, language) {
	    if (/ss\d\d/.test(feature)) {
	        // ss01 - ss20
	        return this.addSingle(feature, sub, script, language);
	    }
	    switch (feature) {
	        case 'aalt':
	        case 'salt':
	            if (typeof sub.by === 'number') {
	                return this.addSingle(feature, sub, script, language);
	            }
	            return this.addAlternate(feature, sub, script, language);
	        case 'dlig':
	        case 'liga':
	        case 'rlig':
	            return this.addLigature(feature, sub, script, language);
	    }
	    return undefined;
	};

	function isBrowser() {
	    return typeof window !== 'undefined';
	}

	function nodeBufferToArrayBuffer(buffer) {
	    var ab = new ArrayBuffer(buffer.length);
	    var view = new Uint8Array(ab);
	    for (var i = 0; i < buffer.length; ++i) {
	        view[i] = buffer[i];
	    }

	    return ab;
	}

	function arrayBufferToNodeBuffer(ab) {
	    var buffer = new Buffer(ab.byteLength);
	    var view = new Uint8Array(ab);
	    for (var i = 0; i < buffer.length; ++i) {
	        buffer[i] = view[i];
	    }

	    return buffer;
	}

	function checkArgument(expression, message) {
	    if (!expression) {
	        throw message;
	    }
	}

	// The `glyf` table describes the glyphs in TrueType outline format.

	// Parse the coordinate data for a glyph.
	function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
	    var v;
	    if ((flag & shortVectorBitMask) > 0) {
	        // The coordinate is 1 byte long.
	        v = p.parseByte();
	        // The `same` bit is re-used for short values to signify the sign of the value.
	        if ((flag & sameBitMask) === 0) {
	            v = -v;
	        }

	        v = previousValue + v;
	    } else {
	        //  The coordinate is 2 bytes long.
	        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
	        if ((flag & sameBitMask) > 0) {
	            v = previousValue;
	        } else {
	            // Parse the coordinate as a signed 16-bit delta value.
	            v = previousValue + p.parseShort();
	        }
	    }

	    return v;
	}

	// Parse a TrueType glyph.
	function parseGlyph(glyph, data, start) {
	    var p = new parse.Parser(data, start);
	    glyph.numberOfContours = p.parseShort();
	    glyph._xMin = p.parseShort();
	    glyph._yMin = p.parseShort();
	    glyph._xMax = p.parseShort();
	    glyph._yMax = p.parseShort();
	    var flags;
	    var flag;

	    if (glyph.numberOfContours > 0) {
	        // This glyph is not a composite.
	        var endPointIndices = glyph.endPointIndices = [];
	        for (var i = 0; i < glyph.numberOfContours; i += 1) {
	            endPointIndices.push(p.parseUShort());
	        }

	        glyph.instructionLength = p.parseUShort();
	        glyph.instructions = [];
	        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
	            glyph.instructions.push(p.parseByte());
	        }

	        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
	        flags = [];
	        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
	            flag = p.parseByte();
	            flags.push(flag);
	            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
	            if ((flag & 8) > 0) {
	                var repeatCount = p.parseByte();
	                for (var j = 0; j < repeatCount; j += 1) {
	                    flags.push(flag);
	                    i$2 += 1;
	                }
	            }
	        }

	        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

	        if (endPointIndices.length > 0) {
	            var points = [];
	            var point;
	            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
	            if (numberOfCoordinates > 0) {
	                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
	                    flag = flags[i$3];
	                    point = {};
	                    point.onCurve = !!(flag & 1);
	                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
	                    points.push(point);
	                }

	                var px = 0;
	                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
	                    flag = flags[i$4];
	                    point = points[i$4];
	                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
	                    px = point.x;
	                }

	                var py = 0;
	                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
	                    flag = flags[i$5];
	                    point = points[i$5];
	                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
	                    py = point.y;
	                }
	            }

	            glyph.points = points;
	        } else {
	            glyph.points = [];
	        }
	    } else if (glyph.numberOfContours === 0) {
	        glyph.points = [];
	    } else {
	        glyph.isComposite = true;
	        glyph.points = [];
	        glyph.components = [];
	        var moreComponents = true;
	        while (moreComponents) {
	            flags = p.parseUShort();
	            var component = {
	                glyphIndex: p.parseUShort(),
	                xScale: 1,
	                scale01: 0,
	                scale10: 0,
	                yScale: 1,
	                dx: 0,
	                dy: 0
	            };
	            if ((flags & 1) > 0) {
	                // The arguments are words
	                if ((flags & 2) > 0) {
	                    // values are offset
	                    component.dx = p.parseShort();
	                    component.dy = p.parseShort();
	                } else {
	                    // values are matched points
	                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
	                }

	            } else {
	                // The arguments are bytes
	                if ((flags & 2) > 0) {
	                    // values are offset
	                    component.dx = p.parseChar();
	                    component.dy = p.parseChar();
	                } else {
	                    // values are matched points
	                    component.matchedPoints = [p.parseByte(), p.parseByte()];
	                }
	            }

	            if ((flags & 8) > 0) {
	                // We have a scale
	                component.xScale = component.yScale = p.parseF2Dot14();
	            } else if ((flags & 64) > 0) {
	                // We have an X / Y scale
	                component.xScale = p.parseF2Dot14();
	                component.yScale = p.parseF2Dot14();
	            } else if ((flags & 128) > 0) {
	                // We have a 2x2 transformation
	                component.xScale = p.parseF2Dot14();
	                component.scale01 = p.parseF2Dot14();
	                component.scale10 = p.parseF2Dot14();
	                component.yScale = p.parseF2Dot14();
	            }

	            glyph.components.push(component);
	            moreComponents = !!(flags & 32);
	        }
	        if (flags & 0x100) {
	            // We have instructions
	            glyph.instructionLength = p.parseUShort();
	            glyph.instructions = [];
	            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
	                glyph.instructions.push(p.parseByte());
	            }
	        }
	    }
	}

	// Transform an array of points and return a new array.
	function transformPoints(points, transform) {
	    var newPoints = [];
	    for (var i = 0; i < points.length; i += 1) {
	        var pt = points[i];
	        var newPt = {
	            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
	            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
	            onCurve: pt.onCurve,
	            lastPointOfContour: pt.lastPointOfContour
	        };
	        newPoints.push(newPt);
	    }

	    return newPoints;
	}

	function getContours(points) {
	    var contours = [];
	    var currentContour = [];
	    for (var i = 0; i < points.length; i += 1) {
	        var pt = points[i];
	        currentContour.push(pt);
	        if (pt.lastPointOfContour) {
	            contours.push(currentContour);
	            currentContour = [];
	        }
	    }

	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
	    return contours;
	}

	// Convert the TrueType glyph outline to a Path.
	function getPath(points) {
	    var p = new Path();
	    if (!points) {
	        return p;
	    }

	    var contours = getContours(points);

	    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
	        var contour = contours[contourIndex];

	        var prev = null;
	        var curr = contour[contour.length - 1];
	        var next = contour[0];

	        if (curr.onCurve) {
	            p.moveTo(curr.x, curr.y);
	        } else {
	            if (next.onCurve) {
	                p.moveTo(next.x, next.y);
	            } else {
	                // If both first and last points are off-curve, start at their middle.
	                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
	                p.moveTo(start.x, start.y);
	            }
	        }

	        for (var i = 0; i < contour.length; ++i) {
	            prev = curr;
	            curr = next;
	            next = contour[(i + 1) % contour.length];

	            if (curr.onCurve) {
	                // This is a straight line.
	                p.lineTo(curr.x, curr.y);
	            } else {
	                var prev2 = prev;
	                var next2 = next;

	                if (!prev.onCurve) {
	                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
	                }

	                if (!next.onCurve) {
	                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
	                }

	                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
	            }
	        }

	        p.closePath();
	    }
	    return p;
	}

	function buildPath(glyphs, glyph) {
	    if (glyph.isComposite) {
	        for (var j = 0; j < glyph.components.length; j += 1) {
	            var component = glyph.components[j];
	            var componentGlyph = glyphs.get(component.glyphIndex);
	            // Force the ttfGlyphLoader to parse the glyph.
	            componentGlyph.getPath();
	            if (componentGlyph.points) {
	                var transformedPoints = (void 0);
	                if (component.matchedPoints === undefined) {
	                    // component positioned by offset
	                    transformedPoints = transformPoints(componentGlyph.points, component);
	                } else {
	                    // component positioned by matched points
	                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
	                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
	                        throw Error('Matched points out of range in ' + glyph.name);
	                    }
	                    var firstPt = glyph.points[component.matchedPoints[0]];
	                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
	                    var transform = {
	                        xScale: component.xScale, scale01: component.scale01,
	                        scale10: component.scale10, yScale: component.yScale,
	                        dx: 0, dy: 0
	                    };
	                    secondPt = transformPoints([secondPt], transform)[0];
	                    transform.dx = firstPt.x - secondPt.x;
	                    transform.dy = firstPt.y - secondPt.y;
	                    transformedPoints = transformPoints(componentGlyph.points, transform);
	                }
	                glyph.points = glyph.points.concat(transformedPoints);
	            }
	        }
	    }

	    return getPath(glyph.points);
	}

	// Parse all the glyphs according to the offsets from the `loca` table.
	function parseGlyfTable(data, start, loca, font) {
	    var glyphs = new glyphset.GlyphSet(font);

	    // The last element of the loca table is invalid.
	    for (var i = 0; i < loca.length - 1; i += 1) {
	        var offset = loca[i];
	        var nextOffset = loca[i + 1];
	        if (offset !== nextOffset) {
	            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
	        } else {
	            glyphs.push(i, glyphset.glyphLoader(font, i));
	        }
	    }

	    return glyphs;
	}

	var glyf = { getPath: getPath, parse: parseGlyfTable };

	/* A TrueType font hinting interpreter.
	*
	* (c) 2017 Axel Kittenberger
	*
	* This interpreter has been implemented according to this documentation:
	* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
	*
	* According to the documentation F24DOT6 values are used for pixels.
	* That means calculation is 1/64 pixel accurate and uses integer operations.
	* However, Javascript has floating point operations by default and only
	* those are available. One could make a case to simulate the 1/64 accuracy
	* exactly by truncating after every division operation
	* (for example with << 0) to get pixel exactly results as other TrueType
	* implementations. It may make sense since some fonts are pixel optimized
	* by hand using DELTAP instructions. The current implementation doesn't
	* and rather uses full floating point precision.
	*
	* xScale, yScale and rotation is currently ignored.
	*
	* A few non-trivial instructions are missing as I didn't encounter yet
	* a font that used them to test a possible implementation.
	*
	* Some fonts seem to use undocumented features regarding the twilight zone.
	* Only some of them are implemented as they were encountered.
	*
	* The exports.DEBUG statements are removed on the minified distribution file.
	*/

	var instructionTable;
	var exec;
	var execGlyph;
	var execComponent;

	/*
	* Creates a hinting object.
	*
	* There ought to be exactly one
	* for each truetype font that is used for hinting.
	*/
	function Hinting(font) {
	    // the font this hinting object is for
	    this.font = font;

	    this.getCommands = function (hPoints) {
	        return glyf.getPath(hPoints).commands;
	    };

	    // cached states
	    this._fpgmState  =
	    this._prepState  =
	        undefined;

	    // errorState
	    // 0 ... all okay
	    // 1 ... had an error in a glyf,
	    //       continue working but stop spamming
	    //       the console
	    // 2 ... error at prep, stop hinting at this ppem
	    // 3 ... error at fpeg, stop hinting for this font at all
	    this._errorState = 0;
	}

	/*
	* Not rounding.
	*/
	function roundOff(v) {
	    return v;
	}

	/*
	* Rounding to grid.
	*/
	function roundToGrid(v) {
	    //Rounding in TT is supposed to "symmetrical around zero"
	    return Math.sign(v) * Math.round(Math.abs(v));
	}

	/*
	* Rounding to double grid.
	*/
	function roundToDoubleGrid(v) {
	    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
	}

	/*
	* Rounding to half grid.
	*/
	function roundToHalfGrid(v) {
	    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
	}

	/*
	* Rounding to up to grid.
	*/
	function roundUpToGrid(v) {
	    return Math.sign(v) * Math.ceil(Math.abs(v));
	}

	/*
	* Rounding to down to grid.
	*/
	function roundDownToGrid(v) {
	    return Math.sign(v) * Math.floor(Math.abs(v));
	}

	/*
	* Super rounding.
	*/
	var roundSuper = function (v) {
	    var period = this.srPeriod;
	    var phase = this.srPhase;
	    var threshold = this.srThreshold;
	    var sign = 1;

	    if (v < 0) {
	        v = -v;
	        sign = -1;
	    }

	    v += threshold - phase;

	    v = Math.trunc(v / period) * period;

	    v += phase;

	    // according to http://xgridfit.sourceforge.net/round.html
	    if (v < 0) { return phase * sign; }

	    return v * sign;
	};

	/*
	* Unit vector of x-axis.
	*/
	var xUnitVector = {
	    x: 1,

	    y: 0,

	    axis: 'x',

	    // Gets the projected distance between two points.
	    // o1/o2 ... if true, respective original position is used.
	    distance: function (p1, p2, o1, o2) {
	        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
	    },

	    // Moves point p so the moved position has the same relative
	    // position to the moved positions of rp1 and rp2 than the
	    // original positions had.
	    //
	    // See APPENDIX on INTERPOLATE at the bottom of this file.
	    interpolate: function (p, rp1, rp2, pv) {
	        var do1;
	        var do2;
	        var doa1;
	        var doa2;
	        var dm1;
	        var dm2;
	        var dt;

	        if (!pv || pv === this) {
	            do1 = p.xo - rp1.xo;
	            do2 = p.xo - rp2.xo;
	            dm1 = rp1.x - rp1.xo;
	            dm2 = rp2.x - rp2.xo;
	            doa1 = Math.abs(do1);
	            doa2 = Math.abs(do2);
	            dt = doa1 + doa2;

	            if (dt === 0) {
	                p.x = p.xo + (dm1 + dm2) / 2;
	                return;
	            }

	            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
	            return;
	        }

	        do1 = pv.distance(p, rp1, true, true);
	        do2 = pv.distance(p, rp2, true, true);
	        dm1 = pv.distance(rp1, rp1, false, true);
	        dm2 = pv.distance(rp2, rp2, false, true);
	        doa1 = Math.abs(do1);
	        doa2 = Math.abs(do2);
	        dt = doa1 + doa2;

	        if (dt === 0) {
	            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
	            return;
	        }

	        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
	    },

	    // Slope of line normal to this
	    normalSlope: Number.NEGATIVE_INFINITY,

	    // Sets the point 'p' relative to point 'rp'
	    // by the distance 'd'.
	    //
	    // See APPENDIX on SETRELATIVE at the bottom of this file.
	    //
	    // p   ... point to set
	    // rp  ... reference point
	    // d   ... distance on projection vector
	    // pv  ... projection vector (undefined = this)
	    // org ... if true, uses the original position of rp as reference.
	    setRelative: function (p, rp, d, pv, org) {
	        if (!pv || pv === this) {
	            p.x = (org ? rp.xo : rp.x) + d;
	            return;
	        }

	        var rpx = org ? rp.xo : rp.x;
	        var rpy = org ? rp.yo : rp.y;
	        var rpdx = rpx + d * pv.x;
	        var rpdy = rpy + d * pv.y;

	        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
	    },

	    // Slope of vector line.
	    slope: 0,

	    // Touches the point p.
	    touch: function (p) {
	        p.xTouched = true;
	    },

	    // Tests if a point p is touched.
	    touched: function (p) {
	        return p.xTouched;
	    },

	    // Untouches the point p.
	    untouch: function (p) {
	        p.xTouched = false;
	    }
	};

	/*
	* Unit vector of y-axis.
	*/
	var yUnitVector = {
	    x: 0,

	    y: 1,

	    axis: 'y',

	    // Gets the projected distance between two points.
	    // o1/o2 ... if true, respective original position is used.
	    distance: function (p1, p2, o1, o2) {
	        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
	    },

	    // Moves point p so the moved position has the same relative
	    // position to the moved positions of rp1 and rp2 than the
	    // original positions had.
	    //
	    // See APPENDIX on INTERPOLATE at the bottom of this file.
	    interpolate: function (p, rp1, rp2, pv) {
	        var do1;
	        var do2;
	        var doa1;
	        var doa2;
	        var dm1;
	        var dm2;
	        var dt;

	        if (!pv || pv === this) {
	            do1 = p.yo - rp1.yo;
	            do2 = p.yo - rp2.yo;
	            dm1 = rp1.y - rp1.yo;
	            dm2 = rp2.y - rp2.yo;
	            doa1 = Math.abs(do1);
	            doa2 = Math.abs(do2);
	            dt = doa1 + doa2;

	            if (dt === 0) {
	                p.y = p.yo + (dm1 + dm2) / 2;
	                return;
	            }

	            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
	            return;
	        }

	        do1 = pv.distance(p, rp1, true, true);
	        do2 = pv.distance(p, rp2, true, true);
	        dm1 = pv.distance(rp1, rp1, false, true);
	        dm2 = pv.distance(rp2, rp2, false, true);
	        doa1 = Math.abs(do1);
	        doa2 = Math.abs(do2);
	        dt = doa1 + doa2;

	        if (dt === 0) {
	            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
	            return;
	        }

	        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
	    },

	    // Slope of line normal to this.
	    normalSlope: 0,

	    // Sets the point 'p' relative to point 'rp'
	    // by the distance 'd'
	    //
	    // See APPENDIX on SETRELATIVE at the bottom of this file.
	    //
	    // p   ... point to set
	    // rp  ... reference point
	    // d   ... distance on projection vector
	    // pv  ... projection vector (undefined = this)
	    // org ... if true, uses the original position of rp as reference.
	    setRelative: function (p, rp, d, pv, org) {
	        if (!pv || pv === this) {
	            p.y = (org ? rp.yo : rp.y) + d;
	            return;
	        }

	        var rpx = org ? rp.xo : rp.x;
	        var rpy = org ? rp.yo : rp.y;
	        var rpdx = rpx + d * pv.x;
	        var rpdy = rpy + d * pv.y;

	        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
	    },

	    // Slope of vector line.
	    slope: Number.POSITIVE_INFINITY,

	    // Touches the point p.
	    touch: function (p) {
	        p.yTouched = true;
	    },

	    // Tests if a point p is touched.
	    touched: function (p) {
	        return p.yTouched;
	    },

	    // Untouches the point p.
	    untouch: function (p) {
	        p.yTouched = false;
	    }
	};

	Object.freeze(xUnitVector);
	Object.freeze(yUnitVector);

	/*
	* Creates a unit vector that is not x- or y-axis.
	*/
	function UnitVector(x, y) {
	    this.x = x;
	    this.y = y;
	    this.axis = undefined;
	    this.slope = y / x;
	    this.normalSlope = -x / y;
	    Object.freeze(this);
	}

	/*
	* Gets the projected distance between two points.
	* o1/o2 ... if true, respective original position is used.
	*/
	UnitVector.prototype.distance = function(p1, p2, o1, o2) {
	    return (
	        this.x * xUnitVector.distance(p1, p2, o1, o2) +
	        this.y * yUnitVector.distance(p1, p2, o1, o2)
	    );
	};

	/*
	* Moves point p so the moved position has the same relative
	* position to the moved positions of rp1 and rp2 than the
	* original positions had.
	*
	* See APPENDIX on INTERPOLATE at the bottom of this file.
	*/
	UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
	    var dm1;
	    var dm2;
	    var do1;
	    var do2;
	    var doa1;
	    var doa2;
	    var dt;

	    do1 = pv.distance(p, rp1, true, true);
	    do2 = pv.distance(p, rp2, true, true);
	    dm1 = pv.distance(rp1, rp1, false, true);
	    dm2 = pv.distance(rp2, rp2, false, true);
	    doa1 = Math.abs(do1);
	    doa2 = Math.abs(do2);
	    dt = doa1 + doa2;

	    if (dt === 0) {
	        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
	        return;
	    }

	    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
	};

	/*
	* Sets the point 'p' relative to point 'rp'
	* by the distance 'd'
	*
	* See APPENDIX on SETRELATIVE at the bottom of this file.
	*
	* p   ...  point to set
	* rp  ... reference point
	* d   ... distance on projection vector
	* pv  ... projection vector (undefined = this)
	* org ... if true, uses the original position of rp as reference.
	*/
	UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
	    pv = pv || this;

	    var rpx = org ? rp.xo : rp.x;
	    var rpy = org ? rp.yo : rp.y;
	    var rpdx = rpx + d * pv.x;
	    var rpdy = rpy + d * pv.y;

	    var pvns = pv.normalSlope;
	    var fvs = this.slope;

	    var px = p.x;
	    var py = p.y;

	    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
	    p.y = fvs * (p.x - px) + py;
	};

	/*
	* Touches the point p.
	*/
	UnitVector.prototype.touch = function(p) {
	    p.xTouched = true;
	    p.yTouched = true;
	};

	/*
	* Returns a unit vector with x/y coordinates.
	*/
	function getUnitVector(x, y) {
	    var d = Math.sqrt(x * x + y * y);

	    x /= d;
	    y /= d;

	    if (x === 1 && y === 0) { return xUnitVector; }
	    else if (x === 0 && y === 1) { return yUnitVector; }
	    else { return new UnitVector(x, y); }
	}

	/*
	* Creates a point in the hinting engine.
	*/
	function HPoint(
	    x,
	    y,
	    lastPointOfContour,
	    onCurve
	) {
	    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
	    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

	    this.lastPointOfContour = lastPointOfContour;
	    this.onCurve = onCurve;
	    this.prevPointOnContour = undefined;
	    this.nextPointOnContour = undefined;
	    this.xTouched = false;
	    this.yTouched = false;

	    Object.preventExtensions(this);
	}

	/*
	* Returns the next touched point on the contour.
	*
	* v  ... unit vector to test touch axis.
	*/
	HPoint.prototype.nextTouched = function(v) {
	    var p = this.nextPointOnContour;

	    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }

	    return p;
	};

	/*
	* Returns the previous touched point on the contour
	*
	* v  ... unit vector to test touch axis.
	*/
	HPoint.prototype.prevTouched = function(v) {
	    var p = this.prevPointOnContour;

	    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }

	    return p;
	};

	/*
	* The zero point.
	*/
	var HPZero = Object.freeze(new HPoint(0, 0));

	/*
	* The default state of the interpreter.
	*
	* Note: Freezing the defaultState and then deriving from it
	* makes the V8 Javascript engine going awkward,
	* so this is avoided, albeit the defaultState shouldn't
	* ever change.
	*/
	var defaultState = {
	    cvCutIn: 17 / 16,    // control value cut in
	    deltaBase: 9,
	    deltaShift: 0.125,
	    loop: 1,             // loops some instructions
	    minDis: 1,           // minimum distance
	    autoFlip: true
	};

	/*
	* The current state of the interpreter.
	*
	* env  ... 'fpgm' or 'prep' or 'glyf'
	* prog ... the program
	*/
	function State(env, prog) {
	    this.env = env;
	    this.stack = [];
	    this.prog = prog;

	    switch (env) {
	        case 'glyf' :
	            this.zp0 = this.zp1 = this.zp2 = 1;
	            this.rp0 = this.rp1 = this.rp2 = 0;
	            /* fall through */
	        case 'prep' :
	            this.fv = this.pv = this.dpv = xUnitVector;
	            this.round = roundToGrid;
	    }
	}

	/*
	* Executes a glyph program.
	*
	* This does the hinting for each glyph.
	*
	* Returns an array of moved points.
	*
	* glyph: the glyph to hint
	* ppem: the size the glyph is rendered for
	*/
	Hinting.prototype.exec = function(glyph, ppem) {
	    if (typeof ppem !== 'number') {
	        throw new Error('Point size is not a number!');
	    }

	    // Received a fatal error, don't do any hinting anymore.
	    if (this._errorState > 2) { return; }

	    var font = this.font;
	    var prepState = this._prepState;

	    if (!prepState || prepState.ppem !== ppem) {
	        var fpgmState = this._fpgmState;

	        if (!fpgmState) {
	            // Executes the fpgm state.
	            // This is used by fonts to define functions.
	            State.prototype = defaultState;

	            fpgmState =
	            this._fpgmState =
	                new State('fpgm', font.tables.fpgm);

	            fpgmState.funcs = [ ];
	            fpgmState.font = font;

	            if (exports.DEBUG) {
	                console.log('---EXEC FPGM---');
	                fpgmState.step = -1;
	            }

	            try {
	                exec(fpgmState);
	            } catch (e) {
	                console.log('Hinting error in FPGM:' + e);
	                this._errorState = 3;
	                return;
	            }
	        }

	        // Executes the prep program for this ppem setting.
	        // This is used by fonts to set cvt values
	        // depending on to be rendered font size.

	        State.prototype = fpgmState;
	        prepState =
	        this._prepState =
	            new State('prep', font.tables.prep);

	        prepState.ppem = ppem;

	        // Creates a copy of the cvt table
	        // and scales it to the current ppem setting.
	        var oCvt = font.tables.cvt;
	        if (oCvt) {
	            var cvt = prepState.cvt = new Array(oCvt.length);
	            var scale = ppem / font.unitsPerEm;
	            for (var c = 0; c < oCvt.length; c++) {
	                cvt[c] = oCvt[c] * scale;
	            }
	        } else {
	            prepState.cvt = [];
	        }

	        if (exports.DEBUG) {
	            console.log('---EXEC PREP---');
	            prepState.step = -1;
	        }

	        try {
	            exec(prepState);
	        } catch (e) {
	            if (this._errorState < 2) {
	                console.log('Hinting error in PREP:' + e);
	            }
	            this._errorState = 2;
	        }
	    }

	    if (this._errorState > 1) { return; }

	    try {
	        return execGlyph(glyph, prepState);
	    } catch (e) {
	        if (this._errorState < 1) {
	            console.log('Hinting error:' + e);
	            console.log('Note: further hinting errors are silenced');
	        }
	        this._errorState = 1;
	        return undefined;
	    }
	};

	/*
	* Executes the hinting program for a glyph.
	*/
	execGlyph = function(glyph, prepState) {
	    // original point positions
	    var xScale = prepState.ppem / prepState.font.unitsPerEm;
	    var yScale = xScale;
	    var components = glyph.components;
	    var contours;
	    var gZone;
	    var state;

	    State.prototype = prepState;
	    if (!components) {
	        state = new State('glyf', glyph.instructions);
	        if (exports.DEBUG) {
	            console.log('---EXEC GLYPH---');
	            state.step = -1;
	        }
	        execComponent(glyph, state, xScale, yScale);
	        gZone = state.gZone;
	    } else {
	        var font = prepState.font;
	        gZone = [];
	        contours = [];
	        for (var i = 0; i < components.length; i++) {
	            var c = components[i];
	            var cg = font.glyphs.get(c.glyphIndex);

	            state = new State('glyf', cg.instructions);

	            if (exports.DEBUG) {
	                console.log('---EXEC COMP ' + i + '---');
	                state.step = -1;
	            }

	            execComponent(cg, state, xScale, yScale);
	            // appends the computed points to the result array
	            // post processes the component points
	            var dx = Math.round(c.dx * xScale);
	            var dy = Math.round(c.dy * yScale);
	            var gz = state.gZone;
	            var cc = state.contours;
	            for (var pi = 0; pi < gz.length; pi++) {
	                var p = gz[pi];
	                p.xTouched = p.yTouched = false;
	                p.xo = p.x = p.x + dx;
	                p.yo = p.y = p.y + dy;
	            }

	            var gLen = gZone.length;
	            gZone.push.apply(gZone, gz);
	            for (var j = 0; j < cc.length; j++) {
	                contours.push(cc[j] + gLen);
	            }
	        }

	        if (glyph.instructions && !state.inhibitGridFit) {
	            // the composite has instructions on its own
	            state = new State('glyf', glyph.instructions);

	            state.gZone = state.z0 = state.z1 = state.z2 = gZone;

	            state.contours = contours;

	            // note: HPZero cannot be used here, since
	            //       the point might be modified
	            gZone.push(
	                new HPoint(0, 0),
	                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
	            );

	            if (exports.DEBUG) {
	                console.log('---EXEC COMPOSITE---');
	                state.step = -1;
	            }

	            exec(state);

	            gZone.length -= 2;
	        }
	    }

	    return gZone;
	};

	/*
	* Executes the hinting program for a component of a multi-component glyph
	* or of the glyph itself for a non-component glyph.
	*/
	execComponent = function(glyph, state, xScale, yScale)
	{
	    var points = glyph.points || [];
	    var pLen = points.length;
	    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
	    var contours = state.contours = [];

	    // Scales the original points and
	    // makes copies for the hinted points.
	    var cp; // current point
	    for (var i = 0; i < pLen; i++) {
	        cp = points[i];

	        gZone[i] = new HPoint(
	            cp.x * xScale,
	            cp.y * yScale,
	            cp.lastPointOfContour,
	            cp.onCurve
	        );
	    }

	    // Chain links the contours.
	    var sp; // start point
	    var np; // next point

	    for (var i$1 = 0; i$1 < pLen; i$1++) {
	        cp = gZone[i$1];

	        if (!sp) {
	            sp = cp;
	            contours.push(i$1);
	        }

	        if (cp.lastPointOfContour) {
	            cp.nextPointOnContour = sp;
	            sp.prevPointOnContour = cp;
	            sp = undefined;
	        } else {
	            np = gZone[i$1 + 1];
	            cp.nextPointOnContour = np;
	            np.prevPointOnContour = cp;
	        }
	    }

	    if (state.inhibitGridFit) { return; }

	    if (exports.DEBUG) {
	        console.log('PROCESSING GLYPH', state.stack);
	        for (var i$2 = 0; i$2 < pLen; i$2++) {
	            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
	        }
	    }

	    gZone.push(
	        new HPoint(0, 0),
	        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
	    );

	    exec(state);

	    // Removes the extra points.
	    gZone.length -= 2;

	    if (exports.DEBUG) {
	        console.log('FINISHED GLYPH', state.stack);
	        for (var i$3 = 0; i$3 < pLen; i$3++) {
	            console.log(i$3, gZone[i$3].x, gZone[i$3].y);
	        }
	    }
	};

	/*
	* Executes the program loaded in state.
	*/
	exec = function(state) {
	    var prog = state.prog;

	    if (!prog) { return; }

	    var pLen = prog.length;
	    var ins;

	    for (state.ip = 0; state.ip < pLen; state.ip++) {
	        if (exports.DEBUG) { state.step++; }
	        ins = instructionTable[prog[state.ip]];

	        if (!ins) {
	            throw new Error(
	                'unknown instruction: 0x' +
	                Number(prog[state.ip]).toString(16)
	            );
	        }

	        ins(state);

	        // very extensive debugging for each step
	        /*
	        if (exports.DEBUG) {
	            var da;
	            if (state.gZone) {
	                da = [];
	                for (let i = 0; i < state.gZone.length; i++)
	                {
	                    da.push(i + ' ' +
	                        state.gZone[i].x * 64 + ' ' +
	                        state.gZone[i].y * 64 + ' ' +
	                        (state.gZone[i].xTouched ? 'x' : '') +
	                        (state.gZone[i].yTouched ? 'y' : '')
	                    );
	                }
	                console.log('GZ', da);
	            }

	            if (state.tZone) {
	                da = [];
	                for (let i = 0; i < state.tZone.length; i++) {
	                    da.push(i + ' ' +
	                        state.tZone[i].x * 64 + ' ' +
	                        state.tZone[i].y * 64 + ' ' +
	                        (state.tZone[i].xTouched ? 'x' : '') +
	                        (state.tZone[i].yTouched ? 'y' : '')
	                    );
	                }
	                console.log('TZ', da);
	            }

	            if (state.stack.length > 10) {
	                console.log(
	                    state.stack.length,
	                    '...', state.stack.slice(state.stack.length - 10)
	                );
	            } else {
	                console.log(state.stack.length, state.stack);
	            }
	        }
	        */
	    }
	};

	/*
	* Initializes the twilight zone.
	*
	* This is only done if a SZPx instruction
	* refers to the twilight zone.
	*/
	function initTZone(state)
	{
	    var tZone = state.tZone = new Array(state.gZone.length);

	    // no idea if this is actually correct...
	    for (var i = 0; i < tZone.length; i++)
	    {
	        tZone[i] = new HPoint(0, 0);
	    }
	}

	/*
	* Skips the instruction pointer ahead over an IF/ELSE block.
	* handleElse .. if true breaks on matching ELSE
	*/
	function skip(state, handleElse)
	{
	    var prog = state.prog;
	    var ip = state.ip;
	    var nesting = 1;
	    var ins;

	    do {
	        ins = prog[++ip];
	        if (ins === 0x58) // IF
	            { nesting++; }
	        else if (ins === 0x59) // EIF
	            { nesting--; }
	        else if (ins === 0x40) // NPUSHB
	            { ip += prog[ip + 1] + 1; }
	        else if (ins === 0x41) // NPUSHW
	            { ip += 2 * prog[ip + 1] + 1; }
	        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
	            { ip += ins - 0xB0 + 1; }
	        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
	            { ip += (ins - 0xB8 + 1) * 2; }
	        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
	            { break; }
	    } while (nesting > 0);

	    state.ip = ip;
	}

	/*----------------------------------------------------------*
	*          And then a lot of instructions...                *
	*----------------------------------------------------------*/

	// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
	// 0x00-0x01
	function SVTCA(v, state) {
	    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }

	    state.fv = state.pv = state.dpv = v;
	}

	// SPVTCA[a] Set Projection Vector to Coordinate Axis
	// 0x02-0x03
	function SPVTCA(v, state) {
	    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }

	    state.pv = state.dpv = v;
	}

	// SFVTCA[a] Set Freedom Vector to Coordinate Axis
	// 0x04-0x05
	function SFVTCA(v, state) {
	    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }

	    state.fv = v;
	}

	// SPVTL[a] Set Projection Vector To Line
	// 0x06-0x07
	function SPVTL(a, state) {
	    var stack = state.stack;
	    var p2i = stack.pop();
	    var p1i = stack.pop();
	    var p2 = state.z2[p2i];
	    var p1 = state.z1[p1i];

	    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }

	    var dx;
	    var dy;

	    if (!a) {
	        dx = p1.x - p2.x;
	        dy = p1.y - p2.y;
	    } else {
	        dx = p2.y - p1.y;
	        dy = p1.x - p2.x;
	    }

	    state.pv = state.dpv = getUnitVector(dx, dy);
	}

	// SFVTL[a] Set Freedom Vector To Line
	// 0x08-0x09
	function SFVTL(a, state) {
	    var stack = state.stack;
	    var p2i = stack.pop();
	    var p1i = stack.pop();
	    var p2 = state.z2[p2i];
	    var p1 = state.z1[p1i];

	    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }

	    var dx;
	    var dy;

	    if (!a) {
	        dx = p1.x - p2.x;
	        dy = p1.y - p2.y;
	    } else {
	        dx = p2.y - p1.y;
	        dy = p1.x - p2.x;
	    }

	    state.fv = getUnitVector(dx, dy);
	}

	// SPVFS[] Set Projection Vector From Stack
	// 0x0A
	function SPVFS(state) {
	    var stack = state.stack;
	    var y = stack.pop();
	    var x = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

	    state.pv = state.dpv = getUnitVector(x, y);
	}

	// SFVFS[] Set Freedom Vector From Stack
	// 0x0B
	function SFVFS(state) {
	    var stack = state.stack;
	    var y = stack.pop();
	    var x = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

	    state.fv = getUnitVector(x, y);
	}

	// GPV[] Get Projection Vector
	// 0x0C
	function GPV(state) {
	    var stack = state.stack;
	    var pv = state.pv;

	    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }

	    stack.push(pv.x * 0x4000);
	    stack.push(pv.y * 0x4000);
	}

	// GFV[] Get Freedom Vector
	// 0x0C
	function GFV(state) {
	    var stack = state.stack;
	    var fv = state.fv;

	    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }

	    stack.push(fv.x * 0x4000);
	    stack.push(fv.y * 0x4000);
	}

	// SFVTPV[] Set Freedom Vector To Projection Vector
	// 0x0E
	function SFVTPV(state) {
	    state.fv = state.pv;

	    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
	}

	// ISECT[] moves point p to the InterSECTion of two lines
	// 0x0F
	function ISECT(state)
	{
	    var stack = state.stack;
	    var pa0i = stack.pop();
	    var pa1i = stack.pop();
	    var pb0i = stack.pop();
	    var pb1i = stack.pop();
	    var pi = stack.pop();
	    var z0 = state.z0;
	    var z1 = state.z1;
	    var pa0 = z0[pa0i];
	    var pa1 = z0[pa1i];
	    var pb0 = z1[pb0i];
	    var pb1 = z1[pb1i];
	    var p = state.z2[pi];

	    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }

	    // math from
	    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

	    var x1 = pa0.x;
	    var y1 = pa0.y;
	    var x2 = pa1.x;
	    var y2 = pa1.y;
	    var x3 = pb0.x;
	    var y3 = pb0.y;
	    var x4 = pb1.x;
	    var y4 = pb1.y;

	    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
	    var f1 = x1 * y2 - y1 * x2;
	    var f2 = x3 * y4 - y3 * x4;

	    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
	    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
	}

	// SRP0[] Set Reference Point 0
	// 0x10
	function SRP0(state) {
	    state.rp0 = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
	}

	// SRP1[] Set Reference Point 1
	// 0x11
	function SRP1(state) {
	    state.rp1 = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
	}

	// SRP1[] Set Reference Point 2
	// 0x12
	function SRP2(state) {
	    state.rp2 = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
	}

	// SZP0[] Set Zone Pointer 0
	// 0x13
	function SZP0(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }

	    state.zp0 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z0 = state.tZone;
	            break;
	        case 1 :
	            state.z0 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SZP1[] Set Zone Pointer 1
	// 0x14
	function SZP1(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }

	    state.zp1 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z1 = state.tZone;
	            break;
	        case 1 :
	            state.z1 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SZP2[] Set Zone Pointer 2
	// 0x15
	function SZP2(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }

	    state.zp2 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z2 = state.tZone;
	            break;
	        case 1 :
	            state.z2 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SZPS[] Set Zone PointerS
	// 0x16
	function SZPS(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }

	    state.zp0 = state.zp1 = state.zp2 = n;

	    switch (n) {
	        case 0:
	            if (!state.tZone) { initTZone(state); }
	            state.z0 = state.z1 = state.z2 = state.tZone;
	            break;
	        case 1 :
	            state.z0 = state.z1 = state.z2 = state.gZone;
	            break;
	        default :
	            throw new Error('Invalid zone pointer');
	    }
	}

	// SLOOP[] Set LOOP variable
	// 0x17
	function SLOOP(state) {
	    state.loop = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
	}

	// RTG[] Round To Grid
	// 0x18
	function RTG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }

	    state.round = roundToGrid;
	}

	// RTHG[] Round To Half Grid
	// 0x19
	function RTHG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }

	    state.round = roundToHalfGrid;
	}

	// SMD[] Set Minimum Distance
	// 0x1A
	function SMD(state) {
	    var d = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }

	    state.minDis = d / 0x40;
	}

	// ELSE[] ELSE clause
	// 0x1B
	function ELSE(state) {
	    // This instruction has been reached by executing a then branch
	    // so it just skips ahead until matching EIF.
	    //
	    // In case the IF was negative the IF[] instruction already
	    // skipped forward over the ELSE[]

	    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }

	    skip(state, false);
	}

	// JMPR[] JuMP Relative
	// 0x1C
	function JMPR(state) {
	    var o = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }

	    // A jump by 1 would do nothing.
	    state.ip += o - 1;
	}

	// SCVTCI[] Set Control Value Table Cut-In
	// 0x1D
	function SCVTCI(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }

	    state.cvCutIn = n / 0x40;
	}

	// DUP[] DUPlicate top stack element
	// 0x20
	function DUP(state) {
	    var stack = state.stack;

	    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }

	    stack.push(stack[stack.length - 1]);
	}

	// POP[] POP top stack element
	// 0x21
	function POP(state) {
	    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }

	    state.stack.pop();
	}

	// CLEAR[] CLEAR the stack
	// 0x22
	function CLEAR(state) {
	    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }

	    state.stack.length = 0;
	}

	// SWAP[] SWAP the top two elements on the stack
	// 0x23
	function SWAP(state) {
	    var stack = state.stack;

	    var a = stack.pop();
	    var b = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }

	    stack.push(a);
	    stack.push(b);
	}

	// DEPTH[] DEPTH of the stack
	// 0x24
	function DEPTH(state) {
	    var stack = state.stack;

	    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }

	    stack.push(stack.length);
	}

	// LOOPCALL[] LOOPCALL function
	// 0x2A
	function LOOPCALL(state) {
	    var stack = state.stack;
	    var fn = stack.pop();
	    var c = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }

	    // saves callers program
	    var cip = state.ip;
	    var cprog = state.prog;

	    state.prog = state.funcs[fn];

	    // executes the function
	    for (var i = 0; i < c; i++) {
	        exec(state);

	        if (exports.DEBUG) { console.log(
	            ++state.step,
	            i + 1 < c ? 'next loopcall' : 'done loopcall',
	            i
	        ); }
	    }

	    // restores the callers program
	    state.ip = cip;
	    state.prog = cprog;
	}

	// CALL[] CALL function
	// 0x2B
	function CALL(state) {
	    var fn = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }

	    // saves callers program
	    var cip = state.ip;
	    var cprog = state.prog;

	    state.prog = state.funcs[fn];

	    // executes the function
	    exec(state);

	    // restores the callers program
	    state.ip = cip;
	    state.prog = cprog;

	    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
	}

	// CINDEX[] Copy the INDEXed element to the top of the stack
	// 0x25
	function CINDEX(state) {
	    var stack = state.stack;
	    var k = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }

	    // In case of k == 1, it copies the last element after popping
	    // thus stack.length - k.
	    stack.push(stack[stack.length - k]);
	}

	// MINDEX[] Move the INDEXed element to the top of the stack
	// 0x26
	function MINDEX(state) {
	    var stack = state.stack;
	    var k = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }

	    stack.push(stack.splice(stack.length - k, 1)[0]);
	}

	// FDEF[] Function DEFinition
	// 0x2C
	function FDEF(state) {
	    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
	    var stack = state.stack;
	    var prog = state.prog;
	    var ip = state.ip;

	    var fn = stack.pop();
	    var ipBegin = ip;

	    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }

	    while (prog[++ip] !== 0x2D){ }

	    state.ip = ip;
	    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
	}

	// MDAP[a] Move Direct Absolute Point
	// 0x2E-0x2F
	function MDAP(round, state) {
	    var pi = state.stack.pop();
	    var p = state.z0[pi];
	    var fv = state.fv;
	    var pv = state.pv;

	    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }

	    var d = pv.distance(p, HPZero);

	    if (round) { d = state.round(d); }

	    fv.setRelative(p, HPZero, d, pv);
	    fv.touch(p);

	    state.rp0 = state.rp1 = pi;
	}

	// IUP[a] Interpolate Untouched Points through the outline
	// 0x30
	function IUP(v, state) {
	    var z2 = state.z2;
	    var pLen = z2.length - 2;
	    var cp;
	    var pp;
	    var np;

	    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }

	    for (var i = 0; i < pLen; i++) {
	        cp = z2[i]; // current point

	        // if this point has been touched go on
	        if (v.touched(cp)) { continue; }

	        pp = cp.prevTouched(v);

	        // no point on the contour has been touched?
	        if (pp === cp) { continue; }

	        np = cp.nextTouched(v);

	        if (pp === np) {
	            // only one point on the contour has been touched
	            // so simply moves the point like that

	            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
	        }

	        v.interpolate(cp, pp, np, v);
	    }
	}

	// SHP[] SHift Point using reference point
	// 0x32-0x33
	function SHP(a, state) {
	    var stack = state.stack;
	    var rpi = a ? state.rp1 : state.rp2;
	    var rp = (a ? state.z0 : state.z1)[rpi];
	    var fv = state.fv;
	    var pv = state.pv;
	    var loop = state.loop;
	    var z2 = state.z2;

	    while (loop--)
	    {
	        var pi = stack.pop();
	        var p = z2[pi];

	        var d = pv.distance(rp, rp, false, true);
	        fv.setRelative(p, p, d, pv);
	        fv.touch(p);

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ?
	                   'loop ' + (state.loop - loop) + ': ' :
	                   ''
	                ) +
	                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
	            );
	        }
	    }

	    state.loop = 1;
	}

	// SHC[] SHift Contour using reference point
	// 0x36-0x37
	function SHC(a, state) {
	    var stack = state.stack;
	    var rpi = a ? state.rp1 : state.rp2;
	    var rp = (a ? state.z0 : state.z1)[rpi];
	    var fv = state.fv;
	    var pv = state.pv;
	    var ci = stack.pop();
	    var sp = state.z2[state.contours[ci]];
	    var p = sp;

	    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }

	    var d = pv.distance(rp, rp, false, true);

	    do {
	        if (p !== rp) { fv.setRelative(p, p, d, pv); }
	        p = p.nextPointOnContour;
	    } while (p !== sp);
	}

	// SHZ[] SHift Zone using reference point
	// 0x36-0x37
	function SHZ(a, state) {
	    var stack = state.stack;
	    var rpi = a ? state.rp1 : state.rp2;
	    var rp = (a ? state.z0 : state.z1)[rpi];
	    var fv = state.fv;
	    var pv = state.pv;

	    var e = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }

	    var z;
	    switch (e) {
	        case 0 : z = state.tZone; break;
	        case 1 : z = state.gZone; break;
	        default : throw new Error('Invalid zone');
	    }

	    var p;
	    var d = pv.distance(rp, rp, false, true);
	    var pLen = z.length - 2;
	    for (var i = 0; i < pLen; i++)
	    {
	        p = z[i];
	        fv.setRelative(p, p, d, pv);
	        //if (p !== rp) fv.setRelative(p, p, d, pv);
	    }
	}

	// SHPIX[] SHift point by a PIXel amount
	// 0x38
	function SHPIX(state) {
	    var stack = state.stack;
	    var loop = state.loop;
	    var fv = state.fv;
	    var d = stack.pop() / 0x40;
	    var z2 = state.z2;

	    while (loop--) {
	        var pi = stack.pop();
	        var p = z2[pi];

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
	                'SHPIX[]', pi, d
	            );
	        }

	        fv.setRelative(p, p, d);
	        fv.touch(p);
	    }

	    state.loop = 1;
	}

	// IP[] Interpolate Point
	// 0x39
	function IP(state) {
	    var stack = state.stack;
	    var rp1i = state.rp1;
	    var rp2i = state.rp2;
	    var loop = state.loop;
	    var rp1 = state.z0[rp1i];
	    var rp2 = state.z1[rp2i];
	    var fv = state.fv;
	    var pv = state.dpv;
	    var z2 = state.z2;

	    while (loop--) {
	        var pi = stack.pop();
	        var p = z2[pi];

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
	                'IP[]', pi, rp1i, '<->', rp2i
	            );
	        }

	        fv.interpolate(p, rp1, rp2, pv);

	        fv.touch(p);
	    }

	    state.loop = 1;
	}

	// MSIRP[a] Move Stack Indirect Relative Point
	// 0x3A-0x3B
	function MSIRP(a, state) {
	    var stack = state.stack;
	    var d = stack.pop() / 64;
	    var pi = stack.pop();
	    var p = state.z1[pi];
	    var rp0 = state.z0[state.rp0];
	    var fv = state.fv;
	    var pv = state.pv;

	    fv.setRelative(p, rp0, d, pv);
	    fv.touch(p);

	    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }

	    state.rp1 = state.rp0;
	    state.rp2 = pi;
	    if (a) { state.rp0 = pi; }
	}

	// ALIGNRP[] Align to reference point.
	// 0x3C
	function ALIGNRP(state) {
	    var stack = state.stack;
	    var rp0i = state.rp0;
	    var rp0 = state.z0[rp0i];
	    var loop = state.loop;
	    var fv = state.fv;
	    var pv = state.pv;
	    var z1 = state.z1;

	    while (loop--) {
	        var pi = stack.pop();
	        var p = z1[pi];

	        if (exports.DEBUG) {
	            console.log(
	                state.step,
	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
	                'ALIGNRP[]', pi
	            );
	        }

	        fv.setRelative(p, rp0, 0, pv);
	        fv.touch(p);
	    }

	    state.loop = 1;
	}

	// RTG[] Round To Double Grid
	// 0x3D
	function RTDG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }

	    state.round = roundToDoubleGrid;
	}

	// MIAP[a] Move Indirect Absolute Point
	// 0x3E-0x3F
	function MIAP(round, state) {
	    var stack = state.stack;
	    var n = stack.pop();
	    var pi = stack.pop();
	    var p = state.z0[pi];
	    var fv = state.fv;
	    var pv = state.pv;
	    var cv = state.cvt[n];

	    if (exports.DEBUG) {
	        console.log(
	            state.step,
	            'MIAP[' + round + ']',
	            n, '(', cv, ')', pi
	        );
	    }

	    var d = pv.distance(p, HPZero);

	    if (round) {
	        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }

	        d = state.round(d);
	    }

	    fv.setRelative(p, HPZero, d, pv);

	    if (state.zp0 === 0) {
	        p.xo = p.x;
	        p.yo = p.y;
	    }

	    fv.touch(p);

	    state.rp0 = state.rp1 = pi;
	}

	// NPUSB[] PUSH N Bytes
	// 0x40
	function NPUSHB(state) {
	    var prog = state.prog;
	    var ip = state.ip;
	    var stack = state.stack;

	    var n = prog[++ip];

	    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }

	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

	    state.ip = ip;
	}

	// NPUSHW[] PUSH N Words
	// 0x41
	function NPUSHW(state) {
	    var ip = state.ip;
	    var prog = state.prog;
	    var stack = state.stack;
	    var n = prog[++ip];

	    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }

	    for (var i = 0; i < n; i++) {
	        var w = (prog[++ip] << 8) | prog[++ip];
	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
	        stack.push(w);
	    }

	    state.ip = ip;
	}

	// WS[] Write Store
	// 0x42
	function WS(state) {
	    var stack = state.stack;
	    var store = state.store;

	    if (!store) { store = state.store = []; }

	    var v = stack.pop();
	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }

	    store[l] = v;
	}

	// RS[] Read Store
	// 0x43
	function RS(state) {
	    var stack = state.stack;
	    var store = state.store;

	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'RS', l); }

	    var v = (store && store[l]) || 0;

	    stack.push(v);
	}

	// WCVTP[] Write Control Value Table in Pixel units
	// 0x44
	function WCVTP(state) {
	    var stack = state.stack;

	    var v = stack.pop();
	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }

	    state.cvt[l] = v / 0x40;
	}

	// RCVT[] Read Control Value Table entry
	// 0x45
	function RCVT(state) {
	    var stack = state.stack;
	    var cvte = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }

	    stack.push(state.cvt[cvte] * 0x40);
	}

	// GC[] Get Coordinate projected onto the projection vector
	// 0x46-0x47
	function GC(a, state) {
	    var stack = state.stack;
	    var pi = stack.pop();
	    var p = state.z2[pi];

	    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }

	    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
	}

	// MD[a] Measure Distance
	// 0x49-0x4A
	function MD(a, state) {
	    var stack = state.stack;
	    var pi2 = stack.pop();
	    var pi1 = stack.pop();
	    var p2 = state.z1[pi2];
	    var p1 = state.z0[pi1];
	    var d = state.dpv.distance(p1, p2, a, a);

	    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }

	    state.stack.push(Math.round(d * 64));
	}

	// MPPEM[] Measure Pixels Per EM
	// 0x4B
	function MPPEM(state) {
	    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
	    state.stack.push(state.ppem);
	}

	// FLIPON[] set the auto FLIP Boolean to ON
	// 0x4D
	function FLIPON(state) {
	    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
	    state.autoFlip = true;
	}

	// LT[] Less Than
	// 0x50
	function LT(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }

	    stack.push(e1 < e2 ? 1 : 0);
	}

	// LTEQ[] Less Than or EQual
	// 0x53
	function LTEQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }

	    stack.push(e1 <= e2 ? 1 : 0);
	}

	// GTEQ[] Greater Than
	// 0x52
	function GT(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }

	    stack.push(e1 > e2 ? 1 : 0);
	}

	// GTEQ[] Greater Than or EQual
	// 0x53
	function GTEQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }

	    stack.push(e1 >= e2 ? 1 : 0);
	}

	// EQ[] EQual
	// 0x54
	function EQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }

	    stack.push(e2 === e1 ? 1 : 0);
	}

	// NEQ[] Not EQual
	// 0x55
	function NEQ(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }

	    stack.push(e2 !== e1 ? 1 : 0);
	}

	// ODD[] ODD
	// 0x56
	function ODD(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }

	    stack.push(Math.trunc(n) % 2 ? 1 : 0);
	}

	// EVEN[] EVEN
	// 0x57
	function EVEN(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }

	    stack.push(Math.trunc(n) % 2 ? 0 : 1);
	}

	// IF[] IF test
	// 0x58
	function IF(state) {
	    var test = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }

	    // if test is true it just continues
	    // if not the ip is skipped until matching ELSE or EIF
	    if (!test) {
	        skip(state, true);

	        if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
	    }
	}

	// EIF[] End IF
	// 0x59
	function EIF(state) {
	    // this can be reached normally when
	    // executing an else branch.
	    // -> just ignore it

	    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
	}

	// AND[] logical AND
	// 0x5A
	function AND(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }

	    stack.push(e2 && e1 ? 1 : 0);
	}

	// OR[] logical OR
	// 0x5B
	function OR(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }

	    stack.push(e2 || e1 ? 1 : 0);
	}

	// NOT[] logical NOT
	// 0x5C
	function NOT(state) {
	    var stack = state.stack;
	    var e = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }

	    stack.push(e ? 0 : 1);
	}

	// DELTAP1[] DELTA exception P1
	// DELTAP2[] DELTA exception P2
	// DELTAP3[] DELTA exception P3
	// 0x5D, 0x71, 0x72
	function DELTAP123(b, state) {
	    var stack = state.stack;
	    var n = stack.pop();
	    var fv = state.fv;
	    var pv = state.pv;
	    var ppem = state.ppem;
	    var base = state.deltaBase + (b - 1) * 16;
	    var ds = state.deltaShift;
	    var z0 = state.z0;

	    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }

	    for (var i = 0; i < n; i++) {
	        var pi = stack.pop();
	        var arg = stack.pop();
	        var appem = base + ((arg & 0xF0) >> 4);
	        if (appem !== ppem) { continue; }

	        var mag = (arg & 0x0F) - 8;
	        if (mag >= 0) { mag++; }
	        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }

	        var p = z0[pi];
	        fv.setRelative(p, p, mag * ds, pv);
	    }
	}

	// SDB[] Set Delta Base in the graphics state
	// 0x5E
	function SDB(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }

	    state.deltaBase = n;
	}

	// SDS[] Set Delta Shift in the graphics state
	// 0x5F
	function SDS(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }

	    state.deltaShift = Math.pow(0.5, n);
	}

	// ADD[] ADD
	// 0x60
	function ADD(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }

	    stack.push(n1 + n2);
	}

	// SUB[] SUB
	// 0x61
	function SUB(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }

	    stack.push(n1 - n2);
	}

	// DIV[] DIV
	// 0x62
	function DIV(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }

	    stack.push(n1 * 64 / n2);
	}

	// MUL[] MUL
	// 0x63
	function MUL(state) {
	    var stack = state.stack;
	    var n2 = stack.pop();
	    var n1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }

	    stack.push(n1 * n2 / 64);
	}

	// ABS[] ABSolute value
	// 0x64
	function ABS(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }

	    stack.push(Math.abs(n));
	}

	// NEG[] NEGate
	// 0x65
	function NEG(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }

	    stack.push(-n);
	}

	// FLOOR[] FLOOR
	// 0x66
	function FLOOR(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }

	    stack.push(Math.floor(n / 0x40) * 0x40);
	}

	// CEILING[] CEILING
	// 0x67
	function CEILING(state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }

	    stack.push(Math.ceil(n / 0x40) * 0x40);
	}

	// ROUND[ab] ROUND value
	// 0x68-0x6B
	function ROUND(dt, state) {
	    var stack = state.stack;
	    var n = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }

	    stack.push(state.round(n / 0x40) * 0x40);
	}

	// WCVTF[] Write Control Value Table in Funits
	// 0x70
	function WCVTF(state) {
	    var stack = state.stack;
	    var v = stack.pop();
	    var l = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }

	    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
	}

	// DELTAC1[] DELTA exception C1
	// DELTAC2[] DELTA exception C2
	// DELTAC3[] DELTA exception C3
	// 0x73, 0x74, 0x75
	function DELTAC123(b, state) {
	    var stack = state.stack;
	    var n = stack.pop();
	    var ppem = state.ppem;
	    var base = state.deltaBase + (b - 1) * 16;
	    var ds = state.deltaShift;

	    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }

	    for (var i = 0; i < n; i++) {
	        var c = stack.pop();
	        var arg = stack.pop();
	        var appem = base + ((arg & 0xF0) >> 4);
	        if (appem !== ppem) { continue; }

	        var mag = (arg & 0x0F) - 8;
	        if (mag >= 0) { mag++; }

	        var delta = mag * ds;

	        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }

	        state.cvt[c] += delta;
	    }
	}

	// SROUND[] Super ROUND
	// 0x76
	function SROUND(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }

	    state.round = roundSuper;

	    var period;

	    switch (n & 0xC0) {
	        case 0x00:
	            period = 0.5;
	            break;
	        case 0x40:
	            period = 1;
	            break;
	        case 0x80:
	            period = 2;
	            break;
	        default:
	            throw new Error('invalid SROUND value');
	    }

	    state.srPeriod = period;

	    switch (n & 0x30) {
	        case 0x00:
	            state.srPhase = 0;
	            break;
	        case 0x10:
	            state.srPhase = 0.25 * period;
	            break;
	        case 0x20:
	            state.srPhase = 0.5  * period;
	            break;
	        case 0x30:
	            state.srPhase = 0.75 * period;
	            break;
	        default: throw new Error('invalid SROUND value');
	    }

	    n &= 0x0F;

	    if (n === 0) { state.srThreshold = 0; }
	    else { state.srThreshold = (n / 8 - 0.5) * period; }
	}

	// S45ROUND[] Super ROUND 45 degrees
	// 0x77
	function S45ROUND(state) {
	    var n = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }

	    state.round = roundSuper;

	    var period;

	    switch (n & 0xC0) {
	        case 0x00:
	            period = Math.sqrt(2) / 2;
	            break;
	        case 0x40:
	            period = Math.sqrt(2);
	            break;
	        case 0x80:
	            period = 2 * Math.sqrt(2);
	            break;
	        default:
	            throw new Error('invalid S45ROUND value');
	    }

	    state.srPeriod = period;

	    switch (n & 0x30) {
	        case 0x00:
	            state.srPhase = 0;
	            break;
	        case 0x10:
	            state.srPhase = 0.25 * period;
	            break;
	        case 0x20:
	            state.srPhase = 0.5  * period;
	            break;
	        case 0x30:
	            state.srPhase = 0.75 * period;
	            break;
	        default:
	            throw new Error('invalid S45ROUND value');
	    }

	    n &= 0x0F;

	    if (n === 0) { state.srThreshold = 0; }
	    else { state.srThreshold = (n / 8 - 0.5) * period; }
	}

	// ROFF[] Round Off
	// 0x7A
	function ROFF(state) {
	    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }

	    state.round = roundOff;
	}

	// RUTG[] Round Up To Grid
	// 0x7C
	function RUTG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }

	    state.round = roundUpToGrid;
	}

	// RDTG[] Round Down To Grid
	// 0x7D
	function RDTG(state) {
	    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }

	    state.round = roundDownToGrid;
	}

	// SCANCTRL[] SCAN conversion ConTRoL
	// 0x85
	function SCANCTRL(state) {
	    var n = state.stack.pop();

	    // ignored by opentype.js

	    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
	}

	// SDPVTL[a] Set Dual Projection Vector To Line
	// 0x86-0x87
	function SDPVTL(a, state) {
	    var stack = state.stack;
	    var p2i = stack.pop();
	    var p1i = stack.pop();
	    var p2 = state.z2[p2i];
	    var p1 = state.z1[p1i];

	    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }

	    var dx;
	    var dy;

	    if (!a) {
	        dx = p1.x - p2.x;
	        dy = p1.y - p2.y;
	    } else {
	        dx = p2.y - p1.y;
	        dy = p1.x - p2.x;
	    }

	    state.dpv = getUnitVector(dx, dy);
	}

	// GETINFO[] GET INFOrmation
	// 0x88
	function GETINFO(state) {
	    var stack = state.stack;
	    var sel = stack.pop();
	    var r = 0;

	    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }

	    // v35 as in no subpixel hinting
	    if (sel & 0x01) { r = 35; }

	    // TODO rotation and stretch currently not supported
	    // and thus those GETINFO are always 0.

	    // opentype.js is always gray scaling
	    if (sel & 0x20) { r |= 0x1000; }

	    stack.push(r);
	}

	// ROLL[] ROLL the top three stack elements
	// 0x8A
	function ROLL(state) {
	    var stack = state.stack;
	    var a = stack.pop();
	    var b = stack.pop();
	    var c = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }

	    stack.push(b);
	    stack.push(a);
	    stack.push(c);
	}

	// MAX[] MAXimum of top two stack elements
	// 0x8B
	function MAX(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }

	    stack.push(Math.max(e1, e2));
	}

	// MIN[] MINimum of top two stack elements
	// 0x8C
	function MIN(state) {
	    var stack = state.stack;
	    var e2 = stack.pop();
	    var e1 = stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }

	    stack.push(Math.min(e1, e2));
	}

	// SCANTYPE[] SCANTYPE
	// 0x8D
	function SCANTYPE(state) {
	    var n = state.stack.pop();
	    // ignored by opentype.js
	    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
	}

	// INSTCTRL[] INSTCTRL
	// 0x8D
	function INSTCTRL(state) {
	    var s = state.stack.pop();
	    var v = state.stack.pop();

	    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }

	    switch (s) {
	        case 1 : state.inhibitGridFit = !!v; return;
	        case 2 : state.ignoreCvt = !!v; return;
	        default: throw new Error('invalid INSTCTRL[] selector');
	    }
	}

	// PUSHB[abc] PUSH Bytes
	// 0xB0-0xB7
	function PUSHB(n, state) {
	    var stack = state.stack;
	    var prog = state.prog;
	    var ip = state.ip;

	    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }

	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

	    state.ip = ip;
	}

	// PUSHW[abc] PUSH Words
	// 0xB8-0xBF
	function PUSHW(n, state) {
	    var ip = state.ip;
	    var prog = state.prog;
	    var stack = state.stack;

	    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }

	    for (var i = 0; i < n; i++) {
	        var w = (prog[++ip] << 8) | prog[++ip];
	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
	        stack.push(w);
	    }

	    state.ip = ip;
	}

	// MDRP[abcde] Move Direct Relative Point
	// 0xD0-0xEF
	// (if indirect is 0)
	//
	// and
	//
	// MIRP[abcde] Move Indirect Relative Point
	// 0xE0-0xFF
	// (if indirect is 1)

	function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
	    var stack = state.stack;
	    var cvte = indirect && stack.pop();
	    var pi = stack.pop();
	    var rp0i = state.rp0;
	    var rp = state.z0[rp0i];
	    var p = state.z1[pi];

	    var md = state.minDis;
	    var fv = state.fv;
	    var pv = state.dpv;
	    var od; // original distance
	    var d; // moving distance
	    var sign; // sign of distance
	    var cv;

	    d = od = pv.distance(p, rp, true, true);
	    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

	    // TODO consider autoFlip
	    d = Math.abs(d);

	    if (indirect) {
	        cv = state.cvt[cvte];

	        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
	    }

	    if (keepD && d < md) { d = md; }

	    if (ro) { d = state.round(d); }

	    fv.setRelative(p, rp, sign * d, pv);
	    fv.touch(p);

	    if (exports.DEBUG) {
	        console.log(
	            state.step,
	            (indirect ? 'MIRP[' : 'MDRP[') +
	            (setRp0 ? 'M' : 'm') +
	            (keepD ? '>' : '_') +
	            (ro ? 'R' : '_') +
	            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
	            ']',
	            indirect ?
	                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
	                '',
	            pi,
	            '(d =', od, '->', sign * d, ')'
	        );
	    }

	    state.rp1 = state.rp0;
	    state.rp2 = pi;
	    if (setRp0) { state.rp0 = pi; }
	}

	/*
	* The instruction table.
	*/
	instructionTable = [
	    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
	    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
	    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
	    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
	    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
	    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
	    /* 0x06 */ SPVTL.bind(undefined, 0),
	    /* 0x07 */ SPVTL.bind(undefined, 1),
	    /* 0x08 */ SFVTL.bind(undefined, 0),
	    /* 0x09 */ SFVTL.bind(undefined, 1),
	    /* 0x0A */ SPVFS,
	    /* 0x0B */ SFVFS,
	    /* 0x0C */ GPV,
	    /* 0x0D */ GFV,
	    /* 0x0E */ SFVTPV,
	    /* 0x0F */ ISECT,
	    /* 0x10 */ SRP0,
	    /* 0x11 */ SRP1,
	    /* 0x12 */ SRP2,
	    /* 0x13 */ SZP0,
	    /* 0x14 */ SZP1,
	    /* 0x15 */ SZP2,
	    /* 0x16 */ SZPS,
	    /* 0x17 */ SLOOP,
	    /* 0x18 */ RTG,
	    /* 0x19 */ RTHG,
	    /* 0x1A */ SMD,
	    /* 0x1B */ ELSE,
	    /* 0x1C */ JMPR,
	    /* 0x1D */ SCVTCI,
	    /* 0x1E */ undefined,   // TODO SSWCI
	    /* 0x1F */ undefined,   // TODO SSW
	    /* 0x20 */ DUP,
	    /* 0x21 */ POP,
	    /* 0x22 */ CLEAR,
	    /* 0x23 */ SWAP,
	    /* 0x24 */ DEPTH,
	    /* 0x25 */ CINDEX,
	    /* 0x26 */ MINDEX,
	    /* 0x27 */ undefined,   // TODO ALIGNPTS
	    /* 0x28 */ undefined,
	    /* 0x29 */ undefined,   // TODO UTP
	    /* 0x2A */ LOOPCALL,
	    /* 0x2B */ CALL,
	    /* 0x2C */ FDEF,
	    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
	    /* 0x2E */ MDAP.bind(undefined, 0),
	    /* 0x2F */ MDAP.bind(undefined, 1),
	    /* 0x30 */ IUP.bind(undefined, yUnitVector),
	    /* 0x31 */ IUP.bind(undefined, xUnitVector),
	    /* 0x32 */ SHP.bind(undefined, 0),
	    /* 0x33 */ SHP.bind(undefined, 1),
	    /* 0x34 */ SHC.bind(undefined, 0),
	    /* 0x35 */ SHC.bind(undefined, 1),
	    /* 0x36 */ SHZ.bind(undefined, 0),
	    /* 0x37 */ SHZ.bind(undefined, 1),
	    /* 0x38 */ SHPIX,
	    /* 0x39 */ IP,
	    /* 0x3A */ MSIRP.bind(undefined, 0),
	    /* 0x3B */ MSIRP.bind(undefined, 1),
	    /* 0x3C */ ALIGNRP,
	    /* 0x3D */ RTDG,
	    /* 0x3E */ MIAP.bind(undefined, 0),
	    /* 0x3F */ MIAP.bind(undefined, 1),
	    /* 0x40 */ NPUSHB,
	    /* 0x41 */ NPUSHW,
	    /* 0x42 */ WS,
	    /* 0x43 */ RS,
	    /* 0x44 */ WCVTP,
	    /* 0x45 */ RCVT,
	    /* 0x46 */ GC.bind(undefined, 0),
	    /* 0x47 */ GC.bind(undefined, 1),
	    /* 0x48 */ undefined,   // TODO SCFS
	    /* 0x49 */ MD.bind(undefined, 0),
	    /* 0x4A */ MD.bind(undefined, 1),
	    /* 0x4B */ MPPEM,
	    /* 0x4C */ undefined,   // TODO MPS
	    /* 0x4D */ FLIPON,
	    /* 0x4E */ undefined,   // TODO FLIPOFF
	    /* 0x4F */ undefined,   // TODO DEBUG
	    /* 0x50 */ LT,
	    /* 0x51 */ LTEQ,
	    /* 0x52 */ GT,
	    /* 0x53 */ GTEQ,
	    /* 0x54 */ EQ,
	    /* 0x55 */ NEQ,
	    /* 0x56 */ ODD,
	    /* 0x57 */ EVEN,
	    /* 0x58 */ IF,
	    /* 0x59 */ EIF,
	    /* 0x5A */ AND,
	    /* 0x5B */ OR,
	    /* 0x5C */ NOT,
	    /* 0x5D */ DELTAP123.bind(undefined, 1),
	    /* 0x5E */ SDB,
	    /* 0x5F */ SDS,
	    /* 0x60 */ ADD,
	    /* 0x61 */ SUB,
	    /* 0x62 */ DIV,
	    /* 0x63 */ MUL,
	    /* 0x64 */ ABS,
	    /* 0x65 */ NEG,
	    /* 0x66 */ FLOOR,
	    /* 0x67 */ CEILING,
	    /* 0x68 */ ROUND.bind(undefined, 0),
	    /* 0x69 */ ROUND.bind(undefined, 1),
	    /* 0x6A */ ROUND.bind(undefined, 2),
	    /* 0x6B */ ROUND.bind(undefined, 3),
	    /* 0x6C */ undefined,   // TODO NROUND[ab]
	    /* 0x6D */ undefined,   // TODO NROUND[ab]
	    /* 0x6E */ undefined,   // TODO NROUND[ab]
	    /* 0x6F */ undefined,   // TODO NROUND[ab]
	    /* 0x70 */ WCVTF,
	    /* 0x71 */ DELTAP123.bind(undefined, 2),
	    /* 0x72 */ DELTAP123.bind(undefined, 3),
	    /* 0x73 */ DELTAC123.bind(undefined, 1),
	    /* 0x74 */ DELTAC123.bind(undefined, 2),
	    /* 0x75 */ DELTAC123.bind(undefined, 3),
	    /* 0x76 */ SROUND,
	    /* 0x77 */ S45ROUND,
	    /* 0x78 */ undefined,   // TODO JROT[]
	    /* 0x79 */ undefined,   // TODO JROF[]
	    /* 0x7A */ ROFF,
	    /* 0x7B */ undefined,
	    /* 0x7C */ RUTG,
	    /* 0x7D */ RDTG,
	    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
	    /* 0x7F */ POP, // actually AA, supposed to do only a pop though
	    /* 0x80 */ undefined,   // TODO FLIPPT
	    /* 0x81 */ undefined,   // TODO FLIPRGON
	    /* 0x82 */ undefined,   // TODO FLIPRGOFF
	    /* 0x83 */ undefined,
	    /* 0x84 */ undefined,
	    /* 0x85 */ SCANCTRL,
	    /* 0x86 */ SDPVTL.bind(undefined, 0),
	    /* 0x87 */ SDPVTL.bind(undefined, 1),
	    /* 0x88 */ GETINFO,
	    /* 0x89 */ undefined,   // TODO IDEF
	    /* 0x8A */ ROLL,
	    /* 0x8B */ MAX,
	    /* 0x8C */ MIN,
	    /* 0x8D */ SCANTYPE,
	    /* 0x8E */ INSTCTRL,
	    /* 0x8F */ undefined,
	    /* 0x90 */ undefined,
	    /* 0x91 */ undefined,
	    /* 0x92 */ undefined,
	    /* 0x93 */ undefined,
	    /* 0x94 */ undefined,
	    /* 0x95 */ undefined,
	    /* 0x96 */ undefined,
	    /* 0x97 */ undefined,
	    /* 0x98 */ undefined,
	    /* 0x99 */ undefined,
	    /* 0x9A */ undefined,
	    /* 0x9B */ undefined,
	    /* 0x9C */ undefined,
	    /* 0x9D */ undefined,
	    /* 0x9E */ undefined,
	    /* 0x9F */ undefined,
	    /* 0xA0 */ undefined,
	    /* 0xA1 */ undefined,
	    /* 0xA2 */ undefined,
	    /* 0xA3 */ undefined,
	    /* 0xA4 */ undefined,
	    /* 0xA5 */ undefined,
	    /* 0xA6 */ undefined,
	    /* 0xA7 */ undefined,
	    /* 0xA8 */ undefined,
	    /* 0xA9 */ undefined,
	    /* 0xAA */ undefined,
	    /* 0xAB */ undefined,
	    /* 0xAC */ undefined,
	    /* 0xAD */ undefined,
	    /* 0xAE */ undefined,
	    /* 0xAF */ undefined,
	    /* 0xB0 */ PUSHB.bind(undefined, 1),
	    /* 0xB1 */ PUSHB.bind(undefined, 2),
	    /* 0xB2 */ PUSHB.bind(undefined, 3),
	    /* 0xB3 */ PUSHB.bind(undefined, 4),
	    /* 0xB4 */ PUSHB.bind(undefined, 5),
	    /* 0xB5 */ PUSHB.bind(undefined, 6),
	    /* 0xB6 */ PUSHB.bind(undefined, 7),
	    /* 0xB7 */ PUSHB.bind(undefined, 8),
	    /* 0xB8 */ PUSHW.bind(undefined, 1),
	    /* 0xB9 */ PUSHW.bind(undefined, 2),
	    /* 0xBA */ PUSHW.bind(undefined, 3),
	    /* 0xBB */ PUSHW.bind(undefined, 4),
	    /* 0xBC */ PUSHW.bind(undefined, 5),
	    /* 0xBD */ PUSHW.bind(undefined, 6),
	    /* 0xBE */ PUSHW.bind(undefined, 7),
	    /* 0xBF */ PUSHW.bind(undefined, 8),
	    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
	    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
	    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
	    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
	    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
	    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
	    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
	    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
	    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
	    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
	    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
	    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
	    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
	    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
	    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
	    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
	    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
	    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
	    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
	    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
	    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
	    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
	    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
	    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
	    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
	    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
	    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
	    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
	    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
	    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
	    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
	    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
	    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
	    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
	    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
	    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
	    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
	    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
	    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
	    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
	    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
	    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
	    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
	    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
	    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
	    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
	    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
	    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
	    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
	    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
	    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
	    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
	    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
	    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
	    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
	    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
	    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
	    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
	    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
	    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
	    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
	    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
	    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
	    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
	];

	/*****************************
	  Mathematical Considerations
	******************************

	fv ... refers to freedom vector
	pv ... refers to projection vector
	rp ... refers to reference point
	p  ... refers to to point being operated on
	d  ... refers to distance

	SETRELATIVE:
	============

	case freedom vector == x-axis:
	------------------------------

	                        (pv)
	                     .-'
	              rpd .-'
	               .-*
	          d .-'90°'
	         .-'       '
	      .-'           '
	   *-'               ' b
	  rp                  '
	                       '
	                        '
	            p *----------*-------------- (fv)
	                          pm

	  rpdx = rpx + d * pv.x
	  rpdy = rpy + d * pv.y

	  equation of line b

	   y - rpdy = pvns * (x- rpdx)

	   y = p.y

	   x = rpdx + ( p.y - rpdy ) / pvns


	case freedom vector == y-axis:
	------------------------------

	    * pm
	    |\
	    | \
	    |  \
	    |   \
	    |    \
	    |     \
	    |      \
	    |       \
	    |        \
	    |         \ b
	    |          \
	    |           \
	    |            \    .-' (pv)
	    |         90° \.-'
	    |           .-'* rpd
	    |        .-'
	    *     *-'  d
	    p     rp

	  rpdx = rpx + d * pv.x
	  rpdy = rpy + d * pv.y

	  equation of line b:
	           pvns ... normal slope to pv

	   y - rpdy = pvns * (x - rpdx)

	   x = p.x

	   y = rpdy +  pvns * (p.x - rpdx)



	generic case:
	-------------


	                              .'(fv)
	                            .'
	                          .* pm
	                        .' !
	                      .'    .
	                    .'      !
	                  .'         . b
	                .'           !
	               *              .
	              p               !
	                         90°   .    ... (pv)
	                           ...-*-'''
	                  ...---'''    rpd
	         ...---'''   d
	   *--'''
	  rp

	    rpdx = rpx + d * pv.x
	    rpdy = rpy + d * pv.y

	 equation of line b:
	    pvns... normal slope to pv

	    y - rpdy = pvns * (x - rpdx)

	 equation of freedom vector line:
	    fvs ... slope of freedom vector (=fy/fx)

	    y - py = fvs * (x - px)


	  on pm both equations are true for same x/y

	    y - rpdy = pvns * (x - rpdx)

	    y - py = fvs * (x - px)

	  form to y and set equal:

	    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

	  expand:

	    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

	  switch:

	    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

	  solve for x:

	    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



	          fvs * px - pvns * rpdx + rpdy - py
	    x =  -----------------------------------
	                 fvs - pvns

	  and:

	    y = fvs * (x - px) + py



	INTERPOLATE:
	============

	Examples of point interpolation.

	The weight of the movement of the reference point gets bigger
	the further the other reference point is away, thus the safest
	option (that is avoiding 0/0 divisions) is to weight the
	original distance of the other point by the sum of both distances.

	If the sum of both distances is 0, then move the point by the
	arithmetic average of the movement of both reference points.




	           (+6)
	    rp1o *---->*rp1
	         .     .                          (+12)
	         .     .                  rp2o *---------->* rp2
	         .     .                       .           .
	         .     .                       .           .
	         .    10          20           .           .
	         |.........|...................|           .
	               .   .                               .
	               .   . (+8)                          .
	                po *------>*p                      .
	               .           .                       .
	               .    12     .          24           .
	               |...........|.......................|
	                                  36


	-------



	           (+10)
	    rp1o *-------->*rp1
	         .         .                      (-10)
	         .         .              rp2 *<---------* rpo2
	         .         .                   .         .
	         .         .                   .         .
	         .    10   .          30       .         .
	         |.........|.............................|
	                   .                   .
	                   . (+5)              .
	                po *--->* p            .
	                   .    .              .
	                   .    .   20         .
	                   |....|..............|
	                     5        15


	-------


	           (+10)
	    rp1o *-------->*rp1
	         .         .
	         .         .
	    rp2o *-------->*rp2


	                               (+10)
	                          po *-------->* p

	-------


	           (+10)
	    rp1o *-------->*rp1
	         .         .
	         .         .(+30)
	    rp2o *---------------------------->*rp2


	                                        (+25)
	                          po *----------------------->* p



	vim: set ts=4 sw=4 expandtab:
	*****/

	/**
	 * Converts a string into a list of tokens.
	 */

	/**
	 * Create a new token
	 * @param {string} char a single char
	 */
	function Token(char) {
	    this.char = char;
	    this.state = {};
	    this.activeState = null;
	}

	/**
	 * Create a new context range
	 * @param {number} startIndex range start index
	 * @param {number} endOffset range end index offset
	 * @param {string} contextName owner context name
	 */
	function ContextRange(startIndex, endOffset, contextName) {
	    this.contextName = contextName;
	    this.startIndex = startIndex;
	    this.endOffset = endOffset;
	}

	/**
	 * Check context start and end
	 * @param {string} contextName a unique context name
	 * @param {function} checkStart a predicate function the indicates a context's start
	 * @param {function} checkEnd a predicate function the indicates a context's end
	 */
	function ContextChecker(contextName, checkStart, checkEnd) {
	    this.contextName = contextName;
	    this.openRange = null;
	    this.ranges = [];
	    this.checkStart = checkStart;
	    this.checkEnd = checkEnd;
	}

	/**
	 * Create a context params
	 * @param {array} context a list of items
	 * @param {number} currentIndex current item index
	 */
	function ContextParams(context, currentIndex) {
	    this.context = context;
	    this.index = currentIndex;
	    this.length = context.length;
	    this.current = context[currentIndex];
	    this.backtrack = context.slice(0, currentIndex);
	    this.lookahead = context.slice(currentIndex + 1);
	}

	/**
	 * Create an event instance
	 * @param {string} eventId event unique id
	 */
	function Event(eventId) {
	    this.eventId = eventId;
	    this.subscribers = [];
	}

	/**
	 * Initialize a core events and auto subscribe required event handlers
	 * @param {any} events an object that enlists core events handlers
	 */
	function initializeCoreEvents(events) {
	    var this$1 = this;

	    var coreEvents = [
	        'start', 'end', 'next', 'newToken', 'contextStart',
	        'contextEnd', 'insertToken', 'removeToken', 'removeRange',
	        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'
	    ];

	    coreEvents.forEach(function (eventId) {
	        Object.defineProperty(this$1.events, eventId, {
	            value: new Event(eventId)
	        });
	    });

	    if (!!events) {
	        coreEvents.forEach(function (eventId) {
	            var event = events[eventId];
	            if (typeof event === 'function') {
	                this$1.events[eventId].subscribe(event);
	            }
	        });
	    }
	    var requiresContextUpdate = [
	        'insertToken', 'removeToken', 'removeRange',
	        'replaceToken', 'replaceRange', 'composeRUD'
	    ];
	    requiresContextUpdate.forEach(function (eventId) {
	        this$1.events[eventId].subscribe(
	            this$1.updateContextsRanges
	        );
	    });
	}

	/**
	 * Converts a string into a list of tokens
	 * @param {any} events tokenizer core events
	 */
	function Tokenizer(events) {
	    this.tokens = [];
	    this.registeredContexts = {};
	    this.contextCheckers = [];
	    this.events = {};
	    this.registeredModifiers = [];

	    initializeCoreEvents.call(this, events);
	}

	/**
	 * Sets the state of a token, usually called by a state modifier.
	 * @param {string} key state item key
	 * @param {any} value state item value
	 */
	Token.prototype.setState = function(key, value) {
	    this.state[key] = value;
	    this.activeState = { key: key, value: this.state[key] };
	    return this.activeState;
	};

	Token.prototype.getState = function (stateId) {
	    return this.state[stateId] || null;
	};

	/**
	 * Checks if an index exists in the tokens list.
	 * @param {number} index token index
	 */
	Tokenizer.prototype.inboundIndex = function(index) {
	    return index >= 0 && index < this.tokens.length;
	};

	/**
	 * Compose and apply a list of operations (replace, update, delete)
	 * @param {array} RUDs replace, update and delete operations
	 * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)
	 */
	Tokenizer.prototype.composeRUD = function (RUDs) {
	    var this$1 = this;

	    var silent = true;
	    var state = RUDs.map(function (RUD) { return (
	        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))
	    ); });
	    var hasFAILObject = function (obj) { return (
	        typeof obj === 'object' &&
	        obj.hasOwnProperty('FAIL')
	    ); };
	    if (state.every(hasFAILObject)) {
	        return {
	            FAIL: "composeRUD: one or more operations hasn't completed successfully",
	            report: state.filter(hasFAILObject)
	        };
	    }
	    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);
	};

	/**
	 * Replace a range of tokens with a list of tokens
	 * @param {number} startIndex range start index
	 * @param {number} offset range offset
	 * @param {token} tokens a list of tokens to replace
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {
	    offset = offset !== null ? offset : this.tokens.length;
	    var isTokenType = tokens.every(function (token) { return token instanceof Token; });
	    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
	        var replaced = this.tokens.splice.apply(
	            this.tokens, [startIndex, offset].concat(tokens)
	        );
	        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }
	        return [replaced, tokens];
	    } else {
	        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };
	    }
	};

	/**
	 * Replace a token with another token
	 * @param {number} index token index
	 * @param {token} token a token to replace
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.replaceToken = function (index, token, silent) {
	    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
	        var replaced = this.tokens.splice(index, 1, token);
	        if (!silent) { this.dispatch('replaceToken', [index, token]); }
	        return [replaced[0], token];
	    } else {
	        return { FAIL: 'replaceToken: invalid token or index.' };
	    }
	};

	/**
	 * Removes a range of tokens
	 * @param {number} startIndex range start index
	 * @param {number} offset range offset
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
	    offset = !isNaN(offset) ? offset : this.tokens.length;
	    var tokens = this.tokens.splice(startIndex, offset);
	    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }
	    return tokens;
	};

	/**
	 * Remove a token at a certain index
	 * @param {number} index token index
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.removeToken = function(index, silent) {
	    if (!isNaN(index) && this.inboundIndex(index)) {
	        var token = this.tokens.splice(index, 1);
	        if (!silent) { this.dispatch('removeToken', [token, index]); }
	        return token;
	    } else {
	        return { FAIL: 'removeToken: invalid token index.' };
	    }
	};

	/**
	 * Insert a list of tokens at a certain index
	 * @param {array} tokens a list of tokens to insert
	 * @param {number} index insert the list of tokens at index
	 * @param {boolean} silent dispatch events and update context ranges
	 */
	Tokenizer.prototype.insertToken = function (tokens, index, silent) {
	    var tokenType = tokens.every(
	        function (token) { return token instanceof Token; }
	    );
	    if (tokenType) {
	        this.tokens.splice.apply(
	            this.tokens, [index, 0].concat(tokens)
	        );
	        if (!silent) { this.dispatch('insertToken', [tokens, index]); }
	        return tokens;
	    } else {
	        return { FAIL: 'insertToken: invalid token(s).' };
	    }
	};

	/**
	 * A state modifier that is called on 'newToken' event
	 * @param {string} modifierId state modifier id
	 * @param {function} condition a predicate function that returns true or false
	 * @param {function} modifier a function to update token state
	 */
	Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
	    this.events.newToken.subscribe(function(token, contextParams) {
	        var conditionParams = [token, contextParams];
	        var canApplyModifier = (
	            condition === null ||
	            condition.apply(this, conditionParams) === true
	        );
	        var modifierParams = [token, contextParams];
	        if (canApplyModifier) {
	            var newStateValue = modifier.apply(this, modifierParams);
	            token.setState(modifierId, newStateValue);
	        }
	    });
	    this.registeredModifiers.push(modifierId);
	};

	/**
	 * Subscribe a handler to an event
	 * @param {function} eventHandler an event handler function
	 */
	Event.prototype.subscribe = function (eventHandler) {
	    if (typeof eventHandler === 'function') {
	        return ((this.subscribers.push(eventHandler)) - 1);
	    } else {
	        return { FAIL: ("invalid '" + (this.eventId) + "' event handler")};
	    }
	};

	/**
	 * Unsubscribe an event handler
	 * @param {string} subsId subscription id
	 */
	Event.prototype.unsubscribe = function (subsId) {
	    this.subscribers.splice(subsId, 1);
	};

	/**
	 * Sets context params current value index
	 * @param {number} index context params current value index
	 */
	ContextParams.prototype.setCurrentIndex = function(index) {
	    this.index = index;
	    this.current = this.context[index];
	    this.backtrack = this.context.slice(0, index);
	    this.lookahead = this.context.slice(index + 1);
	};

	/**
	 * Get an item at an offset from the current value
	 * example (current value is 3):
	 *  1    2   [3]   4    5   |   items values
	 * -2   -1    0    1    2   |   offset values
	 * @param {number} offset an offset from current value index
	 */
	ContextParams.prototype.get = function (offset) {
	    switch (true) {
	        case (offset === 0):
	            return this.current;
	        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
	            return this.backtrack.slice(offset)[0];
	        case (offset > 0 && offset <= this.lookahead.length):
	            return this.lookahead[offset - 1];
	        default:
	            return null;
	    }
	};

	/**
	 * Converts a context range into a string value
	 * @param {contextRange} range a context range
	 */
	Tokenizer.prototype.rangeToText = function (range) {
	    if (range instanceof ContextRange) {
	        return (
	            this.getRangeTokens(range)
	                .map(function (token) { return token.char; }).join('')
	        );
	    }
	};

	/**
	 * Converts all tokens into a string
	 */
	Tokenizer.prototype.getText = function () {
	    return this.tokens.map(function (token) { return token.char; }).join('');
	};

	/**
	 * Get a context by name
	 * @param {string} contextName context name to get
	 */
	Tokenizer.prototype.getContext = function (contextName) {
	    var context = this.registeredContexts[contextName];
	    return !!context ? context : null;
	};

	/**
	 * Subscribes a new event handler to an event
	 * @param {string} eventName event name to subscribe to
	 * @param {function} eventHandler a function to be invoked on event
	 */
	Tokenizer.prototype.on = function(eventName, eventHandler) {
	    var event = this.events[eventName];
	    if (!!event) {
	        return event.subscribe(eventHandler);
	    } else {
	        return null;
	    }
	};

	/**
	 * Dispatches an event
	 * @param {string} eventName event name
	 * @param {any} args event handler arguments
	 */
	Tokenizer.prototype.dispatch = function(eventName, args) {
	    var this$1 = this;

	    var event = this.events[eventName];
	    if (event instanceof Event) {
	        event.subscribers.forEach(function (subscriber) {
	            subscriber.apply(this$1, args || []);
	        });
	    }
	};

	/**
	 * Register a new context checker
	 * @param {string} contextName a unique context name
	 * @param {function} contextStartCheck a predicate function that returns true on context start
	 * @param {function} contextEndCheck  a predicate function that returns true on context end
	 * TODO: call tokenize on registration to update context ranges with the new context.
	 */
	Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
	    if (!!this.getContext(contextName)) { return {
	        FAIL:
	        ("context name '" + contextName + "' is already registered.")
	    }; }
	    if (typeof contextStartCheck !== 'function') { return {
	        FAIL:
	        "missing context start check."
	    }; }
	    if (typeof contextEndCheck !== 'function') { return {
	        FAIL:
	        "missing context end check."
	    }; }
	    var contextCheckers = new ContextChecker(
	        contextName, contextStartCheck, contextEndCheck
	    );
	    this.registeredContexts[contextName] = contextCheckers;
	    this.contextCheckers.push(contextCheckers);
	    return contextCheckers;
	};

	/**
	 * Gets a context range tokens
	 * @param {contextRange} range a context range
	 */
	Tokenizer.prototype.getRangeTokens = function(range) {
	    var endIndex = range.startIndex + range.endOffset;
	    return [].concat(
	        this.tokens
	            .slice(range.startIndex, endIndex)
	    );
	};

	/**
	 * Gets the ranges of a context
	 * @param {string} contextName context name
	 */
	Tokenizer.prototype.getContextRanges = function(contextName) {
	    var context = this.getContext(contextName);
	    if (!!context) {
	        return context.ranges;
	    } else {
	        return { FAIL: ("context checker '" + contextName + "' is not registered.") };
	    }
	};

	/**
	 * Resets context ranges to run context update
	 */
	Tokenizer.prototype.resetContextsRanges = function () {
	    var registeredContexts = this.registeredContexts;
	    for (var contextName in registeredContexts) {
	        if (registeredContexts.hasOwnProperty(contextName)) {
	            var context = registeredContexts[contextName];
	            context.ranges = [];
	        }
	    }
	};

	/**
	 * Updates context ranges
	 */
	Tokenizer.prototype.updateContextsRanges = function () {
	    var this$1 = this;

	    this.resetContextsRanges();
	    var chars = this.tokens.map(function (token) { return token.char; });
	    for (var i = 0; i < chars.length; i++) {
	        var contextParams = new ContextParams(chars, i);
	        this$1.runContextCheck(contextParams);
	    }
	    this.dispatch('updateContextsRanges', [this.registeredContexts]);
	};

	/**
	 * Sets the end offset of an open range
	 * @param {number} offset range end offset
	 * @param {string} contextName context name
	 */
	Tokenizer.prototype.setEndOffset = function (offset, contextName) {
	    var startIndex = this.getContext(contextName).openRange.startIndex;
	    var range = new ContextRange(startIndex, offset, contextName);
	    var ranges = this.getContext(contextName).ranges;
	    range.rangeId = contextName + "." + (ranges.length);
	    ranges.push(range);
	    this.getContext(contextName).openRange = null;
	    return range;
	};

	/**
	 * Runs a context check on the current context
	 * @param {contextParams} contextParams current context params
	 */
	Tokenizer.prototype.runContextCheck = function(contextParams) {
	    var this$1 = this;

	    var index = contextParams.index;
	    this.contextCheckers.forEach(function (contextChecker) {
	        var contextName = contextChecker.contextName;
	        var openRange = this$1.getContext(contextName).openRange;
	        if (!openRange && contextChecker.checkStart(contextParams)) {
	            openRange = new ContextRange(index, null, contextName);
	            this$1.getContext(contextName).openRange = openRange;
	            this$1.dispatch('contextStart', [contextName, index]);
	        }
	        if (!!openRange && contextChecker.checkEnd(contextParams)) {
	            var offset = (index - openRange.startIndex) + 1;
	            var range = this$1.setEndOffset(offset, contextName);
	            this$1.dispatch('contextEnd', [contextName, range]);
	        }
	    });
	};

	/**
	 * Converts a text into a list of tokens
	 * @param {string} text a text to tokenize
	 */
	Tokenizer.prototype.tokenize = function (text) {
	    var this$1 = this;

	    this.tokens = [];
	    this.resetContextsRanges();
	    var chars = Array.from(text);
	    this.dispatch('start');
	    for (var i = 0; i < chars.length; i++) {
	        var char = chars[i];
	        var contextParams = new ContextParams(chars, i);
	        this$1.dispatch('next', [contextParams]);
	        this$1.runContextCheck(contextParams);
	        var token = new Token(char);
	        this$1.tokens.push(token);
	        this$1.dispatch('newToken', [token, contextParams]);
	    }
	    this.dispatch('end', [this.tokens]);
	    return this.tokens;
	};

	// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮
	// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊
	// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯
	// jscs:disable maximumLineLength
	/**
	 * Check if a char is Arabic
	 * @param {string} c a single char
	 */
	function isArabicChar(c) {
	    return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
	}

	/**
	 * Check if a char is an isolated arabic char
	 * @param {string} c a single char
	 */
	function isIsolatedArabicChar(char) {
	    return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
	}

	/**
	 * Check if a char is an Arabic Tashkeel char
	 * @param {string} c a single char
	 */
	function isTashkeelArabicChar(char) {
	    return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
	}

	/**
	 * Check if a char is whitespace char
	 * @param {string} c a single char
	 */
	function isWhiteSpace(c) {
	    return /\s/.test(c);
	}

	/**
	 * Arabic word context checkers
	 */

	function arabicWordStartCheck(contextParams) {
	    var char = contextParams.current;
	    var prevChar = contextParams.get(-1);
	    return (
	        // ? arabic first char
	        (prevChar === null && isArabicChar(char)) ||
	        // ? arabic char preceded with a non arabic char
	        (!isArabicChar(prevChar) && isArabicChar(char))
	    );
	}

	function arabicWordEndCheck(contextParams) {
	    var nextChar = contextParams.get(1);
	    return (
	        // ? last arabic char
	        (nextChar === null) ||
	        // ? next char is not arabic
	        (!isArabicChar(nextChar))
	    );
	}
	var arabicWordCheck = { arabicWordStartCheck: arabicWordStartCheck, arabicWordEndCheck: arabicWordEndCheck };

	/**
	 * Arabic sentence context checkers
	 */

	function arabicSentenceStartCheck(contextParams) {
	    var char = contextParams.current;
	    var prevChar = contextParams.get(-1);
	    return (
	        // ? an arabic char preceded with a non arabic char
	        (isArabicChar(char) || isTashkeelArabicChar(char)) &&
	        !isArabicChar(prevChar)
	    );
	}

	function arabicSentenceEndCheck(contextParams) {
	    var nextChar = contextParams.get(1);
	    switch (true) {
	        case nextChar === null:
	            return true;
	        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
	            var nextIsWhitespace = isWhiteSpace(nextChar);
	            if (!nextIsWhitespace) { return true; }
	            if (nextIsWhitespace) {
	                var arabicCharAhead = false;
	                arabicCharAhead = (
	                    contextParams.lookahead.some(
	                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }
	                    )
	                );
	                if (!arabicCharAhead) { return true; }
	            }
	            break;
	        default:
	            return false;
	    }
	}
	var arabicSentenceCheck = { arabicSentenceStartCheck: arabicSentenceStartCheck, arabicSentenceEndCheck: arabicSentenceEndCheck };

	/**
	 * Apply Arabic presentation forms to a range of tokens
	 */
	/**
	 * Check if a char can be connected to it's preceding char
	 * @param {ContextParams} charContextParams context params of a char
	 */
	function willConnectPrev(charContextParams) {
	    var backtrack = [].concat(charContextParams.backtrack);
	    for (var i = backtrack.length - 1; i >= 0; i--) {
	        var prevChar = backtrack[i];
	        var isolated = isIsolatedArabicChar(prevChar);
	        var tashkeel = isTashkeelArabicChar(prevChar);
	        if (!isolated && !tashkeel) { return true; }
	        if (isolated) { return false; }
	    }
	    return false;
	}

	/**
	 * Check if a char can be connected to it's proceeding char
	 * @param {ContextParams} charContextParams context params of a char
	 */
	function willConnectNext(charContextParams) {
	    if (isIsolatedArabicChar(charContextParams.current)) { return false; }
	    for (var i = 0; i < charContextParams.lookahead.length; i++) {
	        var nextChar = charContextParams.lookahead[i];
	        var tashkeel = isTashkeelArabicChar(nextChar);
	        if (!tashkeel) { return true; }
	    }
	    return false;
	}

	/**
	 * Apply arabic presentation forms to a list of tokens
	 * @param {ContextRange} range a range of tokens
	 */
	function arabicPresentationForms(range) {
	    var features = this.features.arab;
	    var rangeTokens = this.tokenizer.getRangeTokens(range);
	    if (rangeTokens.length === 1) { return; }
	    var getSubstitutionIndex = function (substitution) { return (
	        substitution.length === 1 &&
	        substitution[0].id === 12 &&
	        substitution[0].substitution
	    ); };
	    var applyForm = function (tag, token, params) {
	        if (!features.hasOwnProperty(tag)) { return; }
	        var substitution = features[tag].lookup(params) || null;
	        var substIndex = getSubstitutionIndex(substitution)[0];
	        if (substIndex >= 0) {
	            return token.setState(tag, substIndex);
	        }
	    };
	    var tokensParams = new ContextParams(rangeTokens, 0);
	    var charContextParams = new ContextParams(rangeTokens.map(function (t){ return t.char; }), 0);
	    rangeTokens.forEach(function (token, i) {
	        if (isTashkeelArabicChar(token.char)) { return; }
	        tokensParams.setCurrentIndex(i);
	        charContextParams.setCurrentIndex(i);
	        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)
	        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }
	        if (willConnectNext(charContextParams)) { CONNECT |= 2; }
	        switch (CONNECT) {
	            case 0: // isolated * original form
	                return;
	            case 1: // fina
	                applyForm('fina', token, tokensParams);
	                break;
	            case 2: // init
	                applyForm('init', token, tokensParams);
	                break;
	            case 3: // medi
	                applyForm('medi', token, tokensParams);
	                break;
	        }
	    });
	}

	/**
	 * Apply Arabic required ligatures feature to a range of tokens
	 */

	/**
	 * Apply Arabic required ligatures to a context range
	 * @param {ContextRange} range a range of tokens
	 */
	function arabicRequiredLigatures(range) {
	    var features = this.features.arab;
	    if (!features.hasOwnProperty('rlig')) { return; }
	    var tokens = this.tokenizer.getRangeTokens(range);
	    for (var i = 0; i < tokens.length; i++) {
	        var lookupParams = new ContextParams(tokens, i);
	        var substitution = features.rlig.lookup(lookupParams) || null;
	        var chainingContext = (
	            substitution.length === 1 &&
	            substitution[0].id === 63 &&
	            substitution[0].substitution
	        );
	        var ligature = (
	            substitution.length === 1 &&
	            substitution[0].id === 41 &&
	            substitution[0].substitution[0]
	        );
	        var token = tokens[i];
	        if (!!ligature) {
	            token.setState('rlig', [ligature.ligGlyph]);
	            for (var c = 0; c < ligature.components.length; c++) {
	                var component = ligature.components[c];
	                var lookaheadToken = lookupParams.get(c + 1);
	                if (lookaheadToken.activeState.value === component) {
	                    lookaheadToken.state.deleted = true;
	                }
	            }
	        } else if (chainingContext) {
	            var substIndex = (
	                chainingContext &&
	                chainingContext.length === 1 &&
	                chainingContext[0].id === 12 &&
	                chainingContext[0].substitution
	            );
	            if (!!substIndex && substIndex >= 0) { token.setState('rlig', substIndex); }
	        }
	    }
	}

	/**
	 * Infer bidirectional properties for a given text and apply
	 * the corresponding layout rules.
	 */

	/**
	 * Create Bidi. features
	 * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'
	 */
	function Bidi(baseDir) {
	    this.baseDir = baseDir || 'ltr';
	    this.tokenizer = new Tokenizer();
	    this.features = [];
	}

	/**
	 * Sets Bidi text
	 * @param {string} text a text input
	 */
	Bidi.prototype.setText = function (text) {
	    this.text = text;
	};

	/**
	 * Store essential context checks:
	 * arabic word check for applying gsub features
	 * arabic sentence check for adjusting arabic layout
	 */
	Bidi.prototype.contextChecks = ({
	    arabicWordCheck: arabicWordCheck,
	    arabicSentenceCheck: arabicSentenceCheck
	});

	/**
	 * Register arabic word check
	 */
	function registerArabicWordCheck() {
	    var checks = this.contextChecks.arabicWordCheck;
	    return this.tokenizer.registerContextChecker(
	        'arabicWord',
	        checks.arabicWordStartCheck,
	        checks.arabicWordEndCheck
	    );
	}

	/**
	 * Register arabic sentence check
	 */
	function registerArabicSentenceCheck() {
	    var checks = this.contextChecks.arabicSentenceCheck;
	    return this.tokenizer.registerContextChecker(
	        'arabicSentence',
	        checks.arabicSentenceStartCheck,
	        checks.arabicSentenceEndCheck
	    );
	}

	/**
	 * Perform pre tokenization procedure then
	 * tokenize text input
	 */
	function tokenizeText() {
	    registerArabicWordCheck.call(this);
	    registerArabicSentenceCheck.call(this);
	    return this.tokenizer.tokenize(this.text);
	}

	/**
	 * Reverse arabic sentence layout
	 * TODO: check base dir before applying adjustments - priority low
	 */
	function reverseArabicSentences() {
	    var this$1 = this;

	    var ranges = this.tokenizer.getContextRanges('arabicSentence');
	    ranges.forEach(function (range) {
	        var rangeTokens = this$1.tokenizer.getRangeTokens(range);
	        this$1.tokenizer.replaceRange(
	            range.startIndex,
	            range.endOffset,
	            rangeTokens.reverse()
	        );
	    });
	}

	/**
	 * Subscribe arabic presentation form features
	 * @param {feature} feature a feature to apply
	 */
	Bidi.prototype.subscribeArabicForms = function(feature) {
	    var this$1 = this;

	    this.tokenizer.events.contextEnd.subscribe(
	        function (contextName, range) {
	            if (contextName === 'arabicWord') {
	                return arabicPresentationForms.call(
	                    this$1.tokenizer, range, feature
	                );
	            }
	        }
	    );
	};

	/**
	 * Apply Gsub features
	 * @param {feature} features a list of features
	 */
	Bidi.prototype.applyFeatures = function (features) {
	    var this$1 = this;

	    for (var i = 0; i < features.length; i++) {
	        var feature = features[i];
	        if (feature) {
	            var script = feature.script;
	            if (!this$1.features[script]) {
	                this$1.features[script] = {};
	            }
	            this$1.features[script][feature.tag] = feature;
	        }
	    }
	};

	/**
	 * Register a state modifier
	 * @param {string} modifierId state modifier id
	 * @param {function} condition a predicate function that returns true or false
	 * @param {function} modifier a modifier function to set token state
	 */
	Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {
	    this.tokenizer.registerModifier(modifierId, condition, modifier);
	};

	/**
	 * Check if 'glyphIndex' is registered
	 */
	function checkGlyphIndexStatus() {
	    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {
	        throw new Error(
	            'glyphIndex modifier is required to apply ' +
	            'arabic presentation features.'
	        );
	    }
	}

	/**
	 * Apply arabic presentation forms features
	 */
	function applyArabicPresentationForms() {
	    var this$1 = this;

	    if (!this.features.hasOwnProperty('arab')) { return; }
	    checkGlyphIndexStatus.call(this);
	    var ranges = this.tokenizer.getContextRanges('arabicWord');
	    ranges.forEach(function (range) {
	        arabicPresentationForms.call(this$1, range);
	    });
	}

	/**
	 * Apply required arabic ligatures
	 */
	function applyArabicRequireLigatures() {
	    var this$1 = this;

	    if (!this.features.hasOwnProperty('arab')) { return; }
	    if (!this.features.arab.hasOwnProperty('rlig')) { return; }
	    checkGlyphIndexStatus.call(this);
	    var ranges = this.tokenizer.getContextRanges('arabicWord');
	    ranges.forEach(function (range) {
	        arabicRequiredLigatures.call(this$1, range);
	    });
	}

	/**
	 * process text input
	 * @param {string} text an input text
	 */
	Bidi.prototype.processText = function(text) {
	    if (!this.text || this.text !== text) {
	        this.setText(text);
	        tokenizeText.call(this);
	        applyArabicPresentationForms.call(this);
	        applyArabicRequireLigatures.call(this);
	        reverseArabicSentences.call(this);
	    }
	};

	/**
	 * Process a string of text to identify and adjust
	 * bidirectional text entities.
	 * @param {string} text input text
	 */
	Bidi.prototype.getBidiText = function (text) {
	    this.processText(text);
	    return this.tokenizer.getText();
	};

	/**
	 * Get the current state index of each token
	 * @param {text} text an input text
	 */
	Bidi.prototype.getTextGlyphs = function (text) {
	    var this$1 = this;

	    this.processText(text);
	    var indexes = [];
	    for (var i = 0; i < this.tokenizer.tokens.length; i++) {
	        var token = this$1.tokenizer.tokens[i];
	        if (token.state.deleted) { continue; }
	        var index = token.activeState.value;
	        indexes.push(Array.isArray(index) ? index[0] : index);
	    }
	    return indexes;
	};

	/**
	 * Query a feature by some of it's properties to lookup a glyph substitution.
	 */

	// DEFAULT TEXT BASE DIRECTION
	var BASE_DIR = 'ltr';

	/**
	 * Create feature query instance
	 * @param {Font} font opentype font instance
	 * @param {string} baseDir text base direction
	 */
	function FeatureQuery(font, baseDir) {
	    this.font = font;
	    this.features = {};
	    BASE_DIR = !!baseDir ? baseDir : BASE_DIR;
	}

	/**
	 * Create a new feature lookup
	 * @param {string} tag feature tag
	 * @param {feature} feature reference to feature at gsub table
	 * @param {FeatureLookups} feature lookups associated with this feature
	 * @param {string} script gsub script tag
	 */
	function Feature(tag, feature, featureLookups, script) {
	    this.tag = tag;
	    this.featureRef = feature;
	    this.lookups = featureLookups.lookups;
	    this.script = script;
	}

	/**
	 * Create a coverage table lookup
	 * @param {any} coverageTable gsub coverage table
	 */
	function Coverage$1(coverageTable) {
	    this.table = coverageTable;
	}

	/**
	 * Create a ligature set lookup
	 * @param {any} ligatureSets gsub ligature set
	 */
	function LigatureSets(ligatureSets) {
	    this.ligatureSets = ligatureSets;
	}

	/**
	 * Lookup a glyph ligature
	 * @param {ContextParams} contextParams context params to lookup
	 * @param {number} ligSetIndex ligature set index at ligature sets
	 */
	LigatureSets.prototype.lookup = function (contextParams, ligSetIndex) {
	    var ligatureSet = this.ligatureSets[ligSetIndex];
	    var matchComponents = function (components, indexes) {
	        if (components.length > indexes.length) { return null; }
	        for (var c = 0; c < components.length; c++) {
	            var component = components[c];
	            var index = indexes[c];
	            if (component !== index) { return false; }
	        }
	        return true;
	    };
	    for (var s = 0; s < ligatureSet.length; s++) {
	        var ligSetItem = ligatureSet[s];
	        var lookaheadIndexes = contextParams.lookahead.map(
	            function (token) { return token.activeState.value; }
	        );
	        if (BASE_DIR === 'rtl') { lookaheadIndexes.reverse(); }
	        var componentsMatch = matchComponents(
	            ligSetItem.components, lookaheadIndexes
	        );
	        if (componentsMatch) { return ligSetItem; }
	    }
	    return null;
	};

	/**
	 * Create a feature substitution
	 * @param {any} lookups a reference to gsub lookups
	 * @param {Lookuptable} lookupTable a feature lookup table
	 * @param {any} subtable substitution table
	 */
	function Substitution$1(lookups, lookupTable, subtable) {
	    this.lookups = lookups;
	    this.subtable = subtable;
	    this.lookupTable = lookupTable;
	    if (subtable.hasOwnProperty('coverage')) {
	        this.coverage = new Coverage$1(
	            subtable.coverage
	        );
	    }
	    if (subtable.hasOwnProperty('inputCoverage')) {
	        this.inputCoverage = subtable.inputCoverage.map(
	            function (table) { return new Coverage$1(table); }
	        );
	    }
	    if (subtable.hasOwnProperty('backtrackCoverage')) {
	        this.backtrackCoverage = subtable.backtrackCoverage.map(
	            function (table) { return new Coverage$1(table); }
	        );
	    }
	    if (subtable.hasOwnProperty('lookaheadCoverage')) {
	        this.lookaheadCoverage = subtable.lookaheadCoverage.map(
	            function (table) { return new Coverage$1(table); }
	        );
	    }
	    if (subtable.hasOwnProperty('ligatureSets')) {
	        this.ligatureSets = new LigatureSets(subtable.ligatureSets);
	    }
	}

	/**
	 * Create a lookup table lookup
	 * @param {number} index table index at gsub lookups
	 * @param {any} lookups a reference to gsub lookups
	 */
	function LookupTable(index, lookups) {
	    this.index = index;
	    this.subtables = lookups[index].subtables.map(
	        function (subtable) { return new Substitution$1(
	            lookups, lookups[index], subtable
	        ); }
	    );
	}

	function FeatureLookups(lookups, lookupListIndexes) {
	    this.lookups = lookupListIndexes.map(
	        function (index) { return new LookupTable(index, lookups); }
	    );
	}

	/**
	 * Lookup a lookup table subtables
	 * @param {ContextParams} contextParams context params to lookup
	 */
	LookupTable.prototype.lookup = function (contextParams) {
	    var this$1 = this;

	    var substitutions = [];
	    for (var i = 0; i < this.subtables.length; i++) {
	        var subsTable = this$1.subtables[i];
	        var substitution = subsTable.lookup(contextParams);
	        if (substitution !== null || substitution.length) {
	            substitutions = substitutions.concat(substitution);
	        }
	    }
	    return substitutions;
	};

	/**
	 * Handle a single substitution - format 2
	 * @param {ContextParams} contextParams context params to lookup
	 */
	function singleSubstitutionFormat2(contextParams) {
	    var glyphIndex = contextParams.current.activeState.value;
	    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
	    var substituteIndex = this.coverage.lookup(glyphIndex);
	    if (substituteIndex === -1) { return []; }
	    return [this.subtable.substitute[substituteIndex]];
	}

	/**
	 * Lookup a list of coverage tables
	 * @param {any} coverageList a list of coverage tables
	 * @param {any} contextParams context params to lookup
	 */
	function lookupCoverageList(coverageList, contextParams) {
	    var lookupList = [];
	    for (var i = 0; i < coverageList.length; i++) {
	        var coverage = coverageList[i];
	        var glyphIndex = contextParams.current.activeState.value;
	        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
	        var lookupIndex = coverage.lookup(glyphIndex);
	        if (lookupIndex !== -1) {
	            lookupList.push(lookupIndex);
	        }
	    }
	    if (lookupList.length !== coverageList.length) { return -1; }
	    return lookupList;
	}

	/**
	 * Handle chaining context substitution - format 3
	 * @param {any} contextParams context params to lookup
	 */
	function chainingSubstitutionFormat3(contextParams) {
	    var this$1 = this;

	    var lookupsCount = (
	        this.inputCoverage.length +
	        this.lookaheadCoverage.length +
	        this.backtrackCoverage.length
	    );
	    if (contextParams.context.length < lookupsCount) { return []; }
	    // INPUT LOOKUP //
	    var inputLookups = lookupCoverageList(
	        this.inputCoverage, contextParams
	    );
	    if (inputLookups === -1) { return []; }
	    // LOOKAHEAD LOOKUP //
	    var lookaheadOffset = this.inputCoverage.length - 1;
	    if (contextParams.lookahead.length < this.lookaheadCoverage.length) { return []; }
	    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
	    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
	        lookaheadContext.shift();
	    }
	    var lookaheadParams = new ContextParams(lookaheadContext, 0);
	    var lookaheadLookups = lookupCoverageList(
	        this.lookaheadCoverage, lookaheadParams
	    );
	    // BACKTRACK LOOKUP //
	    var backtrackContext = [].concat(contextParams.backtrack);
	    backtrackContext.reverse();
	    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
	        backtrackContext.shift();
	    }
	    if (backtrackContext.length < this.backtrackCoverage.length) { return []; }
	    var backtrackParams = new ContextParams(backtrackContext, 0);
	    var backtrackLookups = lookupCoverageList(
	        this.backtrackCoverage, backtrackParams
	    );
	    var contextRulesMatch = (
	        inputLookups.length === this.inputCoverage.length &&
	        lookaheadLookups.length === this.lookaheadCoverage.length &&
	        backtrackLookups.length === this.backtrackCoverage.length
	    );
	    var substitutions = [];
	    if (contextRulesMatch) {
	        var lookupRecords = this.subtable.lookupRecords;
	        for (var i = 0; i < lookupRecords.length; i++) {
	            var lookupRecord = lookupRecords[i];
	            for (var j = 0; j < inputLookups.length; j++) {
	                var inputContext = new ContextParams([contextParams.get(j)], 0);
	                var lookupIndex = lookupRecord.lookupListIndex;
	                var lookupTable = new LookupTable(lookupIndex, this$1.lookups);
	                var lookup = lookupTable.lookup(inputContext);
	                substitutions = substitutions.concat(lookup);
	            }
	        }
	    }
	    return substitutions;
	}

	/**
	 * Handle ligature substitution - format 1
	 * @param {any} contextParams context params to lookup
	 */
	function ligatureSubstitutionFormat1(contextParams) {
	    // COVERAGE LOOKUP //
	    var glyphIndex = contextParams.current.activeState.value;
	    var ligSetIndex = this.coverage.lookup(glyphIndex);
	    if (ligSetIndex === -1) { return []; }
	    // COMPONENTS LOOKUP * note that components is logically ordered
	    var ligGlyphs = this.ligatureSets.lookup(contextParams, ligSetIndex);
	    return ligGlyphs ? [ligGlyphs] : [];
	}

	/**
	 * [ LOOKUP TYPES ]
	 * -------------------------------
	 * Single                        1;
	 * Multiple                      2;
	 * Alternate                     3;
	 * Ligature                      4;
	 * Context                       5;
	 * ChainingContext               6;
	 * ExtensionSubstitution         7;
	 * ReverseChainingContext        8;
	 * -------------------------------
	 * @param {any} contextParams context params to lookup
	 */
	Substitution$1.prototype.lookup = function (contextParams) {
	    var substitutions = [];
	    var lookupType = this.lookupTable.lookupType;
	    var substFormat = this.subtable.substFormat;
	    if (lookupType === 1 && substFormat === 2) {
	        var substitution = singleSubstitutionFormat2.call(this, contextParams);
	        if (substitution.length > 0) {
	            substitutions.push({ id: 12, substitution: substitution });
	        }
	    }
	    if (lookupType === 6 && substFormat === 3) {
	        var substitution$1 = chainingSubstitutionFormat3.call(this, contextParams);
	        if (substitution$1.length > 0) {
	            substitutions.push({ id: 63, substitution: substitution$1 });
	        }
	    }
	    if (lookupType === 4 && substFormat === 1) {
	        var substitution$2 = ligatureSubstitutionFormat1.call(this, contextParams);
	        if (substitution$2.length > 0) {
	            substitutions.push({ id: 41, substitution: substitution$2 });
	        }
	    }
	    return substitutions;
	};

	/**
	 * Lookup a coverage table
	 * @param {number} glyphIndex to lookup
	 */
	Coverage$1.prototype.lookup = function (glyphIndex) {
	    if (!glyphIndex) { return -1; }
	    switch (this.table.format) {
	        case 1:
	            return this.table.glyphs.indexOf(glyphIndex);

	        case 2:
	            var ranges = this.table.ranges;
	            for (var i = 0; i < ranges.length; i++) {
	                var range = ranges[i];
	                if (glyphIndex >= range.start && glyphIndex <= range.end) {
	                    var offset = glyphIndex - range.start;
	                    return range.index + offset;
	                }
	            }
	            break;
	        default:
	            return -1; // not found
	    }
	    return -1;
	};

	/**
	 * Lookup a feature for a substitution or more
	 * @param {any} contextParams context params to lookup
	 */
	Feature.prototype.lookup = function(contextParams) {
	    var this$1 = this;

	    var lookups = [];
	    for (var i = 0; i < this.lookups.length; i++) {
	        var lookupTable = this$1.lookups[i];
	        var lookup = lookupTable.lookup(contextParams);
	        if (lookup !== null || lookup.length) {
	            lookups = lookups.concat(lookup);
	        }
	    }
	    return lookups;
	};

	/**
	 * Get feature indexes of a specific script
	 * @param {string} scriptTag script tag
	 */
	FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
	    if (!scriptTag) { return []; }
	    var tables = this.font.tables;
	    if (!tables.gsub) { return []; }
	    var scripts = this.font.tables.gsub.scripts;
	    for (var i = 0; i < scripts.length; i++) {
	        var script = scripts[i];
	        if (script.tag === scriptTag) {
	            var defaultLangSys = script.script.defaultLangSys;
	            return defaultLangSys.featureIndexes;
	        } else {
	            var langSysRecords = script.langSysRecords;
	            if (!!langSysRecords) {
	                for (var j = 0; j < langSysRecords.length; j++) {
	                    var langSysRecord = langSysRecords[j];
	                    if (langSysRecord.tag === scriptTag) {
	                        var langSys = langSysRecord.langSys;
	                        return langSys.featureIndexes;
	                    }
	                }
	            }
	        }
	    }
	    return [];
	};

	/**
	 * Map a feature tag to a gsub feature
	 * @param {any} features gsub features
	 * @param {*} scriptTag script tag
	 */
	FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {
	    var this$1 = this;

	    var tags = {};
	    for (var i = 0; i < features.length; i++) {
	        var feature = features[i].feature;
	        var tag = features[i].tag;
	        var lookups = this$1.font.tables.gsub.lookups;
	        var featureLookups = new FeatureLookups(lookups, feature.lookupListIndexes);
	        tags[tag] = new Feature(tag, feature, featureLookups, scriptTag);
	    }
	    this.features[scriptTag].tags = tags;
	};

	/**
	 * Get features of a specific script
	 * @param {string} scriptTag script tag
	 */
	FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {
	    var features = this.features[scriptTag];
	    if (this.features.hasOwnProperty(scriptTag)) { return features; }
	    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
	    if (!featuresIndexes) { return null; }
	    var gsub = this.font.tables.gsub;
	    features = featuresIndexes.map(function (index) { return gsub.features[index]; });
	    this.features[scriptTag] = features;
	    this.mapTagsToFeatures(features, scriptTag);
	    return features;
	};

	/**
	 * Query a feature by it's properties
	 * @param {any} query an object that describes the properties of a query
	 */
	FeatureQuery.prototype.getFeature = function (query) {
	    if (!this.font) { return { FAIL: "No font was found"}; }
	    if (!this.features.hasOwnProperty(query.script)) {
	        this.getScriptFeatures(query.script);
	    }
	    return this.features[query.script].tags[query.tag] || null;
	};

	// The Font object

	/**
	 * @typedef FontOptions
	 * @type Object
	 * @property {Boolean} empty - whether to create a new empty font
	 * @property {string} familyName
	 * @property {string} styleName
	 * @property {string=} fullName
	 * @property {string=} postScriptName
	 * @property {string=} designer
	 * @property {string=} designerURL
	 * @property {string=} manufacturer
	 * @property {string=} manufacturerURL
	 * @property {string=} license
	 * @property {string=} licenseURL
	 * @property {string=} version
	 * @property {string=} description
	 * @property {string=} copyright
	 * @property {string=} trademark
	 * @property {Number} unitsPerEm
	 * @property {Number} ascender
	 * @property {Number} descender
	 * @property {Number} createdTimestamp
	 * @property {string=} weightClass
	 * @property {string=} widthClass
	 * @property {string=} fsSelection
	 */

	/**
	 * A Font represents a loaded OpenType font file.
	 * It contains a set of glyphs and methods to draw text on a drawing context,
	 * or to get a path representing the text.
	 * @exports opentype.Font
	 * @class
	 * @param {FontOptions}
	 * @constructor
	 */
	function Font(options) {
	    options = options || {};

	    if (!options.empty) {
	        // Check that we've provided the minimum set of names.
	        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
	        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
	        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
	        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
	        checkArgument(options.descender, 'When creating a new Font object, descender is required.');
	        checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).');

	        // OS X will complain if the names are empty, so we put a single space everywhere by default.
	        this.names = {
	            fontFamily: {en: options.familyName || ' '},
	            fontSubfamily: {en: options.styleName || ' '},
	            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
	            // postScriptName may not contain any whitespace
	            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, '')},
	            designer: {en: options.designer || ' '},
	            designerURL: {en: options.designerURL || ' '},
	            manufacturer: {en: options.manufacturer || ' '},
	            manufacturerURL: {en: options.manufacturerURL || ' '},
	            license: {en: options.license || ' '},
	            licenseURL: {en: options.licenseURL || ' '},
	            version: {en: options.version || 'Version 0.1'},
	            description: {en: options.description || ' '},
	            copyright: {en: options.copyright || ' '},
	            trademark: {en: options.trademark || ' '}
	        };
	        this.unitsPerEm = options.unitsPerEm || 1000;
	        this.ascender = options.ascender;
	        this.descender = options.descender;
	        this.createdTimestamp = options.createdTimestamp;
	        this.tables = { os2: {
	            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
	            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
	            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
	        } };
	    }

	    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
	    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
	    this.encoding = new DefaultEncoding(this);
	    this.position = new Position(this);
	    this.substitution = new Substitution(this);
	    this.tables = this.tables || {};

	    Object.defineProperty(this, 'hinting', {
	        get: function() {
	            if (this._hinting) { return this._hinting; }
	            if (this.outlinesFormat === 'truetype') {
	                return (this._hinting = new Hinting(this));
	            }
	        }
	    });
	}

	/**
	 * Check if the font has a glyph for the given character.
	 * @param  {string}
	 * @return {Boolean}
	 */
	Font.prototype.hasChar = function(c) {
	    return this.encoding.charToGlyphIndex(c) !== null;
	};

	/**
	 * Convert the given character to a single glyph index.
	 * Note that this function assumes that there is a one-to-one mapping between
	 * the given character and a glyph; for complex scripts this might not be the case.
	 * @param  {string}
	 * @return {Number}
	 */
	Font.prototype.charToGlyphIndex = function(s) {
	    return this.encoding.charToGlyphIndex(s);
	};

	/**
	 * Convert the given character to a single Glyph object.
	 * Note that this function assumes that there is a one-to-one mapping between
	 * the given character and a glyph; for complex scripts this might not be the case.
	 * @param  {string}
	 * @return {opentype.Glyph}
	 */
	Font.prototype.charToGlyph = function(c) {
	    var glyphIndex = this.charToGlyphIndex(c);
	    var glyph = this.glyphs.get(glyphIndex);
	    if (!glyph) {
	        // .notdef
	        glyph = this.glyphs.get(0);
	    }

	    return glyph;
	};

	/**
	 * Convert the given text to a list of Glyph objects.
	 * Note that there is no strict one-to-one mapping between characters and
	 * glyphs, so the list of returned glyphs can be larger or smaller than the
	 * length of the given string.
	 * @param  {string}
	 * @param  {GlyphRenderOptions} [options]
	 * @return {opentype.Glyph[]}
	 */
	Font.prototype.stringToGlyphs = function(s, options) {
	    var this$1 = this;

	    options = options || this.defaultRenderOptions;

	    var bidi = new Bidi();

	    // Create and register 'glyphIndex' state modifier
	    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };
	    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);

	    var arabFeatureQuery = new FeatureQuery(this);
	    var arabFeatures = ['init', 'medi', 'fina', 'rlig'];
	    bidi.applyFeatures(
	        arabFeatures.map(function (tag) {
	            var query = { tag: tag, script: 'arab' };
	            var feature = arabFeatureQuery.getFeature(query);
	            if (!!feature) { return feature; }
	        })
	    );
	    var indexes = bidi.getTextGlyphs(s);

	    var length = indexes.length;

	    // Apply substitutions on glyph indexes
	    if (options.features) {
	        var script = options.script || this.substitution.getDefaultScriptName();
	        var manyToOne = [];
	        if (options.features.liga) { manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language)); }
	        if (options.features.rlig) { manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language)); }
	        for (var i = 0; i < length; i += 1) {
	            for (var j = 0; j < manyToOne.length; j++) {
	                var ligature = manyToOne[j];
	                var components = ligature.sub;
	                var compCount = components.length;
	                var k = 0;
	                while (k < compCount && components[k] === indexes[i + k]) { k++; }
	                if (k === compCount) {
	                    indexes.splice(i, compCount, ligature.by);
	                    length = length - compCount + 1;
	                }
	            }
	        }
	    }

	    // convert glyph indexes to glyph objects
	    var glyphs = new Array(length);
	    var notdef = this.glyphs.get(0);
	    for (var i$1 = 0; i$1 < length; i$1 += 1) {
	        glyphs[i$1] = this$1.glyphs.get(indexes[i$1]) || notdef;
	    }
	    return glyphs;
	};

	/**
	 * @param  {string}
	 * @return {Number}
	 */
	Font.prototype.nameToGlyphIndex = function(name) {
	    return this.glyphNames.nameToGlyphIndex(name);
	};

	/**
	 * @param  {string}
	 * @return {opentype.Glyph}
	 */
	Font.prototype.nameToGlyph = function(name) {
	    var glyphIndex = this.nameToGlyphIndex(name);
	    var glyph = this.glyphs.get(glyphIndex);
	    if (!glyph) {
	        // .notdef
	        glyph = this.glyphs.get(0);
	    }

	    return glyph;
	};

	/**
	 * @param  {Number}
	 * @return {String}
	 */
	Font.prototype.glyphIndexToName = function(gid) {
	    if (!this.glyphNames.glyphIndexToName) {
	        return '';
	    }

	    return this.glyphNames.glyphIndexToName(gid);
	};

	/**
	 * Retrieve the value of the kerning pair between the left glyph (or its index)
	 * and the right glyph (or its index). If no kerning pair is found, return 0.
	 * The kerning value gets added to the advance width when calculating the spacing
	 * between glyphs.
	 * For GPOS kerning, this method uses the default script and language, which covers
	 * most use cases. To have greater control, use font.position.getKerningValue .
	 * @param  {opentype.Glyph} leftGlyph
	 * @param  {opentype.Glyph} rightGlyph
	 * @return {Number}
	 */
	Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
	    leftGlyph = leftGlyph.index || leftGlyph;
	    rightGlyph = rightGlyph.index || rightGlyph;
	    var gposKerning = this.position.defaultKerningTables;
	    if (gposKerning) {
	        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
	    }
	    // "kern" table
	    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
	};

	/**
	 * @typedef GlyphRenderOptions
	 * @type Object
	 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
	 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
	 * @property {string} [language='dflt'] - language system used to determine which features to apply.
	 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
	 * @property {boolean} [kerning=true] - whether to include kerning values
	 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
	 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
	 */
	Font.prototype.defaultRenderOptions = {
	    kerning: true,
	    features: {
	        liga: true,
	        rlig: true
	    }
	};

	/**
	 * Helper function that invokes the given callback for each glyph in the given text.
	 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
	 * @param {string} text - The text to apply.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @param  {Function} callback
	 */
	Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
	    var this$1 = this;

	    x = x !== undefined ? x : 0;
	    y = y !== undefined ? y : 0;
	    fontSize = fontSize !== undefined ? fontSize : 72;
	    options = options || this.defaultRenderOptions;
	    var fontScale = 1 / this.unitsPerEm * fontSize;
	    var glyphs = this.stringToGlyphs(text, options);
	    var kerningLookups;
	    if (options.kerning) {
	        var script = options.script || this.position.getDefaultScriptName();
	        kerningLookups = this.position.getKerningTables(script, options.language);
	    }
	    for (var i = 0; i < glyphs.length; i += 1) {
	        var glyph = glyphs[i];
	        callback.call(this$1, glyph, x, y, fontSize, options);
	        if (glyph.advanceWidth) {
	            x += glyph.advanceWidth * fontScale;
	        }

	        if (options.kerning && i < glyphs.length - 1) {
	            // We should apply position adjustment lookups in a more generic way.
	            // Here we only use the xAdvance value.
	            var kerningValue = kerningLookups ?
	                  this$1.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
	                  this$1.getKerningValue(glyph, glyphs[i + 1]);
	            x += kerningValue * fontScale;
	        }

	        if (options.letterSpacing) {
	            x += options.letterSpacing * fontSize;
	        } else if (options.tracking) {
	            x += (options.tracking / 1000) * fontSize;
	        }
	    }
	    return x;
	};

	/**
	 * Create a Path object that represents the given text.
	 * @param  {string} text - The text to create.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @return {opentype.Path}
	 */
	Font.prototype.getPath = function(text, x, y, fontSize, options) {
	    var fullPath = new Path();
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
	        fullPath.extend(glyphPath);
	    });
	    return fullPath;
	};

	/**
	 * Create an array of Path objects that represent the glyphs of a given text.
	 * @param  {string} text - The text to create.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @return {opentype.Path[]}
	 */
	Font.prototype.getPaths = function(text, x, y, fontSize, options) {
	    var glyphPaths = [];
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
	        glyphPaths.push(glyphPath);
	    });

	    return glyphPaths;
	};

	/**
	 * Returns the advance width of a text.
	 *
	 * This is something different than Path.getBoundingBox() as for example a
	 * suffixed whitespace increases the advanceWidth but not the bounding box
	 * or an overhanging letter like a calligraphic 'f' might have a quite larger
	 * bounding box than its advance width.
	 *
	 * This corresponds to canvas2dContext.measureText(text).width
	 *
	 * @param  {string} text - The text to create.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 * @return advance width
	 */
	Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
	    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
	};

	/**
	 * Draw the text on the given drawing context.
	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param  {string} text - The text to create.
	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param  {GlyphRenderOptions=} options
	 */
	Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
	    this.getPath(text, x, y, fontSize, options).draw(ctx);
	};

	/**
	 * Draw the points of all glyphs in the text.
	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param {string} text - The text to create.
	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param {GlyphRenderOptions=} options
	 */
	Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        glyph.drawPoints(ctx, gX, gY, gFontSize);
	    });
	};

	/**
	 * Draw lines indicating important font measurements for all glyphs in the text.
	 * Black lines indicate the origin of the coordinate system (point 0,0).
	 * Blue lines indicate the glyph bounding box.
	 * Green line indicates the advance width of the glyph.
	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
	 * @param {string} text - The text to create.
	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
	 * @param {GlyphRenderOptions=} options
	 */
	Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
	        glyph.drawMetrics(ctx, gX, gY, gFontSize);
	    });
	};

	/**
	 * @param  {string}
	 * @return {string}
	 */
	Font.prototype.getEnglishName = function(name) {
	    var translations = this.names[name];
	    if (translations) {
	        return translations.en;
	    }
	};

	/**
	 * Validate
	 */
	Font.prototype.validate = function() {
	    var _this = this;

	    function assert(predicate, message) {
	    }

	    function assertNamePresent(name) {
	        var englishName = _this.getEnglishName(name);
	        assert(englishName && englishName.trim().length > 0,
	               'No English ' + name + ' specified.');
	    }

	    // Identification information
	    assertNamePresent('fontFamily');
	    assertNamePresent('weightName');
	    assertNamePresent('manufacturer');
	    assertNamePresent('copyright');
	    assertNamePresent('version');

	    // Dimension information
	    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
	};

	/**
	 * Convert the font object to a SFNT data structure.
	 * This structure contains all the necessary tables and metadata to create a binary OTF file.
	 * @return {opentype.Table}
	 */
	Font.prototype.toTables = function() {
	    return sfnt.fontToTable(this);
	};
	/**
	 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
	 */
	Font.prototype.toBuffer = function() {
	    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
	    return this.toArrayBuffer();
	};
	/**
	 * Converts a `opentype.Font` into an `ArrayBuffer`
	 * @return {ArrayBuffer}
	 */
	Font.prototype.toArrayBuffer = function() {
	    var sfntTable = this.toTables();
	    var bytes = sfntTable.encode();
	    var buffer = new ArrayBuffer(bytes.length);
	    var intArray = new Uint8Array(buffer);
	    for (var i = 0; i < bytes.length; i++) {
	        intArray[i] = bytes[i];
	    }

	    return buffer;
	};

	/**
	 * Initiate a download of the OpenType font.
	 */
	Font.prototype.download = function(fileName) {
	    var familyName = this.getEnglishName('fontFamily');
	    var styleName = this.getEnglishName('fontSubfamily');
	    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
	    var arrayBuffer = this.toArrayBuffer();

	    if (isBrowser()) {
	        window.URL = window.URL || window.webkitURL;

	        if (window.URL) {
	            var dataView = new DataView(arrayBuffer);
	            var blob = new Blob([dataView], {type: 'font/opentype'});

	            var link = document.createElement('a');
	            link.href = window.URL.createObjectURL(blob);
	            link.download = fileName;

	            var event = document.createEvent('MouseEvents');
	            event.initEvent('click', true, false);
	            link.dispatchEvent(event);
	        } else {
	            console.warn('Font file could not be downloaded. Try using a different browser.');
	        }
	    } else {
	        var fs = require('fs');
	        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
	        fs.writeFileSync(fileName, buffer);
	    }
	};
	/**
	 * @private
	 */
	Font.prototype.fsSelectionValues = {
	    ITALIC:              0x001, //1
	    UNDERSCORE:          0x002, //2
	    NEGATIVE:            0x004, //4
	    OUTLINED:            0x008, //8
	    STRIKEOUT:           0x010, //16
	    BOLD:                0x020, //32
	    REGULAR:             0x040, //64
	    USER_TYPO_METRICS:   0x080, //128
	    WWS:                 0x100, //256
	    OBLIQUE:             0x200  //512
	};

	/**
	 * @private
	 */
	Font.prototype.usWidthClasses = {
	    ULTRA_CONDENSED: 1,
	    EXTRA_CONDENSED: 2,
	    CONDENSED: 3,
	    SEMI_CONDENSED: 4,
	    MEDIUM: 5,
	    SEMI_EXPANDED: 6,
	    EXPANDED: 7,
	    EXTRA_EXPANDED: 8,
	    ULTRA_EXPANDED: 9
	};

	/**
	 * @private
	 */
	Font.prototype.usWeightClasses = {
	    THIN: 100,
	    EXTRA_LIGHT: 200,
	    LIGHT: 300,
	    NORMAL: 400,
	    MEDIUM: 500,
	    SEMI_BOLD: 600,
	    BOLD: 700,
	    EXTRA_BOLD: 800,
	    BLACK:    900
	};

	// The `fvar` table stores font variation axes and instances.

	function addName(name, names) {
	    var nameString = JSON.stringify(name);
	    var nameID = 256;
	    for (var nameKey in names) {
	        var n = parseInt(nameKey);
	        if (!n || n < 256) {
	            continue;
	        }

	        if (JSON.stringify(names[nameKey]) === nameString) {
	            return n;
	        }

	        if (nameID <= n) {
	            nameID = n + 1;
	        }
	    }

	    names[nameID] = name;
	    return nameID;
	}

	function makeFvarAxis(n, axis, names) {
	    var nameID = addName(axis.name, names);
	    return [
	        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
	        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
	        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
	        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
	        {name: 'flags_' + n, type: 'USHORT', value: 0},
	        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
	    ];
	}

	function parseFvarAxis(data, start, names) {
	    var axis = {};
	    var p = new parse.Parser(data, start);
	    axis.tag = p.parseTag();
	    axis.minValue = p.parseFixed();
	    axis.defaultValue = p.parseFixed();
	    axis.maxValue = p.parseFixed();
	    p.skip('uShort', 1);  // reserved for flags; no values defined
	    axis.name = names[p.parseUShort()] || {};
	    return axis;
	}

	function makeFvarInstance(n, inst, axes, names) {
	    var nameID = addName(inst.name, names);
	    var fields = [
	        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
	        {name: 'flags_' + n, type: 'USHORT', value: 0}
	    ];

	    for (var i = 0; i < axes.length; ++i) {
	        var axisTag = axes[i].tag;
	        fields.push({
	            name: 'axis_' + n + ' ' + axisTag,
	            type: 'FIXED',
	            value: inst.coordinates[axisTag] << 16
	        });
	    }

	    return fields;
	}

	function parseFvarInstance(data, start, axes, names) {
	    var inst = {};
	    var p = new parse.Parser(data, start);
	    inst.name = names[p.parseUShort()] || {};
	    p.skip('uShort', 1);  // reserved for flags; no values defined

	    inst.coordinates = {};
	    for (var i = 0; i < axes.length; ++i) {
	        inst.coordinates[axes[i].tag] = p.parseFixed();
	    }

	    return inst;
	}

	function makeFvarTable(fvar, names) {
	    var result = new table.Table('fvar', [
	        {name: 'version', type: 'ULONG', value: 0x10000},
	        {name: 'offsetToData', type: 'USHORT', value: 0},
	        {name: 'countSizePairs', type: 'USHORT', value: 2},
	        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
	        {name: 'axisSize', type: 'USHORT', value: 20},
	        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
	        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
	    ]);
	    result.offsetToData = result.sizeOf();

	    for (var i = 0; i < fvar.axes.length; i++) {
	        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
	    }

	    for (var j = 0; j < fvar.instances.length; j++) {
	        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
	    }

	    return result;
	}

	function parseFvarTable(data, start, names) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseULong();
	    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
	    var offsetToData = p.parseOffset16();
	    // Skip countSizePairs.
	    p.skip('uShort', 1);
	    var axisCount = p.parseUShort();
	    var axisSize = p.parseUShort();
	    var instanceCount = p.parseUShort();
	    var instanceSize = p.parseUShort();

	    var axes = [];
	    for (var i = 0; i < axisCount; i++) {
	        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
	    }

	    var instances = [];
	    var instanceStart = start + offsetToData + axisCount * axisSize;
	    for (var j = 0; j < instanceCount; j++) {
	        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
	    }

	    return {axes: axes, instances: instances};
	}

	var fvar = { make: makeFvarTable, parse: parseFvarTable };

	// The `GPOS` table contains kerning pairs, among other things.

	var subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused

	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
	// this = Parser instance
	subtableParsers$1[1] = function parseLookup1() {
	    var start = this.offset + this.relativeOffset;
	    var posformat = this.parseUShort();
	    if (posformat === 1) {
	        return {
	            posFormat: 1,
	            coverage: this.parsePointer(Parser.coverage),
	            value: this.parseValueRecord()
	        };
	    } else if (posformat === 2) {
	        return {
	            posFormat: 2,
	            coverage: this.parsePointer(Parser.coverage),
	            values: this.parseValueRecordList()
	        };
	    }
	    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
	};

	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
	subtableParsers$1[2] = function parseLookup2() {
	    var start = this.offset + this.relativeOffset;
	    var posFormat = this.parseUShort();
	    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
	    var coverage = this.parsePointer(Parser.coverage);
	    var valueFormat1 = this.parseUShort();
	    var valueFormat2 = this.parseUShort();
	    if (posFormat === 1) {
	        // Adjustments for Glyph Pairs
	        return {
	            posFormat: posFormat,
	            coverage: coverage,
	            valueFormat1: valueFormat1,
	            valueFormat2: valueFormat2,
	            pairSets: this.parseList(Parser.pointer(Parser.list(function() {
	                return {        // pairValueRecord
	                    secondGlyph: this.parseUShort(),
	                    value1: this.parseValueRecord(valueFormat1),
	                    value2: this.parseValueRecord(valueFormat2)
	                };
	            })))
	        };
	    } else if (posFormat === 2) {
	        var classDef1 = this.parsePointer(Parser.classDef);
	        var classDef2 = this.parsePointer(Parser.classDef);
	        var class1Count = this.parseUShort();
	        var class2Count = this.parseUShort();
	        return {
	            // Class Pair Adjustment
	            posFormat: posFormat,
	            coverage: coverage,
	            valueFormat1: valueFormat1,
	            valueFormat2: valueFormat2,
	            classDef1: classDef1,
	            classDef2: classDef2,
	            class1Count: class1Count,
	            class2Count: class2Count,
	            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
	                return {
	                    value1: this.parseValueRecord(valueFormat1),
	                    value2: this.parseValueRecord(valueFormat2)
	                };
	            }))
	        };
	    }
	};

	subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
	subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
	subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
	subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
	subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
	subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
	subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };

	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
	function parseGposTable(data, start) {
	    start = start || 0;
	    var p = new Parser(data, start);
	    var tableVersion = p.parseVersion(1);
	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);

	    if (tableVersion === 1) {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers$1)
	        };
	    } else {
	        return {
	            version: tableVersion,
	            scripts: p.parseScriptList(),
	            features: p.parseFeatureList(),
	            lookups: p.parseLookupList(subtableParsers$1),
	            variations: p.parseFeatureVariationsList()
	        };
	    }

	}

	// GPOS Writing //////////////////////////////////////////////
	// NOT SUPPORTED
	var subtableMakers$1 = new Array(10);

	function makeGposTable(gpos) {
	    return new table.Table('GPOS', [
	        {name: 'version', type: 'ULONG', value: 0x10000},
	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},
	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},
	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}
	    ]);
	}

	var gpos = { parse: parseGposTable, make: makeGposTable };

	// The `kern` table contains kerning pairs.

	function parseWindowsKernTable(p) {
	    var pairs = {};
	    // Skip nTables.
	    p.skip('uShort');
	    var subtableVersion = p.parseUShort();
	    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
	    // Skip subtableLength, subtableCoverage
	    p.skip('uShort', 2);
	    var nPairs = p.parseUShort();
	    // Skip searchRange, entrySelector, rangeShift.
	    p.skip('uShort', 3);
	    for (var i = 0; i < nPairs; i += 1) {
	        var leftIndex = p.parseUShort();
	        var rightIndex = p.parseUShort();
	        var value = p.parseShort();
	        pairs[leftIndex + ',' + rightIndex] = value;
	    }
	    return pairs;
	}

	function parseMacKernTable(p) {
	    var pairs = {};
	    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
	    // Skip the rest.
	    p.skip('uShort');
	    var nTables = p.parseULong();
	    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
	    if (nTables > 1) {
	        console.warn('Only the first kern subtable is supported.');
	    }
	    p.skip('uLong');
	    var coverage = p.parseUShort();
	    var subtableVersion = coverage & 0xFF;
	    p.skip('uShort');
	    if (subtableVersion === 0) {
	        var nPairs = p.parseUShort();
	        // Skip searchRange, entrySelector, rangeShift.
	        p.skip('uShort', 3);
	        for (var i = 0; i < nPairs; i += 1) {
	            var leftIndex = p.parseUShort();
	            var rightIndex = p.parseUShort();
	            var value = p.parseShort();
	            pairs[leftIndex + ',' + rightIndex] = value;
	        }
	    }
	    return pairs;
	}

	// Parse the `kern` table which contains kerning pairs.
	function parseKernTable(data, start) {
	    var p = new parse.Parser(data, start);
	    var tableVersion = p.parseUShort();
	    if (tableVersion === 0) {
	        return parseWindowsKernTable(p);
	    } else if (tableVersion === 1) {
	        return parseMacKernTable(p);
	    } else {
	        throw new Error('Unsupported kern table version (' + tableVersion + ').');
	    }
	}

	var kern = { parse: parseKernTable };

	// The `loca` table stores the offsets to the locations of the glyphs in the font.

	// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
	// relative to the beginning of the glyphData table.
	// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
	// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
	// version where offsets are stored as uLongs. The `head` table specifies which version to use
	// (under indexToLocFormat).
	function parseLocaTable(data, start, numGlyphs, shortVersion) {
	    var p = new parse.Parser(data, start);
	    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
	    // There is an extra entry after the last index element to compute the length of the last glyph.
	    // That's why we use numGlyphs + 1.
	    var glyphOffsets = [];
	    for (var i = 0; i < numGlyphs + 1; i += 1) {
	        var glyphOffset = parseFn.call(p);
	        if (shortVersion) {
	            // The short table version stores the actual offset divided by 2.
	            glyphOffset *= 2;
	        }

	        glyphOffsets.push(glyphOffset);
	    }

	    return glyphOffsets;
	}

	var loca = { parse: parseLocaTable };

	// opentype.js

	/**
	 * The opentype library.
	 * @namespace opentype
	 */

	// File loaders /////////////////////////////////////////////////////////
	/**
	 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
	 * @param  {string} path - The path of the file
	 * @param  {Function} callback - The function to call when the font load completes
	 */
	function loadFromFile(path, callback) {
	    var fs = require('fs');
	    fs.readFile(path, function(err, buffer) {
	        if (err) {
	            return callback(err.message);
	        }

	        callback(null, nodeBufferToArrayBuffer(buffer));
	    });
	}
	/**
	 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
	 * @param  {string} url - The URL of the font file.
	 * @param  {Function} callback - The function to call when the font load completes
	 */
	function loadFromUrl(url, callback) {
	    var request = new XMLHttpRequest();
	    request.open('get', url, true);
	    request.responseType = 'arraybuffer';
	    request.onload = function() {
	        if (request.response) {
	            return callback(null, request.response);
	        } else {
	            return callback('Font could not be loaded: ' + request.statusText);
	        }
	    };

	    request.onerror = function () {
	        callback('Font could not be loaded');
	    };

	    request.send();
	}

	// Table Directory Entries //////////////////////////////////////////////
	/**
	 * Parses OpenType table entries.
	 * @param  {DataView}
	 * @param  {Number}
	 * @return {Object[]}
	 */
	function parseOpenTypeTableEntries(data, numTables) {
	    var tableEntries = [];
	    var p = 12;
	    for (var i = 0; i < numTables; i += 1) {
	        var tag = parse.getTag(data, p);
	        var checksum = parse.getULong(data, p + 4);
	        var offset = parse.getULong(data, p + 8);
	        var length = parse.getULong(data, p + 12);
	        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
	        p += 16;
	    }

	    return tableEntries;
	}

	/**
	 * Parses WOFF table entries.
	 * @param  {DataView}
	 * @param  {Number}
	 * @return {Object[]}
	 */
	function parseWOFFTableEntries(data, numTables) {
	    var tableEntries = [];
	    var p = 44; // offset to the first table directory entry.
	    for (var i = 0; i < numTables; i += 1) {
	        var tag = parse.getTag(data, p);
	        var offset = parse.getULong(data, p + 4);
	        var compLength = parse.getULong(data, p + 8);
	        var origLength = parse.getULong(data, p + 12);
	        var compression = (void 0);
	        if (compLength < origLength) {
	            compression = 'WOFF';
	        } else {
	            compression = false;
	        }

	        tableEntries.push({tag: tag, offset: offset, compression: compression,
	            compressedLength: compLength, length: origLength});
	        p += 20;
	    }

	    return tableEntries;
	}

	/**
	 * @typedef TableData
	 * @type Object
	 * @property {DataView} data - The DataView
	 * @property {number} offset - The data offset.
	 */

	/**
	 * @param  {DataView}
	 * @param  {Object}
	 * @return {TableData}
	 */
	function uncompressTable(data, tableEntry) {
	    if (tableEntry.compression === 'WOFF') {
	        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
	        var outBuffer = new Uint8Array(tableEntry.length);
	        tinyInflate(inBuffer, outBuffer);
	        if (outBuffer.byteLength !== tableEntry.length) {
	            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
	        }

	        var view = new DataView(outBuffer.buffer, 0);
	        return {data: view, offset: 0};
	    } else {
	        return {data: data, offset: tableEntry.offset};
	    }
	}

	// Public API ///////////////////////////////////////////////////////////

	/**
	 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
	 * Throws an error if the font could not be parsed.
	 * @param  {ArrayBuffer}
	 * @return {opentype.Font}
	 */
	function parseBuffer(buffer) {
	    var indexToLocFormat;
	    var ltagTable;

	    // Since the constructor can also be called to create new fonts from scratch, we indicate this
	    // should be an empty font that we'll fill with our own data.
	    var font = new Font({empty: true});

	    // OpenType fonts use big endian byte ordering.
	    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
	    // Instead we use DataViews where we can specify endianness.
	    var data = new DataView(buffer, 0);
	    var numTables;
	    var tableEntries = [];
	    var signature = parse.getTag(data, 0);
	    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
	        font.outlinesFormat = 'truetype';
	        numTables = parse.getUShort(data, 4);
	        tableEntries = parseOpenTypeTableEntries(data, numTables);
	    } else if (signature === 'OTTO') {
	        font.outlinesFormat = 'cff';
	        numTables = parse.getUShort(data, 4);
	        tableEntries = parseOpenTypeTableEntries(data, numTables);
	    } else if (signature === 'wOFF') {
	        var flavor = parse.getTag(data, 4);
	        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
	            font.outlinesFormat = 'truetype';
	        } else if (flavor === 'OTTO') {
	            font.outlinesFormat = 'cff';
	        } else {
	            throw new Error('Unsupported OpenType flavor ' + signature);
	        }

	        numTables = parse.getUShort(data, 12);
	        tableEntries = parseWOFFTableEntries(data, numTables);
	    } else {
	        throw new Error('Unsupported OpenType signature ' + signature);
	    }

	    var cffTableEntry;
	    var fvarTableEntry;
	    var glyfTableEntry;
	    var gposTableEntry;
	    var gsubTableEntry;
	    var hmtxTableEntry;
	    var kernTableEntry;
	    var locaTableEntry;
	    var nameTableEntry;
	    var metaTableEntry;
	    var p;

	    for (var i = 0; i < numTables; i += 1) {
	        var tableEntry = tableEntries[i];
	        var table = (void 0);
	        switch (tableEntry.tag) {
	            case 'cmap':
	                table = uncompressTable(data, tableEntry);
	                font.tables.cmap = cmap.parse(table.data, table.offset);
	                font.encoding = new CmapEncoding(font.tables.cmap);
	                break;
	            case 'cvt ' :
	                table = uncompressTable(data, tableEntry);
	                p = new parse.Parser(table.data, table.offset);
	                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
	                break;
	            case 'fvar':
	                fvarTableEntry = tableEntry;
	                break;
	            case 'fpgm' :
	                table = uncompressTable(data, tableEntry);
	                p = new parse.Parser(table.data, table.offset);
	                font.tables.fpgm = p.parseByteList(tableEntry.length);
	                break;
	            case 'head':
	                table = uncompressTable(data, tableEntry);
	                font.tables.head = head.parse(table.data, table.offset);
	                font.unitsPerEm = font.tables.head.unitsPerEm;
	                indexToLocFormat = font.tables.head.indexToLocFormat;
	                break;
	            case 'hhea':
	                table = uncompressTable(data, tableEntry);
	                font.tables.hhea = hhea.parse(table.data, table.offset);
	                font.ascender = font.tables.hhea.ascender;
	                font.descender = font.tables.hhea.descender;
	                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
	                break;
	            case 'hmtx':
	                hmtxTableEntry = tableEntry;
	                break;
	            case 'ltag':
	                table = uncompressTable(data, tableEntry);
	                ltagTable = ltag.parse(table.data, table.offset);
	                break;
	            case 'maxp':
	                table = uncompressTable(data, tableEntry);
	                font.tables.maxp = maxp.parse(table.data, table.offset);
	                font.numGlyphs = font.tables.maxp.numGlyphs;
	                break;
	            case 'name':
	                nameTableEntry = tableEntry;
	                break;
	            case 'OS/2':
	                table = uncompressTable(data, tableEntry);
	                font.tables.os2 = os2.parse(table.data, table.offset);
	                break;
	            case 'post':
	                table = uncompressTable(data, tableEntry);
	                font.tables.post = post.parse(table.data, table.offset);
	                font.glyphNames = new GlyphNames(font.tables.post);
	                break;
	            case 'prep' :
	                table = uncompressTable(data, tableEntry);
	                p = new parse.Parser(table.data, table.offset);
	                font.tables.prep = p.parseByteList(tableEntry.length);
	                break;
	            case 'glyf':
	                glyfTableEntry = tableEntry;
	                break;
	            case 'loca':
	                locaTableEntry = tableEntry;
	                break;
	            case 'CFF ':
	                cffTableEntry = tableEntry;
	                break;
	            case 'kern':
	                kernTableEntry = tableEntry;
	                break;
	            case 'GPOS':
	                gposTableEntry = tableEntry;
	                break;
	            case 'GSUB':
	                gsubTableEntry = tableEntry;
	                break;
	            case 'meta':
	                metaTableEntry = tableEntry;
	                break;
	        }
	    }

	    var nameTable = uncompressTable(data, nameTableEntry);
	    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
	    font.names = font.tables.name;

	    if (glyfTableEntry && locaTableEntry) {
	        var shortVersion = indexToLocFormat === 0;
	        var locaTable = uncompressTable(data, locaTableEntry);
	        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
	        var glyfTable = uncompressTable(data, glyfTableEntry);
	        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
	    } else if (cffTableEntry) {
	        var cffTable = uncompressTable(data, cffTableEntry);
	        cff.parse(cffTable.data, cffTable.offset, font);
	    } else {
	        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
	    }

	    var hmtxTable = uncompressTable(data, hmtxTableEntry);
	    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
	    addGlyphNames(font);

	    if (kernTableEntry) {
	        var kernTable = uncompressTable(data, kernTableEntry);
	        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
	    } else {
	        font.kerningPairs = {};
	    }

	    if (gposTableEntry) {
	        var gposTable = uncompressTable(data, gposTableEntry);
	        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
	        font.position.init();
	    }

	    if (gsubTableEntry) {
	        var gsubTable = uncompressTable(data, gsubTableEntry);
	        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
	    }

	    if (fvarTableEntry) {
	        var fvarTable = uncompressTable(data, fvarTableEntry);
	        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
	    }

	    if (metaTableEntry) {
	        var metaTable = uncompressTable(data, metaTableEntry);
	        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
	        font.metas = font.tables.meta;
	    }

	    return font;
	}

	/**
	 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
	 * with two arguments `(err, font)`. The `err` will be null on success,
	 * the `font` is a Font object.
	 * We use the node.js callback convention so that
	 * opentype.js can integrate with frameworks like async.js.
	 * @alias opentype.load
	 * @param  {string} url - The URL of the font to load.
	 * @param  {Function} callback - The callback.
	 */
	function load(url, callback) {
	    var isNode$$1 = typeof window === 'undefined';
	    var loadFn = isNode$$1 ? loadFromFile : loadFromUrl;
	    loadFn(url, function(err, arrayBuffer) {
	        if (err) {
	            return callback(err);
	        }
	        var font;
	        try {
	            font = parseBuffer(arrayBuffer);
	        } catch (e) {
	            return callback(e, null);
	        }
	        return callback(null, font);
	    });
	}

	/**
	 * Synchronously load the font from a URL or file.
	 * When done, returns the font object or throws an error.
	 * @alias opentype.loadSync
	 * @param  {string} url - The URL of the font to load.
	 * @return {opentype.Font}
	 */
	function loadSync(url) {
	    var fs = require('fs');
	    var buffer = fs.readFileSync(url);
	    return parseBuffer(nodeBufferToArrayBuffer(buffer));
	}

	exports.Font = Font;
	exports.Glyph = Glyph;
	exports.Path = Path;
	exports.BoundingBox = BoundingBox;
	exports._parse = parse;
	exports.parse = parseBuffer;
	exports.load = load;
	exports.loadSync = loadSync;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=opentype.js.map
;
define('opentype', ['opentype/dist/opentype'], function (main) { return main; });

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Text/X3DTextContext',[
	"jquery",
	"x_ite/Components/Text/FontStyle",
	"opentype",
],
function ($,
          FontStyle,
          opentype)
{
"use strict";

	function X3DTextContext ()
	{
		this .fontCache  = new Map ();
		this .glyphCache = new Map (); // [font] [primitveQuality] [glyphIndex]
	}

	X3DTextContext .prototype =
	{
		initialize: function ()
		{ },
		getDefaultFontStyle: function ()
		{
			if (this .defaultFontStyle)
				return this .defaultFontStyle;

			this .defaultFontStyle = new FontStyle (this .getPrivateScene ());

			this .defaultFontStyle .setup ();

			return this .defaultFontStyle;
		},
		getFont: function (url)
		{
			url = url .toString ();

			var deferred = this .fontCache .get (url);

			if (deferred === undefined)
			{
				this .fontCache .set (url, deferred = $.Deferred ());

				opentype .load (url, this .setFont .bind (this, deferred));
			}

			return deferred;
		},
		setFont: function (deferred, error, font)
		{
			if (error)
			{
				deferred .reject (error);
			}
			else
			{
//				// Workaround to initialize composite glyphs.
//				for (var i = 0, length = font .numGlyphs; i < length; ++ i)
//					font .glyphs .get (i) .getPath (0, 0, 1);

				// Resolve callbacks.
				deferred .resolve (font);
			}
		},
		getGlyph: function (font, primitveQuality, glyphIndex)
		{
			var cachedFont = this .glyphCache .get (font);

			if (! cachedFont)
				this .glyphCache .set (font, cachedFont = [ ]);

			var cachedQuality = cachedFont [primitveQuality];

			if (! cachedQuality)
				cachedQuality = cachedFont [primitveQuality] = [ ];

			var cachedGlyph = cachedQuality [glyphIndex];

			if (! cachedGlyph)
				cachedGlyph = cachedQuality [glyphIndex] = { };

		   return cachedGlyph;
		},
	};

	return X3DTextContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/X3DTextureTransformNode',[
	"x_ite/Components/Shape/X3DAppearanceChildNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix4",
],
function (X3DAppearanceChildNode, 
          X3DConstants,
          Matrix4)
{
"use strict";

	function X3DTextureTransformNode (executionContext)
	{
		X3DAppearanceChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DTextureTransformNode);

		this .matrix      = new Matrix4 ();
		this .matrixArray = new Float32Array (this .matrix);
	}

	X3DTextureTransformNode .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
	{
		constructor: X3DTextureTransformNode,
		setMatrix: function (value)
		{
			this .matrixArray .set (value);
		},
		getMatrix: function ()
		{
			return this .matrix;
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			for (var i = 0, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
				this .setShaderUniformsToChannel (gl, shaderObject, i);
		},
		setShaderUniformsToChannel: function (gl, shaderObject, i)
		{
			gl .uniformMatrix4fv (shaderObject .x3d_TextureMatrix [i], false, this .matrixArray);
		},
	});

	return X3DTextureTransformNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/TextureTransform',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Texturing/X3DTextureTransformNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Matrix3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTextureTransformNode, 
          X3DConstants,
          Vector2,
          Matrix3)
{
"use strict";

	var vector = new Vector2 (0, 0);

	function TextureTransform (executionContext)
	{
		X3DTextureTransformNode .call (this, executionContext);

		this .addType (X3DConstants .TextureTransform);

		this .rotation_ .setUnit ("angle");

		this .matrix3 = new Matrix3 ();
	}

	TextureTransform .prototype = Object .assign (Object .create (X3DTextureTransformNode .prototype),
	{
		constructor: TextureTransform,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",    new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "translation", new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "rotation",    new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "scale",       new Fields .SFVec2f (1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "center",      new Fields .SFVec2f ()),
		]),
		getTypeName: function ()
		{
			return "TextureTransform";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "textureTransform";
		},
		initialize: function ()
		{
			X3DTextureTransformNode .prototype .initialize .call (this);
			
			this .addInterest ("eventsProcessed", this);

			this .eventsProcessed ();
		},
		eventsProcessed: function ()
		{
			var
				translation = this .translation_ .getValue (),
				rotation    = this .rotation_ .getValue (),
				scale       = this .scale_ .getValue (),
				center      = this .center_ .getValue (),
				matrix3     = this .matrix3;

			matrix3 .identity ();

			if (! center .equals (Vector2 .Zero))
				matrix3 .translate (vector .assign (center) .negate ());

			if (! scale .equals (Vector2 .One))
				matrix3 .scale (scale);

			if (rotation !== 0)
				matrix3 .rotate (rotation);

			if (! center .equals (Vector2 .Zero))
				matrix3 .translate (center);

			if (! translation .equals (Vector2 .Zero))
				matrix3 .translate (translation);

			var matrix4 = this .getMatrix ();
			
			matrix4 [ 0] = matrix3 [0];
			matrix4 [ 1] = matrix3 [1];
			matrix4 [ 4] = matrix3 [3];
			matrix4 [ 5] = matrix3 [4];
			matrix4 [12] = matrix3 [6]; 
			matrix4 [13] = matrix3 [7];

			this .setMatrix (matrix4);
		},
	});

	return TextureTransform;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Texturing/X3DTexturingContext',[
	"x_ite/Components/Texturing/TextureProperties",
	"x_ite/Components/Texturing/TextureTransform",
	"x_ite/Components/Texturing/TextureCoordinate",
],
function (TextureProperties,
          TextureTransform,
          TextureCoordinate)
{
"use strict";

	function X3DTexturingContext ()
	{
		var
			gl                    = this .getContext (),
			maxVertexTextureUnits = gl .getParameter (gl .MAX_VERTEX_TEXTURE_IMAGE_UNITS);

		this .maxTextures              = maxVertexTextureUnits > 8 ? 2 : 1;
		this .multiTexturing           = maxVertexTextureUnits > 8;
		this .projectiveTextureMapping = maxVertexTextureUnits > 8;
		this .combinedTextureUnits     = [ ];
	}

	X3DTexturingContext .prototype =
	{
		initialize: function ()
		{
			var gl = this .getContext ();

			this .maxTextureSize          = gl .getParameter (gl .MAX_TEXTURE_SIZE);
			this .maxCombinedTextureUnits = gl .getParameter (gl .MAX_COMBINED_TEXTURE_IMAGE_UNITS);
			this .textureMemory           = NaN;

			var combinedTextureUnits = this .combinedTextureUnits;

			// For shaders
			for (var i = 1, length = this .maxCombinedTextureUnits; i < length; ++ i)
				combinedTextureUnits .push (i);

			// There must always be a texture bound to the used texture units.

			this .shadowTextureUnit = this .getCombinedTextureUnits () .pop ();
			this .linetypeUnit      = this .getCombinedTextureUnits () .pop ();
			this .hatchStyleUnit    = this .getCombinedTextureUnits () .pop ();

			this .texture2DUnits         = new Int32Array (this .getMaxTextures ());
			this .projectiveTextureUnits = new Int32Array (this .getMaxTextures ());

			for (var i = 0, length = this .getMaxTextures (); i < length; ++ i)
				this .texture2DUnits [i] = this .getCombinedTextureUnits () .pop ();

			if (this .getProjectiveTextureMapping ())
			{
				for (var i = 0, length = this .getMaxTextures (); i < length; ++ i)
					this .projectiveTextureUnits [i] = this .getCombinedTextureUnits () .pop ();
			}

         var defaultData = new Uint8Array ([ 255, 255, 255, 255 ]);

			// Texture 2D Units

			this .defaultTexture2D = gl .createTexture ();

			gl .bindTexture (gl .TEXTURE_2D, this .defaultTexture2D);
			gl .texImage2D  (gl .TEXTURE_2D, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);

			gl .activeTexture (gl .TEXTURE0 + this .shadowTextureUnit);
			gl .bindTexture (gl .TEXTURE_2D, this .defaultTexture2D);

			gl .activeTexture (gl .TEXTURE0 + this .linetypeUnit);
			gl .bindTexture (gl .TEXTURE_2D, this .defaultTexture2D);

			gl .activeTexture (gl .TEXTURE0 + this .hatchStyleUnit);
			gl .bindTexture (gl .TEXTURE_2D, this .defaultTexture2D);

			for (var i = 0, length = this .texture2DUnits .length; i < length; ++ i)
			{
				gl .activeTexture (gl .TEXTURE0 + this .texture2DUnits [i]);
				gl .bindTexture (gl .TEXTURE_2D, this .defaultTexture2D);
			}

			for (var i = 0, length = this .projectiveTextureUnits .length; i < length; ++ i)
			{
				gl .activeTexture (gl .TEXTURE0 + this .projectiveTextureUnits [i]);
				gl .bindTexture (gl .TEXTURE_2D, this .defaultTexture2D);
			}

			// Texture 3D Units

			if (gl .getVersion () >= 2)
			{
				this .texture3DUnits = new Int32Array (this .getMaxTextures ());

				for (var i = 0, length = this .getMaxTextures (); i < length; ++ i)
					this .texture3DUnits [i] = this .getCombinedTextureUnits () .pop ();

				this .defaultTexture3D = gl .createTexture ();

				gl .bindTexture (gl .TEXTURE_3D, this .defaultTexture3D);
				gl .texImage3D  (gl .TEXTURE_3D, 0, gl .RGBA, 1, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);

				for (var i = 0, length = this .texture3DUnits .length; i < length; ++ i)
				{
					gl .activeTexture (gl .TEXTURE0 + this .texture3DUnits [i]);
					gl .bindTexture (gl .TEXTURE_3D, this .defaultTexture3D);
				}

				// Fix for Chrome.
				gl .activeTexture (gl .TEXTURE0);
				gl .bindTexture (gl .TEXTURE_3D, this .defaultTexture3D);
			}

			// Cube Map Texture Units

			this .cubeMapTextureUnits = new Int32Array (this .getMaxTextures ());

			for (var i = 0, length = this .getMaxTextures (); i < length; ++ i)
				this .cubeMapTextureUnits [i] = this .getCombinedTextureUnits () .pop ();

 			this .defaultCubeMapTexture = gl .createTexture ();

			gl .bindTexture (gl .TEXTURE_CUBE_MAP, this .defaultCubeMapTexture);
			gl .texImage2D  (gl .TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
			gl .texImage2D  (gl .TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
			gl .texImage2D  (gl .TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
			gl .texImage2D  (gl .TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
			gl .texImage2D  (gl .TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);
			gl .texImage2D  (gl .TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl .RGBA, 1, 1, 0, gl .RGBA, gl .UNSIGNED_BYTE, defaultData);

			for (var i = 0, length = this .cubeMapTextureUnits .length; i < length; ++ i)
			{
				gl .activeTexture (gl .TEXTURE0 + this .cubeMapTextureUnits [i]);
				gl .bindTexture (gl .TEXTURE_CUBE_MAP, this .defaultCubeMapTexture);
			}

			gl .activeTexture (gl .TEXTURE0);
		},
		getMaxTextures: function ()
		{
			return this .maxTextures;
		},
		getMinTextureSize: function ()
		{
			return 16;
		},
		getMaxTextureSize: function ()
		{
			return this .maxTextureSize;
		},
		getMaxCombinedTextureUnits: function ()
		{
			return this .maxCombinedTextureUnits;
		},
		getCombinedTextureUnits: function ()
		{
			return this .combinedTextureUnits;
		},
		getTexture2DUnits: function ()
		{
			return this .texture2DUnits;
		},
		getTexture3DUnits: function ()
		{
			return this .texture3DUnits;
		},
		getCubeMapTextureUnits: function ()
		{
			return this .cubeMapTextureUnits;
		},
		getProjectiveTextureUnits: function ()
		{
			return this .projectiveTextureUnits;
		},
		getShadowTextureUnit: function ()
		{
			return this .shadowTextureUnit;
		},
		getLinetypeUnit: function ()
		{
			return this .linetypeUnit;
		},
		getHatchStyleUnit: function ()
		{
			return this .hatchStyleUnit;
		},
		getTextureMemory: function ()
		{
			return this .textureMemory;
		},
		getMultiTexturing: function ()
		{
			return this .multiTexturing;
		},
		getProjectiveTextureMapping: function ()
		{
			return this .projectiveTextureMapping;
		},
		getDefaultTextureProperties: function ()
		{
			if (this .defaultTextureProperties)
				return this .defaultTextureProperties;

			this .defaultTextureProperties = new TextureProperties (this .getPrivateScene ());
			this .defaultTextureProperties .magnificationFilter_ = "NICEST";
			this .defaultTextureProperties .minificationFilter_  = "AVG_PIXEL_AVG_MIPMAP";
			this .defaultTextureProperties .textureCompression_  = "NICEST";
			this .defaultTextureProperties .generateMipMaps_     = true;

			this .defaultTextureProperties .setup ();

			return this .defaultTextureProperties;
		},
		getDefaultTextureTransform: function ()
		{
			if (this .defaultTextureTransform)
				return this .defaultTextureTransform;

			this .defaultTextureTransform = new TextureTransform (this .getPrivateScene ());

			this .defaultTextureTransform .setup ();

			return this .defaultTextureTransform;
		},
		getDefaultTextureCoordinate: function ()
		{
			if (this .defaultTextureCoordinate)
				return this .defaultTextureCoordinate;

			this .defaultTextureCoordinate = new TextureCoordinate (this .getPrivateScene ());

			this .defaultTextureCoordinate .setup ();

			return this .defaultTextureCoordinate;
		},
	};

	return X3DTexturingContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Time/X3DTimeContext',[
	"standard/Math/Numbers/Vector3",
],
function (Vector3)
{
"use strict";

	var lastPosition = new Vector3 (0, 0, 0);

	function X3DTimeContext ()
	{
		this .currentPosition = new Vector3 (0, 0, 0);
	}

	X3DTimeContext .prototype =
	{
		initialize: function ()
		{
			this .advanceTime (performance .now ());
		},
		getCurrentTime: function ()
		{
			return this .currentTime;
		},
		advanceTime: function (time)
		{
			time = (time + performance .timing .navigationStart) / 1000;

			var interval = time - this .currentTime;

			this .currentTime      = time;
			this .currentFrameRate = interval ? 1 / interval : 60;

			if (this .getWorld () && this .getActiveLayer ())
			{
				var cameraSpaceMatrix = this .getActiveLayer () .getViewpoint () .getCameraSpaceMatrix ();

				lastPosition .assign (this .currentPosition);
				this .currentPosition .set (cameraSpaceMatrix [12], cameraSpaceMatrix [13], cameraSpaceMatrix [14]);

				this .currentSpeed = lastPosition .subtract (this .currentPosition) .abs () * this .currentFrameRate;
			}
			else
				this .currentSpeed = 0;
		},
	};

	return X3DTimeContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Rendering/X3DRenderObject',[
	"jquery",
	"x_ite/Rendering/TextureBuffer",
	"x_ite/Bits/TraverseType",
	"standard/Math/Algorithm",
	"standard/Math/Algorithms/MergeSort",
	"standard/Math/Geometry/Camera",
	"standard/Math/Geometry/Box3",
	"standard/Math/Geometry/ViewVolume",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Utility/MatrixStack",
],
function ($,
          TextureBuffer,
	       TraverseType,
          Algorithm,
          MergeSort,
          Camera,
          Box3,
          ViewVolume,
          Vector3,
          Vector4,
          Rotation4,
          Matrix4,
          MatrixStack)
{
"use strict";

	var
		DEPTH_BUFFER_WIDTH  = 16,
		DEPTH_BUFFER_HEIGHT = DEPTH_BUFFER_WIDTH;

	function compareDistance (lhs, rhs) { return lhs .distance < rhs .distance; }

	function X3DRenderObject (executionContext)
	{
		this .cameraSpaceMatrix        = new MatrixStack (Matrix4);
		this .viewMatrix               = new MatrixStack (Matrix4);
		this .projectionMatrix         = new MatrixStack (Matrix4);
		this .modelViewMatrix          = new MatrixStack (Matrix4);
		this .viewVolumes              = [ ];
		this .globalObjects            = [ ];
		this .localObjects             = [ ];
		this .lights                   = [ ];
		this .shadow                   = [ false ];
		this .localFogs                = [ ];
		this .layouts                  = [ ];
		this .textureProjectors        = [ ];
		this .generatedCubeMapTextures = [ ];
		this .shaders                  = new Set ();
		this .collisions               = [ ];
		this .numOpaqueShapes          = 0;
		this .numTransparentShapes     = 0;
		this .numCollisionShapes       = 0;
		this .numDepthShapes           = 0;
		this .opaqueShapes             = [ ];
		this .transparentShapes        = [ ];
		this .transparencySorter       = new MergeSort (this .transparentShapes, compareDistance);
		this .collisionShapes          = [ ];
		this .activeCollisions         = { };
		this .depthShapes              = [ ];
		this .speed                    = 0;

		try
		{
			this .depthBuffer = new TextureBuffer (executionContext .getBrowser (), DEPTH_BUFFER_WIDTH, DEPTH_BUFFER_HEIGHT);
		}
		catch (error)
		{
			console .error (error);

		   this .getDepth = function () { return 0; };
		}
	}

	X3DRenderObject .prototype =
	{
		constructor: X3DRenderObject,
		initialize: function ()
		{ },
		isIndependent: function ()
		{
			return true;
		},
		getCameraSpaceMatrix: function ()
		{
			return this .cameraSpaceMatrix;
		},
		getViewMatrix: function ()
		{
			return this .viewMatrix;
		},
		getProjectionMatrix: function ()
		{
			return this .projectionMatrix;
		},
		getModelViewMatrix: function ()
		{
			return this .modelViewMatrix;
		},
		getViewVolumes: function ()
		{
			return this .viewVolumes;
		},
		getViewVolume: function ()
		{
			return this .viewVolumes [this .viewVolumes .length - 1];
		},
		getGlobalObjects: function ()
		{
			return this .globalObjects;
		},
		getLocalObjects: function ()
		{
			return this .localObjects;
		},
		getLights: function ()
		{
			return this .lights;
		},
		pushShadow: function (value)
		{
			this .shadow .unshift (value || this .shadow [0]);
		},
		popShadow: function (value)
		{
			this .shadow .pop ();
		},
		setGlobalFog: (function ()
		{
			var modelViewMatrix = new Matrix4 ();

			return function (fog)
			{
				var fogContainer = this .localFogs [0] || fog .getFogs () .pop ();

				modelViewMatrix .assign (fog .getModelMatrix ()) .multRight (this .getViewMatrix () .get ());
				fogContainer .set (fog, modelViewMatrix);

				this .localFog = this .localFogs [0] = fogContainer;
			};
		})(),
		pushLocalFog: function (localFog)
		{
			this .localFogs .push (localFog);

			this .localFog = localFog;
		},
		popLocalFog: function ()
		{
			var localFog = this .localFogs .pop ();

			this .localFog = this .localFogs [this .localFogs .length - 1];

			return localFog;
		},
		getLayouts: function ()
		{
			return this .layouts;
		},
		getParentLayout: function ()
		{
			return this .layouts .length ? this .layouts [this .layouts .length - 1] : null;
		},
		getTextureProjectors: function ()
		{
			return this .textureProjectors;
		},
		getGeneratedCubeMapTextures: function ()
		{
			return this .generatedCubeMapTextures;
		},
		getShaders: function ()
		{
			return this .shaders;
		},
		getCollisions: function ()
		{
			return this .collisions;
		},
		setNumCollisionShapes: function (value)
		{
			this .numCollisionShapes = value;
		},
		getNumCollisionShapes: function ()
		{
			return this .numCollisionShapes;
		},
		getCollisionShapes: function ()
		{
			return this .collisionShapes;
		},
		setNumDepthShapes: function (value)
		{
			this .numDepthShapes = value;
		},
		getNumDepthShapes: function ()
		{
			return this .numDepthShapes;
		},
		getDepthShapes: function ()
		{
			return this .depthShapes;
		},
		setNumOpaqueShapes: function (value)
		{
			this .numOpaqueShapes = value;
		},
		getNumOpaqueShapes: function ()
		{
			return this .numOpaqueShapes;
		},
		getOpaqueShapes: function ()
		{
			return this .opaqueShapes;
		},
		setNumTransparentShapes: function (value)
		{
			this .numTransparentShapes = value;
		},
		getNumTransparentShapes: function ()
		{
			return this .numTransparentShapes;
		},
		getTransparentShapes: function ()
		{
			return this .transparentShapes;
		},
		constrainTranslation: function (translation, stepBack)
		{
			///  Contrains @a translation to a possible value the avatar can move.  If the avatar reaches and intersects with an
			///  and obstacle and @a stepBack is true a translation in the opposite directiion is returned.  Future implementation will
			///  will then return a value where the avatar slides along the wall.  Modifies translation in place.

			var distance = this .getDistance (translation);

			// Constrain translation when the viewer collides with an obstacle.

			distance -= this .getNavigationInfo () .getCollisionRadius ();

			if (distance > 0)
			{
				// Move.

				var length = translation .abs ();

				if (length > distance)
				{
					// Collision, the avatar would intersect with the obstacle.

					return translation .normalize () .multiply (distance);
				}

				// Everything is fine.

				return translation;
			}

			// Collision, the avatar is already within an obstacle.

			if (stepBack)
				return this .constrainTranslation (translation .normalize () .multiply (distance), false);

			return translation .assign (Vector3 .Zero);
		},
		getDistance: (function ()
		{
			var
				projectionMatrix            = new Matrix4 (),
				cameraSpaceProjectionMatrix = new Matrix4 (),
				localOrientation            = new Rotation4 (0, 0, 1, 0),
				vector                      = new Vector3 (0, 0, 0),
				rotation                    = new Rotation4 (0, 0, 1, 0);

			return function (direction)
			{
				///  Returns the distance to the closest object in @a direction.  The maximum determinable value is avatarHeight * 2.

				try
				{
				   var t0 = performance .now ();

					var
						viewpoint       = this .getViewpoint (),
						navigationInfo  = this .getNavigationInfo (),
						collisionRadius = navigationInfo .getCollisionRadius (),
						bottom          = navigationInfo .getStepHeight () - navigationInfo .getAvatarHeight (),
						nearValue       = navigationInfo .getNearValue (),
						avatarHeight    = navigationInfo .getAvatarHeight ();

					// Determine width and height of camera

					// Reshape camera

					Camera .ortho (-collisionRadius,
					               collisionRadius,
					               Math .min (bottom, -collisionRadius), /// TODO: bottom could be a positive value if stepHeight > avatarHeight.
					               collisionRadius,
					               nearValue,
					               Math .max (collisionRadius * 2, avatarHeight * 2),
					               projectionMatrix);

					// Translate camera to user position and to look in the direction of the direction.

					localOrientation .assign (viewpoint .orientation_ .getValue ()) .inverse () .multRight (viewpoint .getOrientation ());
					rotation .setFromToVec (Vector3 .zAxis, vector .assign (direction) .negate ()) .multRight (localOrientation);
					viewpoint .straightenHorizon (rotation);

					cameraSpaceProjectionMatrix .assign (viewpoint .getModelMatrix ());
					cameraSpaceProjectionMatrix .translate (viewpoint .getUserPosition ());
					cameraSpaceProjectionMatrix .rotate (rotation);
					cameraSpaceProjectionMatrix .inverse ();

					cameraSpaceProjectionMatrix .multRight (projectionMatrix);
					cameraSpaceProjectionMatrix .multLeft (viewpoint .getCameraSpaceMatrix ());

					this .getProjectionMatrix () .pushMatrix (cameraSpaceProjectionMatrix);

					var depth = this .getDepth (projectionMatrix);

					this .getProjectionMatrix () .pop ();

					this .collisionTime += performance .now () - t0;
					return -depth;
				}
				catch (error)
				{
					console .log (error);
				}
			};
		})(),
		getDepth: (function ()
		{
			var
				depthBufferViewport   = new Vector4 (0, 0, DEPTH_BUFFER_WIDTH, DEPTH_BUFFER_HEIGHT),
				depthBufferViewVolume = new ViewVolume ();

			depthBufferViewVolume .set (Matrix4 .Identity, depthBufferViewport, depthBufferViewport);

			return function (projectionMatrix)
			{
				///  Returns the depth value to the closest object.  The maximum determinable value is avatarHeight * 2.

				this .depthBuffer .bind ();

				this .viewVolumes .push (depthBufferViewVolume);
				this .depth (this .collisionShapes, this .numCollisionShapes);
				this .viewVolumes .pop ();

				var depth = this .depthBuffer .getDepth (projectionMatrix, depthBufferViewport);

				this .depthBuffer .unbind ();

				return depth;
			};
		})(),
		render: function (type, callback, group)
		{
			switch (type)
			{
				case TraverseType .COLLISION:
				{
					// Collect for collide and gravite
					this .numCollisionShapes = 0;

					callback .call (group, type, this);
					this .collide ();
					this .gravite ();
					break;
				}
				case TraverseType .DEPTH:
				{
					this .numDepthShapes = 0;

					callback .call (group, type, this);
					this .depth (this .depthShapes, this .numDepthShapes);
					break;
				}
				case TraverseType .DISPLAY:
				{
					this .lightIndex           = 0;
					this .numOpaqueShapes      = 0;
					this .numTransparentShapes = 0;

					this .setGlobalFog (this .getFog ());

					callback .call (group, type, this);
					this .draw (group);
					break;
				}
			}
		},
		addCollisionShape: (function ()
		{
			var
				bboxSize   = new Vector3 (0, 0, 0),
				bboxCenter = new Vector3 (0, 0, 0);

			return function (shapeNode)
			{
				var modelViewMatrix = this .getModelViewMatrix () .get ();

				modelViewMatrix .multDirMatrix (bboxSize   .assign (shapeNode .getBBoxSize ()));
				modelViewMatrix .multVecMatrix (bboxCenter .assign (shapeNode .getBBoxCenter ()));

				var
					radius     = bboxSize .abs () / 2,
					viewVolume = this .viewVolumes [this .viewVolumes .length - 1];

				if (viewVolume .intersectsSphere (radius, bboxCenter))
				{
					if (this .numCollisionShapes === this .collisionShapes .length)
						this .collisionShapes .push ({ renderer: this, browser: this .getBrowser (), modelViewMatrix: new Float32Array (16), collisions: [ ], clipPlanes: [ ] });

					var context = this .collisionShapes [this .numCollisionShapes];

					++ this .numCollisionShapes;

					context .modelViewMatrix .set (modelViewMatrix);
					context .shapeNode = shapeNode;
					context .scissor   = viewVolume .getScissor ();

					// Collisions

					var
						sourceCollisions      = this .collisions,
						destinationCollisions = context .collisions;

					for (var i = 0, length = sourceCollisions .length; i < length; ++ i)
						destinationCollisions [i] = sourceCollisions [i];

					destinationCollisions .length = length;

					// Clip planes

					var
						sourceClipPlanes      = this .localObjects,
						destinationClipPlanes = context .clipPlanes;

					for (var i = 0, length = sourceClipPlanes .length; i < length; ++ i)
						destinationClipPlanes [i] = sourceClipPlanes [i];

					destinationClipPlanes .length = length;

					return true;
				}

				return false;
			};
		})(),
		addDepthShape: (function ()
		{
			var
				bboxSize   = new Vector3 (0, 0, 0),
				bboxCenter = new Vector3 (0, 0, 0);

			return function (shapeNode)
			{
				var modelViewMatrix = this .getModelViewMatrix () .get ();

				modelViewMatrix .multDirMatrix (bboxSize   .assign (shapeNode .getBBoxSize ()));
				modelViewMatrix .multVecMatrix (bboxCenter .assign (shapeNode .getBBoxCenter ()));

				var
					radius     = bboxSize .abs () / 2,
					viewVolume = this .viewVolumes [this .viewVolumes .length - 1];

				if (viewVolume .intersectsSphere (radius, bboxCenter))
				{
					if (this .numDepthShapes === this .depthShapes .length)
						this .depthShapes .push ({ renderer: this, browser: this .getBrowser (), modelViewMatrix: new Float32Array (16), clipPlanes: [ ] });

					var context = this .depthShapes [this .numDepthShapes];

					++ this .numDepthShapes;

					context .modelViewMatrix .set (modelViewMatrix);
					context .shapeNode = shapeNode;
					context .scissor   = viewVolume .getScissor ();

					// Clip planes

					var
						sourceClipPlanes      = this .localObjects,
						destinationClipPlanes = context .clipPlanes;

					for (var i = 0, length = sourceClipPlanes .length; i < length; ++ i)
						destinationClipPlanes [i] = sourceClipPlanes [i];

					destinationClipPlanes .length = length;

					return true;
				}

				return false;
			};
		})(),
		addDisplayShape: (function ()
		{
			var
				bboxSize   = new Vector3 (0, 0, 0),
				bboxCenter = new Vector3 (0, 0, 0);

			return function (shapeNode)
			{
				var modelViewMatrix = this .getModelViewMatrix () .get ();

				modelViewMatrix .multDirMatrix (bboxSize   .assign (shapeNode .getBBoxSize ()));
				modelViewMatrix .multVecMatrix (bboxCenter .assign (shapeNode .getBBoxCenter ()));

				var
					radius     = bboxSize .abs () / 2,
					viewVolume = this .viewVolumes [this .viewVolumes .length - 1];

				if (viewVolume .intersectsSphere (radius, bboxCenter))
				{
					if (shapeNode .getTransparent ())
					{
						var num = this .numTransparentShapes;

						if (num === this .transparentShapes .length)
							this .transparentShapes .push (this .createShapeContext (true));

						var context = this .transparentShapes [num];

						++ this .numTransparentShapes;
					}
					else
					{
						var num = this .numOpaqueShapes;

						if (num === this .opaqueShapes .length)
							this .opaqueShapes .push (this .createShapeContext (false));

						var context = this .opaqueShapes [num];

						++ this .numOpaqueShapes;
					}

					context .modelViewMatrix .set (modelViewMatrix);
					context .scissor .assign (viewVolume .getScissor ());
					context .shapeNode = shapeNode;
					context .distance  = bboxCenter .z;
					context .fogNode   = this .localFog;
					context .shadow    = this .shadow [0];

					// Clip planes and local lights

					var
						sourceShaderObjects      = this .localObjects,
						destinationShaderObjects = context .localObjects;

					for (var i = 0, length = sourceShaderObjects .length; i < length; ++ i)
						destinationShaderObjects [i] = sourceShaderObjects [i];

					destinationShaderObjects .length = length;

					return true;
				}

				return false;
			};
		})(),
		createShapeContext: function (transparent)
		{
			return {
				renderer: this,
				browser: this .getBrowser (),
				transparent: transparent,
				geometryType: 3,
				fogCoords: false,
				colorMaterial: false,
				modelViewMatrix: new Float32Array (16),
				scissor: new Vector4 (0, 0, 0, 0),
				localObjects: [ ],
				linePropertiesNode: null,
				materialNode: null,
				textureNode: null,
				textureTransformNode: null,
				shaderNode: null,
				shadow: false,
			};
		},
		collide: (function ()
		{
			var
				invModelViewMatrix = new Matrix4 (),
				modelViewMatrix    = new Matrix4 (),
				collisionBox       = new Box3 (Vector3 .Zero, Vector3 .Zero),
				collisionSize      = new Vector3 (0, 0, 0);

			return function ()
			{
				// Collision nodes are handled here.

				var
					activeCollisions = { }, // current active Collision nodes
					collisionRadius2 = 2.2 * this .getNavigationInfo () .getCollisionRadius (); // Make the radius a little bit larger.

				collisionSize .set (collisionRadius2, collisionRadius2, collisionRadius2);

				for (var i = 0, length = this .numCollisionShapes; i < length; ++ i)
				{
					try
					{
						var
							context    = this .collisionShapes [i],
							collisions = context .collisions;

						if (collisions .length)
						{
						   collisionBox .set (collisionSize, Vector3 .Zero);
							collisionBox .multRight (invModelViewMatrix .assign (context .modelViewMatrix) .inverse ());

							if (context .shapeNode .intersectsBox (collisionBox, context .clipPlanes, modelViewMatrix .assign (context .modelViewMatrix)))
							{
							   for (var c = 0; c < collisions .length; ++ c)
									activeCollisions [collisions [c] .getId ()] = collisions [c];
							}
						}
					}
					catch (error)
					{
						console .log (error);
					}
				}

				// Set isActive to FALSE for affected nodes.

				if (! $.isEmptyObject (this .activeCollisions))
				{
					var inActiveCollisions = $.isEmptyObject (activeCollisions)
					                         ? this .activeCollisions
					                         : Algorithm .set_difference (this .activeCollisions, activeCollisions, { });

					for (var key in inActiveCollisions)
						inActiveCollisions [key] .set_active (false);
				}

				// Set isActive to TRUE for affected nodes.

				this .activeCollisions = activeCollisions;

				for (var key in activeCollisions)
					activeCollisions [key] .set_active (true);
			};
		})(),
		gravite: (function ()
		{
			var
				projectionMatrix            = new Matrix4 (),
				cameraSpaceProjectionMatrix = new Matrix4 (),
				translation                 = new Vector3 (0, 0, 0),
				rotation                    = new Rotation4 (0, 0, 1, 0);

			return function ()
			{
			   try
			   {
					var
						browser    = this .getBrowser (),
						shaderNode = browser .getDepthShader ();

					if (shaderNode .getValid ())
					{
						// Terrain following and gravitation

						if (browser .getActiveLayer () === this)
						{
							if (browser .getCurrentViewer () !== "WALK")
								return;
						}
						else if (this .getNavigationInfo () .getViewer () !== "WALK")
							return;

						// Get NavigationInfo values

						var
							navigationInfo  = this .getNavigationInfo (),
							viewpoint       = this .getViewpoint (),
							collisionRadius = navigationInfo .getCollisionRadius (),
							nearValue       = navigationInfo .getNearValue (),
							avatarHeight    = navigationInfo .getAvatarHeight (),
							stepHeight      = navigationInfo .getStepHeight ();

						// Reshape viewpoint for gravite.

						Camera .ortho (-collisionRadius,
						               collisionRadius,
						               -collisionRadius,
						               collisionRadius,
						               nearValue,
						               Math .max (collisionRadius * 2, avatarHeight * 2),
						               projectionMatrix);

						// Transform viewpoint to look down the up vector

						var
							upVector = viewpoint .getUpVector (),
							down     = rotation .setFromToVec (Vector3 .zAxis, upVector);

						cameraSpaceProjectionMatrix .assign (viewpoint .getModelMatrix ());
						cameraSpaceProjectionMatrix .translate (viewpoint .getUserPosition ());
						cameraSpaceProjectionMatrix .rotate (down);
						cameraSpaceProjectionMatrix .inverse ();

						cameraSpaceProjectionMatrix .multRight (projectionMatrix);
						cameraSpaceProjectionMatrix .multLeft (viewpoint .getCameraSpaceMatrix ());

						this .getProjectionMatrix () .pushMatrix (cameraSpaceProjectionMatrix);

						var distance = -this .getDepth (projectionMatrix);

						this .getProjectionMatrix () .pop ();

						// Gravite or step up

						distance -= avatarHeight;

						var up = rotation .setFromToVec (Vector3 .yAxis, upVector);

						if (distance > 0)
						{
							// Gravite and fall down the to the floor

							var currentFrameRate = this .speed ? browser .getCurrentFrameRate () : 1000000;

							this .speed -= browser .getBrowserOptions () .Gravity_ .getValue () / currentFrameRate;

							var y = this .speed / currentFrameRate;

							if (y < -distance)
							{
								// The ground is reached.
								y = -distance;
								this .speed = 0;
							}

							viewpoint .positionOffset_ = viewpoint .positionOffset_ .getValue () .add (up .multVecRot (translation .set (0, y, 0)));
						}
						else
						{
							this .speed = 0;

							distance = -distance;

							if (distance > 0.01 && distance < stepHeight)
							{
								// Step up
								this .constrainTranslation (up .multVecRot (translation .set (0, distance, 0)), false);

								//if (getBrowser () -> getBrowserOptions () -> animateStairWalks ())
								//{
								//	float step = getBrowser () -> getCurrentSpeed () / getBrowser () -> getCurrentFrameRate ();
								//	step = abs (getViewMatrix () .mult_matrix_dir (Vector3f (0, step, 0) * up));
								//
								//	Vector3f offset = Vector3f (0, step, 0) * up;
								//
								//	if (math::abs (offset) > math::abs (translation) or getBrowser () -> getCurrentSpeed () == 0)
								//		offset = translation;
								//
								//	getViewpoint () -> positionOffset () += offset;
								//}
								//else
									viewpoint .positionOffset_ = translation .add (viewpoint .positionOffset_ .getValue ());
							}
						}
					}
				}
				catch (error)
				{
				   console .log (error);
				}
			};
		})(),
		depth: (function ()
		{
			var projectionMatrixArray = new Float32Array (16);

			return function (shapes, numShapes)
			{
				var
					browser    = this .getBrowser (),
					gl         = browser .getContext (),
					viewport   = this .getViewVolume () .getViewport (),
					shaderNode = browser .getDepthShader ();

				// Configure depth shader.

				if (shaderNode .getValid ())
				{
					shaderNode .enable (gl);

					projectionMatrixArray .set (this .getProjectionMatrix () .get ());

					gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, projectionMatrixArray);

					// Configure viewport and background

					gl .viewport (viewport [0],
					              viewport [1],
					              viewport [2],
					              viewport [3]);

					gl .scissor (viewport [0],
					             viewport [1],
					             viewport [2],
					             viewport [3]);

					gl .clearColor (1, 0, 0, 0); // Must be '1, 0, 0, 0'.
					gl .clear (gl .COLOR_BUFFER_BIT | gl .DEPTH_BUFFER_BIT);

					// Render all objects

					gl .enable (gl .DEPTH_TEST);
					gl .depthMask (true);
					gl .disable (gl .BLEND);
					gl .disable (gl .CULL_FACE);

					for (var s = 0; s < numShapes; ++ s)
					{
						var
							context = shapes [s],
							scissor = context .scissor;

						// TODO: viewport must not be the browser or layer viewport.
						gl .scissor (scissor .x,
						             scissor .y,
						             scissor .z,
						             scissor .w);

						// Clip planes

						shaderNode .setLocalObjects (gl, context .clipPlanes);

						// modelViewMatrix

						gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix, false, context .modelViewMatrix);

						// Draw

						context .shapeNode .depth (gl, context, shaderNode);
					}

					shaderNode .disable (gl);
				}
			};
		})(),
		draw: (function ()
		{
			var
				viewportArray          = new Int32Array (4),
				projectionMatrixArray  = new Float32Array (16),
				cameraSpaceMatrixArray = new Float32Array (16);

			return function (group)
			{
				var
					browser                  = this .getBrowser (),
					gl                       = browser .getContext (),
					viewport                 = this .getViewVolume () .getViewport (),
					shaders                  = this .shaders,
					lights                   = this .lights,
					textureProjectors        = this .textureProjectors,
					generatedCubeMapTextures = this .generatedCubeMapTextures;


				// PREPARATIONS


				if (this .isIndependent ())
				{
					// Render shadow maps.

					for (var i = 0, length = lights .length; i < length; ++ i)
						lights [i] .renderShadowMap (this);

					// Render GeneratedCubeMapTextures.

					for (var i = 0, length = generatedCubeMapTextures .length; i < length; ++ i)
						generatedCubeMapTextures [i] .renderTexture (this, group);
				}


				// DRAW


				// Set up shadow matrix for all lights, and matrix for all projective textures.

				browser .getHeadlight () .setGlobalVariables (this);

				for (var i = 0, length = lights .length; i < length; ++ i)
					lights [i] .setGlobalVariables (this);

				for (var i = 0, length = textureProjectors .length; i < length; ++ i)
					textureProjectors [i] .setGlobalVariables (this);

				// Configure viewport and background

				gl .viewport (viewport [0],
				              viewport [1],
				              viewport [2],
				              viewport [3]);

				gl .scissor (viewport [0],
				             viewport [1],
				             viewport [2],
								 viewport [3]);

				// Draw background.

				gl .clear (gl .DEPTH_BUFFER_BIT);

				this .getBackground () .display (gl, this, viewport);

				// Set global uniforms.

				viewportArray          .set (viewport);
				cameraSpaceMatrixArray .set (this .getCameraSpaceMatrix () .get ());
				projectionMatrixArray  .set (this .getProjectionMatrix () .get ());

				if (browser .hasPointShader ())  shaders .add (browser .getPointShader ());
				if (browser .hasLineShader ())   shaders .add (browser .getLineShader ());
				if (browser .hasShadowShader ()) shaders .add (browser .getShadowShader ());
				shaders .add (browser .getDefaultShader ());

				shaders .forEach (function (shader)
				{
					shader .setGlobalUniforms (gl, this, cameraSpaceMatrixArray, projectionMatrixArray, viewportArray);
				},
				this);

				// Sorted blend

				// Render opaque objects first

				gl .enable (gl .DEPTH_TEST);
				gl .depthMask (true);
				gl .disable (gl .BLEND);

				var opaqueShapes = this .opaqueShapes;

				for (var i = 0, length = this .numOpaqueShapes; i < length; ++ i)
				{
					var
						context = opaqueShapes [i],
						scissor = context .scissor;

					gl .scissor (scissor .x,
					             scissor .y,
					             scissor .z,
					             scissor .w);

					context .shapeNode .display (gl, context);
				}

				// Render transparent objects

				gl .depthMask (false);
				gl .enable (gl .BLEND);

				var transparentShapes = this .transparentShapes;

				this .transparencySorter .sort (0, this .numTransparentShapes);

				for (var i = 0, length = this .numTransparentShapes; i < length; ++ i)
				{
					var
						context = transparentShapes [i],
						scissor = context .scissor;

					gl .scissor (scissor .x,
					             scissor .y,
					             scissor .z,
					             scissor .w);

					context .shapeNode .display (gl, context);
				}

				gl .depthMask (true);
				gl .disable (gl .BLEND);


				// POST DRAW


				gl .activeTexture (gl .TEXTURE0);

				if (this .isIndependent ())
				{
					// Recycle clip planes, local fogs, local lights, and local projective textures.

					var localObjects = browser .getLocalObjects ();

					for (var i = 0, length = localObjects .length; i < length; ++ i)
						localObjects [i] .dispose ();

					localObjects .length = 0;

					// Recycle global lights and global projective textures.

					var globalObjects = this .globalObjects;

					for (var i = 0, length = globalObjects .length; i < length; ++ i)
						globalObjects [i] .dispose ();
				}

				// Reset containers.

				shaders .clear ();

				this .globalObjects .length = 0;

				lights                   .length = 0;
				textureProjectors        .length = 0;
				generatedCubeMapTextures .length = 0;
			};
		})(),
	};

	return X3DRenderObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/BindableStack',[
	"x_ite/Basic/X3DBaseNode",
],
function (X3DBaseNode)
{
"use strict";

	function BindableStack (executionContext, layer, defaultNode)
	{
		X3DBaseNode .call (this, executionContext);

		this .array = [ defaultNode ];
	}

	BindableStack .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: BindableStack,
		getTypeName: function ()
		{
			return "BindableStack";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "bindableStack";
		},
		get: function ()
		{
			return this .array;
		},
		top: function ()
		{
			return this .array [this .array .length - 1];
		},
		pushOnTop: function (node)
		{
			if (node !== this .array [0])
			{
				this .top () .isBound_ = false;
				this .array .push (node);
			}

			node .isBound_  = true;
			node .bindTime_ = this .getBrowser () .getCurrentTime ();

			this .addNodeEvent ();
		},
		update: function (layer, removedNodes, changedNodes)
		{
			if (removedNodes .length === 0 && changedNodes .length === 0)
				return;

			// Save top node for later use.

			var boundNode = this .top ();

			// Remove invisible nodes and unbind them if needed.

			for (var i = 0, length = removedNodes .length; i < length; ++ i)
			{
				var
					removedNode = removedNodes [i],
					index       = this .array .indexOf (removedNode);

				if (index > -1)
				{
					this .array .splice (index, 1);
				}

				if (removedNode .isBound_ .getValue ())
				{
					removedNode .isBound_ = false;
				}
			}

			// Unbind nodes with set_bind false and pop top node.

			var unbindNodes = changedNodes .filter (node => ! node .set_bind_ .getValue ());

			for (var i = 0, length = unbindNodes .length; i < length; ++ i)
			{
				unbindNodes [i] .isBound_ = false;
			}

			if (unbindNodes .indexOf (boundNode) > -1)
			{
				this .array .pop ();
			}

			// Push nodes with set_bind true to top of stack.

			var bindNodes = changedNodes .filter (node => node .set_bind_ .getValue ());

			for (var i = 0, length = bindNodes .length; i < length; ++ i)
			{
				var
					bindNode = bindNodes [i],
					index    = this .array .indexOf (bindNode);

				if (index > -1)
				{
					this .array .splice (index, 1);
				}

				this .array .push (bindNode);
			}

			// Bind top node if not bound.

			var top = this .top ();

			if (! top .isBound_ .getValue ())
			{
				// Bound node could be the default node, and this node must be unbound here.
				boundNode .isBound_ = false;

				top .isBound_  = true;
				top .bindTime_ = this .getBrowser () .getCurrentTime ();

				top .transitionStart (layer, boundNode);

				this .addNodeEvent ();
			}
		},
	});

	return BindableStack;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/BindableList',[
	"x_ite/Basic/X3DBaseNode",
],
function (X3DBaseNode)
{
"use strict";

	function BindableList (executionContext, layer, defaultNode)
	{
		X3DBaseNode .call (this, executionContext);

		this .collected    = [ defaultNode ];
		this .array        = [ defaultNode ];
		this .updateTime   = 0;
		this .removedNodes = [ ];
	}

	BindableList .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: BindableList,
		getTypeName: function ()
		{
			return "BindableList";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "bindableList";
		},
		get: function ()
		{
			return this .array;
		},
		getBound: function (name)
		{
			if (this .array .length > 1)
			{
				var
					enableInlineBindables = false,
					masterScene           = this .getMasterScene ();

				if (name && name .length)
				{
					// Return first viewpoint with @name.

					for (var i = 1, length = this .array .length; i < length; ++ i)
					{
						var node = this .array [i];

						if (! enableInlineBindables && node .getScene () !== masterScene)
							continue;

						if (node .getName () == name)
							return node;
					}
				}

				// Return first bound viewpoint in scene.

				for (var i = 1, length = this .array .length; i < length; ++ i)
				{
					var node = this .array [i];

					if (! enableInlineBindables && node .getScene () !== masterScene)
						continue;

					if (node .isBound_ .getValue ())
						return node;
				}

				// Return first viewpoint in scene.

				for (var i = 1, length = this .array .length; i < length; ++ i)
				{
					var node = this .array [i];

					if (! enableInlineBindables && node .getScene () !== masterScene)
						continue;

					return node;
				}
			}

			// Return default viewpoint.

			return this .array [0];
		},
		push: function (node)
		{
			return this .collected .push (node);
		},
		update: function (layer, stack)
		{
			var
				changedNodes = this .collected .filter (node => node .updateTime > this .updateTime),
				removedNodes = this .removedNodes;

			if (! equals (this .collected, this .array))
			{
				// Unbind nodes not in current list (collected);

				for (var i = 0, length = this .array .length; i < length; ++ i)
				{
					var node = this .array [i];

					if (this .collected .indexOf (node) < 0)
					{
						removedNodes .push (node);
					}
				}

				// Swap arrays.

				var tmp = this .array;

				this .array     = this .collected;
				this .collected = tmp;
			}

			// Clear collected array.

			this .collected .length = 1;

			// Update stack.

			stack .update (layer, removedNodes, changedNodes)

			removedNodes .length = 0;

			// Advance update time.

			this .updateTime = performance .now () / 1000;
		},
	});

	function equals (lhs, rhs)
	{
		if (lhs .length !== rhs .length)
			return false;

		for (var i = 0; i < lhs .length; ++ i)
		{
			if (lhs [i] !== rhs [i])
				return false
		}

		return true;
	}

	return BindableList;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/NavigationInfo',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DBindableNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBindableNode,
          TraverseType,
          X3DConstants)
{
"use strict";

	var TransitionType =
	{
		TELEPORT: true,
		LINEAR:   true,
		ANIMATE:  true,
	};

	function NavigationInfo (executionContext)
	{
		X3DBindableNode .call (this, executionContext);

		this .addType (X3DConstants .NavigationInfo);

		this .addChildObjects ("transitionStart",  new Fields .SFBool (),
		                       "transitionActive", new Fields .SFBool (),
		                       "availableViewers", new Fields .MFString (),
		                       "viewer",           new Fields .SFString ("EXAMINE"));

		this .avatarSize_      .setUnit ("length");
		this .speed_           .setUnit ("speed");
		this .visibilityLimit_ .setUnit ("speed");
	}

	NavigationInfo .prototype = Object .assign (Object .create (X3DBindableNode .prototype),
	{
		constructor: NavigationInfo,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "type",               new Fields .MFString ("EXAMINE", "ANY")),
			new X3DFieldDefinition (X3DConstants .inputOutput, "avatarSize",         new Fields .MFFloat (0.25, 1.6, 0.75)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "speed",              new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "headlight",          new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "visibilityLimit",    new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "transitionType",     new Fields .MFString ("LINEAR")),
			new X3DFieldDefinition (X3DConstants .inputOutput, "transitionTime",     new Fields .SFTime (1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "transitionComplete", new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",            new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",           new Fields .SFTime ()),
		]),
		getTypeName: function ()
		{
			return "NavigationInfo";
		},
		getComponentName: function ()
		{
			return "Navigation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DBindableNode .prototype .initialize .call (this);

			this .type_               .addInterest ("set_type__",               this);
			this .headlight_          .addInterest ("set_headlight__",          this);
			this .transitionStart_    .addInterest ("set_transitionStart__",    this);
			this .transitionComplete_ .addInterest ("set_transitionComplete__", this);
			this .isBound_            .addInterest ("set_isBound__",            this);

			this .set_type__ ();
			this .set_headlight__ ();
		},
		getViewer: function ()
		{
		   return this .viewer_ .getValue ();
		},
		getCollisionRadius: function ()
		{
			if (this .avatarSize_ .length > 0)
			{
				if (this .avatarSize_ [0] > 0)
					return this .avatarSize_ [0];
			}

			return 0.25;
		},
		getAvatarHeight: function ()
		{
			if (this .avatarSize_ .length > 1)
				return this .avatarSize_ [1];

			return 1.6;
		},
		getStepHeight: function ()
		{
			if (this .avatarSize_ .length > 2)
				return this .avatarSize_ [2];

			return 0.75;
		},
		getNearValue: function ()
		{
			var nearValue = this .getCollisionRadius ();

			if (nearValue === 0)
				return 1e-5;

			else
				return nearValue / 2;
		},
		getFarValue: function (viewpoint)
		{
			return this .visibilityLimit_ .getValue ()
				    ? this .visibilityLimit_ .getValue ()
				    : viewpoint .getMaxFarValue ();
		},
		getTransitionType: function ()
		{
			for (var i = 0, length = this .transitionType_ .length; i < length; ++ i)
			{
				var
					value          = this .transitionType_ [i],
					transitionType = TransitionType [value];

				if (transitionType)
					return value;
			}

			return "LINEAR";
		},
		set_type__: function ()
		{
			// Determine active viewer.

			this .viewer_ = "EXAMINE";

			for (var i = 0; i < this .type_ .length; ++ i)
			{
			   var string = this .type_ [i];

				switch (string)
				{
					case "EXAMINE":
					case "WALK":
					case "FLY":
					case "LOOKAT":
					case "PLANE":
					case "NONE":
						this .viewer_ = string;
						break;
					case "PLANE_create3000.de":
						this .viewer_ = "PLANE";
						break;
					default:
						continue;
				}

				// Leave for loop.
				break;
			}

			// Determine available viewers.

			var
				examineViewer = false,
				walkViewer    = false,
				flyViewer     = false,
				planeViewer   = false,
				noneViewer    = false,
				lookAt        = false;

			if (! this .type_ .length)
			{
				examineViewer = true;
				walkViewer    = true;
				flyViewer     = true;
				planeViewer   = true;
				noneViewer    = true;
				lookAt        = true;
			}
			else
			{
				for (var i = 0; i < this .type_ .length; ++ i)
				{
				   var string = this .type_ [i];

					switch (string)
					{
						case "EXAMINE":
							examineViewer = true;
							continue;
						case "WALK":
							walkViewer = true;
							continue;
						case "FLY":
							flyViewer = true;
							continue;
						case "LOOKAT":
							lookAt = true;
							continue;
						case "PLANE":
							planeViewer = true;
							continue;
						case "NONE":
							noneViewer = true;
							continue;
						case "ANY":
							examineViewer = true;
							walkViewer    = true;
							flyViewer     = true;
							planeViewer   = true;
							noneViewer    = true;
							lookAt        = true;
							break;
						default:
							// Some string defaults to EXAMINE.
							examineViewer = true;
							continue;
					}

					break;
				}
			}

			this .availableViewers_ .length = 0;

			if (examineViewer)
				this .availableViewers_ .push ("EXAMINE");

			if (walkViewer)
				this .availableViewers_ .push ("WALK");

			if (flyViewer)
				this .availableViewers_ .push ("FLY");

			if (planeViewer)
				this .availableViewers_ .push ("PLANE");

			if (lookAt)
				this .availableViewers_ .push ("LOOKAT");

			if (noneViewer)
				this .availableViewers_ .push ("NONE");
		},
		set_headlight__: function ()
		{
			if (this .headlight_ .getValue ())
				delete this .enable;
			else
				this .enable = Function .prototype;
		},
		set_transitionStart__: function ()
		{
			if (! this .transitionActive_ .getValue ())
				this .transitionActive_ = true;
		},
		set_transitionComplete__: function ()
		{
			if (this .transitionActive_ .getValue ())
				this .transitionActive_ = false;
		},
		set_isBound__: function ()
		{
			if (this .isBound_ .getValue ())
				return;

			if (this .transitionActive_ .getValue ())
				this .transitionActive_ = false;
		},
		enable: function (type, renderObject)
		{
			if (type !== TraverseType .DISPLAY)
				return;

			if (this .headlight_ .getValue ())
				renderObject .getGlobalObjects () .push (renderObject .getBrowser () .getHeadlight ());
		},
		traverse: function (type, renderObject)
		{
			renderObject .getLayer () .getNavigationInfos () .push (this);
		}
	});

	return NavigationInfo;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/X3DFogObject',[
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix3",
	"standard/Utility/ObjectCache",
],
function (X3DConstants,
          Matrix3,
          ObjectCache)
{
"use strict";

	var Fogs = ObjectCache (FogContainer);

	function FogContainer ()
	{
		this .fogMatrix = new Float32Array (9);
	}

	FogContainer .prototype =
	{
		constructor: FogContainer,
		set: function (fogNode, modelViewMatrix)
		{
			this .fogNode = fogNode;

			try
			{
				this .fogMatrix .set (modelViewMatrix .submatrix .inverse ());
			}
			catch (error)
			{
				this .fogMatrix .set (Matrix3 .Identity);
			}
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			if (shaderObject .hasFog (this))
				return;

			var
				fogNode         = this .fogNode,
				visibilityRange = Math .max (0, fogNode .visibilityRange_ .getValue ());

			if (fogNode .getHidden () || visibilityRange === 0)
			{
				gl .uniform1i (shaderObject .x3d_FogType, 0); // NO_FOG
			}
			else
			{
				var color  = fogNode .color_ .getValue ();

				gl .uniform1i        (shaderObject .x3d_FogType,            fogNode .fogType);
				gl .uniform3f        (shaderObject .x3d_FogColor,           color .r, color .g, color .b);
				gl .uniform1f        (shaderObject .x3d_FogVisibilityRange, visibilityRange);
				gl .uniformMatrix3fv (shaderObject .x3d_FogMatrix, false,   this .fogMatrix);
			}
		},
		dispose: function ()
		{
		   Fogs .push (this);
		},
	};

	function X3DFogObject (executionContext)
	{
		this .addType (X3DConstants .X3DFogObject);

		this .visibilityRange_ .setUnit ("length");

		this .hidden = false;
	}

	X3DFogObject .prototype =
	{
		constructor: X3DFogObject,
		initialize: function ()
		{
			this .fogType_ .addInterest ("set_fogType__", this);

			this .set_fogType__ ();
		},
		set_fogType__: function ()
		{
			switch (this .fogType_ .getValue ())
			{
				case "EXPONENTIAL":
					this .fogType = 2;
					break;
				//case "EXPONENTIAL2":
				//	this .fogType = 3;
				//	break;
				default:
					this .fogType = 1;
					break;
			}
		},
		setHidden: function (value)
		{
			this .hidden = value;

			this .getBrowser () .addBrowserEvent ();
		},
		getHidden: function ()
		{
			return this .hidden;
		},
		getFogs: function ()
		{
			return Fogs;
		},
	};

	return X3DFogObject;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/Fog',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DBindableNode",
	"x_ite/Components/EnvironmentalEffects/X3DFogObject",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBindableNode,
          X3DFogObject,
          TraverseType,
		  X3DConstants,
          Matrix4)
{
"use strict";

	function Fog (executionContext)
	{
		X3DBindableNode .call (this, executionContext);
		X3DFogObject    .call (this, executionContext);

		this .addType (X3DConstants .Fog);

		this .modelMatrix = new Matrix4 ();
	}

	Fog .prototype = Object .assign (Object .create (X3DBindableNode .prototype),
		X3DFogObject .prototype,
	{
		constructor: Fog,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",        new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "fogType",         new Fields .SFString ("LINEAR")),
			new X3DFieldDefinition (X3DConstants .inputOutput, "color",           new Fields .SFColor (1, 1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "visibilityRange", new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",         new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",        new Fields .SFTime ()),
		]),
		getTypeName: function ()
		{
			return "Fog";
		},
		getComponentName: function ()
		{
			return "EnvironmentalEffects";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DBindableNode .prototype .initialize .call (this);
			X3DFogObject    .prototype .initialize .call (this);
		},
		getModelMatrix: function ()
		{
			return this .modelMatrix;
		},
		traverse: function (type, renderObject)
		{
			renderObject .getLayer () .getFogs () .push (this);

			this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
		},
	});

	return Fog;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/X3DBackgroundNode',[
	"x_ite/Components/Core/X3DBindableNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/ViewVolume",
	"standard/Math/Numbers/Complex",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Algorithm",
],
function (X3DBindableNode,
          TraverseType,
          X3DConstants,
          ViewVolume,
          Complex,
          Vector3,
          Rotation4,
          Matrix4,
          Algorithm)
{
"use strict";
	var
		RADIUS      = 1,
		SIZE        = Math .sqrt (RADIUS * RADIUS / 2),
		U_DIMENSION = 20;

	var s = SIZE;

	var texCoords = [
		1, 1, 0, 1,
		0, 1, 0, 1,
		0, 0, 0, 1,
		1, 1, 0, 1,
		0, 0, 0, 1,
		1, 0, 0, 1,
	];

	var frontVertices = [
		 s,  s, -s, 1,
		-s,  s, -s, 1,
		-s, -s, -s, 1,
		 s,  s, -s, 1,
		-s, -s, -s, 1,
		 s, -s, -s, 1,
	];

	var backVertices = [
		-s,  s,  s, 1,
		 s,  s,  s, 1,
		 s, -s,  s, 1,
		-s,  s,  s, 1,
		 s, -s,  s, 1,
		-s, -s,  s, 1,
	];

	var leftVertices = [
		-s,  s, -s, 1,
		-s,  s,  s, 1,
		-s, -s,  s, 1,
		-s,  s, -s, 1,
		-s, -s,  s, 1,
		-s, -s, -s, 1,
	];

	var rightVertices = [
		s,  s,  s, 1,
		s,  s, -s, 1,
		s, -s, -s, 1,
		s,  s,  s, 1,
		s, -s, -s, 1,
		s, -s,  s, 1,
	];

	var topVertices = [
		 s, s,  s, 1,
		-s, s,  s, 1,
		-s, s, -s, 1,
		 s, s,  s, 1,
		-s, s, -s, 1,
		 s, s, -s, 1,
	];

	var bottomVertices = [
		 s, -s, -s, 1,
		-s, -s, -s, 1,
		-s, -s,  s, 1,
		 s, -s, -s, 1,
		-s, -s,  s, 1,
		 s, -s,  s, 1,
	];

	var
		z1 = new Complex (0, 0),
		z2 = new Complex (0, 0),
		y1 = new Complex (0, 0),
		y2 = new Complex (0, 0),
		y3 = new Complex (0, 0),
		y4 = new Complex (0, 0);

	function X3DBackgroundNode (executionContext)
	{
		X3DBindableNode .call (this, executionContext);

		this .addType (X3DConstants .X3DBackgroundNode);

		this .skyAngle_    .setUnit ("angle");
		this .groundAngle_ .setUnit ("angle");

		this .hidden                = false;
		this .projectionMatrixArray = new Float32Array (16);
		this .modelMatrix           = new Matrix4 ();
		this .modelViewMatrixArray  = new Float32Array (16);
		this .localObjects          = [ ];
		this .colors                = [ ];
		this .sphere                = [ ];
		this .textures              = 0;
	}

	X3DBackgroundNode .prototype = Object .assign (Object .create (X3DBindableNode .prototype),
	{
		constructor: X3DBackgroundNode,
		initialize: function ()
		{
			X3DBindableNode .prototype .initialize .call (this);

			var gl = this .getBrowser () .getContext ();

			this .colorBuffer     = gl .createBuffer ();
			this .sphereBuffer    = gl .createBuffer ();
			this .texCoordBuffer  = gl .createBuffer ();
			this .cubeBuffer      = gl .createBuffer ();
			this .texCoordBuffers = [ gl .createBuffer () ];
			this .frontBuffer     = gl .createBuffer ();
			this .backBuffer      = gl .createBuffer ();
			this .leftBuffer      = gl .createBuffer ();
			this .rightBuffer     = gl .createBuffer ();
			this .topBuffer       = gl .createBuffer ();
			this .bottomBuffer    = gl .createBuffer ();

			this .groundAngle_  .addInterest ("build", this);
			this .groundColor_  .addInterest ("build", this);
			this .skyAngle_     .addInterest ("build", this);
			this .skyColor_     .addInterest ("build", this);
			this .transparency_ .addInterest ("build", this);

			this .build ();
			this .transferRectangle ();
		},
		set_frontTexture__: function (value)
		{
			this .setTexture ("frontTexture", value, 0);
		},
		set_backTexture__: function (value)
		{
			this .setTexture ("backTexture", value, 1);
		},
		set_leftTexture__: function (value)
		{
			this .setTexture ("leftTexture", value, 2);
		},
		set_rightTexture__: function (value)
		{
			this .setTexture ("rightTexture", value, 3);
		},
		set_topTexture__: function (value)
		{
			this .setTexture ("topTexture", value, 4);
		},
		set_bottomTexture__: function (value)
		{
			this .setTexture ("bottomTexture", value, 5);
		},
		setTexture: function (key, texture, bit)
		{
			if (this [key])
				this [key] .loadState_ .removeInterest ("setTextureBit", this);

			this [key] = texture;

			if (texture)
			{
				texture .loadState_ .addInterest ("setTextureBit", this, bit);
				this .setTextureBit (texture .loadState_, bit);
			}
			else
				this .textures &= ~(1 << bit);
		},
		setTextureBit: function (loadState, bit)
		{
			if (loadState .getValue () === X3DConstants .COMPLETE_STATE)
				this .textures |= 1 << bit;
			else
				this .textures &= ~(1 << bit);
		},
		setHidden: function (value)
		{
			this .hidden = value;

			this .getBrowser () .addBrowserEvent ();
		},
		getHidden: function ()
		{
			return this .hidden;
		},
		getTransparent: function ()
		{
			if (this .hidden)
				return true;

			if (this .transparency_ .getValue () === 0)
				return false;

			if (! this .frontTexture  || this .frontTexture  .transparent_ .getValue ())
					return true;

			if (! this .backTexture   || this .backTexture   .transparent_ .getValue ())
					return true;

			if (! this .leftTexture   || this .leftTexture   .transparent_ .getValue ())
					return true;

			if (! this .rightTexture  || this .rightTexture  .transparent_ .getValue ())
					return true;

			if (! this .topTexture    || this .topTexture    .transparent_ .getValue ())
					return true;

			if (! this .bottomTexture || this .bottomTexture .transparent_ .getValue ())
					return true;

			return false;
		},
		getColor: function (theta, color, angle)
		{
			var index = Algorithm .upperBound (angle, 0, angle .length, theta, Algorithm .less);

			return color [index];
		},
		build: function ()
		{
			this .colors .length = 0;
			this .sphere .length = 0;

			if (this .transparency_ .getValue () >= 1)
				return;

			var alpha = 1 - Algorithm .clamp (this .transparency_ .getValue (), 0, 1);

			if (this .groundColor_ .length === 0 && this .skyColor_ .length == 1)
			{
				var s = SIZE;

				// Build cube

				this .sphere .vertices = 36;

				this .sphere .push ( s,  s, -s, 1, -s,  s, -s, 1, -s, -s, -s, 1, // Back
				                     s,  s, -s, 1, -s, -s, -s, 1,  s, -s, -s, 1,
				                    -s,  s,  s, 1,  s,  s,  s, 1, -s, -s,  s, 1, // Front
				                    -s, -s,  s, 1,  s,  s,  s, 1,  s, -s,  s, 1,
				                    -s,  s, -s, 1, -s,  s,  s, 1, -s, -s,  s, 1, // Left
				                    -s,  s, -s, 1, -s, -s,  s, 1, -s, -s, -s, 1,
				                    	s,  s,  s, 1,  s,  s, -s, 1,  s, -s,  s, 1, // Right
				                     s, -s,  s, 1,  s,  s, -s, 1,  s, -s, -s, 1,
				                    	s,  s,  s, 1, -s,  s,  s, 1, -s,  s, -s, 1, // Top
				                     s,  s,  s, 1, -s,  s, -s, 1,  s,  s, -s, 1,
				                    -s, -s,  s, 1,  s, -s,  s, 1, -s, -s, -s, 1, // Bottom
				                    -s, -s, -s, 1,  s, -s,  s, 1,  s, -s, -s, 1);

				var c = this .skyColor_ [0];

				for (var i = 0, vertices = this .sphere .vertices; i < vertices; ++ i)
					this .colors .push (c .r, c .g, c .b, alpha);
			}
			else
			{
				// Build sphere

				if (this .skyColor_ .length > this .skyAngle_ .length)
				{
					var vAngle = [ ];

					for (var i = 0, length = this .skyAngle_ .length; i < length; ++ i)
						vAngle .push (this .skyAngle_ [i]);

					if (vAngle .length === 0 || vAngle [0] > 0)
						vAngle .unshift (0);

					var vAngleMax = this .groundColor_ .length > this .groundAngle_ .length ? Math .PI / 2 : Math .PI;

					if (vAngle [vAngle .length - 1] < vAngleMax)
						vAngle .push (vAngleMax);

					this .buildSphere (RADIUS, vAngle, this .skyAngle_, this .skyColor_, alpha, false);
				}

				if (this .groundColor_ .length > this .groundAngle_ .length)
				{
					var vAngle = [ ];

					for (var i = 0, length = this .groundAngle_ .length; i < length; ++ i)
						vAngle .push (this .groundAngle_ [i]);

					vAngle .reverse ();

					if (vAngle .length === 0 || vAngle [0] < Math .PI / 2)
						vAngle .unshift (Math .PI / 2);

					if (vAngle [vAngle .length - 1] > 0)
						vAngle .push (0);

					this .buildSphere (RADIUS, vAngle, this .groundAngle_, this .groundColor_, alpha, true);
				}
			}

			this .transferSphere ();
		},
		buildSphere: function (radius, vAngle, angle, color, alpha, bottom)
		{
			var
				phi         = 0,
				vAngleMax   = bottom ? Math .PI / 2 : Math .PI,
				V_DIMENSION = vAngle .length - 1;

			for (var v = 0; v < V_DIMENSION; ++ v)
			{
				var
					theta1 = Algorithm .clamp (vAngle [v],     0, vAngleMax),
					theta2 = Algorithm .clamp (vAngle [v + 1], 0, vAngleMax);

				if (bottom)
				{
					theta1 = Math .PI - theta1;
					theta2 = Math .PI - theta2;
				}

				z1 .setPolar (radius, theta1);
				z2 .setPolar (radius, theta2);

				var
					c1 = this .getColor (vAngle [v],     color, angle),
					c2 = this .getColor (vAngle [v + 1], color, angle);

				for (var u = 0; u < U_DIMENSION; ++ u)
				{
					// p4 --- p1
					//  |   / |
					//  | /   |
					// p3 --- p2

					// The last point is the first one.
					var u1 = u < U_DIMENSION - 1 ? u + 1 : 0;

					// p1, p2
					phi = 2 * Math .PI * (u / U_DIMENSION);
					y1  .setPolar (-z1 .imag, phi);
					y2  .setPolar (-z2 .imag, phi);

					// p3, p4
					phi = 2 * Math .PI * (u1 / U_DIMENSION);
					y3  .setPolar (-z2 .imag, phi);
					y4  .setPolar (-z1 .imag, phi);

					// Triangle 1 and 2

					this .colors .push (c1 .r, c1 .g, c1 .b, alpha,
					                    c2 .r, c2 .g, c2 .b, alpha,
					                    c2 .r, c2 .g, c2 .b, alpha,
					                    // Triangle 2
					                    c1 .r, c1 .g, c1 .b, alpha,
					                    c1 .r, c1 .g, c1 .b, alpha,
					                    c2 .r, c2 .g, c2 .b, alpha);

					this .sphere .push (y1 .imag, z1 .real, y1 .real, 1,
					                    y3 .imag, z2 .real, y3 .real, 1,
					                    y2 .imag, z2 .real, y2 .real, 1,
					                    // Triangle 2
					                    y1 .imag, z1 .real, y1 .real, 1,
					                    y4 .imag, z1 .real, y4 .real, 1,
					                    y3 .imag, z2 .real, y3 .real, 1);
				}
			}
		},
		transferSphere: function ()
		{
			var gl = this .getBrowser () .getContext ();

			// Transfer colors.

			gl .bindBuffer (gl .ARRAY_BUFFER, this .colorBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (this .colors), gl .STATIC_DRAW);

			// Transfer sphere.

			gl .bindBuffer (gl .ARRAY_BUFFER, this .sphereBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (this .sphere), gl .STATIC_DRAW);
			this .sphereCount = this .sphere .length / 4;
		},
		transferRectangle: function ()
		{
			var gl = this .getBrowser () .getContext ();

			// Transfer texCoords.

			gl .bindBuffer (gl .ARRAY_BUFFER, this .texCoordBuffers [0]);
			gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (texCoords), gl .STATIC_DRAW);

			// Transfer rectangle.

			gl .bindBuffer (gl .ARRAY_BUFFER, this .frontBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (frontVertices), gl .STATIC_DRAW);

			gl .bindBuffer (gl .ARRAY_BUFFER, this .backBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (backVertices), gl .STATIC_DRAW);

			gl .bindBuffer (gl .ARRAY_BUFFER, this .leftBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (leftVertices), gl .STATIC_DRAW);

			gl .bindBuffer (gl .ARRAY_BUFFER, this .rightBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (rightVertices), gl .STATIC_DRAW);

			gl .bindBuffer (gl .ARRAY_BUFFER, this .topBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (topVertices), gl .STATIC_DRAW);

			gl .bindBuffer (gl .ARRAY_BUFFER, this .bottomBuffer);
			gl .bufferData (gl .ARRAY_BUFFER, new Float32Array (bottomVertices), gl .STATIC_DRAW);
		},
		traverse: function (type, renderObject)
		{
			switch (type)
			{
				case TraverseType .CAMERA:
				{
					renderObject .getLayer () .getBackgrounds () .push (this);

					this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
					return;
				}
				case TraverseType .DISPLAY:
				{
					var
						sourceObjects = renderObject .getLocalObjects (),
						destObjects   = this .localObjects;

					for (var i = 0, length = sourceObjects .length; i < length; ++ i)
						destObjects [i] = sourceObjects [i];

					destObjects .length = sourceObjects .length;
					return;
				}
			}
		},
		display: (function ()
		{
			var
				invProjectionMatrix = new Matrix4 (),
				modelViewMatrix     = new Matrix4 (),
				rotation            = new Rotation4 (),
				scale               = new Vector3 (0, 0, 0),
				farVector           = new Vector3 (0, 0, 0);

			return function (gl, renderObject, viewport)
			{
				try
				{
					if (this .hidden)
						return;

					// Setup context.

					gl .disable (gl .DEPTH_TEST);
					gl .depthMask (false);
					gl .enable (gl .CULL_FACE);
					gl .frontFace (gl .CCW);

					// Get background scale.

					var farValue = -ViewVolume .unProjectPointMatrix (0, 0, 1, invProjectionMatrix .assign (renderObject .getProjectionMatrix () .get ()) .inverse (), viewport, farVector) .z * 0.8;

					// Get projection matrix.

					this .projectionMatrixArray .set (renderObject .getProjectionMatrix () .get ());

					// Rotate and scale background.

					modelViewMatrix .assign (this .modelMatrix);
					modelViewMatrix .multRight (renderObject .getViewMatrix () .get ());
					modelViewMatrix .get (null, rotation);
					modelViewMatrix .identity ();
					modelViewMatrix .rotate (rotation);
					modelViewMatrix .scale (scale .set (farValue, farValue, farValue));

					this .modelViewMatrixArray .set (modelViewMatrix);

					// Draw background sphere and texture cube.

					this .drawSphere (renderObject);

					if (this .textures)
						this .drawCube (renderObject);
				}
				catch (error)
				{
					console .log (error);
				}
			};
		})(),
		drawSphere: function (renderObject)
		{
			var transparency = this .transparency_ .getValue ();

			if (transparency >= 1)
				return;

			var
				browser    = renderObject .getBrowser (),
				gl         = browser .getContext (),
				shaderNode = browser .getBackgroundSphereShader ();

			if (shaderNode .getValid ())
			{
				shaderNode .enable (gl);

				// Clip planes

				shaderNode .setLocalObjects (gl, this .localObjects);

				// Enable vertex attribute arrays.

				shaderNode .enableColorAttribute  (gl, this .colorBuffer);
				shaderNode .enableVertexAttribute (gl, this .sphereBuffer);

				// Uniforms

				gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix, false, this .projectionMatrixArray);
				gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,  false, this .modelViewMatrixArray);

				// Setup context.

				if (transparency)
					gl .enable (gl .BLEND);
				else
					gl .disable (gl .BLEND);

				// Draw.

				gl .drawArrays (gl .TRIANGLES, 0, this .sphereCount);

				// Disable vertex attribute arrays.

				shaderNode .disableColorAttribute (gl);
				shaderNode .disable (gl);
			}
		},
		drawCube: (function ()
		{
			var textureMatrixArray = new Float32Array (new Matrix4 ());

			return function (renderObject)
			{
				var
					browser    = renderObject .getBrowser (),
					gl         = browser .getContext (),
					shaderNode = browser .getGouraudShader ();

				if (shaderNode .getValid ())
				{
					shaderNode .enable (gl);

					// Clip planes

					shaderNode .setLocalObjects (gl, this .localObjects);

					// Enable vertex attribute arrays.

					shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers);

					// Uniforms

					gl .uniform1i (shaderNode .x3d_FogType,                            0);
					gl .uniform1i (shaderNode .x3d_FillPropertiesFilled,               true);
					gl .uniform1i (shaderNode .x3d_FillPropertiesHatched,              false);
					gl .uniform1i (shaderNode .x3d_ColorMaterial,                      false);
					gl .uniform1i (shaderNode .x3d_Lighting,                           false);
					gl .uniform1i (shaderNode .x3d_NumTextures,                        1);
					gl .uniform1i (shaderNode .x3d_TextureType [0],                    2);
					gl .uniform1i (shaderNode .x3d_TextureCoordinateGeneratorMode [0], 0);
					gl .uniform1i (shaderNode .x3d_NumProjectiveTextures,              0);

					gl .uniformMatrix4fv (shaderNode .x3d_TextureMatrix [0], false, textureMatrixArray);
					gl .uniformMatrix4fv (shaderNode .x3d_ProjectionMatrix,  false, this .projectionMatrixArray);
					gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix,   false, this .modelViewMatrixArray);

					// Draw.

					this .drawRectangle (gl, shaderNode, this .frontTexture,  this .frontBuffer);
					this .drawRectangle (gl, shaderNode, this .backTexture,   this .backBuffer);
					this .drawRectangle (gl, shaderNode, this .leftTexture,   this .leftBuffer);
					this .drawRectangle (gl, shaderNode, this .rightTexture,  this .rightBuffer);
					this .drawRectangle (gl, shaderNode, this .topTexture,    this .topBuffer);
					this .drawRectangle (gl, shaderNode, this .bottomTexture, this .bottomBuffer);

					// Disable vertex attribute arrays.

					shaderNode .disableTexCoordAttribute (gl);
					shaderNode .disable (gl);
				}
			};
		})(),
		drawRectangle: function (gl, shaderNode, texture, buffer)
		{
			if (texture && texture .checkLoadState () === X3DConstants .COMPLETE_STATE)
			{
				texture .setShaderUniforms (gl, shaderNode);

				if (texture .transparent_ .getValue ())
					gl .enable (gl .BLEND);
				else
					gl .disable (gl .BLEND);

				shaderNode .enableVertexAttribute (gl, buffer);

				// Draw.

				gl .drawArrays (gl .TRIANGLES, 0, 6);
			}
		},
	});

	return X3DBackgroundNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/Background',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/EnvironmentalEffects/X3DBackgroundNode",
	"x_ite/Components/Texturing/ImageTexture",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBackgroundNode,
          ImageTexture,
          X3DConstants)
{
"use strict";

	function Background (executionContext)
	{
		X3DBackgroundNode .call (this, executionContext);

		this .addType (X3DConstants .Background);
	}

	Background .prototype = Object .assign (Object .create (X3DBackgroundNode .prototype),
	{
		constructor: Background,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",     new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",     new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "frontUrl",     new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "backUrl",      new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "leftUrl",      new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "rightUrl",     new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "topUrl",       new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "bottomUrl",    new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "skyAngle",     new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "skyColor",     new Fields .MFColor (new Fields .SFColor ())),
			new X3DFieldDefinition (X3DConstants .inputOutput, "groundAngle",  new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "groundColor",  new Fields .MFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "transparency", new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",      new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",     new Fields .SFTime ()),
		]),
		getTypeName: function ()
		{
			return "Background";
		},
		getComponentName: function ()
		{
			return "EnvironmentalEffects";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DBackgroundNode .prototype .initialize .call (this);

			var
				frontTexture      = new ImageTexture (this .getExecutionContext ()),
				backTexture       = new ImageTexture (this .getExecutionContext ()),
				leftTexture       = new ImageTexture (this .getExecutionContext ()),
				rightTexture      = new ImageTexture (this .getExecutionContext ()),
				topTexture        = new ImageTexture (this .getExecutionContext ()),
				bottomTexture     = new ImageTexture (this .getExecutionContext ()),
				textureProperties = this .getBrowser () .getBackgroundTextureProperties ();

			this .frontUrl_  .addFieldInterest (frontTexture  .url_);
			this .backUrl_   .addFieldInterest (backTexture   .url_);
			this .leftUrl_   .addFieldInterest (leftTexture   .url_);
			this .rightUrl_  .addFieldInterest (rightTexture  .url_);
			this .topUrl_    .addFieldInterest (topTexture    .url_);
			this .bottomUrl_ .addFieldInterest (bottomTexture .url_);

			frontTexture  .url_ = this .frontUrl_;
			backTexture   .url_ = this .backUrl_;
			leftTexture   .url_ = this .leftUrl_;
			rightTexture  .url_ = this .rightUrl_;
			topTexture    .url_ = this .topUrl_;
			bottomTexture .url_ = this .bottomUrl_;

			frontTexture  .textureProperties_ = textureProperties;
			backTexture   .textureProperties_ = textureProperties;
			leftTexture   .textureProperties_ = textureProperties;
			rightTexture  .textureProperties_ = textureProperties;
			topTexture    .textureProperties_ = textureProperties;
			bottomTexture .textureProperties_ = textureProperties;

			frontTexture  .setup ();
			backTexture   .setup ();
			leftTexture   .setup ();
			rightTexture  .setup ();
			topTexture    .setup ();
			bottomTexture .setup ();

			this .set_frontTexture__  (frontTexture);
			this .set_backTexture__   (backTexture);
			this .set_leftTexture__   (leftTexture);
			this .set_rightTexture__  (rightTexture);
			this .set_topTexture__    (topTexture);
			this .set_bottomTexture__ (bottomTexture);
		}
	});

	return Background;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/X3DLayerNode',[
	"x_ite/Components/Core/X3DNode",
	"x_ite/Rendering/X3DRenderObject",
	"x_ite/Components/Layering/X3DViewportNode",
	"x_ite/Execution/BindableStack",
	"x_ite/Execution/BindableList",
	"x_ite/Components/Navigation/NavigationInfo",
	"x_ite/Components/EnvironmentalEffects/Fog",
	"x_ite/Components/EnvironmentalEffects/Background",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Camera",
	"standard/Math/Geometry/Box3",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
],
function (X3DNode,
          X3DRenderObject,
          X3DViewportNode,
          BindableStack,
          BindableList,
          NavigationInfo,
          Fog,
          Background,
          X3DCast,
          TraverseType,
          X3DConstants,
          Camera,
          Box3,
          Vector3,
          Matrix4)
{
"use strict";

	var projectionMatrix = new Matrix4 ();

	function X3DLayerNode (executionContext, defaultViewpoint, groupNode)
	{
		X3DNode         .call (this, executionContext);
		X3DRenderObject .call (this, executionContext);

		this .addType (X3DConstants .X3DLayerNode);

		this .groupNode       = groupNode;
		this .currentViewport = null;

		this .defaultNavigationInfo = new NavigationInfo (executionContext);
		this .defaultViewpoint      = defaultViewpoint;
		this .defaultBackground     = new Background (executionContext);
		this .defaultFog            = new Fog (executionContext);

		this .navigationInfoStack = new BindableStack (executionContext, this, this .defaultNavigationInfo);
		this .viewpointStack      = new BindableStack (executionContext, this, this .defaultViewpoint);
		this .backgroundStack     = new BindableStack (executionContext, this, this .defaultBackground);
		this .fogStack            = new BindableStack (executionContext, this, this .defaultFog);

		this .navigationInfos = new BindableList (executionContext, this, this .defaultNavigationInfo);
		this .viewpoints      = new BindableList (executionContext, this, this .defaultViewpoint);
		this .backgrounds     = new BindableList (executionContext, this, this .defaultBackground);
		this .fogs            = new BindableList (executionContext, this, this .defaultFog);

		this .defaultBackground .setHidden (true);
		this .defaultFog        .setHidden (true);

		this .collisionTime = 0;
	}

	X3DLayerNode .prototype = Object .assign (Object .create (X3DNode .prototype),
		X3DRenderObject .prototype,
	{
		constructor: X3DLayerNode,
		layer0: false,
		initialize: function ()
		{
			X3DNode         .prototype .initialize .call (this);
			X3DRenderObject .prototype .initialize .call (this);

			this .defaultNavigationInfo .setup ();
			this .defaultViewpoint      .setup ();
			this .defaultBackground     .setup ();
			this .defaultFog            .setup ();

			this .navigationInfoStack .setup ();
			this .viewpointStack      .setup ();
			this .backgroundStack     .setup ();
			this .fogStack            .setup ();

			this .navigationInfos .setup ();
			this .viewpoints      .setup ();
			this .backgrounds     .setup ();
			this .fogs            .setup ();

			this .viewport_       .addInterest ("set_viewport__", this);

			this .set_viewport__ ();
		},
		isLayer0: function (value)
		{
			this .layer0 = value;
			this .defaultBackground .setHidden (! value);
		},
		getLayer: function ()
		{
			return this;
		},
		getGroup: function ()
		{
			return this .groupNode;
		},
		getViewport: function ()
		{
			return this .currentViewport;
		},
		getBackground: function ()
		{
			return this .backgroundStack .top ();
		},
		getFog: function ()
		{
			return this .fogStack .top ();
		},
		getNavigationInfo: function ()
		{
			return this .navigationInfoStack .top ();
		},
		getViewpoint: function ()
		{
			return this .viewpointStack .top ();
		},
		getBackgrounds: function ()
		{
			return this .backgrounds;
		},
		getFogs: function ()
		{
			return this .fogs;
		},
		getNavigationInfos: function ()
		{
			return this .navigationInfos;
		},
		getViewpoints: function ()
		{
			return this .viewpoints;
		},
		getUserViewpoints: function ()
		{
			var userViewpoints = [ ];

			for (var i = 0; i < this .viewpoints .get () .length; ++ i)
			{
				var viewpoint = this .viewpoints .get () [i];

				if (viewpoint .description_ .length)
					userViewpoints .push (viewpoint);
			}

			return userViewpoints;
		},
		getBackgroundStack: function ()
		{
			return this .backgroundStack;
		},
		getFogStack: function ()
		{
			return this .fogStack;
		},
		getNavigationInfoStack: function ()
		{
			return this .navigationInfoStack;
		},
		getViewpointStack: function ()
		{
			return this .viewpointStack;
		},
		getBBox: function (bbox)
		{
			return this .groupNode .getBBox (bbox);
		},
		lookAt: function (factor, straighten)
		{
			this .getViewpoint () .lookAtBBox (this .getBBox (new Box3 ()), factor, straighten);
		},
		set_viewport__: function ()
		{
			this .currentViewport = X3DCast (X3DConstants .X3DViewportNode, this .viewport_);

			if (! this .currentViewport)
				this .currentViewport = this .getBrowser () .getDefaultViewport ();
		},
		bind: function (viewpointName)
		{
			this .traverse (TraverseType .CAMERA, this);

			// Bind first viewpoint in viewpoint list.

			var
				navigationInfo = this .navigationInfos .getBound (),
				background     = this .backgrounds     .getBound (),
				fog            = this .fogs            .getBound (),
				viewpoint      = this .viewpoints      .getBound (viewpointName);

			this .navigationInfoStack .pushOnTop (navigationInfo);
			this .viewpointStack      .pushOnTop (viewpoint);
			this .backgroundStack     .pushOnTop (background);
			this .fogStack            .pushOnTop (fog);

			viewpoint .resetUserOffsets ();
		},
		traverse: function (type, renderObject)
		{
			renderObject = renderObject || this;

			var viewpoint = this .getViewpoint ();

			this .getProjectionMatrix ()  .pushMatrix (viewpoint .getProjectionMatrix (this));
			this .getCameraSpaceMatrix () .pushMatrix (viewpoint .getCameraSpaceMatrix ());
			this .getViewMatrix ()        .pushMatrix (viewpoint .getViewMatrix ());

			switch (type)
			{
				case TraverseType .POINTER:
					this .pointer (type, renderObject);
					break;
				case TraverseType .CAMERA:
					this .camera (type, renderObject);
					break;
				case TraverseType .PICKING:
					this .picking (type, renderObject);
					break;
				case TraverseType .COLLISION:
					this .collision (type, renderObject);
					break;
				case TraverseType .DEPTH:
				case TraverseType .DISPLAY:
					this .display (type, renderObject);
					break;
			}

			this .getViewMatrix ()        .pop ();
			this .getCameraSpaceMatrix () .pop ();
			this .getProjectionMatrix ()  .pop ();
		},
		pointer: function (type, renderObject)
		{
			if (this .isPickable_ .getValue ())
			{
				var
					browser  = this .getBrowser (),
					viewport = this .currentViewport .getRectangle (browser);

				if (browser .getSelectedLayer ())
				{
					if (browser .getSelectedLayer () !== this)
						return;
				}
				else
				{
					if (! browser .isPointerInRectangle (viewport))
						return;
				}

				browser .setHitRay (this .getProjectionMatrix () .get (), viewport);
				this .getModelViewMatrix () .pushMatrix (this .getViewMatrix () .get ());

				this .currentViewport .push (this);
				this .groupNode .traverse (type, renderObject);
				this .currentViewport .pop (this);

				this .getModelViewMatrix () .pop ()
			}
		},
		camera: function (type, renderObject)
		{
			this .getModelViewMatrix () .pushMatrix (Matrix4 .Identity);

			this .currentViewport .push (this);
			this .groupNode .traverse (type, renderObject);
			this .currentViewport .pop (this);

			this .getModelViewMatrix () .pop ();

			this .navigationInfos .update (this, this .navigationInfoStack);
			this .viewpoints      .update (this, this .viewpointStack);
			this .backgrounds     .update (this, this .backgroundStack);
			this .fogs            .update (this, this .fogStack);

			this .getViewpoint () .update ();
		},
		picking: function (type, renderObject)
		{
			this .getModelViewMatrix () .pushMatrix (Matrix4 .Identity);

			this .currentViewport .push (this);
			this .groupNode .traverse (type, renderObject);
			this .currentViewport .pop (this);

			this .getModelViewMatrix () .pop ();
		},
		collision: function (type, renderObject)
		{
			var navigationInfo = this .getNavigationInfo ();

			if (navigationInfo .transitionActive_ .getValue ())
				return;

			var
				collisionRadius = navigationInfo .getCollisionRadius (),
				avatarHeight    = navigationInfo .getAvatarHeight (),
				size            = Math .max (collisionRadius * 2, avatarHeight * 2);

			this .collisionTime = 0;

			Camera .ortho (-size, size, -size, size, -size, size, projectionMatrix);

			this .getProjectionMatrix () .pushMatrix (projectionMatrix);
			this .getModelViewMatrix  () .pushMatrix (this .getViewMatrix () .get ());

			// Render
			this .currentViewport .push (this);
			renderObject .render (type, this .groupNode .traverse, this .groupNode);
			this .currentViewport .pop (this);

			this .getModelViewMatrix  () .pop ()
			this .getProjectionMatrix () .pop ()
		},
		display: function (type, renderObject)
		{
			this .getNavigationInfo () .enable (type, renderObject);

			this .getModelViewMatrix () .pushMatrix (this .getViewMatrix () .get ());

			this .currentViewport .push (this);
			renderObject .render (type, this .groupNode .traverse, this .groupNode);
			this .currentViewport .pop (this);

			this .getModelViewMatrix () .pop ()
		},
	});

	return X3DLayerNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/Group',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode, 
          X3DConstants)
{
"use strict";

	function Group (executionContext)
	{
		X3DGroupingNode .call (this, executionContext);

		this .addType (X3DConstants .Group);
	}

	Group .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
	{
		constructor: Group,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "Group";
		},
		getComponentName: function ()
		{
			return "Grouping";
		},
		getContainerField: function ()
		{
			return "children";
		},
	});

	return Group;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/Layer',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Layering/X3DLayerNode",
	"x_ite/Components/Navigation/Viewpoint",
	"x_ite/Components/Grouping/Group",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLayerNode,
          Viewpoint,
          Group,
          X3DConstants)
{
"use strict";

	function Layer (executionContext)
	{
		X3DLayerNode .call (this,
		                    executionContext,
		                    new Viewpoint (executionContext),
		                    new Group (executionContext));

		this .addType (X3DConstants .Layer);
	}

	Layer .prototype = Object .assign (Object .create (X3DLayerNode .prototype),
	{
		constructor: Layer,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "isPickable",     new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "viewport",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "addChildren",    new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "removeChildren", new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "children",       new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "Layer";
		},
		getComponentName: function ()
		{
			return "Layering";
		},
		getContainerField: function ()
		{
			return "layers";
		},
		initialize: function ()
		{
			X3DLayerNode .prototype .initialize .call (this);

			this .addChildren_    .addFieldInterest (this .getGroup () .addChildren_);
			this .removeChildren_ .addFieldInterest (this .getGroup () .removeChildren_);
			this .children_       .addFieldInterest (this .getGroup () .children_);

			this .getGroup () .children_ = this .children_;
			this .getGroup () .setPrivate (true);
			this .getGroup () .setup ();
		},
	});

	return Layer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering/LayerSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Layering/Layer",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode,
          Layer,
          X3DCast,
          TraverseType,
          X3DConstants)
{
"use strict";

	function LayerSet (executionContext)
	{
		X3DNode .call (this, executionContext);

		this .addType (X3DConstants .LayerSet);

		this .layerNodes      = [ new Layer (executionContext) ];
		this .layerNode0      = this .layerNodes [0];
		this .activeLayerNode = null;
	}

	LayerSet .prototype = Object .assign (Object .create (X3DNode .prototype),
	{
		constructor: LayerSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",    new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "activeLayer", new Fields .SFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "order",       new Fields .MFInt32 (0)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "layers",      new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "LayerSet";
		},
		getComponentName: function ()
		{
			return "Layering";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DNode .prototype .initialize .call (this);

			this .layerNode0 .setPrivate (true);
			this .layerNode0 .setup ();
			this .layerNode0 .isLayer0 (true);

			this .activeLayer_ .addInterest ("set_activeLayer", this);
			this .order_       .addInterest ("set_layers", this);
			this .layers_      .addInterest ("set_layers", this);

			this .set_layers ();
		},
		getActiveLayer: function ()
		{
			return this .activeLayerNode;
		},
		setLayer0: function (value)
		{
			this .layerNode0 = value;

			this .set_layers ();
		},
		getLayer0: function ()
		{
			return this .layerNode0;
		},
		getLayers: function ()
		{
			return this .layerNodes;
		},
		set_activeLayer: function ()
		{
			if (this .activeLayer_ .getValue () === 0)
			{
				if (this .activeLayerNode !== this .layerNode0)
					this .activeLayerNode = this .layerNode0;
			}
			else
			{
				var index = this .activeLayer_ - 1;

				if (index >= 0 && index < this .layers_ .length)
				{
					if (this .activeLayerNode !== this .layers_ [index] .getValue ())
						this .activeLayerNode = X3DCast (X3DConstants .X3DLayerNode, this .layers_ [index]);
				}
				else
				{
					if (this .activeLayerNode !== null)
						this .activeLayerNode = null;
				}
			}
		},
		set_layers: function ()
		{
			var layers = this .layers_ .getValue ();

			this .layerNodes .length = 0;

			for (var i = 0; i < this .order_ .length; ++ i)
			{
				var index = this .order_ [i];

				if (index === 0)
					this .layerNodes .push (this .layerNode0);
					
				else
				{
					-- index;

					if (index >= 0 && index < layers .length)
					{
						var layerNode = X3DCast (X3DConstants .X3DLayerNode, layers [index]);

						if (layerNode)
							this .layerNodes .push (layerNode);
					}
				}
			}

			this .set_activeLayer ();
		},
		bind: function (viewpointName)
		{
			var layers = this .layers_ .getValue ();

			this .layerNode0 .bind (viewpointName);

			for (var i = 0, length = layers .length; i < length; ++ i)
			{
				var layerNode = X3DCast (X3DConstants .X3DLayerNode, layers [i]);

				if (layerNode)
					layerNode .bind (viewpointName);
			}
		},
		traverse: function (type, renderObject)
		{
			var layerNodes = this .layerNodes;

			if (type === TraverseType .POINTER)
			{
				for (var i = 0, length = layerNodes .length; i < length; ++ i)
				{
					this .getBrowser () .setLayerNumber (i);
					layerNodes [i] .traverse (type, renderObject);
				}
			}
			else
			{
				for (var i = 0, length = layerNodes .length; i < length; ++ i)
				{
					layerNodes [i] .traverse (type, renderObject);
				}
			}
		},
	});

	return LayerSet;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Execution/World',[
	"x_ite/Fields/SFNode",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Components/Layering/LayerSet",
	"x_ite/Components/Layering/Layer",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
],
function (SFNode,
          X3DBaseNode,
          LayerSet,
          Layer,
          X3DCast,
          X3DConstants)
{
"use strict";

	function World (executionContext)
	{
		X3DBaseNode .call (this, executionContext);

		this .addChildObjects ("activeLayer", new SFNode (this .layer0));

		this .layerSet        = new LayerSet (executionContext);
		this .defaultLayerSet = this .layerSet;
		this .layer0          = new Layer (executionContext);
	}

	World .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
	{
		constructor: World,
		getTypeName: function ()
		{
			return "World";
		},
		initialize: function ()
		{
			X3DBaseNode .prototype .initialize .call (this);

			this .layerSet .setPrivate (true);
			this .layerSet .setup ();
			this .layerSet .setLayer0 (this .layer0);
			this .layerSet .activeLayer_ .addInterest ("set_rootNodes__", this);

			this .getExecutionContext () .getRootNodes () .addInterest ("set_rootNodes__", this);
			this .getExecutionContext () .setup ();

			this .set_rootNodes__ ();

			this .layer0 .setPrivate (true);
			this .layer0 .isLayer0 (true);
			this .layer0 .setup ();

			this .set_activeLayer__ ();
		},
		getLayerSet: function ()
		{
			return this .layerSet;
		},
		getActiveLayer: function ()
		{
			return this .activeLayer_ .getValue ();
		},
		set_rootNodes__: function ()
		{
			var oldLayerSet = this .layerSet;
			this .layerSet  = this .defaultLayerSet;

			var rootNodes = this .getExecutionContext () .getRootNodes ();

			this .layer0 .children_ = rootNodes;

			for (var i = 0; i < rootNodes .length; ++ i)
			{
				var rootLayerSet = X3DCast (X3DConstants .LayerSet, rootNodes [i]);

				if (rootLayerSet)
				{
					rootLayerSet .setLayer0 (this .layer0);
					this .layerSet = rootLayerSet;
				}
			}

			if (this .layerSet !== oldLayerSet)
			{
				oldLayerSet    .activeLayer_ .removeInterest ("set_activeLayer__", this);
				this .layerSet .activeLayer_ .addInterest ("set_activeLayer__", this);

				this .set_activeLayer__ ();
			}
		},
		set_activeLayer__: function ()
		{
			this .activeLayer_ = this .layerSet .getActiveLayer ();
		},
		bind: function ()
		{
			// Bind first X3DBindableNodes found in each layer.

			this .layerSet .bind (this .getExecutionContext () .getURL () .fragment);
		},
		traverse: function (type, renderObject)
		{
			this .layerSet .traverse (type, renderObject);
		},
	});

	return World;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/X3DBrowserContext',[
	"jquery",
	"x_ite/Fields/SFTime",
	"x_ite/Basic/X3DBaseNode",
	"x_ite/Browser/Core/X3DCoreContext",
	"x_ite/Routing/X3DRoutingContext",
	"x_ite/Browser/Scripting/X3DScriptingContext",
	"x_ite/Browser/Networking/X3DNetworkingContext",
	"x_ite/Browser/Shaders/X3DShadersContext",
	"x_ite/Browser/Rendering/X3DRenderingContext",
	"x_ite/Browser/Shape/X3DShapeContext",
	"x_ite/Browser/Geometry3D/X3DGeometry3DContext",
	"x_ite/Browser/PointingDeviceSensor/X3DPointingDeviceSensorContext",
	"x_ite/Browser/Navigation/X3DNavigationContext",
	"x_ite/Browser/Layering/X3DLayeringContext",
	"x_ite/Browser/EnvironmentalEffects/X3DEnvironmentalEffectsContext",
	"x_ite/Browser/Lighting/X3DLightingContext",
	"x_ite/Browser/Picking/X3DPickingContext",
	"x_ite/Browser/Sound/X3DSoundContext",
	"x_ite/Browser/Text/X3DTextContext",
	"x_ite/Browser/Texturing/X3DTexturingContext",
	"x_ite/Browser/Time/X3DTimeContext",
	"x_ite/Execution/World",
	"x_ite/Bits/TraverseType",
],
function ($,
          SFTime,
          X3DBaseNode,
          X3DCoreContext,
          X3DRoutingContext,
          X3DScriptingContext,
          X3DNetworkingContext,
          X3DShadersContext,
          X3DRenderingContext,
          X3DShapeContext,
          X3DGeometry3DContext,
          X3DPointingDeviceSensorContext,
          X3DNavigationContext,
          X3DLayeringContext,
          X3DEnvironmentalEffectsContext,
          X3DLightingContext,
          X3DPickingContext,
          X3DSoundContext,
          X3DTextContext,
          X3DTexturingContext,
          X3DTimeContext,
          World,
          TraverseType)
{
"use strict";

	var contexts = [ ];

	function X3DBrowserContext (element)
	{
		X3DBaseNode                    .call (this, this);
		X3DRoutingContext              .call (this);
		X3DCoreContext                 .call (this, element);
		X3DScriptingContext            .call (this);
		X3DNetworkingContext           .call (this);
		X3DShadersContext              .call (this);
		X3DRenderingContext            .call (this);
		X3DShapeContext                .call (this);
		X3DGeometry3DContext           .call (this);
		X3DPointingDeviceSensorContext .call (this);
		X3DNavigationContext           .call (this);
		X3DLayeringContext             .call (this);
		X3DEnvironmentalEffectsContext .call (this);
		X3DLightingContext             .call (this);
		X3DPickingContext              .call (this);
		X3DSoundContext                .call (this);
		X3DTextContext                 .call (this);
		X3DTexturingContext            .call (this);
		X3DTimeContext                 .call (this);

		contexts .forEach (function (context) { context .call (this); }, this);

		this .addChildObjects ("initialized",   new SFTime (),
		                       "shutdown",      new SFTime (),
		                       "prepareEvents", new SFTime (),
		                       "timeEvents",    new SFTime (),
		                       "sensorEvents",  new SFTime (),
		                       "finished",      new SFTime ());

		this .changedTime     = 0;
		this .renderCallback  = this .traverse .bind (this);
		this .systemTime      = 0;
		this .systemStartTime = 0;
		this .browserTime     = 0;
		this .cameraTime      = 0;
		this .collisionTime   = 0;
		this .displayTime     = 0;
	};

	X3DBrowserContext .prototype = Object .assign (Object .create (X3DBaseNode .prototype),
		X3DRoutingContext .prototype,
		X3DCoreContext .prototype,
		X3DScriptingContext .prototype,
		X3DNetworkingContext .prototype,
		X3DShadersContext .prototype,
		X3DRenderingContext .prototype,
		X3DShapeContext .prototype,
		X3DGeometry3DContext .prototype,
		X3DPointingDeviceSensorContext .prototype,
		X3DNavigationContext .prototype,
		X3DLayeringContext .prototype,
		X3DEnvironmentalEffectsContext .prototype,
		X3DLightingContext .prototype,
		X3DPickingContext .prototype,
		X3DSoundContext .prototype,
		X3DTextContext .prototype,
		X3DTexturingContext .prototype,
		X3DTimeContext .prototype,
	{
		constructor: X3DBrowserContext,
		initialize: function ()
		{
			X3DBaseNode                    .prototype .initialize .call (this);
			X3DRoutingContext              .prototype .initialize .call (this);
			X3DCoreContext                 .prototype .initialize .call (this);
			X3DScriptingContext            .prototype .initialize .call (this);
			X3DNetworkingContext           .prototype .initialize .call (this);
			X3DShadersContext              .prototype .initialize .call (this);
			X3DRenderingContext            .prototype .initialize .call (this);
			X3DShapeContext                .prototype .initialize .call (this);
			X3DGeometry3DContext           .prototype .initialize .call (this);
			X3DPointingDeviceSensorContext .prototype .initialize .call (this);
			X3DNavigationContext           .prototype .initialize .call (this);
			X3DLayeringContext             .prototype .initialize .call (this);
			X3DEnvironmentalEffectsContext .prototype .initialize .call (this);
			X3DLightingContext             .prototype .initialize .call (this);
			X3DPickingContext              .prototype .initialize .call (this);
			X3DSoundContext                .prototype .initialize .call (this);
			X3DTextContext                 .prototype .initialize .call (this);
			X3DTexturingContext            .prototype .initialize .call (this);
			X3DTimeContext                 .prototype .initialize .call (this);

			contexts .forEach (function (context)
			{
				if (context .prototype .initialize)
					context .prototype .initialize .call (this);
			}
			.bind (this));
		},
		initialized: function ()
		{
			return this .initialized_;
		},
		shutdown: function ()
		{
			return this .shutdown_;
		},
		prepareEvents: function ()
		{
			return this .prepareEvents_;
		},
		timeEvents: function ()
		{
			return this .timeEvents_;
		},
		sensorEvents: function ()
		{
			return this .sensorEvents_;
		},
		finished: function ()
		{
			return this .finished_;
		},
		getURL: function ()
		{
			return this .getExecutionContext () .getURL ();
		},
		getBrowser: function ()
		{
			return this;
		},
		getWorld: function ()
		{
			return this .world;
		},
		setExecutionContext: function (executionContext)
		{
			this .world = new World (executionContext);
			this .world .setup ();
		},
		getExecutionContext: function ()
		{
			return this .world .getExecutionContext ();
		},
		addBrowserEvent: function ()
		{
			if (this .changedTime === this .getCurrentTime ())
				return;

			this .changedTime = this .getCurrentTime ();

			requestAnimationFrame (this .renderCallback);
		},
		traverse: function (time)
		{
			var gl = this .getContext ();

			var t0 = performance .now ();
			this .systemTime = t0 - this .systemStartTime;
			this .advanceTime (time);

			this .prepareEvents_ .processInterests ();
			this .processEvents ();

			this .timeEvents_ .processInterests ();
			this .processEvents ();

			var t1 = performance .now ();
			this .world .traverse (TraverseType .CAMERA, null);
			this .cameraTime = performance .now () - t1;

			var t2 = performance .now ();
			if (this .getCollisionCount ())
				this .world .traverse (TraverseType .COLLISION, null);
			this .collisionTime = performance .now () - t2;

			this .sensorEvents_ .processInterests ();
			this .processEvents ();

			// XXX: The depth buffer must be cleared here, although it is cleared in each layer, otherwise there is a
			// XXX: phantom image in the depth buffer at least in Firefox.

			var t3 = performance .now ();
			gl .clearColor (0, 0, 0, 0);
			gl .clear (gl .COLOR_BUFFER_BIT);
			this .world .traverse (TraverseType .DISPLAY, null);
			this .displayTime = performance .now () - t3;

			this .browserTime     = performance .now () - t0;
			this .systemStartTime = performance .now ();

			this .finished_ .processInterests ();
		},
		toStream: function (stream)
		{
			stream .string += Object .prototype .toString .call (this);
		},
	});

	Object .assign (X3DBrowserContext,
	{
		addContext: function (context)
		{
			var X3D = require ("x_ite/X3D");

			contexts .push (context);

			Object .assign (X3DBrowserContext .prototype, context .prototype);

			$("X3DCanvas") .each (function (i, canvas)
			{
				var browser = X3D .getBrowser (canvas);

				context .call (browser);

				if (context .prototype .initialize)
					context .prototype .initialize .call (browser);
			});
		},
	});

	return X3DBrowserContext;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/SupportedNodes',[
	"x_ite/Bits/X3DConstants",
	"x_ite/Parser/HTMLSupport",
],
function (X3DConstants,
          HTMLSupport)
{
"use strict";

	var nodeType = 0;

	function SupportedNodes ()
	{
		this .types         = new Map ();
		this .abstractTypes = new Map ();
	}

	SupportedNodes .prototype =
	{
		addType: function (typeName, Type)
		{
			X3DConstants [typeName] = ++ nodeType; // Start with 1, as X3DBaseNode is 0.

			this .types .set (typeName,                 Type);
			this .types .set (typeName .toUpperCase (), Type);

			// HTMLSupport

			var fieldDefinitions = Type .prototype .fieldDefinitions;

			for (var i = 0, length = fieldDefinitions .length; i < length; ++ i)
			{
				var
					fieldDefinition = fieldDefinitions [i],
					name            = fieldDefinition .name,
					accessType      = fieldDefinition .accessType;

				if (accessType & X3DConstants .initializeOnly)
				{
					HTMLSupport .fields .set (name,                 name);
					HTMLSupport .fields .set (name .toLowerCase (), name);
				}
			}
		},
		addAbstractType: function (typeName, Type)
		{
			X3DConstants [typeName] = ++ nodeType;
		},
		getType: function (typeName)
		{
			return this .types .get (typeName);
		},
	};

	return new SupportedNodes ();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DMetadataObject',[
	"x_ite/Bits/X3DConstants",
],
function (X3DConstants)
{
"use strict";

	function X3DMetadataObject (executionContext)
	{
		this .addType (X3DConstants .X3DMetadataObject);
	}

	X3DMetadataObject .prototype =
	{
		constructor: X3DMetadataObject,
		initialize: function () { },
	};

	return X3DMetadataObject;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataBoolean',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Core/X3DMetadataObject",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode, 
          X3DMetadataObject, 
          X3DConstants)
{
"use strict";

	function MetadataBoolean (executionContext)
	{
		X3DNode           .call (this, executionContext);
		X3DMetadataObject .call (this, executionContext);

		this .addType (X3DConstants .MetadataBoolean);
	}

	MetadataBoolean .prototype = Object .assign (Object .create (X3DNode .prototype),
		X3DMetadataObject .prototype,
	{
		constructor: MetadataBoolean,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFBool ()),
		]),
		getTypeName: function ()
		{
			return "MetadataBoolean";
		},
		getComponentName: function ()
		{
			return "Core";
		},
		getContainerField: function ()
		{
			return "metadata";
		},
	});

	return MetadataBoolean;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataDouble',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Core/X3DMetadataObject",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode, 
          X3DMetadataObject, 
          X3DConstants)
{
"use strict";

	function MetadataDouble (executionContext)
	{
		X3DNode           .call (this, executionContext);
		X3DMetadataObject .call (this, executionContext);

		this .addType (X3DConstants .MetadataDouble);
	}

	MetadataDouble .prototype = Object .assign (Object .create (X3DNode .prototype),
		X3DMetadataObject .prototype,
	{
		constructor: MetadataDouble,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFDouble ()),
		]),
		getTypeName: function ()
		{
			return "MetadataDouble";
		},
		getComponentName: function ()
		{
			return "Core";
		},
		getContainerField: function ()
		{
			return "metadata";
		},
	});

	return MetadataDouble;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataFloat',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Core/X3DMetadataObject",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode, 
          X3DMetadataObject, 
          X3DConstants)
{
"use strict";

	function MetadataFloat (executionContext)
	{
		X3DNode           .call (this, executionContext);
		X3DMetadataObject .call (this, executionContext);

		this .addType (X3DConstants .MetadataFloat);
	}

	MetadataFloat .prototype = Object .assign (Object .create (X3DNode .prototype),
		X3DMetadataObject .prototype,
	{
		constructor: MetadataFloat,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFFloat ()),
		]),
		getTypeName: function ()
		{
			return "MetadataFloat";
		},
		getComponentName: function ()
		{
			return "Core";
		},
		getContainerField: function ()
		{
			return "metadata";
		},
	});

	return MetadataFloat;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataInteger',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Core/X3DMetadataObject",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode, 
          X3DMetadataObject, 
          X3DConstants)
{
"use strict";

	function MetadataInteger (executionContext)
	{
		X3DNode           .call (this, executionContext);
		X3DMetadataObject .call (this, executionContext);

		this .addType (X3DConstants .MetadataInteger);
	}

	MetadataInteger .prototype = Object .assign (Object .create (X3DNode .prototype),
		X3DMetadataObject .prototype,
	{
		constructor: MetadataInteger,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFInt32 ()),
		]),
		getTypeName: function ()
		{
			return "MetadataInteger";
		},
		getComponentName: function ()
		{
			return "Core";
		},
		getContainerField: function ()
		{
			return "metadata";
		},
	});

	return MetadataInteger;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Core/X3DMetadataObject",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode, 
          X3DMetadataObject, 
          X3DConstants)
{
"use strict";

	function MetadataSet (executionContext)
	{
		X3DNode           .call (this, executionContext);
		X3DMetadataObject .call (this, executionContext);

		this .addType (X3DConstants .MetadataSet);
	}

	MetadataSet .prototype = Object .assign (Object .create (X3DNode .prototype),
		X3DMetadataObject .prototype,
	{
		constructor: MetadataSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "MetadataSet";
		},
		getComponentName: function ()
		{
			return "Core";
		},
		getContainerField: function ()
		{
			return "metadata";
		},
	});

	return MetadataSet;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/MetadataString',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Core/X3DMetadataObject",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNode, 
          X3DMetadataObject, 
          X3DConstants)
{
"use strict";

	function MetadataString (executionContext)
	{
		X3DNode           .call (this, executionContext);
		X3DMetadataObject .call (this, executionContext);

		this .addType (X3DConstants .MetadataString);
	}

	MetadataString .prototype = Object .assign (Object .create (X3DNode .prototype),
		X3DMetadataObject .prototype,
	{
		constructor: MetadataString,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "name",      new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "reference", new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "value",     new Fields .MFString ()),
		]),
		getTypeName: function ()
		{
			return "MetadataString";
		},
		getComponentName: function ()
		{
			return "Core";
		},
		getContainerField: function ()
		{
			return "metadata";
		},
	});

	return MetadataString;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/X3DInfoNode',[
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DChildNode, 
          X3DConstants)
{
"use strict";

	function X3DInfoNode (executionContext)
	{
		X3DChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DInfoNode);
	}

	X3DInfoNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: X3DInfoNode,
	});

	return X3DInfoNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core/WorldInfo',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DInfoNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInfoNode, 
          X3DConstants)
{
"use strict";

	function WorldInfo (executionContext)
	{
		X3DInfoNode .call (this, executionContext);

		this .addType (X3DConstants .WorldInfo);
	}

	WorldInfo .prototype = Object .assign (Object .create (X3DInfoNode .prototype),
	{
		constructor: WorldInfo,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "title",    new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "info",     new Fields .MFString ()),
		]),
		getTypeName: function ()
		{
			return "WorldInfo";
		},
		getComponentName: function ()
		{
			return "Core";
		},
		getContainerField: function ()
		{
			return "children";
		},
	});

	return WorldInfo;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Core',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Core/MetadataBoolean",
	"x_ite/Components/Core/MetadataDouble",
	"x_ite/Components/Core/MetadataFloat",
	"x_ite/Components/Core/MetadataInteger",
	"x_ite/Components/Core/MetadataSet",
	"x_ite/Components/Core/MetadataString",
	"x_ite/Components/Core/WorldInfo",
	"x_ite/Components/Core/X3DBindableNode",
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Components/Core/X3DInfoNode",
	"x_ite/Components/Core/X3DMetadataObject",
	"x_ite/Components/Core/X3DNode",
	"x_ite/Components/Core/X3DPrototypeInstance",
	"x_ite/Components/Core/X3DSensorNode",
],
function (SupportedNodes,
          MetadataBoolean,
          MetadataDouble,
          MetadataFloat,
          MetadataInteger,
          MetadataSet,
          MetadataString,
          WorldInfo,
          X3DBindableNode,
          X3DChildNode,
          X3DInfoNode,
          X3DMetadataObject,
          X3DNode,
          X3DPrototypeInstance,
          X3DSensorNode)
{
"use strict";

	var Types =
	{
		MetadataBoolean: MetadataBoolean,
		MetadataDouble:  MetadataDouble,
		MetadataFloat:   MetadataFloat,
		MetadataInteger: MetadataInteger,
		MetadataSet:     MetadataSet,
		MetadataString:  MetadataString,
		WorldInfo:       WorldInfo,
	};

	var AbstractTypes =
	{
		X3DBindableNode:      X3DBindableNode,
		X3DChildNode:         X3DChildNode,
		X3DInfoNode:          X3DInfoNode,
		X3DMetadataObject:    X3DMetadataObject,
		X3DNode:              X3DNode,
		X3DPrototypeInstance: X3DPrototypeInstance,
		X3DSensorNode:        X3DSensorNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/FogCoordinate',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DGeometricPropertyNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometricPropertyNode,
          X3DConstants)
{
"use strict";

	function FogCoordinate (executionContext)
	{
		X3DGeometricPropertyNode .call (this, executionContext);

		this .addType (X3DConstants .FogCoordinate);

		this .depth_ .setUnit ("length");
	}

	FogCoordinate .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
	{
		constructor: FogCoordinate,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "depth",    new Fields .MFFloat ()),
		]),
		getTypeName: function ()
		{
			return "FogCoordinate";
		},
		getComponentName: function ()
		{
			return "EnvironmentalEffects";
		},
		getContainerField: function ()
		{
			return "fogCoord";
		},
		initialize: function ()
		{
			X3DGeometricPropertyNode .prototype .initialize .call (this);

			this .depth_ .addInterest ("set_depth__", this);

			this .set_depth__ ();
		},
		set_depth__: function ()
		{
			this .depth  = this .depth_ .getValue ();
			this .length = this .depth_ .length;
		},
		isEmpty: function ()
		{
			return this .length === 0;
		},
		getSize: function ()
		{
			return this .length;
		},
		addDepth: function (index, array)
		{
			if (index < this .length)
				array .push (this .depth [index]);

			else if (this .length)
				array .push (this .depth [this .length - 1]);

			else
				array .push (0);
		},
		addDepths: function (array, min)
		{
			var length = this .length;

			if (length)
			{
				const depth = this .depth;

				for (var index = 0; index < length; ++ index)
					array .push (depth [index]);

				var last = depth [length - 1];

				for (var index = length; index < min; ++ index)
					array .push (last);
			}
			else
			{
				for (var index = 0; index < min; ++ index)
					array .push (0);
			}
		},
	});

	return FogCoordinate;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/LocalFog',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Components/EnvironmentalEffects/X3DFogObject",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode,
          X3DFogObject,
          X3DConstants)
{
"use strict";

	function LocalFog (executionContext)
	{
		X3DChildNode .call (this, executionContext);
		X3DFogObject .call (this, executionContext);

		this .addType (X3DConstants .LocalFog);
	}

	LocalFog .prototype = Object .assign (Object .create (X3DChildNode .prototype),
		X3DFogObject .prototype,
	{
		constructor: LocalFog,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",         new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "fogType",         new Fields .SFString ("LINEAR")),
			new X3DFieldDefinition (X3DConstants .inputOutput, "color",           new Fields .SFColor (1, 1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "visibilityRange", new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "LocalFog";
		},
		getComponentName: function ()
		{
			return "EnvironmentalEffects";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DChildNode .prototype .initialize .call (this);
			X3DFogObject .prototype .initialize .call (this);
		},
		push: function (renderObject)
		{
			if (this .enabled_ .getValue ())
			{
				var fogContainer = this .getFogs () .pop ();

				fogContainer .set (this, renderObject .getModelViewMatrix () .get ());

				renderObject .pushLocalFog (fogContainer);
			}
		},
		pop: function (renderObject)
		{
			if (this .enabled_ .getValue ())
				renderObject .getBrowser () .getLocalObjects () .push (renderObject .popLocalFog ());
		},
	});

	return LocalFog;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects/TextureBackground',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/EnvironmentalEffects/X3DBackgroundNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DBackgroundNode, 
          X3DCast,
          X3DConstants)
{
"use strict";

	function TextureBackground (executionContext)
	{
		X3DBackgroundNode .call (this, executionContext);

		this .addType (X3DConstants .TextureBackground);
	}

	TextureBackground .prototype = Object .assign (Object .create (X3DBackgroundNode .prototype),
	{
		constructor: TextureBackground,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_bind",      new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "skyAngle",      new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "skyColor",      new Fields .MFColor (0, 0, 0)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "groundAngle",   new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "groundColor",   new Fields .MFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "transparency",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isBound",       new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "bindTime",      new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "frontTexture",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "backTexture",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "leftTexture",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "rightTexture",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "topTexture",    new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "bottomTexture", new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "TextureBackground";
		},
		getComponentName: function ()
		{
			return "EnvironmentalEffects";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DBackgroundNode .prototype .initialize .call (this);

			this .frontTexture_  .addInterest ("set_frontTexture__", this);
			this .backTexture_   .addInterest ("set_backTexture__", this);
			this .leftTexture_   .addInterest ("set_leftTexture__", this);
			this .rightTexture_  .addInterest ("set_rightTexture__", this);
			this .topTexture_    .addInterest ("set_topTexture__", this);
			this .bottomTexture_ .addInterest ("set_bottomTexture__", this);

			this .set_frontTexture__  (this .frontTexture_);
			this .set_backTexture__   (this .backTexture_);
			this .set_leftTexture__   (this .leftTexture_);
			this .set_rightTexture__  (this .rightTexture_);
			this .set_topTexture__    (this .topTexture_);
			this .set_bottomTexture__ (this .bottomTexture_);
		},
		set_frontTexture__: function ()
		{
			X3DBackgroundNode .prototype .set_frontTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this .frontTexture_));
		},
		set_backTexture__: function ()
		{
			X3DBackgroundNode .prototype .set_backTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this .backTexture_));
		},
		set_leftTexture__: function ()
		{
			X3DBackgroundNode .prototype .set_leftTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this .leftTexture_));
		},
		set_rightTexture__: function ()
		{
			X3DBackgroundNode .prototype .set_rightTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this .rightTexture_));
		},
		set_topTexture__: function ()
		{
			X3DBackgroundNode .prototype .set_topTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this .topTexture_));
		},
		set_bottomTexture__: function ()
		{
			X3DBackgroundNode .prototype .set_bottomTexture__ .call (this, X3DCast (X3DConstants .X3DTextureNode, this .bottomTexture_));
		},
	});

	return TextureBackground;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalEffects',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/EnvironmentalEffects/Background",
	"x_ite/Components/EnvironmentalEffects/Fog",
	"x_ite/Components/EnvironmentalEffects/FogCoordinate",
	"x_ite/Components/EnvironmentalEffects/LocalFog",
	"x_ite/Components/EnvironmentalEffects/TextureBackground",
	"x_ite/Components/EnvironmentalEffects/X3DBackgroundNode",
	"x_ite/Components/EnvironmentalEffects/X3DFogObject",
],
function (SupportedNodes,
          Background,
          Fog,
          FogCoordinate,
          LocalFog,
          TextureBackground,
          X3DBackgroundNode,
          X3DFogObject)
{
"use strict";

	var Types =
	{
		Background:        Background,
		Fog:               Fog,
		FogCoordinate:     FogCoordinate,
		LocalFog:          LocalFog,
		TextureBackground: TextureBackground,
	};

	var AbstractTypes =
	{
		X3DBackgroundNode: X3DBackgroundNode,
		X3DFogObject:      X3DFogObject,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode',[
	"x_ite/Fields",
	"x_ite/Components/Core/X3DSensorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DSensorNode, 
          X3DConstants,
          Vector3)
{
"use strict";

	function X3DEnvironmentalSensorNode (executionContext)
	{
		X3DSensorNode .call (this, executionContext);

		this .addType (X3DConstants .X3DEnvironmentalSensorNode);

		this .addChildObjects ("traversed", new Fields .SFBool (true));

		this .size_   .setUnit ("length");
		this .center_ .setUnit ("length");

		this .zeroTest         = false;
		this .currentTraversed = true;
	}

	X3DEnvironmentalSensorNode .prototype = Object .assign (Object .create (X3DSensorNode .prototype),
	{
		constructor: X3DEnvironmentalSensorNode,
		initialize: function ()
		{
			X3DSensorNode .prototype .initialize .call (this);

			this .isLive () .addInterest ("set_live__", this);

			this .enabled_   .addInterest ("set_live__", this);
			this .size_      .addInterest ("set_live__", this);
			this .traversed_ .addInterest ("set_live__", this);

			this .set_live__ ();
		},
		set_live__: function ()
		{
			if (this .traversed_ .getValue () && this .isLive () .getValue () && this .enabled_ .getValue () && ! (this .zeroTest && this .size_. getValue () .equals (Vector3 .Zero)))
			{
				this .getBrowser () .sensorEvents () .addInterest ("update", this);
			}
			else
			{
				this .getBrowser () .sensorEvents () .removeInterest ("update", this);
				
				if (this .isActive_ .getValue ())
				{
					this .isActive_ = false;
					this .exitTime_ = this .getBrowser () .getCurrentTime ();
				}
			}
		},
		setZeroTest: function (value)
		{
			this .zeroTest = value;
		},
		getZeroTest: function ()
		{
			return this .zeroTest;
		},
		setTraversed: function (value)
		{
		   if (value)
			{
				if (this .traversed_ .getValue () === false)
					this .traversed_ = true;
			}
			else
			{
				if (this .currentTraversed !== this .traversed_ .getValue ())
					this .traversed_ = this .currentTraversed;
			}

		   this .currentTraversed = value;
		},
		getTraversed: function ()
		{
		   return this .currentTraversed;
		},
		update: function () { },
	});

	return X3DEnvironmentalSensorNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor/ProximitySensor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DEnvironmentalSensorNode,
          TraverseType,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

	function ProximitySensor (executionContext)
	{
		X3DEnvironmentalSensorNode .call (this, executionContext);

		this .addType (X3DConstants .ProximitySensor);

		this .setCameraObject (true);

		this .centerOfRotation_changed_ .setUnit ("length");
		this .position_changed_         .setUnit ("length");

		this .setZeroTest (true);

		this .viewpointNode = null;
		this .modelMatrix   = new Matrix4 ();
		this .inside        = false;
	}

	ProximitySensor .prototype = Object .assign (Object .create (X3DEnvironmentalSensorNode .prototype),
	{
		constructor: ProximitySensor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",                 new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",                  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "size",                     new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "center",                   new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "enterTime",                new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "exitTime",                 new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",                 new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "position_changed",         new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "orientation_changed",      new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "centerOfRotation_changed", new Fields .SFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "ProximitySensor";
		},
		getComponentName: function ()
		{
			return "EnvironmentalSensor";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DEnvironmentalSensorNode .prototype .initialize .call (this);

			this .enabled_ .addInterest ("set_enabled__", this);
			this .size_    .addInterest ("set_extents__", this);
			this .center_  .addInterest ("set_extents__", this);

			this .traversed_ .addFieldInterest (this .isCameraObject_);

			this .min = new Vector3 (0, 0, 0);
			this .max = new Vector3 (0, 0, 0);

			this .set_enabled__ ();
			this .set_extents__ ();
		},
		set_enabled__: function ()
		{
			this .setCameraObject (this .enabled_ .getValue ());

			if (this .enabled_ .getValue ())
				delete this .traverse;
			else
				this .traverse = Function .prototype;
		},
		set_extents__: function ()
		{
			var
				s  = this .size_ .getValue (),
				c  = this .center_ .getValue (),
				sx = s .x / 2,
				sy = s .y / 2,
				sz = s .z / 2,
				cx = c .x,
				cy = c .y,
				cz = c .z;

			this .min .set (cx - sx, cy - sy, cz - sz);
			this .max .set (cx + sx, cy + sy, cz + sz);
		},
		update: (function ()
		{
			var
				invModelMatrix         = new Matrix4 (),
				centerOfRotationMatrix = new Matrix4 (),
				position               = new Vector3 (0, 0, 0),
				orientation            = new Rotation4 (0, 0, 1, 0),
				centerOfRotation       = new Vector3 (0, 0, 0);

			return function ()
			{
				try
				{
					if (this .inside && this .getTraversed ())
					{
						if (this .viewpointNode)
						{
							var modelMatrix = this .modelMatrix;

							centerOfRotationMatrix .assign (this .viewpointNode .getModelMatrix ());
							centerOfRotationMatrix .translate (this .viewpointNode .getUserCenterOfRotation ());
							centerOfRotationMatrix .multRight (invModelMatrix .assign (modelMatrix) .inverse ());

							modelMatrix .multRight (this .viewpointNode .getViewMatrix ());
							modelMatrix .get (null, orientation);
							modelMatrix .inverse ();

							position .set (modelMatrix [12], modelMatrix [13], modelMatrix [14]);

							orientation .inverse ();

							centerOfRotation .set (centerOfRotationMatrix [12], centerOfRotationMatrix [13], centerOfRotationMatrix [14]);

							if (this .isActive_ .getValue ())
							{
								if (! this .position_changed_ .getValue () .equals (position))
									this .position_changed_ = position;

								if (! this .orientation_changed_ .getValue () .equals (orientation))
									this .orientation_changed_ = orientation;

								if (! this .centerOfRotation_changed_ .getValue () .equals (centerOfRotation))
									this .centerOfRotation_changed_ = centerOfRotation;
							}
							else
							{
								this .isActive_                 = true;
								this .enterTime_                = this .getBrowser () .getCurrentTime ();
								this .position_changed_         = position;
								this .orientation_changed_      = orientation;
								this .centerOfRotation_changed_ = centerOfRotation;
							}
						}
					}
					else
					{
						if (this .isActive_ .getValue ())
						{
							this .isActive_ = false;
							this .exitTime_ = this .getBrowser () .getCurrentTime ();
						}
					}
				}
				catch (error)
				{
					//console .log (error .message);
				}

				this .inside        = false;
				this .viewpointNode = null;

				this .setTraversed (false);
			};
		})(),
		traverse: (function ()
		{
			var
				invModelViewMatrix = new Matrix4 (),
				viewer             = new Vector3 (0, 0, 0),
				infinity           = new Vector3 (-1, -1, -1);

			return function (type, renderObject)
			{
				try
				{
					switch (type)
					{
						case TraverseType .CAMERA:
						{
							this .viewpointNode = renderObject .getViewpoint ();
							this .modelMatrix .assign (renderObject .getModelViewMatrix () .get ());
							return;
						}
						case TraverseType .DISPLAY:
						{
						   this .setTraversed (true);

							if (this .inside)
								return;

							if (this .size_ .getValue () .equals (infinity))
							{
								this .inside = true;
							}
							else
							{
							   invModelViewMatrix .assign (renderObject .getModelViewMatrix () .get ()) .inverse ();

								viewer .set (invModelViewMatrix [12], invModelViewMatrix [13], invModelViewMatrix [14]);

								this .inside = this .intersectsPoint (viewer);
							}

							return;
						}
					}
				}
				catch (error)
				{
					console .log (error);
				}
			};
		})(),
		intersectsPoint: function (point)
		{
			var
				min = this .min,
				max = this .max;

			return min .x <= point .x &&
			       max .x >= point .x &&
			       min .y <= point .y &&
			       max .y >= point .y &&
			       min .z <= point .z &&
			       max .z >= point .z;
		},
	});

	return ProximitySensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor/TransformSensor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"x_ite/Bits/X3DCast",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Box3",
	"standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DEnvironmentalSensorNode, 
          TraverseType,
          X3DConstants,
          X3DCast,
          Vector3,
          Rotation4,
          Matrix4,
          Box3,
          ObjectCache)
{
"use strict";

	var
		ModelMatrixCache = ObjectCache (Matrix4),
		TargetBBoxCache  = ObjectCache (Box3);

	function TransformSensor (executionContext)
	{
		X3DEnvironmentalSensorNode .call (this, executionContext);

		this .addType (X3DConstants .TransformSensor);

		this .position_changed_ .setUnit ("length");

		this .setZeroTest (true);

		this .bbox             = new Box3 ();
		this .targetObjectNode = null;
		this .modelMatrices    = [ ];
		this .targetBBoxes     = [ ];
	}

	TransformSensor .prototype = Object .assign (Object .create (X3DEnvironmentalSensorNode .prototype),
	{
		constructor: TransformSensor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",            new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "size",                new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "center",              new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "enterTime",           new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "exitTime",            new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",            new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "position_changed",    new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "orientation_changed", new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "targetObject",        new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "TransformSensor";
		},
		getComponentName: function ()
		{
			return "EnvironmentalSensor";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DEnvironmentalSensorNode .prototype .initialize .call (this);
		
			this .isLive () .addInterest ("set_enabled__", this);

			this .enabled_      .addInterest ("set_enabled__",      this);
			this .size_         .addInterest ("set_enabled__",      this);
			this .size_         .addInterest ("set_bbox__",         this);
			this .center_       .addInterest ("set_bbox__",         this);
			this .targetObject_ .addInterest ("set_targetObject__", this);

			this .set_bbox__ ();
			this .set_targetObject__ ();
		},
		set_live__: function ()
		{ },
		set_enabled__: function ()
		{
			if (this .isLive () .getValue () && this .targetObjectNode && this .enabled_ .getValue () && ! this .size_. getValue () .equals (Vector3 .Zero))
			{
				this .setPickableObject (true);
				this .getBrowser () .addTransformSensor (this);
				this .targetObjectNode .addTransformSensor (this);
			}
			else
			{
				this .setPickableObject (false);
				this .getBrowser () .removeTransformSensor (this);

				if (this .targetObjectNode)
					this .targetObjectNode .removeTransformSensor (this);

				if (this .isActive_ .getValue ())
				{
					this .isActive_ = false;
					this .exitTime_ = this .getBrowser () .getCurrentTime ();
				}
			}
		},
		set_bbox__: function ()
		{
			this .bbox .set (this .size_ .getValue (), this .center_ .getValue ());
		},
		set_targetObject__: function ()
		{
			this .targetObjectNode = null;

			try
			{
				var
					node = this .targetObject_ .getValue () .getInnerNode (),
					type = node .getType ();
	
				for (var t = type .length - 1; t >= 0; -- t)
				{
					switch (type [t])
					{
						case X3DConstants .X3DGroupingNode:
						case X3DConstants .X3DShapeNode:
						{
							this .targetObjectNode = node;
							break;
						}
						default:
							continue;
					}
				}
			}
			catch (error)
			{ }

			this .set_enabled__ ();
		},
		traverse: function (type, renderObject)
		{
			// TransformSensor nodes are sorted out and only traversed during PICKING, except if is child of a LOD or Switch node.

			if (type !== TraverseType .PICKING)
				return;

			if (this .getPickableObject ())
				this .modelMatrices .push (ModelMatrixCache .pop () .assign (renderObject .getModelViewMatrix () .get ()));
		},
		collect: function (targetBBox)
		{
			this .targetBBoxes .push (TargetBBoxCache .pop () .assign (targetBBox));
		},
		process: (function ()
		{
			var
				bbox        = new Box3 (),
				position    = new Vector3 (0, 0, 0),
				orientation = new Rotation4 (0, 0, 1, 0),
				infinity    = new Vector3 (-1, -1, -1);

			return function ()
			{
				var
					modelMatrices = this .modelMatrices,
					targetBBoxes  = this .targetBBoxes,
					active        = false;

				for (var m = 0, mLength = modelMatrices .length; m < mLength; ++ m)
				{
					var modelMatrix = modelMatrices [m];

					bbox .assign (this .bbox) .multRight (modelMatrix);

					for (var t = 0, tLength = targetBBoxes .length; t < tLength; ++ t)
					{
						var targetBBox = targetBBoxes [t];

						if (this .size_ .getValue () .equals (infinity) || bbox .intersectsBox (targetBBox))
						{
							active = true;

							targetBBox .multRight (modelMatrix .inverse ()) .getMatrix () .get (position, orientation);
						}

						TargetBBoxCache .push (targetBBox);
					}

					ModelMatrixCache .push (modelMatrix);
				}

				if (active)
				{
					if (this .isActive_ .getValue ())
					{
						if (! this .position_changed_ .getValue () .equals (position))
							this .position_changed_ = position;
		
						if (! this .orientation_changed_ .getValue () .equals (orientation))
							this .orientation_changed_ = orientation;
					}
					else
					{
						this .isActive_            = true;
						this .enterTime_           = this .getBrowser () .getCurrentTime ();
						this .position_changed_    = position;
						this .orientation_changed_ = orientation;
					}
				}
				else
				{
					if (this .isActive_ .getValue ())
					{
						this .isActive_ = false;
						this .exitTime_ = this .getBrowser () .getCurrentTime ();
					}
				}

				this .modelMatrices .length = 0;
				this .targetBBoxes  .length = 0;
			};
		})(),
	});

	return TransformSensor;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor/VisibilitySensor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Geometry/Box3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DEnvironmentalSensorNode,
          TraverseType,
          X3DConstants,
          Vector3,
          Box3)
{
"use strict";

	function VisibilitySensor (executionContext)
	{
		X3DEnvironmentalSensorNode .call (this, executionContext);

		this .addType (X3DConstants .VisibilitySensor);

		this .setZeroTest (false);

		this .visible = false;
	}

	VisibilitySensor .prototype = Object .assign (Object .create (X3DEnvironmentalSensorNode .prototype),
	{
		constructor: VisibilitySensor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",   new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "size",      new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "center",    new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "enterTime", new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "exitTime",  new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",  new Fields .SFBool ()),
		]),
		getTypeName: function ()
		{
			return "VisibilitySensor";
		},
		getComponentName: function ()
		{
			return "EnvironmentalSensor";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DEnvironmentalSensorNode .prototype .initialize .call (this);

			this .enabled_ .addInterest ("set_enabled__", this);

			this .set_enabled__ ();
		},
		set_enabled__: function ()
		{
			if (this .enabled_ .getValue ())
				delete this .traverse;
			else
				this .traverse = Function .prototype;
		},
		update: function ()
		{
			if (this .visible && this .getTraversed ())
			{
				if (! this .isActive_ .getValue ())
				{
					this .isActive_  = true;
					this .enterTime_ = this .getBrowser () .getCurrentTime ();
				}

				this .visible = false;
			}
			else
			{
				if (this .isActive_ .getValue ())
				{
					this .isActive_ = false;
					this .exitTime_ = this .getBrowser () .getCurrentTime ();
				}
			}
				
			this .setTraversed (false);
		},
		traverse: (function ()
		{
			var
				bbox     = new Box3 (),
				infinity = new Vector3 (-1, -1, -1);

			return function (type, renderObject)
			{
				if (type !== TraverseType .DISPLAY)
					return;
	
				this .setTraversed (true);
	
				if (this .visible)
					return;
	
				if (this .size_ .getValue () .equals (infinity))
				{
					this .visible = true;
				}
				else
				{
					bbox
						.set (this .size_ .getValue (), this .center_ .getValue ())
						.multRight (renderObject .getModelViewMatrix () .get ());

					this .visible = renderObject .getViewVolume () .intersectsBox (bbox);
				}
			};
		})(),
	});
		
	return VisibilitySensor;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/EnvironmentalSensor',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/EnvironmentalSensor/ProximitySensor",
	"x_ite/Components/EnvironmentalSensor/TransformSensor",
	"x_ite/Components/EnvironmentalSensor/VisibilitySensor",
	"x_ite/Components/EnvironmentalSensor/X3DEnvironmentalSensorNode",
],
function (SupportedNodes,
          ProximitySensor,
          TransformSensor,
          VisibilitySensor,
          X3DEnvironmentalSensorNode)
{
"use strict";

	var Types =
	{
		ProximitySensor:  ProximitySensor,
		TransformSensor:  TransformSensor,
		VisibilitySensor: VisibilitySensor,
	};

	var AbstractTypes =
	{
		X3DEnvironmentalSensorNode: X3DEnvironmentalSensorNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/ColorChaser',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DChaserNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Color3",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Color3,
          Vector3)
{
"use strict";

	var
		initialValue       = new Vector3 (0, 0, 0),
		initialDestination = new Vector3 (0, 0, 0),
		deltaOut           = new Vector3 (0, 0, 0),
		vector             = new Vector3 (0, 0, 0);

	function ColorChaser (executionContext)
	{
		X3DChaserNode .call (this, executionContext);

		this .addType (X3DConstants .ColorChaser);
	}

	ColorChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
	{
		constructor: ColorChaser,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFColor (0.8, 0.8, 0.8)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFColor (0.8, 0.8, 0.8)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFColor ()),
		]),
		getTypeName: function ()
		{
			return "ColorChaser";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector3 (0, 0, 0);
		},
		getValue: function ()
		{
			return this .set_value_ .getValue () .getHSV (vector);
		},
		getDestination: function ()
		{
			return this .set_destination_ .getValue () .getHSV (vector);
		},
		getInitialValue: function ()
		{
			return this .initialValue_ .getValue () .getHSV (initialValue);
		},
		getInitialDestination: function ()
		{
			return this .initialDestination_ .getValue () .getHSV (initialDestination);
		},
		setValue: function (value)
		{
			this .value_changed_ .setHSV (value .x, value .y, value .z);
		},
		interpolate: function (source, destination, weight)
		{
			return Color3 .lerp (source, destination, weight, vector);
		},
		step: function (value1, value2, t)
		{
			deltaOut .assign (this .output) .add (value1) .subtract (value2);

			//step .x = Algorithm .interval (step .x, 0, 2 * Math .PI);

			Color3 .lerp (this .output, deltaOut, t, this .output);
		},
	});

	return ColorChaser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/X3DDamperNode',[
	"x_ite/Components/Followers/X3DFollowerNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (X3DFollowerNode,
          X3DConstants,
          Algorithm)
{
"use strict";

	function X3DDamperNode (executionContext)
	{
		X3DFollowerNode .call (this, executionContext);

		this .addType (X3DConstants .X3DDamperNode);
	}

	X3DDamperNode .prototype = Object .assign (Object .create (X3DFollowerNode .prototype),
	{
		constructor: X3DDamperNode,
		initialize: function ()
		{
			X3DFollowerNode .prototype .initialize .call (this);

			this .order_           .addInterest ("set_order__", this);
			this .set_value_       .addInterest ("set_value__", this);
			this .set_destination_ .addInterest ("set_destination__", this);

			var
				buffer             = this .getBuffer (),
				initialValue       = this .getInitialValue (),
				initialDestination = this .getInitialDestination ();

			buffer [0] = this .duplicate (initialDestination);

			for (var i = 1, length = this .getOrder () + 1; i < length; ++ i)
				buffer [i] = this .duplicate (initialValue);

			if (this .equals (initialDestination, initialValue, this .getTolerance ()))
				this .setValue (initialDestination);

			else
				this .set_active (true);
		},
		getOrder: function ()
		{
			return Algorithm .clamp (this .order_ .getValue (), 0, 5);
		},
		getTolerance: function ()
		{
			if (this .tolerance_ .getValue () < 0)
				return 1e-4;

			return this .tolerance_ .getValue ();
		},
		prepareEvents: function ()
		{
			var
				buffer = this .getBuffer (),
				order  = buffer .length - 1;

			if (this .tau_ .getValue ())
			{
				var
					delta = 1 / this .getBrowser () .currentFrameRate,
					alpha = Math .exp (-delta / this .tau_ .getValue ());

				for (var i = 0; i < order; ++ i)
				{
					try
					{
						this .assign (buffer, i + 1, this .interpolate (buffer [i], buffer [i + 1], alpha));
					}
					catch (error)
					{ }
				}

				this .setValue (buffer [order]);

				if (! this .equals (buffer [order], buffer [0], this .getTolerance ()))
					return;
			}
			else
			{
				this .setValue (buffer [0]);

				order = 0;
			}

			for (var i = 1, length = buffer .length; i < length; ++ i)
				this .assign (buffer, i, buffer [order]);

			this .set_active (false);
		},
		set_value__: function ()
		{
			var
				buffer = this .getBuffer (),
				value  = this .getValue ();

			for (var i = 1, length = buffer .length; i < length; ++ i)
				this .assign (buffer, i, value);

			this .setValue (value);

			this .set_active (true);
		},
		set_destination__: function ()
		{
			this .assign (this .getBuffer (), 0, this .getDestination ());

			this .set_active (true);
		},
		set_order__: function ()
		{
			var
				buffer = this .getBuffer (),
				value  = buffer [buffer .length - 1];

			for (var i = buffer .length, length = this .getOrder () + 1; i < length; ++ i)
				buffer [i] = this .duplicate (value);

			buffer .length = length;
		},
	});

	return X3DDamperNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/ColorDamper',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DDamperNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Color3",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Color3,
          Vector3)
{
"use strict";

	var
		a                  = new Vector3 (0, 0, 0),
		initialValue       = new Vector3 (0, 0, 0),
		initialDestination = new Vector3 (0, 0, 0),
		vector             = new Vector3 (0, 0, 0);

	function ColorDamper (executionContext)
	{
		X3DDamperNode .call (this, executionContext);

		this .addType (X3DConstants .ColorDamper);
	}

	ColorDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
	{
		constructor: ColorDamper,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFColor (0.8, 0.8, 0.8)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFColor (0.8, 0.8, 0.8)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFColor ()),
		]),
		getTypeName: function ()
		{
			return "ColorDamper";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector3 (0, 0, 0);
		},
		getValue: function ()
		{
			return this .set_value_ .getValue () .getHSV (vector);
		},
		getDestination: function ()
		{
			return this .set_destination_ .getValue () .getHSV (vector);
		},
		getInitialValue: function ()
		{
			return this .initialValue_ .getValue () .getHSV (initialValue);
		},
		getInitialDestination: function ()
		{
			return this .initialDestination_ .getValue () .getHSV (initialDestination);
		},
		setValue: function (value)
		{
			this .value_changed_ .setHSV (value .x, value .y, value .z);
		},
		equals: function (lhs, rhs, tolerance)
		{
			return a .assign (lhs) .subtract (rhs) .abs () < tolerance;
		},
		interpolate: function (source, destination, weight)
		{
			return Color3 .lerp (source, destination, weight, vector);
		},
	});

	return ColorDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Followers/X3DArrayFollowerTemplate',[],function ()
{
"use strict";

	return function (Type)
	{
		function X3DArrayFollowerObject ()
		{
			this .array = this .getArray ();
			this .zero  = this .getVector ();
		}

		X3DArrayFollowerObject .prototype =
		{
			getArray: function ()
			{
				var array = [ ];

				array .assign = function (value)
				{
					if (Array .isArray (value))
					{
						for (var i = 0, length = Math .min (this .length, value .length); i < length; ++ i)
							this [i] .assign (value [i]);

						for (var i = length, length = value .length; i < length; ++ i)
							this [i] = value [i] .copy ();

						this .length = length;
					}
					else
					{
						for (var i = 0, length = Math .min (this .length, value .length); i < length; ++ i)
							this [i] .assign (value [i] .getValue ());

						for (var i = length, length = value .length; i < length; ++ i)
							this [i] = value [i] .getValue () .copy ();

						this .length = length;
					}
				};

				return array;
			},
			getValue: function ()
			{
				return this .set_value_;
			},
			getDestination: function ()
			{
				return this .set_destination_;
			},
			getInitialValue: function ()
			{
				return this .initialValue_;
			},
			getInitialDestination: function ()
			{
				return this .initialDestination_;
			},
			setValue: function (value)
			{
				if (Array .isArray (value))
				{
					var value_changed = this .value_changed_;

					for (var i = 0, length = value .length; i < length; ++ i)
						value_changed [i] = value [i];

					value_changed .length = length;
				}
				else
				{
					this .value_changed_ = value;
				}
			},
			duplicate: function (value)
			{
				var array = this .getArray ();

				array .assign (value);

				return array;
			},
			equals: function (lhs, rhs, tolerance)
			{
				if (lhs .length !== rhs .length)
					return false;

				var
					a        = this .a,
					distance = 0;

				for (var i = 0, length = lhs .length; i < length; ++ i)
				  distance = Math .max (a .assign (lhs [i]) .subtract (rhs [i]) .abs ());

				return distance < tolerance;
			},
			interpolate: function (source, destination, weight)
			{
				var array = this .array;

				array .assign (source);

				for (var i = 0, length = array .length; i < length; ++ i)
					array [i] .lerp (destination [i] || this .zero, weight);

				return array;
			},
			set_destination__: function ()
			{
				var
					buffers = this .getBuffer (),
					l       = this .set_destination_ .length;

				for (var i = 0, length = buffers .length; i < length; ++ i)
				{
					var buffer = buffers [i];

					for (var b = buffer .length; b < l; ++ b)
						buffer [b] = this .getVector ();

					buffer .length = l;
				}

				Type .prototype .set_destination__ .call (this);
			},
		};

		return X3DArrayFollowerObject;
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Followers/X3DArrayChaserTemplate',[
	"x_ite/Browser/Followers/X3DArrayFollowerTemplate",
],
function (X3DArrayFollowerTemplate)
{
"use strict";

	return function (Type)
	{
		var X3DArrayFollower = X3DArrayFollowerTemplate (Type);

		function X3DArrayChaserObject ()
		{
			X3DArrayFollower .call (this);

			this .array = this .getArray ();
		}

		Object .assign (X3DArrayChaserObject .prototype,
			X3DArrayFollower .prototype,
		{
			step: function (value1, value2, t)
			{
				var
					output   = this .output,
					deltaOut = this .deltaOut;

				for (var i = 0, length = output .length; i < length; ++ i)
					output [i] .add (deltaOut .assign (value1 [i] || this .zero) .subtract (value2 [i] || this .zero) .multiply (t));
			},
		});

		return X3DArrayChaserObject;
	};
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/CoordinateChaser',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DChaserNode",
	"x_ite/Browser/Followers/X3DArrayChaserTemplate",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DArrayChaserTemplate,
          X3DConstants,
          Vector3)
{
"use strict";

	var X3DArrayChaserObject = X3DArrayChaserTemplate (X3DChaserNode);

	function CoordinateChaser (executionContext)
	{
		X3DChaserNode        .call (this, executionContext);
		X3DArrayChaserObject .call (this, executionContext);

		this .addType (X3DConstants .CoordinateChaser);
	}

	CoordinateChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
		X3DArrayChaserObject .prototype,
	{
		constructor: CoordinateChaser,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .MFVec3f (new Vector3 (0, 0, 0))),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .MFVec3f (new Vector3 (0, 0, 0))),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .MFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "CoordinateChaser";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector3 (0, 0, 0);
		},
	});

	return CoordinateChaser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/CoordinateDamper',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DDamperNode",
	"x_ite/Browser/Followers/X3DArrayFollowerTemplate",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DArrayFollowerTemplate,
          X3DConstants,
          Vector3)
{
"use strict";

	var X3DArrayFollowerObject = X3DArrayFollowerTemplate (X3DDamperNode);

	function CoordinateDamper (executionContext)
	{
		X3DDamperNode          .call (this, executionContext);
		X3DArrayFollowerObject .call (this, executionContext);

		this .addType (X3DConstants .CoordinateDamper);
	}

	CoordinateDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
		X3DArrayFollowerObject .prototype,
	{
		constructor: CoordinateDamper,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .MFVec3f (new Vector3 (0, 0, 0))),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .MFVec3f (new Vector3 (0, 0, 0))),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .MFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "CoordinateDamper";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector3 (0, 0, 0);
		},
	});

	return CoordinateDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/OrientationDamper',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DDamperNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Rotation4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Rotation4)
{
"use strict";

	var
		a        = new Rotation4 (0, 0, 1, 0),
		rotation = new Rotation4 (0, 0, 1, 0);

	function OrientationDamper (executionContext)
	{
		X3DDamperNode .call (this, executionContext);

		this .addType (X3DConstants .OrientationDamper);
	}

	OrientationDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
	{
		constructor: OrientationDamper,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFRotation ()),
		]),
		getTypeName: function ()
		{
			return "OrientationDamper";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Rotation4 (0, 0, 1, 0);
		},
		equals: function (lhs, rhs, tolerance)
		{
			a .assign (lhs) .inverse () .multRight (rhs);

			return Math .abs (a .angle) < tolerance;
		},
		interpolate: function (source, destination, weight)
		{
			return rotation .assign (source) .slerp (destination, weight);
		},
	});

	return OrientationDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/PositionChaser2D',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DChaserNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Vector2)
{
"use strict";

	function PositionChaser2D (executionContext)
	{
		X3DChaserNode .call (this, executionContext);

		this .addType (X3DConstants .PositionChaser2D);
	}

	PositionChaser2D .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
	{
		constructor: PositionChaser2D,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFVec2f ()),
		]),
		getTypeName: function ()
		{
			return "PositionChaser2D";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector2 (0, 0);
		},
	});

	return PositionChaser2D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/PositionDamper',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DDamperNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Vector3)
{
"use strict";

	function PositionDamper (executionContext)
	{
		X3DDamperNode .call (this, executionContext);

		this .addType (X3DConstants .PositionDamper);
	}

	PositionDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
	{
		constructor: PositionDamper,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
		]),
		getTypeName: function ()
		{
			return "PositionDamper";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector3 (0, 0, 0);
		},
	});

	return PositionDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/PositionDamper2D',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DDamperNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Vector2)
{
"use strict";

	function PositionDamper2D (executionContext)
	{
		X3DDamperNode .call (this, executionContext);

		this .addType (X3DConstants .PositionDamper2D);
	}

	PositionDamper2D .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
	{
		constructor: PositionDamper2D,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFVec2f ()),
		]),
		getTypeName: function ()
		{
			return "PositionDamper2D";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector2 (0, 0);
		},
	});

	return PositionDamper2D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/ScalarChaser',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DChaserNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DConstants,
          Algorithm)
{
"use strict";

	function ScalarChaser (executionContext)
	{
		X3DChaserNode .call (this, executionContext);

		this .addType (X3DConstants .ScalarChaser);
	}

	ScalarChaser .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
	{
		constructor: ScalarChaser,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "ScalarChaser";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return 0;
		},
		setPreviousValue: function (value)
		{
			this .previousValue = value;
		},
		setDestination: function (value)
		{
			this .destination = value;
		},
		duplicate: function (value)
		{
			return value;
		},
		assign: function (buffer, i, value)
		{
			buffer [i] = value;
		},
		equals: function (lhs, rhs, tolerance)
		{
			return Math .abs (lhs - rhs) < tolerance;
		},
		interpolate: function (source, destination, weight)
		{
			return Algorithm .lerp (source, destination, weight);
		},
		step: function (value1, value2, t)
		{
			this .output += (value1 - value2) * t;
		},
	});

	return ScalarChaser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/ScalarDamper',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DDamperNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DConstants,
          Algorithm)
{
"use strict";

	function ScalarDamper (executionContext)
	{
		X3DDamperNode .call (this, executionContext);

		this .addType (X3DConstants .ScalarDamper);
	}

	ScalarDamper .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
	{
		constructor: ScalarDamper,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "ScalarDamper";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return 0;
		},
		duplicate: function (value)
		{
			return value;
		},
		assign: function (buffer, i, value)
		{
			buffer [i] = value;
		},
		equals: function (lhs, rhs, tolerance)
		{
			return Math .abs (lhs - rhs) < tolerance;
		},
		interpolate: function (source, destination, weight)
		{
			return Algorithm .lerp (source, destination, weight);
		},
	});

	return ScalarDamper;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/TexCoordChaser2D',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DChaserNode",
	"x_ite/Browser/Followers/X3DArrayChaserTemplate",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChaserNode,
          X3DArrayChaserTemplate,
          X3DConstants,
          Vector2)
{
"use strict";

	var X3DArrayChaserObject = X3DArrayChaserTemplate (X3DChaserNode);

	function TexCoordChaser2D (executionContext)
	{
		X3DChaserNode        .call (this, executionContext);
		X3DArrayChaserObject .call (this, executionContext);

		this .addType (X3DConstants .TexCoordChaser2D);
	}

	TexCoordChaser2D .prototype = Object .assign (Object .create (X3DChaserNode .prototype),
		X3DArrayChaserObject .prototype,
	{
		constructor: TexCoordChaser2D,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "duration",           new Fields .SFTime (1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .MFVec2f ()),
		]),
		getTypeName: function ()
		{
			return "TexCoordChaser2D";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector2 (0, 0);
		},
	});

	return TexCoordChaser2D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers/TexCoordDamper2D',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Followers/X3DDamperNode",
	"x_ite/Browser/Followers/X3DArrayFollowerTemplate",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDamperNode,
          X3DArrayFollowerTemplate,
          X3DConstants,
          Vector2)
{
"use strict";

	var X3DArrayFollowerObject = X3DArrayFollowerTemplate (X3DDamperNode);

	function TexCoordDamper2D (executionContext)
	{
		X3DDamperNode          .call (this, executionContext);
		X3DArrayFollowerObject .call (this, executionContext);

		this .addType (X3DConstants .TexCoordDamper2D);
	}

	TexCoordDamper2D .prototype = Object .assign (Object .create (X3DDamperNode .prototype),
		X3DArrayFollowerObject .prototype,
	{
		constructor: TexCoordDamper2D,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_value",          new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_destination",    new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialValue",       new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "initialDestination", new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "order",              new Fields .SFInt32 (3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tau",                new Fields .SFTime (0.3)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "tolerance",          new Fields .SFFloat (-1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",           new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "value_changed",      new Fields .MFVec2f ()),
		]),
		getTypeName: function ()
		{
			return "TexCoordDamper2D";
		},
		getComponentName: function ()
		{
			return "Followers";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getVector: function ()
		{
			return new Vector2 (0, 0, 0);
		},
	});

	return TexCoordDamper2D;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Followers',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Followers/ColorChaser",
	"x_ite/Components/Followers/ColorDamper",
	"x_ite/Components/Followers/CoordinateChaser",
	"x_ite/Components/Followers/CoordinateDamper",
	"x_ite/Components/Followers/OrientationChaser",
	"x_ite/Components/Followers/OrientationDamper",
	"x_ite/Components/Followers/PositionChaser",
	"x_ite/Components/Followers/PositionChaser2D",
	"x_ite/Components/Followers/PositionDamper",
	"x_ite/Components/Followers/PositionDamper2D",
	"x_ite/Components/Followers/ScalarChaser",
	"x_ite/Components/Followers/ScalarDamper",
	"x_ite/Components/Followers/TexCoordChaser2D",
	"x_ite/Components/Followers/TexCoordDamper2D",
	"x_ite/Components/Followers/X3DChaserNode",
	"x_ite/Components/Followers/X3DDamperNode",
	"x_ite/Components/Followers/X3DFollowerNode",
],
function (SupportedNodes,
          ColorChaser,
          ColorDamper,
          CoordinateChaser,
          CoordinateDamper,
          OrientationChaser,
          OrientationDamper,
          PositionChaser,
          PositionChaser2D,
          PositionDamper,
          PositionDamper2D,
          ScalarChaser,
          ScalarDamper,
          TexCoordChaser2D,
          TexCoordDamper2D,
          X3DChaserNode,
          X3DDamperNode,
          X3DFollowerNode)
{
"use strict";

	var Types =
	{
		ColorChaser:       ColorChaser,
		ColorDamper:       ColorDamper,
		CoordinateChaser:  CoordinateChaser,
		CoordinateDamper:  CoordinateDamper,
		OrientationChaser: OrientationChaser,
		OrientationDamper: OrientationDamper,
		PositionChaser:    PositionChaser,
		PositionChaser2D:  PositionChaser2D,
		PositionDamper:    PositionDamper,
		PositionDamper2D:  PositionDamper2D,
		ScalarChaser:      ScalarChaser,
		ScalarDamper:      ScalarDamper,
		TexCoordChaser2D:  TexCoordChaser2D,
		TexCoordDamper2D:  TexCoordDamper2D,
	};

	var AbstractTypes =
	{
		X3DChaserNode: X3DChaserNode,
		X3DDamperNode: X3DDamperNode,
		X3DFollowerNode: X3DFollowerNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Box',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DConstants,
          Vector3)
{
"use strict";

   var defaultSize = new Vector3 (2, 2, 2);

	function Box (executionContext)
	{
		X3DGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .Box);

		this .size_ .setUnit ("length");
	}

	Box .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
	{
		constructor: Box,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "size",     new Fields .SFVec3f (2, 2, 2)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",    new Fields .SFBool (true)),
		]),
		getTypeName: function ()
		{
			return "Box";
		},
		getComponentName: function ()
		{
			return "Geometry3D";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		build: function ()
		{
			var
				options  = this .getBrowser () .getBoxOptions (),
				geometry = options .getGeometry (),
				size     = this .size_ .getValue ();

			this .setMultiTexCoords (geometry .getMultiTexCoords ());
			this .setNormals        (geometry .getNormals ());

			if (size .equals (defaultSize))
			{
				this .setVertices (geometry .getVertices ());

				this .getMin () .assign (geometry .getMin ());
				this .getMax () .assign (geometry .getMax ());
			}
			else
			{
				var
					scale           = Vector3 .divide (size, 2),
					x               = scale .x,
					y               = scale .y,
					z               = scale .z,
					defaultVertices = geometry .getVertices () .getValue (),
					vertexArray     = this .getVertices ();

				for (var i = 0; i < defaultVertices .length; i += 4)
				{
					vertexArray .push (x * defaultVertices [i],
					                   y * defaultVertices [i + 1],
					                   z * defaultVertices [i + 2],
					                   1);
				}

				x = Math .abs (x);
				y = Math .abs (y);
				z = Math .abs (z);

				this .getMin () .set (-x, -y, -z);
				this .getMax () .set ( x,  y,  z);
			}

			this .setSolid (this .solid_ .getValue ());
		},
	});

	return Box;
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Cone',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Complex",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode, 
          X3DConstants,
          Complex,
          Vector2,
          Vector3)
{
"use strict";

	function Cone (executionContext)
	{
		X3DGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .Cone);

		this .height_       .setUnit ("length");
		this .bottomRadius_ .setUnit ("length");
	}

	Cone .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
	{
		constructor: Cone,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",     new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "side",         new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bottom",       new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "height",       new Fields .SFFloat (2)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bottomRadius", new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",        new Fields .SFBool (true)),
		]),
		getTypeName: function ()
		{
			return "Cone";
		},
		getComponentName: function ()
		{
			return "Geometry3D";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		set_live__: function ()
		{
			X3DGeometryNode .prototype .set_live__ .call (this);

			if (this .isLive () .getValue ())
				this .getBrowser () .getConeOptions () .addInterest ("requestRebuild", this);
			else
				this .getBrowser () .getConeOptions () .removeInterest ("requestRebuild", this);
		},
		build: function ()
		{
			var
				options       = this .getBrowser () .getConeOptions (),
				xDimension    = options .xDimension_ .getValue (),
				height        = this .height_ .getValue (),
				bottomRadius  = this .bottomRadius_ .getValue (),
				texCoordArray = this .getTexCoords (),
				normalArray   = this .getNormals (),
				vertexArray   = this .getVertices ();

			this .getMultiTexCoords () .push (texCoordArray);

			var
				y1 = height / 2,
				y2 = -y1,
				nz = Complex .Polar (1, -Math .PI / 2 + Math .atan (bottomRadius / height));

			if (this .side_ .getValue ())
			{
				for (var i = 0; i < xDimension; ++ i)
				{
					var
						u1     = (i + 0.5) / xDimension,
						theta1 = 2 * Math .PI * u1,
						n1     = Complex .Polar (nz .imag, theta1);

					var
						u2     = i / xDimension,
						theta2 = 2 * Math .PI * u2,
						p2     = Complex .Polar (-bottomRadius, theta2),
						n2     = Complex .Polar (nz .imag, theta2);

					var
						u3     = (i + 1) / xDimension,
						theta3 = 2 * Math .PI * u3,
						p3     = Complex .Polar (-bottomRadius, theta3),
						n3     = Complex .Polar (nz .imag, theta3);

					/*    p1
					 *   /  \
					 *  /    \
					 * p2 -- p3
					 */

					// p1
					texCoordArray .push (u1, 1, 0, 1);
					normalArray .push (n1 .imag, nz .real, n1 .real);
					vertexArray .push (0, y1, 0, 1);

					// p2
					texCoordArray .push (u2, 0, 0, 1);
					normalArray .push (n2 .imag, nz .real, n2 .real);
					vertexArray .push (p2 .imag, y2, p2 .real, 1);

					// p3
					texCoordArray .push (u3, 0, 0, 1);
					normalArray .push (n3 .imag , nz .real, n3 .real);
					vertexArray .push (p3 .imag, y2, p3 .real, 1);
				}
			}

			if (this .bottom_ .getValue ())
			{
				var
					texCoord = [ ],
					points   = [ ];

				for (var i = xDimension - 1; i > -1; -- i)
				{
					var
						u     = i / xDimension,
						theta = 2 * Math .PI * u,
						t     = Complex .Polar (-1, theta),
						p     = Complex .multiply (t, bottomRadius);

					texCoord .push (new Vector2 ((t .imag + 1) / 2, (t .real + 1) / 2));
					points .push (new Vector3 (p .imag, y2, p .real));
				}

				var
					t0 = texCoord [0],
					p0 = points [0];

				for (var i = 1, length = points .length - 1; i < length; ++ i)
				{
					var
						t1 = texCoord [i],
						t2 = texCoord [i + 1],
						p1 = points [i],
						p2 = points [i + 1];

					texCoordArray .push (t0 .x, t0 .y, 0, 1);
					normalArray .push (0, -1, 0);
					vertexArray .push (p0 .x, p0 .y, p0 .z, 1);

					texCoordArray .push (t1 .x, t1 .y, 0, 1);
					normalArray .push (0, -1, 0);
					vertexArray .push (p1 .x, p1 .y, p1 .z, 1);

					texCoordArray .push (t2 .x, t2 .y, 0, 1);
					normalArray .push (0, -1, 0);
					vertexArray .push (p2 .x, p2 .y, p2 .z, 1);
				}
			}

			this .setSolid (this .solid_ .getValue ());
			this .setExtents ();
		},
		setExtents: function ()
		{
			var
				bottomRadius = this .bottomRadius_ .getValue (),
				y1           = this .height_ .getValue () / 2,
				y2           = -y1;

			if (! this .side_ .getValue () && ! this .bottom_ .getValue ())
			{
				this .getMin () .set (0, 0, 0);
				this .getMax () .set (0, 0, 0);
			}

			else if (! this .side_ .getValue ())
			{
				this .getMin () .set (-bottomRadius, y2, -bottomRadius);
				this .getMax () .set ( bottomRadius, y2,  bottomRadius);
			}

			else
			{
				this .getMin () .set (-bottomRadius, y2, -bottomRadius);
				this .getMax () .set ( bottomRadius, y1, bottomRadius);
			}
		},
	});

	return Cone;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Cylinder',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Complex",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode, 
          X3DConstants,
          Complex,
          Vector2,
          Vector3)
{
"use strict";

	function Cylinder (executionContext)
	{
		X3DGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .Cylinder);

		this .height_ .setUnit ("length");
		this .radius_ .setUnit ("length");
	}

	Cylinder .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
	{
		constructor: Cylinder,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "top",      new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "side",     new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bottom",   new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "height",   new Fields .SFFloat (2)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "radius",   new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",    new Fields .SFBool (true)),
		]),
		getTypeName: function ()
		{
			return "Cylinder";
		},
		getComponentName: function ()
		{
			return "Geometry3D";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		set_live__: function ()
		{
			X3DGeometryNode .prototype .set_live__ .call (this);

			if (this .isLive () .getValue ())
				this .getBrowser () .getCylinderOptions () .addInterest ("requestRebuild", this);
			else
				this .getBrowser () .getCylinderOptions () .removeInterest ("requestRebuild", this);
		},
		build: function ()
		{
			var
				options       = this .getBrowser () .getCylinderOptions (),
				xDimension    = options .xDimension_ .getValue (),
				texCoordArray = this .getTexCoords (),
				normalArray   = this .getNormals (),
				vertexArray   = this .getVertices ();

			this .getMultiTexCoords () .push (texCoordArray);

			var
				radius = this .radius_ .getValue (),
				y1     = this .height_ .getValue () / 2,
				y2     = -y1;

			if (this .side_ .getValue ())
			{
				for (var i = 0; i < xDimension; ++ i)
				{
					var
						u1     = i / xDimension,
						theta1 = 2 * Math .PI * u1,
						n1     = Complex .Polar (-1, theta1),
						p1     = Complex .multiply (n1, radius);

					var
						u2     = (i + 1) / xDimension,
						theta2 = 2 * Math .PI * u2,
						n2     = Complex .Polar (-1, theta2),
						p2     = Complex .multiply (n2, radius);

					// p1 - p4
					//  | \ |
					// p2 - p3

					// Triangle one

					// p1
					texCoordArray .push (u1, 1, 0, 1);
					normalArray .push (n1 .imag,  0, n1 .real);
					vertexArray .push (p1 .imag, y1, p1 .real, 1);

					// p2
					texCoordArray .push (u1, 0, 0, 1);
					normalArray .push (n1 .imag,  0, n1 .real);
					vertexArray .push (p1 .imag, y2, p1 .real, 1);

					// p3
					texCoordArray .push (u2, 0, 0, 1);
					normalArray .push (n2 .imag,  0, n2 .real);
					vertexArray .push (p2 .imag, y2, p2 .real, 1);

					// Triangle two

					// p1
					texCoordArray .push (u1, 1, 0, 1);
					normalArray .push (n1 .imag,  0, n1 .real);
					vertexArray .push (p1 .imag, y1, p1 .real, 1);

					// p3
					texCoordArray .push (u2, 0, 0, 1);
					normalArray .push (n2 .imag,  0, n2 .real);
					vertexArray .push (p2 .imag, y2, p2 .real, 1);

					// p4
					texCoordArray .push (u2, 1, 0, 1);
					normalArray .push (n2 .imag,  0, n2 .real);
					vertexArray .push (p2 .imag, y1, p2 .real, 1);
				}
			}

			if (this .top_ .getValue ())
			{
				var
					texCoord = [ ],
					points   = [ ];

				for (var i = 0; i < xDimension; ++ i)
				{
					var
						u     = i / xDimension,
						theta = 2 * Math .PI * u,
						t     = Complex .Polar (-1, theta);

					texCoord .push (new Vector2 ((t .imag + 1) / 2, -(t .real - 1) / 2));
					points   .push (new Vector3 (t .imag * radius, y1, t .real * radius));
				}

				var
					t0 = texCoord [0],
					p0 = points [0];

				for (var i = 1, length = points .length - 1; i < length; ++ i)
				{
					var
						t1 = texCoord [i],
						t2 = texCoord [i + 1],
						p1 = points [i],
						p2 = points [i + 1];

					texCoordArray .push (t0 .x, t0 .y, 0, 1);
					normalArray .push (0, 1, 0);
					vertexArray .push (p0 .x, p0 .y, p0 .z, 1);

					texCoordArray .push (t1 .x, t1 .y, 0, 1);
					normalArray .push (0, 1, 0);
					vertexArray .push (p1 .x, p1 .y, p1 .z, 1);

					texCoordArray .push (t2 .x, t2 .y, 0, 1);
					normalArray .push (0, 1, 0);
					vertexArray .push (p2 .x, p2 .y, p2 .z, 1);
				}
			}

			if (this .bottom_ .getValue ())
			{
				var
					texCoord = [ ],
					points   = [ ];

				for (var i = xDimension - 1; i > -1; -- i)
				{
					var
						u     = i / xDimension,
						theta = 2 * Math .PI * u,
						t     = Complex .Polar (-1, theta);

					texCoord .push (new Vector2 ((t .imag + 1) / 2, (t .real + 1) / 2));
					points   .push (new Vector3 (t .imag * radius, y2, t .real * radius));
				}
			
				var
					t0 = texCoord [0],
					p0 = points [0];
				
				for (var i = 1, length = points .length - 1; i < length; ++ i)
				{
					var
						t1 = texCoord [i],
						t2 = texCoord [i + 1],
						p1 = points [i],
						p2 = points [i + 1];

					texCoordArray .push (t0 .x, t0 .y, 0, 1);
					normalArray .push (0, -1, 0);
					vertexArray .push (p0 .x, p0 .y, p0 .z, 1);

					texCoordArray .push (t1 .x, t1 .y, 0, 1);
					normalArray .push (0, -1, 0);
					vertexArray .push (p1 .x, p1 .y, p1 .z, 1);

					texCoordArray .push (t2 .x, t2 .y, 0, 1);
					normalArray .push (0, -1, 0);
					vertexArray .push (p2 .x, p2 .y, p2 .z, 1);
				}
			}

			this .setSolid (this .solid_ .getValue ());
			this .setExtents ();
		},
		setExtents: function ()
		{
			var
				radius = this .radius_ .getValue (),
				y1     = this .height_ .getValue () / 2,
				y2     = -y1;

			if (! this .top_ .getValue () && ! this .side_ .getValue () && ! this .bottom_ .getValue ())
			{
				this .getMin () .set (0, 0, 0);
				this .getMax () .set (0, 0, 0);
			}

			else if (! this .top_ .getValue () && ! this .side_ .getValue ())
			{
				this .getMin () .set (-radius, y2, -radius);
				this .getMax () .set ( radius, y2,  radius);
			}

			else if (! this .bottom_ .getValue () && ! this .side_ .getValue ())
			{
				this .getMin () .set (-radius, y1, -radius);
				this .getMax () .set ( radius, y1,  radius);
			}

			else
			{
				this .getMin () .set (-radius, y2, -radius);
				this .getMax () .set ( radius, y1,  radius);
			}
		},
	});

	return Cylinder;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/ElevationGrid',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Triangle3",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DCast,
          X3DConstants,
          Triangle3,
          Vector2,
          Vector3)
{
"use strict";

	function ElevationGrid (executionContext)
	{
		X3DGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .ElevationGrid);

		this .xSpacing_    .setUnit ("length");
		this .zSpacing_    .setUnit ("length");
		this .creaseAngle_ .setUnit ("angle");
		this .height_      .setUnit ("length");

		this .fogCoordNode = null;
		this .colorNode    = null;
		this .texCoordNode = null;
		this .normalNode   = null;
		this .coordNode    = null;
	}

	ElevationGrid .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
	{
		constructor: ElevationGrid,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_height",      new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "xDimension",      new Fields .SFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "zDimension",      new Fields .SFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "xSpacing",        new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "zSpacing",        new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "creaseAngle",     new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "height",          new Fields .MFFloat ()),
		]),
		getTypeName: function ()
		{
			return "ElevationGrid";
		},
		getComponentName: function ()
		{
			return "Geometry3D";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DGeometryNode .prototype .initialize .call (this);

			this .set_height_ .addFieldInterest (this .height_);
			this .attrib_     .addInterest ("set_attrib__",   this);
			this .fogCoord_   .addInterest ("set_fogCoord__", this);
			this .color_      .addInterest ("set_color__",    this);
			this .texCoord_   .addInterest ("set_texCoord__", this);
			this .normal_     .addInterest ("set_normal__",   this);

			this .set_attrib__ ();
			this .set_fogCoord__ ();
			this .set_color__ ();
			this .set_texCoord__ ();
			this .set_normal__ ();
		},
		set_attrib__: function ()
		{
			var attribNodes = this .getAttrib ();

			for (var i = 0, length = attribNodes .length; i < length; ++ i)
				attribNodes [i] .removeInterest ("requestRebuild", this);

			attribNodes .length = 0;

			for (var i = 0, length = this .attrib_ .length; i < length; ++ i)
			{
				var attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, this .attrib_ [i]);

				if (attribNode)
					attribNodes .push (attribNode);
			}

			for (var i = 0; i < this .attribNodes .length; ++ i)
				attribNodes [i] .addInterest ("requestRebuild", this);
		},
		set_fogCoord__: function ()
		{
			if (this .fogCoordNode)
				this .fogCoordNode .removeInterest ("requestRebuild", this);

			this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this .fogCoord_);

			if (this .fogCoordNode)
				this .fogCoordNode .addInterest ("requestRebuild", this);
		},
		set_color__: function ()
		{
			if (this .colorNode)
			{
				this .colorNode .removeInterest ("requestRebuild", this);
				this .colorNode .transparent_ .removeInterest ("set_transparent__", this);
			}

			this .colorNode = X3DCast (X3DConstants .X3DColorNode, this .color_);

			if (this .colorNode)
			{
				this .colorNode .addInterest ("requestRebuild", this);
				this .colorNode .transparent_ .addInterest ("set_transparent__", this);

				this .set_transparent__ ();
			}
			else
				this .setTransparent (false);
		},
		set_transparent__: function ()
		{
			this .setTransparent (this .colorNode .getTransparent ());
		},
		set_texCoord__: function ()
		{
			if (this .texCoordNode)
				this .texCoordNode .removeInterest ("requestRebuild", this);

			this .texCoordNode = X3DCast (X3DConstants .X3DTextureCoordinateNode, this .texCoord_);

			if (this .texCoordNode)
				this .texCoordNode .addInterest ("requestRebuild", this);

			this .setTextureCoordinate (this .texCoordNode);
		},
		set_normal__: function ()
		{
			if (this .normalNode)
				this .normalNode .removeInterest ("requestRebuild", this);

			this .normalNode = X3DCast (X3DConstants .X3DNormalNode, this .normal_);

			if (this .normalNode)
				this .normalNode .addInterest ("requestRebuild", this);
		},
		getColor: function ()
		{
			return this .colorNode;
		},
		getTexCoord: function ()
		{
			return this .texCoordNode;
		},
		getNormal: function ()
		{
			return this .normalNode;
		},
		getHeight: function (index)
		{
			if (index < this .height_ .length)
				return this .height_ [index];

			return 0;
		},
		createTexCoords: function ()
		{
			var
				texCoords  = [ ],
				xDimension = this .xDimension_ .getValue (),
				zDimension = this .zDimension_ .getValue (),
				xSize      = xDimension - 1,
				zSize      = zDimension - 1;

			for (var z = 0; z < zDimension; ++ z)
			{
				for (var x = 0; x < xDimension; ++ x)
					texCoords .push (new Vector2 (x / xSize, z / zSize));
			}

			return texCoords;
		},
		createNormals: function (points, coordIndex, creaseAngle)
		{
			var
				cw          = ! this .ccw_ .getValue (),
				normalIndex = [ ],
				normals     = [ ];

			for (var p = 0; p < points .length; ++ p)
				normalIndex [p] = [ ];

			for (var c = 0; c < coordIndex .length; c += 3)
			{
				var
					c0 = coordIndex [c],
					c1 = coordIndex [c + 1],
					c2 = coordIndex [c + 2];

				normalIndex [c0] .push (normals .length);
				normalIndex [c1] .push (normals .length + 1);
				normalIndex [c2] .push (normals .length + 2);

				var normal = Triangle3 .normal (points [c0], points [c1], points [c2], new Vector3 (0, 0, 0));

				if (cw)
					normal .negate ();

				normals .push (normal);
				normals .push (normal);
				normals .push (normal);
			}

			return this .refineNormals (normalIndex, normals, this .creaseAngle_ .getValue ());
		},
		createCoordIndex: function ()
		{
			// p1 - p4
			//  | \ |
			// p2 - p3

			var
				coordIndex = [ ],
				xDimension = this .xDimension_ .getValue (),
				zDimension = this .zDimension_ .getValue (),
				xSize      = xDimension - 1,
				zSize      = zDimension - 1;

			for (var z = 0; z < zSize; ++ z)
			{
				for (var x = 0; x < xSize; ++ x)
				{
					var
						i1 =       z * xDimension + x,
						i2 = (z + 1) * xDimension + x,
						i3 = (z + 1) * xDimension + (x + 1),
						i4 =       z * xDimension + (x + 1);

					coordIndex .push (i1); // p1
					coordIndex .push (i2); // p2
					coordIndex .push (i3); // p3

					coordIndex .push (i1); // p1
					coordIndex .push (i3); // p3
					coordIndex .push (i4); // p4
				}
			}

			return coordIndex;
		},
		createPoints: function ()
		{
			var
				points     = [ ],
				xDimension = this .xDimension_ .getValue (),
				zDimension = this .zDimension_ .getValue (),
				xSpacing   = this .xSpacing_ .getValue (),
				zSpacing   = this .zSpacing_ .getValue ();

			for (var z = 0; z < zDimension; ++ z)
			{
				for (var x = 0; x < xDimension; ++ x)
				{
					points .push (new Vector3 (xSpacing * x,
					                           this .getHeight (x + z * xDimension),
					                           zSpacing * z));
				}
			}

			return points;
		},
		build: function ()
		{
			if (this .xDimension_ .getValue () < 2 || this .zDimension_ .getValue () < 2)
				return;

			var
				colorPerVertex     = this .colorPerVertex_ .getValue (),
				normalPerVertex    = this .normalPerVertex_ .getValue (),
				coordIndex         = this .createCoordIndex (),
				attribNodes        = this .getAttrib (),
				numAttrib          = attribNodes .length,
				attribs            = this .getAttribs (),
				fogCoordNode       = this .fogCoordNode,
				colorNode          = this .getColor (),
				texCoordNode       = this .getTexCoord (),
				normalNode         = this .getNormal (),
				points             = this .createPoints (),
				fogDepthArray      = this .getFogDepths (),
				colorArray         = this .getColors (),
				multiTexCoordArray = this .getMultiTexCoords (),
				normalArray        = this .getNormals (),
				vertexArray        = this .getVertices (),
				face               = 0;

			if (texCoordNode)
			{
				texCoordNode .init (multiTexCoordArray);
			}
			else
			{
				var
					texCoords     = this .createTexCoords (),
					texCoordArray = this .getTexCoords ();

				multiTexCoordArray .push (texCoordArray);
			}

			// Build geometry

			for (var c = 0, numCoordIndices = coordIndex .length; c < numCoordIndices; ++ face)
			{
				for (var p = 0; p < 6; ++ p, ++ c)
				{
					var
						index = coordIndex [c],
						point = points [index];

					for (var a = 0; a < numAttrib; ++ a)
						attribNodes [a] .addValue (index, attribs [a]);

					if (fogCoordNode)
						fogCoordNode .addDepth (index, fogDepthArray);

					if (colorNode)
					{
						if (colorPerVertex)
							colorNode .addColor (index, colorArray);
						else
							colorNode .addColor (face, colorArray);
					}

					if (texCoordNode)
					{
						texCoordNode .addTexCoord (index, multiTexCoordArray);
					}
					else
					{
						var t = texCoords [index];

						texCoordArray .push (t .x, t .y, 0, 1);
					}

					if (normalNode)
					{
						if (normalPerVertex)
							normalNode .addVector (index, normalArray);

						else
							normalNode .addVector (face, normalArray);
					}

					vertexArray .push (point .x, point .y, point .z, 1);
				}
			}

			// Add auto-generated normals if needed.

			if (! normalNode)
			{
				var normals = this .createNormals (points, coordIndex);

				for (var i = 0; i < normals .length; ++ i)
				{
					var normal = normals [i];

					normalArray .push (normal .x, normal .y, normal .z);
				}
			}

			this .setSolid (this .solid_ .getValue ());
			this .setCCW (this .ccw_ .getValue ());
		},
	});

	return ElevationGrid;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Extrusion',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Triangle3",
	"standard/Math/Numbers/Vector2",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode,
          X3DConstants,
          Triangle3,
          Vector2,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

	function Extrusion (executionContext)
	{
		X3DGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .Extrusion);

		this .creaseAngle_  .setUnit ("angle");
		this .crossSection_ .setUnit ("length");
		this .spine_        .setUnit ("length");
	}

	Extrusion .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
	{
		constructor: Extrusion,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_crossSection", new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_orientation",  new Fields .MFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_scale",        new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_spine",        new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "beginCap",         new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "endCap",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",            new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",              new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "convex",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "creaseAngle",      new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "crossSection",     new Fields .MFVec2f (new Vector2 (1, 1), new Vector2 (1, -1), new Vector2 (-1, -1), new Vector2 (-1, 1), new Vector2 (1, 1))),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "orientation",      new Fields .MFRotation (new Rotation4 ())),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "scale",            new Fields .MFVec2f (new Vector2 (1, 1))),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "spine",            new Fields .MFVec3f (new Vector3 (0, 0, 0), new Vector3 (0, 1, 0))),
		]),
		getTypeName: function ()
		{
			return "Extrusion";
		},
		getComponentName: function ()
		{
			return "Geometry3D";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DGeometryNode .prototype .initialize .call (this);

			this .set_crossSection_ .addFieldInterest (this .crossSection_);
			this .set_orientation_  .addFieldInterest (this .orientation_);
			this .set_scale_        .addFieldInterest (this .scale_);
			this .set_spine_        .addFieldInterest (this .spine_);
		},
		getClosedOrientation: function ()
		{
			var orientation = this .orientation_;

			if (orientation .length)
			{
				var
					firstOrientation = orientation [0] .getValue (),
					lastOrientation  = orientation [orientation .length - 1] .getValue ();

				return firstOrientation .equals (lastOrientation);
			}

			return true;
		},
		createPoints: (function ()
		{
			var scale3 = new Vector3 (1, 1, 1);

			return function ()
			{
				var
					crossSection = this .crossSection_,
					orientation  = this .orientation_,
					scale        = this .scale_,
					spine        = this .spine_,
					points       = [ ];

				// calculate SCP rotations

				var rotations = this .createRotations ();

				// calculate vertices.

				for (var i = 0, length = spine .length; i < length; ++ i)
				{
					var matrix = rotations [i];

					if (orientation .length)
						matrix .rotate (orientation [Math .min (i, orientation .length - 1)] .getValue ());

					if (scale .length)
					{
						var s = scale [Math .min (i, scale .length - 1)] .getValue ();
						matrix .scale (scale3 .set (s .x, 1, s .y));
					}

					for (var cs = 0, csLength = crossSection .length; cs < csLength; ++ cs)
					{
						var vector = crossSection [cs] .getValue ();
						points .push (matrix .multVecMatrix (new Vector3 (vector .x, 0, vector .y)));
					}
				}

				return points;
			};
		})(),
		createRotations: (function ()
		{
			var rotations = [ ];

			var
				SCPxAxis = new Vector3 (0, 0, 0),
				SCPyAxis = new Vector3 (0, 0, 0),
				SCPzAxis = new Vector3 (0, 0, 0);

			var
				SCPyAxisPrevious = new Vector3 (0, 0, 0),
				SCPzAxisPrevious = new Vector3 (0, 0, 0);

			var
				vector3  = new Vector3 (0, 0, 0),
				rotation = new Rotation4 (0, 0, 1, 0);

			return function ()
			{
				// calculate SCP rotations

				var
					spine       = this .spine_,
					numSpines   = spine .length,
					firstSpine  = spine [0] .getValue (),
					lastSpine   = spine [spine .length - 1] .getValue (),
					closedSpine = firstSpine .equals (lastSpine) && this .getClosedOrientation ();

				// Extend or shrink static rotations array:
				for (var i = rotations .length; i < numSpines; ++ i)
					rotations [i] = new Matrix4 ();

				rotations .length = numSpines;

				// SCP axes:
				SCPxAxis .set (0, 0, 0);
				SCPyAxis .set (0, 0, 0);
				SCPzAxis .set (0, 0, 0);

				// SCP for the first point:
				if (closedSpine)
				{
					// Find first defined Y-axis.
					for (var i = 1, length = numSpines - 2; i < length; ++ i)
					{
						SCPyAxis .assign (spine [i] .getValue ()) .subtract (spine [length] .getValue ()) .normalize ();

						if (! SCPyAxis .equals (Vector3 .Zero))
							break;
					}

					// Find first defined Z-axis.
					for (var i = 0, length = numSpines - 2; i < length; ++ i)
					{
						SCPzAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i] .getValue ())
						           .cross (vector3 .assign (spine [length] .getValue ()) .subtract (spine [i] .getValue ()))
						           .normalize ();

						if (! SCPzAxis .equals (Vector3 .Zero))
							break;
					}
				}
				else
				{
					// Find first defined Y-axis.
					for (var i = 0, length = numSpines - 1; i < length; ++ i)
					{
						SCPyAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i] .getValue ()) .normalize ();

						if (! SCPyAxis .equals (Vector3 .Zero))
							break;
					}

					// Find first defined Z-axis.
					for (var i = 1, length = numSpines - 1; i < length; ++ i)
					{
						SCPzAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i] .getValue ())
						         .cross (vector3 .assign (spine [i - 1] .getValue ()) .subtract (spine [i] .getValue ()))
						         .normalize ();

						if (! SCPzAxis .equals (Vector3 .Zero))
							break;
					}
				}

				// The entire spine is coincident:
				if (SCPyAxis .equals (Vector3 .Zero))
					SCPyAxis .set (0, 1, 0);

				// The entire spine is collinear:
				if (SCPzAxis .equals (Vector3 .Zero))
					rotation .setFromToVec (Vector3 .yAxis, SCPyAxis) .multVecRot (SCPzAxis .assign (Vector3 .zAxis));

				// We do not have to normalize SCPxAxis, as SCPyAxis and SCPzAxis are orthogonal.
				SCPxAxis .assign (SCPyAxis) .cross (SCPzAxis);

				// Get first spine
				var s = firstSpine;

				rotations [0] .set (SCPxAxis .x, SCPxAxis .y, SCPxAxis .z, 0,
				                    SCPyAxis .x, SCPyAxis .y, SCPyAxis .z, 0,
				                    SCPzAxis .x, SCPzAxis .y, SCPzAxis .z, 0,
				                    s .x,        s .y,        s .z,        1);

				// For all points other than the first or last:

				SCPyAxisPrevious .assign (SCPyAxis);
				SCPzAxisPrevious .assign (SCPzAxis);

				for (var i = 1, length = numSpines - 1; i < length; ++ i)
				{
					var s = spine [i] .getValue ();

					SCPyAxis .assign (spine [i + 1] .getValue ()) .subtract (spine [i - 1] .getValue ()) .normalize ();
					SCPzAxis .assign (spine [i + 1] .getValue ()) .subtract (s)
					         .cross (vector3 .assign (spine [i - 1] .getValue ()) .subtract (s))
					         .normalize ();

					// g.
					if (SCPzAxisPrevious .dot (SCPzAxis) < 0)
						SCPzAxis .negate ();

					// The two points used in computing the Y-axis are coincident.
					if (SCPyAxis .equals (Vector3 .Zero))
						SCPyAxis .assign (SCPyAxisPrevious);
					else
						SCPyAxisPrevious .assign (SCPyAxis);

					// The three points used in computing the Z-axis are collinear.
					if (SCPzAxis .equals (Vector3 .Zero))
						SCPzAxis .assign (SCPzAxisPrevious);
					else
						SCPzAxisPrevious .assign (SCPzAxis);

					// We do not have to normalize SCPxAxis, as SCPyAxis and SCPzAxis are orthogonal.
					SCPxAxis .assign (SCPyAxis) .cross (SCPzAxis);

					rotations [i] .set (SCPxAxis .x, SCPxAxis .y, SCPxAxis .z, 0,
					                    SCPyAxis .x, SCPyAxis .y, SCPyAxis .z, 0,
					                    SCPzAxis .x, SCPzAxis .y, SCPzAxis .z, 0,
					                    s .x,        s .y,        s .z,        1);
				}

				// SCP for the last point
				if (closedSpine)
				{
					// The SCPs for the first and last points are the same.
					rotations [numSpines - 1] .assign (rotations [0]);
				}
				else
				{
					var s = lastSpine;

					SCPyAxis .assign (s) .subtract (spine [numSpines - 2] .getValue ()) .normalize ();

					if (numSpines > 2)
					{
						SCPzAxis .assign (s) .subtract (spine [numSpines - 2] .getValue ())
						         .cross (vector3 .assign (spine [numSpines - 3] .getValue ()) .subtract (spine [numSpines - 2] .getValue ()))
						         .normalize ();
					}

					// g.
					if (SCPzAxisPrevious .dot (SCPzAxis) < 0)
						SCPzAxis .negate ();

					// The two points used in computing the Y-axis are coincident.
					if (SCPyAxis .equals (Vector3 .Zero))
						SCPyAxis .assign (SCPyAxisPrevious);

					// The three points used in computing the Z-axis are collinear.
					if (SCPzAxis .equals (Vector3 .Zero))
						SCPzAxis .assign (SCPzAxisPrevious);

					// We do not have to normalize SCPxAxis, as SCPyAxis and SCPzAxis are orthogonal.
					SCPxAxis .assign (SCPyAxis) .cross (SCPzAxis);

					rotations [numSpines - 1] .set (SCPxAxis .x, SCPxAxis .y, SCPxAxis .z, 0,
					                                SCPyAxis .x, SCPyAxis .y, SCPyAxis .z, 0,
					                                SCPzAxis .x, SCPzAxis .y, SCPzAxis .z, 0,
					                                s .x,        s .y,        s .z,        1);
				}

				return rotations;
			};
		})(),
		build: (function ()
		{
			var
				min     = new Vector2 (0, 0, 0),
				max     = new Vector2 (0, 0, 0),
				vector2 = new Vector2 (0, 0, 0);

			return function ()
			{
				var
					cw            = ! this .ccw_ .getValue (),
					crossSection  = this .crossSection_,
					spine         = this .spine_,
					numSpines     = spine .length,
					texCoordArray = this .getTexCoords ();

				if (numSpines < 2 || crossSection .length < 2)
					return;

				this .getMultiTexCoords () .push (texCoordArray);

				var crossSectionSize = crossSection .length; // This one is used only in the INDEX macro.

				function INDEX (n, k) { return n * crossSectionSize + k; }

				var
					firstSpine  = spine [0] .getValue (),
					lastSpine   = spine [numSpines - 1] .getValue (),
					closedSpine = firstSpine .equals (lastSpine) && this .getClosedOrientation ();

				var
					firstCrossSection  = crossSection [0] .getValue (),
					lastCrossSection   = crossSection [crossSection .length - 1] .getValue (),
					closedCrossSection = firstCrossSection .equals (lastCrossSection);

				// For caps calculation

				min .assign (crossSection [0] .getValue ());
				max .assign (crossSection [0] .getValue ());

				for (var k = 1, length = crossSection .length; k < length; ++ k)
				{
					min .min (crossSection [k] .getValue ());
					max .max (crossSection [k] .getValue ());
				}

				var
					capSize      = vector2 .assign (max) .subtract (min),
					capMax       = Math .max (capSize .x, capSize .y),
					numCapPoints = closedCrossSection ? crossSection .length - 1 : crossSection .length;

				// Create

				var
					normalIndex = [ ],
				   normals     = [ ],
					points      = this .createPoints ();

				for (var p = 0, length = points .length; p < length; ++ p)
					normalIndex [p] = [ ];

				// Build body.

				var
					normalArray = this .getNormals (),
					vertexArray = this .getVertices ();

				var
					numCrossSection_1 = crossSection .length - 1,
					numSpine_1        = numSpines - 1;

				var
					indexLeft  = INDEX (0, 0),
					indexRight = INDEX (0, closedCrossSection ? 0 : numCrossSection_1);

				for (var n = 0; n < numSpine_1; ++ n)
				{
					for (var k = 0; k < numCrossSection_1; ++ k)
					{
						var
							n1 = closedSpine && n === numSpines - 2 ? 0 : n + 1,
							k1 = closedCrossSection && k === crossSection .length - 2 ? 0 : k + 1;

						// k      k+1
						//
						// p4 ----- p3   n+1
						//  |     / |
						//  |   /   |
						//  | /     |
						// p1 ----- p2   n

						var
							i1 = INDEX (n,  k),
							i2 = INDEX (n,  k1),
							i3 = INDEX (n1, k1),
							i4 = INDEX (n1, k),
							p1 = points [i1],
							p2 = points [i2],
							p3 = points [i3],
							p4 = points [i4],
							l1 = p2 .distance (p3) >= 1e-7,
							l2 = p4 .distance (p1) >= 1e-7;

						if (cw)
						{
							var
								normal1 = Triangle3 .normal (p3, p2, p1, new Vector3 (0, 0, 0)),
								normal2 = Triangle3 .normal (p4, p3, p1, new Vector3 (0, 0, 0));
						}
						else
						{
							var
								normal1 = Triangle3 .normal (p1, p2, p3, new Vector3 (0, 0, 0)),
								normal2 = Triangle3 .normal (p1, p3, p4, new Vector3 (0, 0, 0));
						}

						// Merge points on the left and right side if spine is coincident for better normal generation.

						if (k == 0)
						{
							if (l2)
								indexLeft = i1;
							else
							{
								i1 = indexLeft;
								p1 = points [i1];
							}
						}

						if (k == crossSection .length - 2)
						{
							if (l1)
								indexRight = i2;
							else
							{
								i3 = indexRight;
								p3 = points [i3];
							}
						}

						// If there are coincident spine points then one length can be zero.

						// Triangle one

						if (l1)
						{
							// p1
							if (l2)
								texCoordArray .push (k / numCrossSection_1, n / numSpine_1, 0, 1);
							else
							{
								// Cone case: ((texCoord1 + texCoord4) / 2)
								var y = (n / numSpine_1 + (n + 1) / numSpine_1) / 2;

								texCoordArray .push (k / numCrossSection_1, y, 0, 1);
							}

							normalIndex [i1] .push (normals .length);
							normals .push (normal1);
							vertexArray .push (p1 .x, p1 .y, p1 .z, 1);

							// p2
							texCoordArray .push ((k + 1) / numCrossSection_1, n / numSpine_1, 0, 1);
							normalIndex [i2] .push (normals .length);
							normals .push (normal1);
							vertexArray .push (p2 .x, p2 .y, p2 .z, 1);

							// p3
							texCoordArray .push ((k + 1) / numCrossSection_1, (n + 1) / numSpine_1, 0, 1);
							normalIndex [i3] .push (normals .length);
							normals .push (normal1);
							vertexArray .push (p3 .x, p3 .y, p3 .z, 1);
						}

						// Triangle two

						if (l2)
						{
							// p1
							texCoordArray .push (k / numCrossSection_1, n / numSpine_1, 0, 1);
							normalIndex [i1] .push (normals .length);
							normals .push (normal2);
							vertexArray .push (p1 .x, p1 .y, p1 .z, 1);

							// p3
							if (l1)
								texCoordArray .push ((k + 1) / numCrossSection_1, (n + 1) / numSpine_1, 0, 1);
							else
							{
								// Cone case: ((texCoord3 + texCoord2) / 2)
								var y = ((n + 1) / numSpine_1 + n / numSpine_1) / 2;

								texCoordArray .push ((k + 1) / numCrossSection_1, y, 0, 1);
							}

							normalIndex [i3] .push (normals .length);
							normals .push (normal2);
							vertexArray .push (p3 .x, p3 .y, p3 .z, 1);

							// p4
							texCoordArray .push (k / numCrossSection_1, (n + 1) / numSpine_1, 0, 1);
							normalIndex [i4] .push (normals .length);
							normals .push (normal2);
							vertexArray .push (p4 .x, p4 .y, p4 .z, 1);
						}
					}
				}

				// Refine body normals and add them.

				normals = this .refineNormals (normalIndex, normals, this .creaseAngle_ .getValue ());

				for (var i = 0; i < normals .length; ++ i)
				{
					var normal = normals [i];

					normalArray .push (normal .x, normal .y, normal .z);
				}
				// Build caps

				if (capMax && crossSection .length > 2)
				{
					if (this .beginCap_ .getValue ())
					{
						var
							j         = 0, // spine
							polygon   = [ ],
							triangles = [ ];

						for (var k = 0; k < numCapPoints; ++ k)
						{
							var
								index = INDEX (j, numCapPoints - 1 - k),
								point = points [index] .copy ();

							point .index    = index;
							point .texCoord = Vector2 .subtract (crossSection [numCapPoints - 1 - k] .getValue (), min) .divide (capMax);
							polygon .push (point);
						}

						if (this .convex_ .getValue ())
							Triangle3 .triangulateConvexPolygon (polygon, triangles);

						else
							Triangle3 .triangulatePolygon (polygon, triangles);

						if (triangles .length >= 3)
						{
							var normal = Triangle3 .normal (points [triangles [0] .index],
							                                points [triangles [1] .index],
							                                points [triangles [2] .index],
							                                new Vector3 (0, 0, 0));

							if (cw)
								normal .negate ();

							this .addCap (texCoordArray, normal, points, triangles);
						}
					}

					if (this .endCap_ .getValue ())
					{
						var
							j         = numSpines - 1, // spine
							polygon   = [ ],
							triangles = [ ];

						for (var k = 0; k < numCapPoints; ++ k)
						{
							var
								index = INDEX (j, k),
								point = points [index] .copy ();

							point .index    = index;
							point .texCoord = Vector2 .subtract (crossSection [k] .getValue (), min) .divide (capMax);
							polygon .push (point);
						}

						if (this .convex_ .getValue ())
							Triangle3 .triangulateConvexPolygon (polygon, triangles);

						else
							Triangle3 .triangulatePolygon (polygon, triangles);

						if (triangles .length >= 3)
						{
							var normal = Triangle3 .normal (points [triangles [0] .index],
							                                points [triangles [1] .index],
							                                points [triangles [2] .index],
							                                new Vector3 (0, 0, 0));

							if (cw)
								normal .negate ();

							this .addCap (texCoordArray, normal, points, triangles);
						}
					}
				}

				this .setSolid (this .solid_ .getValue ());
				this .setCCW (this .ccw_ .getValue ());
			};
		})(),
		addCap: function (texCoordArray, normal, vertices, triangles)
		{
			var
				normalArray = this .getNormals (),
				vertexArray = this .getVertices ();

			for (var i = 0; i < triangles .length; i += 3)
			{
				var
					p0 = vertices [triangles [i]     .index],
					p1 = vertices [triangles [i + 1] .index],
					p2 = vertices [triangles [i + 2] .index],
					t0 = triangles [i]     .texCoord,
					t1 = triangles [i + 1] .texCoord,
					t2 = triangles [i + 2] .texCoord;

				texCoordArray .push (t0 .x, t0 .y, 0, 1);
				texCoordArray .push (t1 .x, t1 .y, 0, 1);
				texCoordArray .push (t2 .x, t2 .y, 0, 1);

				normalArray .push (normal .x, normal .y, normal .z,
				                   normal .x, normal .y, normal .z,
				                   normal .x, normal .y, normal .z);

				vertexArray .push (p0 .x, p0 .y, p0 .z, 1,
				                   p1 .x, p1 .y, p1 .z, 1,
				                   p2 .x, p2 .y, p2 .z, 1);
			}
		},
	});

	return Extrusion;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D/Sphere',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode, 
          X3DConstants)
{
"use strict";

	function Sphere (executionContext)
	{
		X3DGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .Sphere);

		this .radius_ .setUnit ("length");
	}

	Sphere .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
	{
		constructor: Sphere,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "radius",   new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",    new Fields .SFBool (true)),
		]),
		getTypeName: function ()
		{
			return "Sphere";
		},
		getComponentName: function ()
		{
			return "Geometry3D";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		set_live__: function ()
		{
			X3DGeometryNode .prototype .set_live__ .call (this);
		   
			if (this .isLive () .getValue ())
				this .getBrowser () .getSphereOptions () .addInterest ("requestRebuild", this);
			else
				this .getBrowser () .getSphereOptions () .removeInterest ("requestRebuild", this);
		},
		build: function ()
		{
			var
				options  = this .getBrowser () .getSphereOptions (),
				geometry = options .getGeometry (),
				radius   = this .radius_ .getValue ();

			this .setMultiTexCoords (geometry .getMultiTexCoords ());
			this .setNormals        (geometry .getNormals ());

			if (radius === 1)
			{
				this .setVertices (geometry .getVertices ());
	
				this .getMin () .assign (geometry .getMin ());
				this .getMax () .assign (geometry .getMax ());
			}
			else
			{
				var
					defaultVertices = geometry .getVertices () .getValue (),
					vertexArray     = this .getVertices ();

				for (var i = 0; i < defaultVertices .length; i += 4)
				{
					vertexArray .push (radius * defaultVertices [i],
					                   radius * defaultVertices [i + 1],
					                   radius * defaultVertices [i + 2],
					                   1);
				}

				radius = Math .abs (radius);

				this .getMin () .set (-radius, -radius, -radius);
				this .getMax () .set ( radius,  radius,  radius);
			}

			this .setSolid (this .solid_ .getValue ());
		},
	});

	return Sphere;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Geometry3D',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Geometry3D/Box",
	"x_ite/Components/Geometry3D/Cone",
	"x_ite/Components/Geometry3D/Cylinder",
	"x_ite/Components/Geometry3D/ElevationGrid",
	"x_ite/Components/Geometry3D/Extrusion",
	"x_ite/Components/Geometry3D/IndexedFaceSet",
	"x_ite/Components/Geometry3D/Sphere",
],
function (SupportedNodes,
          Box,
          Cone,
          Cylinder,
          ElevationGrid,
          Extrusion,
          IndexedFaceSet,
          Sphere)
{
"use strict";

	var Types =
	{
		Box:            Box,
		Cone:           Cone,
		Cylinder:       Cylinder,
		ElevationGrid:  ElevationGrid,
		Extrusion:      Extrusion,
		IndexedFaceSet: IndexedFaceSet,
		Sphere:         Sphere,
	};

	var AbstractTypes =
	{
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/StaticGroup',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Components/Grouping/X3DBoundedObject",
	"x_ite/Components/Grouping/Group",
	"x_ite/Bits/X3DConstants",
	"x_ite/Bits/TraverseType",
	"standard/Math/Geometry/Box3",
	"standard/Math/Geometry/ViewVolume",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode, 
          X3DBoundedObject, 
          Group,
          X3DConstants,
          TraverseType,
          Box3,
          ViewVolume)
{
"use strict";

	// No support for X3DBindableNode nodes, local lights. X3DLocalFog, local ClipPlane nodes, LOD, Billboard, Switch node.

	function StaticGroup (executionContext)
	{
		X3DChildNode     .call (this, executionContext);
		X3DBoundedObject .call (this, executionContext);

		this .addType (X3DConstants .StaticGroup);

		this .group             = new Group (this .getExecutionContext ());
		this .collisionShapes   = null;
		this .depthShapes       = null;
		this .opaqueShapes      = null;
		this .transparentShapes = null;
		this .bbox              = new Box3 ();
	}

	StaticGroup .prototype = Object .assign (Object .create (X3DChildNode .prototype),
		X3DBoundedObject .prototype,
	{
		constructor: StaticGroup,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",   new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter", new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "children",   new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "StaticGroup";
		},
		getComponentName: function ()
		{
			return "Grouping";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DChildNode     .prototype .initialize .call (this);
			X3DBoundedObject .prototype .initialize .call (this);

			this .bboxSize_   .addFieldInterest (this .group .bboxSize_);
			this .bboxCenter_ .addFieldInterest (this .group .bboxCenter_);
			this .children_   .addFieldInterest (this .group .children_);

			this .group .bboxSize_   = this .bboxSize_;
			this .group .bboxCenter_ = this .bboxCenter_;
			this .group .children_   = this .children_;
			this .group .setPrivate (true);
			this .group .setup ();

			// Connect after Group setup.
			this .group .isCameraObject_   .addFieldInterest (this .isCameraObject_);
			this .group .isPickableObject_ .addFieldInterest (this .isPickableObject_);
			this .group .children_         .addInterest ("set_children__", this);

			this .setCameraObject   (this .group .getCameraObject ());
			this .setPickableObject (this .group .getPickableObject ());

			this .set_children__ ();
		},
		getBBox: function (bbox)
		{
			return bbox .assign (this .bbox);
		},
		set_children__: function ()
		{
			this .group .getBBox (this .bbox);

			this .collisionShapes   = null;
			this .depthShapes       = null;
			this .opaqueShapes      = null;
			this .transparentShapes = null;
		},
		traverse: (function ()
		{
			var viewVolume = new ViewVolume ();

			viewVolume .intersectsSphere = function () { return true; };

			return function (type, renderObject)
			{
				switch (type)
				{
					case TraverseType .CAMERA:
					{
						return;
					}
					case TraverseType .POINTER:
					case TraverseType .COLLISION:
					{
						if (! this .collisionShapes)
						{
							//console .log ("Rebuilding StaticGroup collisionShapes");

							var
								viewVolumes         = renderObject .getViewVolumes (),
								viewport            = renderObject .getViewport (),
								projectionMatrix    = renderObject .getProjectionMatrix (),
								modelViewMatrix     = renderObject .getModelViewMatrix (),
								firstCollisionShape = renderObject .getNumCollisionShapes ();
				
							viewVolumes .push (viewVolume .set (projectionMatrix, viewport, viewport));
	
							modelViewMatrix .push ();
							modelViewMatrix .identity ();
	
							this .group .traverse (type, renderObject);
	
							modelViewMatrix .pop ();
							viewVolumes     .pop ();

							var lastCollisionShape = renderObject .getNumCollisionShapes ();

							this .collisionShapes = renderObject .getCollisionShapes () .splice (firstCollisionShape, lastCollisionShape - firstCollisionShape);

							renderObject .setNumCollisionShapes (firstCollisionShape);
						}

						var
							collisionShapes = this .collisionShapes,
							modelViewMatrix = renderObject .getModelViewMatrix ();

						for (var i = 0, length = collisionShapes .length; i < length; ++ i)
						{
							var collisionShape = collisionShapes [i];

							modelViewMatrix .push ();
							modelViewMatrix .multLeft (collisionShape .modelViewMatrix);
							collisionShape .shapeNode .traverse (type, renderObject);
							modelViewMatrix .pop ();
						}

						return;
					}
					case TraverseType .DEPTH:
					{
						if (! this .depthShapes)
						{
							//console .log ("Rebuilding StaticGroup depthShapes");

							var
								viewVolumes      = renderObject .getViewVolumes (),
								viewport         = renderObject .getViewport (),
								projectionMatrix = renderObject .getProjectionMatrix (),
								modelViewMatrix  = renderObject .getModelViewMatrix (),
								firstDepthShape  = renderObject .getNumDepthShapes ();
				
							viewVolumes .push (viewVolume .set (projectionMatrix, viewport, viewport));
	
							modelViewMatrix .push ();
							modelViewMatrix .identity ();
	
							this .group .traverse (type, renderObject);
	
							modelViewMatrix .pop ();
							viewVolumes     .pop ();

							var lastDepthShape = renderObject .getNumDepthShapes ();

							this .depthShapes = renderObject .getDepthShapes () .splice (firstDepthShape, lastDepthShape - firstDepthShape);

							renderObject .setNumDepthShapes (firstDepthShape);
						}

						var
							depthShapes     = this .depthShapes,
							modelViewMatrix = renderObject .getModelViewMatrix ();

						for (var i = 0, length = depthShapes .length; i < length; ++ i)
						{
							var depthShape = depthShapes [i];

							modelViewMatrix .push ();
							modelViewMatrix .multLeft (depthShape .modelViewMatrix);
							depthShape .shapeNode .traverse (type, renderObject);
							modelViewMatrix .pop ();
						}

						return;
					}
					case TraverseType .DISPLAY:
					{
						if (! this .opaqueShapes)
						{
							//console .log ("Rebuilding StaticGroup opaqueShapes and transparentShapes");

							var
								viewVolumes           = renderObject .getViewVolumes (),
								viewport              = renderObject .getViewport (),
								projectionMatrix      = renderObject .getProjectionMatrix (),
								modelViewMatrix       = renderObject .getModelViewMatrix (),
								firstOpaqueShape      = renderObject .getNumOpaqueShapes (),
								firstTransparentShape = renderObject .getNumTransparentShapes ();
				
							viewVolumes .push (viewVolume .set (projectionMatrix, viewport, viewport));
	
							modelViewMatrix .push ();
							modelViewMatrix .identity ();
	
							this .group .traverse (type, renderObject);
	
							modelViewMatrix .pop ();
							viewVolumes     .pop ();

							var
								lastOpaqueShape      = renderObject .getNumOpaqueShapes (),
								lastTransparentShape = renderObject .getNumTransparentShapes ();

							this .opaqueShapes      = renderObject .getOpaqueShapes () .splice (firstOpaqueShape, lastOpaqueShape - firstOpaqueShape);
							this .transparentShapes = renderObject .getTransparentShapes () .splice (firstTransparentShape, lastTransparentShape - firstTransparentShape);

							renderObject .setNumOpaqueShapes (firstOpaqueShape);
							renderObject .setNumTransparentShapes (firstTransparentShape);
						}

						var
							opaqueShapes      = this .opaqueShapes,
							transparentShapes = this .transparentShapes,
							modelViewMatrix   = renderObject .getModelViewMatrix ();

						for (var i = 0, length = opaqueShapes .length; i < length; ++ i)
						{
							var opaqueShape = opaqueShapes [i];

							modelViewMatrix .push ();
							modelViewMatrix .multLeft (opaqueShape .modelViewMatrix);
							opaqueShape .shapeNode .traverse (type, renderObject);
							modelViewMatrix .pop ();
						}

						for (var i = 0, length = transparentShapes .length; i < length; ++ i)
						{
							var transparentShape = transparentShapes [i];

							modelViewMatrix .push ();
							modelViewMatrix .multLeft (transparentShape .modelViewMatrix);
							transparentShape .shapeNode .traverse (type, renderObject);
							modelViewMatrix .pop ();
						}

						return;
					}
				}
			};
		})(),
	});

	return StaticGroup;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/Switch',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Box3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode,
          TraverseType,
          X3DCast,
          X3DConstants,
          Box3)
{
"use strict";

	function Switch (executionContext)
	{
		X3DGroupingNode .call (this, executionContext);

		this .addType (X3DConstants .Switch);

		if (executionContext .getSpecificationVersion () == "2.0")
			this .addAlias ("choice", this .children_);
	}

	Switch .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
	{
		constructor: Switch,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "whichChoice",    new Fields .SFInt32 (-1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "Switch";
		},
		getComponentName: function ()
		{
			return "Grouping";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DGroupingNode .prototype .initialize .call (this);

			this .whichChoice_ .addInterest ("set_whichChoice__", this);
			this .children_    .addInterest ("set_whichChoice__", this);

			this .set_whichChoice__ ();
		},
		getBBox: function (bbox)
		{
			if (this .bboxSize_ .getValue () .equals (this .getDefaultBBoxSize ()))
			{
				var boundedObject = X3DCast (X3DConstants .X3DBoundedObject, this .child);

				if (boundedObject)
					return boundedObject .getBBox (bbox);

				return bbox .set ();
			}

			return bbox .set (this .bboxSize_ .getValue (), this .bboxCenter_ .getValue ());
		},
		getSubBBox: function (bbox)
		{
			return this .getBBox (bbox);
		},
		set_whichChoice__: function ()
		{
			this .child = this .getChild (this .whichChoice_ .getValue ());

			this .set_cameraObjects__ ();
			this .set_pickableObjects__ ();
		},
		set_cameraObjects__: function ()
		{
			if (this .child && this .child .getCameraObject)
				this .setCameraObject (this .child .getCameraObject ());
			else
				this .setCameraObject (false);
		},
		set_pickableObjects__: function ()
		{
			if (this .getTransformSensors () .size)
				this .setPickableObject (true);
			else if (this .child && this .child .getPickableObject)
				this .setPickableObject (this .child .getPickableObject ());
			else
				this .setPickableObject (false);
		},
		traverse: (function ()
		{
			var bbox = new Box3 ();

			return function (type, renderObject)
			{
				var child = this .child;

				if (child)
				{
					if (type === TraverseType .PICKING)
					{
						if (this .getTransformSensors () .size)
						{
							this .getSubBBox (bbox) .multRight (renderObject .getModelViewMatrix () .get ());

							this .getTransformSensors () .forEach (function (transformSensorNode)
							{
								transformSensorNode .collect (bbox);
							});
						}

						var
							browser          = renderObject .getBrowser (),
							pickingHierarchy = browser .getPickingHierarchy ();

						pickingHierarchy .push (this);

						child .traverse (type, renderObject);

						pickingHierarchy .pop ();
					}
					else
					{
						child .traverse (type, renderObject);
					}
				}
			};
		})(),
	});

	return Switch;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/X3DTransformMatrix3DNode',[
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
],
function (X3DGroupingNode,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

	function X3DTransformMatrix3DNode (executionContext)
	{
		X3DGroupingNode .call (this, executionContext);

		this .addType (X3DConstants .X3DTransformMatrix3DNode);

		this .matrix   = new Matrix4 ();
		this .traverse = this .getGroupTraverse ();
	}

	X3DTransformMatrix3DNode .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
	{
		constructor: X3DTransformMatrix3DNode,
		getBBox: function (bbox)
		{
			var bbox = X3DGroupingNode .prototype .getBBox .call (this, bbox);

			if (this .traverse === this .getGroupTraverse ())
				return bbox;

			return bbox .multRight (this .matrix);
		},
		getSubBBox: function (bbox)
		{
			return X3DGroupingNode .prototype .getBBox .call (this, bbox);
		},
		setMatrix: function (matrix)
		{
			if (matrix .equals (Matrix4 .Identity))
			{
				this .matrix .identity ();
				this .traverse = this .getGroupTraverse ();
			}
			else
			{
				this .matrix .assign (matrix);
				this .traverse = this .getTraverse ();
			}
		},
		getMatrix: function ()
		{
			return this .matrix;
		},
		setTransform: function (t, r, s, so, c)
		{
			if (t .equals (Vector3 .Zero) && r .equals (Rotation4 .Identity) && s .equals (Vector3 .One))
			{
				this .matrix .identity ();
				this .traverse = this .getGroupTraverse ();
			}
			else
			{
			   this .matrix .set (t, r, s, so, c);
				this .traverse = this .getTraverse ();
			}
		},
		getTraverse: (function ()
		{
			function traverse (type, renderObject)
			{
				var modelViewMatrix = renderObject .getModelViewMatrix ();
	
				modelViewMatrix .push ();
				modelViewMatrix .multLeft (this .matrix);
				
				X3DGroupingNode .prototype .traverse .call (this, type, renderObject);
	
				modelViewMatrix .pop ();
			}

			return function ()
			{
				return traverse;
			};
		})(),
		getGroupTraverse: function ()
		{
			return X3DGroupingNode .prototype .traverse;
		},
	});

	return X3DTransformMatrix3DNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/X3DTransformNode',[
	"x_ite/Components/Grouping/X3DTransformMatrix3DNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DTransformMatrix3DNode, 
          X3DConstants)
{
"use strict";

	function X3DTransformNode (executionContext)
	{
		X3DTransformMatrix3DNode .call (this, executionContext);

		this .addType (X3DConstants .X3DTransformNode);

		this .translation_ .setUnit ("length");
		this .center_      .setUnit ("length");
	}

	X3DTransformNode .prototype = Object .assign (Object .create (X3DTransformMatrix3DNode .prototype),
	{
		constructor: X3DTransformNode,
		initialize: function ()
		{
			X3DTransformMatrix3DNode .prototype .initialize .call (this);
			
			this .addInterest ("eventsProcessed", this);

			this .eventsProcessed ();
		},
		eventsProcessed: function ()
		{
			this .setHidden (this .scale_ .x === 0 ||
			                 this .scale_ .y === 0 ||
			                 this .scale_ .z === 0);

			this .setTransform (this .translation_      .getValue (),
			                    this .rotation_         .getValue (),
			                    this .scale_            .getValue (),
			                    this .scaleOrientation_ .getValue (),
			                    this .center_           .getValue ());
		},
	});

	return X3DTransformNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping/Transform',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Grouping/X3DTransformNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTransformNode, 
          X3DConstants)
{
"use strict";

	function Transform (executionContext)
	{
		X3DTransformNode .call (this, executionContext);

		this .addType (X3DConstants .Transform);
	}

	Transform .prototype = Object .assign (Object .create (X3DTransformNode .prototype),
	{
		constructor: Transform,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "translation",      new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "rotation",         new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "scale",            new Fields .SFVec3f (1, 1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "scaleOrientation", new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "center",           new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",         new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",       new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",      new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren",   new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "children",         new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "Transform";
		},
		getComponentName: function ()
		{
			return "Grouping";
		},
		getContainerField: function ()
		{
			return "children";
		},
	});

	return Transform;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Grouping',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Grouping/Group",
	"x_ite/Components/Grouping/StaticGroup",
	"x_ite/Components/Grouping/Switch",
	"x_ite/Components/Grouping/Transform",
	"x_ite/Components/Grouping/X3DBoundedObject",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Components/Grouping/X3DTransformMatrix3DNode",
	"x_ite/Components/Grouping/X3DTransformNode",
],
function (SupportedNodes,
          Group,
          StaticGroup,
          Switch,
          Transform,
          X3DBoundedObject,
          X3DGroupingNode,
          X3DTransformMatrix3DNode,
          X3DTransformNode)
{
"use strict";

	var Types =
	{
		Group:       Group,
		StaticGroup: StaticGroup,
		Switch:      Switch,
		Transform:   Transform,
	};

	var AbstractTypes =
	{
		X3DBoundedObject:         X3DBoundedObject,
		X3DGroupingNode:          X3DGroupingNode,
		X3DTransformMatrix3DNode: X3DTransformMatrix3DNode,
		X3DTransformNode:         X3DTransformNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/ColorInterpolator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Color3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          X3DConstants,
          Color3)
{
"use strict";

	function ColorInterpolator (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .ColorInterpolator);

		this .hsv = [ ];
	}

	ColorInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: ColorInterpolator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFColor ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFColor ()),
		]),
		getTypeName: function ()
		{
			return "ColorInterpolator";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);

			this .keyValue_ .addInterest ("set_keyValue__", this);
		},
		set_keyValue__: function ()
		{
			var keyValue = this .keyValue_;

			if (keyValue .length < this .key_ .length)
				this .keyValue_ .resize (this .key_ .length, keyValue .length ? keyValue [this .keyValue_ .length - 1] : new Fields .SFColor ());

			this .hsv .length = 0;

			for (var i = 0, length = keyValue .length; i < length; ++ i)
				this .hsv .push (keyValue [i] .getHSV ([ ]));
		},
		interpolate: (function ()
		{
			var value = [ ];

			return function (index0, index1, weight)
			{
				Color3 .lerp (this .hsv [index0], this .hsv [index1], weight, value);
	
				this .value_changed_ .setHSV (value [0], value [1], value [2]);
			};
		})(),
	});

	return ColorInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/CoordinateInterpolator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          X3DConstants,
          Algorithm)
{
"use strict";

	function CoordinateInterpolator (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .CoordinateInterpolator);
	}

	CoordinateInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: CoordinateInterpolator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .MFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "CoordinateInterpolator";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		set_keyValue__: function () { },
		interpolate: function (index0, index1, weight)
		{
			var
				keyValue = this .keyValue_ .getValue (),
				size     = this .key_ .length ? Math .floor (this .keyValue_ .length / this .key_ .length) : 0;

			this .value_changed_ .length = size;

			var value_changed = this .value_changed_ .getValue ();

			index0 *= size;
			index1  = index0 + (this .key_ .length > 1 ? size : 0);

			index0 *= 3;
			index1 *= 3;
			size   *= 3;

			for (var i0 = 0; i0 < size; i0 += 3)
			{
				var
					i1 = i0 + 1,
					i2 = i0 + 2;

				value_changed [i0] = Algorithm .lerp (keyValue [index0 + i0], keyValue [index1 + i0], weight);
				value_changed [i1] = Algorithm .lerp (keyValue [index0 + i1], keyValue [index1 + i1], weight);
				value_changed [i2] = Algorithm .lerp (keyValue [index0 + i2], keyValue [index1 + i2], weight);
			}

			this .value_changed_ .addEvent ();
		},
	});

	return CoordinateInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/CoordinateInterpolator2D',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          X3DConstants,
          Algorithm)
{
"use strict";

	function CoordinateInterpolator2D (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .CoordinateInterpolator2D);
	}

	CoordinateInterpolator2D .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: CoordinateInterpolator2D,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .MFVec2f ()),
		]),
		getTypeName: function ()
		{
			return "CoordinateInterpolator2D";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		set_keyValue__: function () { },
		interpolate: function (index0, index1, weight)
		{
			var
				keyValue = this .keyValue_ .getValue (),
				size     = this .key_ .length ? Math .floor (this .keyValue_ .length / this .key_ .length) : 0;

			this .value_changed_ .length = size;

			var value_changed = this .value_changed_ .getValue ();

			index0 *= size;
			index1  = index0 + (this .key_ .length > 1 ? size : 0);

			index0 *= 2;
			index1 *= 2;
			size   *= 2;

			for (var i0 = 0; i0 < size; i0 += 2)
			{
				var i1 = i0 + 1;

				value_changed [i0] = Algorithm .lerp (keyValue [index0 + i0], keyValue [index1 + i0], weight);
				value_changed [i1] = Algorithm .lerp (keyValue [index0 + i1], keyValue [index1 + i1], weight);
			}

			this .value_changed_ .addEvent ();
		},
	});

	return CoordinateInterpolator2D;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/NormalInterpolator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          X3DConstants,
          Vector3,
          Algorithm)
{
"use strict";

	var
		keyValue0 = new Vector3 (0, 0, 0),
		keyValue1 = new Vector3 (0, 0, 0);

	function NormalInterpolator (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .NormalInterpolator);
	}

	NormalInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: NormalInterpolator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .MFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "NormalInterpolator";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);

			this .keyValue_ .addInterest ("set_keyValue__", this);
		},
		set_keyValue__: function () { },
		interpolate: function (index0, index1, weight)
		{
			var
				keyValue = this .keyValue_ .getValue (),
				size     = this .key_ .length > 1 ? Math .floor (this .keyValue_ .length / this .key_ .length) : 0;

			this .value_changed_ .length = size;

			var value_changed = this .value_changed_ .getValue ();

			index0 *= size;
			index1  = index0 + size;

			index0 *= 3;
			index1 *= 3;
			size   *= 3;

			for (var i0 = 0; i0 < size; i0 += 3)
			{
				try
				{
					var
						i1 = i0 + 1,
						i2 = i0 + 2;

					keyValue0 .set (keyValue [index0 + i0], keyValue [index0 + i1], keyValue [index0 + i2]);
					keyValue1 .set (keyValue [index1 + i0], keyValue [index1 + i1], keyValue [index1 + i2]);

					var value = Algorithm .simpleSlerp (keyValue0, keyValue1, weight);

					value_changed [i0] = value [0];
					value_changed [i1] = value [1];
					value_changed [i2] = value [2];
				}
				catch (error)
				{ }
			}

			this .value_changed_ .addEvent ();
		},
	});

	return NormalInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/PositionInterpolator2D',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector2",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          X3DConstants,
          Vector2)
{
"use strict";

	function PositionInterpolator2D (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .PositionInterpolator2D);
	}

	PositionInterpolator2D .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: PositionInterpolator2D,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFVec2f ()),
		]),
		getTypeName: function ()
		{
			return "PositionInterpolator2D";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);

			this .keyValue_ .addInterest ("set_keyValue__", this);
		},
		set_keyValue__: function ()
		{
			var
				key      = this .key_,
				keyValue = this .keyValue_;

			if (keyValue .length < key .length)
				keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFVec2f ());
		},
		interpolate:  (function ()
		{
			var keyValue = new Vector2 (0, 0);

			return function (index0, index1, weight)
			{
				this .value_changed_ = keyValue .assign (this .keyValue_ [index0] .getValue ()) .lerp (this .keyValue_ [index1] .getValue (), weight);
			};
		})(),
	});

	return PositionInterpolator2D;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolator',[
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Matrix4",
],
function (Vector4,
          Matrix4)
{
"use strict";

	var
		T  = [ ],
		Fp = [ ],
		Fm = [ ],
		S  = new Vector4 (0, 0, 0, 0);
		
	var H = new Matrix4 ( 2, -2,  1,  1,
			               -3,  3, -2, -1,
			                0,  0,  1,  0,
			                1,  0,  0,  0);

	function CatmullRomSplineInterpolator ()
	{
		this .T0 = [ ];
		this .T1 = [ ];
	}

	CatmullRomSplineInterpolator .prototype =
	{
		constructor: CatmullRomSplineInterpolator,
		generate: function (closed, key, keyValue, keyVelocity, normalizeVelocity)
		{
			var
				T0 = this .T0,
				T1 = this .T1;

			T0 .length = 0;
			T1 .length = 0;

			T  .length = 0;
			Fp .length = 0;
			Fm .length = 0;

			if (key .length > 1)
			{
				// T
		
				if (keyVelocity .length === 0)
				{
					if (closed)
						T .push (this .divide (this .subtract (keyValue [1], keyValue [keyValue .length - 2]), 2));
		
					else
						T .push (this .create ());
		
					for (var i = 1, length = keyValue .length - 1; i < length; ++ i)
						T .push (this .divide (this .subtract (keyValue [i + 1], keyValue [i - 1]), 2));
		
					T .push (this .copy (T [0]));
				}
				else
				{
					for (var i = 0, length = keyVelocity .length; i < length; ++ i)
						T .push (this .copy (keyVelocity [i]));
		
					if (normalizeVelocity)
					{
						var Dtot = 0;
		
						for (var i = 0, length = keyValue .length - 1; i < length; ++ i)
							Dtot += this .abs (this .subtract (keyValue [i], keyValue [i + 1]));
		
						for (var i = 0, length = T .length - 1; i < length; ++ i)
						{
							var Tia = this .abs (T [i]);

							if (Tia)
								T [i] = this .multiply (T [i], Dtot / Tia);
						}
					}
				}

				// Fm, Fp
		
				if (closed)
				{
					var i_1 = key .length - 1;
					var i_2 = key .length - 2;
		
					var d = key [1] - key [0] + key [i_1] - key [i_2];
		
					Fm .push (2 * (key [1]   - key [0])   / d);
					Fp .push (2 * (key [i_1] - key [i_2]) / d);

				}
				else
				{
					Fm .push (1);
					Fp .push (1);
				}

				for (var i = 1, length = key .length - 1; i < length; ++ i)
				{
					var d = key [i + 1] - key [i - 1];
		
					Fm .push (2 * (key [i + 1] - key [i])     / d);
					Fp .push (2 * (key [i]     - key [i - 1]) / d);
				}
		
				Fm .push (Fm [0]);
				Fp .push (Fp [0]);
		
				// T0, T1
		
				for (var i = 0, length = T .length; i < length; ++ i)
				{
					T0 .push (this .multiply (T [i], Fp [i]));
					T1 .push (this .multiply (T [i], Fm [i]));
				}
			}
			else
			{
				T0 .push (this .create ());
				T1 .push (this .create ());
			}
		},
		interpolate: function (index0, index1, weight, keyValue)
		{
			S .set (Math .pow (weight, 3), Math .pow (weight, 2), weight, 1);
		
			// Taking dot product from SH and C;

			return this .dot (H .multVecMatrix (S),
                           keyValue [index0],
                           keyValue [index1],
                           this .T0 [index0],
                           this .T1 [index1]);
		},
	};

	return CatmullRomSplineInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolatorTemplate',[
	"x_ite/Browser/Interpolation/CatmullRomSplineInterpolator"
],
function (CatmullRomSplineInterpolator)
{
"use strict";

	return function (Type)
	{
		var
			c0 = new Type (0, 0, 0, 0),
			c1 = new Type (0, 0, 0, 0),
			c2 = new Type (0, 0, 0, 0),
			c3 = new Type (0, 0, 0, 0);
	
		function CatmullRomSplineInterpolatorInstance ()
		{
			this .T0 = [ ];
			this .T1 = [ ];
		}
	
		CatmullRomSplineInterpolatorInstance .prototype = Object .assign (Object .create (CatmullRomSplineInterpolator .prototype),
		{
			constructor: CatmullRomSplineInterpolatorInstance,
			create: function ()
			{
				return new Type (0, 0, 0, 0);
			},
			copy: function (value)
			{
				return value .copy ();
			},
			subtract: function (lhs, rhs)
			{
				return Type .subtract (lhs, rhs);
			},
			multiply: function (lhs, rhs)
			{
				return Type .multiply (lhs, rhs);
			},
			divide: function (lhs, rhs)
			{
				return Type .divide (lhs, rhs);
			},
			abs: function (value)
			{
				return value .abs ();
			},
			dot: function (SH, C0, C1, C2, C3)
			{
				c0 .assign (C0) .multiply (SH [0]);
				c1 .assign (C1) .multiply (SH [1]);
				c2 .assign (C2) .multiply (SH [2]);
				c3 .assign (C3) .multiply (SH [3]);
	
				return c0 .add (c1) .add (c2) .add (c3);
			},
		});
	
		return CatmullRomSplineInterpolatorInstance;
	};
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolator3',[
	"x_ite/Browser/Interpolation/CatmullRomSplineInterpolatorTemplate",
	"standard/Math/Numbers/Vector3",
],
function (CatmullRomSplineInterpolatorTemplate,
          Vector3)
{
"use strict";

	return CatmullRomSplineInterpolatorTemplate (Vector3);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/SplinePositionInterpolator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Browser/Interpolation/CatmullRomSplineInterpolator3",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          CatmullRomSplineInterpolator3,
          X3DConstants)
{
"use strict";

	function SplinePositionInterpolator (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .SplinePositionInterpolator);

		this .spline = new CatmullRomSplineInterpolator3 ();
	}

	SplinePositionInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: SplinePositionInterpolator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",      new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "closed",            new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",               new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",          new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyVelocity",       new Fields .MFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "normalizeVelocity", new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed",     new Fields .SFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "SplinePositionInterpolator";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);
		
			this .keyValue_          .addInterest ("set_keyValue__",          this);
			this .keyVelocity_       .addInterest ("set_keyVelocity__",       this);
			this .normalizeVelocity_ .addInterest ("set_normalizeVelocity__", this);
		},
		set_keyValue__: function ()
		{
			var
				key      = this .key_,
				keyValue = this .keyValue_;

			if (keyValue .length < key .length)
				keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFVec3f ());
		
			this .set_keyVelocity__ ();
		},
		set_keyVelocity__: function ()
		{
			if (this .keyVelocity_ .length)
			{
				if (this .keyVelocity_ .length < this .key_ .length)
					this .keyVelocity_ .resize (this .key_ .length, new Fields .SFVec3f ());
			}

			this .set_normalizeVelocity__ ();
		},
		set_normalizeVelocity__: function ()
		{
			this .spline .generate (this .closed_ .getValue (),
			                        this .key_,
			                        this .keyValue_,
			                        this .keyVelocity_,
			                        this .normalizeVelocity_ .getValue ());
		},
		interpolate: function (index0, index1, weight)
		{
			this .value_changed_ = this .spline .interpolate (index0, index1, weight, this .keyValue_);
		},
	});

	return SplinePositionInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolator2',[
	"x_ite/Browser/Interpolation/CatmullRomSplineInterpolatorTemplate",
	"standard/Math/Numbers/Vector2",
],
function (CatmullRomSplineInterpolatorTemplate,
          Vector2)
{
"use strict";

	return CatmullRomSplineInterpolatorTemplate (Vector2);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/SplinePositionInterpolator2D',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Browser/Interpolation/CatmullRomSplineInterpolator2",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          CatmullRomSplineInterpolator2,
          X3DConstants)
{
"use strict";

	function SplinePositionInterpolator2D (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .SplinePositionInterpolator2D);

		this .spline = new CatmullRomSplineInterpolator2 ();
	}

	SplinePositionInterpolator2D .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: SplinePositionInterpolator2D,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",      new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "closed",            new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",               new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",          new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyVelocity",       new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "normalizeVelocity", new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed",     new Fields .SFVec2f ()),
		]),
		getTypeName: function ()
		{
			return "SplinePositionInterpolator2D";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);

			this .keyValue_          .addInterest ("set_keyValue__",          this);
			this .keyVelocity_       .addInterest ("set_keyVelocity__",       this);
			this .normalizeVelocity_ .addInterest ("set_normalizeVelocity__", this);
		},
		set_keyValue__: function ()
		{
			var
				key      = this .key_,
				keyValue = this .keyValue_;

			if (keyValue .length < key .length)
				keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFVec2f ());
		
			this .set_keyVelocity__ ();
		},
		set_keyVelocity__: function ()
		{
			if (this .keyVelocity_ .length)
			{
				if (this .keyVelocity_ .length < this .key_ .length)
					this .keyVelocity_ .resize (this .key_ .length, new Fields .SFVec2f ());
			}

			this .set_normalizeVelocity__ ();
		},
		set_normalizeVelocity__: function ()
		{
			this .spline .generate (this .closed_ .getValue (),
			                        this .key_,
			                        this .keyValue_,
			                        this .keyVelocity_,
			                        this .normalizeVelocity_ .getValue ());
		},
		interpolate: function (index0, index1, weight)
		{
			this .value_changed_ = this .spline .interpolate (index0, index1, weight, this .keyValue_);
		},
	});

	return SplinePositionInterpolator2D;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/CatmullRomSplineInterpolator1',[
	"x_ite/Browser/Interpolation/CatmullRomSplineInterpolator"
],
function (CatmullRomSplineInterpolator)
{
"use strict";

	function CatmullRomSplineInterpolator1 ()
	{
		this .T0 = [ ];
		this .T1 = [ ];
	}

	CatmullRomSplineInterpolator1 .prototype = Object .assign (Object .create (CatmullRomSplineInterpolator .prototype),
	{
		constructor: CatmullRomSplineInterpolator1,
		create: function ()
		{
			return 0;
		},
		copy: function (value)
		{
			return value;
		},
		subtract: function (lhs, rhs)
		{
			return lhs - rhs;
		},
		multiply: function (lhs, rhs)
		{
			return lhs * rhs;
		},
		divide: function (lhs, rhs)
		{
			return lhs / rhs;
		},
		abs: function (value)
		{
			return Math .abs (value);
		},
		dot: function (SH, C0, C1, C2, C3)
		{
			return C0 * SH [0] + C1 * SH [1] + C2 * SH [2] + C3 * SH [3];
		},
	});

	return CatmullRomSplineInterpolator1;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/SplineScalarInterpolator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Browser/Interpolation/CatmullRomSplineInterpolator1",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode, 
          CatmullRomSplineInterpolator1,
          X3DConstants)
{
"use strict";

	function SplineScalarInterpolator (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .SplineScalarInterpolator);

		this .spline = new CatmullRomSplineInterpolator1 ();
	}

	SplineScalarInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: SplineScalarInterpolator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",      new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "closed",            new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",               new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",          new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyVelocity",       new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "normalizeVelocity", new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed",     new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "SplineScalarInterpolator";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);
		
			this .keyValue_          .addInterest ("set_keyValue__",          this);
			this .keyVelocity_       .addInterest ("set_keyVelocity__",       this);
			this .normalizeVelocity_ .addInterest ("set_normalizeVelocity__", this);
		},
		set_keyValue__: function ()
		{
			var
				key      = this .key_,
				keyValue = this .keyValue_;

			if (keyValue .length < key .length)
				keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFFloat ());
		
			this .set_keyVelocity__ ();
		},
		set_keyVelocity__: function ()
		{
			if (this .keyVelocity_ .length)
			{
				if (this .keyVelocity_ .length < this .key_ .length)
					this .keyVelocity_ .resize (this .key_ .length, new Fields .SFFloat ());
			}

			this .set_normalizeVelocity__ ();
		},
		set_normalizeVelocity__: function ()
		{
			this .spline .generate (this .closed_ .getValue (),
			                        this .key_,
			                        this .keyValue_,
			                        this .keyVelocity_,
			                        this .normalizeVelocity_ .getValue ());
		},
		interpolate: function (index0, index1, weight)
		{
			this .value_changed_ = this .spline .interpolate (index0, index1, weight, this .keyValue_);
		},
	});

	return SplineScalarInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/Interpolation/SquatInterpolator',[
	"standard/Math/Numbers/Rotation4",
],
function (Rotation4)
{
"use strict";

	var result = new Rotation4 (0, 0, 1, 0);

	function SquatInterpolator ()
	{
		this .s = [ ];
	}

	SquatInterpolator .prototype =
	{
		constructor: SquatInterpolator,
		generate: function (closed, key, keyValue)
		{
			var s = this .s;

			s .length = 0;

			if (key .length > 1)
			{
				if (closed)
				{
					s .push (Rotation4 .spline (keyValue [key .length - 2] .getValue (),
					                            keyValue [0] .getValue (),
					                            keyValue [1] .getValue ()));
				}
				else
				{
					s .push (keyValue [0] .getValue ());
				}
		
				for (var i = 1, length = key .length - 1; i < length; ++ i)
				{
					s .push (Rotation4 .spline (keyValue [i - 1] .getValue (),
					                            keyValue [i]     .getValue (),
					                            keyValue [i + 1] .getValue ()));
				}
		
				if (closed)
				{
					s .push (Rotation4 .spline (keyValue [key .length - 2] .getValue (),
					                            keyValue [key .length - 1] .getValue (),
					                            keyValue [1] .getValue ()));
				}
				else
				{
					s .push (keyValue [key .length - 1] .getValue ());
				}
			}
			else if (key .length > 0)
				s .push (keyValue [0] .getValue () .copy ());
		},
		interpolate: function (index0, index1, weight, keyValue)
		{
			return result .assign (keyValue [index0] .getValue ()) .squad (this .s [index0],
			                                                               this .s [index1],
			                                                               keyValue [index1] .getValue (), weight);
		},
	};

	return SquatInterpolator;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation/SquadOrientationInterpolator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
	"x_ite/Browser/Interpolation/SquatInterpolator",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DInterpolatorNode,
          SquatInterpolator,
          X3DConstants)
{
"use strict";

	function SquadOrientationInterpolator (executionContext)
	{
		X3DInterpolatorNode .call (this, executionContext);

		this .addType (X3DConstants .SquadOrientationInterpolator);

		this .squad = new SquatInterpolator ();
	}

	SquadOrientationInterpolator .prototype = Object .assign (Object .create (X3DInterpolatorNode .prototype),
	{
		constructor: SquadOrientationInterpolator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,   "set_fraction",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "closed",        new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "key",           new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "keyValue",      new Fields .MFRotation ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "value_changed", new Fields .SFRotation ()),
		]),
		getTypeName: function ()
		{
			return "SquadOrientationInterpolator";
		},
		getComponentName: function ()
		{
			return "Interpolation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DInterpolatorNode .prototype .initialize .call (this);
		
			this .keyValue_    .addInterest ("set_keyValue__", this);
		},
		set_keyValue__: function ()
		{
			var
				key      = this .key_,
				keyValue = this .keyValue_;

			if (keyValue .length < key .length)
				keyValue .resize (key .length, keyValue .length ? keyValue [keyValue .length - 1] : new Fields .SFRotation ());

			this .squad .generate (this .closed_ .getValue (),
			                       this .key_,
			                       this .keyValue_);
		},
		interpolate: function (index0, index1, weight)
		{
			try
			{
				this .value_changed_ = this .squad .interpolate (index0, index1, weight, this .keyValue_);
			}
			catch (error)
			{
				console .log (error);
			}
		},
	});

	return SquadOrientationInterpolator;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Interpolation',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Interpolation/ColorInterpolator",
	"x_ite/Components/Interpolation/CoordinateInterpolator",
	"x_ite/Components/Interpolation/CoordinateInterpolator2D",
	"x_ite/Components/Interpolation/EaseInEaseOut",
	"x_ite/Components/Interpolation/NormalInterpolator",
	"x_ite/Components/Interpolation/OrientationInterpolator",
	"x_ite/Components/Interpolation/PositionInterpolator",
	"x_ite/Components/Interpolation/PositionInterpolator2D",
	"x_ite/Components/Interpolation/ScalarInterpolator",
	"x_ite/Components/Interpolation/SplinePositionInterpolator",
	"x_ite/Components/Interpolation/SplinePositionInterpolator2D",
	"x_ite/Components/Interpolation/SplineScalarInterpolator",
	"x_ite/Components/Interpolation/SquadOrientationInterpolator",
	"x_ite/Components/Interpolation/X3DInterpolatorNode",
],
function (SupportedNodes,
          ColorInterpolator,
          CoordinateInterpolator,
          CoordinateInterpolator2D,
          EaseInEaseOut,
          NormalInterpolator,
          OrientationInterpolator,
          PositionInterpolator,
          PositionInterpolator2D,
          ScalarInterpolator,
          SplinePositionInterpolator,
          SplinePositionInterpolator2D,
          SplineScalarInterpolator,
          SquadOrientationInterpolator,
          X3DInterpolatorNode)
{
"use strict";

	var Types =
	{
		ColorInterpolator:            ColorInterpolator,
		CoordinateInterpolator:       CoordinateInterpolator,
		CoordinateInterpolator2D:     CoordinateInterpolator2D,
		EaseInEaseOut:                EaseInEaseOut,
		NormalInterpolator:           NormalInterpolator,
		OrientationInterpolator:      OrientationInterpolator,
		PositionInterpolator:         PositionInterpolator,
		PositionInterpolator2D:       PositionInterpolator2D,
		ScalarInterpolator:           ScalarInterpolator,
		SplinePositionInterpolator:   SplinePositionInterpolator,
		SplinePositionInterpolator2D: SplinePositionInterpolator2D,
		SplineScalarInterpolator:     SplineScalarInterpolator,
		SquadOrientationInterpolator: SquadOrientationInterpolator,
	};

	var AbstractTypes =
	{
		X3DInterpolatorNode: X3DInterpolatorNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Layering',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Layering/Layer",
	"x_ite/Components/Layering/LayerSet",
	"x_ite/Components/Layering/Viewport",
	"x_ite/Components/Layering/X3DLayerNode",
	"x_ite/Components/Layering/X3DViewportNode",
],
function (SupportedNodes,
          Layer,
          LayerSet,
          Viewport,
          X3DLayerNode,
          X3DViewportNode)
{
"use strict";

	var Types =
	{
		Layer:    Layer,
		LayerSet: LayerSet,
		Viewport: Viewport,
	};

	var AbstractTypes =
	{
		X3DLayerNode:    X3DLayerNode,
		X3DViewportNode: X3DViewportNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting/PointLight',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Lighting/X3DLightNode",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Box3",
	"standard/Math/Geometry/Camera",
	"standard/Math/Geometry/ViewVolume",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Utility/MatrixStack",
	"standard/Math/Algorithm",
	"standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLightNode, 
          X3DGroupingNode, 
          TraverseType,
          X3DConstants,
          Box3,
          Camera,
          ViewVolume,
          Vector3,
          Vector4,
          Rotation4,
          Matrix3,
          Matrix4,
          MatrixStack,
          Algorithm,
          ObjectCache)
{
"use strict";

	// Shadow map layout
	// Compact layout:
	//
	// xzXZ		Char: Axis
	// yyYY		Case: Sign

	var orientationMatrices = [
		new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 1,  0,  0), Vector3 .zAxis)), // left
		new Matrix4 () .setRotation (new Rotation4 (new Vector3 (-1,  0,  0), Vector3 .zAxis)), // right
		new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 0,  0, -1), Vector3 .zAxis)), // front
		new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 0,  0,  1), Vector3 .zAxis)), // back
		new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 0,  1,  0), Vector3 .zAxis)), // bottom
		new Matrix4 () .setRotation (new Rotation4 (new Vector3 ( 0, -1,  0), Vector3 .zAxis)), // top
	];

	var viewports = [
		new Vector4 (0,    0.5, 0.25, 0.5), // left
		new Vector4 (0.5,  0.5, 0.25, 0.5), // right
		new Vector4 (0.75, 0.5, 0.25, 0.5), // front
		new Vector4 (0.25, 0.5, 0.25, 0.5), // back
		new Vector4 (0.0,  0,   0.5,  0.5), // bottom
		new Vector4 (0.5,  0,   0.5,  0.5), // top   
	];

	var PointLights = ObjectCache (PointLightContainer);
	
	function PointLightContainer ()
	{
		this .location                      = new Vector3 (0, 0, 0);
		this .matrixArray                   = new Float32Array (9);
		this .shadowBuffer                  = null;
		this .viewVolume                    = new ViewVolume ();
		this .viewport                      = new Vector4 (0, 0, 0, 0);
		this .projectionMatrix              = new Matrix4 ();
		this .modelViewMatrix               = new MatrixStack (Matrix4);
		this .modelMatrix                   = new Matrix4 ();
		this .invLightSpaceMatrix           = new Matrix4 ();
		this .invLightSpaceProjectionMatrix = new Matrix4 ();
		this .shadowMatrix                  = new Matrix4 ();
		this .shadowMatrixArray             = new Float32Array (16);
		this .rotation                      = new Rotation4 ();
		this .rotationMatrix                = new Matrix4 ();
		this .textureUnit                   = 0;
	}

	PointLightContainer .prototype =
	{
		constructor: PointLightContainer,
		getModelViewMatrix: function ()
		{
			return this .modelViewMatrix;
		},
	   set: function (browser, lightNode, groupNode, modelViewMatrix)
	   {
			var
				gl            = browser .getContext (),
				shadowMapSize = lightNode .getShadowMapSize ();

			this .browser   = browser;
			this .lightNode = lightNode;
			this .groupNode = groupNode;

			try
			{
				this .matrixArray .set (modelViewMatrix .submatrix .inverse ());
			}
			catch (error)
			{
				this .matrixArray .set (Matrix3 .Identity);
			}

			this .modelViewMatrix .pushMatrix (modelViewMatrix);

			// Get shadow buffer from browser.

			if (lightNode .getShadowIntensity () > 0 && shadowMapSize > 0)
			{
				this .shadowBuffer = browser .popShadowBuffer (shadowMapSize);

				if (this .shadowBuffer)
				{
					if (browser .getCombinedTextureUnits () .length)
					{
						this .textureUnit = browser .getCombinedTextureUnits () .pop ();

						gl .activeTexture (gl .TEXTURE0 + this .textureUnit);

						if (gl .getVersion () >= 2 || browser .getExtension ("WEBGL_depth_texture"))
							gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getDepthTexture ());
						else
							gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getColorTexture ());

						gl .activeTexture (gl .TEXTURE0);
					}
					else
					{
						console .warn ("Not enough combined texture units for shadow map available.");
					}
				}
				else
				{
					console .warn ("Couldn't create shadow buffer.");
				}
			}
	   },
		renderShadowMap: function (renderObject)
		{
			try
			{
				if (! this .shadowBuffer)
					return;

				var
					lightNode           = this .lightNode,
					cameraSpaceMatrix   = renderObject .getCameraSpaceMatrix () .get (),
					modelMatrix         = this .modelMatrix .assign (this .modelViewMatrix .get ()) .multRight (cameraSpaceMatrix),
					invLightSpaceMatrix = this .invLightSpaceMatrix .assign (lightNode .getGlobal () ? modelMatrix : Matrix4 .Identity);

				invLightSpaceMatrix .translate (lightNode .getLocation ());
				invLightSpaceMatrix .inverse ();

				var shadowMapSize  = lightNode .getShadowMapSize ();

				this .shadowBuffer .bind ();

				for (var i = 0; i < 6; ++ i)
				{
					var
						v                = viewports [i],
						viewport         = this .viewport .set (v [0] * shadowMapSize, v [1] * shadowMapSize, v [2] * shadowMapSize, v [3] * shadowMapSize),
						projectionMatrix = Camera .perspective2 (Algorithm .radians (90), 0.125, 10000, viewport [2], viewport [3], this .projectionMatrix); // Use higher far value for better precision.

					renderObject .getViewVolumes      () .push (this .viewVolume .set (projectionMatrix, viewport, viewport));
					renderObject .getProjectionMatrix () .pushMatrix (this .projectionMatrix);
					renderObject .getModelViewMatrix  () .pushMatrix (orientationMatrices [i]);
					renderObject .getModelViewMatrix  () .multLeft (invLightSpaceMatrix);
	
					renderObject .render (TraverseType .DEPTH, X3DGroupingNode .prototype .traverse, this .groupNode);
	
					renderObject .getModelViewMatrix  () .pop ();
					renderObject .getProjectionMatrix () .pop ();
					renderObject .getViewVolumes () .pop ();
				}

				this .shadowBuffer .unbind ();
	
				if (! lightNode .getGlobal ())
					invLightSpaceMatrix .multLeft (modelMatrix .inverse ());

				this .invLightSpaceProjectionMatrix .assign (invLightSpaceMatrix);
			}
			catch (error)
			{
				// Catch error from matrix inverse.
				console .log (error);
			}
		},
		setGlobalVariables: function (renderObject)
		{
			this .modelViewMatrix .get () .multVecMatrix (this .location .assign (this .lightNode .location_ .getValue ()));

			this .shadowMatrix .assign (renderObject .getCameraSpaceMatrix () .get ()) .multRight (this .invLightSpaceProjectionMatrix);
			this .shadowMatrixArray .set (this .shadowMatrix);
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			var i = shaderObject .numLights ++;

			if (shaderObject .hasLight (i, this))
				return;

			var 
				lightNode   = this .lightNode,
				color       = lightNode .getColor (),
				attenuation = lightNode .getAttenuation (),
				location    = this .location;

			gl .uniform1i        (shaderObject .x3d_LightType [i],             2);
			gl .uniform3f        (shaderObject .x3d_LightColor [i],            color .r, color .g, color .b);
			gl .uniform1f        (shaderObject .x3d_LightIntensity [i],        lightNode .getIntensity ());
			gl .uniform1f        (shaderObject .x3d_LightAmbientIntensity [i], lightNode .getAmbientIntensity ());
			gl .uniform3f        (shaderObject .x3d_LightAttenuation [i],      Math .max (0, attenuation .x), Math .max (0, attenuation .y), Math .max (0, attenuation .z));
			gl .uniform3f        (shaderObject .x3d_LightLocation [i],         location .x, location .y, location .z);
			gl .uniform1f        (shaderObject .x3d_LightRadius [i],           lightNode .getRadius ());
			gl .uniformMatrix3fv (shaderObject .x3d_LightMatrix [i], false,    this .matrixArray);

			if (this .textureUnit)
			{
				var shadowColor = lightNode .getShadowColor ();

				gl .uniform3f        (shaderObject .x3d_ShadowColor [i],         shadowColor .r, shadowColor .g, shadowColor .b);
				gl .uniform1f        (shaderObject .x3d_ShadowIntensity [i],     lightNode .getShadowIntensity ());
				gl .uniform1f        (shaderObject .x3d_ShadowBias [i],          lightNode .getShadowBias ());
				gl .uniformMatrix4fv (shaderObject .x3d_ShadowMatrix [i], false, this .shadowMatrixArray);
				gl .uniform1i        (shaderObject .x3d_ShadowMapSize [i],       lightNode .getShadowMapSize ());
				gl .uniform1i        (shaderObject .x3d_ShadowMap [i],           this .textureUnit);
			}
			else
			{
				// Must be set to zero in case of multiple lights.
				gl .uniform1f (shaderObject .x3d_ShadowIntensity [i], 0);			
			}
		},
		dispose: function ()
		{
			// Return shadowBuffer and textureUnit.

			if (this .textureUnit)
				this .browser .getCombinedTextureUnits () .push (this .textureUnit);

			this .browser .pushShadowBuffer (this .shadowBuffer);
			this .modelViewMatrix .clear ();

			this .browser      = null;
			this .lightNode    = null;
			this .groupNode    = null;
			this .shadowBuffer = null;
			this .textureUnit  = 0;

			// Return container

		   PointLights .push (this);
		},
	};

	function PointLight (executionContext)
	{
		X3DLightNode .call (this, executionContext);

		this .addType (X3DConstants .PointLight);

		this .location_ .setUnit ("length");
		this .radius_   .setUnit ("length");
	}

	PointLight .prototype = Object .assign (Object .create (X3DLightNode .prototype),
	{
		constructor: PointLight,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "global",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "on",               new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",            new Fields .SFColor (1, 1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "intensity",        new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "ambientIntensity", new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attenuation",      new Fields .SFVec3f (1, 0, 0)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "location",         new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "radius",           new Fields .SFFloat (100)),
																				   
			new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowColor",     new  Fields .SFColor ()),        // Color of shadow.
			new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowIntensity", new  Fields .SFFloat ()),        // Intensity of shadow color in the range (0, 1).
			new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowBias",      new  Fields .SFFloat (0.005)),   // Bias of the shadow.
			new X3DFieldDefinition (X3DConstants .initializeOnly, "shadowMapSize",   new  Fields .SFInt32 (1024)),    // Size of the shadow map in pixels in the range (0, inf).
		]),
		getTypeName: function ()
		{
			return "PointLight";
		},
		getComponentName: function ()
		{
			return "Lighting";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getAttenuation: function ()
		{
			return this .attenuation_ .getValue ();
		},
		getLocation: function ()
		{
			return this .location_ .getValue ();
		},
		getRadius: function ()
		{
			return Math .max (0, this .radius_ .getValue ());
		},
		getLights: function ()
		{
			return PointLights;
		},
	});

	return PointLight;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting/SpotLight',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Lighting/X3DLightNode",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Box3",
	"standard/Math/Geometry/Camera",
	"standard/Math/Geometry/ViewVolume",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Utility/MatrixStack",
	"standard/Math/Algorithm",
	"standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLightNode, 
          X3DGroupingNode, 
          TraverseType,
          X3DConstants,
          Box3,
          Camera,
          ViewVolume,
          Vector3,
          Vector4,
          Rotation4,
          Matrix3,
          Matrix4,
          MatrixStack,
          Algorithm,
          ObjectCache)
{
"use strict";

	var SpotLights = ObjectCache (SpotLightContainer);
	
	function SpotLightContainer ()
	{
		this .location                      = new Vector3 (0, 0, 0);
		this .direction                     = new Vector3 (0, 0, 0);
		this .matrixArray                   = new Float32Array (9);
		this .renderShadow                  = true; 
		this .shadowBuffer                  = null;
		this .bbox                          = new Box3 ();
		this .viewVolume                    = new ViewVolume ();
		this .viewport                      = new Vector4 (0, 0, 0, 0);
		this .projectionMatrix              = new Matrix4 ();
		this .modelViewMatrix               = new MatrixStack (Matrix4);
		this .modelMatrix                   = new Matrix4 ();
		this .invLightSpaceMatrix           = new Matrix4 ();
		this .invLightSpaceProjectionMatrix = new Matrix4 ();
		this .shadowMatrix                  = new Matrix4 ();
		this .shadowMatrixArray             = new Float32Array (16);
		this .rotation                      = new Rotation4 ();
		this .lightBBoxMin                  = new Vector3 (0, 0, 0);
		this .lightBBoxMax                  = new Vector3 (0, 0, 0);
		this .textureUnit                   = 0;
	}

	SpotLightContainer .prototype =
	{
		constructor: SpotLightContainer,
		getModelViewMatrix: function ()
		{
			return this .modelViewMatrix;
		},
	   set: function (browser, lightNode, groupNode, modelViewMatrix)
	   {
			var
				gl            = browser .getContext (),
				shadowMapSize = lightNode .getShadowMapSize ();

			this .browser   = browser;
			this .lightNode = lightNode;
			this .groupNode = groupNode;

			try
			{
				this .matrixArray .set (modelViewMatrix .submatrix .inverse ());
			}
			catch (error)
			{
				this .matrixArray .set (Matrix3 .Identity);
			}

			this .modelViewMatrix .pushMatrix (modelViewMatrix);

			// Get shadow buffer from browser.

			if (lightNode .getShadowIntensity () > 0 && shadowMapSize > 0)
			{
				this .shadowBuffer = browser .popShadowBuffer (shadowMapSize);

				if (this .shadowBuffer)
				{
					if (browser .getCombinedTextureUnits () .length)
					{
						this .textureUnit = browser .getCombinedTextureUnits () .pop ();

						gl .activeTexture (gl .TEXTURE0 + this .textureUnit);

						if (gl .getVersion () >= 2 || browser .getExtension ("WEBGL_depth_texture"))
							gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getDepthTexture ());
						else
							gl .bindTexture (gl .TEXTURE_2D, this .shadowBuffer .getColorTexture ());

						gl .activeTexture (gl .TEXTURE0);
					}
					else
					{
						console .warn ("Not enough combined texture units for shadow map available.");
					}
				}
				else
				{
					console .warn ("Couldn't create shadow buffer.");
				}
			}
	   },
		renderShadowMap: function (renderObject)
		{
			try
			{
				if (! this .shadowBuffer)
					return;

				var
					lightNode            = this .lightNode,
					cameraSpaceMatrix    = renderObject .getCameraSpaceMatrix () .get (),
					modelMatrix          = this .modelMatrix .assign (this .modelViewMatrix .get ()) .multRight (cameraSpaceMatrix),
					invLightSpaceMatrix  = this .invLightSpaceMatrix .assign (lightNode .getGlobal () ? modelMatrix : Matrix4 .Identity);

				invLightSpaceMatrix .translate (lightNode .getLocation ());
				invLightSpaceMatrix .rotate (this .rotation .setFromToVec (Vector3 .zAxis, this .direction .assign (lightNode .getDirection ()) .negate ()));
				invLightSpaceMatrix .inverse ();

				var
					groupBBox        = X3DGroupingNode .prototype .getBBox .call (this .groupNode, this .bbox), // Group bbox.
					lightBBox        = groupBBox .multRight (invLightSpaceMatrix),                              // Group bbox from the perspective of the light.
					lightBBoxExtents = lightBBox .getExtents (this .lightBBoxMin, this .lightBBoxMax),          // Result not used, but arguments.
					shadowMapSize    = lightNode .getShadowMapSize (),
					farValue         = Math .min (lightNode .getRadius (), -this .lightBBoxMin .z),
					viewport         = this .viewport .set (0, 0, shadowMapSize, shadowMapSize),
					projectionMatrix = Camera .perspective (lightNode .getCutOffAngle () * 2, 0.125, Math .max (10000, farValue), shadowMapSize, shadowMapSize, this .projectionMatrix); // Use higher far value for better precision.

				this .renderShadow = farValue > 0;

				this .shadowBuffer .bind ();

				renderObject .getViewVolumes      () .push (this .viewVolume .set (projectionMatrix, viewport, viewport));
				renderObject .getProjectionMatrix () .pushMatrix (projectionMatrix);
				renderObject .getModelViewMatrix  () .pushMatrix (invLightSpaceMatrix);

				renderObject .render (TraverseType .DEPTH, X3DGroupingNode .prototype .traverse, this .groupNode);

				renderObject .getModelViewMatrix  () .pop ();
				renderObject .getProjectionMatrix () .pop ();
				renderObject .getViewVolumes      () .pop ();

				this .shadowBuffer .unbind ();
	
				if (! lightNode .getGlobal ())
					invLightSpaceMatrix .multLeft (modelMatrix .inverse ());

				this .invLightSpaceProjectionMatrix .assign (invLightSpaceMatrix) .multRight (projectionMatrix) .multRight (lightNode .getBiasMatrix ());
			}
			catch (error)
			{
				// Catch error from matrix inverse.
				console .log (error);
			}
		},
		setGlobalVariables: function (renderObject)
		{
			var 
				lightNode       = this .lightNode,
				modelViewMatrix = this .modelViewMatrix .get ();

			modelViewMatrix .multVecMatrix (this .location  .assign (lightNode .location_  .getValue ()));
			modelViewMatrix .multDirMatrix (this .direction .assign (lightNode .direction_ .getValue ())) .normalize ();

			this .shadowMatrix .assign (renderObject .getCameraSpaceMatrix () .get ()) .multRight (this .invLightSpaceProjectionMatrix);
			this .shadowMatrixArray .set (this .shadowMatrix);
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			var i = shaderObject .numLights ++;

			if (shaderObject .hasLight (i, this))
				return;

			var 
				lightNode   = this .lightNode,
				color       = lightNode .getColor (),
				attenuation = lightNode .getAttenuation (),
				location    = this .location,
				direction   = this .direction;

			gl .uniform1i        (shaderObject .x3d_LightType [i],             3);
			gl .uniform3f        (shaderObject .x3d_LightColor [i],            color .r, color .g, color .b);
			gl .uniform1f        (shaderObject .x3d_LightIntensity [i],        lightNode .getIntensity ());
			gl .uniform1f        (shaderObject .x3d_LightAmbientIntensity [i], lightNode .getAmbientIntensity ());
			gl .uniform3f        (shaderObject .x3d_LightAttenuation [i],      Math .max (0, attenuation .x), Math .max (0, attenuation .y), Math .max (0, attenuation .z));
			gl .uniform3f        (shaderObject .x3d_LightLocation [i],         location .x, location .y, location .z);
			gl .uniform3f        (shaderObject .x3d_LightDirection [i],        direction .x, direction .y, direction .z);
			gl .uniform1f        (shaderObject .x3d_LightRadius [i],           lightNode .getRadius ());
			gl .uniform1f        (shaderObject .x3d_LightBeamWidth [i],        lightNode .getBeamWidth ());
			gl .uniform1f        (shaderObject .x3d_LightCutOffAngle [i],      lightNode .getCutOffAngle ());
			gl .uniformMatrix3fv (shaderObject .x3d_LightMatrix [i], false,    this .matrixArray);

			if (this .renderShadow && this .textureUnit)
			{
				var shadowColor = lightNode .getShadowColor ();

				gl .uniform3f        (shaderObject .x3d_ShadowColor [i],         shadowColor .r, shadowColor .g, shadowColor .b);
				gl .uniform1f        (shaderObject .x3d_ShadowIntensity [i],     lightNode .getShadowIntensity ());
				gl .uniform1f        (shaderObject .x3d_ShadowBias [i],          lightNode .getShadowBias ());
				gl .uniformMatrix4fv (shaderObject .x3d_ShadowMatrix [i], false, this .shadowMatrixArray);
				gl .uniform1i        (shaderObject .x3d_ShadowMapSize [i],       lightNode .getShadowMapSize ());
				gl .uniform1i        (shaderObject .x3d_ShadowMap [i],           this .textureUnit);
			}
			else
			{
				// Must be set to zero in case of multiple lights.
				gl .uniform1f (shaderObject .x3d_ShadowIntensity [i], 0);			
			}
		},
		dispose: function ()
		{
			// Return shadowBuffer and textureUnit.

			if (this .textureUnit)
				this .browser .getCombinedTextureUnits () .push (this .textureUnit);

			this .browser .pushShadowBuffer (this .shadowBuffer);
			this .modelViewMatrix .clear ();

			this .browser      = null;
			this .lightNode    = null;
			this .groupNode    = null;
			this .shadowBuffer = null;
			this .textureUnit  = 0;

			// Return container

		   SpotLights .push (this);
		},
	};

	function SpotLight (executionContext)
	{
		X3DLightNode .call (this, executionContext);

		this .addType (X3DConstants .SpotLight);

		this .location_    .setUnit ("length");
		this .radius_      .setUnit ("length");
		this .beamWidth_   .setUnit ("angle");
		this .cutOffAngle_ .setUnit ("angle");
	}

	SpotLight .prototype = Object .assign (Object .create (X3DLightNode .prototype),
	{
		constructor: SpotLight,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "global",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "on",               new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",            new Fields .SFColor (1, 1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "intensity",        new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "ambientIntensity", new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attenuation",      new Fields .SFVec3f (1, 0, 0)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "location",         new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "direction",        new Fields .SFVec3f (0, 0, -1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "radius",           new Fields .SFFloat (100)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "beamWidth",        new Fields .SFFloat (0.785398)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "cutOffAngle",      new Fields .SFFloat (1.5708)),
																				   
			new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowColor",     new  Fields .SFColor ()),        // Color of shadow.
			new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowIntensity", new  Fields .SFFloat ()),        // Intensity of shadow color in the range (0, 1).
			new X3DFieldDefinition (X3DConstants .inputOutput,    "shadowBias",      new  Fields .SFFloat (0.005)),   // Bias of the shadow.
			new X3DFieldDefinition (X3DConstants .initializeOnly, "shadowMapSize",   new  Fields .SFInt32 (1024)),    // Size of the shadow map in pixels in the range (0, inf).
		]),
		getTypeName: function ()
		{
			return "SpotLight";
		},
		getComponentName: function ()
		{
			return "Lighting";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getAttenuation: function ()
		{
			return this .attenuation_ .getValue ();
		},
		getLocation: function ()
		{
			return this .location_ .getValue ();
		},
		getRadius: function ()
		{
			return Math .max (0, this .radius_ .getValue ());
		},
		getBeamWidth: function ()
		{
			// If the beamWidth is greater than the cutOffAngle, beamWidth is defined to be equal to the cutOffAngle.

			var
				beamWidth   = this .beamWidth_ .getValue (),
				cutOffAngle = this .getCutOffAngle ();

			if (beamWidth > cutOffAngle)
				return cutOffAngle;

			return Algorithm .clamp (beamWidth, 0, Math .PI / 2);
		},
		getCutOffAngle: function ()
		{
			return Algorithm .clamp (this .cutOffAngle_ .getValue (), 0, Math .PI / 2);
		},
		getLights: function ()
		{
			return SpotLights;
		},
	});

	return SpotLight;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Lighting',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Lighting/DirectionalLight",
	"x_ite/Components/Lighting/PointLight",
	"x_ite/Components/Lighting/SpotLight",
	"x_ite/Components/Lighting/X3DLightNode",
],
function (SupportedNodes,
          DirectionalLight,
          PointLight,
          SpotLight,
          X3DLightNode)
{
"use strict";

	var Types =
	{
		DirectionalLight: DirectionalLight,
		PointLight:       PointLight,
		SpotLight:        SpotLight,
	};

	var AbstractTypes =
	{
		X3DLightNode: X3DLightNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/Billboard',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Bits/TraverseType",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode, 
          X3DConstants,
          TraverseType,
          Vector3,
          Rotation4,
          Matrix4)
{
"use strict";

	var
	   inverseModelViewMatrix = new Matrix4 (),
		yAxis                  = new Vector3 (0, 1, 0),
		zAxis                  = new Vector3 (0, 0, 1),
		viewerYAxis            = new Vector3 (0, 0, 0),
		x                      = new Vector3 (0, 0, 0),
		y                      = new Vector3 (0, 0, 0),
		N1                     = new Vector3 (0, 0, 0),
		N2                     = new Vector3 (0, 0, 0),
		rotation               = new Rotation4 (0, 0, 1, 0);

	function Billboard (executionContext)
	{
		X3DGroupingNode .call (this, executionContext);

		this .addType (X3DConstants .Billboard);
		
		this .matrix = new Matrix4 ();
	}

	Billboard .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
	{
		constructor: Billboard,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "axisOfRotation", new Fields .SFVec3f (0, 1, 0)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "Billboard";
		},
		getComponentName: function ()
		{
			return "Navigation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		getBBox: function (bbox)
		{
			return X3DGroupingNode .prototype .getBBox .call (this, bbox) .multRight (this .matrix);
		},
		getMatrix: function ()
		{
			return this .matrix;
		},
		rotate: function (modelViewMatrix)
		{
			// throws domain error

			inverseModelViewMatrix .assign (modelViewMatrix) .inverse ();

			var billboardToViewer = inverseModelViewMatrix .origin .normalize (); // Normalized to get work with Geo

			if (this .axisOfRotation_ .getValue () .equals (Vector3 .Zero))
			{
				inverseModelViewMatrix .multDirMatrix (viewerYAxis .assign (yAxis)) .normalize (); // Normalized to get work with Geo

				x .assign (viewerYAxis) .cross (billboardToViewer);
				y .assign (billboardToViewer) .cross (x);
				var z = billboardToViewer;

				// Compose rotation

				x .normalize ();
				y .normalize ();

				this .matrix .set (x [0], x [1], x [2], 0,
				                   y [0], y [1], y [2], 0,
				                   z [0], z [1], z [2], 0,
				                   0,     0,     0,     1);
			}
			else
			{
				N1 .assign (this .axisOfRotation_ .getValue ()) .cross (billboardToViewer); // Normal vector of plane as in specification
				N2 .assign (this .axisOfRotation_ .getValue ()) .cross (zAxis);             // Normal vector of plane between axisOfRotation and zAxis

				this .matrix .setRotation (rotation .setFromToVec (N2, N1));                // Rotate zAxis in plane
			}

			return this .matrix;
		},
		traverse: function (type, renderObject)
		{
			var modelViewMatrix = renderObject .getModelViewMatrix ();

			modelViewMatrix .push ();

			try
			{
				switch (type)
				{
					case TraverseType .CAMERA:
					case TraverseType .PICKING:
					case TraverseType .DEPTH:
						// No clone support for shadow, generated cube map texture, and bbox
						modelViewMatrix .multLeft (this .matrix);
						break;
					default:
						modelViewMatrix .multLeft (this .rotate (modelViewMatrix .get ()));
						break;
				}

				X3DGroupingNode .prototype .traverse .call (this, type, renderObject);
			}
			catch (error)
			{
				console .log (error);
			}

			modelViewMatrix .pop ();
		},
	});

	return Billboard;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/Collision',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Components/Core/X3DSensorNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode, 
          X3DSensorNode,
          X3DCast,
          TraverseType,
          X3DConstants)
{
"use strict";

	function Collision (executionContext)
	{
		X3DGroupingNode .call (this, executionContext);
		X3DSensorNode   .call (this, executionContext);

		this .addType (X3DConstants .Collision);

		if (executionContext .getSpecificationVersion () == "2.0")
			this .addAlias ("collide", this .enabled_); // VRML2
	}

	Collision .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
		X3DSensorNode .prototype,
	{
		constructor: Collision,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "enabled",        new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",       new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "collideTime",    new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "proxy",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "Collision";
		},
		getComponentName: function ()
		{
			return "Navigation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DGroupingNode .prototype .initialize .call (this);
			//X3DSensorNode   .prototype .initialize .call (this); // We can only call the base of a *Objects.
	
			this .isLive () .addInterest ("set_live__", this);
			this .enabled_  .addInterest ("set_live__", this);
			this .proxy_    .addInterest ("set_proxy__", this);

			this .set_live__ ();
			this .set_proxy__ ();
		},
		set_live__: function ()
		{
		   if (this .isLive () .getValue () && this .enabled_ .getValue ())
		      this .getBrowser () .addCollision (this);
		   
		   else
		      this .getBrowser () .removeCollision (this);
		},
		set_active: function (value)
		{
			if (this .isActive_ .getValue () !== value)
			{
				this .isActive_ = value;

				if (value)
					this .collideTime_ = this .getBrowser () .getCurrentTime ();
			}
		},
		set_proxy__: function ()
		{
		   this .proxyNode = X3DCast (X3DConstants .X3DChildNode, this .proxy_);
		},
		traverse: function (type, renderObject)
		{
			switch (type)
			{
				case TraverseType .COLLISION:
				{
					if (this .enabled_ .getValue ())
					{
					   var collisions = renderObject .getCollisions ();

						collisions .push (this);

						if (this .proxyNode)
							this .proxyNode .traverse (type, renderObject);

						else
							X3DGroupingNode .prototype .traverse .call (this, type, renderObject);

						collisions .pop ();
					}

					return;
				}
				default:
				{
					X3DGroupingNode .prototype .traverse .call (this, type, renderObject);
					return;
				}
			}
		},
	});

	return Collision;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/LOD',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Box3",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode,
          X3DCast,
          TraverseType,
          X3DConstants,
          Matrix4,
          Box3,
          Algorithm)
{
"use strict";

	function LOD (executionContext)
	{
		X3DGroupingNode .call (this, executionContext);

		this .addType (X3DConstants .LOD);

		if (executionContext .getSpecificationVersion () == "2.0")
			this .addAlias ("level", this .children_); // VRML2

		this .center_ .setUnit ("length");
		this .range_  .setUnit ("length");

		this .frameRate        = 60;
		this .keepCurrentLevel = false;
	}

	LOD .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
	{
		constructor: LOD,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "forceTransitions", new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "center",           new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "range",            new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "level_changed",    new Fields .SFInt32 (-1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",         new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",       new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",      new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren",   new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "children",         new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "LOD";
		},
		getComponentName: function ()
		{
			return "Navigation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DGroupingNode .prototype .initialize .call (this);

			this .child = this .getChild (this .level_changed_ .getValue ());
			this .set_cameraObjects__ ();
		},
		getBBox: function (bbox)
		{
			if (this .bboxSize_ .getValue () .equals (this .getDefaultBBoxSize ()))
			{
				var boundedObject = X3DCast (X3DConstants .X3DBoundedObject, this .child);

				if (boundedObject)
					return boundedObject .getBBox (bbox);

				return bbox .set ();
			}

			return bbox .set (this .bboxSize_ .getValue (), this .bboxCenter_ .getValue ());
		},
		getSubBBox: function (bbox)
		{
			return this .getBBox (bbox);
		},
		set_cameraObjects__: function ()
		{
			if (this .child && this .child .getCameraObject)
				this .setCameraObject (this .child .getCameraObject ());
			else
				this .setCameraObject (false);
		},
		set_pickableObjects__: function ()
		{
			if (this .getTransformSensors () .size)
				this .setPickableObject (true);
			else if (this .child && this .child .getPickableObject)
				this .setPickableObject (this .child .getPickableObject ());
			else
				this .setPickableObject (false);
		},
		getLevel: (function ()
		{
			var
				FRAMES         = 180, // Number of frames after wich a level change takes in affect.
				FRAME_RATE_MIN = 20,  // Lowest level of detail.
				FRAME_RATE_MAX = 55;  // Highest level of detail.

			return function (browser, modelViewMatrix)
			{
				if (this .range_ .length === 0)
				{
					var size = this .children_ .length;

					if (size < 2)
						return 0;

					this .frameRate = ((FRAMES - 1) * this .frameRate + browser .currentFrameRate) / FRAMES;

					if (size === 2)
						return (this .frameRate > FRAME_RATE_MAX) * 1;

					var fraction = 1 - Algorithm .clamp ((this .frameRate - FRAME_RATE_MIN) / (FRAME_RATE_MAX - FRAME_RATE_MIN), 0, 1);

					return Math .min (Math .floor (fraction * size), size - 1);
				}

				var distance = this .getDistance (modelViewMatrix);

				return Algorithm .upperBound (this .range_, 0, this .range_ .length, distance, Algorithm .less);
			};
		})(),
		getDistance: function (modelViewMatrix)
		{
			modelViewMatrix .translate (this .center_ .getValue ());

			return modelViewMatrix .origin .abs ();
		},
		traverse: (function ()
		{
			var
				modelViewMatrix = new Matrix4 (),
				bbox            = new Box3 ();

			return function (type, renderObject)
			{
				var child = this .child;

				switch (type)
				{
					case TraverseType .PICKING:
					{
						if (this .getTransformSensors () .size)
						{
							this .getSubBBox (bbox) .multRight (renderObject .getModelViewMatrix () .get ());

							this .getTransformSensors () .forEach (function (transformSensorNode)
							{
								transformSensorNode .collect (bbox);
							});
						}

						if (child)
						{
							var
								browser          = renderObject .getBrowser (),
								pickingHierarchy = browser .getPickingHierarchy ();

							pickingHierarchy .push (this);

							child .traverse (type, renderObject);

							pickingHierarchy .pop ();
						}

						return;
					}
					case TraverseType .DISPLAY:
					{
						if (! this .keepCurrentLevel)
						{
							var
								level        = this .getLevel (renderObject .getBrowser (), modelViewMatrix .assign (renderObject .getModelViewMatrix () .get ())),
								currentLevel = this .level_changed_ .getValue ();

							if (this .forceTransitions_ .getValue ())
							{
								if (level > currentLevel)
									level = currentLevel + 1;

								else if (level < currentLevel)
									level = currentLevel - 1;
							}

							if (level !== currentLevel)
							{
								this .level_changed_ = level;

								child = this .child = this .getChild (Math .min (level, this .children_ .length - 1));

								this .set_cameraObjects__ ();
							}
						}

						if (child)
							child .traverse (type, renderObject);

						return;
					}
					default:
					{
						if (child)
							child .traverse (type, renderObject);

						return;
					}
				}
			};
		})(),
	});

	return LOD;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation/ViewpointGroup',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Components/EnvironmentalSensor/ProximitySensor",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode,
          ProximitySensor,
          TraverseType,
          X3DConstants,
          Vector3)
{
"use strict";

	function ViewpointGroup (executionContext)
	{
		X3DChildNode .call (this, executionContext);

		this .addType (X3DConstants .ViewpointGroup);

		this .size_   .setUnit ("length");
		this .center_ .setUnit ("length");

		this .proximitySensor  = new ProximitySensor (executionContext);
		this .cameraObjects    = [ ];
		this .viewpointGroups  = [ ];
	}

	ViewpointGroup .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: ViewpointGroup,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "description",       new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "displayed",         new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "retainUserOffsets", new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "size",              new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "center",            new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "children",          new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "ViewpointGroup";
		},
		getComponentName: function ()
		{
			return "Navigation";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DChildNode .prototype .initialize .call (this);
		   
			this .proximitySensor .setup ();

			this .size_   .addFieldInterest (this .proximitySensor .size_);
			this .center_ .addFieldInterest (this .proximitySensor .center_);

			this .proximitySensor .size_   = this .size_;
			this .proximitySensor .center_ = this .center_;

			this .displayed_ .addInterest ("set_displayed__", this);
			this .size_      .addInterest ("set_displayed__", this);
			this .children_  .addInterest ("set_children__", this);

			this .set_displayed__ ();
			this .set_children__ ();
		},
		isActive: function ()
		{
		   return this .proximitySensor .isActive_ .getValue ();
		},
		set_displayed__: function ()
		{
			var
				proxy     = ! this .size_ .getValue () .equals (Vector3 .Zero),
				displayed = this .displayed_ .getValue ();

			this .proximitySensor .enabled_ = displayed && proxy;

			if (displayed && proxy)
			{
				this .proximitySensor .isCameraObject_   .addFieldInterest (this .isCameraObject_);
				this .proximitySensor .isPickableObject_ .addFieldInterest (this .isPickableObject_);

				this .setCameraObject   (this .proximitySensor .getCameraObject ());
				this .setPickableObject (this .proximitySensor .getPickableObject ());

				this .traverse = traverseWithProximitySensor;
			}
			else
			{
				this .proximitySensor .isCameraObject_    .removeFieldInterest (this .isCameraObject_);
				this .proximitySensor .isPickableObject_ .removeFieldInterest (this .isPickableObject_);

				this .setCameraObject   (displayed);
				this .setPickableObject (false);

				if (displayed)
					this .traverse = traverse;
				else
					delete this .traverse;
			}
		},
		set_children__: function ()
		{
			this .cameraObjects   .length = 0;
			this .viewpointGroups .length = 0;

			var children = this .children_;

			for (var i = 0, length = children .length; i < length; ++ i)
			{
				try
				{
					var
						innerNode = children [i] .getValue () .getInnerNode (),
						type      = innerNode .getType ();

					for (var t = type .length - 1; t >= 0; -- t)
					{
						switch (type [t])
						{
							case X3DConstants .X3DViewpointNode:
							{
								this .cameraObjects .push (innerNode);
								break;
							}
							case X3DConstants .ViewpointGroup:
							{
								this .cameraObjects   .push (innerNode);
								this .viewpointGroups .push (innerNode);
								break;
							}
						}
					}
				}
				catch (error)
				{ }
			}
		},
		traverse: function () { },
	});

	function traverseWithProximitySensor (type, renderObject)
	{
		switch (type)
		{
			case TraverseType .CAMERA:
			{
				this .proximitySensor .traverse (type, renderObject);
		
				if (this .proximitySensor .isActive_ .getValue ())
				{
					for (var i = 0, length = this .cameraObjects .length; i < length; ++ i)
						this .cameraObjects [i] .traverse (type, renderObject);
				}

				return;
			}
			case TraverseType .DISPLAY:
			{
				this .proximitySensor .traverse (type, renderObject);
		
				if (this .proximitySensor .isActive_ .getValue ())
				{
					for (var i = 0, length = this .viewpointGroups .length; i < length; ++ i)
						this .viewpointGroups [i] .traverse (type, renderObject);
				}

				return;
			}
		}
	}

	function traverse (type, renderObject)
	{
		switch (type)
		{
			case TraverseType .CAMERA:
			{
				for (var i = 0, length = this .cameraObjects .length; i < length; ++ i)
					this .cameraObjects [i] .traverse (type, renderObject);

				return;
			}
			case TraverseType .DISPLAY:
			{
				for (var i = 0, length = this .viewpointGroups .length; i < length; ++ i)
					this .viewpointGroups [i] .traverse (type, renderObject);

				return;
			}
		}
	}

	return ViewpointGroup;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Navigation',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Navigation/Billboard",
	"x_ite/Components/Navigation/Collision",
	"x_ite/Components/Navigation/LOD",
	"x_ite/Components/Navigation/NavigationInfo",
	"x_ite/Components/Navigation/OrthoViewpoint",
	"x_ite/Components/Navigation/Viewpoint",
	"x_ite/Components/Navigation/ViewpointGroup",
	"x_ite/Components/Navigation/X3DViewpointNode",
],
function (SupportedNodes,
          Billboard,
          Collision,
          LOD,
          NavigationInfo,
          OrthoViewpoint,
          Viewpoint,
          ViewpointGroup,
          X3DViewpointNode)
{
"use strict";

	var Types =
	{
		Billboard:      Billboard,
		Collision:      Collision,
		LOD:            LOD,
		NavigationInfo: NavigationInfo,
		OrthoViewpoint: OrthoViewpoint,
		Viewpoint:      Viewpoint,
		ViewpointGroup: ViewpointGroup,
	};

	var AbstractTypes =
	{
		X3DViewpointNode: X3DViewpointNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/PointingDeviceSensor/PointingDeviceSensorContainer',[
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Matrix4",
],
function (Vector4,
          Matrix4)
{
"use strict";
	
	function PointingDeviceSensorContainer (node, modelViewMatrix, projectionMatrix, viewport)
	{
		this .node             = null;
		this .modelViewMatrix  = new Matrix4 ();
		this .projectionMatrix = new Matrix4 ();
		this .viewport         = new Vector4 (0, 0, 0, 0);

		this .set (node, modelViewMatrix, projectionMatrix, viewport);
	}

	PointingDeviceSensorContainer .prototype =
	{
		set: function (node, modelViewMatrix, projectionMatrix, viewport)
		{
			this .node = node;

			this .modelViewMatrix  .assign (modelViewMatrix);
			this .projectionMatrix .assign (projectionMatrix);
			this .viewport         .assign (viewport);
		},
		set_over__: function (over, hit)
		{
			this .node .set_over__ (over, hit, this .modelViewMatrix, this .projectionMatrix, this .viewport);
		},
		set_active__: function (active, hit)
		{
			this .node .set_active__ (active, hit, this .modelViewMatrix, this .projectionMatrix, this .viewport);
		},
		set_motion__: function (hit)
		{
			this .node .set_motion__ (hit, this .modelViewMatrix, this .projectionMatrix, this .viewport);
		},
	};

	return PointingDeviceSensorContainer;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/X3DPointingDeviceSensorNode',[
	"x_ite/Components/Core/X3DSensorNode",
	"x_ite/Browser/PointingDeviceSensor/PointingDeviceSensorContainer",
	"x_ite/Bits/X3DConstants",
],
function (X3DSensorNode,
          PointingDeviceSensorContainer,
          X3DConstants)
{
"use strict";

	function X3DPointingDeviceSensorNode (executionContext)
	{
		X3DSensorNode .call (this, executionContext);

		this .addType (X3DConstants .X3DPointingDeviceSensorNode);
	}

	X3DPointingDeviceSensorNode .prototype = Object .assign (Object .create (X3DSensorNode .prototype),
	{
		constructor: X3DPointingDeviceSensorNode,
		initialize: function ()
		{
			X3DSensorNode .prototype .initialize .call (this);

			this .enabled_ .addInterest ("set_enabled__", this);
		},
		getMatrices: function ()
		{
			return this .matrices;
		},
		set_enabled__: function ()
		{
			if (this .enabled_ .getValue ())
				return;

			if (this .isActive_ .getValue ())
				this .isActive_ = false;

			if (this .isOver_ .getValue ())
				this .isOver_ = false;
		},
		set_over__: function (over, hit)
		{
			if (over !== this .isOver_ .getValue ())
			{
				this .isOver_ = over;

				if (over)
					this .getBrowser () .getNotification () .string_ = this .description_;
			}
		},
		set_active__: function (active, hit)
		{
			if (active !== this .isActive_ .getValue ())
				this .isActive_ = active
		},
		set_motion__: function (hit)
		{ },
		push: function (renderObject, sensors)
		{
			if (this .enabled_ .getValue ())
			{
				sensors [this .getId ()] = new PointingDeviceSensorContainer (this,
				                                                              renderObject .getModelViewMatrix  () .get (),
				                                                              renderObject .getProjectionMatrix () .get (),
				                                                              renderObject .getViewVolume () .getViewport ());
			}
		},
	});

	return X3DPointingDeviceSensorNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/X3DTouchSensorNode',[
	"x_ite/Components/PointingDeviceSensor/X3DPointingDeviceSensorNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DPointingDeviceSensorNode, 
          X3DConstants)
{
"use strict";

	function X3DTouchSensorNode (executionContext)
	{
		X3DPointingDeviceSensorNode .call (this, executionContext);

		this .addType (X3DConstants .X3DTouchSensorNode);
	}

	X3DTouchSensorNode .prototype = Object .assign (Object .create (X3DPointingDeviceSensorNode .prototype),
	{
		constructor: X3DTouchSensorNode,
		set_active__: function (active, hit)
		{
			X3DPointingDeviceSensorNode .prototype .set_active__ .call (this, active, hit);

			if (this .enabled_ .getValue () && this .isOver_ .getValue () && ! active)
				this .touchTime_ = this .getBrowser () .getCurrentTime ();
		},
	});

	return X3DTouchSensorNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/TouchSensor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/PointingDeviceSensor/X3DTouchSensorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTouchSensorNode, 
          X3DConstants,
          Matrix4)
{
"use strict";

	var invModelViewMatrix = new Matrix4 ();

	function TouchSensor (executionContext)
	{
		X3DTouchSensorNode .call (this, executionContext);

		this .addType (X3DConstants .TouchSensor);

		this .hitPoint_changed_ .setUnit ("length");
	}

	TouchSensor .prototype = Object .assign (Object .create (X3DTouchSensorNode .prototype),
	{
		constructor: TouchSensor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",            new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "description",         new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "hitTexCoord_changed", new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "hitNormal_changed",   new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "hitPoint_changed",    new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isOver",              new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",            new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "touchTime",           new Fields .SFTime ()),
		]),
		getTypeName: function ()
		{
			return "TouchSensor";
		},
		getComponentName: function ()
		{
			return "PointingDeviceSensor";
		},
		getContainerField: function ()
		{
			return "children";
		},
		set_over__: function (over, hit, modelViewMatrix, projectionMatrix, viewport)
		{
			try
			{
				X3DTouchSensorNode .prototype .set_over__ .call (this, over, hit, modelViewMatrix, projectionMatrix, viewport);

				if (this .isOver_ .getValue ())
				{
					var intersection = hit .intersection;

					invModelViewMatrix .assign (modelViewMatrix) .inverse ();

					this .hitTexCoord_changed_ = intersection .texCoord;
					this .hitNormal_changed_   = modelViewMatrix .multMatrixDir (intersection .normal .copy ()) .normalize ();
					this .hitPoint_changed_    = invModelViewMatrix .multVecMatrix (intersection .point .copy ());
				}
			}
			catch (error)
			{
				console .log (error);
			}
		},
	});

	return TouchSensor;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/Anchor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Grouping/X3DGroupingNode",
	"x_ite/Components/Networking/X3DUrlObject",
	"x_ite/Components/PointingDeviceSensor/TouchSensor",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/FileLoader",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGroupingNode,
          X3DUrlObject,
          TouchSensor,
          TraverseType,
          X3DConstants,
          FileLoader)
{
"use strict";

	function Anchor (executionContext)
	{
		X3DGroupingNode .call (this, executionContext);
		X3DUrlObject    .call (this, executionContext);

		this .addType (X3DConstants .Anchor);

		this .touchSensorNode = new TouchSensor (executionContext);
	}

	Anchor .prototype = Object .assign (Object .create (X3DGroupingNode .prototype),
		X3DUrlObject .prototype,
	{
		constructor: Anchor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "description",    new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "url",            new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "parameter",      new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",       new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter",     new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "addChildren",    new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "removeChildren", new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "children",       new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "Anchor";
		},
		getComponentName: function ()
		{
			return "Networking";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DGroupingNode .prototype .initialize .call (this);
			X3DUrlObject    .prototype .initialize .call (this);

			this .description_ .addFieldInterest (this .touchSensorNode .description_);

			this .touchSensorNode .description_ = this .description_;
			this .touchSensorNode .setup ();

			// Modify set_active__ to get immediate response to user action (click event), otherwise links are not opened in this window.

			var
				anchor       = this,
				set_active__ = this .touchSensorNode .set_active__;

			this .touchSensorNode .set_active__ = function (active, hit)
			{
				set_active__ .call (this, active, hit);

				if (this .isOver_ .getValue () && ! active)
					anchor .requestAsyncLoad ();
			};
		},
		requestAsyncLoad: function ()
		{
			this .setLoadState (X3DConstants .IN_PROGRESS_STATE, false);

			new FileLoader (this) .createX3DFromURL (this .url_, this .parameter_,
			function (scene)
			{
				if (scene)
				{
					this .getBrowser () .replaceWorld (scene);
					this .setLoadState (X3DConstants .COMPLETE_STATE, false);
				}
				else
					this .setLoadState (X3DConstants .FAILED_STATE, false);		
			}
			.bind (this),
			function (fragment)
			{
			   try
			   {
					this .getExecutionContext () .changeViewpoint (fragment);
				}
				catch (error)
				{ }

				this .setLoadState (X3DConstants .COMPLETE_STATE, false);
			}
			.bind (this),
			function (url, target)
			{
				if (target)
					window .open (url, target);
				else
					location = url;

				this .setLoadState (X3DConstants .COMPLETE_STATE, false);
			}
			.bind (this));
		},
		traverse: function (type, renderObject)
		{
			if (type === TraverseType .POINTER)
			{
			   var sensors = { };

				renderObject .getBrowser () .getSensors () .push (sensors);
				this .touchSensorNode .push (renderObject, sensors);

				X3DGroupingNode .prototype .traverse .call (this, type, renderObject);

				renderObject .getBrowser () .getSensors () .pop ();
			}
			else
				X3DGroupingNode .prototype .traverse .call (this, type, renderObject);
		},
	});

	return Anchor;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking/Inline',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Components/Networking/X3DUrlObject",
	"x_ite/Components/Grouping/X3DBoundedObject",
	"x_ite/Components/Grouping/Group",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"x_ite/InputOutput/FileLoader",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode,
          X3DUrlObject,
          X3DBoundedObject,
          Group,
          TraverseType,
          X3DConstants,
          FileLoader)
{
"use strict";

	function Inline (executionContext)
	{
		X3DChildNode     .call (this, executionContext);
		X3DUrlObject     .call (this, executionContext);
		X3DBoundedObject .call (this, executionContext);

		this .addType (X3DConstants .Inline);

		this .addChildObjects ("buffer", new Fields .MFString ());

		this .scene = this .getBrowser () .getDefaultScene ();
		this .group = new Group (executionContext);

		this .group .addParent (this);
	}

	Inline .prototype = Object .assign (Object .create (X3DChildNode .prototype),
		X3DUrlObject .prototype,
		X3DBoundedObject .prototype,
	{
		constructor: Inline,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "load",       new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "url",        new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",   new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter", new Fields .SFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "Inline";
		},
		getComponentName: function ()
		{
			return "Networking";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DChildNode     .prototype .initialize .call (this);
			X3DUrlObject     .prototype .initialize .call (this);
			X3DBoundedObject .prototype .initialize .call (this);

			this .isLive () .addInterest ("set_live__", this);

			this .group .setPrivate (true);
			this .group .setup ();

			this .group .isCameraObject_   .addFieldInterest (this .isCameraObject_);
			this .group .isPickableObject_ .addFieldInterest (this .isPickableObject_);

			this .load_   .addInterest ("set_load__",   this);
			this .url_    .addInterest ("set_url__",    this);
			this .buffer_ .addInterest ("set_buffer__", this);

			this .set_url__ ();
		},
		getBBox: function (bbox)
		{
			return this .group .getBBox (bbox);
		},
		set_live__: function ()
		{
			if (! this .getPrivate ())
			{
				this .scene .setLive (this .isLive () .getValue ());
			}
		},
		set_load__: function ()
		{
			if (this .load_ .getValue ())
			{
				this .setLoadState (X3DConstants .NOT_STARTED_STATE);

				this .requestAsyncLoad ();
			}
			else
				this .requestUnload ();
		},
		set_url__: function ()
		{
			if (! this .load_ .getValue ())
				return;

			this .setLoadState (X3DConstants .NOT_STARTED_STATE);

			this .requestAsyncLoad ();
		},
		requestImmediateLoad: function ()
		{
			try
			{
				if (this .checkLoadState () === X3DConstants .COMPLETE_STATE || this .checkLoadState () === X3DConstants .IN_PROGRESS_STATE)
					return;

				this .setLoadState (X3DConstants .IN_PROGRESS_STATE);

				this .setInternalScene (new FileLoader (this) .createX3DFromURL (this .url_, null));
			}
			catch (error)
			{
				console .log (error);
				this .setInternalScene (this .getBrowser () .getDefaultScene ());
			}
		},
		requestAsyncLoad: function ()
		{
			if (this .checkLoadState () === X3DConstants .COMPLETE_STATE || this .checkLoadState () === X3DConstants .IN_PROGRESS_STATE)
				return;

			this .setLoadState (X3DConstants .IN_PROGRESS_STATE);

			// buffer prevents double load of the scene if load and url field are set at the same time.
			this .buffer_ = this .url_;
		},
		set_buffer__: function ()
		{
			new FileLoader (this) .createX3DFromURL (this .buffer_, null, this .setInternalSceneAsync .bind (this));
		},
		requestUnload: function ()
		{
			if (this .checkLoadState () === X3DConstants .NOT_STARTED_STATE || this .checkLoadState () === X3DConstants .FAILED_STATE)
				return;

			this .setLoadState (X3DConstants .NOT_STARTED_STATE);
			this .setInternalScene (this .getBrowser () .getDefaultScene ());
		},
		setInternalSceneAsync: function (scene)
		{
			if (scene)
			{
				this .setLoadState (X3DConstants .COMPLETE_STATE);
				this .setInternalScene (scene);
			}
			else
			{
				this .setLoadState (X3DConstants .FAILED_STATE);
				this .setInternalScene (this .getBrowser () .getDefaultScene ());
			}
		},
		setInternalScene: function (scene)
		{
			this .scene .setLive (false);
			this .scene .rootNodes .removeFieldInterest (this .group .children_);

			// Set new scene.

			this .scene = scene;
			this .scene .setExecutionContext (this .getExecutionContext ());
			this .scene .setPrivate (this .getExecutionContext () .getPrivate ());
			this .scene .setup ();

			this .scene .rootNodes .addFieldInterest (this .group .children_);
			this .group .children_ = this .scene .rootNodes;

			this .set_live__ ();

			this .getBrowser () .addBrowserEvent ();
		},
		getInternalScene: function ()
		{
			///  Returns the internal X3DScene of this extern proto, that is loaded from the url given.
			///  If the load field was false an empty scene is returned.  This empty scene is the same for all Inline
			///  nodes (due to performance reasons).

			return this .scene;
		},
		traverse: function (type, renderObject)
		{
			switch (type)
			{
				case TraverseType .PICKING:
				{
					var
						browser          = renderObject .getBrowser (),
						pickingHierarchy = browser .getPickingHierarchy ();

					pickingHierarchy .push (this);

					this .group .traverse (type, renderObject);

					pickingHierarchy .pop ();
					return;
				}
				default:
				{
					this .group .traverse (type, renderObject);
					return;
				}
			}
		},
	});

	return Inline;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Networking',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Networking/Anchor",
	"x_ite/Components/Networking/Inline",
	"x_ite/Components/Networking/LoadSensor",
	"x_ite/Components/Networking/X3DNetworkSensorNode",
	"x_ite/Components/Networking/X3DUrlObject",
],
function (SupportedNodes,
          Anchor,
          Inline,
          LoadSensor,
          X3DNetworkSensorNode,
          X3DUrlObject)
{
"use strict";

	var Types =
	{
		Anchor:     Anchor,
		Inline:     Inline,
		LoadSensor: LoadSensor,
	};

	var AbstractTypes =
	{
		X3DNetworkSensorNode: X3DNetworkSensorNode,
		X3DUrlObject:         X3DUrlObject,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/X3DDragSensorNode',[
	"x_ite/Components/PointingDeviceSensor/X3DPointingDeviceSensorNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DPointingDeviceSensorNode, 
          X3DConstants)
{
"use strict";

	function X3DDragSensorNode (executionContext)
	{
		X3DPointingDeviceSensorNode .call (this, executionContext);

		this .addType (X3DConstants .X3DDragSensorNode);

		this .trackPoint_changed_ .setUnit ("length");
	}

	X3DDragSensorNode .prototype = Object .assign (Object .create (X3DPointingDeviceSensorNode .prototype),
	{
		constructor: X3DDragSensorNode,
	});

	return X3DDragSensorNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Cylinder3',[
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Line3",
],
function (Vector3,
          Rotation4,
          Matrix4,
          Line3)
{
"use strict";

	function Cylinder3 (axis, radius)
	{
		this .axis   = axis .copy ();
		this .radius = radius;
	}

	Cylinder3 .prototype =
	{
		constructor: Cylinder3,
		intersectsLine: function (line, enter, exit)
		{
			////////////////////////////////////////////////////////////////////////
			//
			// Description:
			//  Intersect given line with this cylinder, returning the
			//  results in enter and exit. Returns TRUE if there was an
			//  intersection (and results are valid).
			//
			// Taken from Inventor SbCylinder.c++
			
			// The intersection will actually be done on a radius 1 cylinder
			// aligned with the y axis, so we transform the line into that
			// space, then intersect, then transform the results back.

			// rotation to y axis
			var
				rotToYAxis = new Rotation4 (this .axis .direction, new Vector3 (0, 1, 0)),
				mtxToYAxis = Matrix4 .Rotation (rotToYAxis);

			// scale to unit space
			var
				scaleFactor    = 1 / this .radius,
				toUnitCylSpace = new Matrix4 ();
	
			toUnitCylSpace .scale (new Vector3 (scaleFactor, scaleFactor, scaleFactor));
			toUnitCylSpace .multLeft (mtxToYAxis);

			// find the given line un-translated
			var
				point             = Vector3 .subtract (line .point, this .axis .point),
				noTranslationLine = new Line3 (point, line .direction);

			// find the un-translated line in unit cylinder's space
			var cylLine = noTranslationLine .multLineMatrix (toUnitCylSpace);

			// find the intersection on the unit cylinder
			var intersected = this .unitCylinderIntersectsLine (cylLine, enter, exit);

			if (intersected)
			{
				// transform back to original space
				var fromUnitCylSpace = toUnitCylSpace .inverse ();

				fromUnitCylSpace .multVecMatrix (enter);
				enter .add (this .axis .point);

				fromUnitCylSpace .multVecMatrix (exit);
				exit .add (this .axis .point);
			}

			return intersected;
		},
		unitCylinderIntersectsLine: function (line, enter, exit)
		{
			var t0, t1;

			var
				pos = line .point,
				dir = line .direction;

			var
				A = dir [0] * dir [0] + dir [2] * dir [2],
				B = 2 * (pos [0] * dir [0] + pos [2] * dir [2]),
				C = pos [0] * pos [0] + pos [2] * pos [2] - 1;

			// discriminant = B^2 - 4AC
			var discr = B * B - 4 * A * C;

			// if discriminant is negative, no intersection
			if (discr < 0)
				return false;

			var sqroot = Math .sqrt (discr);

			// magic to stabilize the answer
			if (B > 0)
			{
				t0 = -(2 * C) / (sqroot + B);
				t1 = -(sqroot + B) / (2 * A);
			}
			else
			{
				t0 = (2 * C) / (sqroot - B);
				t1 = (sqroot - B) / (2 * A);
			}

			enter .assign (dir) .multiply (t0) .add (pos);
			exit  .assign (dir) .multiply (t1) .add (pos);

			return true;
		},
		toString: function ()
		{
			return this .axis .toString () + " " + this .radius;
		},
	};

	return Cylinder3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/CylinderSensor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/PointingDeviceSensor/X3DDragSensorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Line3",
	"standard/Math/Geometry/Plane3",
	"standard/Math/Geometry/Cylinder3",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDragSensorNode,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4,
          Line3,
          Plane3,
          Cylinder3,
          Algorithm)
{
"use strict";

	function CylinderSensor (executionContext)
	{
		X3DDragSensorNode .call (this, executionContext);

		this .addType (X3DConstants .CylinderSensor);

		this .diskAngle_ .setUnit ("angle");
		this .minAngle_  .setUnit ("angle");
		this .maxAngle_  .setUnit ("angle");
		this .offset_    .setUnit ("angle");
	}

	CylinderSensor .prototype = Object .assign (Object .create (X3DDragSensorNode .prototype),
	{
		constructor: CylinderSensor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",            new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "description",        new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "axisRotation",       new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "diskAngle",          new Fields .SFFloat (0.261792)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "minAngle",           new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "maxAngle",           new Fields .SFFloat (-1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "offset",             new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "autoOffset",         new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "trackPoint_changed", new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "rotation_changed",   new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isOver",             new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",           new Fields .SFBool ()),
		]),
		getTypeName: function ()
		{
			return "CylinderSensor";
		},
		getComponentName: function ()
		{
			return "PointingDeviceSensor";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DDragSensorNode .prototype .initialize .call (this);

			this .modelViewMatrix    = new Matrix4 ();
			this .invModelViewMatrix = new Matrix4 ();

			this .cylinder    = new Cylinder3 (new Line3 (new Vector3 (0, 0, 0), new Vector3 (0, 0, 0)), 0);
			this .disk        = false;
			this .yPlane      = null;
			this .zPlane      = null;
			this .sxPlane     = null;
			this .szNormal    = null;
			this .behind      = false;
			this .fromVector  = new Vector3 (0, 0, 0);
			this .startOffset = new Rotation4 (0, 0, 1, 0);
		},
		isBehind: function (hitRay, hitPoint)
		{
			var
				enter = new Vector3 (0, 0 ,0),
				exit  = new Vector3 (0, 0, 0);

			this .cylinder .intersectsLine (hitRay, enter, exit);

			return Vector3 .subtract (hitPoint, enter) .abs () > Vector3 .subtract (hitPoint, exit) .abs ();
		},
		getTrackPoint: function (hitRay, trackPoint)
		{
			var zPoint = new Vector3 (0, 0, 0);

			this .zPlane .intersectsLine (hitRay, zPoint);

			var
				axisPoint = Vector3 .add (zPoint, this .cylinder .axis .getPerpendicularVector (zPoint)),
				distance  = this .sxPlane .getDistanceToPoint (zPoint) / this .cylinder .radius,
				section   = Math .floor ((distance + 1) / 2);

			// Use asin on the cylinder and outside linear angle.
			var
				sinp  = Algorithm .interval (distance, -1, 1),
				phi   = section === 0 ? Math .asin (sinp) : sinp * Math .PI / 2,
				angle = phi + section * Math .PI;

			var rotation = new Rotation4 (this .cylinder .axis .direction, angle);

			rotation .multVecRot (trackPoint .assign (this .szNormal) .multiply (this .cylinder .radius));
			trackPoint .add (axisPoint);
		},
		getAngle: function (rotation)
		{
			if (Vector3 .dot (rotation .getAxis (), this .cylinder .axis .direction) > 0)
				return rotation .angle;

			else
				return -rotation .angle;
		},
		set_active__: function (active, hit, modelViewMatrix, projectionMatrix, viewport)
		{
			X3DDragSensorNode .prototype .set_active__ .call (this, active, hit, modelViewMatrix, projectionMatrix, viewport);

			try
			{
				if (this .isActive_ .getValue ())
				{
					this .modelViewMatrix .assign (modelViewMatrix);
					this .invModelViewMatrix .assign (modelViewMatrix) .inverse ();

					var
						hitRay   = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
						hitPoint = this .invModelViewMatrix .multVecMatrix (hit .intersection .point .copy ());

					var
						yAxis      = this .axisRotation_ .getValue () .multVecRot (new Vector3 (0, 1, 0)),
						cameraBack = this .invModelViewMatrix .multDirMatrix (new Vector3 (0, 0, 1)) .normalize ();

					var
						axis   = new Line3 (new Vector3 (0, 0, 0), yAxis),
						radius = axis .getPerpendicularVector (hitPoint) .abs ();

					this .cylinder = new Cylinder3 (axis, radius);

					this .disk   = Math .abs (Vector3 .dot (cameraBack, yAxis)) > Math .cos (this .diskAngle_ .getValue ());
					this .behind = this .isBehind (hitRay, hitPoint);

					this .yPlane = new Plane3 (hitPoint, yAxis);             // Sensor aligned y-plane
					this .zPlane = new Plane3 (hitPoint, cameraBack);        // Screen aligned z-plane

					// Compute normal like in Billboard with yAxis as axis of rotation.
					var
						billboardToViewer = this .invModelViewMatrix .origin,
						sxNormal          = Vector3 .cross (yAxis, billboardToViewer) .normalize ();

					this .sxPlane  = new Plane3 (new Vector3 (0, 0, 0), sxNormal);   // Billboarded special x-plane made parallel to sensors axis.
					this .szNormal = Vector3 .cross (sxNormal, yAxis) .normalize (); // Billboarded special z-normal made parallel to sensors axis.

					var trackPoint = new Vector3 (0, 0, 0);

					if (this .disk)
						this .yPlane .intersectsLine (hitRay, trackPoint);
					else
						this .getTrackPoint (hitRay, trackPoint);

					this .fromVector  = this .cylinder .axis .getPerpendicularVector (trackPoint) .negate ();
					this .startOffset = new Rotation4 (yAxis, this .offset_ .getValue ());

					this .trackPoint_changed_ = trackPoint;
					this .rotation_changed_   = this .startOffset;

					// For min/max angle.

					this .angle       = this .offset_ .getValue ();
					this .startVector = this .rotation_changed_ .getValue () .multVecRot (this .axisRotation_ .getValue () .multVecRot (new Vector3 (0, 0, 1)));
				}
				else
				{
					if (this .autoOffset_ .getValue ())
						this .offset_ = this .getAngle (this .rotation_changed_ .getValue ());
				}
			}
			catch (error)
			{
				//console .log (error);
			}
		},
		set_motion__: function (hit)
		{
			try
			{
				var
					hitRay     = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
					trackPoint = new Vector3 (0, 0, 0);

				if (this .disk)
					this .yPlane .intersectsLine (hitRay, trackPoint);
				else
					this .getTrackPoint (hitRay, trackPoint);

				this .trackPoint_changed_ = trackPoint;

				var
					toVector = this .cylinder .axis .getPerpendicularVector (trackPoint) .negate (),
					rotation = new Rotation4 (this .fromVector, toVector);

				if (this .disk)
				{
					// The trackpoint can swap behind the viewpoint if viewpoint is a Viewpoint node
					// as the viewing volume is not a cube where the picking ray goes straight up.
					// This phenomenon is very clear on the viewport corners.

					var trackPoint_ = this .modelViewMatrix .multVecMatrix (trackPoint .copy ());

					if (trackPoint_ .z > 0)
						rotation .multRight (new Rotation4 (this .yPlane .normal, Math .PI));
				}
				else
				{
					if (this .behind)
						rotation .inverse ();
				}

				rotation .multLeft (this .startOffset);

				if (this .minAngle_ .getValue () > this .maxAngle_ .getValue ())
				{
					this .rotation_changed_ = rotation;
				}
				else
				{
					var
						endVector     = rotation .multVecRot (this .axisRotation_ .getValue () .multVecRot (new Vector3 (0, 0, 1))),
						deltaRotation = new Rotation4 (this .startVector, endVector),
						axis          = this .axisRotation_ .getValue () .multVecRot (new Vector3 (0, 1, 0)),
						sign          = axis .dot (deltaRotation .getAxis ()) > 0 ? 1 : -1,
						min           = this .minAngle_ .getValue (),
						max           = this .maxAngle_ .getValue ();

					this .angle += sign * deltaRotation .angle;

					this .startVector .assign (endVector);

					//console .log (this .angle, min, max);

					if (this .angle < min)
						rotation .setAxisAngle (this .cylinder .axis .direction, min);
					else if (this .angle > max)
						rotation .setAxisAngle (this .cylinder .axis .direction, max);
					else
						rotation .setAxisAngle (this .cylinder .axis .direction, this .angle);

					if (! this .rotation_changed_ .getValue () .equals (rotation))
						this .rotation_changed_ = rotation;
				}
			}
			catch (error)
			{
				//console .log (error);

				this .trackPoint_changed_ .addEvent ();
				this .rotation_changed_   .addEvent ();
			}
		},
	});

	return CylinderSensor;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/PlaneSensor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/PointingDeviceSensor/X3DDragSensorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Line3",
	"standard/Math/Geometry/Plane3",
	"standard/Math/Geometry/ViewVolume",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDragSensorNode, 
          X3DConstants,
          Rotation4,
          Vector3,
          Vector4,
          Matrix4,
          Line3,
          Plane3,
          ViewVolume,
          Algorithm)
{
"use strict";

	var
		screenLine     = new Line3 (Vector3 .Zero, Vector3 .Zero),
		trackPoint1    = new Vector3 (0, 0, 0),
		trackPointLine = new Line3 (Vector3 .Zero, Vector3 .Zero);

	function PlaneSensor (executionContext)
	{
		X3DDragSensorNode .call (this, executionContext);

		this .addType (X3DConstants .PlaneSensor);

		this .offset_              .setUnit ("length");
		this .minPosition_         .setUnit ("length");
		this .maxPosition_         .setUnit ("length");
		this .translation_changed_ .setUnit ("length");
	}

	PlaneSensor .prototype = Object .assign (Object .create (X3DDragSensorNode .prototype),
	{
		constructor: PlaneSensor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",            new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "description",         new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "axisRotation",        new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "autoOffset",          new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "offset",              new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "minPosition",         new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "maxPosition",         new Fields .SFVec2f (-1, -1)),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "trackPoint_changed",  new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "translation_changed", new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isOver",              new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",            new Fields .SFBool ()),
		]),
		getTypeName: function ()
		{
			return "PlaneSensor";
		},
		getComponentName: function ()
		{
			return "PointingDeviceSensor";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DDragSensorNode .prototype .initialize .call (this);

			this .modelViewMatrix    = new Matrix4 ();
			this .invModelViewMatrix = new Matrix4 ();
			this .projectionMatrix   = new Matrix4 ();
			this .viewport           = new Vector4 ();

			this .planeSensor = true;
			this .plane       = null;
			this .line        = null;
			this .startOffset = new Vector3 (0, 0, 0);
			this .startPoint  = new Vector3 (0, 0, 0);
		},
		getLineTrackPoint: function (hit, line, trackPoint)
		{
			ViewVolume .projectLine (line, this .modelViewMatrix, this .projectionMatrix, this .viewport, screenLine);
			screenLine .getClosestPointToPoint (new Vector3 (hit .pointer .x, hit .pointer .y, 0), trackPoint1);
			ViewVolume .unProjectRay (trackPoint1 .x, trackPoint1 .y, this .modelViewMatrix, this .projectionMatrix, this .viewport, trackPointLine);

			return line .getClosestPointToLine (trackPointLine, trackPoint);
		},
		set_active__: function (active, hit, modelViewMatrix, projectionMatrix, viewport)
		{
			X3DDragSensorNode .prototype .set_active__ .call (this, active, hit, modelViewMatrix, projectionMatrix, viewport);

			try
			{
				if (this .isActive_ .getValue ())
				{
					this .modelViewMatrix    .assign (modelViewMatrix);
					this .projectionMatrix   .assign (projectionMatrix);
					this .viewport           .assign (viewport);
					this .invModelViewMatrix .assign (modelViewMatrix) .inverse ();

					var
						hitRay   = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
						hitPoint = this .invModelViewMatrix .multVecMatrix (hit .intersection .point .copy ());

					var axisRotation = this .axisRotation_ .getValue ();

					if (this .minPosition_ .x === this .maxPosition_ .x)
					{
						this .planeSensor = false;

						var direction = axisRotation .multVecRot (new Vector3 (0, Math .abs (this .maxPosition_ .y - this .minPosition_ .y), 0));

						this .line = new Line3 (hitPoint, direction .normalize ());
					}
					else if (this .minPosition_ .y === this .maxPosition_ .y)
					{
						this .planeSensor = false;

						var direction = axisRotation .multVecRot (new Vector3 (Math .abs (this .maxPosition_ .x - this .minPosition_ .x), 0, 0));

						this .line = new Line3 (hitPoint, direction .normalize ());
					}
					else
					{
						this .planeSensor = true;
						this .plane       = new Plane3 (hitPoint, axisRotation .multVecRot (new Vector3 (0, 0, 1)));
					}

					if (this .planeSensor)
					{
						if (this .plane .intersectsLine (hitRay, this .startPoint))
						{
							this .trackStart (this .startPoint);
						}

//						new Plane3 (new Vector3 (0, 0, 0), this .plane .normal) .intersectsLine (hitRay, trackPoint);
					}
					else
					{
						if (this .getLineTrackPoint (hit, this .line, this .startPoint))
						{
							var trackPoint = new Vector3 (0, 0, 0);
	
							try
							{
								this .getLineTrackPoint (hit, new Line3 (this .line .direction, this .line .direction), trackPoint);
							}
							catch (error)
							{
								//console .log (error);
	
								trackPoint = this .startPoint;
							}

							this .trackStart (trackPoint);
						}
					}
				}
				else
				{
					if (this .autoOffset_ .getValue ())
						this .offset_ = this .translation_changed_;
				}
			}
			catch (error)
			{
				console .log (error);
			}
		},
		trackStart: function (trackPoint)
		{
			this .startOffset .assign (this .offset_ .getValue ());

			this .trackPoint_changed_  = trackPoint;
			this .translation_changed_ = this .offset_ .getValue ();
		},
		set_motion__: function (hit)
		{
			try
			{
				if (this .planeSensor)
				{
					var
						hitRay   = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
						endPoint = new Vector3 (0, 0, 0);

					if (this .plane .intersectsLine (hitRay, endPoint))
					{
						this .track (endPoint, endPoint .copy ());
					}
					else
						throw new Error ("Plane and line are parallel.");
				}
				else
				{
					var
						endPoint   = new Vector3 (0, 0, 0),
						trackPoint = new Vector3 (0, 0, 0);

					if (this .getLineTrackPoint (hit, this .line, endPoint))
					{
						try
						{
							this .getLineTrackPoint (hit, new Line3 (Vector3 .Zero, this .line .direction), trackPoint);
						}
						catch (error)
						{
							trackPoint .assign (endPoint);
						}
					
						this .track (endPoint, trackPoint);
					}
					else
						throw new Error ("Lines are parallel.");
				}
			}
			catch (error)
			{
				//console .log (error);

				this .trackPoint_changed_  .addEvent ();
				this .translation_changed_ .addEvent ();
			}
		},
		track: function (endPoint, trackPoint)
		{
			var
				axisRotation = this .axisRotation_ .getValue (),
				translation  = Rotation4 .inverse (axisRotation) .multVecRot (endPoint .add (this .startOffset) .subtract (this .startPoint));

			// X component

			if (! (this .minPosition_ .x > this .maxPosition_ .x))
				translation .x = Algorithm .clamp (translation .x, this .minPosition_ .x, this .maxPosition_ .x);

			// Y component

			if (! (this .minPosition_ .y > this .maxPosition_ .y))
				translation .y = Algorithm .clamp (translation .y, this .minPosition_ .y, this .maxPosition_ .y);

			axisRotation .multVecRot (translation);

			if (! this .trackPoint_changed_ .getValue () .equals (trackPoint))
				this .trackPoint_changed_ = trackPoint;

			if (! this .translation_changed_ .getValue () .equals (translation))
				this .translation_changed_ = translation;
		},
	});

	return PlaneSensor;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Geometry/Sphere3',[
	"standard/Math/Numbers/Vector3",
],
function (Vector3)
{
"use strict";

	function Sphere3 (radius, center)
	{
		this .radius = radius;
		this .center = center .copy ();
	}

	Sphere3 .prototype =
	{
		constructor: Sphere3,
		set: function (radius, center)
		{
			this .radius = radius;
			this .center .assign (center);
		},
		intersectsLine: function (line, enterPoint, exitPoint)
		{
			// https://github.com/Alexpux/Coin3D/blob/master/src/base/SbSphere.cpp

			var
				linepos = line .point,
				linedir = line .direction;

			var
				scenter = this .center,
				r       = this .radius;

			var
				b = 2 * (linepos .dot (linedir) - scenter .dot (linedir)),
				c = (linepos .x * linepos .x + linepos .y * linepos .y + linepos .z * linepos .z) +
			       (scenter .x * scenter .x + scenter .y * scenter .y + scenter .z * scenter .z) -
			       2 * linepos .dot (scenter) - r * r;

			var core = b * b - 4 * c;

			if (core >= 0)
			{
				var
					t1 = (-b + Math .sqrt (core)) / 2,
					t2 = (-b - Math .sqrt (core)) / 2;

				if (t1 > t2)
				{
					var tmp = t1;
					t1 = t2;
					t2 = tmp;
				}

				enterPoint .assign (linedir) .multiply (t1) .add (linepos);
				exitPoint  .assign (linedir) .multiply (t2) .add (linepos);

				return true;
			}
			else
			{
				return false;
			}
		},
		intersectsTriangle: (function ()
		{
			var
				AB = new Vector3 (0, 0, 0),
				AC = new Vector3 (0, 0, 0),
				BC = new Vector3 (0, 0, 0),
				CA = new Vector3 (0, 0, 0),
				Q1 = new Vector3 (0, 0, 0),
				Q2 = new Vector3 (0, 0, 0),
				Q3 = new Vector3 (0, 0, 0);

			return function (A, B, C)
			{
				var
					P = this .center,
					r = this .radius;

				A .subtract (P);
				B .subtract (P);
				C .subtract (P);

				// Testing if sphere lies outside the triangle plane.

				AB .assign (B) .subtract (A);
				AC .assign (C) .subtract (A);

				var
					rr   = r * r,
					V    = AB .cross (AC),
					d    = Vector3 .dot (A, V),
					e    = Vector3 .dot (V, V),
					sep1 = d * d > rr * e;

				if (sep1)
					return false;

				// Testing if sphere lies outside a triangle vertex.
				var
					aa   = Vector3 .dot (A, A),
					ab   = Vector3 .dot (A, B),
					ac   = Vector3 .dot (A, C),
					bb   = Vector3 .dot (B, B),
					bc   = Vector3 .dot (B, C),
					cc   = Vector3 .dot (C, C),
					sep2 = (aa > rr) && (ab > aa) && (ac > aa),
					sep3 = (bb > rr) && (ab > bb) && (bc > bb),
					sep4 = (cc > rr) && (ac > cc) && (bc > cc);

				if (sep2 || sep3 || sep4)
					return false;

				// Testing if sphere lies outside a triangle edge.

				AB .assign (B) .subtract (A);
				BC .assign (C) .subtract (B);
				CA .assign (A) .subtract (C);

				var
					d1   = ab - aa,
					d2   = bc - bb,
					d3   = ac - cc,
					e1   = Vector3 .dot (AB, AB),
					e2   = Vector3 .dot (BC, BC),
					e3   = Vector3 .dot (CA, CA);

				Q1 .assign (A) .multiply (e1) .subtract (AB .multiply (d1));
				Q2 .assign (B) .multiply (e2) .subtract (BC .multiply (d2));
				Q3 .assign (C) .multiply (e3) .subtract (CA .multiply (d3));

				var
					QC   = C .multiply (e1) .subtract (Q1),
					QA   = A .multiply (e2) .subtract (Q2),
					QB   = B .multiply (e3) .subtract (Q3),
					sep5 = (Vector3 .dot (Q1, Q1) > rr * e1 * e1) && (Vector3 .dot (Q1, QC) > 0),
					sep6 = (Vector3 .dot (Q2, Q2) > rr * e2 * e2) && (Vector3 .dot (Q2, QA) > 0),
					sep7 = (Vector3 .dot (Q3, Q3) > rr * e3 * e3) && (Vector3 .dot (Q3, QB) > 0);

				if (sep5 || sep6 || sep7)
					return false;

				return true;
			};
		})(),
		toString: function ()
		{
			return this .radius + " " + this .center .toString ();
		},
	};

	return Sphere3;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor/SphereSensor',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/PointingDeviceSensor/X3DDragSensorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Triangle3",
	"standard/Math/Geometry/Line3",
	"standard/Math/Geometry/Plane3",
	"standard/Math/Geometry/Sphere3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DDragSensorNode, 
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4,
          Triangle3,
          Line3,
          Plane3,
          Sphere3)
{
"use strict";

	function SphereSensor (executionContext)
	{
		X3DDragSensorNode .call (this, executionContext);

		this .addType (X3DConstants .SphereSensor);
	}

	SphereSensor .prototype = Object .assign (Object .create (X3DDragSensorNode .prototype),
	{
		constructor: SphereSensor,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",            new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "description",        new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "autoOffset",         new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "offset",             new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "trackPoint_changed", new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "rotation_changed",   new Fields .SFRotation ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isOver",             new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",           new Fields .SFBool ()),
		]),
		getTypeName: function ()
		{
			return "SphereSensor";
		},
		getComponentName: function ()
		{
			return "PointingDeviceSensor";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DDragSensorNode .prototype .initialize .call (this);

			this .modelViewMatrix    = new Matrix4 ();
			this .invModelViewMatrix = new Matrix4 ();

			this .sphere      = null;
			this .zPlane      = null;
			this .behind      = false;
			this .fromVector  = new Vector3 (0, 0, 0);
			this .startPoint  = new Vector3 (0, 0, 0);
			this .startOffset = new Rotation4 (0, 0, 1, 0);
		},
		getTrackPoint: function (hitRay, trackPoint, behind)
		{
			var exit = new Vector3 (0, 0, 0);

			if (this .sphere .intersectsLine (hitRay, trackPoint, exit))
			{
				if ((Vector3 .subtract (hitRay .point, exit) .abs () < Vector3 .subtract (hitRay .point, trackPoint) .abs ()) - behind)
					trackPoint .assign (exit);

				return true;
			}

			return false;
		},
		set_active__: function (active, hit, modelViewMatrix, projectionMatrix, viewport)
		{
			X3DDragSensorNode .prototype .set_active__ .call (this, active, hit, modelViewMatrix, projectionMatrix, viewport);

			try
			{
				if (this .isActive_ .getValue ())
				{
					this .modelViewMatrix    .assign (modelViewMatrix);
					this .invModelViewMatrix .assign (modelViewMatrix) .inverse ();

					var
						hitPoint = this .invModelViewMatrix .multVecMatrix (hit .intersection .point .copy ()),
						center   = new Vector3 (0, 0, 0);

					this .zPlane = new Plane3 (center, this .invModelViewMatrix .multDirMatrix (new Vector3 (0, 0, 1)) .normalize ()); // Screen aligned Z-plane
					this .sphere = new Sphere3 (hitPoint .abs (), center);
					this .behind = this .zPlane .getDistanceToPoint (hitPoint) < 0;

					this .fromVector  .assign (hitPoint);
					this .startPoint  .assign (hitPoint);
					this .startOffset .assign (this .offset_ .getValue ());
	
					this .trackPoint_changed_ = hitPoint;
					this .rotation_changed_   = this .offset_ .getValue ();
				}
				else
				{
					if (this .autoOffset_ .getValue ())
						this .offset_ = this .rotation_changed_;
				}
			}
			catch (error)
			{
				//console .log (error);
			}
		},
		set_motion__: function (hit)
		{
			try
			{
				var
					hitRay     = hit .hitRay .copy () .multLineMatrix (this .invModelViewMatrix),
					trackPoint = new Vector3 (0, 0, 0);

				if (this .getTrackPoint (hitRay, trackPoint, this .behind))
				{
					var zAxis = this .invModelViewMatrix .multDirMatrix (new Vector3 (0, 0, 1)) .normalize (); // Camera direction
					this .zPlane = new Plane3 (trackPoint, zAxis);                                             // Screen aligned Z-plane
				}
				else
				{
					// Find trackPoint on the plane with sphere

					var tangentPoint = new Vector3 (0, 0, 0);
					this .zPlane .intersectsLine (hitRay, tangentPoint);

					hitRay = new Line3 (tangentPoint, Vector3 .subtract (this .sphere .center, tangentPoint) .normalize ());
					
					//console .log (hitRay .toString ());

					this .getTrackPoint (hitRay, trackPoint, false);

					// Find trackPoint behind sphere

					var
						triNormal     = Triangle3 .normal (this .sphere .center, trackPoint, this .startPoint, new Vector3 (0, 0, 0)),
						dirFromCenter = Vector3 .subtract (trackPoint, this .sphere .center) .normalize (),
						normal        = Vector3 .cross (triNormal, dirFromCenter) .normalize ();

					var point1 = Vector3 .subtract (trackPoint, normal .multiply (Vector3 .subtract (tangentPoint, trackPoint) .abs ()));

					hitRay = new Line3 (point1, Vector3 .subtract (this .sphere .center, point1) .normalize ());

					this .getTrackPoint (hitRay, trackPoint, false);
				}

				this .trackPoint_changed_ = trackPoint;

				var
					toVector = Vector3 .subtract (trackPoint, this .sphere .center),
					rotation = new Rotation4 (this .fromVector, toVector);

				if (this .behind)
					rotation .inverse ();

				this .rotation_changed_ = Rotation4 .multRight (this .startOffset, rotation);
			}
			catch (error)
			{
				//console .log (error);

				this .trackPoint_changed_ .addEvent ();
				this .rotation_changed_   .addEvent ();
			}
		},
	});

	return SphereSensor;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/PointingDeviceSensor',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/PointingDeviceSensor/CylinderSensor",
	"x_ite/Components/PointingDeviceSensor/PlaneSensor",
	"x_ite/Components/PointingDeviceSensor/SphereSensor",
	"x_ite/Components/PointingDeviceSensor/TouchSensor",
	"x_ite/Components/PointingDeviceSensor/X3DDragSensorNode",
	"x_ite/Components/PointingDeviceSensor/X3DPointingDeviceSensorNode",
	"x_ite/Components/PointingDeviceSensor/X3DTouchSensorNode",
],
function (SupportedNodes,
          CylinderSensor,
          PlaneSensor,
          SphereSensor,
          TouchSensor,
          X3DDragSensorNode,
          X3DPointingDeviceSensorNode,
          X3DTouchSensorNode)
{
"use strict";

	var Types =
	{
		CylinderSensor: CylinderSensor,
		PlaneSensor:    PlaneSensor,
		SphereSensor:   SphereSensor,
		TouchSensor:    TouchSensor,
	};

	var AbstractTypes =
	{
		X3DDragSensorNode:           X3DDragSensorNode,
		X3DPointingDeviceSensorNode: X3DPointingDeviceSensorNode,
		X3DTouchSensorNode:          X3DTouchSensorNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/ClipPlane',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Vector4",
	"standard/Math/Geometry/Plane3",
	"standard/Utility/ObjectCache",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DChildNode,
          X3DConstants,
          Vector3,
          Vector4,
          Plane3,
          ObjectCache)
{
"use strict";

	var ClipPlanes = ObjectCache (ClipPlaneContainer);

	function ClipPlaneContainer ()
	{
		this .plane = new Plane3 (Vector3 .Zero, Vector3 .Zero);
	}

	ClipPlaneContainer .prototype =
	{
		constructor: ClipPlaneContainer,
		isClipped: function (point)
		{
			return this .plane .getDistanceToPoint (point) < 0;
		},
		set: function (clipPlane, modelViewMatrix)
		{
			var
				plane      = this .plane,
				localPlane = clipPlane .plane;

			try
			{
				plane .normal .assign (localPlane);
				plane .distanceFromOrigin = -localPlane .w;

				plane .multRight (modelViewMatrix);
			}
			catch (error)
			{
				plane .normal .set (0, 0, 0);
				plane .distanceFromOrigin = 0;
			}
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			var
				plane  = this .plane,
				normal = plane .normal;

			gl .uniform4f (shaderObject .x3d_ClipPlane [shaderObject .numClipPlanes ++], normal .x, normal .y, normal .z, plane .distanceFromOrigin);
		},
		dispose: function ()
		{
		   ClipPlanes .push (this);
		},
	};

	function ClipPlane (executionContext)
	{
		X3DChildNode .call (this, executionContext);

		this .addType (X3DConstants .ClipPlane);

		this .enabled = false;
		this .plane   = new Vector4 (0, 0, 0, 0);
	}

	ClipPlane .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: ClipPlane,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "enabled",  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "plane",    new Fields .SFVec4f (0, 1, 0, 0)),
		]),
		getTypeName: function ()
		{
			return "ClipPlane";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DChildNode .prototype .initialize .call (this);

			this .enabled_ .addInterest ("set_enabled__", this);
			this .plane_   .addInterest ("set_enabled__", this);

			this .set_enabled__ ();
		},
		set_enabled__: function ()
		{
			this .plane .assign (this .plane_ .getValue ());

			this .enabled = this .enabled_ .getValue () && ! this .plane .equals (Vector4 .Zero);
		},
		push: function (renderObject)
		{
			if (this .enabled)
			{
				var clipPlaneContainer = ClipPlanes .pop ();

				clipPlaneContainer .set (this, renderObject .getModelViewMatrix () .get ());

				renderObject .getLocalObjects () .push (clipPlaneContainer);
			}
		},
		pop: function (renderObject)
		{
			if (this .enabled)
				renderObject .getBrowser () .getLocalObjects () .push (renderObject .getLocalObjects () .pop ());
		},
	});

	return ClipPlane;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DColorNode',[
	"x_ite/Fields",
	"x_ite/Components/Rendering/X3DGeometricPropertyNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DGeometricPropertyNode, 
          X3DConstants)
{
"use strict";

	function X3DColorNode (executionContext)
	{
		X3DGeometricPropertyNode .call (this, executionContext);

		this .addType (X3DConstants .X3DColorNode);

		this .addChildObjects ("transparent", new Fields .SFBool ());

		this .transparent_ .setAccessType (X3DConstants .outputOnly);
	}

	X3DColorNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
	{
		constructor: X3DColorNode,
		setTransparent: function (value)
		{
			if (value !== this .transparent_ .getValue ())
				this .transparent_ = value;
		},
		getTransparent: function ()
		{
			return this .transparent_ .getValue ();
		},
	});

	return X3DColorNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/Color',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DColorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DColorNode,
          X3DConstants,
          Vector4)
{
"use strict";

	function Color (executionContext)
	{
		X3DColorNode .call (this, executionContext);

		this .addType (X3DConstants .Color);
	}

	Color .prototype = Object .assign (Object .create (X3DColorNode .prototype),
	{
		constructor: Color,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "color",    new Fields .MFColor ()),
		]),
		getTypeName: function ()
		{
			return "Color";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "color";
		},
		initialize: function ()
		{
			X3DColorNode .prototype .initialize .call (this);

			this .color_ .addInterest ("set_color__", this);

			this .set_color__ ();
		},
		set_color__: function ()
		{
			this .color  = this .color_ .getValue ();
			this .length = this .color_ .length;
		},
		addColor: function (index, array)
		{
			if (index >= 0 && index < this .length)
			{
				const color = this .color;

				index *= 3;

				array .push (color [index], color [index + 1], color [index + 2], 1);
			}
			else if (this .length)
			{
				const color = this .color;

				index = (this .length - 1) * 3;

				array .push (color [index], color [index + 1], color [index + 2], 1);
			}
			else
			{
				array .push (1, 1, 1, 1);
			}
		},
		addColors: function (array, min)
		{
			if (this .length)
			{
				const color = this .color;

				for (var index = 0, length = this .length * 3; index < length; index += 3)
					array .push (color [index], color [index + 1], color [index + 2], 1);

				var
					index = (this .length - 1) * 3,
					r     = color [index],
					g     = color [index + 1],
					b     = color [index + 2];

				for (var index = length, length = min * 3; index < length; index += 3)
					array .push (r, g, b, 1);
			}
			else
			{
				for (var index = 0; index < min; ++ index)
					array .push (1, 1, 1, 1);
			}
		},
		getVectors: function (array)
		{
			var color = this .color_;

			for (var i = 0, length = color .length; i < length; ++ i)
			{
				var c = color [i];

				array [i] = new Vector4 (c .r, c .g, c .b, 1);
			}

			array .length = length;

			return array;
		},
	});

	return Color;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/ColorRGBA',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DColorNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector4",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DColorNode,
          X3DConstants,
          Vector4)
{
"use strict";

	function ColorRGBA (executionContext)
	{
		X3DColorNode .call (this, executionContext);

		this .addType (X3DConstants .ColorRGBA);

		this .setTransparent (true);
	}

	ColorRGBA .prototype = Object .assign (Object .create (X3DColorNode .prototype),
	{
		constructor: ColorRGBA,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "color",    new Fields .MFColorRGBA ()),
		]),
		getTypeName: function ()
		{
			return "ColorRGBA";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "color";
		},
		initialize: function ()
		{
			X3DColorNode .prototype .initialize .call (this);

			this .color_ .addInterest ("set_color__", this);

			this .set_color__ ();
		},
		set_color__: function ()
		{
			this .color  = this .color_ .getValue ();
			this .length = this .color_ .length;
		},
		addColor: function (index, array)
		{
			if (index >= 0 && index < this .length)
			{
				const color = this .color;

				index *= 4;

				array .push (color [index], color [index + 1], color [index + 2], color [index + 3]);
			}
			else if (this .length)
			{
				const color = this .color;

				index = (this .length - 1) * 4;

				array .push (color [index], color [index + 1], color [index + 2], color [index + 3]);
			}
			else
			{
				array .push (1, 1, 1, 1);
			}
		},
		addColors: function (array, min)
		{
			if (this .length)
			{
				const color = this .color;

				for (var index = 0, length = this .length * 4; index < length; index += 4)
					array .push (color [index], color [index + 1], color [index + 2], color [index + 3]);

				var
					index = (this .length - 1) * 4,
					r     = color [index],
					g     = color [index + 1],
					b     = color [index + 2],
					a     = color [index + 2];

				for (var index = length, length = min * 4; index < length; index += 4)
					array .push (r, g, b, a);
			}
			else
			{
				for (var index = 0; index < min; ++ index)
					array .push (1, 1, 1, 1);
			}
		},
		getVectors: function (array)
		{
			var color = this .color_;

			for (var i = 0, length = color .length; i < length; ++ i)
			{
				var c = color [i];

				array [i] = new Vector4 (c .r, c .g, c .b, c .a);
			}

			array .length = length;

			return array;
		},
	});

	return ColorRGBA;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DLineGeometryNode',[
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix4",
],
function (X3DGeometryNode,
          X3DConstants,
          Matrix4)
{
"use strict";

	function X3DLineGeometryNode (executionContext)
	{
		X3DGeometryNode .call (this, executionContext);

		//this .addType (X3DConstants .X3DLineGeometryNode);
	}

	X3DLineGeometryNode .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
	{
		constructor: X3DLineGeometryNode,
		getShader: function (browser)
		{
			return browser .getLineShader ();
		},
		intersectsLine: function (line, clipPlanes, modelViewMatrix, intersections)
		{
			return false;
		},
		intersectsBox: function (box, clipPlanes, modelViewMatrix)
		{
			return false;
		},
		transfer: function ()
		{
			if (this .getGeometryType () === 1)
			{
				var
					texCoords = this .getTexCoords (),
					vertices  = this .getVertices ();
	
				this .getMultiTexCoords () .push (texCoords);
	
				for (var i = 0, length = vertices .length; i < length; i += 8)
				{
					texCoords .push (vertices [i],
					                 vertices [i + 1],
					                 vertices [i + 2],
					                 vertices [i + 3],
					                 vertices [i],
					                 vertices [i + 1],
					                 vertices [i + 2],
					                 vertices [i + 3]);
				}
	
				texCoords .shrinkToFit ();
			}

			X3DGeometryNode .prototype .transfer .call (this);
		},
		display: function (gl, context)
		{
			try
			{
				var
					browser    = context .browser,
					shaderNode = context .shaderNode;

				if (! shaderNode .getCustom ())
					shaderNode = this .getShader (browser);

				if (shaderNode .getValid ())
				{
					var
						attribNodes   = this .attribNodes,
						attribBuffers = this .attribBuffers;

					// Setup shader.
		
					context .geometryType          = this .getGeometryType ();
					context .fogCoords             = this .fogCoords;
					context .colorMaterial         = this .colorMaterial;
					context .textureCoordinateNode = browser .getDefaultTextureCoordinate ();
	
					shaderNode .enable (gl);
					shaderNode .setLocalUniforms (gl, context);
		
					// Setup vertex attributes.
		
					for (var i = 0, length = attribNodes .length; i < length; ++ i)
						attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);
	
					if (this .fogCoords)
						shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer);
	
					if (this .colorMaterial)
						shaderNode .enableColorAttribute (gl, this .colorBuffer);

					if (this .getMultiTexCoords () .length)
						shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers, true);

					shaderNode .enableVertexAttribute (gl, this .vertexBuffer);
		
					// Wireframes are always solid so only one drawing call is needed.
	
					gl .drawArrays (shaderNode .primitiveMode === gl .POINTS ? gl .POINTS : this .primitiveMode, 0, this .vertexCount);
		
					for (var i = 0, length = attribNodes .length; i < length; ++ i)
						attribNodes [i] .disable (gl, shaderNode);
		
					if (this .fogCoords)
						shaderNode .disableFogDepthAttribute (gl);
	
					if (this .colorMaterial)
						shaderNode .disableColorAttribute (gl);
	
					shaderNode .disableTexCoordAttribute (gl);
					shaderNode .disable (gl);
				}
			}
			catch (error)
			{
				// Catch error from setLocalUniforms.
				console .log (error);
			}
		},
		displayParticles: function (gl, context, particles, numParticles)
		{
			try
			{
				var
					browser    = context .browser,
					shaderNode = context .shaderNode;

				if (! shaderNode .getCustom ())
					shaderNode = this .getShader (browser);

				if (shaderNode .getValid ())
				{
					var
						attribNodes   = this .attribNodes,
						attribBuffers = this .attribBuffers;

					// Setup shader.
		
					context .geometryType          = this .getGeometryType ();
					context .fogCoords             = this .fogCoords;
					context .colorMaterial         = this .colorMaterial;
					context .textureCoordinateNode = browser .getDefaultTextureCoordinate ();
	
					shaderNode .enable (gl);
					shaderNode .setLocalUniforms (gl, context);
		
					// Setup vertex attributes.
		
					for (var i = 0, length = attribNodes .length; i < length; ++ i)
						attribNodes [i] .enable (gl, shaderNode, attribBuffers [i]);
	
					if (this .fogCoords)
						shaderNode .enableFogDepthAttribute (gl, this .fogDepthBuffer);
	
					if (this .colorMaterial)
						shaderNode .enableColorAttribute (gl, this .colorBuffer);
		
					if (this .getMultiTexCoords () .length)
						shaderNode .enableTexCoordAttribute (gl, this .texCoordBuffers);
						
					shaderNode .enableVertexAttribute   (gl, this .vertexBuffer);

					// Wireframes are always solid so only one drawing call is needed.
		
					var
						modelViewMatrix = context .modelViewMatrix,
						x               = modelViewMatrix [12],
						y               = modelViewMatrix [13],
						z               = modelViewMatrix [14],
						primitiveMode   = shaderNode .primitiveMode === gl .POINTS ? gl .POINTS : this .primitiveMode;
		
					for (var p = 0; p < numParticles; ++ p)
					{
						modelViewMatrix [12] = x;
						modelViewMatrix [13] = y;
						modelViewMatrix [14] = z;
		
						Matrix4 .prototype .translate .call (modelViewMatrix, particles [p] .position);
		
						gl .uniformMatrix4fv (shaderNode .x3d_ModelViewMatrix, false, modelViewMatrix);
			
						gl .drawArrays (primitiveMode, 0, this .vertexCount);
					}
		
					for (var i = 0, length = attribNodes .length; i < length; ++ i)
						attribNodes [i] .disable (gl, shaderNode);
		
					if (this .fogCoords)
						shaderNode .disableFogDepthAttribute (gl);
	
					if (this .colorMaterial)
						shaderNode .disableColorAttribute (gl);
	
					shaderNode .disableTexCoordAttribute (gl);
					shaderNode .disable (gl);
				}
			}
			catch (error)
			{
				// Catch error from setLocalUniforms.
				console .log (error);
			}
		},
	});

	return X3DLineGeometryNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/IndexedLineSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DLineGeometryNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLineGeometryNode,
          X3DCast,
          X3DConstants)
{
"use strict";

	function IndexedLineSet (executionContext)
	{
		X3DLineGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .IndexedLineSet);

		this .setGeometryType (1);

		this .fogCoordNode = null;
		this .colorNode    = null;
		this .coordNode    = null;
	}

	IndexedLineSet .prototype = Object .assign (Object .create (X3DLineGeometryNode .prototype),
	{
		constructor: IndexedLineSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_colorIndex", new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_coordIndex", new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorIndex",     new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "coordIndex",     new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",         new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",          new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "IndexedLineSet";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DLineGeometryNode .prototype .initialize .call (this);

			this .set_colorIndex_ .addFieldInterest (this .colorIndex_);
			this .set_coordIndex_ .addFieldInterest (this .coordIndex_);
			this .attrib_         .addInterest ("set_attrib__",   this);
			this .fogCoord_       .addInterest ("set_fogCoord__", this);
			this .color_          .addInterest ("set_color__",    this);
			this .coord_          .addInterest ("set_coord__",    this);

			this .setPrimitiveMode (this .getBrowser () .getContext () .LINES);
			this .setSolid (false);

			this .set_attrib__ ();
			this .set_fogCoord__ ();
			this .set_color__ ();
			this .set_coord__ ();
		},
		set_attrib__: function ()
		{
			var attribNodes = this .getAttrib ();

			for (var i = 0, length = attribNodes .length; i < length; ++ i)
				attribNodes [i] .removeInterest ("requestRebuild", this);

			attribNodes .length = 0;

			for (var i = 0, length = this .attrib_ .length; i < length; ++ i)
			{
				var attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, this .attrib_ [i]);

				if (attribNode)
					attribNodes .push (attribNode);
			}

			for (var i = 0; i < this .attribNodes .length; ++ i)
				attribNodes [i] .addInterest ("requestRebuild", this);
		},
		set_fogCoord__: function ()
		{
			if (this .fogCoordNode)
				this .fogCoordNode .removeInterest ("requestRebuild", this);

			this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this .fogCoord_);

			if (this .fogCoordNode)
				this .fogCoordNode .addInterest ("requestRebuild", this);
		},
		set_color__: function ()
		{
			if (this .colorNode)
			{
				this .colorNode .removeInterest ("requestRebuild", this);
				this .colorNode .transparent_ .removeInterest ("set_transparent__", this);
			}

			this .colorNode = X3DCast (X3DConstants .X3DColorNode, this .color_);

			if (this .colorNode)
			{
				this .colorNode .addInterest ("requestRebuild", this);
				this .colorNode .transparent_ .addInterest ("set_transparent__", this);

				this .set_transparent__ ();
			}
			else
				this .setTransparent (false);
		},
		set_transparent__: function ()
		{
			this .setTransparent (this .colorNode .getTransparent ());
		},
		set_coord__: function ()
		{
			if (this .coordNode)
				this .coordNode .removeInterest ("requestRebuild", this);

			this .coordNode = X3DCast (X3DConstants .X3DCoordinateNode, this .coord_);

			if (this .coordNode)
				this .coordNode .addInterest ("requestRebuild", this);
		},
		getColorPerVertexIndex: function (index)
		{
			if (index < this .colorIndex_ .length)
				return this .colorIndex_ [index];

			return this .coordIndex_ [index];
		},
		getColorIndex: function (index)
		{
			if (index < this .colorIndex_ .length)
				return this .colorIndex_ [index];

			return index;
		},
		getPolylineIndices: function ()
		{
			var
				coordIndex = this .coordIndex_,
				polylines  = [ ],
				polyline   = [ ];

			if (coordIndex .length)
			{
				var i = 0;

				for (var i = 0, length = coordIndex .length; i < length; ++ i)
				{
					var index = coordIndex [i];

					if (index >= 0)
						// Add vertex.
						polyline .push (i);

					else
					{
						// Negativ index.
						// Add polylines.
						polylines .push (polyline);

						polyline = [ ];
					}
				}

				if (coordIndex [coordIndex .length - 1] >= 0)
				{
					polylines .push (polyline);
				}
			}

			return polylines;
		},
		build: function ()
		{
			if (! this .coordNode || this .coordNode .isEmpty ())
				return;

			var
				coordIndex     = this .coordIndex_,
				polylines      = this .getPolylineIndices (),
				colorPerVertex = this .colorPerVertex_ .getValue (),
				attribNodes    = this .getAttrib (),
				numAttrib      = attribNodes .length,
				attribs        = this .getAttribs (),
				fogCoordNode   = this .fogCoordNode,
				colorNode      = this .colorNode,
				coordNode      = this .coordNode,
				fogDepthArray  = this .getFogDepths (),
				colorArray     = this .getColors (),
				vertexArray    = this .getVertices ();

			// Fill GeometryNode

			var face = 0;

			for (var p = 0, pl = polylines .length; p < pl; ++ p)
			{
				var polyline = polylines [p];

				// Create two vertices for each line.

				if (polyline .length > 1)
				{
					for (var line = 0, l_end = polyline .length - 1; line < l_end; ++ line)
					{
						for (var l = line, i_end = line + 2; l < i_end; ++ l)
						{
							var
								i     = polyline [l],
								index = coordIndex [i];

							for (var a = 0; a < numAttrib; ++ a)
								attribNodes [a] .addValue (index, attribs [a]);

							if (fogCoordNode)
								fogCoordNode .addDepth (index, fogDepthArray);

							if (colorNode)
							{
								if (colorPerVertex)
									colorNode .addColor (this .getColorPerVertexIndex (i), colorArray);
								else
									colorNode .addColor (this .getColorIndex (face), colorArray);
							}

							coordNode .addPoint (index, vertexArray);
						}
					}
				}

				++ face;
			}
		},
	});

	return IndexedLineSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/IndexedTriangleFanSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DComposedGeometryNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants)
{
"use strict";

	function IndexedTriangleFanSet (executionContext)
	{
		X3DComposedGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .IndexedTriangleFanSet);

		this .triangleIndex = [ ];
	}

	IndexedTriangleFanSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
	{
		constructor: IndexedTriangleFanSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_index",       new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "index",           new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "IndexedTriangleFanSet";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DComposedGeometryNode .prototype .initialize .call (this);

			this .set_index_ .addFieldInterest (this .index_);
			this .index_     .addInterest ("set_index__", this);

			this .set_index__ ();
		},
		set_index__: function ()
		{
			// Build coordIndex

			var
				index         = this .index_,
				triangleIndex = this .triangleIndex;

			triangleIndex .length = 0;

			for (var i = 0, length = index .length; i < length; ++ i)
			{
				var first = index [i];

				if (first < 0)
					continue;

				if (++ i < length)
				{
					var second = index [i];

					if (second < 0)
						continue;

					for (++ i; i < length; ++ i)
					{
						var third = index [i];

						if (third < 0)
							break;

						triangleIndex .push (first, second, third);

						second = third;
					}
				}
			}
		},
		getPolygonIndex: function (index)
		{
			return this .triangleIndex [index];
		},
		build: function ()
		{
			X3DComposedGeometryNode .prototype .build .call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
		},
	});

	return IndexedTriangleFanSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/IndexedTriangleSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DComposedGeometryNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants)
{
"use strict";

	function IndexedTriangleSet (executionContext)
	{
		X3DComposedGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .IndexedTriangleSet);
	}

	IndexedTriangleSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
	{
		constructor: IndexedTriangleSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_index",       new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "index",           new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "IndexedTriangleSet";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		getPolygonIndex: function (i)
		{
			return this .index_ [i];
		},
		initialize: function ()
		{
			X3DComposedGeometryNode .prototype .initialize .call (this);

			this .set_index_ .addFieldInterest (this .index_);
		},
		build: function ()
		{
			X3DComposedGeometryNode .prototype .build .call (this, 3, this .index_ .length, 3, this .index_ .length);
		},
	});

	return IndexedTriangleSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/IndexedTriangleStripSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DComposedGeometryNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode,
          X3DConstants)
{
"use strict";

	function IndexedTriangleStripSet (executionContext)
	{
		X3DComposedGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .IndexedTriangleStripSet);

		this .triangleIndex = [ ];
	}

	IndexedTriangleStripSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
	{
		constructor: IndexedTriangleStripSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOnly,      "set_index",       new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "index",           new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "IndexedTriangleStripSet";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DComposedGeometryNode .prototype .initialize .call (this);

			this .set_index_ .addFieldInterest (this .index_);
			this .index_     .addInterest ("set_index__", this);

			this .set_index__ ();
		},
		set_index__: function ()
		{
			// Build coordIndex

			var
				index         = this .index_,
				triangleIndex = this .triangleIndex;

			triangleIndex .length = 0;

			// Build coordIndex

			for (var i = 0, length = index .length; i < length; ++ i)
			{
				var first = index [i];

				if (first < 0)
					continue;

				if (++ i < length)
				{
					var second = index [i];

					if (second < 0)
						continue;

					++ i;

					for (var face = 0; i < length; ++ i, ++ face)
					{
						var third = index [i];

						if (third < 0)
							break;

						triangleIndex .push (first, second, third);

						if (face & 1)
							second = third;

						else
							first = third;
					}
				}
			}
		},
		getPolygonIndex: function (index)
		{
			return this .triangleIndex [index];
		},
		build: function ()
		{
			X3DComposedGeometryNode .prototype .build .call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
		},
	});

	return IndexedTriangleStripSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/LineSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DLineGeometryNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLineGeometryNode,
          X3DCast,
          X3DConstants)
{
"use strict";

	function LineSet (executionContext)
	{
		X3DLineGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .LineSet);

		this .setGeometryType (1);

		this .fogCoordNode = null;
		this .colorNode    = null;
		this .coordNode    = null;
	}

	LineSet .prototype = Object .assign (Object .create (X3DLineGeometryNode .prototype),
	{
		constructor: LineSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",    new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "vertexCount", new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "attrib",      new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "fogCoord",    new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "color",       new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "coord",       new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "LineSet";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DLineGeometryNode .prototype .initialize .call (this);

			this .attrib_   .addInterest ("set_attrib__",   this);
			this .fogCoord_ .addInterest ("set_fogCoord__", this);
			this .color_    .addInterest ("set_color__",    this);
			this .coord_    .addInterest ("set_coord__",    this);

			this .setPrimitiveMode (this .getBrowser () .getContext () .LINES);
			this .setSolid (false);

			this .set_attrib__ ();
			this .set_fogCoord__ ();
			this .set_color__ ();
			this .set_coord__ ();
		},
		set_attrib__: function ()
		{
			var attribNodes = this .getAttrib ();

			for (var i = 0, length = attribNodes .length; i < length; ++ i)
				attribNodes [i] .removeInterest ("requestRebuild", this);

			attribNodes .length = 0;

			for (var i = 0, length = this .attrib_ .length; i < length; ++ i)
			{
				var attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, this .attrib_ [i]);

				if (attribNode)
					attribNodes .push (attribNode);
			}

			for (var i = 0; i < this .attribNodes .length; ++ i)
				attribNodes [i] .addInterest ("requestRebuild", this);
		},
		set_fogCoord__: function ()
		{
			if (this .fogCoordNode)
				this .fogCoordNode .removeInterest ("requestRebuild", this);

			this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this .fogCoord_);

			if (this .fogCoordNode)
				this .fogCoordNode .addInterest ("requestRebuild", this);
		},
		set_color__: function ()
		{
			if (this .colorNode)
			{
				this .colorNode .removeInterest ("requestRebuild", this);
				this .colorNode .transparent_ .removeInterest ("set_transparent__", this);
			}

			this .colorNode = X3DCast (X3DConstants .X3DColorNode, this .color_);

			if (this .colorNode)
			{
				this .colorNode .addInterest ("requestRebuild", this);
				this .colorNode .transparent_ .addInterest ("set_transparent__", this);

				this .set_transparent__ ();
			}
			else
				this .setTransparent (false);
		},
		set_transparent__: function ()
		{
			this .setTransparent (this .colorNode .getTransparent ());
		},
		set_coord__: function ()
		{
			if (this .coordNode)
				this .coordNode .removeInterest ("requestRebuild", this);

			this .coordNode = X3DCast (X3DConstants .X3DCoordinateNode, this .coord_);

			if (this .coordNode)
				this .coordNode .addInterest ("requestRebuild", this);
		},
		build: function ()
		{
			if (! this .coordNode || this .coordNode .isEmpty ())
				return;

			// Fill GeometryNode

			var
				vertexCount   = this .vertexCount_,
				attribNodes   = this .getAttrib (),
				numAttrib     = attribNodes .length,
				attribs       = this .getAttribs (),
				fogCoordNode  = this .fogCoordNode,
				colorNode     = this .colorNode,
				coordNode     = this .coordNode,
				fogDepthArray = this .getFogDepths (),
				colorArray    = this .getColors (),
				vertexArray   = this .getVertices (),
				size          = coordNode .getSize (),
				index         = 0;

			for (var c = 0, length = vertexCount .length; c < length; ++ c)
			{
				var count = vertexCount [c];

				if (index + count > size)
					break;

				if (count > 1)
				{
					count = 2 * count - 2; // numVertices for line lines trip

					for (var i = 0; i < count; ++ i, index += i & 1)
					{
						for (var a = 0; a < numAttrib; ++ a)
							attribNodes [a] .addValue (index, attribs [a]);

						if (fogCoordNode)
							fogCoordNode .addDepth (index, fogDepthArray);

						if (colorNode)
							colorNode .addColor (index, colorArray);

						coordNode .addPoint (index, vertexArray);
					}

					++ index;
				}
				else
					index += count;
			}
		},
	});

	return LineSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/X3DNormalNode',[
	"x_ite/Components/Rendering/X3DGeometricPropertyNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DGeometricPropertyNode, 
          X3DConstants)
{
"use strict";

	function X3DNormalNode (executionContext)
	{
		X3DGeometricPropertyNode .call (this, executionContext);

		this .addType (X3DConstants .X3DNormalNode);
	}

	X3DNormalNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
	{
		constructor: X3DNormalNode,
	});

	return X3DNormalNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/Normal',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DNormalNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DNormalNode,
          X3DConstants,
          Vector3)
{
"use strict";

	function Normal (executionContext)
	{
		X3DNormalNode .call (this, executionContext);

		this .addType (X3DConstants .Normal);
	}

	Normal .prototype = Object .assign (Object .create (X3DNormalNode .prototype),
	{
		constructor: Normal,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "vector",   new Fields .MFVec3f ()),
		]),
		getTypeName: function ()
		{
			return "Normal";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "normal";
		},
		initialize: function ()
		{
			X3DNormalNode .prototype .initialize .call (this);

			this .vector_ .addInterest ("set_vector__", this);

			this .set_vector__ ();
		},
		set_vector__: function ()
		{
			this .vector = this .vector_ .getValue ();
			this .length = this .vector_ .length;
		},
		set1Vector: function (index, vector)
		{
			this .vector_ [index] = vector;
		},
		get1Vector: function (index, result)
		{
			if (index >= 0 && index < this .length)
			{
				const vector = this .vector;

				index *= 3;

				return result .set (vector [index], vector [index + 1], vector [index + 2]);
			}
			else if (index >= 0 && this .length)
			{
				const vector = this .vector;

				index %= this .length;
				index *= 3;

				return result .set (vector [index], vector [index + 1], vector [index + 2]);
			}
			else
			{
				return result .set (0, 0, 0);
			}
		},
		addVector: function (index, array)
		{
			if (index >= 0 && index < this .length)
			{
				const vector = this .vector;

				index *= 3;

				array .push (vector [index], vector [index + 1], vector [index + 2]);
			}
			else if (index >= 0 && this .length)
			{
				const vector = this .vector;

				index %= this .length;
				index *= 3;

				array .push (vector [index], vector [index + 1], vector [index + 2]);
			}
			else
			{
				return array .push (0, 0, 0);
			}
		},
	});

	return Normal;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/PointSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DLineGeometryNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DLineGeometryNode,
          X3DCast,
          X3DConstants)
{
"use strict";

	function PointSet (executionContext)
	{
		X3DLineGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .PointSet);

		this .setGeometryType (0);
		this .setTransparent (true);

		this .fogCoordNode = null;
		this .colorNode    = null;
		this .coordNode    = null;
	}

	PointSet .prototype = Object .assign (Object .create (X3DLineGeometryNode .prototype),
	{
		constructor: PointSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "attrib",   new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "fogCoord", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "color",    new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "coord",    new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "PointSet";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DLineGeometryNode .prototype .initialize .call (this);

			this .attrib_   .addInterest ("set_attrib__",   this);
			this .fogCoord_ .addInterest ("set_fogCoord__", this);
			this .color_    .addInterest ("set_color__",    this);
			this .coord_    .addInterest ("set_coord__",    this);

			var browser = this .getBrowser ();

			this .setPrimitiveMode (browser .getContext () .POINTS);
			this .setSolid (false);

			this .set_attrib__ ();
			this .set_fogCoord__ ();
			this .set_color__ ();
			this .set_coord__ ();
		},
		getShader: function (browser)
		{
			return browser .getPointShader ();
		},
		getCoord: function ()
		{
			return this .coordNode;
		},
		set_attrib__: function ()
		{
			var attribNodes = this .getAttrib ();

			for (var i = 0, length = attribNodes .length; i < length; ++ i)
				attribNodes [i] .removeInterest ("requestRebuild", this);

			attribNodes .length = 0;

			for (var i = 0, length = this .attrib_ .length; i < length; ++ i)
			{
				var attribNode = X3DCast (X3DConstants .X3DVertexAttributeNode, this .attrib_ [i]);

				if (attribNode)
					attribNodes .push (attribNode);
			}

			for (var i = 0; i < this .attribNodes .length; ++ i)
				attribNodes [i] .addInterest ("requestRebuild", this);
		},
		set_fogCoord__: function ()
		{
			if (this .fogCoordNode)
				this .fogCoordNode .removeInterest ("requestRebuild", this);

			this .fogCoordNode = X3DCast (X3DConstants .FogCoordinate, this .fogCoord_);

			if (this .fogCoordNode)
				this .fogCoordNode .addInterest ("requestRebuild", this);
		},
		set_color__: function ()
		{
			if (this .colorNode)
				this .colorNode .removeInterest ("requestRebuild", this);

			this .colorNode = X3DCast (X3DConstants .X3DColorNode, this .color_);

			if (this .colorNode)
				this .colorNode .addInterest ("requestRebuild", this);
		},
		set_coord__: function ()
		{
			if (this .coordNode)
				this .coordNode .removeInterest ("requestRebuild", this);

			this .coordNode = X3DCast (X3DConstants .X3DCoordinateNode, this .coord_);

			if (this .coordNode)
				this .coordNode .addInterest ("requestRebuild", this);
		},
		build: function ()
		{
			if (! this .coordNode || this .coordNode .isEmpty ())
				return;

			var
				attribNodes   = this .getAttrib (),
				numAttrib     = attribNodes .length,
				attribs       = this .getAttribs (),
				fogCoordNode  = this .fogCoordNode,
				colorNode     = this .colorNode,
				coordNode     = this .coordNode,
				fogDepthArray = this .getFogDepths (),
				colorArray    = this .getColors (),
				vertexArray   = this .getVertices (),
				numPoints     = coordNode .point_ .length;

			for (var a = 0; a < numAttrib; ++ a)
			{
				for (var i = 0; i < numPoints; ++ i)
					attribNodes [a] .addValue (i, attribs [a]);
			}

			if (fogCoordNode)
				fogCoordNode .addDepths (fogDepthArray, numPoints);

			if (colorNode)
				colorNode .addColors (colorArray, numPoints);

			coordNode .addPoints (vertexArray, numPoints);
		},
	});

	return PointSet;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/TriangleFanSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DComposedGeometryNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode, 
          X3DConstants)
{
"use strict";

	function TriangleFanSet (executionContext)
	{
		X3DComposedGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .TriangleFanSet);

		this .triangleIndex = [ ];
	}

	TriangleFanSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
	{
		constructor: TriangleFanSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fanCount",        new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "TriangleFanSet";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DComposedGeometryNode .prototype .initialize .call (this);
		
			this .fanCount_ .addInterest ("set_fanCount__", this);
		
			this .set_fanCount__ ();
		},
		set_fanCount__: function ()
		{
			// Build coordIndex

			var
				fanCount      = this .fanCount_,
				triangleIndex = this .triangleIndex;
		
			triangleIndex .length = 0;

			for (var f = 0, fans = fanCount .length, index = 0; f < fans; ++ f)
			{
				var vertexCount = fanCount [f];

				for (var i = 1, count = vertexCount - 1; i < count; ++ i)
				{
					triangleIndex .push (index, index + i, index + i + 1);
				}
		
				index += vertexCount;
			}
		},
		getPolygonIndex: function (index)
		{
			return this .triangleIndex [index];
		},
		build: function ()
		{
			X3DComposedGeometryNode .prototype .build .call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
		},
	});

	return TriangleFanSet;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/TriangleSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DComposedGeometryNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode, 
          X3DConstants)
{
"use strict";

	function TriangleSet (executionContext)
	{
		X3DComposedGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .TriangleSet);
	}

	TriangleSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
	{
		constructor: TriangleSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "TriangleSet";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		build: function ()
		{
			if (! this .getCoord ())
				return;

			X3DComposedGeometryNode .prototype .build .call (this, 3, this .getCoord () .getSize (), 3, this .getCoord () .getSize ());
		},
		createNormals: function (verticesPerPolygon, polygonsSize)
		{
			return this .createFaceNormals (verticesPerPolygon, polygonsSize);
		},
	});

	return TriangleSet;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering/TriangleStripSet',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DComposedGeometryNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DComposedGeometryNode, 
          X3DConstants)
{
"use strict";

	function TriangleStripSet (executionContext)
	{
		X3DComposedGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .TriangleStripSet);

		this .triangleIndex = [ ];
	}

	TriangleStripSet .prototype = Object .assign (Object .create (X3DComposedGeometryNode .prototype),
	{
		constructor: TriangleStripSet,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "ccw",             new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "colorPerVertex",  new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "normalPerVertex", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "stripCount",      new Fields .MFInt32 ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "attrib",          new Fields .MFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fogCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "color",           new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "texCoord",        new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "normal",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "coord",           new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "TriangleStripSet";
		},
		getComponentName: function ()
		{
			return "Rendering";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DComposedGeometryNode .prototype .initialize .call (this);
		
			this .stripCount_ .addInterest ("set_stripCount__", this);
		
			this .set_stripCount__ ();
		},
		set_stripCount__: function ()
		{
			// Build coordIndex

			var
				stripCount    = this .stripCount_,
				triangleIndex = this .triangleIndex;

			triangleIndex .length = 0;

			for (var s = 0, strips = stripCount .length, index = 0; s < strips; ++ s)
			{
				var vertexCount = stripCount [s];

				for (var i = 0, count = vertexCount - 2; i < count; ++ i)
				{
					var is_odd = i & 1;

					triangleIndex .push (index + (is_odd ? i + 1 : i),
					                     index + (is_odd ? i : i + 1),
					                     index + (i + 2));
				}

				index += vertexCount;
			}
		},
		getPolygonIndex: function (index)
		{
			return this .triangleIndex [index];
		},
		build: function ()
		{
			X3DComposedGeometryNode .prototype .build .call (this, 3, this .triangleIndex .length, 3, this .triangleIndex .length);
		},
	});

	return TriangleStripSet;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Rendering',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Rendering/ClipPlane",
	"x_ite/Components/Rendering/Color",
	"x_ite/Components/Rendering/ColorRGBA",
	"x_ite/Components/Rendering/Coordinate",
	"x_ite/Components/Rendering/IndexedLineSet",
	"x_ite/Components/Rendering/IndexedTriangleFanSet",
	"x_ite/Components/Rendering/IndexedTriangleSet",
	"x_ite/Components/Rendering/IndexedTriangleStripSet",
	"x_ite/Components/Rendering/LineSet",
	"x_ite/Components/Rendering/Normal",
	"x_ite/Components/Rendering/PointSet",
	"x_ite/Components/Rendering/TriangleFanSet",
	"x_ite/Components/Rendering/TriangleSet",
	"x_ite/Components/Rendering/TriangleStripSet",
	"x_ite/Components/Rendering/X3DColorNode",
	"x_ite/Components/Rendering/X3DComposedGeometryNode",
	"x_ite/Components/Rendering/X3DCoordinateNode",
	"x_ite/Components/Rendering/X3DGeometricPropertyNode",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Components/Rendering/X3DLineGeometryNode",
	"x_ite/Components/Rendering/X3DNormalNode",
],
function (SupportedNodes,
          ClipPlane,
          Color,
          ColorRGBA,
          Coordinate,
          IndexedLineSet,
          IndexedTriangleFanSet,
          IndexedTriangleSet,
          IndexedTriangleStripSet,
          LineSet,
          Normal,
          PointSet,
          TriangleFanSet,
          TriangleSet,
          TriangleStripSet,
          X3DColorNode,
          X3DComposedGeometryNode,
          X3DCoordinateNode,
          X3DGeometricPropertyNode,
          X3DGeometryNode,
          X3DLineGeometryNode,
          X3DNormalNode)
{
"use strict";

	var Types =
	{
		ClipPlane:               ClipPlane,
		Color:                   Color,
		ColorRGBA:               ColorRGBA,
		Coordinate:              Coordinate,
		IndexedLineSet:          IndexedLineSet,
		IndexedTriangleFanSet:   IndexedTriangleFanSet,
		IndexedTriangleSet:      IndexedTriangleSet,
		IndexedTriangleStripSet: IndexedTriangleStripSet,
		LineSet:                 LineSet,
		Normal:                  Normal,
		PointSet:                PointSet,
		TriangleFanSet:          TriangleFanSet,
		TriangleSet:             TriangleSet,
		TriangleStripSet:        TriangleStripSet,
	};

	var AbstractTypes =
	{
		X3DColorNode:             X3DColorNode,
		X3DComposedGeometryNode:  X3DComposedGeometryNode,
		X3DCoordinateNode:        X3DCoordinateNode,
		X3DGeometricPropertyNode: X3DGeometricPropertyNode,
		X3DGeometryNode:          X3DGeometryNode,
		X3DLineGeometryNode:      X3DLineGeometryNode,
		X3DNormalNode:            X3DNormalNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/X3DVertexAttributeNode',[
	"x_ite/Components/Rendering/X3DGeometricPropertyNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DGeometricPropertyNode, 
          X3DConstants)
{
"use strict";

	function X3DVertexAttributeNode (executionContext)
	{
		X3DGeometricPropertyNode .call (this, executionContext);

		this .addType (X3DConstants .X3DVertexAttributeNode);
	}

	X3DVertexAttributeNode .prototype = Object .assign (Object .create (X3DGeometricPropertyNode .prototype),
	{
		constructor: X3DVertexAttributeNode,
	});

	return X3DVertexAttributeNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/FloatVertexAttribute',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shaders/X3DVertexAttributeNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DVertexAttributeNode,
          X3DConstants,
          Algorithm)
{
"use strict";

	function FloatVertexAttribute (executionContext)
	{
		X3DVertexAttributeNode .call (this, executionContext);

		this .addType (X3DConstants .FloatVertexAttribute);
	}

	FloatVertexAttribute .prototype = Object .assign (Object .create (X3DVertexAttributeNode .prototype),
	{
		constructor: FloatVertexAttribute,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",      new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "name",          new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "numComponents", new Fields .SFInt32 (4)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "value",         new Fields .MFFloat ()),
		]),
		getTypeName: function ()
		{
			return "FloatVertexAttribute";
		},
		getComponentName: function ()
		{
			return "Shaders";
		},
		getContainerField: function ()
		{
			return "attrib";
		},
		initialize: function ()
		{
			X3DVertexAttributeNode .prototype .initialize .call (this);

			this .numComponents_ .addInterest ("set_numComponents", this);
			this .value_         .addInterest ("set_value",         this);

			this .set_numComponents ();
			this .set_value ();
		},
		set_numComponents: function ()
		{
			this .numComponents = Algorithm .clamp (this .numComponents_ .getValue (), 1, 4);
		},
		set_value: function ()
		{
			this .value  = this .value_ .getValue ();
			this .length = this .value_ .length;
		},
		addValue: function (index, array)
		{
			var
				value = this .value,
				first = index * this .numComponents,
				last  = first + this .numComponents;

			if (last <= this .length)
			{
				for (; first < last; ++ first)
					array .push (value [first]);
			}
			else if (this .numComponents <= this .length)
			{
				last  = value .length;
				first = last - this .numComponents;

				for (; first < last; ++ first)
					array .push (value [first]);
			}
			else
			{
				for (; first < last; ++ first)
					array .push (0);
			}
		},
		enable: function (gl, shaderNode, buffer)
		{
			shaderNode .enableFloatAttrib (gl, this .name_ .getValue (), buffer, this .numComponents);
		},
		disable: function (gl, shaderNode)
		{
			shaderNode .disableFloatAttrib (gl, this .name_ .getValue ());
		},
	});

	return FloatVertexAttribute;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/Matrix3VertexAttribute',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shaders/X3DVertexAttributeNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Matrix3",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DVertexAttributeNode,
          X3DConstants,
          Matrix3)
{
"use strict";

	function Matrix3VertexAttribute (executionContext)
	{
		X3DVertexAttributeNode .call (this, executionContext);

		this .addType (X3DConstants .Matrix3VertexAttribute);
	}

	Matrix3VertexAttribute .prototype = Object .assign (Object .create (X3DVertexAttributeNode .prototype),
	{
		constructor: Matrix3VertexAttribute,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "name",     new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "value",    new Fields .MFMatrix3f ()),
		]),
		getTypeName: function ()
		{
			return "Matrix3VertexAttribute";
		},
		getComponentName: function ()
		{
			return "Shaders";
		},
		getContainerField: function ()
		{
			return "attrib";
		},
		initialize: function ()
		{
			X3DVertexAttributeNode .prototype .initialize .call (this);

			this .value_ .addInterest ("set_value", this);

			this .set_value ();
		},
		set_value: function ()
		{
			this .value  = this .value_ .getValue ();
			this .length = this .value_ .length;
		},
		addValue: function (index, array)
		{
			if (index < this .length)
			{
				var value = this .value;

				for (var i = index * 9, l = i + 9; i < l; ++ i)
					array .push (value [i]);
			}
			else if (this .length)
			{
				var value = this .value;

				index = this .length - 1;

				for (var i = index * 9, l = i + 9; i < l; ++ i)
					array .push (value [i]);
			}
			else
			{
				var value = Matrix3 .Identity;

				for (var i = 0; i < 9; ++ i)
					array .push (value [i]);
			}
		},
		enable: function (gl, shaderNode, buffer)
		{
			shaderNode .enableMatrix3Attrib (gl, this .name_ .getValue (), buffer);
		},
		disable: function (gl, shaderNode)
		{
			shaderNode .disableMatrix3Attrib (gl, this .name_ .getValue ());
		},
	});

	return Matrix3VertexAttribute;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders/Matrix4VertexAttribute',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shaders/X3DVertexAttributeNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DVertexAttributeNode,
          X3DConstants)
{
"use strict";

	function Matrix4VertexAttribute (executionContext)
	{
		X3DVertexAttributeNode .call (this, executionContext);

		this .addType (X3DConstants .Matrix4VertexAttribute);
	}

	Matrix4VertexAttribute .prototype = Object .assign (Object .create (X3DVertexAttributeNode .prototype),
	{
		constructor: Matrix4VertexAttribute,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "name",     new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "value",    new Fields .MFMatrix4f ()),
		]),
		getTypeName: function ()
		{
			return "Matrix4VertexAttribute";
		},
		getComponentName: function ()
		{
			return "Shaders";
		},
		getContainerField: function ()
		{
			return "attrib";
		},
		initialize: function ()
		{
			X3DVertexAttributeNode .prototype .initialize .call (this);

			this .value_ .addInterest ("set_value", this);

			this .set_value ();
		},
		set_value: function ()
		{
			this .value  = this .value_ .getValue ();
			this .length = this .value_ .length;
		},
		addValue: function (index, array)
		{
			if (index < this .length)
			{
				var value = this .value;

				for (var i = index * 16, l = i + 16; i < l; ++ i)
					array .push (value [i]);
			}
			else if (this .length)
			{
				var value = this .value;

				index = this .length - 1;

				for (var i = index * 16, l = i + 16; i < l; ++ i)
					array .push (value [i]);
			}
			else
			{
				var value = Matrix4 .Identity;

				for (var i = 0; i < 16; ++ i)
					array .push (value [i]);
			}
		},
		enable: function (gl, shaderNode, buffer)
		{
			shaderNode .enableMatrix4Attrib (gl, this .name_ .getValue (), buffer);
		},
		disable: function (gl, shaderNode)
		{
			shaderNode .disableMatrix4Attrib (gl, this .name_ .getValue ());
		},
	});

	return Matrix4VertexAttribute;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shaders',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Shaders/ComposedShader",
	"x_ite/Components/Shaders/FloatVertexAttribute",
	"x_ite/Components/Shaders/Matrix3VertexAttribute",
	"x_ite/Components/Shaders/Matrix4VertexAttribute",
//	"x_ite/Components/Shaders/PackagedShader",
//	"x_ite/Components/Shaders/ProgramShader",
	"x_ite/Components/Shaders/ShaderPart",
//	"x_ite/Components/Shaders/ShaderProgram",
	"x_ite/Components/Shaders/X3DProgrammableShaderObject",
	"x_ite/Components/Shaders/X3DShaderNode",
	"x_ite/Components/Shaders/X3DVertexAttributeNode",
],
function (SupportedNodes,
          ComposedShader,
          FloatVertexAttribute,
          Matrix3VertexAttribute,
          Matrix4VertexAttribute,
//          PackagedShader,
//          ProgramShader,
          ShaderPart,
//          ShaderProgram,
          X3DProgrammableShaderObject,
          X3DShaderNode,
          X3DVertexAttributeNode)
{
"use strict";

	var Types =
	{
		ComposedShader:         ComposedShader,
		FloatVertexAttribute:   FloatVertexAttribute,
		Matrix3VertexAttribute: Matrix3VertexAttribute,
		Matrix4VertexAttribute: Matrix4VertexAttribute,
//		PackagedShader:         PackagedShader,
//		ProgramShader:          ProgramShader,
		ShaderPart:             ShaderPart,
//		ShaderProgram:          ShaderProgram,
	};

	var AbstractTypes =
	{
		X3DProgrammableShaderObject: X3DProgrammableShaderObject,
		X3DShaderNode:               X3DShaderNode,
		X3DVertexAttributeNode:      X3DVertexAttributeNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/X3DMaterialNode',[
	"x_ite/Fields",
	"x_ite/Components/Shape/X3DAppearanceChildNode",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DAppearanceChildNode, 
          X3DConstants)
{
"use strict";

	function X3DMaterialNode (executionContext)
	{
		X3DAppearanceChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DMaterialNode);

		this .addChildObjects ("transparent", new Fields .SFBool ());

		this .transparent_ .setAccessType (X3DConstants .outputOnly);
	}

	X3DMaterialNode .prototype = Object .assign (Object .create (X3DAppearanceChildNode .prototype),
	{
		constructor: X3DMaterialNode,
		setTransparent: function (value)
		{
			if (value !== this .transparent_ .getValue ())
				this .transparent_ = value;
		},
		getTransparent: function ()
		{
			return this .transparent_ .getValue ();
		},
	});

	return X3DMaterialNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/Material',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shape/X3DMaterialNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DMaterialNode, 
          X3DConstants,
          Algorithm)
{
"use strict";

	function Material (executionContext)
	{
		X3DMaterialNode .call (this, executionContext);

		this .addType (X3DConstants .Material);

		this .diffuseColor  = new Float32Array (3);
		this .specularColor = new Float32Array (3);
		this .emissiveColor = new Float32Array (3);
	}

	Material .prototype = Object .assign (Object .create (X3DMaterialNode .prototype),
	{
		constructor: Material,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "ambientIntensity", new Fields .SFFloat (0.2)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "diffuseColor",     new Fields .SFColor (0.8, 0.8, 0.8)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "specularColor",    new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveColor",    new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "shininess",        new Fields .SFFloat (0.2)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "transparency",     new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "Material";
		},
		getComponentName: function ()
		{
			return "Shape";
		},
		getContainerField: function ()
		{
			return "material";
		},
		initialize: function ()
		{
			X3DMaterialNode .prototype .initialize .call (this);

			this .ambientIntensity_ .addInterest ("set_ambientIntensity__", this);
			this .diffuseColor_     .addInterest ("set_diffuseColor__",     this);
			this .specularColor_    .addInterest ("set_specularColor__",    this);
			this .emissiveColor_    .addInterest ("set_emissiveColor__",    this);
			this .shininess_        .addInterest ("set_shininess__",        this);
			this .transparency_     .addInterest ("set_transparency__",     this);
	
			this .set_ambientIntensity__ ();
			this .set_diffuseColor__ ();
			this .set_specularColor__ ();
			this .set_emissiveColor__ ();
			this .set_shininess__ ();
			this .set_transparency__ ();
		},
		set_ambientIntensity__: function ()
		{
			this .ambientIntensity = Math .max (this .ambientIntensity_ .getValue (), 0);
		},
		set_diffuseColor__: function ()
		{
			//We cannot use this in Windows Edge:
			//this .diffuseColor .set (this .diffuseColor_ .getValue ());
			
			var
				diffuseColor  = this .diffuseColor,
				diffuseColor_ = this .diffuseColor_ .getValue ();
			
			diffuseColor [0] = diffuseColor_ .r;
			diffuseColor [1] = diffuseColor_ .g;
			diffuseColor [2] = diffuseColor_ .b;
		},
		set_specularColor__: function ()
		{
			//We cannot use this in Windows Edge:
			//this .specularColor .set (this .specularColor_ .getValue ());
			
			var
				specularColor  = this .specularColor,
				specularColor_ = this .specularColor_ .getValue ();
			
			specularColor [0] = specularColor_ .r;
			specularColor [1] = specularColor_ .g;
			specularColor [2] = specularColor_ .b;
		},
		set_emissiveColor__: function ()
		{
			//We cannot use this in Windows Edge:
			//this .emissiveColor .set (this .emissiveColor_ .getValue ());
			
			var
				emissiveColor  = this .emissiveColor,
				emissiveColor_ = this .emissiveColor_ .getValue ();
			
			emissiveColor [0] = emissiveColor_ .r;
			emissiveColor [1] = emissiveColor_ .g;
			emissiveColor [2] = emissiveColor_ .b;
		},
		set_shininess__: function ()
		{
			this .shininess = Algorithm .clamp (this .shininess_ .getValue (), 0, 1);
		},
		set_transparency__: function ()
		{
			var transparency = Algorithm .clamp (this .transparency_ .getValue (), 0, 1);

			this .transparency = transparency;

			this .setTransparent (Boolean (transparency));
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			gl .uniform1i  (shaderObject .x3d_SeparateBackColor, false);
			gl .uniform1f  (shaderObject .x3d_AmbientIntensity,  this .ambientIntensity);
			gl .uniform3fv (shaderObject .x3d_DiffuseColor,      this .diffuseColor);
			gl .uniform3fv (shaderObject .x3d_SpecularColor,     this .specularColor);
			gl .uniform3fv (shaderObject .x3d_EmissiveColor,     this .emissiveColor);
			gl .uniform1f  (shaderObject .x3d_Shininess,         this .shininess);
			gl .uniform1f  (shaderObject .x3d_Transparency,      this .transparency);
		},
	});

	return Material;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/X3DShapeNode',[
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Components/Grouping/X3DBoundedObject",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Geometry/Box3",
	"standard/Math/Numbers/Vector3",
],
function (X3DChildNode, 
          X3DBoundedObject,
          X3DCast,
          X3DConstants,
          Box3,
          Vector3)
{
"use strict";

	function X3DShapeNode (executionContext)
	{
		X3DChildNode     .call (this, executionContext);
		X3DBoundedObject .call (this, executionContext);

		this .addType (X3DConstants .X3DShapeNode);

		this .bbox       = new Box3 ();
		this .bboxSize   = new Vector3 (0, 0, 0);
		this .bboxCenter = new Vector3 (0, 0, 0);
	}

	X3DShapeNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
		X3DBoundedObject .prototype,
	{
		constructor: X3DShapeNode,
		initialize: function ()
		{
			X3DChildNode     .prototype .initialize .call (this);
			X3DBoundedObject .prototype .initialize .call (this);

			this .bboxSize_   .addInterest ("set_bbox__", this);
			this .bboxCenter_ .addInterest ("set_bbox__", this);
			this .appearance_ .addInterest ("set_apparance__", this);
			this .geometry_   .addInterest ("set_geometry__", this);

			this .set_apparance__ ();
			this .set_geometry__ ();
		},
		getBBox: function (bbox)
		{
			return bbox .assign (this .bbox);
		},
		getBBoxSize: function ()
		{
			return this .bboxSize;
		},
		getBBoxCenter: function ()
		{
			return this .bboxCenter;
		},
		getAppearance: function ()
		{
			return this .apparanceNode;
		},
		getGeometry: function ()
		{
			return this .geometryNode;
		},
		setTransparent: function (value)
		{
			this .transparent = value;
		},
		getTransparent: function ()
		{
			return this .transparent;
		},
		set_bbox__: function ()
		{
			if (this .bboxSize_ .getValue () .equals (this .getDefaultBBoxSize ()))
			{
				if (this .getGeometry ())
					this .bbox .assign (this .getGeometry () .getBBox ());

				else
					this .bbox .set ();
			}
			else
				this .bbox .set (this .bboxSize_ .getValue (), this .bboxCenter_ .getValue ());

			this .bboxSize   .assign (this .bbox .size);
			this .bboxCenter .assign (this .bbox .center);
		},
		set_apparance__: function ()
		{
			if (this .apparanceNode)
				this .apparanceNode .transparent_ .removeInterest ("set_transparent__", this);

			this .apparanceNode = X3DCast (X3DConstants .X3DAppearanceNode, this .appearance_);

			if (this .apparanceNode)
				this .apparanceNode .transparent_ .addInterest ("set_transparent__", this);

			else
				this .apparanceNode = this .getBrowser () .getDefaultAppearance ();

			this .set_transparent__ ();
		},
		set_geometry__: function ()
		{
			if (this .geometryNode)
			{
				this .geometryNode .transparent_  .addInterest ("set_transparent__", this);
				this .geometryNode .bbox_changed_ .addInterest ("set_bbox__",        this);
			}

			this .geometryNode = X3DCast (X3DConstants .X3DGeometryNode, this .geometry_);

			if (this .geometryNode)
			{
				this .geometryNode .transparent_  .addInterest ("set_transparent__", this);
				this .geometryNode .bbox_changed_ .addInterest ("set_bbox__",        this);
			}

			this .set_transparent__ ();
			this .set_bbox__ ();
		},
		set_transparent__: function ()
		{
			this .transparent = (this .apparanceNode && this .apparanceNode .getTransparent ()) ||
			                    (this .geometryNode  && this .geometryNode  .getTransparent ());
		},
	});

	return X3DShapeNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('standard/Math/Algorithms/QuickSort',[],function ()
{
"use strict";

	function QuickSort (array, compare)
	{
		this .array = array;
		
		if (compare)
			this .compare = compare;
	}

	QuickSort .prototype =
	{
		compare: function (lhs, rhs)
		{
			return lhs < rhs;
		},
		sort: function (first, last)
		{
			if (last - first > 1)
				this .quicksort (first, last - 1);
		},
		quicksort: function (lo, hi)
		{
			var
				i = lo,
				j = hi,
				array   = this .array,
				compare = this .compare;

			// Vergleichs­element x
			var x = array [(lo + hi) >>> 1];

			for (;;)
			{
				while (compare (array [i], x)) ++ i;
				while (compare (x, array [j])) -- j;

				if (i < j)
				{
					// Exchange
					
					var t = array [i];
					array [i] = array [j];
					array [j] = t;

					i ++; j --;
				}
				else
				{
					if (i === j) ++ i, -- j;
					break;
				}
			}

			// Rekursion
			if (lo < j) this .quicksort (lo, j);
			if (i < hi) this .quicksort (i, hi);
		},
	};

	return QuickSort;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/Shape',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shape/X3DShapeNode",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Box3",
	"standard/Math/Geometry/Line3",
	"standard/Math/Algorithms/QuickSort",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DShapeNode,
          TraverseType,
          X3DConstants,
          Algorithm,
          Vector3,
          Matrix4,
          Box3,
          Line3,
          QuickSort)
{
"use strict";

	function Shape (executionContext)
	{
		X3DShapeNode .call (this, executionContext);

		this .addType (X3DConstants .Shape);
	}

	Shape .prototype = Object .assign (Object .create (X3DShapeNode .prototype),
	{
		constructor: Shape,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxSize",   new Fields .SFVec3f (-1, -1, -1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "bboxCenter", new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "appearance", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "geometry",   new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "Shape";
		},
		getComponentName: function ()
		{
			return "Shape";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DShapeNode .prototype .initialize .call (this);

			this .transformSensors_changed_ .addInterest ("set_transformSensors__", this);

			this .set_transformSensors__ ();
		},
		set_geometry__: function ()
		{
			X3DShapeNode .prototype .set_geometry__ .call (this);

			if (this .getGeometry ())
				delete this .traverse;
			else
				this .traverse = Function .prototype;
		},
		set_transformSensors__: function ()
		{
			this .setPickableObject (this .getTransformSensors () .size);
		},
		intersectsBox: function (box, clipPlanes, modelViewMatrix)
		{
			return this .getGeometry () .intersectsBox (box, clipPlanes, modelViewMatrix);
		},
		traverse: function (type, renderObject)
		{
			// Always look at ParticleSystem if you do modify something here and there.

			switch (type)
			{
				case TraverseType .POINTER:
				{
					this .pointer (renderObject);
					break;
				}
				case TraverseType .PICKING:
				{
					this .picking (renderObject);
					break;
				}
				case TraverseType .COLLISION:
				{
					renderObject .addCollisionShape (this);
					break;
				}
				case TraverseType .DEPTH:
				{
					renderObject .addDepthShape (this);
					break;
				}
				case TraverseType .DISPLAY:
				{
					if (renderObject .addDisplayShape (this))
						this .getAppearance () .traverse (type, renderObject); // Currently used for GeneratedCubeMapTexture.

					break;
				}
			}

			this .getGeometry () .traverse (type, renderObject); // Currently used for ScreenText.
		},
		pointer: (function ()
		{
			var
				modelViewMatrix    = new Matrix4 (),
				invModelViewMatrix = new Matrix4 (),
				hitRay             = new Line3 (new Vector3 (0, 0, 0), new Vector3 (0, 0, 0)),
				intersections      = [ ],
				intersectionSorter = new QuickSort (intersections, function (lhs, rhs)
				{
					return lhs .point .z > rhs .point .z;
				});

			return function (renderObject)
			{
				try
				{
					var geometry = this .getGeometry ();

					if (geometry .getGeometryType () < 2)
						return;

					var browser = renderObject .getBrowser ();

					modelViewMatrix    .assign (renderObject .getModelViewMatrix () .get ());
					invModelViewMatrix .assign (modelViewMatrix) .inverse ();

					hitRay .assign (browser .getHitRay ()) .multLineMatrix (invModelViewMatrix);

					if (geometry .intersectsLine (hitRay, renderObject .getLocalObjects (), modelViewMatrix, intersections))
					{
						// Finally we have intersections and must now find the closest hit in front of the camera.

						// Transform hitPoints to absolute space.
						for (var i = 0; i < intersections .length; ++ i)
							modelViewMatrix .multVecMatrix (intersections [i] .point);

						intersectionSorter .sort (0, intersections .length);

						// Find first point that is not greater than near plane;
						var index = Algorithm .lowerBound (intersections, 0, intersections .length, -renderObject .getNavigationInfo () .getNearValue (),
						function (lhs, rhs)
						{
						   return lhs .point .z > rhs;
						});

						// Are there intersections before the camera?
						if (index !== intersections .length)
						{
							// Transform hitNormal to absolute space.
							invModelViewMatrix .multMatrixDir (intersections [index] .normal) .normalize ();

							browser .addHit (intersections [index], renderObject .getLayer (), this, modelViewMatrix .multRight (renderObject .getCameraSpaceMatrix () .get ()));
						}

						intersections .length = 0;
					}
				}
				catch (error)
				{
					console .log (error);
				}
			};
		})(),
		picking: (function ()
		{
			var bbox = new Box3 ();

			return function (renderObject)
			{
				if (this .getTransformSensors () .size)
				{
					this .getBBox (bbox) .multRight (renderObject .getModelViewMatrix () .get ());

					this .getTransformSensors () .forEach (function (transformSensorNode)
					{
						transformSensorNode .collect (bbox);
					});
				}

				var
					browser          = renderObject .getBrowser (),
					pickSensorStack  = browser .getPickSensors (),
					pickingHierarchy = browser .getPickingHierarchy ();

				pickingHierarchy .push (this);

				pickSensorStack [pickSensorStack .length - 1] .forEach (function (pickSensor)
				{
					pickSensor .collect (this .getGeometry (), renderObject .getModelViewMatrix () .get (), browser .getPickingHierarchy ());
				},
				this);

				pickingHierarchy .pop ();
			};
		})(),
		depth: function (gl, context, shaderNode)
		{
			this .getGeometry () .depth (gl, context, shaderNode);
		},
		display: function (gl, context)
		{
			var geometryNode = this .getGeometry ();

			this .getAppearance () .enable  (gl, context, geometryNode .getGeometryType ());
			geometryNode .display (gl, context);
			this .getAppearance () .disable (gl, context);
		},
	});

	return Shape;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape/TwoSidedMaterial',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Shape/X3DMaterialNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DMaterialNode, 
          X3DConstants,
          Algorithm)
{
"use strict";

	function TwoSidedMaterial (executionContext)
	{
		X3DMaterialNode .call (this, executionContext);

		this .addType (X3DConstants .TwoSidedMaterial);

		this .diffuseColor  = new Float32Array (3);
		this .specularColor = new Float32Array (3);
		this .emissiveColor = new Float32Array (3);
			
		this .backDiffuseColor  = new Float32Array (3);
		this .backSpecularColor = new Float32Array (3);
		this .backEmissiveColor = new Float32Array (3);
	}

	TwoSidedMaterial .prototype = Object .assign (Object .create (X3DMaterialNode .prototype),
	{
		constructor: TwoSidedMaterial,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",             new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "separateBackColor",    new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "ambientIntensity",     new Fields .SFFloat (0.2)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "diffuseColor",         new Fields .SFColor (0.8, 0.8, 0.8)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "specularColor",        new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "emissiveColor",        new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "shininess",            new Fields .SFFloat (0.2)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "transparency",         new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "backAmbientIntensity", new Fields .SFFloat (0.2)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "backDiffuseColor",     new Fields .SFColor (0.8, 0.8, 0.8)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "backSpecularColor",    new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "backEmissiveColor",    new Fields .SFColor ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "backShininess",        new Fields .SFFloat (0.2)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "backTransparency",     new Fields .SFFloat ()),
		]),
		getTypeName: function ()
		{
			return "TwoSidedMaterial";
		},
		getComponentName: function ()
		{
			return "Shape";
		},
		getContainerField: function ()
		{
			return "material";
		},
		initialize: function ()
		{
			X3DMaterialNode . prototype .initialize .call (this);

			this .separateBackColor_ .addInterest ("set_transparent__", this);

			this .ambientIntensity_ .addInterest ("set_ambientIntensity__", this);
			this .diffuseColor_     .addInterest ("set_diffuseColor__",     this);
			this .specularColor_    .addInterest ("set_specularColor__",    this);
			this .emissiveColor_    .addInterest ("set_emissiveColor__",    this);
			this .shininess_        .addInterest ("set_shininess__",        this);
			this .transparency_     .addInterest ("set_transparency__",     this);
	
			this .backAmbientIntensity_ .addInterest ("set_backAmbientIntensity__", this);
			this .backDiffuseColor_     .addInterest ("set_backDiffuseColor__",     this);
			this .backSpecularColor_    .addInterest ("set_backSpecularColor__",    this);
			this .backEmissiveColor_    .addInterest ("set_backEmissiveColor__",    this);
			this .backShininess_        .addInterest ("set_backShininess__",        this);
			this .backTransparency_     .addInterest ("set_backTransparency__",     this);
	
			this .set_ambientIntensity__ ();
			this .set_diffuseColor__ ();
			this .set_specularColor__ ();
			this .set_emissiveColor__ ();
			this .set_shininess__ ();
			this .set_transparency__ ();

			this .set_backAmbientIntensity__ ();
			this .set_backDiffuseColor__ ();
			this .set_backSpecularColor__ ();
			this .set_backEmissiveColor__ ();
			this .set_backShininess__ ();
			this .set_backTransparency__ ();
		},
		set_ambientIntensity__: function ()
		{
			this .ambientIntensity = Math .max (this .ambientIntensity_ .getValue (), 0);
		},
		set_diffuseColor__: function ()
		{
			//We cannot use this in Windows Edge:
			//this .diffuseColor .set (this .diffuseColor_ .getValue ());
			
			var
				diffuseColor  = this .diffuseColor,
				diffuseColor_ = this .diffuseColor_ .getValue ();
			
			diffuseColor [0] = diffuseColor_ .r;
			diffuseColor [1] = diffuseColor_ .g;
			diffuseColor [2] = diffuseColor_ .b;
		},
		set_specularColor__: function ()
		{
			//We cannot use this in Windows Edge:
			//this .specularColor .set (this .specularColor_ .getValue ());
			
			var
				specularColor  = this .specularColor,
				specularColor_ = this .specularColor_ .getValue ();
			
			specularColor [0] = specularColor_ .r;
			specularColor [1] = specularColor_ .g;
			specularColor [2] = specularColor_ .b;
		},
		set_emissiveColor__: function ()
		{
			//We cannot use this in Windows Edge:
			//this .emissiveColor .set (this .emissiveColor_ .getValue ());
			
			var
				emissiveColor  = this .emissiveColor,
				emissiveColor_ = this .emissiveColor_ .getValue ();
			
			emissiveColor [0] = emissiveColor_ .r;
			emissiveColor [1] = emissiveColor_ .g;
			emissiveColor [2] = emissiveColor_ .b;
		},
		set_shininess__: function ()
		{
			this .shininess = Algorithm .clamp (this .shininess_ .getValue (), 0, 1);
		},
		set_transparency__: function ()
		{
			this .transparency = Algorithm .clamp (this .transparency_ .getValue (), 0, 1);

			this .set_transparent__ ();
		},
		/*
		 * Back Material
		 */
		set_backAmbientIntensity__: function ()
		{
			this .backAmbientIntensity = Math .max (this .backAmbientIntensity_ .getValue (), 0);
		},
		set_backDiffuseColor__: function ()
		{
			//We cannot use this in Windows Edge:
			//this .backDiffuseColor .set (this .backDiffuseColor_ .getValue ());
			
			var
				backDiffuseColor  = this .backDiffuseColor,
				backDiffuseColor_ = this .backDiffuseColor_ .getValue ();
			
			backDiffuseColor [0] = backDiffuseColor_ .r;
			backDiffuseColor [1] = backDiffuseColor_ .g;
			backDiffuseColor [2] = backDiffuseColor_ .b;
		},
		set_backSpecularColor__: function ()
		{
			//We cannot use this in Windows Edge:
			//this .backSpecularColor .set (this .backSpecularColor_ .getValue ());
			
			var
				backSpecularColor  = this .backSpecularColor,
				backSpecularColor_ = this .backSpecularColor_ .getValue ();
			
			backSpecularColor [0] = backSpecularColor_ .r;
			backSpecularColor [1] = backSpecularColor_ .g;
			backSpecularColor [2] = backSpecularColor_ .b;
		},
		set_backEmissiveColor__: function ()
		{
			//We cannot use this in Windows Edge:
			//this .backEmissiveColor .set (this .backEmissiveColor_ .getValue ());
			
			var
				backEmissiveColor  = this .backEmissiveColor,
				backEmissiveColor_ = this .backEmissiveColor_ .getValue ();
			
			backEmissiveColor [0] = backEmissiveColor_ .r;
			backEmissiveColor [1] = backEmissiveColor_ .g;
			backEmissiveColor [2] = backEmissiveColor_ .b;
		},
		set_backShininess__: function ()
		{
			this .backShininess = Algorithm .clamp (this .backShininess_ .getValue (), 0, 1);
		},
		set_backTransparency__: function ()
		{
			this .backTransparency = Algorithm .clamp (this .backTransparency_ .getValue (), 0, 1);

			this .set_transparent__ ();
		},
		set_transparent__: function ()
		{
			this .setTransparent (Boolean (this .transparency_ .getValue () || (this .separateBackColor_ .getValue () && this .backTransparency_ .getValue ())));
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			gl .uniform1f  (shaderObject .x3d_AmbientIntensity, this .ambientIntensity);
			gl .uniform3fv (shaderObject .x3d_DiffuseColor,     this .diffuseColor);
			gl .uniform3fv (shaderObject .x3d_SpecularColor,    this .specularColor);
			gl .uniform3fv (shaderObject .x3d_EmissiveColor,    this .emissiveColor);
			gl .uniform1f  (shaderObject .x3d_Shininess,        this .shininess);
			gl .uniform1f  (shaderObject .x3d_Transparency,     this .transparency);

			if (this .separateBackColor_ .getValue ())
			{
				gl .uniform1i  (shaderObject .x3d_SeparateBackColor,    true);
				gl .uniform1f  (shaderObject .x3d_BackAmbientIntensity, this .backAmbientIntensity);
				gl .uniform3fv (shaderObject .x3d_BackDiffuseColor,     this .backDiffuseColor);
				gl .uniform3fv (shaderObject .x3d_BackSpecularColor,    this .backSpecularColor);
				gl .uniform3fv (shaderObject .x3d_BackEmissiveColor,    this .backEmissiveColor);
				gl .uniform1f  (shaderObject .x3d_BackShininess,        this .backShininess);
				gl .uniform1f  (shaderObject .x3d_BackTransparency,     this .backTransparency);
			}
			else
			{
				gl .uniform1i  (shaderObject .x3d_SeparateBackColor, false);
			}
		},
	});

	return TwoSidedMaterial;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Shape',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Shape/Appearance",
	"x_ite/Components/Shape/FillProperties",
	"x_ite/Components/Shape/LineProperties",
	"x_ite/Components/Shape/Material",
	"x_ite/Components/Shape/PointProperties",
	"x_ite/Components/Shape/Shape",
	"x_ite/Components/Shape/TwoSidedMaterial",
	"x_ite/Components/Shape/X3DAppearanceChildNode",
	"x_ite/Components/Shape/X3DAppearanceNode",
	"x_ite/Components/Shape/X3DMaterialNode",
	"x_ite/Components/Shape/X3DShapeNode",
],
function (SupportedNodes,
          Appearance,
          FillProperties,
          LineProperties,
          Material,
          PointProperties,
          Shape,
          TwoSidedMaterial,
          X3DAppearanceChildNode,
          X3DAppearanceNode,
          X3DMaterialNode,
          X3DShapeNode)
{
"use strict";

	var Types =
	{
		Appearance:       Appearance,
		FillProperties:   FillProperties,
		LineProperties:   LineProperties,
		Material:         Material,
		PointProperties:  PointProperties,
		Shape:            Shape,
		TwoSidedMaterial: TwoSidedMaterial,
	};

	var AbstractTypes =
	{
		X3DAppearanceChildNode: X3DAppearanceChildNode,
		X3DAppearanceNode:      X3DAppearanceNode,
		X3DMaterialNode:        X3DMaterialNode,
		X3DShapeNode:           X3DShapeNode,
	};

	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]);

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]);
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound/X3DSoundSourceNode',[
	"x_ite/Fields",
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Components/Time/X3DTimeDependentNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DChildNode,
          X3DTimeDependentNode,
          X3DConstants,
          Algorithm)
{
"use strict";

	function X3DSoundSourceNode (executionContext)
	{
		X3DChildNode         .call (this, executionContext);
		X3DTimeDependentNode .call (this, executionContext);

		this .addType (X3DConstants .X3DSoundSourceNode);

		this .addChildObjects ("enabled", new Fields .SFBool (true));

		this .volume = 0;
		this .media  = null;
	}

	X3DSoundSourceNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
		X3DTimeDependentNode .prototype,
	{
		constructor: X3DSoundSourceNode,
		initialize: function ()
		{
			X3DChildNode         .prototype .initialize .call (this);
			X3DTimeDependentNode .prototype .initialize .call (this);

		},
		set_browser_live__: function ()
		{
			X3DTimeDependentNode .prototype .set_browser_live__ .call (this);

			if (this .getDisabled ())
			{
				this .getBrowser () .volume_ .removeInterest ("set_volume__", this);
				this .getBrowser () .mute_   .removeInterest ("set_volume__", this);
			}
			else
			{
				this .getBrowser () .volume_ .addInterest ("set_volume__", this);
				this .getBrowser () .mute_   .addInterest ("set_volume__", this);
				this .set_volume__ ();
			}
		},
		setMedia: function (value)
		{
			if (this .media)
			{
				this .media [0] .volume = 0;
				this .media [0] .pause ();
				this .media .unbind ("ended");
			}

			this .media = value;

			if (value)
			{
				var media = value [0];

				this .setVolume (0);
				this .duration_changed_ = media .duration;

				this .resetElapsedTime ();

				if (this .isActive_ .getValue ())
				{
					if (this .isPaused_ .getValue ())
					{
						this .set_pause ();
					}
					else
					{
						if (this .getLiveState ())
							this .set_start ();
						else
							this .set_pause ();
					}
				}
				else
				{
					this .set_stop ();
				}
			}
		},
		getMedia: function ()
		{
			return this .media;
		},
		setVolume: function (volume)
		{
			this .volume = Algorithm .clamp (volume, 0, 1);

			this .set_volume__ ();
		},
		set_volume__: function ()
		{
			if (! this .media)
				return;

			var
				mute      = this .getBrowser () .mute_ .getValue (),
				intensity = Algorithm .clamp (this .getBrowser () .volume_ .getValue (), 0, 1),
				volume    = (! mute) * intensity * this .volume;

			this .media [0] .volume = volume;
		},
		set_speed: function ()
		{ },
		set_pitch: function ()
		{ },
		set_start: function ()
		{
			if (this .media)
			{
				if (this .speed_ .getValue ())
				{
					this .media [0] .currentTime = 0;
					this .media [0] .play ();
				}
			}
		},
		set_pause: function ()
		{
			if (this .media)
			{
				this .media .unbind ("ended");
				this .media [0] .pause ();
			}
		},
		set_resume: function ()
		{
			if (this .media)
			{
				if (this .speed_ .getValue ())
					this .media [0] .play ();
			}
		},
		set_stop: function ()
		{
			if (this .media)
			{
				this .media .unbind ("ended");
				this .media [0] .pause ();
			}
		},
		set_ended: function ()
		{
			if (this .media)
			{
				var media = this .media [0];

				if (media .currentTime < media .duration)
					return;

				if (this .loop_ .getValue ())
				{
					if (this .speed_ .getValue ())
						media .play ();

					// The event order below is very important.

					this .elapsedTime_ = this .getElapsedTime ();
				}
				else
				{
					this .stop ();
				}
			}
		},
		set_time: function ()
		{
			this .set_ended ();

			if (this .media)
				this .elapsedTime_ = this .getElapsedTime ();
		},
	});

	return X3DSoundSourceNode;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound/AudioClip',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Sound/X3DSoundSourceNode",
	"x_ite/Components/Networking/X3DUrlObject",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Networking/urls",
	"standard/Networking/URI",
	"x_ite/DEBUG",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DSoundSourceNode,
          X3DUrlObject,
          X3DConstants,
          urls,
          URI,
          DEBUG)
{
"use strict";

	function AudioClip (executionContext)
	{
		X3DSoundSourceNode .call (this, executionContext);
		X3DUrlObject       .call (this, executionContext);

		this .addType (X3DConstants .AudioClip);

		this .addChildObjects ("speed",  new Fields .SFFloat (1),
		                       "buffer", new Fields .MFString ());

		this .audio    = $("<audio></audio>");
		this .urlStack = new Fields .MFString ();
	}

	AudioClip .prototype = Object .assign (Object .create (X3DSoundSourceNode .prototype),
		X3DUrlObject .prototype,
	{
		constructor: AudioClip,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "description",      new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "url",              new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "pitch",            new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "loop",             new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "startTime",        new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "resumeTime",       new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "pauseTime",        new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "stopTime",         new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isPaused",         new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "isActive",         new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "elapsedTime",      new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,  "duration_changed", new Fields .SFTime (-1)),
		]),
		getTypeName: function ()
		{
			return "AudioClip";
		},
		getComponentName: function ()
		{
			return "Sound";
		},
		getContainerField: function ()
		{
			return "source";
		},
		initialize: function ()
		{
			X3DSoundSourceNode .prototype .initialize .call (this);
			X3DUrlObject       .prototype .initialize .call (this);

			this .url_    .addInterest ("set_url__",    this);
			this .buffer_ .addInterest ("set_buffer__", this);

			this .audio .on ("error", this .setError .bind (this));

			this .audio [0] .preload     = "auto";
			this .audio [0] .volume      = 0;
			this .audio [0] .crossOrigin = "Anonymous";

			this .set_url__ ();
		},
		getElement: function ()
		{
			return this .audio [0];
		},
		set_url__: function ()
		{
			this .setLoadState (X3DConstants .NOT_STARTED_STATE);

			this .requestAsyncLoad ();
		},
		requestAsyncLoad: function ()
		{
			if (this .checkLoadState () === X3DConstants .COMPLETE_STATE || this .checkLoadState () === X3DConstants .IN_PROGRESS_STATE)
				return;

			this .setLoadState (X3DConstants .IN_PROGRESS_STATE);

			this .buffer_ = this .url_;
		},
		set_buffer__: function ()
		{
			this .setMedia (null);
			this .urlStack .setValue (this .buffer_);
			this .audio .bind ("canplaythrough", this .setAudio .bind (this));
			this .loadNext ();
		},
		loadNext: function ()
		{
			if (this .urlStack .length === 0)
			{
				this .audio .unbind ("canplaythrough");
				this .duration_changed_ = -1;
				this .setLoadState (X3DConstants .FAILED_STATE);
				return;
			}

			// Get URL.

			this .URL = new URI (this .urlStack .shift ());
			this .URL = this .getExecutionContext () .getURL () .transform (this .URL);

			this .audio .attr ("src", this .URL);
			this .audio .get (0) .load ();
		},
		setError: function ()
		{
			var URL = this .URL .toString ();

			if (DEBUG)
			{
				if (! (this .URL .isLocal () || this .URL .host === "localhost"))
				{
					if (! URL .match (urls .getFallbackExpression ()))
						this .urlStack .unshift (urls .getFallbackUrl (URL));
				}
			}

			if (this .URL .scheme !== "data")
				console .warn ("Error loading audio:", this .URL .toString ());

			this .loadNext ();
		},
		setAudio: function ()
		{
			if (DEBUG)
			{
				if (this .URL .scheme !== "data")
					console .info ("Done loading audio:", this .URL .toString ());
			}

			this .audio .unbind ("canplaythrough");
			this .setMedia (this .audio);
			this .setLoadState (X3DConstants .COMPLETE_STATE);
		},
	});

	return AudioClip;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound/X3DSoundNode',[
	"x_ite/Components/Core/X3DChildNode",
	"x_ite/Bits/X3DConstants",
],
function (X3DChildNode, 
          X3DConstants)
{
"use strict";

	function X3DSoundNode (executionContext)
	{
		X3DChildNode .call (this, executionContext);

		this .addType (X3DConstants .X3DSoundNode);
	}

	X3DSoundNode .prototype = Object .assign (Object .create (X3DChildNode .prototype),
	{
		constructor: X3DSoundNode,
	});

	return X3DSoundNode;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound/Sound',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Sound/X3DSoundNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/TraverseType",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Rotation4",
	"standard/Math/Numbers/Matrix4",
	"standard/Math/Geometry/Line3",
	"standard/Math/Geometry/Sphere3",
	"standard/Math/Algorithm",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DSoundNode,
          X3DCast,
          TraverseType,
          X3DConstants,
          Vector3,
          Rotation4,
          Matrix4,
          Line3,
          Sphere3,
          Algorithm)
{
"use strict";

	function Sound (executionContext)
	{
		X3DSoundNode .call (this, executionContext);

		this .addType (X3DConstants .Sound);

		this .addChildObjects ("traversed", new Fields .SFBool (true));

		this .location_ .setUnit ("length");
		this .minBack_  .setUnit ("length");
		this .minFront_ .setUnit ("length");
		this .maxBack_  .setUnit ("length");
		this .maxFront_ .setUnit ("length");

		this .currentTraversed = true;
	}

	Sound .prototype = Object .assign (Object .create (X3DSoundNode .prototype),
	{
		constructor: Sound,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "intensity",  new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "spatialize", new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "location",   new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "direction",  new Fields .SFVec3f (0, 0, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "minBack",    new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "minFront",   new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "maxBack",    new Fields .SFFloat (10)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "maxFront",   new Fields .SFFloat (10)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "priority",   new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "source",     new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "Sound";
		},
		getComponentName: function ()
		{
			return "Sound";
		},
		getContainerField: function ()
		{
			return "children";
		},
		initialize: function ()
		{
			X3DSoundNode .prototype .initialize .call (this);

			this .isLive ()  .addInterest ("set_live__", this);
			this .traversed_ .addInterest ("set_live__", this);

			this .source_ .addInterest ("set_source__", this);

			this .set_live__ ();
			this .set_source__ ();
		},
		setTraversed: function (value)
		{
		   if (value)
			{
				if (this .traversed_ .getValue () === false)
					this .traversed_ = true;
			}
			else
			{
				if (this .currentTraversed !== this .traversed_ .getValue ())
					this .traversed_ = this .currentTraversed;
			}

		   this .currentTraversed = value;
		},
		getTraversed: function ()
		{
		   return this .currentTraversed;
		},
		set_live__: function ()
		{
			if (this .isLive () .getValue () && this .traversed_ .getValue ())
			{
				this .getBrowser () .sensorEvents () .addInterest ("update", this);
			}
			else
			{
				this .getBrowser () .sensorEvents () .removeInterest ("update", this);
			}
		},
		set_source__: function ()
		{
		   if (this .sourceNode)
		      this .sourceNode .setVolume (0);

			this .sourceNode = X3DCast (X3DConstants .X3DSoundSourceNode, this .source_);
		},
		update: function ()
		{
			if (! this .getTraversed ())
			{
				if (this .sourceNode)
					this .sourceNode .setVolume (0);
			}

			this .setTraversed (false);
		},
		traverse: (function ()
		{
			var
				min = { distance: 0, intersection: new Vector3 (0, 0, 0) },
				max = { distance: 0, intersection: new Vector3 (0, 0, 0) };

			return function (type, renderObject)
			{
				try
				{
					if (type !== TraverseType .DISPLAY)
						return;

					if (! this .sourceNode)
						return;

					if (! this .sourceNode .isActive_ .getValue () || this .sourceNode .isPaused_ .getValue ())
						return;

					this .setTraversed (true);

					var modelViewMatrix = renderObject .getModelViewMatrix () .get ();

					this .getEllipsoidParameter (modelViewMatrix,
					                             Math .max (this .maxBack_  .getValue (), 0),
					                             Math .max (this .maxFront_ .getValue (), 0),
					                             max);

					if (max .distance < 1) // Sphere radius is 1
					{
						this .getEllipsoidParameter (modelViewMatrix,
						                             Math .max (this .minBack_  .getValue (), 0),
						                             Math .max (this .minFront_ .getValue (), 0),
						                             min);

						if (min .distance < 1) // Sphere radius is 1
						{
							this .sourceNode .setVolume (this .intensity_ .getValue ());
						}
						else
						{
							var
								d1        = max .intersection .abs (), // Viewer is here at (0, 0, 0)
								d2        = max .intersection .distance (min .intersection),
								d         = Math .min (d1 / d2, 1),
								intensity = Algorithm .clamp (this .intensity_ .getValue (), 0, 1),
								volume    = intensity * d;

							this .sourceNode .setVolume (volume);
						}
					}
					else
					{
						this .sourceNode .setVolume (0);
					}
				}
				catch (error)
				{
					//console .log (error);

					if (this .sourceNode)
						this .sourceNode .setVolume (0);
				}
			};
		})(),
		getEllipsoidParameter: (function ()
		{
			var
				location        = new Vector3 (0, 0, 0),
				sphereMatrix    = new Matrix4 (),
				invSphereMatrix = new Matrix4 (),
				rotation        = new Rotation4 (),
				scale           = new Vector3 (1, 1, 1),
				sphere          = new Sphere3 (1, Vector3 .Zero),
				normal          = new Vector3 (0, 0, 0),
				line            = new Line3 (Vector3 .Zero, Vector3 .zAxis),
				enterPoint      = new Vector3 (0, 0, 0),
				exitPoint       = new Vector3 (0, 0, 0);

			return function (modelViewMatrix, back, front, value)
			{
				/*
				 * http://de.wikipedia.org/wiki/Ellipse
				 *
				 * The ellipsoid is transformed to a sphere for easier calculation and then the viewer position is
				 * transformed into this coordinate system. The radius and distance can then be obtained.
				 *
				 * throws Error
				 */

				if (back == 0 || front == 0)
				{
					sphereMatrix .multVecMatrix (value .intersection .assign (this .location_ .getValue ()));
					value .distance = 1;
					return;
				}

				var
					a = (back + front) / 2,
					e = a - back,
					b = Math .sqrt (a * a - e * e);

				location .set (0, 0, e);
				scale    .set (b, b, a);
				rotation .setFromToVec (Vector3 .zAxis, this .direction_ .getValue ());

				sphereMatrix
					.assign (modelViewMatrix)
					.translate (this .location_ .getValue ())
					.rotate (rotation)
					.translate (location)
					.scale (scale);

				invSphereMatrix .assign (sphereMatrix) .inverse ();

				var viewer = invSphereMatrix .origin;
				location .negate () .divVec (scale);

				normal .assign (location) .subtract (viewer) .normalize ();
				line .set (viewer, normal);
				sphere .intersectsLine (line, enterPoint, exitPoint);

				value .intersection .assign (sphereMatrix .multVecMatrix (enterPoint));
				value .distance = viewer .abs ();
			};
		})(),
	});

	return Sound;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Sound',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Sound/AudioClip",
	"x_ite/Components/Sound/Sound",
	"x_ite/Components/Sound/X3DSoundNode",
	"x_ite/Components/Sound/X3DSoundSourceNode",
],
function (SupportedNodes,
          AudioClip,
          Sound,
          X3DSoundNode,
          X3DSoundSourceNode)
{
"use strict";

	var Types =
	{
		AudioClip: AudioClip,
		Sound:     Sound,
	};

	var AbstractTypes =
	{
		X3DSoundNode:       X3DSoundNode,
		X3DSoundSourceNode: X3DSoundSourceNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Text/Text',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Rendering/X3DGeometryNode",
	"x_ite/Bits/X3DCast",
	"x_ite/Bits/X3DConstants",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DGeometryNode, 
          X3DCast,
          X3DConstants)
{
"use strict";

	function Text (executionContext)
	{
		X3DGeometryNode .call (this, executionContext);

		this .addType (X3DConstants .Text);

		this .length_     .setUnit ("length");
		this .maxExtent_  .setUnit ("length");
		this .origin_     .setUnit ("length");
		this .textBounds_ .setUnit ("length");
		this .lineBounds_ .setUnit ("length");
	}

	Text .prototype = Object .assign (Object .create (X3DGeometryNode .prototype),
	{
		constructor: Text,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",   new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "string",     new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "length",     new Fields .MFFloat ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "maxExtent",  new Fields .SFFloat ()),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "solid",      new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "origin",     new Fields .SFVec3f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "textBounds", new Fields .SFVec2f ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "lineBounds", new Fields .MFVec2f ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "fontStyle",  new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "Text";
		},
		getComponentName: function ()
		{
			return "Text";
		},
		getContainerField: function ()
		{
			return "geometry";
		},
		initialize: function ()
		{
			X3DGeometryNode .prototype .initialize .call (this);

			this .fontStyle_ .addInterest ("set_fontStyle__", this);
	
			this .set_fontStyle__ ();
		},
		getMatrix: function ()
		{
			return this .textGeometry .getMatrix ();
		},
		getLength: function (index)
		{
			if (index < this .length_ .length)
				return Math .max (0, this .length_ [index]);

			return 0;
		},
		set_live__: function ()
		{
		    X3DGeometryNode .prototype .set_live__ .call (this);

		   if (this .isLive () .getValue ())
				this .getBrowser () .getBrowserOptions () .PrimitiveQuality_ .addInterest ("requestRebuild", this);
		   else
				this .getBrowser () .getBrowserOptions () .PrimitiveQuality_ .removeInterest ("requestRebuild", this);
		},
		set_fontStyle__: function ()
		{
		   if (this .fontStyleNode)
		      this .fontStyleNode .removeInterest ("requestRebuild", this);

			this .fontStyleNode = X3DCast (X3DConstants .X3DFontStyleNode, this .fontStyle_);

			if (! this .fontStyleNode)
				this .fontStyleNode = this .getBrowser () .getDefaultFontStyle ();

		   this .fontStyleNode .addInterest ("requestRebuild", this);

		   this .textGeometry = this .fontStyleNode .getTextGeometry (this);

		   this .setTransparent (this .textGeometry .getTransparent ());
		},
		build: function ()
		{
			this .textGeometry .update ();
			this .textGeometry .build ();

			this .setSolid (this .solid_ .getValue ());
		},
		traverse: function (type, renderObject)
		{
			try
			{
				this .textGeometry .traverse (type, renderObject);

				X3DGeometryNode .prototype .traverse .call (this, type, renderObject);
			}
			catch (error)
			{
				console .log (error);
			}
		},
		display: function (gl, context)
		{
			try
			{
				this .textGeometry .display (gl, context);

				X3DGeometryNode .prototype .display .call (this, gl, context);
			}
			catch (error)
			{
				console .log (error);
			}
		},
		transformLine: function (line)
		{
			// Apply sceen nodes transformation in place here.
			return this .textGeometry .transformLine (line);
		},
		transformMatrix: function (matrix)
		{
			// Apply sceen nodes transformation in place here.
			return this .textGeometry .transformMatrix (matrix);
		},
	});

	return Text;
});



/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Text',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Text/FontStyle",
	"x_ite/Components/Text/Text",
	"x_ite/Components/Text/X3DFontStyleNode",
],
function (SupportedNodes,
          FontStyle,
          Text,
          X3DFontStyleNode)
{
"use strict";

	var Types =
	{
		FontStyle: FontStyle,
		Text: Text,
	};

	var AbstractTypes =
	{
		X3DFontStyleNode: X3DFontStyleNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/MovieTexture',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Texturing/X3DTexture2DNode",
	"x_ite/Components/Sound/X3DSoundSourceNode",
	"x_ite/Components/Networking/X3DUrlObject",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Networking/urls",
	"standard/Networking/URI",
	"standard/Math/Algorithm",
	"x_ite/DEBUG",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTexture2DNode,
          X3DSoundSourceNode,
          X3DUrlObject,
          X3DConstants,
          urls,
          URI,
          Algorithm,
          DEBUG)
{
"use strict";

	function MovieTexture (executionContext)
	{
		X3DTexture2DNode   .call (this, executionContext);
		X3DSoundSourceNode .call (this, executionContext);
		X3DUrlObject       .call (this, executionContext);

		this .addType (X3DConstants .MovieTexture);

		this .addChildObjects ("buffer", new Fields .MFString ());

		this .canvas   = $("<canvas></canvas>");
		this .video    = $("<video></video>");
		this .urlStack = new Fields .MFString ();
	}

	MovieTexture .prototype = Object .assign (Object .create (X3DTexture2DNode .prototype),
		X3DSoundSourceNode .prototype,
		X3DUrlObject .prototype,
	{
		constructor: MovieTexture,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "description",       new Fields .SFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "url",               new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "speed",             new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "pitch",             new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "loop",              new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "startTime",         new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "resumeTime",        new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "pauseTime",         new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "stopTime",          new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isPaused",          new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "isActive",          new Fields .SFBool ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "elapsedTime",       new Fields .SFTime ()),
			new X3DFieldDefinition (X3DConstants .outputOnly,     "duration_changed",  new Fields .SFTime (-1)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatS",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatT",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "textureProperties", new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "MovieTexture";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "texture";
		},
		initialize: function ()
		{
			X3DTexture2DNode   .prototype .initialize .call (this);
			X3DSoundSourceNode .prototype .initialize .call (this);
			X3DUrlObject       .prototype .initialize .call (this);

			this .url_    .addInterest ("set_url__",    this);
			this .buffer_ .addInterest ("set_buffer__", this);

			this .video .on ("error", this .setError .bind (this));

			this .video [0] .preload     = "auto";
			this .video [0] .volume      = 0;
			this .video [0] .crossOrigin = "Anonymous";

			this .set_url__ ();
		},
		getElement: function ()
		{
			return this .video [0];
		},
		set_url__: function ()
		{
			this .setLoadState (X3DConstants .NOT_STARTED_STATE);

			this .requestAsyncLoad ();
		},
		requestAsyncLoad: function ()
		{
			if (this .checkLoadState () === X3DConstants .COMPLETE_STATE || this .checkLoadState () === X3DConstants .IN_PROGRESS_STATE)
				return;

			this .setLoadState (X3DConstants .IN_PROGRESS_STATE);

			this .buffer_ = this .url_;
		},
		set_buffer__: function ()
		{
			this .setMedia (null);
			this .urlStack .setValue (this .buffer_);
			this .video .bind ("canplaythrough", this .setVideo .bind (this));
			this .loadNext ();
		},
		loadNext: function ()
		{
			if (this .urlStack .length === 0)
			{
				this .video .unbind ("canplaythrough");
			   this .duration_changed_ = -1;
				this .clearTexture ();
				this .setLoadState (X3DConstants .FAILED_STATE);
				return;
			}

			// Get URL.

			this .URL = new URI (this .urlStack .shift ());
			this .URL = this .getExecutionContext () .getURL () .transform (this .URL);

			this .video .attr ("src", this .URL);
			this .video .get (0) .load ();
		},
		setError: function ()
		{
			var URL = this .URL .toString ();

			if (DEBUG)
			{
				if (! (this .URL .isLocal () || this .URL .host === "localhost"))
				{
					if (! URL .match (urls .getFallbackExpression ()))
						this .urlStack .unshift (urls .getFallbackUrl (URL));
				}
			}

			if (this .URL .scheme !== "data")
				console .warn ("Error loading movie:", this .URL .toString ());

			this .loadNext ();
		},
		setVideo: function ()
		{
			if (DEBUG)
			{
				if (this .URL .scheme !== "data")
					console .info ("Done loading movie:", this .URL .toString ());
			}

			try
			{
				this .video .unbind ("canplaythrough");

				var
			      video  = this .video [0],
					width  = video .videoWidth,
					height = video .videoHeight,
					canvas = this .canvas [0],
					cx     = canvas .getContext ("2d");

				if (! Algorithm .isPowerOfTwo (width) || ! Algorithm .isPowerOfTwo (height))
					throw new Error ("The movie texture is a non power-of-two texture.");

				canvas .width  = width;
				canvas .height = height;

				cx .drawImage (video, 0, 0);

				var data = cx .getImageData (0, 0, width, height) .data;

				setTimeout (function ()
				{
					this .setMedia (this .video);
					this .setTexture (width, height, false, new Uint8Array (data), true);
					this .setLoadState (X3DConstants .COMPLETE_STATE);
				}
				.bind (this), 16);
			}
			catch (error)
			{
				// Catch security error from cross origin requests.
				console .log (error .message);
				this .setError ();
			}
		},
		set_time: function ()
		{
		   X3DSoundSourceNode .prototype .set_time .call (this);

			if (this .checkLoadState () === X3DConstants .COMPLETE_STATE)
				this .updateTexture (this .getMedia () [0], true);
		},
		traverse: X3DTexture2DNode .prototype .traverse,
	});

	return MovieTexture;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/MultiTexture',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Texturing/X3DTextureNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Bits/X3DCast",
	"x_ite/Browser/Texturing/MultiTextureModeType",
	"x_ite/Browser/Texturing/MultiTextureSourceType",
	"x_ite/Browser/Texturing/MultiTextureFunctionType",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTextureNode, 
          X3DConstants,
          X3DCast,
          ModeType,
          SourceType,
          FunctionType)
{
"use strict";

	function MultiTexture (executionContext)
	{
		X3DTextureNode .call (this, executionContext);

		this .addType (X3DConstants .MultiTexture);

		this .addChildObjects ("loadState", new Fields .SFInt32 (X3DConstants .NOT_STARTED_STATE));

		this .color        = new Float32Array (4);
		this .modes        = [ ];
		this .alphaModes   = [ ];
		this .sources      = [ ];
		this .functions    = [ ];
		this .textureNodes = [ ];

		this .setTransparent (false);
	}

	MultiTexture .prototype = Object .assign (Object .create (X3DTextureNode .prototype),
	{
		constructor: MultiTexture,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "color",    new Fields .SFColor (1, 1, 1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "alpha",    new Fields .SFFloat (1)),
			new X3DFieldDefinition (X3DConstants .inputOutput, "mode",     new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "source",   new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "function", new Fields .MFString ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "texture",  new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "MultiTexture";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "texture";
		},
		initialize: function ()
		{
			X3DTextureNode .prototype .initialize .call (this);

			this .color_    .addInterest ("set_color__",    this);
			this .alpha_    .addInterest ("set_alpha__",    this);
			this .mode_     .addInterest ("set_mode__",     this);
			this .source_   .addInterest ("set_source__",   this);
			this .function_ .addInterest ("set_function__", this);
			this .texture_  .addInterest ("set_texture__",  this);

			this .set_color__ ();
			this .set_alpha__ ();
			this .set_mode__ ();
			this .set_source__ ();
			this .set_function__ ();
			this .set_texture__ ();

			this .loadState_ = X3DConstants .COMPLETE_STATE;
		},
		getMode: function (index)
		{
			if (index < this .modes .length)
				return this .modes [index];

			return ModeType .MODULATE;
		},
		getAlphaMode: function (index)
		{
			if (index < this .alphaModes .length)
				return this .alphaModes [index];

			return ModeType .MODULATE;
		},
		getSource: function (index)
		{
			if (index < this .sources .length)
				return this .sources [index];

			return SourceType .DEFAULT;
		},
		getFunction: function (index)
		{
			if (index < this .functions .length)
				return this .functions [index];

			return FunctionType .DEFAULT;
		},
		set_color__: function ()
		{
			this .color [0] = this .color_ .r;
			this .color [1] = this .color_ .g;
			this .color [2] = this .color_ .b;
		},
		set_alpha__: function ()
		{
			this .color [3] = this .alpha_;
		},
		set_mode__: (function ()
		{
			var modeTypes = new Map ([
				["REPLACE",                   ModeType .REPLACE],
				["MODULATE",                  ModeType .MODULATE],
				["MODULATE2X",                ModeType .MODULATE2X],
				["MODULATE4X",                ModeType .MODULATE4X],
				["ADD",                       ModeType .ADD],
				["ADDSIGNED",                 ModeType .ADDSIGNED],
				["ADDSIGNED2X",               ModeType .ADDSIGNED2X],
				["ADDSMOOTH",                 ModeType .ADDSMOOTH],
				["SUBTRACT",                  ModeType .SUBTRACT],
				["BLENDDIFFUSEALPHA",         ModeType .BLENDDIFFUSEALPHA],
				["BLENDTEXTUREALPHA",         ModeType .BLENDTEXTUREALPHA],
				["BLENDFACTORALPHA",          ModeType .BLENDFACTORALPHA],
				["BLENDCURRENTALPHA",         ModeType .BLENDCURRENTALPHA],
				["MODULATEALPHA_ADDCOLOR",    ModeType .MODULATEALPHA_ADDCOLOR],
				["MODULATEINVALPHA_ADDCOLOR", ModeType .MODULATEINVALPHA_ADDCOLOR],
				["MODULATEINVCOLOR_ADDALPHA", ModeType .MODULATEINVCOLOR_ADDALPHA],
				["DOTPRODUCT3",               ModeType .DOTPRODUCT3],
				["SELECTARG1",                ModeType .SELECTARG1],
				["SELECTARG2",                ModeType .SELECTARG2],
				["OFF",                       ModeType .OFF],
			]);

			return function ()
			{
				this .modes      .length = 0;
				this .alphaModes .length = 0;

				for (var i = 0, length = this .mode_ .length; i < length; ++ i)
				{
					var mode = this .mode_ [i] .split (",");

					for (var m = 0, mLength = mode .length; m < mLength; ++ m)
						mode [m] = mode [m] .trim ();

					if (mode .length === 0)
						mode .push ("MODULATE");

					if (mode .length < 2)
						mode .push (mode [0]);

					// RGB

					var modeType = modeTypes .get (mode [0]);

					if (modeType !== undefined)
						this .modes .push (modeType);
					else
						this .modes .push (ModeType .MODULATE);

					// Alpha

					var modeType = modeTypes .get (mode [1]);

					if (modeType !== undefined)
						this .alphaModes .push (modeType);
					else
						this .alphaModes .push (ModeType .MODULATE);
				}
			};
		})(),
		set_source__: (function ()
		{
			var sourceTypes = new Map ([
				["DIFFUSE",  SourceType .DIFFUSE],
				["SPECULAR", SourceType .SPECULAR],
				["FACTOR",   SourceType .FACTOR],
			]);

			return function ()
			{
				this .sources .length = 0;

				for (var i = 0, length = this .source_ .length; i < length; ++ i)
				{
					var sourceType = sourceTypes .get (this .source_ [i]);

					if (sourceType !== undefined)
						this .sources .push (sourceType);
					else
						this .sources .push (SourceType .DEFAULT);
				}
			};
		})(),
		set_function__: (function ()
		{
			var functionsTypes = new Map ([
				["COMPLEMENT",     FunctionType .COMPLEMENT],
				["ALPHAREPLICATE", FunctionType .ALPHAREPLICATE],
			]);

			return function ()
			{
				this .functions .length = 0;

				for (var i = 0, length = this .function_ .length; i < length; ++ i)
				{
					var functionsType = functionsTypes .get (this .function_ [i]);

					if (functionsType !== undefined)
						this .functions .push (functionsType);
					else
						this .functions .push (FunctionType .DEFAULT);
				}
			};
		})(),
		set_texture__: function ()
		{
			this .textureNodes .length = 0;

			for (var i = 0, length = this .texture_ .length; i < length; ++ i)
			{
				var node = this .texture_ [i];

				if (X3DCast (X3DConstants .MultiTexture, node))
					continue;

				var textureNode = X3DCast (X3DConstants .X3DTextureNode, node);

				if (textureNode)
					this .textureNodes .push (textureNode);
			}	
		},
		traverse: function (type, renderObject)
		{
			var textureNodes = this .textureNodes;

			for (var i = 0, length = textureNodes .length; i < length; ++ i)
				textureNodes [i] .traverse (type, renderObject);
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			var
				textureNodes = this .textureNodes,
				channels     = Math .min (shaderObject .getBrowser () .getMaxTextures (), textureNodes .length);

			gl .uniform1i  (shaderObject .x3d_NumTextures,       channels);
			gl .uniform4fv (shaderObject .x3d_MultiTextureColor, this .color);

			for (var i = 0; i < channels; ++ i)
			{
				textureNodes [i] .setShaderUniformsToChannel (gl, shaderObject, i);

				gl .uniform1i  (shaderObject .x3d_MultiTextureMode [i],      this .getMode (i));
				gl .uniform1i  (shaderObject .x3d_MultiTextureAlphaMode [i], this .getAlphaMode (i));
				gl .uniform1i  (shaderObject .x3d_MultiTextureSource [i],    this .getSource (i));
				gl .uniform1i  (shaderObject .x3d_MultiTextureFunction [i],  this .getFunction (i));
			}
		},
	});

	return MultiTexture;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/MultiTextureCoordinate',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Texturing/X3DTextureCoordinateNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Bits/X3DCast",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTextureCoordinateNode, 
          X3DConstants,
          X3DCast)
{
"use strict";

	function MultiTextureCoordinate (executionContext)
	{
		X3DTextureCoordinateNode .call (this, executionContext);

		this .addType (X3DConstants .MultiTextureCoordinate);

		this .textureCoordinateNodes = [ ];
	}

	MultiTextureCoordinate .prototype = Object .assign (Object .create (X3DTextureCoordinateNode .prototype),
	{
		constructor: MultiTextureCoordinate,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata", new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "texCoord", new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "MultiTextureCoordinate";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "texCoord";
		},
		initialize: function ()
		{
			X3DTextureCoordinateNode .prototype .initialize .call (this);

			this .texCoord_ .addInterest ("set_texCoord__", this);

			this .set_texCoord__ ();
		},
		set_texCoord__: function ()
		{
			var textureCoordinateNodes = this .textureCoordinateNodes;

			for (var i = 0, length = textureCoordinateNodes .length; i < length; ++ i)
				textureCoordinateNodes [i] .removeInterest ("addNodeEvent", this);

			textureCoordinateNodes .length = 0;

			for (var i = 0, length = this .texCoord_ .length; i < length; ++ i)
			{
				var node = this .texCoord_ [i];

				if (X3DCast (X3DConstants .MultiTextureCoordinate, node))
					continue;

				var textureCoordinateNode = X3DCast (X3DConstants .X3DTextureCoordinateNode, node);

				if (textureCoordinateNode)
					textureCoordinateNodes .push (textureCoordinateNode);
			}

			for (var i = 0, length = textureCoordinateNodes .length; i < length; ++ i)
				textureCoordinateNodes [i] .addInterest ("addNodeEvent", this);
		},
		isEmpty: function ()
		{
			return true;
		},
		getSize: function ()
		{
			return 0;
		},
		get1Point: function (index, vector)
		{
			var textureCoordinateNodes = this .textureCoordinateNodes;

			for (var i = 0, length = textureCoordinateNodes .length; i < length; ++ i)
				return textureCoordinateNodes [i] .get1Point (index, vector);

			return vector .set (0, 0, 0, 1);
		},
		init: function (multiArray)
		{
			var textureCoordinateNodes = this .textureCoordinateNodes;

			for (var i = 0, length = textureCoordinateNodes .length; i < length; ++ i)
				textureCoordinateNodes [i] .init (multiArray);
		},
		addTexCoord: function (index, multiArray)
		{
			var textureCoordinateNodes = this .textureCoordinateNodes;

			for (var i = 0, length = textureCoordinateNodes .length; i < length; ++ i)
				textureCoordinateNodes [i] .addTexCoordToChannel (index, multiArray [i]);
		},
		addTexCoordToChannel: function (index, array)
		{ },
		getTexCoord: function (array)
		{
			var textureCoordinateNodes = this .textureCoordinateNodes;

			for (var i = 0, length = textureCoordinateNodes .length; i < length; ++ i)
				return textureCoordinateNodes [i] .getTexCoord (array);

			return array;
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			var
				textureCoordinateNodes = this .textureCoordinateNodes,
				length                 = Math .min (shaderObject .x3d_MaxTextures, textureCoordinateNodes .length);

			for (var i = 0; i < length; ++ i)
				textureCoordinateNodes [i] .setShaderUniformsToChannel (gl, shaderObject, i);

			if (length)
			{
				var last = length - 1;
	
				for (var i = length, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
					textureCoordinateNodes [last] .setShaderUniformsToChannel (gl, shaderObject, i);
			}
			else
			{
				for (var i = 0, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
					this .setShaderUniformsToChannel (gl, shaderObject, i);
			}
		},
	});

	return MultiTextureCoordinate;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/MultiTextureTransform',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Texturing/X3DTextureTransformNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Bits/X3DCast",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTextureTransformNode, 
          X3DConstants,
          X3DCast)
{
"use strict";

	function MultiTextureTransform (executionContext)
	{
		X3DTextureTransformNode .call (this, executionContext);

		this .addType (X3DConstants .MultiTextureTransform);

		this .textureTransformNodes = [ ];
	}

	MultiTextureTransform .prototype = Object .assign (Object .create (X3DTextureTransformNode .prototype),
	{
		constructor: MultiTextureTransform,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",         new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "textureTransform", new Fields .MFNode ()),
		]),
		getTypeName: function ()
		{
			return "MultiTextureTransform";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "textureTransform";
		},
		initialize: function ()
		{
			X3DTextureTransformNode .prototype .initialize .call (this);

			this .textureTransform_ .addInterest ("set_textureTransform_", this);

			this .set_textureTransform__ ();
		},
		set_textureTransform__: function ()
		{
			var textureTransformNodes = this .textureTransformNodes;

			textureTransformNodes .length = 0;

			for (var i = 0, length = this .textureTransform_ .length; i < length; ++ i)
			{
				var node = this .textureTransform_ [i];

				if (X3DCast (X3DConstants .MultiTextureTransform, node))
					continue;

				var textureTransformNode = X3DCast (X3DConstants .X3DTextureTransformNode, node);

				if (textureTransformNode)
					textureTransformNodes .push (textureTransformNode);
			}
		},
		setShaderUniforms: function (gl, shaderObject)
		{
			var
				textureTransformNodes = this .textureTransformNodes,
				length                = Math .min (shaderObject .x3d_MaxTextures, textureTransformNodes .length);

			for (var i = 0; i < length; ++ i)
				textureTransformNodes [i] .setShaderUniformsToChannel (gl, shaderObject, i);

			if (length)
			{
				var last = length - 1;

				for (var i = length, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
					textureTransformNodes [last] .setShaderUniformsToChannel (gl, shaderObject, i);
			}
			else
			{
				for (var i = 0, length = shaderObject .x3d_MaxTextures; i < length; ++ i)
					this .setShaderUniformsToChannel (gl, shaderObject, i);
			}
		},
	});

	return MultiTextureTransform;
});



/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/PixelTexture',[
	"jquery",
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Texturing/X3DTexture2DNode",
	"x_ite/Bits/X3DConstants",
	"standard/Math/Algorithm",
	"standard/Math/Numbers/Vector3",
	"standard/Math/Numbers/Matrix3",
],
function ($,
          Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTexture2DNode,
          X3DConstants,
          Algorithm)
{
"use strict";

	function PixelTexture (executionContext)
	{
		X3DTexture2DNode .call (this, executionContext);

		this .addType (X3DConstants .PixelTexture);

		this .addChildObjects ("loadState", new Fields .SFInt32 (X3DConstants .NOT_STARTED_STATE));
	}

	PixelTexture .prototype = Object .assign (Object .create (X3DTexture2DNode .prototype),
	{
		constructor: PixelTexture,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput,    "metadata",          new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput,    "image",             new Fields .SFImage (0, 0, 0, new Fields .MFInt32 ())),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatS",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "repeatT",           new Fields .SFBool (true)),
			new X3DFieldDefinition (X3DConstants .initializeOnly, "textureProperties", new Fields .SFNode ()),
		]),
		getTypeName: function ()
		{
			return "PixelTexture";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "texture";
		},
		initialize: function ()
		{
			X3DTexture2DNode .prototype .initialize .call (this);

			this .image_ .addInterest ("set_image__", this);

			this .canvas1 = $("<canvas></canvas>");
			this .canvas2 = $("<canvas></canvas>");

			this .set_image__ ();
		},
		checkLoadState: function ()
		{
			return this .loadState_ .getValue ();
		},
		convert: function (data, comp, array, length)
		{
			switch (comp)
			{
				case 1:
				{
					for (var i = 0, index = 0; i < length; ++ i, index += 4)
					{
						var pixel = array [i];

						data [index]     =
						data [index + 1] =
						data [index + 2] = pixel & 255;
						data [index + 3] = 255;
					}

					break;
				}
				case 2:
				{
					for (var i = 0, index = 0; i < length; ++ i, index += 4)
					{
						var pixel = array [i];

						data [index]     =
						data [index + 1] =
						data [index + 2] = (pixel >>> 8) & 255;
						data [index + 3] = pixel & 255;
					}

					break;
				}
				case 3:
				{
					for (var i = 0, index = 0; i < length; ++ i, index += 4)
					{
						var pixel = array [i];

						data [index]     = (pixel >>> 16) & 255;
						data [index + 1] = (pixel >>>  8) & 255;
						data [index + 2] = pixel & 255;
						data [index + 3] = 255;
					}

					break;
				}
				case 4:
				{
					for (var i = 0, index = 0; i < length; ++ i, index += 4)
					{
						var pixel = array [i];

						data [index]     = (pixel >>> 24);
						data [index + 1] = (pixel >>> 16) & 255;
						data [index + 2] = (pixel >>>  8) & 255;
						data [index + 3] = pixel & 255;
					}

					break;
				}
			}
		},
		resize: function (input, inputWidth, inputHeight, outputWidth, outputHeight)
		{
		   // Nearest neighbor scaling algorithm for very small images.

			var
				output = new Uint8Array (outputWidth * outputHeight * 4),
				scaleX = outputWidth / inputWidth,
				scaleY = outputHeight / inputHeight;

			for (var y = 0; y < outputHeight; ++ y)
			{
				var
					inputW  = Math .floor (y / scaleY) * inputWidth,
					outputW = y * outputWidth;

				for (var x = 0; x < outputWidth; ++ x)
				{
					var
						index       = (inputW + Math.floor (x / scaleX)) * 4,
						indexScaled = (outputW + x) * 4;

					output [indexScaled]     = input [index];
					output [indexScaled + 1] = input [index + 1];
					output [indexScaled + 2] = input [index + 2];
					output [indexScaled + 3] = input [index + 3];
				}
			}

			return output;
		},
		set_image__: function ()
		{
			var
				gl          = this .getBrowser () .getContext (),
				width       = this .image_ .width,
				height      = this .image_ .height,
				comp        = this .image_ .comp,
				array       = this .image_ .array,
				transparent = ! (comp % 2),
				data        = null;

			if (width > 0 && height > 0 && comp > 0 && comp < 5)
			{
				if (gl .getVersion () >= 2 || (Algorithm .isPowerOfTwo (width) && Algorithm .isPowerOfTwo (height)))
				{
					data = new Uint8Array (width * height * 4);

					this .convert (data, comp, array .getValue (), array .length);
				}
				else if (Math .max (width, height) < this .getBrowser () .getMinTextureSize () && ! this .textureProperties_ .getValue ())
				{
					data = new Uint8Array (width * height * 4);

					this .convert (data, comp, array .getValue (), array .length);

					var
						inputWidth  = width,
						inputHeight = height;

					width  = Algorithm .nextPowerOfTwo (inputWidth)  * 4;
					height = Algorithm .nextPowerOfTwo (inputHeight) * 4;

					data = this .resize (data, inputWidth, inputHeight, width, height);
				}
				else
				{
					var
						canvas1   = this .canvas1 [0],
						canvas2   = this .canvas2 [0],
						cx1       = canvas1 .getContext("2d"),
						cx2       = canvas2 .getContext("2d"),
						imageData = cx1 .createImageData (width, height);

					canvas1 .width  = width;
					canvas1 .height = height;

					this .convert (imageData .data, comp, array, array .length);
					cx1 .putImageData (imageData, 0, 0);

					width  = Algorithm .nextPowerOfTwo (width);
					height = Algorithm .nextPowerOfTwo (height);

					canvas2 .width  = width;
					canvas2 .height = height;

					cx2 .clearRect (0, 0, width, height);
					cx2 .drawImage (canvas1, 0, 0, canvas1 .width, canvas1 .height, 0, 0, width, height);

					data = cx2 .getImageData (0, 0, width, height) .data;
				}

				this .setTexture (width, height, transparent, new Uint8Array (data), false);
				this .loadState_ = X3DConstants .COMPLETE_STATE;
			}
			else
			{
				this .clearTexture ();
				this .loadState_ = X3DConstants .FAILED_STATE;
			}
		},
	});

	return PixelTexture;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing/TextureCoordinateGenerator',[
	"x_ite/Fields",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Components/Texturing/X3DTextureCoordinateNode",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Texturing/TextureCoordinateGeneratorModeType",
],
function (Fields,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DTextureCoordinateNode,
          X3DConstants,
          ModeType)
{
"use strict";

	function TextureCoordinateGenerator (executionContext)
	{
		X3DTextureCoordinateNode .call (this, executionContext);

		this .addType (X3DConstants .TextureCoordinateGenerator);

		this .mode      = ModeType .SPHERE;
		this .parameter = new Float32Array (6);
	}

	TextureCoordinateGenerator .prototype = Object .assign (Object .create (X3DTextureCoordinateNode .prototype),
	{
		constructor: TextureCoordinateGenerator,
		fieldDefinitions: new FieldDefinitionArray ([
			new X3DFieldDefinition (X3DConstants .inputOutput, "metadata",  new Fields .SFNode ()),
			new X3DFieldDefinition (X3DConstants .inputOutput, "mode",      new Fields .SFString ("SPHERE")),
			new X3DFieldDefinition (X3DConstants .inputOutput, "parameter", new Fields .MFFloat ()),
		]),
		getTypeName: function ()
		{
			return "TextureCoordinateGenerator";
		},
		getComponentName: function ()
		{
			return "Texturing";
		},
		getContainerField: function ()
		{
			return "texCoord";
		},
		initialize: function ()
		{
			X3DTextureCoordinateNode .prototype .initialize .call (this);

			this .mode_      .addInterest ("set_mode__",      this);
			this .parameter_ .addInterest ("set_parameter__", this);

			this .set_mode__ ();
			this .set_parameter__ ();
		},
		set_mode__: (function ()
		{
			var modes = new Map ([
				["SPHERE",                      ModeType .SPHERE],
				["CAMERASPACENORMAL",           ModeType .CAMERASPACENORMAL],
				["CAMERASPACEPOSITION",         ModeType .CAMERASPACEPOSITION],
				["CAMERASPACEREFLECTIONVECTOR", ModeType .CAMERASPACEREFLECTIONVECTOR],
				["SPHERE-LOCAL",                ModeType .SPHERE_LOCAL],
				["COORD",                       ModeType .COORD],
				["COORD-EYE",                   ModeType .COORD_EYE],
				["NOISE",                       ModeType .NOISE],
				["NOISE-EYE",                   ModeType .NOISE_EYE],
				["SPHERE-REFLECT",              ModeType .SPHERE_REFLECT],
				["SPHERE-REFLECT-LOCAL",        ModeType .SPHERE_REFLECT_LOCAL],
			]);

			return function ()
			{
				this .mode = modes .get (this .mode_ .getValue ());

				if (this .mode === undefined)
					this .mode = ModeType .SPHERE;
			};
		})(),
		set_parameter__: function ()
		{
			for (var i = 0, length = Math .min (this .parameter .length, this .parameter_ .length); i < length; ++ i)
				this .parameter [i] = this .parameter_ [i];

			this .parameter .fill (0, length);
		},
		get1Point: function (index, vector)
		{
			return vector;
		},
		addTexCoordToChannel: function (index, array)
		{
			array .push (0, 0, 0, 1);
		},
		getTexCoord: function (array)
		{
			return arrray;
		},
		setShaderUniformsToChannel: function (gl, shaderObject, channel)
		{
			gl .uniform1i  (shaderObject .x3d_TextureCoordinateGeneratorMode [channel],      this .mode);
			gl .uniform1fv (shaderObject .x3d_TextureCoordinateGeneratorParameter [channel], this .parameter);
		},
	});

	return TextureCoordinateGenerator;
});

/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Texturing',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Texturing/ImageTexture",
	"x_ite/Components/Texturing/MovieTexture",
	"x_ite/Components/Texturing/MultiTexture",
	"x_ite/Components/Texturing/MultiTextureCoordinate",
	"x_ite/Components/Texturing/MultiTextureTransform",
	"x_ite/Components/Texturing/PixelTexture",
	"x_ite/Components/Texturing/TextureCoordinate",
	"x_ite/Components/Texturing/TextureCoordinateGenerator",
	"x_ite/Components/Texturing/TextureProperties",
	"x_ite/Components/Texturing/TextureTransform",
	"x_ite/Components/Texturing/X3DTexture2DNode",
	"x_ite/Components/Texturing/X3DTextureCoordinateNode",
	"x_ite/Components/Texturing/X3DTextureNode",
	"x_ite/Components/Texturing/X3DTextureTransformNode",
],
function (SupportedNodes,
          ImageTexture,
          MovieTexture,
          MultiTexture,
          MultiTextureCoordinate,
          MultiTextureTransform,
          PixelTexture,
          TextureCoordinate,
          TextureCoordinateGenerator,
          TextureProperties,
          TextureTransform,
          X3DTexture2DNode,
          X3DTextureCoordinateNode,
          X3DTextureNode,
          X3DTextureTransformNode)
{
"use strict";

	var Types =
	{
		ImageTexture:               ImageTexture,
		MovieTexture:               MovieTexture,
		MultiTexture:               MultiTexture,
		MultiTextureCoordinate:     MultiTextureCoordinate,
		MultiTextureTransform:      MultiTextureTransform,
		PixelTexture:               PixelTexture,
		TextureCoordinate:          TextureCoordinate,
		TextureCoordinateGenerator: TextureCoordinateGenerator,
		TextureProperties:          TextureProperties,
		TextureTransform:           TextureTransform,
	};

	var AbstractTypes =
	{
		X3DTexture2DNode:         X3DTexture2DNode,
		X3DTextureCoordinateNode: X3DTextureCoordinateNode,
		X3DTextureNode:           X3DTextureNode,
		X3DTextureTransformNode:  X3DTextureTransformNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/*******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components/Time',[
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Time/TimeSensor",
	"x_ite/Components/Time/X3DTimeDependentNode",
],
function (SupportedNodes,
          TimeSensor,
          X3DTimeDependentNode)
{
"use strict";

	var Types =
	{
		TimeSensor: TimeSensor,
	};

	var AbstractTypes =
	{
		X3DTimeDependentNode: X3DTimeDependentNode,
	};
	
	for (var typeName in Types)
		SupportedNodes .addType (typeName, Types [typeName]); 

	for (var typeName in AbstractTypes)
		SupportedNodes .addAbstractType (typeName, AbstractTypes [typeName]); 
});


/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Components',[
	"x_ite/DEBUG",
	"x_ite/Browser/X3DBrowserContext",
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Components/Core",
	"x_ite/Components/EnvironmentalEffects",
	"x_ite/Components/EnvironmentalSensor",
	"x_ite/Components/Followers",
	"x_ite/Components/Geometry3D",
	"x_ite/Components/Grouping",
	"x_ite/Components/Interpolation",
	"x_ite/Components/Layering",
	"x_ite/Components/Lighting",
	"x_ite/Components/Navigation",
	"x_ite/Components/Networking",
	"x_ite/Components/PointingDeviceSensor",
	"x_ite/Components/Rendering",
	"x_ite/Components/Shaders",
	"x_ite/Components/Shape",
	"x_ite/Components/Sound",
	"x_ite/Components/Text",
	"x_ite/Components/Texturing",
	"x_ite/Components/Time",
],
function (DEBUG,
          X3DBrowserContext,
          SupportedNodes)
{
"use strict";

	function Components () { }

	Components .prototype =
	{
		addComponent: function (component)
		{
			if (component .types)
			{
				for (var typeName in component .types)
					SupportedNodes .addType (typeName, component .types [typeName]); 
			}

			if (component .abstractTypes)
			{
				for (var typeName in component .abstractTypes)
					SupportedNodes .addAbstractType (typeName, component .abstractTypes [typeName]);
			}

			if (component .browser)
				X3DBrowserContext .addContext (component .browser);

			if (component .name)
			{
				if (DEBUG)
					console .log ("Done loading external component '" + component .name + "'.");
			}
		},
	};

	return new Components ();
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/ProfileInfo',[],function ()
{
"use strict";

	function ProfileInfo (name, title, providerUrl, components)
	{
		this .name        = name;
		this .title       = title;
		this .providerUrl = providerUrl;
		this .components  = components;

		Object .preventExtensions (this);
		Object .freeze (this);
		Object .seal (this);
	}

	Object .assign (ProfileInfo .prototype,
	{
		constructor: ProfileInfo,
		toVRMLStream: function (stream)
		{
			stream .string += "PROFILE";
			stream .string += " ";
			stream .string += this .name;
		},
		toXMLStream: function (stream)
		{
			stream .string += this .name;
		},
	});

	return ProfileInfo;
});
/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/ProfileInfoArray',[
	"x_ite/Configuration/ComponentInfoArray",
	"x_ite/Configuration/ProfileInfo",
	"x_ite/Configuration/X3DInfoArray",
],
function (ComponentInfoArray,
          ProfileInfo,
          X3DInfoArray)
{
"use strict";

	function ProfileInfoArray ()
	{
		return X3DInfoArray .call (this);
	}

	ProfileInfoArray .prototype = Object .assign (Object .create (X3DInfoArray .prototype),
	{
		constructor: ProfileInfoArray,
		addProfile: function (value)
		{
			this .add (value .name, new ProfileInfo (value .name, value .title, value .providerUrl, new ComponentInfoArray (value .components)));
		},
	});

	return ProfileInfoArray;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/SupportedComponents',[
	"x_ite/Configuration/ComponentInfoArray",
	"x_ite/Browser/Networking/urls",
],
function (ComponentInfoArray,
          urls)
{
"use strict";

	var SupportedComponents = new ComponentInfoArray ();

	SupportedComponents .addBaseComponent (
	{
		title:      "Annotation",
		name:       "Annotation",
		level:       2,
		providerUrl: urls .getProviderUrl ("annotation"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Computer-Aided Design (CAD) model geometry",
		name:       "CADGeometry",
		level:       2,
		providerUrl: urls .getProviderUrl ("cad-geometry"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Core",
		name:       "Core",
		level:       2,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Cube map environmental texturing",
		name:       "CubeMapTexturing",
		level:       3,
		providerUrl: urls .getProviderUrl ("cube-map-texturing"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Distributed interactive simulation (DIS)",
		name:       "DIS",
		level:       2,
		providerUrl: urls .getProviderUrl ("dis"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Environmental effects",
		name:       "EnvironmentalEffects",
		level:       4,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Environmental sensor",
		name:       "EnvironmentalSensor",
		level:       4,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Event utilities",
		name:       "EventUtilities",
		level:       4,
		providerUrl: urls .getProviderUrl ("event-utilities"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Followers",
		name:       "Followers",
		level:       4,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Geometry2D",
		name:       "Geometry2D",
		level:       2,
		providerUrl: urls .getProviderUrl ("geometry2d"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Geometry3D",
		name:       "Geometry3D",
		level:       4,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Geospatial",
		name:       "Geospatial",
		level:       2,
		providerUrl: urls .getProviderUrl ("geospatial"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Grouping",
		name:       "Grouping",
		level:       3,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Humanoid animation (HAnim)",
		name:       "HAnim",
		level:       3,
		providerUrl: urls .getProviderUrl ("h-anim"),
	});

	SupportedComponents .addAlias ("H-Anim", "HAnim");

	SupportedComponents .addBaseComponent (
	{
		title:      "Interpolation",
		name:       "Interpolation",
		level:       5,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Key device sensor",
		name:       "KeyDeviceSensor",
		level:       2,
		providerUrl: urls .getProviderUrl ("key-device-sensor"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Layering",
		name:       "Layering",
		level:       1,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Layout",
		name:       "Layout",
		level:       2,
		providerUrl: urls .getProviderUrl ("layout"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Lighting",
		name:       "Lighting",
		level:       3,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Navigation",
		name:       "Navigation",
		level:       3,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Networking",
		name:       "Networking",
		level:       4,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Non-uniform Rational B-Spline (NURBS)",
		name:       "NURBS",
		level:       4,
		providerUrl: urls .getProviderUrl ("nurbs"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Particle systems",
		name:       "ParticleSystems",
		level:       3,
		providerUrl: urls .getProviderUrl ("particle-systems"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Picking sensor",
		name:       "Picking",
		level:       3,
		providerUrl: urls .getProviderUrl ("picking"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Pointing device sensor",
		name:       "PointingDeviceSensor",
		level:       1,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Projective Texture Mapping",
		name:       "ProjectiveTextureMapping",
		level:       2,
		providerUrl: urls .getProviderUrl ("projective-texture-mapping"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Programmable shaders",
		name:       "Shaders",
		level:       1,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Rendering",
		name:       "Rendering",
		level:       5,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Rigid body physics",
		name:       "RigidBodyPhysics",
		level:       5,
		providerUrl: urls .getProviderUrl ("rigid-body-physics"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Scripting",
		name:       "Scripting",
		level:       1,
		providerUrl: urls .getProviderUrl ("scripting"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Shape",
		name:       "Shape",
		level:       5,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Sound",
		name:       "Sound",
		level:       1,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Text",
		name:       "Text",
		level:       1,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Texturing",
		name:       "Texturing",
		level:       3,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Texturing3D",
		name:       "Texturing3D",
		level:       3,
		providerUrl: urls .getProviderUrl ("texturing-3d"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Time",
		name:       "Time",
		level:       2,
		providerUrl: urls .getProviderUrl (),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "Volume rendering",
		name:       "VolumeRendering",
		level:       2,
		providerUrl: urls .getProviderUrl ("volume-rendering"),
	});

	SupportedComponents .addBaseComponent (
	{
		title:      "X_ITE",
		name:       "X_ITE",
		level:       1,
		providerUrl: urls .getProviderUrl ("x_ite"),
	});

	return SupportedComponents;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Configuration/SupportedProfiles',[
	"x_ite/Configuration/ProfileInfo",
	"x_ite/Configuration/ProfileInfoArray",
	"x_ite/Configuration/ComponentInfoArray",
	"x_ite/Configuration/SupportedComponents",
	"x_ite/Browser/Networking/urls",
],
function (ProfileInfo,
          ProfileInfoArray,
          ComponentInfoArray,
          SupportedComponents,
          urls)
{
"use strict";

	var SupportedProfiles = new ProfileInfoArray ();

	SupportedProfiles .addProfile ({
		title: "Computer-Aided Design (CAD) interchange",
		name: "CADInterchange",
		providerUrl: urls .getProviderUrl (),
		components: [
			SupportedComponents ["CADGeometry"],
			SupportedComponents ["Core"],
			SupportedComponents ["Grouping"],
			SupportedComponents ["Lighting"],
			SupportedComponents ["Navigation"],
			SupportedComponents ["Networking"],
			SupportedComponents ["Rendering"],
			SupportedComponents ["Shaders"],
			SupportedComponents ["Shape"],
			SupportedComponents ["Texturing"],
		],
	});

	SupportedProfiles .addProfile ({
		title: "Core",
		name: "Core",
		providerUrl: urls .getProviderUrl (),
		components: [
			SupportedComponents ["Core"],
		],
	});

	SupportedProfiles .addProfile ({
		title: "Full",
		name: "Full",
		providerUrl: urls .getProviderUrl (),
		components: [
			SupportedComponents ["Annotation"],
			SupportedComponents ["CADGeometry"],
			SupportedComponents ["Core"],
			SupportedComponents ["CubeMapTexturing"],
			SupportedComponents ["DIS"],
			SupportedComponents ["EnvironmentalEffects"],
			SupportedComponents ["EnvironmentalSensor"],
			SupportedComponents ["EventUtilities"],
			SupportedComponents ["Followers"],
			SupportedComponents ["Geometry2D"],
			SupportedComponents ["Geometry3D"],
			SupportedComponents ["Geospatial"],
			SupportedComponents ["Grouping"],
			SupportedComponents ["HAnim"],
			SupportedComponents ["Interpolation"],
			SupportedComponents ["KeyDeviceSensor"],
			SupportedComponents ["Layering"],
			SupportedComponents ["Layout"],
			SupportedComponents ["Lighting"],
			SupportedComponents ["Navigation"],
			SupportedComponents ["Networking"],
			SupportedComponents ["NURBS"],
			SupportedComponents ["ParticleSystems"],
			SupportedComponents ["Picking"],
			SupportedComponents ["PointingDeviceSensor"],
			SupportedComponents ["ProjectiveTextureMapping"],
			SupportedComponents ["Rendering"],
			SupportedComponents ["RigidBodyPhysics"],
			SupportedComponents ["Scripting"],
			SupportedComponents ["Shaders"],
			SupportedComponents ["Shape"],
			SupportedComponents ["Sound"],
			SupportedComponents ["Text"],
			SupportedComponents ["Texturing"],
			SupportedComponents ["Texturing3D"],
			SupportedComponents ["Time"],
			SupportedComponents ["VolumeRendering"],
		],
	});

	SupportedProfiles .addProfile ({
		title: "Immersive",
		name: "Immersive",
		providerUrl: urls .getProviderUrl (),
		components: [
			SupportedComponents ["Core"],
			SupportedComponents ["EnvironmentalEffects"],
			SupportedComponents ["EnvironmentalSensor"],
			SupportedComponents ["EventUtilities"],
			SupportedComponents ["Geometry2D"],
			SupportedComponents ["Geometry3D"],
			SupportedComponents ["Grouping"],
			SupportedComponents ["Interpolation"],
			SupportedComponents ["KeyDeviceSensor"],
			SupportedComponents ["Lighting"],
			SupportedComponents ["Navigation"],
			SupportedComponents ["Networking"],
			SupportedComponents ["PointingDeviceSensor"],
			SupportedComponents ["Rendering"],
			SupportedComponents ["Scripting"],
			SupportedComponents ["Shape"],
			SupportedComponents ["Sound"],
			SupportedComponents ["Text"],
			SupportedComponents ["Texturing"],
			SupportedComponents ["Time"],
		],
	});

	SupportedProfiles .addProfile ({
		title: "Interactive",
		name: "Interactive",
		providerUrl: urls .getProviderUrl (),
		components: [
			SupportedComponents ["Core"],
			SupportedComponents ["EnvironmentalEffects"],
			SupportedComponents ["EnvironmentalSensor"],
			SupportedComponents ["EventUtilities"],
			SupportedComponents ["Geometry3D"],
			SupportedComponents ["Grouping"],
			SupportedComponents ["Interpolation"],
			SupportedComponents ["KeyDeviceSensor"],
			SupportedComponents ["Lighting"],
			SupportedComponents ["Navigation"],
			SupportedComponents ["Networking"],
			SupportedComponents ["PointingDeviceSensor"],
			SupportedComponents ["Rendering"],
			SupportedComponents ["Shape"],
			SupportedComponents ["Texturing"],
			SupportedComponents ["Time"],
		],
	});

	SupportedProfiles .addProfile ({
		title: "Interchange",
		name: "Interchange",
		providerUrl: urls .getProviderUrl (),
		components: [
			SupportedComponents ["Core"],
			SupportedComponents ["EnvironmentalEffects"],
			SupportedComponents ["Geometry3D"],
			SupportedComponents ["Grouping"],
			SupportedComponents ["Interpolation"],
			SupportedComponents ["Lighting"],
			SupportedComponents ["Navigation"],
			SupportedComponents ["Networking"],
			SupportedComponents ["Rendering"],
			SupportedComponents ["Shape"],
			SupportedComponents ["Texturing"],
			SupportedComponents ["Time"],
		],
	});

	SupportedProfiles .addProfile ({
		title: "Medical interchange",
		name: "MedicalInterchange",
		providerUrl: urls .getProviderUrl (),
		components: [
			SupportedComponents ["Core"],
			SupportedComponents ["EnvironmentalEffects"],
			SupportedComponents ["EventUtilities"],
			SupportedComponents ["Geometry2D"],
			SupportedComponents ["Geometry3D"],
			SupportedComponents ["Grouping"],
			SupportedComponents ["Interpolation"],
			SupportedComponents ["Lighting"],
			SupportedComponents ["Navigation"],
			SupportedComponents ["Networking"],
			SupportedComponents ["Rendering"],
			SupportedComponents ["Shape"],
			SupportedComponents ["Text"],
			SupportedComponents ["Texturing"],
			SupportedComponents ["Texturing3D"],
			SupportedComponents ["Time"],
			SupportedComponents ["VolumeRendering"],
		],
	});

	SupportedProfiles .addProfile ({
		title: "MPEG-4 interactive",
		name: "MPEG-4",
		providerUrl: urls .getProviderUrl (),
		components: [
			SupportedComponents ["Core"],
			SupportedComponents ["EnvironmentalEffects"],
			SupportedComponents ["EnvironmentalSensor"],
			SupportedComponents ["Geometry3D"],
			SupportedComponents ["Grouping"],
			SupportedComponents ["Interpolation"],
			SupportedComponents ["Lighting"],
			SupportedComponents ["Navigation"],
			SupportedComponents ["Networking"],
			SupportedComponents ["PointingDeviceSensor"],
			SupportedComponents ["Rendering"],
			SupportedComponents ["Shape"],
			SupportedComponents ["Texturing"],
			SupportedComponents ["Time"],
		],
	});

	return SupportedProfiles;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/Browser/X3DBrowser',[
	"jquery",
	"x_ite/Browser/VERSION",
	"x_ite/Base/Events",
	"x_ite/Fields",
	"x_ite/Components",
	"x_ite/Browser/X3DBrowserContext",
	"x_ite/Configuration/ComponentInfo",
	"x_ite/Configuration/SupportedProfiles",
	"x_ite/Configuration/SupportedComponents",
	"x_ite/Configuration/SupportedNodes",
	"x_ite/Execution/Scene",
	"x_ite/Execution/X3DScene",
	"x_ite/InputOutput/FileLoader",
	"x_ite/Parser/XMLParser",
	"x_ite/Parser/JSONParser",
	"x_ite/Bits/X3DConstants",
	"standard/Utility/MapUtilities",
	"locale/gettext",
],
function ($,
          VERSION,
          Events,
          Fields,
          Components,
          X3DBrowserContext,
          ComponentInfo,
          SupportedProfiles,
          SupportedComponents,
          SupportedNodes,
          Scene,
          X3DScene,
          FileLoader,
          XMLParser,
          JSONParser,
          X3DConstants,
          MapUtilities,
          _)
{
"use strict";

	function X3DBrowser (element)
	{
		//this .loadTime = performance .now () / 1000;

		X3DBrowserContext .call (this, element);

		this .currentSpeed     = 0;
		this .currentFrameRate = 60;
		this .components       = { };
		this .browserCallbacks = new Map ();

		this .replaceWorld (this .createScene ());
	};

	X3DBrowser .prototype = Object .assign (Object .create (X3DBrowserContext .prototype),
	{
		constructor: X3DBrowser,
		getTypeName: function ()
		{
			return "X3DBrowser";
		},
		getComponentName: function ()
		{
			return "X_ITE";
		},
		getContainerField: function ()
		{
			return "browser";
		},
		initialize: function ()
		{
			//console .log (performance .now () / 1000 - this .loadTime);

			X3DBrowserContext .prototype .initialize .call (this);

			var urlCharacters = this .getElement () .attr ("src");

			if (urlCharacters)
				urlCharacters = '"' + urlCharacters + '"';
			else
				urlCharacters = this .getElement () .attr ("url");

			if (urlCharacters)
			{
				this .initialized () .set (this .getCurrentTime ());

				this .load (urlCharacters);
			}
			else
			{
				this .initialized () .setValue (this .getCurrentTime ());
				this .callBrowserCallbacks (X3DConstants .INITIALIZED_EVENT);
				this .callBrowserEventHandler ("onload");
			}

			// Print welcome message.

			this .print ("Welcome to " + this .name + " X3D Browser " + this .version + ":\n" +
			             "   Current Graphics Renderer\n" +
			             "      Name: " + this .getVendor () + " " + this .getRenderer () + "\n" +
			             "      WebGL version: " + this .getWebGLVersion () + "\n" +
			             "      Shading language: " + this .getShadingLanguageVersion () + "\n" +
			             "   Rendering Properties\n" +
			             "      Antialiased: " + this .getAntialiased () + "\n" +
			             "      Depth size: " + this .getDepthSize () + " bits\n" +
			             "      Color depth: " + this .getColorDepth () + " bits\n" +
			             "      Max clip planes: " + this .getMaxClipPlanes () + "\n" +
			             "      Max global lights: " + this .getMaxLights () + "\n" +
			             "      Max textures: " + this .getMaxTextures () + "\n" +
			             "      Texture units: " + this .getMaxCombinedTextureUnits () + "\n" +
			             "      Max texture size: " + this .getMaxTextureSize () + " × " + this .getMaxTextureSize () + " pixel\n" +
			             "      Texture memory: " + this .getTextureMemory () + "\n" +
			             "      Max vertex uniform vectors: " + this .getMaxVertexUniformVectors () + "\n" +
			             "      Max fragment uniform vectors: " + this .getMaxFragmentUniformVectors () + "\n" +
			             "      Max vertex attribs: " + this .getMaxVertexAttribs () + "\n");
		},
		getName: function ()
		{
			return this .name;
		},
		getVersion: function ()
		{
			return this .version;
		},
		getCurrentSpeed: function ()
		{
			return this .currentSpeed;
		},
		getCurrentFrameRate: function ()
		{
			return this .currentFrameRate;
		},
		setDescription: function (value)
		{
			this .description = value;
		},
		getWorldURL: function ()
		{
			return this .currentScene .worldURL;
		},
		getProfile: function (name)
		{
			var profile = SupportedProfiles .get (name);

			if (profile)
				return profile;

			throw Error ("Profile '" + name + "' is not supported.");
		},
		getComponent: function (name, level)
		{
			var component = SupportedComponents .get (name);

			if (component)
			{
				if (level <= component .level || true)
					return new ComponentInfo (name, level, component .title, component. providerUrl);
			}

			throw Error ("Component '" + name + "' at level '" + level + "' is not supported.");
		},
		getSupportedNode: function (typeName)
		{
			return SupportedNodes .getType (typeName);
		},
		createScene: function (profile, component1 /*, ...*/)
		{
		   var scene = new Scene (this);

			if (arguments .length)
			{
				scene .setProfile (profile);

				for (var i = 1, length = arguments .length; i < length; ++ i)
					scene .addComponent (arguments [i]);
			}

			scene .setup ();

			if (this .isExternal ())
			   return scene;

			scene .setLive (true);

			return scene;
		},
		replaceWorld: function (scene)
		{
			// Cancel any loading.

			this .loadCount_       .removeInterest ("set_loadCount__", this);
			this .prepareEvents () .removeInterest ("bind", this);

			if (this .loader)
				this .loader .abort ();

			// Remove world.

			if (this .getWorld ())
			{
				this .getExecutionContext () .setLive (false);
				this .shutdown () .processInterests ();
				this .callBrowserCallbacks (X3DConstants .SHUTDOWN_EVENT);
				this .callBrowserEventHandler ("onshutdown");
			}

			// Clear event cache.
			Events .clear ();

			// Replace world.

			if (scene instanceof Fields .MFNode)
			{
				// VRML version of replaceWorld has a MFNode value as argument.

				var rootNodes = scene;

				scene = this .createScene ();

				for (var i = 0, length = rootNodes .length; i < length; ++ i)
					scene .isLive () .addInterest (rootNodes [i] .getValue () .getExecutionContext () .isLive ());

				scene .setRootNodes (rootNodes);
			}

			if (! (scene instanceof X3DScene))
				scene = this .createScene ();

			// bindWorld
			this .description = "";

			this .getBrowserOptions () .configure ();
			this .setBrowserLoading (true);
			this .loadCount_ .addInterest ("set_loadCount__", this);
			this .prepareEvents () .removeInterest ("bind", this);

			for (var id in scene .getLoadingObjects ())
				this .addLoadCount (scene .getLoadingObjects () [id]);

			scene .setLive (this .isLive () .getValue ());

			// Scene.setup is done in World.inititalize.
			this .setExecutionContext (scene);

			this .getWorld () .bind ();
		},
		set_loadCount__: function (loadCount)
		{
			if (loadCount .getValue ())
				return;

			this .loadCount_ .removeInterest ("set_loadCount__", this);

			this .prepareEvents () .addInterest ("bind", this);
			this .addBrowserEvent ();
		},
		bind: function ()
		{
			this .prepareEvents () .removeInterest ("bind", this);

			this .setBrowserLoading (false);

			if (this .initialized () .getValue ())
			{
				this .initialized () .setValue (this .getCurrentTime ());
				this .callBrowserCallbacks (X3DConstants .INITIALIZED_EVENT);
				this .callBrowserEventHandler ("onload");
			}
		},
		createVrmlFromString: function (vrmlSyntax)
		{
			return this .createX3DFromString (vrmlSyntax) .rootNodes;
		},
		createX3DFromString: function (x3dSyntax)
		{
			var
				currentScene = this .currentScene,
				external     = this .isExternal (),
				scene        = new FileLoader (this .getWorld ()) .createX3DFromString (this .currentScene .getURL (), x3dSyntax);

			if (! external)
			{
				scene .setExecutionContext (currentScene);
				currentScene .isLive () .addInterest ("setLive", scene);

				if (currentScene .isLive () .getValue ())
					scene .setLive (true);
			}

			scene .setup ();

			return scene;
		},
		createVrmlFromURL: function (url, node, event)
		{
			if (! (node instanceof Fields .SFNode))
				throw new Error ("Browser.createVrmlFromURL: node must be of type SFNode.");

			if (! node .getValue ())
				throw new Error ("Browser.createVrmlFromURL: node IS NULL.");

			var field = node .getValue () .getField (event);

			if (! field .isInput ())
				throw new Error ("Browser.createVrmlFromURL: event named '" + event + "' must be a input field.");

			if (field .getType () !== X3DConstants .MFNode)
				throw new Error ("Browser.createVrmlFromURL: event named '" + event + "' must be of type MFNode.");

			var
				currentScene = this .currentScene,
				external     = this .isExternal (),
				loader       = new FileLoader (this .getWorld ());

			this .addLoadCount (loader);

			loader .createX3DFromURL (url, null,
			function (scene)
			{
				this .removeLoadCount (loader);

				if (scene)
				{
					// Handle isLive for script scenes here:

				   if (! external)
				   {
						scene .setExecutionContext (currentScene);
				      currentScene .isLive () .addInterest ("setLive", scene);

						if (currentScene .isLive () .getValue ())
						   scene .setLive (true);
					}

					scene .setup ();

					// Wait until scene is completely loaded, scene .loadCount_ must be 0.
					field .setValue (scene .rootNodes);
				}
			}
			.bind (this));
		},
		createX3DFromURL: function (url, event, node)
		{
			if (arguments .length === 3)
				return this .createVrmlFromURL (url, event, node);

			var
				currentScene = this .currentScene,
				external     = this .isExternal (),
				scene        = new FileLoader (this .getWorld ()) .createX3DFromURL (url, null);

			if (! external)
			{
				scene .setExecutionContext (currentScene);
				currentScene .isLive () .addInterest ("setLive", scene);

				if (currentScene .isLive () .getValue ())
					scene .setLive (true);
			}

			scene .setup ();

			return scene;
		},
		loadURL: function (url, parameter)
		{
			// Cancel any loading.

			this .loadCount_       .removeInterest ("set_loadCount__", this);
			this .prepareEvents () .removeInterest ("bind", this);

			if (this .loader)
				this .loader .abort ();

			// Start loading.

			this .setBrowserLoading (true);
			this .addLoadCount (this);

			this .loader = new FileLoader (this .getWorld ());

			this .loader .createX3DFromURL (url, parameter,
			function (scene)
			{
				if (! this .getBrowserOptions () .getSplashScreen ())
					this .getCanvas () .fadeIn (0);

				if (scene)
				{
					this .replaceWorld (scene);
				}
				else
				{
					this .callBrowserCallbacks (X3DConstants .CONNECTION_ERROR);
					this .callBrowserEventHandler ("onerror");

					setTimeout (function () { this .getSplashScreen () .find (".x_ite-private-spinner-text") .text (_ ("Failed loading world.")); } .bind (this), 31);
				}

				// Must not remove load count, replaceWorld does a resetLoadCount when it sets setBrowserLoading to true.
				// Don't set browser loading to false.
			}
			.bind (this),
			function (fragment)
			{
				this .currentScene .changeViewpoint (fragment);
				this .removeLoadCount (this);
				this .setBrowserLoading (false);
			}
			.bind (this),
			function (url, target)
			{
				if (target)
					window .open (url, target);
				else
					location = url;

				this .removeLoadCount (this);
				this .setBrowserLoading (false);
			}
			.bind (this));
		},
		addBrowserListener: function (callback, object)
		{
			// The string describes the name of the callback function to be called within the current ECMAScript context.
		},
		removeBrowserListener: function (callback)
		{
			// The string describes the name of the callback function to be called within the current ECMAScript context.
		},
		addBrowserCallback: function (key, object)
		{
			this .browserCallbacks .set (key, object);
		},
		removeBrowserCallback: function (key)
		{
			this .browserCallbacks .delete (key);
		},
		getBrowserCallbacks: function ()
		{
			return this .browserCallbacks;
		},
		callBrowserCallbacks: (function ()
		{
			var browserCallbacks = new Map ();

			return function (browserEvent)
			{
				if (this .browserCallbacks .size)
				{
					MapUtilities .assign (browserCallbacks, this .browserCallbacks) .forEach (function (browserCallback)
					{
						browserCallback (browserEvent);
					});
				}
			};
		})(),
		importDocument: function (dom, success, error)
		{
			if (! dom)
				return;

			var
				scene        = this .createScene (),
				currentScene = this .currentScene,
				external     = this .isExternal ();

			if (success)
			{
				new XMLParser (scene) .parseIntoScene (dom,
				function ()
				{
					if (! external)
					{
						scene .setExecutionContext (currentScene);
						currentScene .isLive () .addInterest ("setLive", scene);

						if (currentScene .isLive () .getValue ())
							scene .setLive (true);
					}

					success (scene);
				},
				function (message)
				{
					if (error)
						error (message);
				});
			}
			else
			{
				new XMLParser (scene) .parseIntoScene (dom);

				if (! external)
				{
					scene .setExecutionContext (currentScene);
					currentScene .isLive () .addInterest ("setLive", scene);

					if (currentScene .isLive () .getValue ())
						scene .setLive (true);
				}

				return scene;
			}
		},
		importJS: function (jsobj, success, error)
		{
			if (! jsobj)
				return;

			var
				scene        = this .createScene (),
				currentScene = this .currentScene,
				external     = this .isExternal ();

			if (success)
			{
				new JSONParser (scene) .parseJavaScript (jsobj,
				function ()
				{
					if (! external)
					{
						scene .setExecutionContext (currentScene);
						currentScene .isLive () .addInterest ("setLive", scene);

						if (currentScene .isLive () .getValue ())
							scene .setLive (true);
					}

					success (scene);
				},
				function (message)
				{
					if (error)
						error (message);
				});
			}
			else
			{
				new JSONParser (scene) .parseJavaScript (jsobj);

				if (! external)
				{
					scene .setExecutionContext (currentScene);
					currentScene .isLive () .addInterest ("setLive", scene);

					if (currentScene .isLive () .getValue ())
						scene .setLive (true);
				}

				return scene;
			}
		},
		getBrowserProperty: function (name)
		{
			return this .getBrowserProperties () .getField (name) .getValue ();
		},
		setBrowserOption: function (name, value)
		{
			this .getBrowserOptions () .getField (name) .setValue (value);
		},
		getBrowserOption: function (name)
		{
			return this .getBrowserOptions () .getField (name) .getValue ();
		},
		getRenderingProperty: function (name)
		{
			return this .getRenderingProperties () .getField (name) .getValue ();
		},
		firstViewpoint: function (layer)
		{
			if (! layer)
				layer = this .getActiveLayer ();

			if (layer)
			{
				var viewpoints = layer .getUserViewpoints ();

				if (viewpoints .length)
					this .bindViewpoint (viewpoints [0]);
			}
		},
		previousViewpoint: function (layer)
		{
			if (! layer)
				layer = this .getActiveLayer ();

			if (layer)
			{
				var viewpoints = layer .getUserViewpoints ();

				if (viewpoints .length === 0)
					return;

				var index = 0;

				for (var i = 0; i < viewpoints .length; ++ i)
				{
					if (viewpoints [i] .isBound_ .getValue ())
						break;

					++ index;
				}

				if (index < viewpoints .length)
				{
					if (index === 0)
						this .bindViewpoint (viewpoints [viewpoints .length - 1]);

					else
						this .bindViewpoint (viewpoints [index - 1]);
				}
				else
					this .bindViewpoint (viewpoints [viewpoints .length - 1]);
			}
		},
		nextViewpoint: function (layer)
		{
			if (! layer)
				layer = this .getActiveLayer ();

			if (layer)
			{
				var viewpoints = layer .getUserViewpoints ();

				if (viewpoints .length === 0)
					return;

				var index = 0;

				for (var i = 0; i < viewpoints .length; ++ i)
				{
					if (viewpoints [i] .isBound_ .getValue ())
						break;

					++ index;
				}

				if (index < viewpoints .length)
				{
					if (index === viewpoints .length - 1)
						this .bindViewpoint (viewpoints [0]);

					else
						this .bindViewpoint (viewpoints [index + 1]);
				}
				else
					this .bindViewpoint (viewpoints [0]);
			}
		},
		lastViewpoint: function (layer)
		{
			if (! layer)
				layer = this .getActiveLayer ();

			if (layer)
			{
				var viewpoints = layer .getUserViewpoints ();

				if (viewpoints .length)
					this .bindViewpoint (viewpoints [viewpoints .length - 1]);
			}
		},
		changeViewpoint: function (name)
		{
			try
			{
				this .currentScene .changeViewpoint (name);
			}
			catch (error)
			{
				console .log (error .message);
			}
		},
		bindViewpoint: function (viewpoint)
		{
			viewpoint .setAnimate (true); // VRML

			if (viewpoint .isBound_ .getValue ())
				viewpoint .transitionStart (viewpoint);

			else
				viewpoint .set_bind_ = true;
		},
		addRoute: function (fromNode, fromEventOut, toNode, toEventIn)
		{
			this .currentScene .addRoute (fromNode, fromEventOut, toNode, toEventIn);
		},
		deleteRoute: function (fromNode, fromEventOut, toNode, toEventIn)
		{
			try
			{
				var route = this .currentScene .getRoute (fromNode, fromEventOut, toNode, toEventIn);

				if (route)
					this .currentScene .deleteRoute (route);
			}
			catch (error)
			{
				console .log (error);
			}
		},
		beginUpdate: function ()
		{
			this .setLive (true);
			this .getExecutionContext () .setLive (true);
			this .advanceTime (performance .now ());
		},
		endUpdate: function ()
		{
			this .setLive (false);
			this .getExecutionContext () .setLive (false);
		},
		print: function ()
		{
			var string = "";

			for (var i = 0; i < arguments .length; ++ i)
				string += arguments [i];

			console .log (string);

			var consoleElement = $(".x_ite-console");

			if (consoleElement .length)
				consoleElement .append (document .createTextNode (string));
		},
		println: function ()
		{
			var string = "";

			for (var i = 0; i < arguments .length; ++ i)
				string += arguments [i];

			console .log (string);

			string += "\n";

			var element = $(".x_ite-console");

			if (element .length)
				element .append (document .createTextNode (string));
		},
	});

	Object .defineProperty (X3DBrowser .prototype, "name",
	{
		get: function () { return "X_ITE"; },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DBrowser .prototype, "version",
	{
		get: function () { return VERSION; },
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DBrowser .prototype, "description",
	{
		get: function ()
		{
			return this .getNotification () .string_ .getValue ();
		},
		set: function (value)
		{
			this .getNotification () .string_ = value;
		},
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DBrowser .prototype, "currentScene",
	{
		get: function ()
		{
			return this .getScriptStack () [this .getScriptStack () .length - 1] .getExecutionContext ();
		},
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DBrowser .prototype, "supportedProfiles",
	{
		get: function ()
		{
			return SupportedProfiles;
		},
		enumerable: true,
		configurable: false
	});

	Object .defineProperty (X3DBrowser .prototype, "supportedComponents",
	{
		get: function ()
		{
			return SupportedComponents;
		},
		enumerable: true,
		configurable: false
	});

	return X3DBrowser;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/


define ('x_ite/X3D',[
	"jquery",
	"x_ite/Error",
	"x_ite/Basic/X3DFieldDefinition",
	"x_ite/Basic/FieldDefinitionArray",
	"x_ite/Basic/X3DField",
	"x_ite/Basic/X3DArrayField",
	"x_ite/Fields",
	"x_ite/Browser/X3DBrowser",
	"x_ite/Configuration/ComponentInfo",
	"x_ite/Configuration/ComponentInfoArray",
	"x_ite/Configuration/ProfileInfo",
	"x_ite/Configuration/ProfileInfoArray",
	"x_ite/Configuration/UnitInfo",
	"x_ite/Configuration/UnitInfoArray",
	"x_ite/Execution/X3DExecutionContext",
	"x_ite/Execution/X3DScene",
	"x_ite/Prototype/ExternProtoDeclarationArray",
	"x_ite/Prototype/ProtoDeclarationArray",
	"x_ite/Prototype/X3DExternProtoDeclaration",
	"x_ite/Prototype/X3DProtoDeclaration",
	"x_ite/Routing/RouteArray",
	"x_ite/Routing/X3DRoute",
	"x_ite/Bits/X3DConstants",
	"x_ite/Browser/Networking/urls",
],
function ($,
          Error,
          X3DFieldDefinition,
          FieldDefinitionArray,
          X3DField,
          X3DArrayField,
          Fields,
          X3DBrowser,
          ComponentInfo,
          ComponentInfoArray,
          ProfileInfo,
          ProfileInfoArray,
          UnitInfo,
          UnitInfoArray,
          X3DExecutionContext,
          X3DScene,
          ExternProtoDeclarationArray,
          ProtoDeclarationArray,
          X3DExternProtoDeclaration,
          X3DProtoDeclaration,
          RouteArray,
          X3DRoute,
          X3DConstants,
          urls)
{
"use strict";

	// Console fallback

	if (! console)        console        = { };
	if (! console .log)   console .log   = function () { };
	if (! console .info)  console .info  = console .log;
	if (! console .warn)  console .warn  = console .log;
	if (! console .error) console .error = console .log;

	// DEBUG
	//	function print ()
	//	{
	//		var string = "";
	//
	//		for (var i = 0; i < arguments .length; ++ i)
	//			string += arguments [i];
	//
	//		$(".x_ite-console") .append (string);
	//	}
	//
	//	console .log   = print;
	//	console .info  = print;
	//	console .warn  = print;
	//	console .error = print;

	// X3D

	function createBrowser (url, parameter)
	{
		var element = $("<X3DCanvas></X3DCanvas>");

		if (url instanceof Fields .MFString)
			 element .attr ("url", url .toString ())

		createBrowserFromElement (element);

		return element [0];
	}

	function getBrowser (dom)
	{
		return $(dom || "X3DCanvas") .data ("browser");
	}

	function createBrowserFromElement (dom)
	{
		dom = $(dom);

		if (dom .find (".x_ite-private-browser") .length)
			return;

		var browser = new X3DBrowser (dom);

		dom .data ("browser", browser);

		browser .setup ();

		return browser;
	}

	var
		initialized = false,
		callbacks   = $.Deferred (),
		fallbacks   = $.Deferred ();

	function X3D (callback, fallback)
	{
		if (typeof callback === "function")
			callbacks .done (callback);

		if (typeof fallback === "function")
			fallbacks .done (fallback);

		if (initialized)
			return;

		initialized = true;

		$(function ()
		{
			var elements = $("X3DCanvas");

			elements .children () .hide ();

			try
			{
				$.map (elements, createBrowserFromElement);
				callbacks .resolve ();
			}
			catch (error)
			{
				Error .fallback (elements, error);
				fallbacks .resolve (error);
			}
		});
	}

	function getComponentUrl (name)
	{
		return urls .getProviderUrl (name);
	}

	Object .assign (X3D,
	{
		require:                     require,
		define:                      define,
		getComponentUrl:             getComponentUrl,

		getBrowser:                  getBrowser,
		createBrowser:               createBrowser,

		X3DConstants:                X3DConstants,
		X3DBrowser:                  X3DBrowser,
		X3DExecutionContext:         X3DExecutionContext,
		X3DScene:                    X3DScene,
		ComponentInfo:               ComponentInfo,
		ComponentInfoArray:          ComponentInfoArray,
		ProfileInfo:                 ProfileInfo,
		ProfileInfoArray:            ProfileInfoArray,
		UnitInfo:                    UnitInfo,
		UnitInfoArray:               UnitInfoArray,
		ExternProtoDeclarationArray: ExternProtoDeclarationArray,
		ProtoDeclarationArray:       ProtoDeclarationArray,
		X3DExterProtonDeclaration:   X3DExternProtoDeclaration,
		X3DProtoDeclaration:         X3DProtoDeclaration,
		RouteArray:                  RouteArray,
		X3DRoute:                    X3DRoute,

		X3DFieldDefinition:          X3DFieldDefinition,
		FieldDefinitionArray:        FieldDefinitionArray,

		X3DField:                    X3DField,
		X3DArrayField:               X3DArrayField,

		SFColor:                     Fields .SFColor,
		SFColorRGBA:                 Fields .SFColorRGBA,
		SFImage:                     Fields .SFImage,
		SFMatrix3d:                  Fields .SFMatrix3d,
		SFMatrix3f:                  Fields .SFMatrix3f,
		SFMatrix4d:                  Fields .SFMatrix4d,
		SFMatrix4f:                  Fields .SFMatrix4f,
		SFNode:                      Fields .SFNode,
		SFRotation:                  Fields .SFRotation,
		SFVec2d:                     Fields .SFVec2d,
		SFVec2f:                     Fields .SFVec2f,
		SFVec3d:                     Fields .SFVec3d,
		SFVec3f:                     Fields .SFVec3f,
		SFVec4d:                     Fields .SFVec4d,
		SFVec4f:                     Fields .SFVec4f,
		VrmlMatrix:                  Fields .VrmlMatrix,
							              
		MFBool:                      Fields .MFBool,
		MFColor:                     Fields .MFColor,
		MFColorRGBA:                 Fields .MFColorRGBA,
		MFDouble:                    Fields .MFDouble,
		MFFloat:                     Fields .MFFloat,
		MFImage:                     Fields .MFImage,
		MFInt32:                     Fields .MFInt32,
		MFMatrix3d:                  Fields .MFMatrix3d,
		MFMatrix3f:                  Fields .MFMatrix3f,
		MFMatrix4d:                  Fields .MFMatrix4d,
		MFMatrix4f:                  Fields .MFMatrix4f,
		MFNode:                      Fields .MFNode,
		MFRotation:                  Fields .MFRotation,
		MFString:                    Fields .MFString,
		MFTime:                      Fields .MFTime,
		MFVec2d:                     Fields .MFVec2d,
		MFVec2f:                     Fields .MFVec2f,
		MFVec3d:                     Fields .MFVec3d,
		MFVec3f:                     Fields .MFVec3f,
		MFVec4d:                     Fields .MFVec4d,
		MFVec4f:                     Fields .MFVec4f,
	});

	return X3D;
});

/* -*- Mode: JavaScript; coding: utf-8; tab-width: 3; indent-tabs-mode: tab; c-basic-offset: 3 -*-
 *******************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright create3000, Scheffelstraße 31a, Leipzig, Germany 2011.
 *
 * All rights reserved. Holger Seelig <holger.seelig@yahoo.de>.
 *
 * The copyright notice above does not evidence any actual of intended
 * publication of such source code, and is an unpublished work by create3000.
 * This material contains CONFIDENTIAL INFORMATION that is the property of
 * create3000.
 *
 * No permission is granted to copy, distribute, or create derivative works from
 * the contents of this software, in whole or in part, without the prior written
 * permission of create3000.
 *
 * NON-MILITARY USE ONLY
 *
 * All create3000 software are effectively free software with a non-military use
 * restriction. It is free. Well commented source is provided. You may reuse the
 * source in any way you please with the exception anything that uses it must be
 * marked to indicate is contains 'non-military use only' components.
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2015, 2016 Holger Seelig <holger.seelig@yahoo.de>.
 *
 * This file is part of the X_ITE Project.
 *
 * X_ITE is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 3 only, as published by the
 * Free Software Foundation.
 *
 * X_ITE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License version 3 for more
 * details (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version 3
 * along with X_ITE.  If not, see <http://www.gnu.org/licenses/gpl.html> for a
 * copy of the GPLv3 License.
 *
 * For Silvio, Joy and Adi.
 *
 ******************************************************************************/

var module = { };

require .config ({
	"waitSeconds": 0,
});

var getScriptURL = (function ()
{
	var
		scripts = document .getElementsByTagName ('script'),
		src     = scripts [scripts .length - 1] .src;

	return function ()
	{
		return src;
	};
})();

(function ()
{
"use strict";

	function X_ITE (callback, fallback)
	{
		if (PrivateX3D)
		{
			PrivateX3D (callback, fallback);
		}
		else
		{
			callbacks .push (callback);
			fallbacks .push (fallback);
		}
	}

	function fallback (error)
	{
		require (["x_ite/Error"],
		function (Error)
		{
			Error (error, fallbacks);
		});
	}

	function noConflict ()
	{
		if (window .X3D === X_ITE)
		{
			if (X3D_ === undefined)
				delete window .X3D;
			else
				window .X3D = X3D_;
		}

		return X_ITE;
	}

	var
		X3D_       = window .X3D,
		PrivateX3D = null;

	X_ITE .noConflict = noConflict;
	X_ITE .require    = require;
	X_ITE .define     = define;

	// Now assign temporary X3D.
	window .X3D = X_ITE;

	// IE fix.
	document .createElement ("X3DCanvas");

	if (window .Proxy === undefined)
		return fallback ("Proxy is not defined");

	var
		callbacks = [ ],
		fallbacks = [ ];

	require (["jquery", "x_ite/X3D"],
	function ($, X3D)
	{
		$ .noConflict (true);

		// Now assign real X3D.
		PrivateX3D = X3D;

		Object .assign (X_ITE, X3D);

		// Initialize all X3DCanvas tags.
		X3D ();

		for (var i = 0; i < callbacks .length; ++ i)
		   X3D (callbacks [i], fallbacks [i]);
	},
	fallback);

}) ();

define("x_ite", function(){});


define ('x_ite/Browser/Shaders/ShaderSource',[
],
function ()
{
"use strict";

	return {
		get: function (gl, source)
		{
			return source;
		},
	};
});

for (var key in x_iteNoConfict)
{
	if (x_iteNoConfict [key] === undefined)
		delete window [key];
	else
		window [key] = x_iteNoConfict [key];
}
}());
