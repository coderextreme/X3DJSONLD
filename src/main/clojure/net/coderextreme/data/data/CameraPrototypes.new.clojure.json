{ "X3D": {
    "encoding":"UTF-8",
"@profile":"Immersive",
"@version":"3.2",
"@xsd:noNamespaceSchemaLocation":"https://www.web3d.org/specifications/x3d-3.2.xsd",
    "JSON schema":"https://www.web3d.org/specifications/x3d-4.0-JSONSchema.autogenerated.json",
"head": {
"meta": [
{
"@name":"title",
"@content":"CameraPrototypes.x3d"
},
{
"@name":"description",
"@content":"Camera, CameraShot and CameraMovement prototypes that demonstrate storyboard
capabilities and precise camera operation. This is a developmental effort for potential
X3D Specification improvement."
},
{
"@name":"creator",
"@content":"Don Brutzman and Jeff Weekley"
},
{
"@name":"created",
"@content":"16 March 2009"
},
{
"@name":"modified",
"@content":"25 October 2016"
},
{
"@name":"TODO",
"@content":"Schematron rules, backed up by initialize() checks"
},
{
"@name":"reference",
"@content":"BeyondViewpointCameraNodesWeb3D2009.pdf"
},
{
"@name":"reference",
"@content":"https://www.web3d.org/x3d/specifications/ISO-IEC-FDIS-19775-1.2-X3D-AbstractSpecification/Part01/components/navigation.html"
},
{
"@name":"subject",
"@content":"Camera nodes for Viewpoint navigation control"
},
{
"@name":"reference",
"@content":"CameraExamples.x3d"
},
{
"@name":"identifier",
"@content":"https://www.web3d.org/x3d/content/examples/Basic/development/CameraPrototypes.x3d"
},
{
"@name":"reference",
"@content":"http://sourceforge.net/p/x3d/code/HEAD/tree/www.web3d.org/x3d/content/examples/Basic/development/CameraPrototypes.x3d"
},
{
"@name":"generator",
"@content":"X3D-Edit 3.3, https://savage.nps.edu/X3D-Edit"
},
{
"@name":"license",
"@content":"../license.html"
},
{
"@name":"translated",
"@content":"15 July 2025"
},
{
"@name":"generator",
"@content":"X3dToJson.xslt, https://www.web3d.org/x3d/stylesheets/X3dToJson.html"
},
{
"@name":"reference",
"@content":"X3D JSON encoding: https://www.web3d.org/wiki/index.php/X3D_JSON_Encoding"
}
]
},
"Scene": {
"-children":[
{ "ProtoDeclare":
{
"@name":"Camera",
"@appinfo":"Camera node provides direct control of scene view to enable cinematic
camera animation shot by shot and move by move along with still digital-photography
settings for offline rendering of camera images.",
"ProtoInterface": {
"field": [
{
"@name":"description",
"@accessType":"inputOutput",
"@appinfo":"Text description to be displayed for this Camera",
"@type":"SFString"
},
{
"@name":"position",
"@accessType":"inputOutput",
"@appinfo":"Camera position in local transformation frame, which is default prior
to first CameraShot initialPosition getting activated",
"@type":"SFVec3f",
"@value":[0,0,10]
},
{
"@name":"orientation",
"@accessType":"inputOutput",
"@appinfo":"Camera rotation in local transformation frame, which is default prior
to first CameraShot initialPosition getting activated",
"@type":"SFRotation",
"@value":[0,0,1,0]
},
{
"@name":"fieldOfView",
"@accessType":"inputOutput",
"@appinfo":"pi/4",
"@type":"SFFloat",
"@value":0.7854
},
{
"@name":"set_fraction",
"@accessType":"inputOnly",
"@appinfo":"input fraction drives interpolators",
"@type":"SFFloat"
},
{
"@name":"set_bind",
"@accessType":"inputOnly",
"@appinfo":"input event binds or unbinds this Camera",
"@type":"SFBool"
},
{
"@name":"bindTime",
"@accessType":"outputOnly",
"@appinfo":"output event indicates when this Camera is bound",
"@type":"SFTime"
},
{
"@name":"isBound",
"@accessType":"outputOnly",
"@appinfo":"output event indicates whether this Camera is bound or unbound",
"@type":"SFBool"
},
{
"@name":"nearClipPlane",
"@accessType":"inputOutput",
"@appinfo":"Vector distance to near clipping plane corresponds to NavigationInfo.avatarSize[0]",
"@type":"SFFloat",
"@value":0.25
},
{
"@name":"farClipPlane",
"@accessType":"inputOutput",
"@appinfo":"Vector distance to far clipping plane corresponds to NavigationInfo.visibilityLimit",
"@type":"SFFloat",
"@value":0.0
},
{
"@name":"shots",
"@accessType":"inputOutput",
"@appinfo":"Array of CameraShot nodes which in turn contain CameraMovement nodes",
"@type":"MFNode"
},
{
"@name":"headlight",
"@accessType":"inputOutput",
"@appinfo":"Whether camera headlight is on or off",
"@type":"SFBool",
"@value":true
},
{
"@name":"headlightColor",
"@accessType":"inputOutput",
"@appinfo":"Camera headlight color",
"@type":"SFColor",
"@value":[1,1,1]
},
{
"@name":"headlightIntensity",
"@accessType":"inputOutput",
"@appinfo":"Camera headlight intensity",
"@type":"SFFloat",
"@value":1.0
},
{
"@name":"filterColor",
"@accessType":"inputOutput",
"@appinfo":"Camera filter color that modifies virtual lens capture",
"@type":"SFColor",
"@value":[1,1,1]
},
{
"@name":"filterTransparency",
"@accessType":"inputOutput",
"@appinfo":"Camera filter transparency that modifies virtual lens capture",
"@type":"SFFloat",
"@value":1.0
},
{
"@name":"upVector",
"@accessType":"inputOutput",
"@appinfo":"upVector changes modify camera orientation (and possibly vice versa)",
"@type":"SFVec3f",
"@value":[0,1,0]
},
{
"@name":"fStop",
"@accessType":"inputOutput",
"@appinfo":"Focal length divided effective aperture diameter indicating width of focal
plane",
"@type":"SFFloat",
"@value":5.6
},
{
"@name":"focusDistance",
"@accessType":"inputOutput",
"@appinfo":"Distance to focal plane of sharpest focus",
"@type":"SFFloat",
"@value":10.0
},
{
"@name":"isActive",
"@accessType":"outputOnly",
"@appinfo":"Mark start/stop with true/false output respectively useful to trigger
external animations",
"@type":"SFBool"
},
{
"@name":"totalDuration",
"@accessType":"outputOnly",
"@appinfo":"Total duration of contained enabled CameraShot (and thus CameraMovement)
move durations",
"@type":"SFTime"
},
{
"@name":"offlineRender",
"@accessType":"inputOutput",
"@appinfo":"OfflineRender node",
"@type":"SFNode"
},
{
"@name":"traceEnabled",
"@accessType":"initializeOnly",
"@appinfo":"enable console output to trace script computations and prototype progress",
"@type":"SFBool",
"@value":false
}
]
},
"ProtoBody": {
"-children":[
{ "Viewpoint":
{
"@DEF":"CameraViewpoint",
"IS": {
"connect": [
{
"@nodeField":"description",
"@protoField":"description"
},
{
"@nodeField":"position",
"@protoField":"position"
},
{
"@nodeField":"orientation",
"@protoField":"orientation"
},
{
"@nodeField":"fieldOfView",
"@protoField":"fieldOfView"
},
{
"@nodeField":"set_bind",
"@protoField":"set_bind"
},
{
"@nodeField":"bindTime",
"@protoField":"bindTime"
},
{
"@nodeField":"isBound",
"@protoField":"isBound"
}
]
}
}
},
{ "NavigationInfo":
{
"@DEF":"CameraNavInfo",
"@type":"\"EXAMINE\" \"FLY\" \"ANY\"",
"IS": {
"connect": [
{
"@nodeField":"set_bind",
"@protoField":"set_bind"
},
{
"@nodeField":"headlight",
"@protoField":"headlight"
},
{
"@nodeField":"visibilityLimit",
"@protoField":"farClipPlane"
}
]
}
}
},
{ "DirectionalLight":
{
"@DEF":"CameraDirectionalLight",
"@global":true,
"IS": {
"connect": [
{
"@nodeField":"on",
"@protoField":"headlight"
},
{
"@nodeField":"color",
"@protoField":"headlightColor"
},
{
"@nodeField":"intensity",
"@protoField":"headlightIntensity"
}
]
}
}
},
{ "PositionInterpolator":
{
"@DEF":"CameraPositionInterpolator",
"@key":[0,1],
"@keyValue":[0,0,0,0,0,0],
"IS": {
"connect": [
{
"@nodeField":"set_fraction",
"@protoField":"set_fraction"
}
]
}
}
},
{ "OrientationInterpolator":
{
"@DEF":"CameraOrientationInterpolator",
"@key":[0,1],
"@keyValue":[0,1,0,0,0,1,0,0],
"IS": {
"connect": [
{
"@nodeField":"set_fraction",
"@protoField":"set_fraction"
}
]
}
}
},
{ "ROUTE":
{
"@fromField":"value_changed",
"@fromNode":"CameraPositionInterpolator",
"@toField":"position",
"@toNode":"CameraViewpoint"
}
},
{ "ROUTE":
{
"@fromField":"value_changed",
"@fromNode":"CameraOrientationInterpolator",
"@toField":"orientation",
"@toNode":"CameraViewpoint"
}
},
{ "Script":
{
"@DEF":"CameraScript",
"@directOutput":true,
"@mustEvaluate":true,
"field": [
{
"@name":"description",
"@accessType":"inputOutput",
"@appinfo":"Text description to be displayed for this Camera",
"@type":"SFString"
},
{
"@name":"position",
"@accessType":"inputOutput",
"@appinfo":"Camera position in local transformation frame",
"@type":"SFVec3f"
},
{
"@name":"orientation",
"@accessType":"inputOutput",
"@appinfo":"Camera rotation in local transformation frame",
"@type":"SFRotation"
},
{
"@name":"set_fraction",
"@accessType":"inputOnly",
"@appinfo":"input fraction drives interpolators",
"@type":"SFFloat"
},
{
"@name":"set_bind",
"@accessType":"inputOnly",
"@appinfo":"input event binds or unbinds this Camera",
"@type":"SFBool"
},
{
"@name":"fieldOfView",
"@accessType":"inputOutput",
"@appinfo":"pi/4",
"@type":"SFFloat"
},
{
"@name":"nearClipPlane",
"@accessType":"inputOutput",
"@appinfo":"Vector distance to near clipping plane",
"@type":"SFFloat"
},
{
"@name":"farClipPlane",
"@accessType":"inputOutput",
"@appinfo":"Vector distance to far clipping plane",
"@type":"SFFloat"
},
{
"@name":"shots",
"@accessType":"inputOutput",
"@appinfo":"Array of CameraShot nodes which in turn contain CameraMovement nodes",
"@type":"MFNode"
},
{
"@name":"filterColor",
"@accessType":"inputOutput",
"@appinfo":"Camera filter color that modifies virtual lens capture",
"@type":"SFColor"
},
{
"@name":"filterTransparency",
"@accessType":"inputOutput",
"@appinfo":"Camera filter transparency that modifies virtual lens capture",
"@type":"SFFloat"
},
{
"@name":"upVector",
"@accessType":"inputOutput",
"@appinfo":"upVector changes modify camera orientation (and possibly vice versa)",
"@type":"SFVec3f"
},
{
"@name":"fStop",
"@accessType":"inputOutput",
"@appinfo":"Focal length divided effective aperture diameter indicating width of focal
plane",
"@type":"SFFloat"
},
{
"@name":"focusDistance",
"@accessType":"inputOutput",
"@appinfo":"Distance to focal plane of sharpest focus",
"@type":"SFFloat"
},
{
"@name":"isActive",
"@accessType":"outputOnly",
"@appinfo":"Mark start/stop with true/false output respectively useful to trigger
external animations",
"@type":"SFBool"
},
{
"@name":"totalDuration",
"@accessType":"outputOnly",
"@appinfo":"Total duration of contained enabled CameraShot (and thus CameraMovement)
move durations",
"@type":"SFTime"
},
{
"@name":"offlineRender",
"@accessType":"inputOutput",
"@appinfo":"OfflineRender node",
"@type":"SFNode"
},
{
"@name":"ViewpointNode",
"@accessType":"initializeOnly",
"@appinfo":"node reference to permit getting setting fields from within Script",
"@type":"SFNode",
"-children":[
{ "Viewpoint":
{
"@USE":"CameraViewpoint"
}
}
]
},
{
"@name":"NavInfoNode",
"@accessType":"initializeOnly",
"@appinfo":"node reference to permit getting setting fields from within Script",
"@type":"SFNode",
"-children":[
{ "NavigationInfo":
{
"@USE":"CameraNavInfo"
}
}
]
},
{
"@name":"CameraPI",
"@accessType":"initializeOnly",
"@appinfo":"node reference to permit getting setting fields from within Script",
"@type":"SFNode",
"-children":[
{ "PositionInterpolator":
{
"@USE":"CameraPositionInterpolator"
}
}
]
},
{
"@name":"CameraOI",
"@accessType":"initializeOnly",
"@appinfo":"node reference to permit getting setting fields from within Script",
"@type":"SFNode",
"-children":[
{ "OrientationInterpolator":
{
"@USE":"CameraOrientationInterpolator"
}
}
]
},
{
"@name":"key",
"@accessType":"inputOutput",
"@appinfo":"key array for interpolators",
"@type":"MFFloat"
},
{
"@name":"keyValuePosition",
"@accessType":"inputOutput",
"@appinfo":"keyValue array for PositionInterpolator",
"@type":"MFVec3f"
},
{
"@name":"keyValueOrientation",
"@accessType":"inputOutput",
"@appinfo":"keyValue array for OrientationInterpolator",
"@type":"MFRotation"
},
{
"@name":"animated",
"@accessType":"inputOutput",
"@appinfo":"whether internal CameraShot and CameraMove nodes are tracking or changed
via ROUTE events",
"@type":"SFBool",
"@value":false
},
{
"@name":"initialized",
"@accessType":"initializeOnly",
"@appinfo":"perform checkShots() function once immediately after initialization",
"@type":"SFBool",
"@value":false
},
{
"@name":"shotCount",
"@accessType":"initializeOnly",
"@appinfo":"how many CameraShot nodes are contained in shots array",
"@type":"SFInt32",
"@value":0
},
{
"@name":"movesCount",
"@accessType":"initializeOnly",
"@appinfo":"how many CameraMove nodes are contained in moves array",
"@type":"SFInt32",
"@value":0
},
{
"@name":"frameCount",
"@accessType":"initializeOnly",
"@appinfo":"how many frames were created in current loop",
"@type":"SFFloat",
"@value":0.0
},
{
"@name":"startTime",
"@accessType":"initializeOnly",
"@appinfo":"holding variable",
"@type":"SFTime",
"@value":0.0
},
{
"@name":"priorTraceTime",
"@accessType":"initializeOnly",
"@appinfo":"holding variable",
"@type":"SFTime",
"@value":0.0
},
{
"@name":"traceEnabled",
"@accessType":"initializeOnly",
"@appinfo":"enable console output to trace script computations and prototype progress",
"@type":"SFBool"
}
],
"IS": {
"connect": [
{
"@nodeField":"description",
"@protoField":"description"
},
{
"@nodeField":"position",
"@protoField":"position"
},
{
"@nodeField":"orientation",
"@protoField":"orientation"
},
{
"@nodeField":"set_fraction",
"@protoField":"set_fraction"
},
{
"@nodeField":"set_bind",
"@protoField":"set_bind"
},
{
"@nodeField":"fieldOfView",
"@protoField":"fieldOfView"
},
{
"@nodeField":"nearClipPlane",
"@protoField":"nearClipPlane"
},
{
"@nodeField":"farClipPlane",
"@protoField":"farClipPlane"
},
{
"@nodeField":"shots",
"@protoField":"shots"
},
{
"@nodeField":"filterColor",
"@protoField":"filterColor"
},
{
"@nodeField":"filterTransparency",
"@protoField":"filterTransparency"
},
{
"@nodeField":"upVector",
"@protoField":"upVector"
},
{
"@nodeField":"fStop",
"@protoField":"fStop"
},
{
"@nodeField":"focusDistance",
"@protoField":"focusDistance"
},
{
"@nodeField":"isActive",
"@protoField":"isActive"
},
{
"@nodeField":"totalDuration",
"@protoField":"totalDuration"
},
{
"@nodeField":"offlineRender",
"@protoField":"offlineRender"
},
{
"@nodeField":"traceEnabled",
"@protoField":"traceEnabled"
}
]
},
"#sourceCode":[
"",
"",
"\newlinefunction initialize () // CameraScript\newline{\newline//  tracePrint ('initialize
start...');\newline\newline    NavInfoNode.avatarSize[0]   = nearClipPlane;\newline\newline
// remaining setups deferred to invocation of checkShots() method\newline    // thanks
to Yvonne Jung Fraunhofer for diagnosing better approach to function initialization\newline
alwaysPrint ('initialize complete');\newline}\newline\newlinefunction checkShots (eventValue)\newline{\newline
tracePrint ('checkShots() method should only occur after initialize() methods in all
other Scripts are complete');\newline\newline    // compute totalDuration by summing
durations from contained CameraShot and CameraMovement nodes\newline    totalDuration=
0;\newline    shotCount  = shots.length;\newline    movesCount = 0;\newline    for
(i = 0; i &lt; shotCount; i++) // shots index\newline    {\newline       tracePrint ('shots['
+ i + '].moves.length=' + shots[i].moves.length);\newline       movesCount   += shots[i].moves.length;\newline
totalDuration = totalDuration + shots[i].shotDuration;\newline       if (shots[i].moves.length
== 0)\newline       {\newline          alwaysPrint ('warning: CameraShot[' + i + ']['
+ shots[i].description + '] has no contained CameraMove nodes');\newline       }\newline
}\newline    // size checks before proceeding\newline    if (shotCount == 0)\newline
{\newline       alwaysPrint ('warning: no CameraShot nodes found for the shots, nothing
to do!');\newline       return;\newline    }\newline    else if (movesCount == 0)\newline
{\newline       alwaysPrint ('warning: no CameraMove nodes found for the shots, nothing
to do!');\newline       return;\newline    }\newline    else if (totalDuration ==
0)\newline    {\newline       alwaysPrint ('warning: totalDuration = 0 seconds, nothing
to do!');\newline       return;\newline    }\newline    tracePrint ('number of contained
CameraShot nodes=' + shotCount);\newline    tracePrint ('number of contained CameraMove
nodes=' + movesCount);\newline    tracePrint ('totalDuration=' + totalDuration + '
seconds for all shots and moves');\newline\newline    // compute interpolators\newline
var k = 0; // index for latest key, keyValuePosition, keyValueOrientation\newline
for (i = 0; i &lt; shotCount; i++) // shots index\newline    {\newline        if (i==0)
// initial entries\newline        {\newline           key[0]                   = 0.0;
// no previous move\newline           keyValuePosition[0]      = shots[i].initialPosition;\newline
keyValueOrientation[0]   = shots[i].initialOrientation;\newline        }\newline 
else     // new shot repositions, reorients camera as clean break from preceding shot/move\newline
{\newline           key[k+1]                 = key[k]; // start from end from previous
move\newline           keyValuePosition[k+1]    = shots[i].initialPosition;\newline
keyValueOrientation[k+1] = shots[i].initialOrientation;\newline           k++;\newline
}\newline        tracePrint (shots[i].description);\newline        tracePrint ('shots[i].moves.length='
+ shots[i].moves.length);\newline\newline        for (j = 0; j &lt; shots[i].moves.length;
j++) // moves index\newline        {\newline            var durationFloat =      
shots[i].moves[j].duration;  // implicit type conversion from SFTime\newline     
//  durationFloat = new SFFloat (shots[i].moves[j].duration); // explicit type conversion
from SFTime\newline            //  tracePrint ('durationFloat=' + durationFloat);\newline
key[k+1]               = key[k] + (durationFloat / totalDuration);\newline       
keyValuePosition[k+1]  = shots[i].moves[j].goalPosition;\newline            if (!animated)\newline
{\newline                 keyValueOrientation[k+1] = shots[i].moves[j].goalOrientation;\newline
}\newline            else\newline            {\newline                // using constructor
SFRotation (SFVec3f fromVector, SFVec3f toVector)\newline                // see X3D
ECMAScript binding Table 7.18 — SFRotation instance creation functions\newline\newline
// test if difference vector is zero, if so maintain previous rotation\newline   
var shotVector = ViewpointNode.position.subtract(shots[i].moves[j].goalAimPoint).normalize();\newline
if (shotVector.length() &gt;= 0)\newline                {\newline                   
// default view direction is along -Z axis\newline                    shots[i].moves[j].goalOrientation
= new SFRotation (new SFVec3f (0, 0, 1), shotVector);\newline                    keyValueOrientation[k+1]
= shots[i].moves[j].goalOrientation;\newline                }\newline            
else // note (k &gt; 0)\newline                {\newline                    keyValueOrientation[k+1]
= keyValueOrientation[k];  // no change\newline                }\newline\newline 
tracePrint ('shots[' + i + '].moves[' + j + '].goalAimPoint=' + shots[i].moves[j].goalAimPoint.toString());\newline
tracePrint ('        ViewpointNode.position=' + ViewpointNode.position.toString());\newline
tracePrint ('          shotVector     delta=' + ViewpointNode.position.subtract(shots[i].moves[j].goalAimPoint).toString());\newline
tracePrint ('          shotVector normalize=' + ViewpointNode.position.subtract(shots[i].moves[j].goalAimPoint).normalize().toString());\newline
tracePrint ('               goalOrientation=' + shots[i].moves[j].goalOrientation.toString());\newline
tracePrint ('      keyValueOrientation[k+1]=' + keyValueOrientation[k+1].toString()
+ '\n');\newline            }\newline            k++; // update index to match latest
key, keyValuePosition, keyValueOrientation\newline\newline            // check animated
parameter:  set true if any of moves are tracking moves\newline            if (!animated)
animated = shots[i].moves[j].tracking; // once true, remains true\newline        
// tracePrint ('shots[' + i + '].moves[' + j + '].tracking=' + shots[i].moves[j].tracking
+ ', animated=' + animated);\newline\newline            // intermediate trace\newline
tracePrint ('                key=' + key);\newline            tracePrint ('   keyValuePosition='
+ keyValuePosition);\newline            tracePrint ('keyValueOrientation=' + keyValueOrientation);\newline
tracePrint ('- ' + shots[i].moves[j].description);\newline        }\newline    }\newline
tracePrint ('                key=' + key);\newline    tracePrint ('   keyValuePosition='
+ keyValuePosition);\newline    tracePrint ('keyValueOrientation=' + keyValueOrientation);\newline
if (key.length != keyValuePosition.length)\newline    {\newline      alwaysPrint ('warning:
internal error during array construction, ' +\newline                  'key.length='
+ key.length + ' must equal ' +\newline                  'keyValuePosition.length='
+ keyValuePosition.length);\newline    }\newline    if (key.length != keyValueOrientation.length)\newline
{\newline      alwaysPrint ('warning: internal error during array construction, '
+\newline                  'key.length=' + key.length + ' must equal ' +\newline 
'keyValueOrientation.length=' + keyValueOrientation.length);\newline    }\newline
if (key.length != (shotCount + movesCount))\newline    {\newline      alwaysPrint
('warning: internal error during array construction, ' +\newline                 
'key.length=' + key.length + ' must equal ' +\newline                  '(shotCount
+ movesCount)=' + (shotCount + movesCount));\newline    }\newline    tracePrint ('
animated=' + animated);\newline    // set node values\newline    CameraPI.key    
= key;\newline    CameraOI.key      = key;\newline    CameraPI.keyValue = keyValuePosition;\newline
CameraOI.keyValue = keyValueOrientation;\newline\newline    if (!animated) // output
results\newline    {\newline        tracePrint ('&lt;PositionInterpolator    DEF=\\'CameraPositionInterpolator\\'
key=\\'' + stripBrackets(CameraPI.key) + '\\' keyValue=\\'' + stripBrackets(CameraPI.keyValue)
+ '\\'/&gt;');\newline        tracePrint ('&lt;OrientationInterpolator DEF=\\'CameraOrientationInterpolator\\'
key=\\'' + stripBrackets(CameraOI.key) + '\\' keyValue=\\'' + stripBrackets(CameraOI.keyValue)
+ '\\'/&gt;');\newline    }\newline    tracePrint ('checkShots() complete');\newline}\newline\newlinefunction
stripBrackets (fieldArray)\newline{\newline    // some browsers add brackets to array
output strings, this function strips them\newline    outputString = '';\newline  
for (i = 0; i &lt; fieldArray.length; i++)\newline    {\newline       outputString +=
fieldArray[i].toString();\newline       if (i &lt; fieldArray.length - 1) outputString
+= ' ';\newline    }\newline    return outputString;\newline}\newline\newlinefunction
set_fraction (eventValue, timestamp) // input event received for inputOnly field\newline{\newline
// traceEnabled = false;  // for testing purposes\newline\newline   // if Camera is
being animated, immediately recompute interpolator settings\newline   if (animated)
checkShots (true);\newline\newline   // trace progress on console with reduced output
frequency\newline   if (frameCount == 0)\newline   {\newline      alwaysPrint ('Animation
loop commencing, timestamp=' + timestamp);\newline      startTime      = timestamp;\newline
priorTraceTime = timestamp;\newline      alwaysPrint ('shotClock=' + (timestamp -
startTime) + ' seconds, frameCount=' + frameCount + ', fraction=' + eventValue + ',
position=' + ViewpointNode.position.toString() + ', orientation=' + ViewpointNode.orientation.toString());\newline\newline
if (animated) // output results\newline      {\newline        // TODO how to report
or speed up response?  alwaysPrint ('  aimPoint=' + aimPoint.toString());\newline
tracePrint ('  &lt;PositionInterpolator    DEF=\\'CameraPositionInterpolator\\'    key=\\''
+ stripBrackets(CameraPI.key) + '\\' keyValue=\\'' + stripBrackets(CameraPI.keyValue)
+ '\\'/&gt;');\newline        tracePrint ('  &lt;OrientationInterpolator DEF=\\'CameraOrientationInterpolator\\'
key=\\'' + stripBrackets(CameraOI.key) + '\\' keyValue=\\'' + stripBrackets(CameraOI.keyValue)
+ '\\'/&gt;');\newline      }\newline   }\newline   else if ((timestamp - priorTraceTime)
&gt;= 1.0) // 1 second trace interval\newline   {\newline      alwaysPrint ('shotClock='
+ (timestamp - startTime) + ' seconds, frameCount=' + frameCount + ', fraction=' +
eventValue + ', position=' + ViewpointNode.position.toString() + ', orientation='
+ ViewpointNode.orientation.toString());\newline      priorTraceTime = timestamp;\newline\newline
if (animated) // output results\newline      {\newline        // TODO how to report
or speed up response?  alwaysPrint ('  aimPoint=' + aimPoint.toString());\newline
tracePrint ('  &lt;PositionInterpolator    DEF=\\'CameraPositionInterpolator\\'    key=\\''
+ stripBrackets(CameraPI.key) + '\\' keyValue=\\'' + stripBrackets(CameraPI.keyValue)
+ '\\'/&gt;');\newline        alwaysPrint ('  &lt;OrientationInterpolator DEF=\\'CameraOrientationInterpolator\\'
key=\\'' + stripBrackets(CameraOI.key) + '\\' keyValue=\\'' + stripBrackets(CameraOI.keyValue)
+ '\\'/&gt;');\newline      }\newline   }\newline   if (eventValue == 0)\newline   {\newline
// note that zero value is not necessarily sent first by TimeSensor, so otherwise
ignored\newline      frameCount++;\newline   }\newline   else if (eventValue == 1)\newline
{\newline      alwaysPrint ('shotClock=' + (timestamp - startTime) + ', frameCount='
+ frameCount + ', fraction=' + eventValue + ', position=' + ViewpointNode.position.toString()
+ ', orientation=' + ViewpointNode.orientation.toString());\newline      if (animated)
// output results\newline      {\newline        // TODO how to report or speed up
response?  alwaysPrint ('  aimPoint=' + aimPoint.toString());\newline      }\newline
alwaysPrint ('Animation loop complete.');\newline      // do not unbind the Viewpoint
and NavigationInfo nodes, let that be controlled externally\newline   }\newline  
else\newline   {\newline      frameCount++;\newline   }\newline}\newline\newlinefunction
set_bind (eventValue) // input event received for inputOnly field\newline{\newline
// need to ensure CameraShot nodes are properly initialized\newline   if (initialized
== false)\newline   {\newline      checkShots (true);\newline      initialized = true;\newline
}\newline   if (eventValue)\newline   {\newline       tracePrint ('Camera has been
bound');\newline   }\newline   else\newline   {\newline       tracePrint ('Camera
has been unbound');\newline   }\newline}\newline\newlinefunction set_description (eventValue)
// input event received for inputOutput field\newline{\newline    description = eventValue;\newline}\newline\newlinefunction
set_position (eventValue) // input event received for inputOutput field\newline{\newline
position = eventValue;\newline}\newline\newlinefunction set_orientation (eventValue)
// input event received for inputOutput field\newline{\newline    orientation = eventValue;\newline}\newline\newlinefunction
set_fieldOfView (eventValue) // input event received for inputOutput field\newline{\newline
fieldOfView = eventValue;\newline}\newline\newlinefunction set_nearClipPlane (eventValue)
// input event received for inputOutput field\newline{\newline    nearClipPlane =
eventValue;\newline}\newline\newlinefunction set_farClipPlane (eventValue) // input
event received for inputOutput field\newline{\newline    farClipPlane = eventValue;\newline}\newline\newlinefunction
set_shots (eventValue) // input event received for inputOutput field\newline{\newline
shots = eventValue;\newline}\newline\newlinefunction set_filterColor (eventValue)
// input event received for inputOutput field\newline{\newline    filterColor = eventValue;\newline}\newline\newlinefunction
set_filterTransparency (eventValue) // input event received for inputOutput field\newline{\newline
filterTransparency = eventValue;\newline}\newline\newlinefunction set_upVector (eventValue)
// input event received for inputOutput field\newline{\newline    upVector = eventValue;\newline}\newline\newlinefunction
set_fStop (eventValue) // input event received for inputOutput field\newline{\newline
fStop = eventValue;\newline}\newline\newlinefunction set_focusDistance (eventValue)
// input event received for inputOutput field\newline{\newline    focusDistance =
eventValue;\newline}\newline\newlinefunction set_offlineRender (eventValue) // input
event received for inputOutput field\newline{\newline    offlineRender = eventValue;\newline}\newline\newlinefunction
set_key (eventValue) // input event received for inputOutput field\newline{\newline
key = eventValue;\newline}\newline\newlinefunction set_keyValuePosition (eventValue)
// input event received for inputOutput field\newline{\newline    keyValuePosition
= eventValue;\newline}\newline\newlinefunction set_keyValueOrientation (eventValue)
// input event received for inputOutput field\newline{\newline    keyValueOrientation
= eventValue;\newline}\newline\newlinefunction set_animated (eventValue) // input
event received for inputOutput field\newline{\newline    animated = eventValue;\newline}\newline\newlinefunction
tracePrint (outputValue)\newline{\newline\tif (traceEnabled) alwaysPrint (outputValue);\newline}\newlinefunction
alwaysPrint (outputValue)\newline{\newline    // try to ensure outputValue is converted
to string despite Browser.println idiosyncracies\newline    var outputString = outputValue.toString();
// utility function according to spec\newline    if (outputString == null) outputString
= outputValue; // direct cast\newline\newline    if  (description.length &gt; 0)\newline
Browser.print ('[Camera: ' + description + '] ' + outputString + '\n');\newline  
else\newline         Browser.print ('[Camera] ' + outputString + '\n');\newline}\newline",
"",
""
]
}
},
{ "ROUTE":
{
"@fromField":"position",
"@fromNode":"CameraScript",
"@toField":"position",
"@toNode":"CameraViewpoint"
}
},
{ "ROUTE":
{
"@fromField":"orientation",
"@fromNode":"CameraScript",
"@toField":"orientation",
"@toNode":"CameraViewpoint"
}
},
{ "ROUTE":
{
"@fromField":"isActive",
"@fromNode":"CameraScript",
"@toField":"set_bind",
"@toNode":"CameraViewpoint"
}
},
{ "ROUTE":
{
"@fromField":"isActive",
"@fromNode":"CameraScript",
"@toField":"set_bind",
"@toNode":"CameraNavInfo"
}
},
{ "ROUTE":
{
"@fromField":"isActive",
"@fromNode":"CameraScript",
"@toField":"on",
"@toNode":"CameraDirectionalLight"
}
}
]
}
}
},
{ "ProtoDeclare":
{
"@name":"CameraShot",
"@appinfo":"CameraShot collects a specific set of CameraMovement animations that make
up an individual shot.",
"ProtoInterface": {
"field": [
{
"@name":"description",
"@accessType":"inputOutput",
"@appinfo":"Text description to be displayed for this CameraShot",
"@type":"SFString"
},
{
"@name":"enabled",
"@accessType":"inputOutput",
"@appinfo":"Whether this CameraShot can be activated",
"@type":"SFBool",
"@value":true
},
{
"@name":"moves",
"@accessType":"inputOutput",
"@appinfo":"Set of CameraMovement nodes",
"@type":"MFNode"
},
{
"@name":"initialPosition",
"@accessType":"inputOutput",
"@appinfo":"Setup to reinitialize camera position for this shot",
"@type":"SFVec3f",
"@value":[0,0,10]
},
{
"@name":"initialOrientation",
"@accessType":"inputOutput",
"@appinfo":"Setup to reinitialize camera rotation for this shot",
"@type":"SFRotation",
"@value":[0,0,1,0]
},
{
"@name":"initialAimPoint",
"@accessType":"inputOutput",
"@appinfo":"Setup to reinitialize aimpoint (relative location for camera direction)
for this shot",
"@type":"SFVec3f",
"@value":[0,0,0]
},
{
"@name":"initialFieldOfView",
"@accessType":"inputOutput",
"@appinfo":"pi/4",
"@type":"SFFloat",
"@value":0.7854
},
{
"@name":"initialFStop",
"@accessType":"inputOutput",
"@appinfo":"Focal length divided effective aperture diameter indicating width of focal
plane",
"@type":"SFFloat",
"@value":5.6
},
{
"@name":"initialFocusDistance",
"@accessType":"inputOutput",
"@appinfo":"Distance to focal plane of sharpest focus",
"@type":"SFFloat",
"@value":10.0
},
{
"@name":"shotDuration",
"@accessType":"outputOnly",
"@appinfo":"Subtotal duration of contained CameraMovement move durations",
"@type":"SFTime"
},
{
"@name":"isActive",
"@accessType":"outputOnly",
"@appinfo":"Mark start/stop with true/false output respectively useful to trigger
external animations",
"@type":"SFBool"
},
{
"@name":"traceEnabled",
"@accessType":"initializeOnly",
"@appinfo":"enable console output to trace script computations and prototype progress",
"@type":"SFBool",
"@value":false
}
]
},
"ProtoBody": {
"-children":[
{ "Script":
{
"@DEF":"CameraShotScript",
"@directOutput":true,
"@mustEvaluate":true,
"field": [
{
"@name":"description",
"@accessType":"inputOutput",
"@appinfo":"Text description to be displayed for this CameraShot",
"@type":"SFString"
},
{
"@name":"enabled",
"@accessType":"inputOutput",
"@appinfo":"Whether this CameraShot can be activated",
"@type":"SFBool"
},
{
"@name":"moves",
"@accessType":"inputOutput",
"@appinfo":"Set of CameraMovement nodes",
"@type":"MFNode"
},
{
"@name":"initialPosition",
"@accessType":"inputOutput",
"@appinfo":"Setup to reinitialize camera position for this shot",
"@type":"SFVec3f"
},
{
"@name":"initialOrientation",
"@accessType":"inputOutput",
"@appinfo":"Setup to reinitialize camera rotation for this shot",
"@type":"SFRotation"
},
{
"@name":"initialAimPoint",
"@accessType":"inputOutput",
"@appinfo":"Setup to reinitialize aimpoint (relative location for camera direction)
for this shot",
"@type":"SFVec3f"
},
{
"@name":"initialFieldOfView",
"@accessType":"inputOutput",
"@appinfo":"pi/4",
"@type":"SFFloat"
},
{
"@name":"initialFStop",
"@accessType":"inputOutput",
"@appinfo":"Focal length divided effective aperture diameter indicating width of focal
plane",
"@type":"SFFloat"
},
{
"@name":"initialFocusDistance",
"@accessType":"inputOutput",
"@appinfo":"Distance to focal plane of sharpest focus",
"@type":"SFFloat"
},
{
"@name":"shotDuration",
"@accessType":"outputOnly",
"@appinfo":"Subtotal duration of contained CameraMovement move durations",
"@type":"SFTime"
},
{
"@name":"isActive",
"@accessType":"outputOnly",
"@appinfo":"Mark start/stop with true/false output respectively useful to trigger
external animations",
"@type":"SFBool"
},
{
"@name":"traceEnabled",
"@accessType":"initializeOnly",
"@appinfo":"enable console output to trace script computations and prototype progress",
"@type":"SFBool"
},
{
"@name":"key",
"@accessType":"inputOutput",
"@appinfo":"key array for interpolators",
"@type":"MFFloat"
},
{
"@name":"keyValuePosition",
"@accessType":"inputOutput",
"@appinfo":"keyValue array for PositionInterpolator",
"@type":"MFVec3f"
},
{
"@name":"keyValueOrientation",
"@accessType":"inputOutput",
"@appinfo":"keyValue array for OrientationInterpolator",
"@type":"MFRotation"
}
],
"IS": {
"connect": [
{
"@nodeField":"description",
"@protoField":"description"
},
{
"@nodeField":"enabled",
"@protoField":"enabled"
},
{
"@nodeField":"moves",
"@protoField":"moves"
},
{
"@nodeField":"initialPosition",
"@protoField":"initialPosition"
},
{
"@nodeField":"initialOrientation",
"@protoField":"initialOrientation"
},
{
"@nodeField":"initialAimPoint",
"@protoField":"initialAimPoint"
},
{
"@nodeField":"initialFieldOfView",
"@protoField":"initialFieldOfView"
},
{
"@nodeField":"initialFStop",
"@protoField":"initialFStop"
},
{
"@nodeField":"initialFocusDistance",
"@protoField":"initialFocusDistance"
},
{
"@nodeField":"shotDuration",
"@protoField":"shotDuration"
},
{
"@nodeField":"isActive",
"@protoField":"isActive"
},
{
"@nodeField":"traceEnabled",
"@protoField":"traceEnabled"
}
]
},
"#sourceCode":[
"",
"",
"\newlinefunction initialize () // CameraShotScript\newline{\newline//  tracePrint
('initialize start...');\newline\newline    // compute shotDuration by summing durations
from contained CameraMovement nodes\newline    shotDuration = 0;\newline    for (i
= 0; i &lt; moves.length; i++)\newline    {\newline        shotDuration = shotDuration
+ moves[i].duration;\newline    }\newline    alwaysPrint ('number of contained CameraMove
nodes=' + moves.length + ', shotDuration=' + shotDuration + ' seconds');\newline\newline//
tracePrint ('... initialize() complete');\newline}\newline\newlinefunction set_description
(eventValue) // input event received for inputOutput field\newline{\newline    description
= eventValue;\newline}\newline\newlinefunction set_enabled (eventValue) // input event
received for inputOutput field\newline{\newline    enabled = eventValue;\newline}\newline\newlinefunction
set_moves (eventValue) // input event received for inputOutput field\newline{\newline
moves = eventValue;\newline}\newline\newlinefunction set_initialPosition (eventValue)
// input event received for inputOutput field\newline{\newline    initialPosition
= eventValue;\newline}\newline\newlinefunction set_initialOrientation (eventValue)
// input event received for inputOutput field\newline{\newline    initialOrientation
= eventValue;\newline}\newline\newlinefunction set_initialAimPoint (eventValue) //
input event received for inputOutput field\newline{\newline    initialAimPoint = eventValue;\newline}\newline\newlinefunction
set_initialFieldOfView (eventValue) // input event received for inputOutput field\newline{\newline
initialFieldOfView = eventValue;\newline}\newline\newlinefunction set_initialFStop
(eventValue) // input event received for inputOutput field\newline{\newline    initialFStop
= eventValue;\newline}\newline\newlinefunction set_initialFocusDistance (eventValue)
// input event received for inputOutput field\newline{\newline    initialFocusDistance
= eventValue;\newline}\newline\newlinefunction set_key (eventValue) // input event
received for inputOutput field\newline{\newline    key = eventValue;\newline}\newline\newlinefunction
set_keyValuePosition (eventValue) // input event received for inputOutput field\newline{\newline
keyValuePosition = eventValue;\newline}\newline\newlinefunction set_keyValueOrientation
(eventValue) // input event received for inputOutput field\newline{\newline    keyValueOrientation
= eventValue;\newline}\newline\newline// TODO consider method set_active for constructed
Camera node BooleanSequencer to send isActive\newline\newlinefunction tracePrint (outputValue)\newline{\newline\tif
(traceEnabled) alwaysPrint (outputValue);\newline}\newlinefunction alwaysPrint (outputValue)\newline{\newline\t//
try to ensure outputValue is converted to string despite browser idiosyncracies\newline
var outputString = outputValue.toString(); // utility function according to spec\newline
if (outputString == null) outputString = outputValue; // direct cast\newline\newline
if  (description.length &gt; 0)\newline         Browser.print ('[CameraShot: ' + description
+ '] ' + outputString + '\n');\newline    else\newline         Browser.print ('[CameraShot]
' + outputString + '\n');\newline}\newline",
"",
""
]
}
}
]
}
}
},
{ "ProtoDeclare":
{
"@name":"CameraMovement",
"@appinfo":"CameraMovement node defines a single camera movement animation including
goalPosition, goalOrientation, goalAimPoint and goalFieldOfView.",
"ProtoInterface": {
"field": [
{
"@name":"description",
"@accessType":"inputOutput",
"@appinfo":"Text description to be displayed for this CameraMovement",
"@type":"SFString"
},
{
"@name":"enabled",
"@accessType":"inputOutput",
"@appinfo":"Whether this CameraMovement can be activated",
"@type":"SFBool",
"@value":true
},
{
"@name":"duration",
"@accessType":"inputOutput",
"@appinfo":"Duration in seconds for this move",
"@type":"SFFloat",
"@value":0.0
},
{
"@name":"goalPosition",
"@accessType":"inputOutput",
"@appinfo":"Goal camera position for this move",
"@type":"SFVec3f",
"@value":[0,0,10]
},
{
"@name":"goalOrientation",
"@accessType":"inputOutput",
"@appinfo":"Goal camera rotation for this move",
"@type":"SFRotation",
"@value":[0,0,1,0]
},
{
"@name":"tracking",
"@accessType":"inputOutput",
"@appinfo":"Whether or not camera direction is tracking towards the aimPoint",
"@type":"SFBool",
"@value":false
},
{
"@name":"goalAimPoint",
"@accessType":"inputOutput",
"@appinfo":"Goal aimPoint for this move, ignored if tracking=false",
"@type":"SFVec3f",
"@value":[0,0,0]
},
{
"@name":"goalFieldOfView",
"@accessType":"inputOutput",
"@appinfo":"Goal fieldOfView for this move",
"@type":"SFFloat",
"@value":0.7854
},
{
"@name":"goalFStop",
"@accessType":"inputOutput",
"@appinfo":"Focal length divided effective aperture diameter indicating width of focal
plane",
"@type":"SFFloat",
"@value":5.6
},
{
"@name":"goalFocusDistance",
"@accessType":"inputOutput",
"@appinfo":"Distance to focal plane of sharpest focus",
"@type":"SFFloat",
"@value":10.0
},
{
"@name":"isActive",
"@accessType":"outputOnly",
"@appinfo":"Mark start/stop with true/false output respectively useful to trigger
external animations",
"@type":"SFBool"
},
{
"@name":"traceEnabled",
"@accessType":"initializeOnly",
"@appinfo":"enable console output to trace script computations and prototype progress",
"@type":"SFBool",
"@value":false
}
]
},
"ProtoBody": {
"-children":[
{ "Script":
{
"@DEF":"CameraMovementScript",
"@directOutput":true,
"@mustEvaluate":true,
"field": [
{
"@name":"description",
"@accessType":"inputOutput",
"@appinfo":"Text description to be displayed for this CameraMovement",
"@type":"SFString"
},
{
"@name":"enabled",
"@accessType":"inputOutput",
"@appinfo":"Whether this CameraMovement can be activated",
"@type":"SFBool"
},
{
"@name":"duration",
"@accessType":"inputOutput",
"@appinfo":"Duration in seconds for this move",
"@type":"SFFloat"
},
{
"@name":"goalPosition",
"@accessType":"inputOutput",
"@appinfo":"Goal camera position for this move",
"@type":"SFVec3f"
},
{
"@name":"goalOrientation",
"@accessType":"inputOutput",
"@appinfo":"Goal camera rotation for this move",
"@type":"SFRotation"
},
{
"@name":"tracking",
"@accessType":"inputOutput",
"@appinfo":"Whether or not camera direction is tracking towards the aimPoint",
"@type":"SFBool"
},
{
"@name":"goalAimPoint",
"@accessType":"inputOutput",
"@appinfo":"Goal aimPoint for this move, ignored if tracking=false",
"@type":"SFVec3f"
},
{
"@name":"goalFieldOfView",
"@accessType":"inputOutput",
"@appinfo":"Goal fieldOfView for this move",
"@type":"SFFloat"
},
{
"@name":"goalFStop",
"@accessType":"inputOutput",
"@appinfo":"Focal length divided effective aperture diameter indicating width of focal
plane",
"@type":"SFFloat"
},
{
"@name":"goalFocusDistance",
"@accessType":"inputOutput",
"@appinfo":"Distance to focal plane of sharpest focus",
"@type":"SFFloat"
},
{
"@name":"isActive",
"@accessType":"outputOnly",
"@appinfo":"Mark start/stop with true/false output respectively useful to trigger
external animations",
"@type":"SFBool"
},
{
"@name":"traceEnabled",
"@accessType":"initializeOnly",
"@appinfo":"enable console output to trace script computations and prototype progress",
"@type":"SFBool"
}
],
"IS": {
"connect": [
{
"@nodeField":"description",
"@protoField":"description"
},
{
"@nodeField":"enabled",
"@protoField":"enabled"
},
{
"@nodeField":"duration",
"@protoField":"duration"
},
{
"@nodeField":"goalPosition",
"@protoField":"goalPosition"
},
{
"@nodeField":"goalOrientation",
"@protoField":"goalOrientation"
},
{
"@nodeField":"tracking",
"@protoField":"tracking"
},
{
"@nodeField":"goalAimPoint",
"@protoField":"goalAimPoint"
},
{
"@nodeField":"goalFieldOfView",
"@protoField":"goalFieldOfView"
},
{
"@nodeField":"goalFStop",
"@protoField":"goalFStop"
},
{
"@nodeField":"goalFocusDistance",
"@protoField":"goalFocusDistance"
},
{
"@nodeField":"isActive",
"@protoField":"isActive"
},
{
"@nodeField":"traceEnabled",
"@protoField":"traceEnabled"
}
]
},
"#sourceCode":[
"",
"",
"\newlinefunction initialize () // CameraMovementScript\newline{\newline//  tracePrint
('initialize start...');\newline    alwaysPrint ('initialize goalPosition=' + goalPosition.toString()
+ ', goalOrientation=' + goalOrientation.toString() +\newline                    
', goalAimPoint=' + goalAimPoint.toString() // + ', tracking=' + tracking.toString()\newline
);\newline    if (duration &lt; 0)\newline    {\newline       alwaysPrint ('error: negative
duration=' + duration + ', reset to 0 and ignored');\newline       duration = 0;\newline
}\newline    else if (duration == 0)\newline    {\newline       alwaysPrint ('warning:
duration=0, nothing to do!');\newline    }\newline    tracePrint ('... initialize
complete');\newline}\newline\newlinefunction set_goalAimPoint (eventValue) // input
event received for inputOutput field\newline{\newline    goalAimPoint_changed = eventValue;\newline
tracePrint ('goalAimPoint=' + goalAimPoint.toString());\newline\newline    // updated
goalOrientation tracking is handled by Camera recomputing the OrientationInterpolator\newline}\newline\newlinefunction
set_description (eventValue) // input event received for inputOutput field\newline{\newline
description = eventValue;\newline}\newline\newlinefunction set_enabled (eventValue)
// input event received for inputOutput field\newline{\newline    enabled = eventValue;\newline}\newline\newlinefunction
set_duration (eventValue) // input event received for inputOutput field\newline{\newline
duration = eventValue;\newline}\newline\newlinefunction set_goalPosition (eventValue)
// input event received for inputOutput field\newline{\newline    goalPosition = eventValue;\newline}\newline\newlinefunction
set_goalOrientation (eventValue) // input event received for inputOutput field\newline{\newline
goalOrientation = eventValue;\newline}\newline\newlinefunction set_tracking (eventValue)
// input event received for inputOutput field\newline{\newline    tracking = eventValue;\newline}\newline\newlinefunction
set_goalFieldOfView (eventValue) // input event received for inputOutput field\newline{\newline
goalFieldOfView = eventValue;\newline}\newline\newlinefunction set_goalFStop (eventValue)
// input event received for inputOutput field\newline{\newline    goalFStop = eventValue;\newline}\newline\newlinefunction
set_goalFocusDistance (eventValue) // input event received for inputOutput field\newline{\newline
goalFocusDistance = eventValue;\newline}\newline\newline// TODO consider method set_active
for constructed Camera node BooleanSequencer to send isActive\newline\newlinefunction
tracePrint (outputValue)\newline{\newline\tif (traceEnabled) alwaysPrint (outputValue);\newline}\newline\newlinefunction
alwaysPrint (outputValue)\newline{\newline\t// try to ensure outputValue is converted
to string despite browser idiosyncracies\newline    var outputString = outputValue.toString();
// utility function according to spec\newline    if (outputString == null) outputString
= outputValue; // direct cast\newline\newline    if  (description.length &gt; 0)\newline
Browser.print ('[CameraMovement: ' + description + '] ' + outputString + '\n');\newline
else\newline         Browser.print ('[CameraMovement] ' + outputString + '\n');\newline}\newline",
"",
""
]
}
}
]
}
}
},
{ "ProtoDeclare":
{
"@name":"OfflineRender",
"@appinfo":"OfflineRender defines a parameters for offline rendering of Camera animation
output to a movie file (or possibly a still shot).",
"ProtoInterface": {
"field": [
{
"@name":"description",
"@accessType":"inputOutput",
"@appinfo":"Text description to be displayed for this OfflineRender",
"@type":"SFString"
},
{
"@name":"enabled",
"@accessType":"inputOutput",
"@appinfo":"Whether this OfflineRender can be activated",
"@type":"SFBool",
"@value":true
},
{
"@name":"frameRate",
"@accessType":"inputOutput",
"@appinfo":"Frames per second recorded for this rendering",
"@type":"SFFloat",
"@value":30.0
},
{
"@name":"frameSize",
"@accessType":"inputOutput",
"@appinfo":"Size of frame in number of pixels width and height",
"@type":"SFVec2f",
"@value":[640,480]
},
{
"@name":"pixelAspectRatio",
"@accessType":"inputOutput",
"@appinfo":"Relative dimensions of pixel height/width typically 1.33 or 1",
"@type":"SFFloat",
"@value":1.33
},
{
"@name":"set_startTime",
"@accessType":"inputOnly",
"@appinfo":"Begin render operation",
"@type":"SFTime"
},
{
"@name":"progress",
"@accessType":"outputOnly",
"@appinfo":"Progress performing render operation (0..1)",
"@type":"SFFloat"
},
{
"@name":"renderCompleteTime",
"@accessType":"outputOnly",
"@appinfo":"Render operation complete",
"@type":"SFTime"
},
{
"@name":"movieFormat",
"@accessType":"initializeOnly",
"@appinfo":"Format of rendered output movie (mpeg mp4 etc.), use first supported format",
"@type":"MFString",
"@value":["mpeg"]
},
{
"@name":"imageFormat",
"@accessType":"initializeOnly",
"@appinfo":"Format of rendered output images (png jpeg gif tiff etc.) use first supported
format",
"@type":"MFString",
"@value":["png"]
},
{
"@name":"traceEnabled",
"@accessType":"initializeOnly",
"@appinfo":"enable console output to trace script computations and prototype progress",
"@type":"SFBool",
"@value":false
}
]
},
"ProtoBody": {
"-children":[
{ "Script":
{
"@DEF":"OfflineRenderScript",
"@mustEvaluate":true,
"field": [
{
"@name":"description",
"@accessType":"inputOutput",
"@appinfo":"Text description to be displayed for this OfflineRender",
"@type":"SFString"
},
{
"@name":"enabled",
"@accessType":"inputOutput",
"@appinfo":"Whether this OfflineRender can be activated",
"@type":"SFBool"
},
{
"@name":"frameRate",
"@accessType":"inputOutput",
"@appinfo":"Frames per second recorded for this rendering",
"@type":"SFFloat"
},
{
"@name":"frameSize",
"@accessType":"inputOutput",
"@appinfo":"Size of frame in number of pixels width and height",
"@type":"SFVec2f"
},
{
"@name":"pixelAspectRatio",
"@accessType":"inputOutput",
"@appinfo":"Relative dimensions of pixel height/width typically 1.33 or 1",
"@type":"SFFloat"
},
{
"@name":"set_startTime",
"@accessType":"inputOnly",
"@appinfo":"Begin render operation",
"@type":"SFTime"
},
{
"@name":"progress",
"@accessType":"outputOnly",
"@appinfo":"Progress performing render operation (0..1)",
"@type":"SFFloat"
},
{
"@name":"renderCompleteTime",
"@accessType":"outputOnly",
"@appinfo":"Render operation complete",
"@type":"SFTime"
},
{
"@name":"movieFormat",
"@accessType":"initializeOnly",
"@appinfo":"Format of rendered output movie (mpeg mp4 etc.)",
"@type":"MFString"
},
{
"@name":"imageFormat",
"@accessType":"initializeOnly",
"@appinfo":"Format of rendered output images (png jpeg gif tiff etc.)",
"@type":"MFString"
},
{
"@name":"traceEnabled",
"@accessType":"initializeOnly",
"@appinfo":"enable console output to trace script computations and prototype progress",
"@type":"SFBool"
}
],
"IS": {
"connect": [
{
"@nodeField":"description",
"@protoField":"description"
},
{
"@nodeField":"enabled",
"@protoField":"enabled"
},
{
"@nodeField":"frameRate",
"@protoField":"frameRate"
},
{
"@nodeField":"frameSize",
"@protoField":"frameSize"
},
{
"@nodeField":"pixelAspectRatio",
"@protoField":"pixelAspectRatio"
},
{
"@nodeField":"set_startTime",
"@protoField":"set_startTime"
},
{
"@nodeField":"progress",
"@protoField":"progress"
},
{
"@nodeField":"renderCompleteTime",
"@protoField":"renderCompleteTime"
},
{
"@nodeField":"movieFormat",
"@protoField":"movieFormat"
},
{
"@nodeField":"imageFormat",
"@protoField":"imageFormat"
},
{
"@nodeField":"traceEnabled",
"@protoField":"traceEnabled"
}
]
},
"#sourceCode":[
"",
"",
"\newlinefunction initialize () // OfflineRenderScript\newline{\newline//  tracePrint
('initialize start...');\newline\newline    tracePrint ('... initialize complete');\newline}\newline\newlinefunction
set_description (eventValue) // input event received for inputOutput field\newline{\newline
description = eventValue;\newline}\newline\newlinefunction set_enabled (eventValue)
// input event received for inputOutput field\newline{\newline    enabled = eventValue;\newline}\newline\newlinefunction
set_frameRate (eventValue) // input event received for inputOutput field\newline{\newline
frameRate = eventValue;\newline}\newline\newlinefunction set_frameSize (eventValue)
// input event received for inputOutput field\newline{\newline    frameSize = eventValue;\newline}\newline\newlinefunction
set_pixelAspectRatio (eventValue) // input event received for inputOutput field\newline{\newline
pixelAspectRatio = eventValue;\newline}\newline\newlinefunction set_startTime (eventValue)
// input event received for inputOnly field\newline{\newline   // do something with
input eventValue;\newline}\newline\newlinefunction tracePrint (outputValue)\newline{\newline\tif
(traceEnabled) alwaysPrint (outputValue);\newline}\newline\newlinefunction alwaysPrint
(outputValue)\newline{\newline\t// try to ensure outputValue is converted to string
despite browser idiosyncracies\newline    var outputString = outputValue.toString();
// utility function according to spec\newline    if (outputString == null) outputString
= outputValue; // direct cast\newline\newline    if  (description.length &gt; 0)\newline
Browser.print ('[OfflineRender: ' + description + '] ' + outputString + '\n');\newline
else\newline         Browser.print ('[OfflineRender] ' + outputString + '\n');\newline}\newline",
"",
""
]
}
}
]
}
}
},
{ "Background":
{
"@skyColor":[0.282353,0.380392,0.470588]
}
},
{ "Anchor":
{
"@description":"launch CameraExample scene",
"@url":["CameraExamples.x3d","https://www.web3d.org/x3d/content/examples/Basic/development/CameraExamples.x3d","CameraExamples.wrl","https://www.web3d.org/x3d/content/examples/Basic/development/CameraExamples.wrl"],
"-children":[
{ "Transform":
{
"-children":[
{ "Shape":
{
"-appearance":
{ "Appearance":
{
"-material":
{ "Material":
{
"@diffuseColor":[1,1,0.2]
}
}
}
},
"-geometry":
{ "Text":
{
"@string":["CameraPrototypes.x3d","defines multiple prototype nodes","","Click on
this text to see","CameraExamples.x3d scene"],
"-fontStyle":
{ "FontStyle":
{
"@justify":["MIDDLE","MIDDLE"]
}
}
}
}
}
}
]
}
}
]
}
}
]
}
  }
}