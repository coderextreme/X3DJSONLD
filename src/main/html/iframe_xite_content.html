<!DOCTYPE html>
<html>
<head>
    <title>X_ITE Content</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="https://create3000.github.io/code/x_ite/latest/dist/x_ite.css"/>
    <script type="text/javascript" src="https://create3000.github.io/code/x_ite/latest/x_ite.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
        x3d-canvas { width: 100%; height: 100%; border: none; }
    </style>
</head>
<body>
    <x3d-canvas id="xite_canvas_in_iframe" cache="false">
        <X3D profile="Immersive" version="4.0">
            <Scene>
                <!-- Content will be loaded here by parent -->
            </Scene>
        </X3D>
    </x3d-canvas>

    <script>
        let x3dCanvasElement = null;
        let xiteBrowserInstance = null; // To store the obtained browser instance

        // Helper to get the canvas DOM element
        function getX3dCanvasDOMElement() {
            if (!x3dCanvasElement) {
                x3dCanvasElement = document.getElementById('xite_canvas_in_iframe');
            }
            return x3dCanvasElement;
        }

        // Function to get the X_ITE Browser instance asynchronously
        async function getXiteBrowser() {
            if (xiteBrowserInstance) {
                return xiteBrowserInstance;
            }
            try {
                const canvasElement = getX3dCanvasDOMElement();
                if (!canvasElement) {
                    console.error("X_ITE Canvas DOM element not found to get browser.");
                    return null;
                }

                // Standard X3D SAI pattern: await X3D() if X3D is a promise (often the case for library readiness)
                // then X3D.getBrowser(selector).
                // For X_ITE, after the x_ite.js script runs, X3D should be globally available.
                // The runtime on the element is usually the entry point.
                if (typeof X3D !== 'undefined' && typeof X3D.getBrowser === 'function') {
                     // If X3D() itself is a promise that needs to resolve for the environment
                    if (typeof X3D === 'function' && X3D.constructor.name === 'AsyncFunction' || (typeof X3D === 'function' && X3D() instanceof Promise) ) {
                        await X3D(); // Wait for the X3D environment to be ready
                    }
                    xiteBrowserInstance = X3D.getBrowser(canvasElement); // Pass the DOM element
                } else if (canvasElement.runtime && canvasElement.runtime.browser) {
                    // Fallback or direct X_ITE way if X3D.getBrowser isn't the primary method for an already init'd canvas
                    xiteBrowserInstance = canvasElement.runtime.browser;
                }

                if (!xiteBrowserInstance) {
                    console.warn("Could not obtain X_ITE browser instance.");
                } else {
                    console.log("X_ITE Browser instance obtained.");
                }
                return xiteBrowserInstance;
            } catch (e) {
                console.error("Error getting X_ITE browser instance:", e);
                return null;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = getX3dCanvasDOMElement();
            if (canvas) {
                canvas.addEventListener('load', async function() { // Make this async
                    console.log("X_ITE canvas in iframe is fully loaded (load event).");
                    await getXiteBrowser(); // Ensure browser instance is ready after X_ITE load
                    // If parent tried to convert XML to JSON before this, it might be queued.
                    // The parent's onload handler for the iframe should manage this.
                });
            }
            // Eagerly try to get browser instance too, in case 'load' is slow or already fired
            getXiteBrowser();
        });

        async function loadContentInXite(xmlString) { // Make async to ensure browser is available
            const canvas = getX3dCanvasDOMElement();
            if (!canvas) return;

            const browser = await getXiteBrowser(); // Ensure we have the browser
            if (!browser) {
                console.error("X_ITE Browser not available for loadContentInXite. Load aborted.");
                return;
            }

            const scene = canvas.querySelector('Scene'); // Or browser.currentScene if more appropriate

            if (scene) {
                // Clear previous content more safely if using browser API
                // browser.replaceWorld(browser.createX3DFromString(newSceneXml)); is another option
                while (scene.firstChild) {
                    scene.removeChild(scene.firstChild);
                }

                if (xmlString) {
                    try {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                        const newSceneRootNode = xmlDoc.documentElement;

                        if (newSceneRootNode && newSceneRootNode.nodeName === 'X3D') {
                            const newSceneContent = newSceneRootNode.querySelector('Scene');
                            if (newSceneContent && newSceneContent.childNodes) {
                                Array.from(newSceneContent.childNodes).forEach(child => {
                                   scene.appendChild(document.importNode(child, true));
                                });
                            }
                            // For X_ITE, after modifying the DOM scene directly,
                            // you might need to tell the runtime to re-evaluate.
                            if (canvas.runtime && typeof canvas.runtime.reload === 'function') {
                                canvas.runtime.reload();
                            } else {
                                // If direct DOM manipulation isn't picked up, this is an alternative:
                                // browser.replaceWorld(browser.createX3DFromString(xmlString));
                                console.warn("X_ITE runtime.reload not available, hoping for reactive update or consider browser.replaceWorld.");
                            }
                        } else {
                             console.warn("Provided XML for X_ITE does not have an X3D root element or Scene properly.");
                        }
                    } catch (e) {
                        console.error("Error parsing or loading XML into X_ITE:", e, xmlString.substring(0,200));
                         if(scene) scene.appendChild(document.createTextNode("Error loading content."));
                    }
                }
            } else {
                console.error("X_ITE scene element not found for loadContentInXite.");
            }
        }

        async function getSceneAsJsonString() { // Make async
            const browser = await getXiteBrowser(); // Crucial: Wait for browser instance
            if (browser && typeof browser.toJSONString === 'function') {
                try {
                    const jsonString = browser.toJSONString();
                    console.log("X_ITE successfully converted current scene to JSON string via browser API.");
                    return jsonString;
                } catch (e) {
                    console.error("Error getting JSON string from X_ITE browser.toJSONString():", e);
                    return null;
                }
            } else {
                let reason = "X_ITE ";
                if (!browser) reason += "browser instance not obtained. ";
                else if (typeof browser.toJSONString !== 'function') reason += "browser.toJSONString method not found. ";
                console.warn(reason + "Cannot get JSON string.");
                return null;
            }
        }
    </script>
</body>
</html>
