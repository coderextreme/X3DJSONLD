package x3d

import ("encoding/xml";"fmt")

// Code generated by CreateX3DGSAIL.xslt. DO NOT EDIT.
// Source: X3dUnifiedObjectModel-4.0.xml

// Component: Functional summary: each added component statement indicates needed scene functionality support above the given X3D profile.
type Component struct {
    CoreX3DStatement
    Level *int32 `xml:"level,attr,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
}

func (n *Component) GetStatementName() string { return "component" }
func (n *Component) Validate() error {
    if n.Name != nil {
        switch *n.Name {
        case ComponentNameChoicesCore, ComponentNameChoicesCADGeometry, ComponentNameChoicesCubeMapTexturing, ComponentNameChoicesDIS, ComponentNameChoicesEnvironmentalEffects, ComponentNameChoicesEnvironmentalSensor, ComponentNameChoicesEventUtilities, ComponentNameChoicesFollowers, ComponentNameChoicesGeometry2D, ComponentNameChoicesGeometry3D, ComponentNameChoicesGeospatial, ComponentNameChoicesGrouping, ComponentNameChoicesHAnim, ComponentNameChoicesInterpolation, ComponentNameChoicesKeyDeviceSensor, ComponentNameChoicesLayering, ComponentNameChoicesLayout, ComponentNameChoicesLighting, ComponentNameChoicesNavigation, ComponentNameChoicesNetworking, ComponentNameChoicesNURBS, ComponentNameChoicesParticleSystems, ComponentNameChoicesPicking, ComponentNameChoicesPointingDeviceSensor, ComponentNameChoicesTextureProjection, ComponentNameChoicesRendering, ComponentNameChoicesRigidBodyPhysics, ComponentNameChoicesScripting, ComponentNameChoicesShaders, ComponentNameChoicesShape, ComponentNameChoicesSound, ComponentNameChoicesText, ComponentNameChoicesTexturing, ComponentNameChoicesTexturing3D, ComponentNameChoicesTime, ComponentNameChoicesVolumeRendering: // valid
        default: return fmt.Errorf("invalid value for field name: %s", *n.Name)
        }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *Component) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Level != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "level"}, Value: fmt.Sprintf("%v", *n.Level)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    return e.EncodeToken(start.End())
}

// Connect: Functional summary: connect statements define event-routing connections between node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
type Connect struct {
    CoreX3DStatement
    NodeField *string `xml:"nodeField,attr,omitempty""`
    ProtoField *string `xml:"protoField,attr,omitempty""`
}

func (n *Connect) GetStatementName() string { return "connect" }
func (n *Connect) Validate() error {
    return n.CoreX3DStatement.Validate()
}

func (n *Connect) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.NodeField != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "nodeField"}, Value: fmt.Sprintf("%v", *n.NodeField)}) }
    if n.ProtoField != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "protoField"}, Value: fmt.Sprintf("%v", *n.ProtoField)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    return e.EncodeToken(start.End())
}

// EXPORT: Functional summary: EXPORT exposes a local node for ROUTE passing of event values when the current Scene is included via Inline by a parent external world. These connections allow event values to be exchanged via ROUTE statements between a parent model and a child Inline model.
type EXPORT struct {
    CoreX3DStatement
    AS *string `xml:"AS,attr,omitempty""`
    LocalDEF *string `xml:"localDEF,attr,omitempty""`
}

func (n *EXPORT) GetStatementName() string { return "EXPORT" }
func (n *EXPORT) Validate() error {
    return n.CoreX3DStatement.Validate()
}

func (n *EXPORT) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.AS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "AS"}, Value: fmt.Sprintf("%v", *n.AS)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.LocalDEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "localDEF"}, Value: fmt.Sprintf("%v", *n.LocalDEF)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    return e.EncodeToken(start.End())
}

// ExternProtoDeclare: ExternProtoDeclare refers to a ProtoDeclare node declaration provided in another file. ExternProtoDeclare interfaces are defined by field statements (and without IS/connect statements).
type ExternProtoDeclare struct {
    CoreX3DStatement
    Appinfo *string `xml:"appinfo,attr,omitempty""`
    Documentation *string `xml:"documentation,attr,omitempty""`
    Field []X3DNode `xml:",any""`
    Name *string `xml:"name,attr,omitempty""`
    Url MFString `xml:"url,attr,omitempty""`
}

func (n *ExternProtoDeclare) GetStatementName() string { return "ExternProtoDeclare" }
func (n *ExternProtoDeclare) Validate() error {
    if n.Field != nil {
        for i, child := range n.Field { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Field[%d]: %w", i, err) } }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *ExternProtoDeclare) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Appinfo != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "appinfo"}, Value: fmt.Sprintf("%v", *n.Appinfo)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.Documentation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "documentation"}, Value: fmt.Sprintf("%v", *n.Documentation)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Field != nil {
        for _, child := range n.Field { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// Field: Functional summary: a field statement defines an interface attribute or node. Each field statement can contain either attribute-value or node content.
type Field struct {
    CoreX3DStatement
    AccessType *string `xml:"accessType,attr,omitempty""`
    Appinfo *string `xml:"appinfo,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Documentation *string `xml:"documentation,attr,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Type *string `xml:"type,attr,omitempty""`
    Value *string `xml:"value,attr,omitempty""`
}

func (n *Field) GetStatementName() string { return "field" }
func (n *Field) Validate() error {
    if n.AccessType != nil {
        switch *n.AccessType {
        case AccessTypeChoicesInitializeOnly, AccessTypeChoicesInputOnly, AccessTypeChoicesOutputOnly, AccessTypeChoicesInputOutput: // valid
        default: return fmt.Errorf("invalid value for field accessType: %s", *n.AccessType)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.Type != nil {
        switch *n.Type {
        case FieldTypeChoicesSFBool, FieldTypeChoicesMFBool, FieldTypeChoicesSFColor, FieldTypeChoicesMFColor, FieldTypeChoicesSFColorRGBA, FieldTypeChoicesMFColorRGBA, FieldTypeChoicesSFDouble, FieldTypeChoicesMFDouble, FieldTypeChoicesSFFloat, FieldTypeChoicesMFFloat, FieldTypeChoicesSFImage, FieldTypeChoicesMFImage, FieldTypeChoicesSFInt32, FieldTypeChoicesMFInt32, FieldTypeChoicesSFNode, FieldTypeChoicesMFNode, FieldTypeChoicesSFRotation, FieldTypeChoicesMFRotation, FieldTypeChoicesSFString, FieldTypeChoicesMFString, FieldTypeChoicesSFTime, FieldTypeChoicesMFTime, FieldTypeChoicesSFVec2d, FieldTypeChoicesMFVec2d, FieldTypeChoicesSFVec2f, FieldTypeChoicesMFVec2f, FieldTypeChoicesSFVec3d, FieldTypeChoicesMFVec3d, FieldTypeChoicesSFVec3f, FieldTypeChoicesMFVec3f, FieldTypeChoicesSFVec4d, FieldTypeChoicesMFVec4d, FieldTypeChoicesSFVec4f, FieldTypeChoicesMFVec4f, FieldTypeChoicesSFMatrix3d, FieldTypeChoicesMFMatrix3d, FieldTypeChoicesSFMatrix3f, FieldTypeChoicesMFMatrix3f, FieldTypeChoicesSFMatrix4d, FieldTypeChoicesMFMatrix4d, FieldTypeChoicesSFMatrix4f, FieldTypeChoicesMFMatrix4f: // valid
        default: return fmt.Errorf("invalid value for field type: %s", *n.Type)
        }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *Field) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.AccessType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "accessType"}, Value: fmt.Sprintf("%v", *n.AccessType)}) }
    if n.Appinfo != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "appinfo"}, Value: fmt.Sprintf("%v", *n.Appinfo)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.Documentation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "documentation"}, Value: fmt.Sprintf("%v", *n.Documentation)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.Type != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "type"}, Value: fmt.Sprintf("%v", *n.Type)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", *n.Value)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// FieldValue: Functional summary: a fieldValue statement re-initializes the default value of a field in a ProtoInstance. Each fieldValue statement can contain either attribute-value or node content.
type FieldValue struct {
    CoreX3DStatement
    Children []X3DNode `xml:",any""`
    Name *string `xml:"name,attr,omitempty""`
    Value *string `xml:"value,attr,omitempty""`
}

func (n *FieldValue) GetStatementName() string { return "fieldValue" }
func (n *FieldValue) Validate() error {
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *FieldValue) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", *n.Value)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// IMPORT: Functional summary: IMPORT provides ROUTE access to a node that has a corresponding EXPORT statement within an Inline scene. These connections allow event values to be exchanged via ROUTE statements between a parent model and a child Inline model.
type IMPORT struct {
    CoreX3DStatement
    AS *string `xml:"AS,attr,omitempty""`
    ImportedDEF *string `xml:"importedDEF,attr,omitempty""`
    InlineDEF *string `xml:"inlineDEF,attr,omitempty""`
}

func (n *IMPORT) GetStatementName() string { return "IMPORT" }
func (n *IMPORT) Validate() error {
    return n.CoreX3DStatement.Validate()
}

func (n *IMPORT) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.AS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "AS"}, Value: fmt.Sprintf("%v", *n.AS)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.ImportedDEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "importedDEF"}, Value: fmt.Sprintf("%v", *n.ImportedDEF)}) }
    if n.InlineDEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "inlineDEF"}, Value: fmt.Sprintf("%v", *n.InlineDEF)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    return e.EncodeToken(start.End())
}

// IS: Functional summary: the IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields. IS/connect statements can be added if the parent node is within a ProtoBody and connect statements define correspondences between prototype fields and built-in node fields.
type IS struct {
    CoreX3DStatement
    Connect []X3DNode `xml:",any""`
}

func (n *IS) GetStatementName() string { return "IS" }
func (n *IS) Validate() error {
    if n.Connect != nil {
        for i, child := range n.Connect { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Connect[%d]: %w", i, err) } }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *IS) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Connect != nil {
        for _, child := range n.Connect { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// Meta: Functional summary: the meta statement provides metadata information about a scene, where name and content attributes provide attribute=value metadata pairs.
type Meta struct {
    CoreX3DStatement
    Content *string `xml:"content,attr,omitempty""`
    Dir *string `xml:"dir,attr,omitempty""`
    HttpEquiv *string `xml:"http-equiv,attr,omitempty""`
    Lang *string `xml:"lang,attr,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Scheme *string `xml:"scheme,attr,omitempty""`
}

func (n *Meta) GetStatementName() string { return "meta" }
func (n *Meta) Validate() error {
    if n.Dir != nil {
        switch *n.Dir {
        case MetaDirectionChoicesRtl, MetaDirectionChoicesLtr: // valid
        default: return fmt.Errorf("invalid value for field dir: %s", *n.Dir)
        }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *Meta) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.Content != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "content"}, Value: fmt.Sprintf("%v", *n.Content)}) }
    if n.Dir != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "dir"}, Value: fmt.Sprintf("%v", *n.Dir)}) }
    if n.HttpEquiv != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "http-equiv"}, Value: fmt.Sprintf("%v", *n.HttpEquiv)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Lang != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "lang"}, Value: fmt.Sprintf("%v", *n.Lang)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Scheme != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scheme"}, Value: fmt.Sprintf("%v", *n.Scheme)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    return e.EncodeToken(start.End())
}

// ProtoBody: ProtoBody contains the definition nodes for new Prototype nodes.
type ProtoBody struct {
    CoreX3DStatement
    Children []X3DNode `xml:",any""`
}

func (n *ProtoBody) GetStatementName() string { return "ProtoBody" }
func (n *ProtoBody) Validate() error {
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *ProtoBody) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// ProtoDeclare: ProtoDeclare defines new Prototype nodes. Nested ProtoDeclares and ProtoInstances are allowed by the specification.
type ProtoDeclare struct {
    CoreX3DStatement
    Appinfo *string `xml:"appinfo,attr,omitempty""`
    Documentation *string `xml:"documentation,attr,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    ProtoBody X3DNode `xml:"ProtoBody,omitempty""`
    ProtoInterface X3DNode `xml:"ProtoInterface,omitempty""`
}

func (n *ProtoDeclare) GetStatementName() string { return "ProtoDeclare" }
func (n *ProtoDeclare) Validate() error {
    if n.ProtoBody != nil {
        if err := n.ProtoBody.Validate(); err != nil { return fmt.Errorf("validation error in ProtoBody: %w", err) }
    }
    if n.ProtoInterface != nil {
        if err := n.ProtoInterface.Validate(); err != nil { return fmt.Errorf("validation error in ProtoInterface: %w", err) }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *ProtoDeclare) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Appinfo != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "appinfo"}, Value: fmt.Sprintf("%v", *n.Appinfo)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.Documentation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "documentation"}, Value: fmt.Sprintf("%v", *n.Documentation)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.ProtoBody != nil {
        if err := e.EncodeElement(n.ProtoBody, xml.StartElement{Name: xml.Name{Local: n.ProtoBody.GetNodeName()}}); err != nil { return err }
    }
    if n.ProtoInterface != nil {
        if err := e.EncodeElement(n.ProtoInterface, xml.StartElement{Name: xml.Name{Local: n.ProtoInterface.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ProtoInterface: ProtoInterface defines fields for new Prototype nodes.
type ProtoInterface struct {
    CoreX3DStatement
    Field []X3DNode `xml:",any""`
}

func (n *ProtoInterface) GetStatementName() string { return "ProtoInterface" }
func (n *ProtoInterface) Validate() error {
    if n.Field != nil {
        for i, child := range n.Field { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Field[%d]: %w", i, err) } }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *ProtoInterface) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Field != nil {
        for _, child := range n.Field { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// ROUTE: ROUTE connects output fields of event-producing nodes to input fields of event-consuming nodes.
type ROUTE struct {
    CoreX3DStatement
    FromField *string `xml:"fromField,attr,omitempty""`
    FromNode *string `xml:"fromNode,attr,omitempty""`
    ToField *string `xml:"toField,attr,omitempty""`
    ToNode *string `xml:"toNode,attr,omitempty""`
}

func (n *ROUTE) GetStatementName() string { return "ROUTE" }
func (n *ROUTE) Validate() error {
    return n.CoreX3DStatement.Validate()
}

func (n *ROUTE) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.FromField != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fromField"}, Value: fmt.Sprintf("%v", *n.FromField)}) }
    if n.FromNode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fromNode"}, Value: fmt.Sprintf("%v", *n.FromNode)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.ToField != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "toField"}, Value: fmt.Sprintf("%v", *n.ToField)}) }
    if n.ToNode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "toNode"}, Value: fmt.Sprintf("%v", *n.ToNode)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    return e.EncodeToken(start.End())
}

// Unit: Functional summary: unit statement defines data-conversion factors for typed values defined in a scene.
type Unit struct {
    CoreX3DStatement
    Category *string `xml:"category,attr,omitempty""`
    ConversionFactor *float64 `xml:"conversionFactor,attr,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
}

func (n *Unit) GetStatementName() string { return "unit" }
func (n *Unit) Validate() error {
    if n.Category != nil {
        switch *n.Category {
        case UnitCategoryChoicesAngle, UnitCategoryChoicesForce, UnitCategoryChoicesLength, UnitCategoryChoicesMass: // valid
        default: return fmt.Errorf("invalid value for field category: %s", *n.Category)
        }
    }
    return n.CoreX3DStatement.Validate()
}

func (n *Unit) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetStatementName()
    if n.Category != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "category"}, Value: fmt.Sprintf("%v", *n.Category)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ConversionFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "conversionFactor"}, Value: fmt.Sprintf("%v", *n.ConversionFactor)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    return e.EncodeToken(start.End())
}

// Added by AI Assistant
// Add these functions to the end of your gox3d/x3d/statements.go file

func (n *Connect) GetNodeName() string { return n.GetStatementName() }
func (n *Connect) GetSpecificationURL() string { return "" }
func (n *Connect) GetCore() *CoreX3DNode { return nil }

func (n *EXPORT) GetNodeName() string { return n.GetStatementName() }
func (n *EXPORT) GetSpecificationURL() string { return "" }
func (n *EXPORT) GetCore() *CoreX3DNode { return nil }

func (n *ExternProtoDeclare) GetNodeName() string { return n.GetStatementName() }
func (n *ExternProtoDeclare) GetSpecificationURL() string { return "" }
func (n *ExternProtoDeclare) GetCore() *CoreX3DNode { return nil }

func (n *Field) GetNodeName() string { return n.GetStatementName() }
func (n *Field) GetSpecificationURL() string { return "" }
func (n *Field) GetCore() *CoreX3DNode { return nil }

func (n *FieldValue) GetNodeName() string { return n.GetStatementName() }
func (n *FieldValue) GetSpecificationURL() string { return "" }
func (n *FieldValue) GetCore() *CoreX3DNode { return nil }

func (n *IMPORT) GetNodeName() string { return n.GetStatementName() }
func (n *IMPORT) GetSpecificationURL() string { return "" }
func (n *IMPORT) GetCore() *CoreX3DNode { return nil }

func (n *IS) GetNodeName() string { return n.GetStatementName() }
func (n *IS) GetSpecificationURL() string { return "" }
func (n *IS) GetCore() *CoreX3DNode { return nil }

func (n *ProtoBody) GetNodeName() string { return n.GetStatementName() }
func (n *ProtoBody) GetSpecificationURL() string { return "" }
func (n *ProtoBody) GetCore() *CoreX3DNode { return nil }

func (n *ProtoDeclare) GetNodeName() string { return n.GetStatementName() }
func (n *ProtoDeclare) GetSpecificationURL() string { return "" }
func (n *ProtoDeclare) GetCore() *CoreX3DNode { return nil }

func (n *ProtoInterface) GetNodeName() string { return n.GetStatementName() }
func (n *ProtoInterface) GetSpecificationURL() string { return "" }
func (n *ProtoInterface) GetCore() *CoreX3DNode { return nil }

func (n *ROUTE) GetNodeName() string { return n.GetStatementName() }
func (n *ROUTE) GetSpecificationURL() string { return "" }
func (n *ROUTE) GetCore() *CoreX3DNode { return nil }
