package x3d

import ("encoding/xml";"errors";"fmt")

// Code generated by CreateX3DGSAIL.xslt. DO NOT EDIT.
// Source: X3dUnifiedObjectModel-4.0.xml


type X3DNode interface { GetNodeName() string; GetSpecificationURL() string; Validate() error; MarshalXML(e *xml.Encoder, start xml.StartElement) error; GetCore() *CoreX3DNode }
type X3DStatement interface { GetStatementName() string; Validate() error; MarshalXML(e *xml.Encoder, start xml.StartElement) error }
type X3DChildNode interface { X3DNode }
type X3DGeometryNode interface { X3DNode }
type X3DAppearanceChildNode interface { X3DNode }
 
type CoreX3DNode struct { DEF *string `xml:"DEF,attr,omitempty"`; USE *string `xml:"USE,attr,omitempty"`; Class *string `xml:"class,attr,omitempty"`; ID *string `xml:"id,attr,omitempty"`; Style *string `xml:"style,attr,omitempty"`; Metadata X3DNode `xml:"Metadata,omitempty"` }
func (n *CoreX3DNode) GetCore() *CoreX3DNode { return n }
func (n *CoreX3DNode) Validate() error { if n.DEF != nil && n.USE != nil { return errors.New("DEF and USE attributes are mutually exclusive") }; if n.Metadata != nil { if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("metadata validation error: %w", err) } }; return nil }
type CoreX3DStatement struct { Class *string `xml:"class,attr,omitempty"`; ID *string `xml:"id,attr,omitempty"`; Style *string `xml:"style,attr,omitempty"` }
func (s *CoreX3DStatement) Validate() error { return nil }
type X3D struct { XMLName xml.Name `xml:"X3D"`; Profile *string `xml:"profile,attr"`; Version *string `xml:"version,attr"`; Head *Head `xml:"head,omitempty"`; Scene *Scene `xml:"Scene"` }
type Head struct { XMLName xml.Name `xml:"head"`; Components []*Component `xml:"component,omitempty"`; Units []*Unit `xml:"unit,omitempty"`; Metas []*Meta `xml:"meta,omitempty"` }
type Scene struct { CoreX3DNode; Children []X3DChildNode `xml:",any"` }
func (n *Scene) GetNodeName() string { return "Scene" }
func (n *Scene) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#Scene" }
func (n *Scene) Validate() error { for _, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("child node validation error in Scene: %w", err) } }; return n.CoreX3DNode.Validate() }
func (n *Scene) MarshalXML(e *xml.Encoder, start xml.StartElement) error { start.Name.Local = n.GetNodeName(); if err := e.EncodeToken(start); err != nil { return err }; for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }; return e.EncodeToken(start.End()) }
 
func validateNonNegative(value float32, fieldName string) error { if value < 0 { return fmt.Errorf("%s must be non-negative, got %f", fieldName, value) }; return nil }
func validateZeroToOne(value float32, fieldName string) error { if value < 0.0 || value > 1.0 { return fmt.Errorf("%s must be in range [0, 1], got %f", fieldName, value) }; return nil }
func validatePositive(value float32, fieldName string) error { if value <= 0 { return fmt.Errorf("%s must be positive, got %f", fieldName, value) }; return nil }
func validateBoundingBox(value [3]float32, fieldName string) error { if value[0] == -1 && value[1] == -1 && value[2] == -1 { return nil }; if value[0] < 0 || value[1] < 0 || value[2] < 0 { return fmt.Errorf("%s components must all be non-negative or all be -1, got %v", fieldName, value) }; return nil }
 
