package x3d

import ("encoding/xml";"fmt")

// Code generated by CreateX3DGSAIL.xslt. DO NOT EDIT.
// Source: X3dUnifiedObjectModel-4.0.xml

// AcousticProperties: AcousticProperties specifies the interaction of sound waves with characteristics of geometric objects in the scene.
type AcousticProperties struct {
    CoreX3DNode
    Absorption *float32 `xml:"absorption,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Diffuse *float32 `xml:"diffuse,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Refraction *float32 `xml:"refraction,attr,omitempty""`
    Specular *float32 `xml:"specular,attr,omitempty""`
}

func (n *AcousticProperties) GetNodeName() string { return "AcousticProperties" }
func (n *AcousticProperties) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#AcousticProperties" }
func (n *AcousticProperties) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *AcousticProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Absorption != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "absorption"}, Value: fmt.Sprintf("%v", *n.Absorption)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Diffuse != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuse"}, Value: fmt.Sprintf("%v", *n.Diffuse)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Refraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "refraction"}, Value: fmt.Sprintf("%v", *n.Refraction)}) }
    if n.Specular != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specular"}, Value: fmt.Sprintf("%v", *n.Specular)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Analyser: Analyser provides real-time frequency and time-domain analysis information, without any signal-processing change to the audio stream which is passed unprocessed from input to output.
type Analyser struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    FftSize *int32 `xml:"fftSize,attr,omitempty""`
    FrequencyBinCount *int32 `xml:"frequencyBinCount,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    MaxDecibels *float32 `xml:"maxDecibels,attr,omitempty""`
    MinDecibels *float32 `xml:"minDecibels,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    SmoothingTimeConstant *float32 `xml:"smoothingTimeConstant,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    TailTime *float64 `xml:"tailTime,attr,omitempty""`
}

func (n *Analyser) GetNodeName() string { return "Analyser" }
func (n *Analyser) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Analyser" }
func (n *Analyser) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Analyser) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.FftSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fftSize"}, Value: fmt.Sprintf("%v", *n.FftSize)}) }
    if n.FrequencyBinCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frequencyBinCount"}, Value: fmt.Sprintf("%v", *n.FrequencyBinCount)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.MaxDecibels != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxDecibels"}, Value: fmt.Sprintf("%v", *n.MaxDecibels)}) }
    if n.MinDecibels != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minDecibels"}, Value: fmt.Sprintf("%v", *n.MinDecibels)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.SmoothingTimeConstant != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "smoothingTimeConstant"}, Value: fmt.Sprintf("%v", *n.SmoothingTimeConstant)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.TailTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tailTime"}, Value: fmt.Sprintf("%v", *n.TailTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Anchor: Anchor is a Grouping node that can contain most nodes.
type Anchor struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    Parameter []string `xml:"parameter,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Url []string `xml:"url,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *Anchor) GetNodeName() string { return "Anchor" }
func (n *Anchor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/networking.html#Anchor" }
func (n *Anchor) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Anchor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Parameter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "parameter"}, Value: fmt.Sprintf("%v", n.Parameter)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// Appearance: Appearance specifies the visual properties of geometry by containing the Material, ImageTexture/MovieTexture/PixelTexture, FillProperties, LineProperties, programmable shader nodes (ComposedShader, PackagedShader, ProgramShader) and TextureTransform nodes.
type Appearance struct {
    CoreX3DNode
    AcousticProperties X3DNode `xml:"acousticProperties,omitempty""`
    AlphaCutoff *float32 `xml:"alphaCutoff,attr,omitempty""`
    AlphaMode *string `xml:"alphaMode,attr,omitempty""`
    BackMaterial X3DNode `xml:"backMaterial,omitempty""`
    FillProperties X3DNode `xml:"fillProperties,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    LineProperties X3DNode `xml:"lineProperties,omitempty""`
    Material X3DNode `xml:"material,omitempty""`
    PointProperties X3DNode `xml:"pointProperties,omitempty""`
    Shaders []X3DNode `xml:",any""`
    Texture X3DNode `xml:"texture,omitempty""`
    TextureTransform X3DNode `xml:"textureTransform,omitempty""`
    BlendMode X3DNode `xml:"blendMode,omitempty""`
    DepthMode X3DNode `xml:"depthMode,omitempty""`
}

func (n *Appearance) GetNodeName() string { return "Appearance" }
func (n *Appearance) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#Appearance" }
func (n *Appearance) Validate() error {
    if n.AcousticProperties != nil {
        if err := n.AcousticProperties.Validate(); err != nil { return fmt.Errorf("validation error in AcousticProperties: %w", err) }
    }
    if n.AlphaMode != nil {
        switch *n.AlphaMode {
        case AlphaModeChoicesAUTO, AlphaModeChoicesOPAQUE, AlphaModeChoicesMASK, AlphaModeChoicesBLEND: // valid
        default: return fmt.Errorf("invalid value for field alphaMode: %s", *n.AlphaMode)
        }
    }
    if n.BackMaterial != nil {
        if err := n.BackMaterial.Validate(); err != nil { return fmt.Errorf("validation error in BackMaterial: %w", err) }
    }
    if n.FillProperties != nil {
        if err := n.FillProperties.Validate(); err != nil { return fmt.Errorf("validation error in FillProperties: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.LineProperties != nil {
        if err := n.LineProperties.Validate(); err != nil { return fmt.Errorf("validation error in LineProperties: %w", err) }
    }
    if n.Material != nil {
        if err := n.Material.Validate(); err != nil { return fmt.Errorf("validation error in Material: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.PointProperties != nil {
        if err := n.PointProperties.Validate(); err != nil { return fmt.Errorf("validation error in PointProperties: %w", err) }
    }
    if n.Shaders != nil {
        for i, child := range n.Shaders { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Shaders[%d]: %w", i, err) } }
    }
    if n.Texture != nil {
        if err := n.Texture.Validate(); err != nil { return fmt.Errorf("validation error in Texture: %w", err) }
    }
    if n.TextureTransform != nil {
        if err := n.TextureTransform.Validate(); err != nil { return fmt.Errorf("validation error in TextureTransform: %w", err) }
    }
    if n.BlendMode != nil {
        if err := n.BlendMode.Validate(); err != nil { return fmt.Errorf("validation error in BlendMode: %w", err) }
    }
    if n.DepthMode != nil {
        if err := n.DepthMode.Validate(); err != nil { return fmt.Errorf("validation error in DepthMode: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Appearance) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AlphaCutoff != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "alphaCutoff"}, Value: fmt.Sprintf("%v", *n.AlphaCutoff)}) }
    if n.AlphaMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "alphaMode"}, Value: fmt.Sprintf("%v", *n.AlphaMode)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AcousticProperties != nil {
        if err := e.EncodeElement(n.AcousticProperties, xml.StartElement{Name: xml.Name{Local: n.AcousticProperties.GetNodeName()}}); err != nil { return err }
    }
    if n.BackMaterial != nil {
        if err := e.EncodeElement(n.BackMaterial, xml.StartElement{Name: xml.Name{Local: n.BackMaterial.GetNodeName()}}); err != nil { return err }
    }
    if n.FillProperties != nil {
        if err := e.EncodeElement(n.FillProperties, xml.StartElement{Name: xml.Name{Local: n.FillProperties.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.LineProperties != nil {
        if err := e.EncodeElement(n.LineProperties, xml.StartElement{Name: xml.Name{Local: n.LineProperties.GetNodeName()}}); err != nil { return err }
    }
    if n.Material != nil {
        if err := e.EncodeElement(n.Material, xml.StartElement{Name: xml.Name{Local: n.Material.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.PointProperties != nil {
        if err := e.EncodeElement(n.PointProperties, xml.StartElement{Name: xml.Name{Local: n.PointProperties.GetNodeName()}}); err != nil { return err }
    }
    if n.Shaders != nil {
        for _, child := range n.Shaders { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Texture != nil {
        if err := e.EncodeElement(n.Texture, xml.StartElement{Name: xml.Name{Local: n.Texture.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureTransform != nil {
        if err := e.EncodeElement(n.TextureTransform, xml.StartElement{Name: xml.Name{Local: n.TextureTransform.GetNodeName()}}); err != nil { return err }
    }
    if n.BlendMode != nil {
        if err := e.EncodeElement(n.BlendMode, xml.StartElement{Name: xml.Name{Local: n.BlendMode.GetNodeName()}}); err != nil { return err }
    }
    if n.DepthMode != nil {
        if err := e.EncodeElement(n.DepthMode, xml.StartElement{Name: xml.Name{Local: n.DepthMode.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Arc2D: Arc2D is a line-based geometry node that defines a linear circular arc with center (0,0) in X-Y plane, with angles measured starting at positive x-axis and sweeping towards positive y-axis.
type Arc2D struct {
    CoreX3DNode
    EndAngle *float32 `xml:"endAngle,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Radius *float32 `xml:"radius,attr,omitempty""`
    StartAngle *float32 `xml:"startAngle,attr,omitempty""`
}

func (n *Arc2D) GetNodeName() string { return "Arc2D" }
func (n *Arc2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Arc2D" }
func (n *Arc2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Arc2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.EndAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "endAngle"}, Value: fmt.Sprintf("%v", *n.EndAngle)}) }
    if n.Radius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radius"}, Value: fmt.Sprintf("%v", *n.Radius)}) }
    if n.StartAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startAngle"}, Value: fmt.Sprintf("%v", *n.StartAngle)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ArcClose2D: ArcClose2D is a polygonal geometry node that defines a linear circular arc, closed by PIE or CHORD line segments, with center (0,0) in X-Y plane, with angles measured starting at positive x-axis and sweeping towards positive y-axis.
type ArcClose2D struct {
    CoreX3DNode
    ClosureType *string `xml:"closureType,attr,omitempty""`
    EndAngle *float32 `xml:"endAngle,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Radius *float32 `xml:"radius,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    StartAngle *float32 `xml:"startAngle,attr,omitempty""`
}

func (n *ArcClose2D) GetNodeName() string { return "ArcClose2D" }
func (n *ArcClose2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#ArcClose2D" }
func (n *ArcClose2D) Validate() error {
    if n.ClosureType != nil {
        switch *n.ClosureType {
        case ClosureTypeChoicesPIE, ClosureTypeChoicesCHORD: // valid
        default: return fmt.Errorf("invalid value for field closureType: %s", *n.ClosureType)
        }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ArcClose2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ClosureType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "closureType"}, Value: fmt.Sprintf("%v", *n.ClosureType)}) }
    if n.EndAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "endAngle"}, Value: fmt.Sprintf("%v", *n.EndAngle)}) }
    if n.Radius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radius"}, Value: fmt.Sprintf("%v", *n.Radius)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.StartAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startAngle"}, Value: fmt.Sprintf("%v", *n.StartAngle)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// AudioClip: AudioClip provides audio data used by parent Sound nodes.
type AudioClip struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    DurationChanged *float64 `xml:"duration_changed,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    Loop *bool `xml:"loop,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    Pitch *float32 `xml:"pitch,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *AudioClip) GetNodeName() string { return "AudioClip" }
func (n *AudioClip) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#AudioClip" }
func (n *AudioClip) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *AudioClip) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.DurationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "duration_changed"}, Value: fmt.Sprintf("%v", *n.DurationChanged)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Loop != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loop"}, Value: fmt.Sprintf("%v", *n.Loop)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.Pitch != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pitch"}, Value: fmt.Sprintf("%v", *n.Pitch)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// AudioDestination: AudioDestination node represents the final audio destination and is what user ultimately hears, typically from the speakers of user device.
type AudioDestination struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    MaxChannelCount *int32 `xml:"maxChannelCount,attr,omitempty""`
    MediaDeviceID *string `xml:"mediaDeviceID,attr,omitempty""`
}

func (n *AudioDestination) GetNodeName() string { return "AudioDestination" }
func (n *AudioDestination) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#AudioDestination" }
func (n *AudioDestination) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *AudioDestination) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.MaxChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxChannelCount"}, Value: fmt.Sprintf("%v", *n.MaxChannelCount)}) }
    if n.MediaDeviceID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mediaDeviceID"}, Value: fmt.Sprintf("%v", *n.MediaDeviceID)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Background: Background simulates ground and sky, using vertical arrays of wraparound color values.
type Background struct {
    CoreX3DNode
    BackUrl []string `xml:"backUrl,attr,omitempty""`
    BindTime *float64 `xml:"bindTime,attr,omitempty""`
    BottomUrl []string `xml:"bottomUrl,attr,omitempty""`
    FrontUrl []string `xml:"frontUrl,attr,omitempty""`
    GroundAngle []float32 `xml:"groundAngle,attr,omitempty""`
    GroundColor *MFColor `xml:"groundColor,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsBound *bool `xml:"isBound,attr,omitempty""`
    LeftUrl []string `xml:"leftUrl,attr,omitempty""`
    RightUrl []string `xml:"rightUrl,attr,omitempty""`
    SetBind *bool `xml:"set_bind,attr,omitempty""`
    SkyAngle []float32 `xml:"skyAngle,attr,omitempty""`
    SkyColor *MFColor `xml:"skyColor,attr,omitempty""`
    TopUrl []string `xml:"topUrl,attr,omitempty""`
    Transparency *float32 `xml:"transparency,attr,omitempty""`
}

func (n *Background) GetNodeName() string { return "Background" }
func (n *Background) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#Background" }
func (n *Background) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Background) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BackUrl != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "backUrl"}, Value: fmt.Sprintf("%v", n.BackUrl)}) }
    if n.BindTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bindTime"}, Value: fmt.Sprintf("%v", *n.BindTime)}) }
    if n.BottomUrl != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bottomUrl"}, Value: fmt.Sprintf("%v", n.BottomUrl)}) }
    if n.FrontUrl != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frontUrl"}, Value: fmt.Sprintf("%v", n.FrontUrl)}) }
    if n.GroundAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "groundAngle"}, Value: fmt.Sprintf("%v", n.GroundAngle)}) }
    if n.GroundColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "groundColor"}, Value: fmt.Sprintf("%v", *n.GroundColor)}) }
    if n.IsBound != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isBound"}, Value: fmt.Sprintf("%v", *n.IsBound)}) }
    if n.LeftUrl != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "leftUrl"}, Value: fmt.Sprintf("%v", n.LeftUrl)}) }
    if n.RightUrl != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rightUrl"}, Value: fmt.Sprintf("%v", n.RightUrl)}) }
    if n.SetBind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_bind"}, Value: fmt.Sprintf("%v", *n.SetBind)}) }
    if n.SkyAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "skyAngle"}, Value: fmt.Sprintf("%v", n.SkyAngle)}) }
    if n.SkyColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "skyColor"}, Value: fmt.Sprintf("%v", *n.SkyColor)}) }
    if n.TopUrl != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "topUrl"}, Value: fmt.Sprintf("%v", n.TopUrl)}) }
    if n.Transparency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transparency"}, Value: fmt.Sprintf("%v", *n.Transparency)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BallJoint: BallJoint represents an unconstrained joint between two bodies that pivot about a common anchor point.
type BallJoint struct {
    CoreX3DNode
    AnchorPoint *SFVec3f `xml:"anchorPoint,attr,omitempty""`
    Body1 X3DNode `xml:"body1,omitempty""`
    Body1AnchorPoint *SFVec3f `xml:"body1AnchorPoint,attr,omitempty""`
    Body2 X3DNode `xml:"body2,omitempty""`
    Body2AnchorPoint *SFVec3f `xml:"body2AnchorPoint,attr,omitempty""`
    ForceOutput []string `xml:"forceOutput,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
}

func (n *BallJoint) GetNodeName() string { return "BallJoint" }
func (n *BallJoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#BallJoint" }
func (n *BallJoint) Validate() error {
    if n.Body1 != nil {
        if err := n.Body1.Validate(); err != nil { return fmt.Errorf("validation error in Body1: %w", err) }
    }
    if n.Body2 != nil {
        if err := n.Body2.Validate(); err != nil { return fmt.Errorf("validation error in Body2: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BallJoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "anchorPoint"}, Value: fmt.Sprintf("%v", *n.AnchorPoint)}) }
    if n.Body1AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body1AnchorPoint"}, Value: fmt.Sprintf("%v", *n.Body1AnchorPoint)}) }
    if n.Body2AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body2AnchorPoint"}, Value: fmt.Sprintf("%v", *n.Body2AnchorPoint)}) }
    if n.ForceOutput != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "forceOutput"}, Value: fmt.Sprintf("%v", n.ForceOutput)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Body1 != nil {
        if err := e.EncodeElement(n.Body1, xml.StartElement{Name: xml.Name{Local: n.Body1.GetNodeName()}}); err != nil { return err }
    }
    if n.Body2 != nil {
        if err := e.EncodeElement(n.Body2, xml.StartElement{Name: xml.Name{Local: n.Body2.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Billboard: Billboard is a Grouping node that can contain most nodes.
type Billboard struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    AxisOfRotation *SFVec3f `xml:"axisOfRotation,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *Billboard) GetNodeName() string { return "Billboard" }
func (n *Billboard) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#Billboard" }
func (n *Billboard) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Billboard) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AxisOfRotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axisOfRotation"}, Value: fmt.Sprintf("%v", *n.AxisOfRotation)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// BiquadFilter: BiquadFilter node is an AudioNode processor implementing common low-order filters.
type BiquadFilter struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Detune *float32 `xml:"detune,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Frequency *float32 `xml:"frequency,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    QualityFactor *float32 `xml:"qualityFactor,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    TailTime *float64 `xml:"tailTime,attr,omitempty""`
    Type *string `xml:"type,attr,omitempty""`
}

func (n *BiquadFilter) GetNodeName() string { return "BiquadFilter" }
func (n *BiquadFilter) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#BiquadFilter" }
func (n *BiquadFilter) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Type != nil {
        switch *n.Type {
        case BiquadTypeFilterChoicesLOWPASS, BiquadTypeFilterChoicesHIGHPASS, BiquadTypeFilterChoicesBANDPASS, BiquadTypeFilterChoicesLOWSHELF, BiquadTypeFilterChoicesHIGHSHELF, BiquadTypeFilterChoicesPEAKING, BiquadTypeFilterChoicesNOTCH, BiquadTypeFilterChoicesALLPASS: // valid
        default: return fmt.Errorf("invalid value for field type: %s", *n.Type)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BiquadFilter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Detune != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "detune"}, Value: fmt.Sprintf("%v", *n.Detune)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Frequency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frequency"}, Value: fmt.Sprintf("%v", *n.Frequency)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.QualityFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "qualityFactor"}, Value: fmt.Sprintf("%v", *n.QualityFactor)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.TailTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tailTime"}, Value: fmt.Sprintf("%v", *n.TailTime)}) }
    if n.Type != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "type"}, Value: fmt.Sprintf("%v", *n.Type)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BlendedVolumeStyle: BlendedVolumeStyle combines rendering of two voxel data sets into one by blending voxel values.
type BlendedVolumeStyle struct {
    CoreX3DNode
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RenderStyle X3DNode `xml:"renderStyle,omitempty""`
    Voxels X3DNode `xml:"voxels,omitempty""`
    WeightConstant1 *float32 `xml:"weightConstant1,attr,omitempty""`
    WeightConstant2 *float32 `xml:"weightConstant2,attr,omitempty""`
    WeightFunction1 *string `xml:"weightFunction1,attr,omitempty""`
    WeightFunction2 *string `xml:"weightFunction2,attr,omitempty""`
    WeightTransferFunction1 X3DNode `xml:"weightTransferFunction1,omitempty""`
    WeightTransferFunction2 X3DNode `xml:"weightTransferFunction2,omitempty""`
}

func (n *BlendedVolumeStyle) GetNodeName() string { return "BlendedVolumeStyle" }
func (n *BlendedVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#BlendedVolumeStyle" }
func (n *BlendedVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RenderStyle != nil {
        if err := n.RenderStyle.Validate(); err != nil { return fmt.Errorf("validation error in RenderStyle: %w", err) }
    }
    if n.Voxels != nil {
        if err := n.Voxels.Validate(); err != nil { return fmt.Errorf("validation error in Voxels: %w", err) }
    }
    if n.WeightFunction1 != nil {
        switch *n.WeightFunction1 {
        case VolumeRenderingWeightFunctionChoicesCONSTANT, VolumeRenderingWeightFunctionChoicesALPHA1, VolumeRenderingWeightFunctionChoicesALPHA2, VolumeRenderingWeightFunctionChoicesONEMINUSALPHA1, VolumeRenderingWeightFunctionChoicesONEMINUSALPHA2, VolumeRenderingWeightFunctionChoicesTABLE: // valid
        default: return fmt.Errorf("invalid value for field weightFunction1: %s", *n.WeightFunction1)
        }
    }
    if n.WeightFunction2 != nil {
        switch *n.WeightFunction2 {
        case VolumeRenderingWeightFunctionChoicesCONSTANT, VolumeRenderingWeightFunctionChoicesALPHA1, VolumeRenderingWeightFunctionChoicesALPHA2, VolumeRenderingWeightFunctionChoicesONEMINUSALPHA1, VolumeRenderingWeightFunctionChoicesONEMINUSALPHA2, VolumeRenderingWeightFunctionChoicesTABLE: // valid
        default: return fmt.Errorf("invalid value for field weightFunction2: %s", *n.WeightFunction2)
        }
    }
    if n.WeightTransferFunction1 != nil {
        if err := n.WeightTransferFunction1.Validate(); err != nil { return fmt.Errorf("validation error in WeightTransferFunction1: %w", err) }
    }
    if n.WeightTransferFunction2 != nil {
        if err := n.WeightTransferFunction2.Validate(); err != nil { return fmt.Errorf("validation error in WeightTransferFunction2: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BlendedVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.WeightConstant1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weightConstant1"}, Value: fmt.Sprintf("%v", *n.WeightConstant1)}) }
    if n.WeightConstant2 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weightConstant2"}, Value: fmt.Sprintf("%v", *n.WeightConstant2)}) }
    if n.WeightFunction1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weightFunction1"}, Value: fmt.Sprintf("%v", *n.WeightFunction1)}) }
    if n.WeightFunction2 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weightFunction2"}, Value: fmt.Sprintf("%v", *n.WeightFunction2)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RenderStyle != nil {
        if err := e.EncodeElement(n.RenderStyle, xml.StartElement{Name: xml.Name{Local: n.RenderStyle.GetNodeName()}}); err != nil { return err }
    }
    if n.Voxels != nil {
        if err := e.EncodeElement(n.Voxels, xml.StartElement{Name: xml.Name{Local: n.Voxels.GetNodeName()}}); err != nil { return err }
    }
    if n.WeightTransferFunction1 != nil {
        if err := e.EncodeElement(n.WeightTransferFunction1, xml.StartElement{Name: xml.Name{Local: n.WeightTransferFunction1.GetNodeName()}}); err != nil { return err }
    }
    if n.WeightTransferFunction2 != nil {
        if err := e.EncodeElement(n.WeightTransferFunction2, xml.StartElement{Name: xml.Name{Local: n.WeightTransferFunction2.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BooleanFilter: BooleanFilter selectively passes true, false or negated events.
type BooleanFilter struct {
    CoreX3DNode
    InputFalse *bool `xml:"inputFalse,attr,omitempty""`
    InputNegate *bool `xml:"inputNegate,attr,omitempty""`
    InputTrue *bool `xml:"inputTrue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    SetBoolean *bool `xml:"set_boolean,attr,omitempty""`
}

func (n *BooleanFilter) GetNodeName() string { return "BooleanFilter" }
func (n *BooleanFilter) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#BooleanFilter" }
func (n *BooleanFilter) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BooleanFilter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.InputFalse != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "inputFalse"}, Value: fmt.Sprintf("%v", *n.InputFalse)}) }
    if n.InputNegate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "inputNegate"}, Value: fmt.Sprintf("%v", *n.InputNegate)}) }
    if n.InputTrue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "inputTrue"}, Value: fmt.Sprintf("%v", *n.InputTrue)}) }
    if n.SetBoolean != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_boolean"}, Value: fmt.Sprintf("%v", *n.SetBoolean)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BooleanSequencer: BooleanSequencer generates periodic discrete Boolean values.
type BooleanSequencer struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue []bool `xml:"keyValue,attr,omitempty""`
    Next *bool `xml:"next,attr,omitempty""`
    Previous *bool `xml:"previous,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *bool `xml:"value_changed,attr,omitempty""`
}

func (n *BooleanSequencer) GetNodeName() string { return "BooleanSequencer" }
func (n *BooleanSequencer) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#BooleanSequencer" }
func (n *BooleanSequencer) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BooleanSequencer) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", n.KeyValue)}) }
    if n.Next != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "next"}, Value: fmt.Sprintf("%v", *n.Next)}) }
    if n.Previous != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "previous"}, Value: fmt.Sprintf("%v", *n.Previous)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BooleanToggle: BooleanToggle maintains state and negates output when a true input is provided.
type BooleanToggle struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    SetBoolean *bool `xml:"set_boolean,attr,omitempty""`
    Toggle *bool `xml:"toggle,attr,omitempty""`
}

func (n *BooleanToggle) GetNodeName() string { return "BooleanToggle" }
func (n *BooleanToggle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#BooleanToggle" }
func (n *BooleanToggle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BooleanToggle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.SetBoolean != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_boolean"}, Value: fmt.Sprintf("%v", *n.SetBoolean)}) }
    if n.Toggle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "toggle"}, Value: fmt.Sprintf("%v", *n.Toggle)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BooleanTrigger: BooleanTrigger converts time events to boolean true events.
type BooleanTrigger struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    SetTriggerTime *float64 `xml:"set_triggerTime,attr,omitempty""`
    TriggerTrue *bool `xml:"triggerTrue,attr,omitempty""`
}

func (n *BooleanTrigger) GetNodeName() string { return "BooleanTrigger" }
func (n *BooleanTrigger) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#BooleanTrigger" }
func (n *BooleanTrigger) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BooleanTrigger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.SetTriggerTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_triggerTime"}, Value: fmt.Sprintf("%v", *n.SetTriggerTime)}) }
    if n.TriggerTrue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "triggerTrue"}, Value: fmt.Sprintf("%v", *n.TriggerTrue)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BoundaryEnhancementVolumeStyle: BoundaryEnhancementVolumeStyle provides boundary enhancement for the volume rendering style.
type BoundaryEnhancementVolumeStyle struct {
    CoreX3DNode
    BoundaryOpacity *float32 `xml:"boundaryOpacity,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    OpacityFactor *float32 `xml:"opacityFactor,attr,omitempty""`
    RetainedOpacity *float32 `xml:"retainedOpacity,attr,omitempty""`
}

func (n *BoundaryEnhancementVolumeStyle) GetNodeName() string { return "BoundaryEnhancementVolumeStyle" }
func (n *BoundaryEnhancementVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#BoundaryEnhancementVolumeStyle" }
func (n *BoundaryEnhancementVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BoundaryEnhancementVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BoundaryOpacity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "boundaryOpacity"}, Value: fmt.Sprintf("%v", *n.BoundaryOpacity)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.OpacityFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "opacityFactor"}, Value: fmt.Sprintf("%v", *n.OpacityFactor)}) }
    if n.RetainedOpacity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "retainedOpacity"}, Value: fmt.Sprintf("%v", *n.RetainedOpacity)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BoundedPhysicsModel: BoundedPhysicsModel provides user-defined geometrical boundaries for particle motion.
type BoundedPhysicsModel struct {
    CoreX3DNode
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Geometry X3DNode `xml:"geometry,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Damping *float32 `xml:"damping,attr,omitempty""`
}

func (n *BoundedPhysicsModel) GetNodeName() string { return "BoundedPhysicsModel" }
func (n *BoundedPhysicsModel) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#BoundedPhysicsModel" }
func (n *BoundedPhysicsModel) Validate() error {
    if n.Geometry != nil {
        if err := n.Geometry.Validate(); err != nil { return fmt.Errorf("validation error in Geometry: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BoundedPhysicsModel) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.Damping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "damping"}, Value: fmt.Sprintf("%v", *n.Damping)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Geometry != nil {
        if err := e.EncodeElement(n.Geometry, xml.StartElement{Name: xml.Name{Local: n.Geometry.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Box: Box is a geometry node specifying a rectangular cuboid.
type Box struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Size *SFVec3f `xml:"size,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
}

func (n *Box) GetNodeName() string { return "Box" }
func (n *Box) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Box" }
func (n *Box) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Box) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", *n.Size)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BufferAudioSource: BufferAudioSource node represents a memory-resident audio asset that can contain one or more channels.
type BufferAudioSource struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Buffer []float32 `xml:"buffer,attr,omitempty""`
    BufferDuration *float64 `xml:"bufferDuration,attr,omitempty""`
    Bufferlength *int32 `xml:"bufferlength,attr,omitempty""`
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Detune *float32 `xml:"detune,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    Length *int32 `xml:"length,attr,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    Loop *bool `xml:"loop,attr,omitempty""`
    LoopEnd *float32 `xml:"loopEnd,attr,omitempty""`
    LoopStart *float32 `xml:"loopStart,attr,omitempty""`
    NumberOfChannels *int32 `xml:"numberOfChannels,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    PlaybackRate *float32 `xml:"playbackRate,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    SampleRate *float32 `xml:"sampleRate,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *BufferAudioSource) GetNodeName() string { return "BufferAudioSource" }
func (n *BufferAudioSource) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#BufferAudioSource" }
func (n *BufferAudioSource) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BufferAudioSource) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Buffer != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "buffer"}, Value: fmt.Sprintf("%v", n.Buffer)}) }
    if n.BufferDuration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bufferDuration"}, Value: fmt.Sprintf("%v", *n.BufferDuration)}) }
    if n.Bufferlength != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bufferlength"}, Value: fmt.Sprintf("%v", *n.Bufferlength)}) }
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Detune != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "detune"}, Value: fmt.Sprintf("%v", *n.Detune)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.Length != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "length"}, Value: fmt.Sprintf("%v", *n.Length)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Loop != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loop"}, Value: fmt.Sprintf("%v", *n.Loop)}) }
    if n.LoopEnd != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loopEnd"}, Value: fmt.Sprintf("%v", *n.LoopEnd)}) }
    if n.LoopStart != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loopStart"}, Value: fmt.Sprintf("%v", *n.LoopStart)}) }
    if n.NumberOfChannels != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "numberOfChannels"}, Value: fmt.Sprintf("%v", *n.NumberOfChannels)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.PlaybackRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "playbackRate"}, Value: fmt.Sprintf("%v", *n.PlaybackRate)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.SampleRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sampleRate"}, Value: fmt.Sprintf("%v", *n.SampleRate)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CADAssembly: CADAssembly holds a set of Computer-Aided Design (CAD) assemblies or parts grouped together.
type CADAssembly struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *CADAssembly) GetNodeName() string { return "CADAssembly" }
func (n *CADAssembly) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#CADAssembly" }
func (n *CADAssembly) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CADAssembly) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// CADFace: CADFace holds geometry representing one face in a Computer-Aided Design (CAD) CADPart.
type CADFace struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Shape X3DNode `xml:"shape,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *CADFace) GetNodeName() string { return "CADFace" }
func (n *CADFace) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#CADFace" }
func (n *CADFace) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Shape != nil {
        if err := n.Shape.Validate(); err != nil { return fmt.Errorf("validation error in Shape: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CADFace) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Shape != nil {
        if err := e.EncodeElement(n.Shape, xml.StartElement{Name: xml.Name{Local: n.Shape.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CADLayer: CADLayer nodes define a hierarchy that shows layer structure for a Computer-Aided Design (CAD) model.
type CADLayer struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *CADLayer) GetNodeName() string { return "CADLayer" }
func (n *CADLayer) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#CADLayer" }
func (n *CADLayer) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CADLayer) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// CADPart: CADPart is an atomic part that defines both coordinate-system location and the faces that constitute a part in a Computer-Aided Design (CAD) model.
type CADPart struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    Scale *SFVec3f `xml:"scale,attr,omitempty""`
    ScaleOrientation *SFRotation `xml:"scaleOrientation,attr,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *CADPart) GetNodeName() string { return "CADPart" }
func (n *CADPart) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#CADPart" }
func (n *CADPart) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CADPart) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.ScaleOrientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scaleOrientation"}, Value: fmt.Sprintf("%v", *n.ScaleOrientation)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// CartoonVolumeStyle: CartoonVolumeStyle generates cartoon-style non-photorealistic rendering of associated volumetric data.
type CartoonVolumeStyle struct {
    CoreX3DNode
    ColorSteps *int32 `xml:"colorSteps,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    OrthogonalColor *SFColorRGBA `xml:"orthogonalColor,attr,omitempty""`
    ParallelColor *SFColorRGBA `xml:"parallelColor,attr,omitempty""`
    SurfaceNormals X3DNode `xml:"surfaceNormals,omitempty""`
}

func (n *CartoonVolumeStyle) GetNodeName() string { return "CartoonVolumeStyle" }
func (n *CartoonVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#CartoonVolumeStyle" }
func (n *CartoonVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.SurfaceNormals != nil {
        if err := n.SurfaceNormals.Validate(); err != nil { return fmt.Errorf("validation error in SurfaceNormals: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CartoonVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ColorSteps != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorSteps"}, Value: fmt.Sprintf("%v", *n.ColorSteps)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.OrthogonalColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orthogonalColor"}, Value: fmt.Sprintf("%v", *n.OrthogonalColor)}) }
    if n.ParallelColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "parallelColor"}, Value: fmt.Sprintf("%v", *n.ParallelColor)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.SurfaceNormals != nil {
        if err := e.EncodeElement(n.SurfaceNormals, xml.StartElement{Name: xml.Name{Local: n.SurfaceNormals.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ChannelMerger: ChannelMerger unites different input channels into a single output channel.
type ChannelMerger struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
}

func (n *ChannelMerger) GetNodeName() string { return "ChannelMerger" }
func (n *ChannelMerger) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#ChannelMerger" }
func (n *ChannelMerger) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ChannelMerger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ChannelSelector: ChannelSelector selects a single channel output from all input channels.
type ChannelSelector struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    ChannelSelection *int32 `xml:"channelSelection,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
}

func (n *ChannelSelector) GetNodeName() string { return "ChannelSelector" }
func (n *ChannelSelector) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#ChannelSelector" }
func (n *ChannelSelector) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ChannelSelector) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.ChannelSelection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelSelection"}, Value: fmt.Sprintf("%v", *n.ChannelSelection)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ChannelSplitter: ChannelSplitter separates the different channels of a single audio source into a set of monophonic output channels.
type ChannelSplitter struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Outputs []X3DNode `xml:",any""`
}

func (n *ChannelSplitter) GetNodeName() string { return "ChannelSplitter" }
func (n *ChannelSplitter) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#ChannelSplitter" }
func (n *ChannelSplitter) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Outputs != nil {
        for i, child := range n.Outputs { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Outputs[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ChannelSplitter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Outputs != nil {
        for _, child := range n.Outputs { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// Circle2D: Circle2D is a geometry node that defines a linear X-Y circle with center (0,0) in X-Y plane.
type Circle2D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Radius *float32 `xml:"radius,attr,omitempty""`
}

func (n *Circle2D) GetNodeName() string { return "Circle2D" }
func (n *Circle2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Circle2D" }
func (n *Circle2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Circle2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Radius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radius"}, Value: fmt.Sprintf("%v", *n.Radius)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ClipPlane: ClipPlane specifies a single plane equation used to clip (i.
type ClipPlane struct {
    CoreX3DNode
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Plane *SFVec4f `xml:"plane,attr,omitempty""`
}

func (n *ClipPlane) GetNodeName() string { return "ClipPlane" }
func (n *ClipPlane) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#ClipPlane" }
func (n *ClipPlane) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ClipPlane) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Plane != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "plane"}, Value: fmt.Sprintf("%v", *n.Plane)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CollidableOffset: CollidableOffset repositions geometry relative to center of owning body.
type CollidableOffset struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Collidable X3DNode `xml:"collidable,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *CollidableOffset) GetNodeName() string { return "CollidableOffset" }
func (n *CollidableOffset) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollidableOffset" }
func (n *CollidableOffset) Validate() error {
    if n.Collidable != nil {
        if err := n.Collidable.Validate(); err != nil { return fmt.Errorf("validation error in Collidable: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CollidableOffset) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Collidable != nil {
        if err := e.EncodeElement(n.Collidable, xml.StartElement{Name: xml.Name{Local: n.Collidable.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CollidableShape: CollidableShape connects the collision detection system, the rigid body model, and the renderable scene graph.
type CollidableShape struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    Shape X3DNode `xml:"shape,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *CollidableShape) GetNodeName() string { return "CollidableShape" }
func (n *CollidableShape) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollidableShape" }
func (n *CollidableShape) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Shape != nil {
        if err := n.Shape.Validate(); err != nil { return fmt.Errorf("validation error in Shape: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CollidableShape) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Shape != nil {
        if err := e.EncodeElement(n.Shape, xml.StartElement{Name: xml.Name{Local: n.Shape.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Collision: Collision detects camera-to-object contact using current view and NavigationInfo avatarSize.
type Collision struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    CollideTime *float64 `xml:"collideTime,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    Proxy X3DNode `xml:"proxy,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *Collision) GetNodeName() string { return "Collision" }
func (n *Collision) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#Collision" }
func (n *Collision) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Proxy != nil {
        if err := n.Proxy.Validate(); err != nil { return fmt.Errorf("validation error in Proxy: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Collision) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.CollideTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "collideTime"}, Value: fmt.Sprintf("%v", *n.CollideTime)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Proxy != nil {
        if err := e.EncodeElement(n.Proxy, xml.StartElement{Name: xml.Name{Local: n.Proxy.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// CollisionCollection: CollisionCollection holds a collection of objects that can be managed as a single entity for resolution of inter-object collisions.
type CollisionCollection struct {
    CoreX3DNode
    AppliedParameters []string `xml:"appliedParameters,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Bounce *float32 `xml:"bounce,attr,omitempty""`
    Collidables []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    FrictionCoefficients *SFVec2f `xml:"frictionCoefficients,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    MinBounceSpeed *float32 `xml:"minBounceSpeed,attr,omitempty""`
    SlipFactors *SFVec2f `xml:"slipFactors,attr,omitempty""`
    SoftnessConstantForceMix *float32 `xml:"softnessConstantForceMix,attr,omitempty""`
    SoftnessErrorCorrection *float32 `xml:"softnessErrorCorrection,attr,omitempty""`
    SurfaceSpeed *SFVec2f `xml:"surfaceSpeed,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *CollisionCollection) GetNodeName() string { return "CollisionCollection" }
func (n *CollisionCollection) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollisionCollection" }
func (n *CollisionCollection) Validate() error {
    if n.AppliedParameters != nil {
        for _, value := range n.AppliedParameters {
            switch value {
            case AppliedParametersChoicesBOUNCE, AppliedParametersChoicesUSERFRICTION, AppliedParametersChoicesFRICTIONCOEFFICIENT2, AppliedParametersChoicesERRORREDUCTION, AppliedParametersChoicesCONSTANTFORCE, AppliedParametersChoicesSPEED1, AppliedParametersChoicesSPEED2, AppliedParametersChoicesSLIP1, AppliedParametersChoicesSLIP2: // valid
            default: return fmt.Errorf("invalid value in field appliedParameters: %s", value)
            }
        }
    }
    if n.Collidables != nil {
        for i, child := range n.Collidables { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Collidables[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CollisionCollection) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AppliedParameters != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "appliedParameters"}, Value: fmt.Sprintf("%v", n.AppliedParameters)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Bounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bounce"}, Value: fmt.Sprintf("%v", *n.Bounce)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.FrictionCoefficients != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frictionCoefficients"}, Value: fmt.Sprintf("%v", *n.FrictionCoefficients)}) }
    if n.MinBounceSpeed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minBounceSpeed"}, Value: fmt.Sprintf("%v", *n.MinBounceSpeed)}) }
    if n.SlipFactors != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "slipFactors"}, Value: fmt.Sprintf("%v", *n.SlipFactors)}) }
    if n.SoftnessConstantForceMix != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "softnessConstantForceMix"}, Value: fmt.Sprintf("%v", *n.SoftnessConstantForceMix)}) }
    if n.SoftnessErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "softnessErrorCorrection"}, Value: fmt.Sprintf("%v", *n.SoftnessErrorCorrection)}) }
    if n.SurfaceSpeed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceSpeed"}, Value: fmt.Sprintf("%v", *n.SurfaceSpeed)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Collidables != nil {
        for _, child := range n.Collidables { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CollisionSensor: CollisionSensor generates collision-detection events.
type CollisionSensor struct {
    CoreX3DNode
    Collider X3DNode `xml:"collider,omitempty""`
    Contacts []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Intersections []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
}

func (n *CollisionSensor) GetNodeName() string { return "CollisionSensor" }
func (n *CollisionSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollisionSensor" }
func (n *CollisionSensor) Validate() error {
    if n.Collider != nil {
        if err := n.Collider.Validate(); err != nil { return fmt.Errorf("validation error in Collider: %w", err) }
    }
    if n.Contacts != nil {
        for i, child := range n.Contacts { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Contacts[%d]: %w", i, err) } }
    }
    if n.Intersections != nil {
        for i, child := range n.Intersections { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Intersections[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CollisionSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Collider != nil {
        if err := e.EncodeElement(n.Collider, xml.StartElement{Name: xml.Name{Local: n.Collider.GetNodeName()}}); err != nil { return err }
    }
    if n.Contacts != nil {
        for _, child := range n.Contacts { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Intersections != nil {
        for _, child := range n.Intersections { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CollisionSpace: CollisionSpace holds collection of objects considered together for resolution of inter-object collisions.
type CollisionSpace struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Collidables []X3DNode `xml:",any""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    UseGeometry *bool `xml:"useGeometry,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *CollisionSpace) GetNodeName() string { return "CollisionSpace" }
func (n *CollisionSpace) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#CollisionSpace" }
func (n *CollisionSpace) Validate() error {
    if n.Collidables != nil {
        for i, child := range n.Collidables { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Collidables[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CollisionSpace) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.UseGeometry != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "useGeometry"}, Value: fmt.Sprintf("%v", *n.UseGeometry)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Collidables != nil {
        for _, child := range n.Collidables { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Color: Color node defines a set of RGB color values that apply either to a sibling Coordinate|CoordinateDouble node, or else to a parent ElevationGrid node.
type Color struct {
    CoreX3DNode
    Color *MFColor `xml:"color,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
}

func (n *Color) GetNodeName() string { return "Color" }
func (n *Color) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#Color" }
func (n *Color) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Color) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ColorChaser: ColorChaser generates a series of SFColor values that progressively change from initial value to destination value.
type ColorChaser struct {
    CoreX3DNode
    Duration *float64 `xml:"duration,attr,omitempty""`
    InitialDestination *SFColor `xml:"initialDestination,attr,omitempty""`
    InitialValue *SFColor `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    SetDestination *SFColor `xml:"set_destination,attr,omitempty""`
    SetValue *SFColor `xml:"set_value,attr,omitempty""`
    ValueChanged *SFColor `xml:"value_changed,attr,omitempty""`
}

func (n *ColorChaser) GetNodeName() string { return "ColorChaser" }
func (n *ColorChaser) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#ColorChaser" }
func (n *ColorChaser) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ColorChaser) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Duration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "duration"}, Value: fmt.Sprintf("%v", *n.Duration)}) }
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ColorDamper: ColorDamper generates a series of RGB color values that progressively change from initial value to destination value.
type ColorDamper struct {
    CoreX3DNode
    InitialDestination *SFColor `xml:"initialDestination,attr,omitempty""`
    InitialValue *SFColor `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    SetDestination *SFColor `xml:"set_destination,attr,omitempty""`
    SetValue *SFColor `xml:"set_value,attr,omitempty""`
    Tau *float64 `xml:"tau,attr,omitempty""`
    Tolerance *float32 `xml:"tolerance,attr,omitempty""`
    ValueChanged *SFColor `xml:"value_changed,attr,omitempty""`
}

func (n *ColorDamper) GetNodeName() string { return "ColorDamper" }
func (n *ColorDamper) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#ColorDamper" }
func (n *ColorDamper) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ColorDamper) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.Tau != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tau"}, Value: fmt.Sprintf("%v", *n.Tau)}) }
    if n.Tolerance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tolerance"}, Value: fmt.Sprintf("%v", *n.Tolerance)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ColorInterpolator: ColorInterpolator generates a range of color values.
type ColorInterpolator struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFColor `xml:"keyValue,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFColor `xml:"value_changed,attr,omitempty""`
}

func (n *ColorInterpolator) GetNodeName() string { return "ColorInterpolator" }
func (n *ColorInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#ColorInterpolator" }
func (n *ColorInterpolator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ColorInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ColorRGBA: ColorRGBA node defines a set of RGBA color values that apply either to a sibling Coordinate|CoordinateDouble node, or else to a parent ElevationGrid node.
type ColorRGBA struct {
    CoreX3DNode
    Color *MFColorRGBA `xml:"color,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
}

func (n *ColorRGBA) GetNodeName() string { return "ColorRGBA" }
func (n *ColorRGBA) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#ColorRGBA" }
func (n *ColorRGBA) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ColorRGBA) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ComposedCubeMapTexture: ComposedCubeMapTexture is a texture node that defines a cubic environment map source as an explicit set of images drawn from individual 2D texture nodes.
type ComposedCubeMapTexture struct {
    CoreX3DNode
    BackTexture X3DNode `xml:"backTexture,omitempty""`
    BottomTexture X3DNode `xml:"bottomTexture,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    FrontTexture X3DNode `xml:"frontTexture,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    LeftTexture X3DNode `xml:"leftTexture,omitempty""`
    RightTexture X3DNode `xml:"rightTexture,omitempty""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
    TopTexture X3DNode `xml:"topTexture,omitempty""`
}

func (n *ComposedCubeMapTexture) GetNodeName() string { return "ComposedCubeMapTexture" }
func (n *ComposedCubeMapTexture) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalTexturing.html#ComposedCubeMapTexture" }
func (n *ComposedCubeMapTexture) Validate() error {
    if n.BackTexture != nil {
        if err := n.BackTexture.Validate(); err != nil { return fmt.Errorf("validation error in BackTexture: %w", err) }
    }
    if n.BottomTexture != nil {
        if err := n.BottomTexture.Validate(); err != nil { return fmt.Errorf("validation error in BottomTexture: %w", err) }
    }
    if n.FrontTexture != nil {
        if err := n.FrontTexture.Validate(); err != nil { return fmt.Errorf("validation error in FrontTexture: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.LeftTexture != nil {
        if err := n.LeftTexture.Validate(); err != nil { return fmt.Errorf("validation error in LeftTexture: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RightTexture != nil {
        if err := n.RightTexture.Validate(); err != nil { return fmt.Errorf("validation error in RightTexture: %w", err) }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    if n.TopTexture != nil {
        if err := n.TopTexture.Validate(); err != nil { return fmt.Errorf("validation error in TopTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ComposedCubeMapTexture) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.BackTexture != nil {
        if err := e.EncodeElement(n.BackTexture, xml.StartElement{Name: xml.Name{Local: n.BackTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.BottomTexture != nil {
        if err := e.EncodeElement(n.BottomTexture, xml.StartElement{Name: xml.Name{Local: n.BottomTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.FrontTexture != nil {
        if err := e.EncodeElement(n.FrontTexture, xml.StartElement{Name: xml.Name{Local: n.FrontTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.LeftTexture != nil {
        if err := e.EncodeElement(n.LeftTexture, xml.StartElement{Name: xml.Name{Local: n.LeftTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RightTexture != nil {
        if err := e.EncodeElement(n.RightTexture, xml.StartElement{Name: xml.Name{Local: n.RightTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    if n.TopTexture != nil {
        if err := e.EncodeElement(n.TopTexture, xml.StartElement{Name: xml.Name{Local: n.TopTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ComposedShader: ComposedShader can contain field declarations, but no CDATA section of plain-text source code, since programs are composed from child ShaderPart nodes.
type ComposedShader struct {
    CoreX3DNode
    Activate *bool `xml:"activate,attr,omitempty""`
    Field []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    IsSelected *bool `xml:"isSelected,attr,omitempty""`
    IsValid *bool `xml:"isValid,attr,omitempty""`
    Language *string `xml:"language,attr,omitempty""`
    Parts []X3DNode `xml:",any""`
}

func (n *ComposedShader) GetNodeName() string { return "ComposedShader" }
func (n *ComposedShader) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#ComposedShader" }
func (n *ComposedShader) Validate() error {
    if n.Field != nil {
        for i, child := range n.Field { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Field[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Parts != nil {
        for i, child := range n.Parts { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Parts[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ComposedShader) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Activate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "activate"}, Value: fmt.Sprintf("%v", *n.Activate)}) }
    if n.IsSelected != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isSelected"}, Value: fmt.Sprintf("%v", *n.IsSelected)}) }
    if n.IsValid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isValid"}, Value: fmt.Sprintf("%v", *n.IsValid)}) }
    if n.Language != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "language"}, Value: fmt.Sprintf("%v", *n.Language)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Field != nil {
        for _, child := range n.Field { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Parts != nil {
        for _, child := range n.Parts { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// ComposedTexture3D: ComposedTexture3D defines a 3D image-based texture map as a collection of 2D texture sources at various depths.
type ComposedTexture3D struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RepeatR *bool `xml:"repeatR,attr,omitempty""`
    RepeatS *bool `xml:"repeatS,attr,omitempty""`
    RepeatT *bool `xml:"repeatT,attr,omitempty""`
    Texture []X3DNode `xml:",any""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
}

func (n *ComposedTexture3D) GetNodeName() string { return "ComposedTexture3D" }
func (n *ComposedTexture3D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#ComposedTexture3D" }
func (n *ComposedTexture3D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Texture != nil {
        for i, child := range n.Texture { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Texture[%d]: %w", i, err) } }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ComposedTexture3D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.RepeatR != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatR"}, Value: fmt.Sprintf("%v", *n.RepeatR)}) }
    if n.RepeatS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatS"}, Value: fmt.Sprintf("%v", *n.RepeatS)}) }
    if n.RepeatT != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatT"}, Value: fmt.Sprintf("%v", *n.RepeatT)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Texture != nil {
        for _, child := range n.Texture { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ComposedVolumeStyle: ComposedVolumeStyle allows compositing multiple rendering styles into single rendering pass.
type ComposedVolumeStyle struct {
    CoreX3DNode
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RenderStyle []X3DNode `xml:",any""`
}

func (n *ComposedVolumeStyle) GetNodeName() string { return "ComposedVolumeStyle" }
func (n *ComposedVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#ComposedVolumeStyle" }
func (n *ComposedVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RenderStyle != nil {
        for i, child := range n.RenderStyle { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RenderStyle[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ComposedVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RenderStyle != nil {
        for _, child := range n.RenderStyle { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// Cone: Cone is a geometry node.
type Cone struct {
    CoreX3DNode
    Bottom *bool `xml:"bottom,attr,omitempty""`
    BottomRadius *float32 `xml:"bottomRadius,attr,omitempty""`
    Height *float32 `xml:"height,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Side *bool `xml:"side,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
}

func (n *Cone) GetNodeName() string { return "Cone" }
func (n *Cone) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Cone" }
func (n *Cone) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Cone) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Bottom != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bottom"}, Value: fmt.Sprintf("%v", *n.Bottom)}) }
    if n.BottomRadius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bottomRadius"}, Value: fmt.Sprintf("%v", *n.BottomRadius)}) }
    if n.Height != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "height"}, Value: fmt.Sprintf("%v", *n.Height)}) }
    if n.Side != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "side"}, Value: fmt.Sprintf("%v", *n.Side)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ConeEmitter: ConeEmitter generates all available particles from a specific point in space.
type ConeEmitter struct {
    CoreX3DNode
    Angle *float32 `xml:"angle,attr,omitempty""`
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Mass *float32 `xml:"mass,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    Position *SFVec3f `xml:"position,attr,omitempty""`
    Speed *float32 `xml:"speed,attr,omitempty""`
    SurfaceArea *float32 `xml:"surfaceArea,attr,omitempty""`
    Variation *float32 `xml:"variation,attr,omitempty""`
}

func (n *ConeEmitter) GetNodeName() string { return "ConeEmitter" }
func (n *ConeEmitter) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#ConeEmitter" }
func (n *ConeEmitter) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ConeEmitter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "angle"}, Value: fmt.Sprintf("%v", *n.Angle)}) }
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.Mass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mass"}, Value: fmt.Sprintf("%v", *n.Mass)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.Position != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position"}, Value: fmt.Sprintf("%v", *n.Position)}) }
    if n.Speed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speed"}, Value: fmt.Sprintf("%v", *n.Speed)}) }
    if n.SurfaceArea != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceArea"}, Value: fmt.Sprintf("%v", *n.SurfaceArea)}) }
    if n.Variation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "variation"}, Value: fmt.Sprintf("%v", *n.Variation)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Contact: Contact nodes are produced as output events when two collidable objects or spaces make contact.
type Contact struct {
    CoreX3DNode
    AppliedParameters []string `xml:"appliedParameters,attr,omitempty""`
    Body1 X3DNode `xml:"body1,omitempty""`
    Body2 X3DNode `xml:"body2,omitempty""`
    Bounce *float32 `xml:"bounce,attr,omitempty""`
    ContactNormal *SFVec3f `xml:"contactNormal,attr,omitempty""`
    Depth *float32 `xml:"depth,attr,omitempty""`
    FrictionCoefficients *SFVec2f `xml:"frictionCoefficients,attr,omitempty""`
    FrictionDirection *SFVec3f `xml:"frictionDirection,attr,omitempty""`
    Geometry1 X3DNode `xml:"geometry1,omitempty""`
    Geometry2 X3DNode `xml:"geometry2,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    MinBounceSpeed *float32 `xml:"minBounceSpeed,attr,omitempty""`
    Position *SFVec3f `xml:"position,attr,omitempty""`
    SlipCoefficients *SFVec2f `xml:"slipCoefficients,attr,omitempty""`
    SoftnessConstantForceMix *float32 `xml:"softnessConstantForceMix,attr,omitempty""`
    SoftnessErrorCorrection *float32 `xml:"softnessErrorCorrection,attr,omitempty""`
    SurfaceSpeed *SFVec2f `xml:"surfaceSpeed,attr,omitempty""`
}

func (n *Contact) GetNodeName() string { return "Contact" }
func (n *Contact) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#Contact" }
func (n *Contact) Validate() error {
    if n.AppliedParameters != nil {
        for _, value := range n.AppliedParameters {
            switch value {
            case AppliedParametersChoicesBOUNCE, AppliedParametersChoicesUSERFRICTION, AppliedParametersChoicesFRICTIONCOEFFICIENT2, AppliedParametersChoicesERRORREDUCTION, AppliedParametersChoicesCONSTANTFORCE, AppliedParametersChoicesSPEED1, AppliedParametersChoicesSPEED2, AppliedParametersChoicesSLIP1, AppliedParametersChoicesSLIP2: // valid
            default: return fmt.Errorf("invalid value in field appliedParameters: %s", value)
            }
        }
    }
    if n.Body1 != nil {
        if err := n.Body1.Validate(); err != nil { return fmt.Errorf("validation error in Body1: %w", err) }
    }
    if n.Body2 != nil {
        if err := n.Body2.Validate(); err != nil { return fmt.Errorf("validation error in Body2: %w", err) }
    }
    if n.Geometry1 != nil {
        if err := n.Geometry1.Validate(); err != nil { return fmt.Errorf("validation error in Geometry1: %w", err) }
    }
    if n.Geometry2 != nil {
        if err := n.Geometry2.Validate(); err != nil { return fmt.Errorf("validation error in Geometry2: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Contact) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AppliedParameters != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "appliedParameters"}, Value: fmt.Sprintf("%v", n.AppliedParameters)}) }
    if n.Bounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bounce"}, Value: fmt.Sprintf("%v", *n.Bounce)}) }
    if n.ContactNormal != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "contactNormal"}, Value: fmt.Sprintf("%v", *n.ContactNormal)}) }
    if n.Depth != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "depth"}, Value: fmt.Sprintf("%v", *n.Depth)}) }
    if n.FrictionCoefficients != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frictionCoefficients"}, Value: fmt.Sprintf("%v", *n.FrictionCoefficients)}) }
    if n.FrictionDirection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frictionDirection"}, Value: fmt.Sprintf("%v", *n.FrictionDirection)}) }
    if n.MinBounceSpeed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minBounceSpeed"}, Value: fmt.Sprintf("%v", *n.MinBounceSpeed)}) }
    if n.Position != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position"}, Value: fmt.Sprintf("%v", *n.Position)}) }
    if n.SlipCoefficients != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "slipCoefficients"}, Value: fmt.Sprintf("%v", *n.SlipCoefficients)}) }
    if n.SoftnessConstantForceMix != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "softnessConstantForceMix"}, Value: fmt.Sprintf("%v", *n.SoftnessConstantForceMix)}) }
    if n.SoftnessErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "softnessErrorCorrection"}, Value: fmt.Sprintf("%v", *n.SoftnessErrorCorrection)}) }
    if n.SurfaceSpeed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceSpeed"}, Value: fmt.Sprintf("%v", *n.SurfaceSpeed)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Body1 != nil {
        if err := e.EncodeElement(n.Body1, xml.StartElement{Name: xml.Name{Local: n.Body1.GetNodeName()}}); err != nil { return err }
    }
    if n.Body2 != nil {
        if err := e.EncodeElement(n.Body2, xml.StartElement{Name: xml.Name{Local: n.Body2.GetNodeName()}}); err != nil { return err }
    }
    if n.Geometry1 != nil {
        if err := e.EncodeElement(n.Geometry1, xml.StartElement{Name: xml.Name{Local: n.Geometry1.GetNodeName()}}); err != nil { return err }
    }
    if n.Geometry2 != nil {
        if err := e.EncodeElement(n.Geometry2, xml.StartElement{Name: xml.Name{Local: n.Geometry2.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Contour2D: Contour2D groups a set of curve segments into a composite contour.
type Contour2D struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
}

func (n *Contour2D) GetNodeName() string { return "Contour2D" }
func (n *Contour2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#Contour2D" }
func (n *Contour2D) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Contour2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// ContourPolyline2D: ContourPolyline2D defines a linear curve segment as part of a trimming contour in the u-v domain of a NURBS surface.
type ContourPolyline2D struct {
    CoreX3DNode
    ControlPoint *MFVec2d `xml:"controlPoint,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
}

func (n *ContourPolyline2D) GetNodeName() string { return "ContourPolyline2D" }
func (n *ContourPolyline2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#ContourPolyline2D" }
func (n *ContourPolyline2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ContourPolyline2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ControlPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "controlPoint"}, Value: fmt.Sprintf("%v", *n.ControlPoint)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Convolver: Convolver performs a linear convolution on a given AudioBuffer, often used to achieve a reverberation effect.
type Convolver struct {
    CoreX3DNode
    Buffer []float32 `xml:"buffer,attr,omitempty""`
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    Normalize *bool `xml:"normalize,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    TailTime *float64 `xml:"tailTime,attr,omitempty""`
}

func (n *Convolver) GetNodeName() string { return "Convolver" }
func (n *Convolver) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Convolver" }
func (n *Convolver) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Convolver) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Buffer != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "buffer"}, Value: fmt.Sprintf("%v", n.Buffer)}) }
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.Normalize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalize"}, Value: fmt.Sprintf("%v", *n.Normalize)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.TailTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tailTime"}, Value: fmt.Sprintf("%v", *n.TailTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Coordinate: Coordinate builds geometry by defining a set of 3D coordinate (triplet) point values.
type Coordinate struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Point *MFVec3f `xml:"point,attr,omitempty""`
}

func (n *Coordinate) GetNodeName() string { return "Coordinate" }
func (n *Coordinate) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#Coordinate" }
func (n *Coordinate) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Coordinate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Point != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "point"}, Value: fmt.Sprintf("%v", *n.Point)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CoordinateChaser: CoordinateChaser generates a series of coordinate arrays that progressively change from initial value to destination value.
type CoordinateChaser struct {
    CoreX3DNode
    Duration *float64 `xml:"duration,attr,omitempty""`
    InitialDestination *MFVec3f `xml:"initialDestination,attr,omitempty""`
    InitialValue *MFVec3f `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    SetDestination *MFVec3f `xml:"set_destination,attr,omitempty""`
    SetValue *MFVec3f `xml:"set_value,attr,omitempty""`
    ValueChanged *MFVec3f `xml:"value_changed,attr,omitempty""`
}

func (n *CoordinateChaser) GetNodeName() string { return "CoordinateChaser" }
func (n *CoordinateChaser) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#CoordinateChaser" }
func (n *CoordinateChaser) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CoordinateChaser) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Duration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "duration"}, Value: fmt.Sprintf("%v", *n.Duration)}) }
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CoordinateDamper: CoordinateDamper generates a series of coordinate arrays that progressively change from initial value to destination value.
type CoordinateDamper struct {
    CoreX3DNode
    InitialDestination *MFVec3f `xml:"initialDestination,attr,omitempty""`
    InitialValue *MFVec3f `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    SetDestination *MFVec3f `xml:"set_destination,attr,omitempty""`
    SetValue *MFVec3f `xml:"set_value,attr,omitempty""`
    Tau *float64 `xml:"tau,attr,omitempty""`
    Tolerance *float32 `xml:"tolerance,attr,omitempty""`
    ValueChanged *MFVec3f `xml:"value_changed,attr,omitempty""`
}

func (n *CoordinateDamper) GetNodeName() string { return "CoordinateDamper" }
func (n *CoordinateDamper) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#CoordinateDamper" }
func (n *CoordinateDamper) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CoordinateDamper) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.Tau != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tau"}, Value: fmt.Sprintf("%v", *n.Tau)}) }
    if n.Tolerance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tolerance"}, Value: fmt.Sprintf("%v", *n.Tolerance)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CoordinateDouble: CoordinateDouble builds geometry by defining a set of 3D coordinate (triplet) point values.
type CoordinateDouble struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Point *MFVec3d `xml:"point,attr,omitempty""`
}

func (n *CoordinateDouble) GetNodeName() string { return "CoordinateDouble" }
func (n *CoordinateDouble) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#CoordinateDouble" }
func (n *CoordinateDouble) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CoordinateDouble) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Point != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "point"}, Value: fmt.Sprintf("%v", *n.Point)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CoordinateInterpolator: CoordinateInterpolator linearly interpolates among a list of 3-tuple MFVec3f arrays, producing a single MFVec3f array that is fractional average between two nearest arrays in the list.
type CoordinateInterpolator struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFVec3f `xml:"keyValue,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *MFVec3f `xml:"value_changed,attr,omitempty""`
}

func (n *CoordinateInterpolator) GetNodeName() string { return "CoordinateInterpolator" }
func (n *CoordinateInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#CoordinateInterpolator" }
func (n *CoordinateInterpolator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CoordinateInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CoordinateInterpolator2D: CoordinateInterpolator2D generates a series of SFVec2f or MFVec2f 2-tuple float values.
type CoordinateInterpolator2D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFVec2f `xml:"keyValue,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *MFVec2f `xml:"value_changed,attr,omitempty""`
}

func (n *CoordinateInterpolator2D) GetNodeName() string { return "CoordinateInterpolator2D" }
func (n *CoordinateInterpolator2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#CoordinateInterpolator2D" }
func (n *CoordinateInterpolator2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CoordinateInterpolator2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Cylinder: Cylinder is a geometry node.
type Cylinder struct {
    CoreX3DNode
    Bottom *bool `xml:"bottom,attr,omitempty""`
    Height *float32 `xml:"height,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Radius *float32 `xml:"radius,attr,omitempty""`
    Side *bool `xml:"side,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    Top *bool `xml:"top,attr,omitempty""`
}

func (n *Cylinder) GetNodeName() string { return "Cylinder" }
func (n *Cylinder) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Cylinder" }
func (n *Cylinder) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Cylinder) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Bottom != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bottom"}, Value: fmt.Sprintf("%v", *n.Bottom)}) }
    if n.Height != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "height"}, Value: fmt.Sprintf("%v", *n.Height)}) }
    if n.Radius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radius"}, Value: fmt.Sprintf("%v", *n.Radius)}) }
    if n.Side != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "side"}, Value: fmt.Sprintf("%v", *n.Side)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.Top != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "top"}, Value: fmt.Sprintf("%v", *n.Top)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// CylinderSensor: CylinderSensor converts pointer motion (for example, a mouse or wand) into rotation values using an invisible cylinder aligned with local Y-axis.
type CylinderSensor struct {
    CoreX3DNode
    AutoOffset *bool `xml:"autoOffset,attr,omitempty""`
    AxisRotation *SFRotation `xml:"axisRotation,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    DiskAngle *float32 `xml:"diskAngle,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsOver *bool `xml:"isOver,attr,omitempty""`
    MaxAngle *float32 `xml:"maxAngle,attr,omitempty""`
    MinAngle *float32 `xml:"minAngle,attr,omitempty""`
    Offset *float32 `xml:"offset,attr,omitempty""`
    RotationChanged *SFRotation `xml:"rotation_changed,attr,omitempty""`
    TrackPointChanged *SFVec3f `xml:"trackPoint_changed,attr,omitempty""`
}

func (n *CylinderSensor) GetNodeName() string { return "CylinderSensor" }
func (n *CylinderSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#CylinderSensor" }
func (n *CylinderSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *CylinderSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoOffset != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoOffset"}, Value: fmt.Sprintf("%v", *n.AutoOffset)}) }
    if n.AxisRotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axisRotation"}, Value: fmt.Sprintf("%v", *n.AxisRotation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.DiskAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diskAngle"}, Value: fmt.Sprintf("%v", *n.DiskAngle)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsOver != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isOver"}, Value: fmt.Sprintf("%v", *n.IsOver)}) }
    if n.MaxAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxAngle"}, Value: fmt.Sprintf("%v", *n.MaxAngle)}) }
    if n.MinAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minAngle"}, Value: fmt.Sprintf("%v", *n.MinAngle)}) }
    if n.Offset != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "offset"}, Value: fmt.Sprintf("%v", *n.Offset)}) }
    if n.RotationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation_changed"}, Value: fmt.Sprintf("%v", *n.RotationChanged)}) }
    if n.TrackPointChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "trackPoint_changed"}, Value: fmt.Sprintf("%v", *n.TrackPointChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Delay: Delay causes a time delay between the arrival of input data and subsequent propagation to the output.
type Delay struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    DelayTime *float64 `xml:"delayTime,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    MaxDelayTime *float64 `xml:"maxDelayTime,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    TailTime *float64 `xml:"tailTime,attr,omitempty""`
}

func (n *Delay) GetNodeName() string { return "Delay" }
func (n *Delay) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Delay" }
func (n *Delay) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Delay) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.DelayTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "delayTime"}, Value: fmt.Sprintf("%v", *n.DelayTime)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.MaxDelayTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxDelayTime"}, Value: fmt.Sprintf("%v", *n.MaxDelayTime)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.TailTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tailTime"}, Value: fmt.Sprintf("%v", *n.TailTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// DirectionalLight: DirectionalLight might not be scoped by parent Group or Transform at levels 1 or 2.
type DirectionalLight struct {
    CoreX3DNode
    AmbientIntensity *float32 `xml:"ambientIntensity,attr,omitempty""`
    Color *SFColor `xml:"color,attr,omitempty""`
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    Global *bool `xml:"global,attr,omitempty""`
    Intensity *float32 `xml:"intensity,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    ShadowIntensity *float32 `xml:"shadowIntensity,attr,omitempty""`
    Shadows *bool `xml:"shadows,attr,omitempty""`
}

func (n *DirectionalLight) GetNodeName() string { return "DirectionalLight" }
func (n *DirectionalLight) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/lighting.html#DirectionalLight" }
func (n *DirectionalLight) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *DirectionalLight) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AmbientIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ambientIntensity"}, Value: fmt.Sprintf("%v", *n.AmbientIntensity)}) }
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.Global != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "global"}, Value: fmt.Sprintf("%v", *n.Global)}) }
    if n.Intensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intensity"}, Value: fmt.Sprintf("%v", *n.Intensity)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.ShadowIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadowIntensity"}, Value: fmt.Sprintf("%v", *n.ShadowIntensity)}) }
    if n.Shadows != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadows"}, Value: fmt.Sprintf("%v", *n.Shadows)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// DISEntityManager: DISEntityManager notifies a scene when new DIS ESPDU entities arrive or current entities leave.
type DISEntityManager struct {
    CoreX3DNode
    AddedEntities []X3DNode `xml:",any""`
    Address *string `xml:"address,attr,omitempty""`
    ApplicationID *int32 `xml:"applicationID,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Port *int32 `xml:"port,attr,omitempty""`
    RemovedEntities []X3DNode `xml:",any""`
    SiteID *int32 `xml:"siteID,attr,omitempty""`
}

func (n *DISEntityManager) GetNodeName() string { return "DISEntityManager" }
func (n *DISEntityManager) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#DISEntityManager" }
func (n *DISEntityManager) Validate() error {
    if n.AddedEntities != nil {
        for i, child := range n.AddedEntities { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddedEntities[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemovedEntities != nil {
        for i, child := range n.RemovedEntities { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemovedEntities[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *DISEntityManager) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Address != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "address"}, Value: fmt.Sprintf("%v", *n.Address)}) }
    if n.ApplicationID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "applicationID"}, Value: fmt.Sprintf("%v", *n.ApplicationID)}) }
    if n.Port != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "port"}, Value: fmt.Sprintf("%v", *n.Port)}) }
    if n.SiteID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "siteID"}, Value: fmt.Sprintf("%v", *n.SiteID)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddedEntities != nil {
        for _, child := range n.AddedEntities { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemovedEntities != nil {
        for _, child := range n.RemovedEntities { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// DISEntityTypeMapping: DISEntityTypeMapping provides a best-match mapping from DIS ESPDU entity type information to a specific X3D model, thus providing a visual and behavioral representation that best matches the entity type.
type DISEntityTypeMapping struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Category *int32 `xml:"category,attr,omitempty""`
    Country *int32 `xml:"country,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Domain *int32 `xml:"domain,attr,omitempty""`
    Extra *int32 `xml:"extra,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Kind *int32 `xml:"kind,attr,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    Specific *int32 `xml:"specific,attr,omitempty""`
    Subcategory *int32 `xml:"subcategory,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *DISEntityTypeMapping) GetNodeName() string { return "DISEntityTypeMapping" }
func (n *DISEntityTypeMapping) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#DISEntityTypeMapping" }
func (n *DISEntityTypeMapping) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *DISEntityTypeMapping) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Category != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "category"}, Value: fmt.Sprintf("%v", *n.Category)}) }
    if n.Country != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "country"}, Value: fmt.Sprintf("%v", *n.Country)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Domain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "domain"}, Value: fmt.Sprintf("%v", *n.Domain)}) }
    if n.Extra != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "extra"}, Value: fmt.Sprintf("%v", *n.Extra)}) }
    if n.Kind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "kind"}, Value: fmt.Sprintf("%v", *n.Kind)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Specific != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specific"}, Value: fmt.Sprintf("%v", *n.Specific)}) }
    if n.Subcategory != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "subcategory"}, Value: fmt.Sprintf("%v", *n.Subcategory)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Disk2D: Disk2D is a geometry node that defines a filled (or partially filled) planar circle with center (0,0).
type Disk2D struct {
    CoreX3DNode
    InnerRadius *float32 `xml:"innerRadius,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    OuterRadius *float32 `xml:"outerRadius,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
}

func (n *Disk2D) GetNodeName() string { return "Disk2D" }
func (n *Disk2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Disk2D" }
func (n *Disk2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Disk2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.InnerRadius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "innerRadius"}, Value: fmt.Sprintf("%v", *n.InnerRadius)}) }
    if n.OuterRadius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "outerRadius"}, Value: fmt.Sprintf("%v", *n.OuterRadius)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// DoubleAxisHingeJoint: DoubleAxisHingeJoint has two independent axes located around a common anchor point.
type DoubleAxisHingeJoint struct {
    CoreX3DNode
    AnchorPoint *SFVec3f `xml:"anchorPoint,attr,omitempty""`
    Axis1 *SFVec3f `xml:"axis1,attr,omitempty""`
    Axis2 *SFVec3f `xml:"axis2,attr,omitempty""`
    Body1 X3DNode `xml:"body1,omitempty""`
    Body1AnchorPoint *SFVec3f `xml:"body1AnchorPoint,attr,omitempty""`
    Body1Axis *SFVec3f `xml:"body1Axis,attr,omitempty""`
    Body2 X3DNode `xml:"body2,omitempty""`
    Body2AnchorPoint *SFVec3f `xml:"body2AnchorPoint,attr,omitempty""`
    Body2Axis *SFVec3f `xml:"body2Axis,attr,omitempty""`
    DesiredAngularVelocity1 *float32 `xml:"desiredAngularVelocity1,attr,omitempty""`
    DesiredAngularVelocity2 *float32 `xml:"desiredAngularVelocity2,attr,omitempty""`
    ForceOutput []string `xml:"forceOutput,attr,omitempty""`
    Hinge1Angle *float32 `xml:"hinge1Angle,attr,omitempty""`
    Hinge1AngleRate *float32 `xml:"hinge1AngleRate,attr,omitempty""`
    Hinge2Angle *float32 `xml:"hinge2Angle,attr,omitempty""`
    Hinge2AngleRate *float32 `xml:"hinge2AngleRate,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    MaxAngle1 *float32 `xml:"maxAngle1,attr,omitempty""`
    MaxTorque1 *float32 `xml:"maxTorque1,attr,omitempty""`
    MaxTorque2 *float32 `xml:"maxTorque2,attr,omitempty""`
    MinAngle1 *float32 `xml:"minAngle1,attr,omitempty""`
    Stop1Bounce *float32 `xml:"stop1Bounce,attr,omitempty""`
    Stop1ConstantForceMix *float32 `xml:"stop1ConstantForceMix,attr,omitempty""`
    Stop1ErrorCorrection *float32 `xml:"stop1ErrorCorrection,attr,omitempty""`
    SuspensionErrorCorrection *float32 `xml:"suspensionErrorCorrection,attr,omitempty""`
    SuspensionForce *float32 `xml:"suspensionForce,attr,omitempty""`
}

func (n *DoubleAxisHingeJoint) GetNodeName() string { return "DoubleAxisHingeJoint" }
func (n *DoubleAxisHingeJoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#DoubleAxisHingeJoint" }
func (n *DoubleAxisHingeJoint) Validate() error {
    if n.Body1 != nil {
        if err := n.Body1.Validate(); err != nil { return fmt.Errorf("validation error in Body1: %w", err) }
    }
    if n.Body2 != nil {
        if err := n.Body2.Validate(); err != nil { return fmt.Errorf("validation error in Body2: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *DoubleAxisHingeJoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "anchorPoint"}, Value: fmt.Sprintf("%v", *n.AnchorPoint)}) }
    if n.Axis1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis1"}, Value: fmt.Sprintf("%v", *n.Axis1)}) }
    if n.Axis2 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis2"}, Value: fmt.Sprintf("%v", *n.Axis2)}) }
    if n.Body1AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body1AnchorPoint"}, Value: fmt.Sprintf("%v", *n.Body1AnchorPoint)}) }
    if n.Body1Axis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body1Axis"}, Value: fmt.Sprintf("%v", *n.Body1Axis)}) }
    if n.Body2AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body2AnchorPoint"}, Value: fmt.Sprintf("%v", *n.Body2AnchorPoint)}) }
    if n.Body2Axis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body2Axis"}, Value: fmt.Sprintf("%v", *n.Body2Axis)}) }
    if n.DesiredAngularVelocity1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "desiredAngularVelocity1"}, Value: fmt.Sprintf("%v", *n.DesiredAngularVelocity1)}) }
    if n.DesiredAngularVelocity2 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "desiredAngularVelocity2"}, Value: fmt.Sprintf("%v", *n.DesiredAngularVelocity2)}) }
    if n.ForceOutput != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "forceOutput"}, Value: fmt.Sprintf("%v", n.ForceOutput)}) }
    if n.Hinge1Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hinge1Angle"}, Value: fmt.Sprintf("%v", *n.Hinge1Angle)}) }
    if n.Hinge1AngleRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hinge1AngleRate"}, Value: fmt.Sprintf("%v", *n.Hinge1AngleRate)}) }
    if n.Hinge2Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hinge2Angle"}, Value: fmt.Sprintf("%v", *n.Hinge2Angle)}) }
    if n.Hinge2AngleRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hinge2AngleRate"}, Value: fmt.Sprintf("%v", *n.Hinge2AngleRate)}) }
    if n.MaxAngle1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxAngle1"}, Value: fmt.Sprintf("%v", *n.MaxAngle1)}) }
    if n.MaxTorque1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxTorque1"}, Value: fmt.Sprintf("%v", *n.MaxTorque1)}) }
    if n.MaxTorque2 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxTorque2"}, Value: fmt.Sprintf("%v", *n.MaxTorque2)}) }
    if n.MinAngle1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minAngle1"}, Value: fmt.Sprintf("%v", *n.MinAngle1)}) }
    if n.Stop1Bounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop1Bounce"}, Value: fmt.Sprintf("%v", *n.Stop1Bounce)}) }
    if n.Stop1ConstantForceMix != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop1ConstantForceMix"}, Value: fmt.Sprintf("%v", *n.Stop1ConstantForceMix)}) }
    if n.Stop1ErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop1ErrorCorrection"}, Value: fmt.Sprintf("%v", *n.Stop1ErrorCorrection)}) }
    if n.SuspensionErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "suspensionErrorCorrection"}, Value: fmt.Sprintf("%v", *n.SuspensionErrorCorrection)}) }
    if n.SuspensionForce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "suspensionForce"}, Value: fmt.Sprintf("%v", *n.SuspensionForce)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Body1 != nil {
        if err := e.EncodeElement(n.Body1, xml.StartElement{Name: xml.Name{Local: n.Body1.GetNodeName()}}); err != nil { return err }
    }
    if n.Body2 != nil {
        if err := e.EncodeElement(n.Body2, xml.StartElement{Name: xml.Name{Local: n.Body2.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// DynamicsCompressor: DynamicsCompressor node implements a dynamics compression effect, lowering volume of loudest parts of signal and raising volume of softest parts.
type DynamicsCompressor struct {
    CoreX3DNode
    Attack *float64 `xml:"attack,attr,omitempty""`
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    Knee *float32 `xml:"knee,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    Ratio *float32 `xml:"ratio,attr,omitempty""`
    Reduction *float32 `xml:"reduction,attr,omitempty""`
    Release *float64 `xml:"release,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    TailTime *float64 `xml:"tailTime,attr,omitempty""`
    Threshold *float32 `xml:"threshold,attr,omitempty""`
}

func (n *DynamicsCompressor) GetNodeName() string { return "DynamicsCompressor" }
func (n *DynamicsCompressor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#DynamicsCompressor" }
func (n *DynamicsCompressor) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *DynamicsCompressor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Attack != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "attack"}, Value: fmt.Sprintf("%v", *n.Attack)}) }
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.Knee != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "knee"}, Value: fmt.Sprintf("%v", *n.Knee)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.Ratio != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ratio"}, Value: fmt.Sprintf("%v", *n.Ratio)}) }
    if n.Reduction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "reduction"}, Value: fmt.Sprintf("%v", *n.Reduction)}) }
    if n.Release != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "release"}, Value: fmt.Sprintf("%v", *n.Release)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.TailTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tailTime"}, Value: fmt.Sprintf("%v", *n.TailTime)}) }
    if n.Threshold != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "threshold"}, Value: fmt.Sprintf("%v", *n.Threshold)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// EaseInEaseOut: EaseInEaseOut enables gradual animation transitions by modifying TimeSensor fraction outputs.
type EaseInEaseOut struct {
    CoreX3DNode
    EaseInEaseOut *MFVec2f `xml:"easeInEaseOut,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    ModifiedFractionChanged *float32 `xml:"modifiedFraction_changed,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
}

func (n *EaseInEaseOut) GetNodeName() string { return "EaseInEaseOut" }
func (n *EaseInEaseOut) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#EaseInEaseOut" }
func (n *EaseInEaseOut) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *EaseInEaseOut) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.EaseInEaseOut != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "easeInEaseOut"}, Value: fmt.Sprintf("%v", *n.EaseInEaseOut)}) }
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.ModifiedFractionChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "modifiedFraction_changed"}, Value: fmt.Sprintf("%v", *n.ModifiedFractionChanged)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// EdgeEnhancementVolumeStyle: EdgeEnhancementVolumeStyle specifies edge enhancement for the volume rendering style.
type EdgeEnhancementVolumeStyle struct {
    CoreX3DNode
    EdgeColor *SFColorRGBA `xml:"edgeColor,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    GradientThreshold *float32 `xml:"gradientThreshold,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    SurfaceNormals X3DNode `xml:"surfaceNormals,omitempty""`
}

func (n *EdgeEnhancementVolumeStyle) GetNodeName() string { return "EdgeEnhancementVolumeStyle" }
func (n *EdgeEnhancementVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#EdgeEnhancementVolumeStyle" }
func (n *EdgeEnhancementVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.SurfaceNormals != nil {
        if err := n.SurfaceNormals.Validate(); err != nil { return fmt.Errorf("validation error in SurfaceNormals: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *EdgeEnhancementVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.EdgeColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "edgeColor"}, Value: fmt.Sprintf("%v", *n.EdgeColor)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.GradientThreshold != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gradientThreshold"}, Value: fmt.Sprintf("%v", *n.GradientThreshold)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.SurfaceNormals != nil {
        if err := e.EncodeElement(n.SurfaceNormals, xml.StartElement{Name: xml.Name{Local: n.SurfaceNormals.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ElevationGrid: ElevationGrid is a geometry node defining a rectangular height field, with default values for a 1m by 1m square at height 0.
type ElevationGrid struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    CreaseAngle *float32 `xml:"creaseAngle,attr,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    Height []float32 `xml:"height,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    SetHeight []float32 `xml:"set_height,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    XDimension *int32 `xml:"xDimension,attr,omitempty""`
    XSpacing *float32 `xml:"xSpacing,attr,omitempty""`
    ZDimension *int32 `xml:"zDimension,attr,omitempty""`
    ZSpacing *float32 `xml:"zSpacing,attr,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *ElevationGrid) GetNodeName() string { return "ElevationGrid" }
func (n *ElevationGrid) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#ElevationGrid" }
func (n *ElevationGrid) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ElevationGrid) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.CreaseAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "creaseAngle"}, Value: fmt.Sprintf("%v", *n.CreaseAngle)}) }
    if n.Height != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "height"}, Value: fmt.Sprintf("%v", n.Height)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.SetHeight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_height"}, Value: fmt.Sprintf("%v", n.SetHeight)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.XDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "xDimension"}, Value: fmt.Sprintf("%v", *n.XDimension)}) }
    if n.XSpacing != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "xSpacing"}, Value: fmt.Sprintf("%v", *n.XSpacing)}) }
    if n.ZDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "zDimension"}, Value: fmt.Sprintf("%v", *n.ZDimension)}) }
    if n.ZSpacing != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "zSpacing"}, Value: fmt.Sprintf("%v", *n.ZSpacing)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// EspduTransform: EspduTransform is a networked Transform node that can contain most nodes.
type EspduTransform struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    Address *string `xml:"address,attr,omitempty""`
    ApplicationID *int32 `xml:"applicationID,attr,omitempty""`
    ArticulationParameterArray []float32 `xml:"articulationParameterArray,attr,omitempty""`
    ArticulationParameterChangeIndicatorArray []int32 `xml:"articulationParameterChangeIndicatorArray,attr,omitempty""`
    ArticulationParameterCount *int32 `xml:"articulationParameterCount,attr,omitempty""`
    ArticulationParameterDesignatorArray []int32 `xml:"articulationParameterDesignatorArray,attr,omitempty""`
    ArticulationParameterIdPartAttachedToArray []int32 `xml:"articulationParameterIdPartAttachedToArray,attr,omitempty""`
    ArticulationParameterTypeArray []int32 `xml:"articulationParameterTypeArray,attr,omitempty""`
    ArticulationParameterValue0Changed *float32 `xml:"articulationParameterValue0_changed,attr,omitempty""`
    ArticulationParameterValue1Changed *float32 `xml:"articulationParameterValue1_changed,attr,omitempty""`
    ArticulationParameterValue2Changed *float32 `xml:"articulationParameterValue2_changed,attr,omitempty""`
    ArticulationParameterValue3Changed *float32 `xml:"articulationParameterValue3_changed,attr,omitempty""`
    ArticulationParameterValue4Changed *float32 `xml:"articulationParameterValue4_changed,attr,omitempty""`
    ArticulationParameterValue5Changed *float32 `xml:"articulationParameterValue5_changed,attr,omitempty""`
    ArticulationParameterValue6Changed *float32 `xml:"articulationParameterValue6_changed,attr,omitempty""`
    ArticulationParameterValue7Changed *float32 `xml:"articulationParameterValue7_changed,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    CollideTime *float64 `xml:"collideTime,attr,omitempty""`
    CollisionType *int32 `xml:"collisionType,attr,omitempty""`
    DeadReckoning *int32 `xml:"deadReckoning,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    DetonateTime *float64 `xml:"detonateTime,attr,omitempty""`
    DetonationLocation *SFVec3f `xml:"detonationLocation,attr,omitempty""`
    DetonationRelativeLocation *SFVec3f `xml:"detonationRelativeLocation,attr,omitempty""`
    DetonationResult *int32 `xml:"detonationResult,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EntityCategory *int32 `xml:"entityCategory,attr,omitempty""`
    EntityCountry *int32 `xml:"entityCountry,attr,omitempty""`
    EntityDomain *int32 `xml:"entityDomain,attr,omitempty""`
    EntityExtra *int32 `xml:"entityExtra,attr,omitempty""`
    EntityID *int32 `xml:"entityID,attr,omitempty""`
    EntityKind *int32 `xml:"entityKind,attr,omitempty""`
    EntitySpecific *int32 `xml:"entitySpecific,attr,omitempty""`
    EntitySubcategory *int32 `xml:"entitySubcategory,attr,omitempty""`
    EventApplicationID *int32 `xml:"eventApplicationID,attr,omitempty""`
    EventEntityID *int32 `xml:"eventEntityID,attr,omitempty""`
    EventNumber *int32 `xml:"eventNumber,attr,omitempty""`
    EventSiteID *int32 `xml:"eventSiteID,attr,omitempty""`
    Fired1 *bool `xml:"fired1,attr,omitempty""`
    Fired2 *bool `xml:"fired2,attr,omitempty""`
    FiredTime *float64 `xml:"firedTime,attr,omitempty""`
    FireMissionIndex *int32 `xml:"fireMissionIndex,attr,omitempty""`
    FiringRange *float32 `xml:"firingRange,attr,omitempty""`
    FiringRate *int32 `xml:"firingRate,attr,omitempty""`
    ForceID *int32 `xml:"forceID,attr,omitempty""`
    Fuse *int32 `xml:"fuse,attr,omitempty""`
    GeoCoords *SFVec3d `xml:"geoCoords,attr,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsCollided *bool `xml:"isCollided,attr,omitempty""`
    IsDetonated *bool `xml:"isDetonated,attr,omitempty""`
    IsNetworkReader *bool `xml:"isNetworkReader,attr,omitempty""`
    IsNetworkWriter *bool `xml:"isNetworkWriter,attr,omitempty""`
    IsRtpHeaderHeard *bool `xml:"isRtpHeaderHeard,attr,omitempty""`
    IsStandAlone *bool `xml:"isStandAlone,attr,omitempty""`
    LinearAcceleration *SFVec3f `xml:"linearAcceleration,attr,omitempty""`
    LinearVelocity *SFVec3f `xml:"linearVelocity,attr,omitempty""`
    Marking *string `xml:"marking,attr,omitempty""`
    MulticastRelayHost *string `xml:"multicastRelayHost,attr,omitempty""`
    MulticastRelayPort *int32 `xml:"multicastRelayPort,attr,omitempty""`
    MunitionApplicationID *int32 `xml:"munitionApplicationID,attr,omitempty""`
    MunitionEndPoint *SFVec3f `xml:"munitionEndPoint,attr,omitempty""`
    MunitionEntityID *int32 `xml:"munitionEntityID,attr,omitempty""`
    MunitionQuantity *int32 `xml:"munitionQuantity,attr,omitempty""`
    MunitionSiteID *int32 `xml:"munitionSiteID,attr,omitempty""`
    MunitionStartPoint *SFVec3f `xml:"munitionStartPoint,attr,omitempty""`
    NetworkMode *string `xml:"networkMode,attr,omitempty""`
    Port *int32 `xml:"port,attr,omitempty""`
    ReadInterval *float64 `xml:"readInterval,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    RtpHeaderExpected *bool `xml:"rtpHeaderExpected,attr,omitempty""`
    Scale *SFVec3f `xml:"scale,attr,omitempty""`
    ScaleOrientation *SFRotation `xml:"scaleOrientation,attr,omitempty""`
    SetArticulationParameterValue0 *float32 `xml:"set_articulationParameterValue0,attr,omitempty""`
    SetArticulationParameterValue1 *float32 `xml:"set_articulationParameterValue1,attr,omitempty""`
    SetArticulationParameterValue2 *float32 `xml:"set_articulationParameterValue2,attr,omitempty""`
    SetArticulationParameterValue3 *float32 `xml:"set_articulationParameterValue3,attr,omitempty""`
    SetArticulationParameterValue4 *float32 `xml:"set_articulationParameterValue4,attr,omitempty""`
    SetArticulationParameterValue5 *float32 `xml:"set_articulationParameterValue5,attr,omitempty""`
    SetArticulationParameterValue6 *float32 `xml:"set_articulationParameterValue6,attr,omitempty""`
    SetArticulationParameterValue7 *float32 `xml:"set_articulationParameterValue7,attr,omitempty""`
    SiteID *int32 `xml:"siteID,attr,omitempty""`
    Timestamp *float64 `xml:"timestamp,attr,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    Warhead *int32 `xml:"warhead,attr,omitempty""`
    WriteInterval *float64 `xml:"writeInterval,attr,omitempty""`
}

func (n *EspduTransform) GetNodeName() string { return "EspduTransform" }
func (n *EspduTransform) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#EspduTransform" }
func (n *EspduTransform) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.NetworkMode != nil {
        switch *n.NetworkMode {
        case NetworkModeChoicesStandAlone, NetworkModeChoicesNetworkReader, NetworkModeChoicesNetworkWriter: // valid
        default: return fmt.Errorf("invalid value for field networkMode: %s", *n.NetworkMode)
        }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *EspduTransform) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Address != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "address"}, Value: fmt.Sprintf("%v", *n.Address)}) }
    if n.ApplicationID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "applicationID"}, Value: fmt.Sprintf("%v", *n.ApplicationID)}) }
    if n.ArticulationParameterArray != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterArray"}, Value: fmt.Sprintf("%v", n.ArticulationParameterArray)}) }
    if n.ArticulationParameterChangeIndicatorArray != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterChangeIndicatorArray"}, Value: fmt.Sprintf("%v", n.ArticulationParameterChangeIndicatorArray)}) }
    if n.ArticulationParameterCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterCount"}, Value: fmt.Sprintf("%v", *n.ArticulationParameterCount)}) }
    if n.ArticulationParameterDesignatorArray != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterDesignatorArray"}, Value: fmt.Sprintf("%v", n.ArticulationParameterDesignatorArray)}) }
    if n.ArticulationParameterIdPartAttachedToArray != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterIdPartAttachedToArray"}, Value: fmt.Sprintf("%v", n.ArticulationParameterIdPartAttachedToArray)}) }
    if n.ArticulationParameterTypeArray != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterTypeArray"}, Value: fmt.Sprintf("%v", n.ArticulationParameterTypeArray)}) }
    if n.ArticulationParameterValue0Changed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterValue0_changed"}, Value: fmt.Sprintf("%v", *n.ArticulationParameterValue0Changed)}) }
    if n.ArticulationParameterValue1Changed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterValue1_changed"}, Value: fmt.Sprintf("%v", *n.ArticulationParameterValue1Changed)}) }
    if n.ArticulationParameterValue2Changed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterValue2_changed"}, Value: fmt.Sprintf("%v", *n.ArticulationParameterValue2Changed)}) }
    if n.ArticulationParameterValue3Changed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterValue3_changed"}, Value: fmt.Sprintf("%v", *n.ArticulationParameterValue3Changed)}) }
    if n.ArticulationParameterValue4Changed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterValue4_changed"}, Value: fmt.Sprintf("%v", *n.ArticulationParameterValue4Changed)}) }
    if n.ArticulationParameterValue5Changed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterValue5_changed"}, Value: fmt.Sprintf("%v", *n.ArticulationParameterValue5Changed)}) }
    if n.ArticulationParameterValue6Changed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterValue6_changed"}, Value: fmt.Sprintf("%v", *n.ArticulationParameterValue6Changed)}) }
    if n.ArticulationParameterValue7Changed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "articulationParameterValue7_changed"}, Value: fmt.Sprintf("%v", *n.ArticulationParameterValue7Changed)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.CollideTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "collideTime"}, Value: fmt.Sprintf("%v", *n.CollideTime)}) }
    if n.CollisionType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "collisionType"}, Value: fmt.Sprintf("%v", *n.CollisionType)}) }
    if n.DeadReckoning != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "deadReckoning"}, Value: fmt.Sprintf("%v", *n.DeadReckoning)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.DetonateTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "detonateTime"}, Value: fmt.Sprintf("%v", *n.DetonateTime)}) }
    if n.DetonationLocation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "detonationLocation"}, Value: fmt.Sprintf("%v", *n.DetonationLocation)}) }
    if n.DetonationRelativeLocation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "detonationRelativeLocation"}, Value: fmt.Sprintf("%v", *n.DetonationRelativeLocation)}) }
    if n.DetonationResult != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "detonationResult"}, Value: fmt.Sprintf("%v", *n.DetonationResult)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EntityCategory != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entityCategory"}, Value: fmt.Sprintf("%v", *n.EntityCategory)}) }
    if n.EntityCountry != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entityCountry"}, Value: fmt.Sprintf("%v", *n.EntityCountry)}) }
    if n.EntityDomain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entityDomain"}, Value: fmt.Sprintf("%v", *n.EntityDomain)}) }
    if n.EntityExtra != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entityExtra"}, Value: fmt.Sprintf("%v", *n.EntityExtra)}) }
    if n.EntityID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entityID"}, Value: fmt.Sprintf("%v", *n.EntityID)}) }
    if n.EntityKind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entityKind"}, Value: fmt.Sprintf("%v", *n.EntityKind)}) }
    if n.EntitySpecific != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entitySpecific"}, Value: fmt.Sprintf("%v", *n.EntitySpecific)}) }
    if n.EntitySubcategory != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entitySubcategory"}, Value: fmt.Sprintf("%v", *n.EntitySubcategory)}) }
    if n.EventApplicationID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "eventApplicationID"}, Value: fmt.Sprintf("%v", *n.EventApplicationID)}) }
    if n.EventEntityID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "eventEntityID"}, Value: fmt.Sprintf("%v", *n.EventEntityID)}) }
    if n.EventNumber != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "eventNumber"}, Value: fmt.Sprintf("%v", *n.EventNumber)}) }
    if n.EventSiteID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "eventSiteID"}, Value: fmt.Sprintf("%v", *n.EventSiteID)}) }
    if n.Fired1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fired1"}, Value: fmt.Sprintf("%v", *n.Fired1)}) }
    if n.Fired2 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fired2"}, Value: fmt.Sprintf("%v", *n.Fired2)}) }
    if n.FiredTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "firedTime"}, Value: fmt.Sprintf("%v", *n.FiredTime)}) }
    if n.FireMissionIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fireMissionIndex"}, Value: fmt.Sprintf("%v", *n.FireMissionIndex)}) }
    if n.FiringRange != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "firingRange"}, Value: fmt.Sprintf("%v", *n.FiringRange)}) }
    if n.FiringRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "firingRate"}, Value: fmt.Sprintf("%v", *n.FiringRate)}) }
    if n.ForceID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "forceID"}, Value: fmt.Sprintf("%v", *n.ForceID)}) }
    if n.Fuse != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fuse"}, Value: fmt.Sprintf("%v", *n.Fuse)}) }
    if n.GeoCoords != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoCoords"}, Value: fmt.Sprintf("%v", *n.GeoCoords)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsCollided != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isCollided"}, Value: fmt.Sprintf("%v", *n.IsCollided)}) }
    if n.IsDetonated != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isDetonated"}, Value: fmt.Sprintf("%v", *n.IsDetonated)}) }
    if n.IsNetworkReader != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isNetworkReader"}, Value: fmt.Sprintf("%v", *n.IsNetworkReader)}) }
    if n.IsNetworkWriter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isNetworkWriter"}, Value: fmt.Sprintf("%v", *n.IsNetworkWriter)}) }
    if n.IsRtpHeaderHeard != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isRtpHeaderHeard"}, Value: fmt.Sprintf("%v", *n.IsRtpHeaderHeard)}) }
    if n.IsStandAlone != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isStandAlone"}, Value: fmt.Sprintf("%v", *n.IsStandAlone)}) }
    if n.LinearAcceleration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "linearAcceleration"}, Value: fmt.Sprintf("%v", *n.LinearAcceleration)}) }
    if n.LinearVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "linearVelocity"}, Value: fmt.Sprintf("%v", *n.LinearVelocity)}) }
    if n.Marking != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "marking"}, Value: fmt.Sprintf("%v", *n.Marking)}) }
    if n.MulticastRelayHost != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "multicastRelayHost"}, Value: fmt.Sprintf("%v", *n.MulticastRelayHost)}) }
    if n.MulticastRelayPort != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "multicastRelayPort"}, Value: fmt.Sprintf("%v", *n.MulticastRelayPort)}) }
    if n.MunitionApplicationID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "munitionApplicationID"}, Value: fmt.Sprintf("%v", *n.MunitionApplicationID)}) }
    if n.MunitionEndPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "munitionEndPoint"}, Value: fmt.Sprintf("%v", *n.MunitionEndPoint)}) }
    if n.MunitionEntityID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "munitionEntityID"}, Value: fmt.Sprintf("%v", *n.MunitionEntityID)}) }
    if n.MunitionQuantity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "munitionQuantity"}, Value: fmt.Sprintf("%v", *n.MunitionQuantity)}) }
    if n.MunitionSiteID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "munitionSiteID"}, Value: fmt.Sprintf("%v", *n.MunitionSiteID)}) }
    if n.MunitionStartPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "munitionStartPoint"}, Value: fmt.Sprintf("%v", *n.MunitionStartPoint)}) }
    if n.NetworkMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "networkMode"}, Value: fmt.Sprintf("%v", *n.NetworkMode)}) }
    if n.Port != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "port"}, Value: fmt.Sprintf("%v", *n.Port)}) }
    if n.ReadInterval != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "readInterval"}, Value: fmt.Sprintf("%v", *n.ReadInterval)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.RtpHeaderExpected != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rtpHeaderExpected"}, Value: fmt.Sprintf("%v", *n.RtpHeaderExpected)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.ScaleOrientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scaleOrientation"}, Value: fmt.Sprintf("%v", *n.ScaleOrientation)}) }
    if n.SetArticulationParameterValue0 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_articulationParameterValue0"}, Value: fmt.Sprintf("%v", *n.SetArticulationParameterValue0)}) }
    if n.SetArticulationParameterValue1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_articulationParameterValue1"}, Value: fmt.Sprintf("%v", *n.SetArticulationParameterValue1)}) }
    if n.SetArticulationParameterValue2 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_articulationParameterValue2"}, Value: fmt.Sprintf("%v", *n.SetArticulationParameterValue2)}) }
    if n.SetArticulationParameterValue3 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_articulationParameterValue3"}, Value: fmt.Sprintf("%v", *n.SetArticulationParameterValue3)}) }
    if n.SetArticulationParameterValue4 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_articulationParameterValue4"}, Value: fmt.Sprintf("%v", *n.SetArticulationParameterValue4)}) }
    if n.SetArticulationParameterValue5 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_articulationParameterValue5"}, Value: fmt.Sprintf("%v", *n.SetArticulationParameterValue5)}) }
    if n.SetArticulationParameterValue6 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_articulationParameterValue6"}, Value: fmt.Sprintf("%v", *n.SetArticulationParameterValue6)}) }
    if n.SetArticulationParameterValue7 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_articulationParameterValue7"}, Value: fmt.Sprintf("%v", *n.SetArticulationParameterValue7)}) }
    if n.SiteID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "siteID"}, Value: fmt.Sprintf("%v", *n.SiteID)}) }
    if n.Timestamp != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "timestamp"}, Value: fmt.Sprintf("%v", *n.Timestamp)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.Warhead != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "warhead"}, Value: fmt.Sprintf("%v", *n.Warhead)}) }
    if n.WriteInterval != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "writeInterval"}, Value: fmt.Sprintf("%v", *n.WriteInterval)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// ExplosionEmitter: ExplosionEmitter generates all particles from a specific point in space at the initial time enabled.
type ExplosionEmitter struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Mass *float32 `xml:"mass,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    Position *SFVec3f `xml:"position,attr,omitempty""`
    Speed *float32 `xml:"speed,attr,omitempty""`
    SurfaceArea *float32 `xml:"surfaceArea,attr,omitempty""`
    Variation *float32 `xml:"variation,attr,omitempty""`
}

func (n *ExplosionEmitter) GetNodeName() string { return "ExplosionEmitter" }
func (n *ExplosionEmitter) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#ExplosionEmitter" }
func (n *ExplosionEmitter) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ExplosionEmitter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Mass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mass"}, Value: fmt.Sprintf("%v", *n.Mass)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.Position != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position"}, Value: fmt.Sprintf("%v", *n.Position)}) }
    if n.Speed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speed"}, Value: fmt.Sprintf("%v", *n.Speed)}) }
    if n.SurfaceArea != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceArea"}, Value: fmt.Sprintf("%v", *n.SurfaceArea)}) }
    if n.Variation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "variation"}, Value: fmt.Sprintf("%v", *n.Variation)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Extrusion: Extrusion is a geometry node that sequentially stretches a 2D cross section along a 3D-spine path in the local coordinate system, creating an outer hull.
type Extrusion struct {
    CoreX3DNode
    BeginCap *bool `xml:"beginCap,attr,omitempty""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Convex *bool `xml:"convex,attr,omitempty""`
    CreaseAngle *float32 `xml:"creaseAngle,attr,omitempty""`
    CrossSection *MFVec2f `xml:"crossSection,attr,omitempty""`
    EndCap *bool `xml:"endCap,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Orientation *MFRotation `xml:"orientation,attr,omitempty""`
    Scale *MFVec2f `xml:"scale,attr,omitempty""`
    SetCrossSection *MFVec2f `xml:"set_crossSection,attr,omitempty""`
    SetOrientation *MFRotation `xml:"set_orientation,attr,omitempty""`
    SetScale *MFVec2f `xml:"set_scale,attr,omitempty""`
    SetSpine *MFVec3f `xml:"set_spine,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    Spine *MFVec3f `xml:"spine,attr,omitempty""`
}

func (n *Extrusion) GetNodeName() string { return "Extrusion" }
func (n *Extrusion) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Extrusion" }
func (n *Extrusion) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Extrusion) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BeginCap != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "beginCap"}, Value: fmt.Sprintf("%v", *n.BeginCap)}) }
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.Convex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "convex"}, Value: fmt.Sprintf("%v", *n.Convex)}) }
    if n.CreaseAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "creaseAngle"}, Value: fmt.Sprintf("%v", *n.CreaseAngle)}) }
    if n.CrossSection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "crossSection"}, Value: fmt.Sprintf("%v", *n.CrossSection)}) }
    if n.EndCap != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "endCap"}, Value: fmt.Sprintf("%v", *n.EndCap)}) }
    if n.Orientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orientation"}, Value: fmt.Sprintf("%v", *n.Orientation)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.SetCrossSection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_crossSection"}, Value: fmt.Sprintf("%v", *n.SetCrossSection)}) }
    if n.SetOrientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_orientation"}, Value: fmt.Sprintf("%v", *n.SetOrientation)}) }
    if n.SetScale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_scale"}, Value: fmt.Sprintf("%v", *n.SetScale)}) }
    if n.SetSpine != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_spine"}, Value: fmt.Sprintf("%v", *n.SetSpine)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.Spine != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "spine"}, Value: fmt.Sprintf("%v", *n.Spine)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// FillProperties: FillProperties indicates whether appearance is filled or hatched for associated geometry nodes inside the same Shape.
type FillProperties struct {
    CoreX3DNode
    Filled *bool `xml:"filled,attr,omitempty""`
    HatchColor *SFColor `xml:"hatchColor,attr,omitempty""`
    Hatched *bool `xml:"hatched,attr,omitempty""`
    HatchStyle *int32 `xml:"hatchStyle,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
}

func (n *FillProperties) GetNodeName() string { return "FillProperties" }
func (n *FillProperties) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#FillProperties" }
func (n *FillProperties) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *FillProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Filled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "filled"}, Value: fmt.Sprintf("%v", *n.Filled)}) }
    if n.HatchColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hatchColor"}, Value: fmt.Sprintf("%v", *n.HatchColor)}) }
    if n.Hatched != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hatched"}, Value: fmt.Sprintf("%v", *n.Hatched)}) }
    if n.HatchStyle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hatchStyle"}, Value: fmt.Sprintf("%v", *n.HatchStyle)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// FloatVertexAttribute: FloatVertexAttribute defines a set of per-vertex single-precision floating-point attributes.
type FloatVertexAttribute struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    NumComponents *int32 `xml:"numComponents,attr,omitempty""`
    Value []float32 `xml:"value,attr,omitempty""`
}

func (n *FloatVertexAttribute) GetNodeName() string { return "FloatVertexAttribute" }
func (n *FloatVertexAttribute) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#FloatVertexAttribute" }
func (n *FloatVertexAttribute) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *FloatVertexAttribute) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.NumComponents != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "numComponents"}, Value: fmt.Sprintf("%v", *n.NumComponents)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", n.Value)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Fog: Fog simulates atmospheric effects by blending distant objects with fog color.
type Fog struct {
    CoreX3DNode
    BindTime *float64 `xml:"bindTime,attr,omitempty""`
    Color *SFColor `xml:"color,attr,omitempty""`
    FogType *string `xml:"fogType,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsBound *bool `xml:"isBound,attr,omitempty""`
    SetBind *bool `xml:"set_bind,attr,omitempty""`
    VisibilityRange *float32 `xml:"visibilityRange,attr,omitempty""`
}

func (n *Fog) GetNodeName() string { return "Fog" }
func (n *Fog) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#Fog" }
func (n *Fog) Validate() error {
    if n.FogType != nil {
        switch *n.FogType {
        case FogTypeChoicesLINEAR, FogTypeChoicesEXPONENTIAL: // valid
        default: return fmt.Errorf("invalid value for field fogType: %s", *n.FogType)
        }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Fog) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BindTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bindTime"}, Value: fmt.Sprintf("%v", *n.BindTime)}) }
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.FogType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fogType"}, Value: fmt.Sprintf("%v", *n.FogType)}) }
    if n.IsBound != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isBound"}, Value: fmt.Sprintf("%v", *n.IsBound)}) }
    if n.SetBind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_bind"}, Value: fmt.Sprintf("%v", *n.SetBind)}) }
    if n.VisibilityRange != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visibilityRange"}, Value: fmt.Sprintf("%v", *n.VisibilityRange)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// FogCoordinate: FogCoordinate defines a set of explicit fog depths on a per-vertex basis, overriding Fog visibilityRange.
type FogCoordinate struct {
    CoreX3DNode
    Depth []float32 `xml:"depth,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
}

func (n *FogCoordinate) GetNodeName() string { return "FogCoordinate" }
func (n *FogCoordinate) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#FogCoordinate" }
func (n *FogCoordinate) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *FogCoordinate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Depth != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "depth"}, Value: fmt.Sprintf("%v", n.Depth)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// FontStyle: FontStyle is an X3DFontStyleNode that defines the size, family, justification, and other styles used by Text nodes.
type FontStyle struct {
    CoreX3DNode
    Family []string `xml:"family,attr,omitempty""`
    Horizontal *bool `xml:"horizontal,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Justify []string `xml:"justify,attr,omitempty""`
    Language *string `xml:"language,attr,omitempty""`
    LeftToRight *bool `xml:"leftToRight,attr,omitempty""`
    Size *float32 `xml:"size,attr,omitempty""`
    Spacing *float32 `xml:"spacing,attr,omitempty""`
    TopToBottom *bool `xml:"topToBottom,attr,omitempty""`
}

func (n *FontStyle) GetNodeName() string { return "FontStyle" }
func (n *FontStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/text.html#FontStyle" }
func (n *FontStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Justify != nil {
        for _, value := range n.Justify {
            switch value {
            case JustifyChoicesMIDDLE, JustifyChoicesMIDDLEBEGIN, JustifyChoicesMIDDLEEND, JustifyChoicesMIDDLEFIRST, JustifyChoicesMIDDLEMIDDLE, JustifyChoicesBEGIN, JustifyChoicesBEGINBEGIN, JustifyChoicesBEGINEND, JustifyChoicesBEGINFIRST, JustifyChoicesBEGINMIDDLE, JustifyChoicesEND, JustifyChoicesENDBEGIN, JustifyChoicesENDEND, JustifyChoicesENDFIRST, JustifyChoicesENDMIDDLE, JustifyChoicesFIRST, JustifyChoicesFIRSTBEGIN, JustifyChoicesFIRSTEND, JustifyChoicesFIRSTFIRST, JustifyChoicesFIRSTMIDDLE: // valid
            default: return fmt.Errorf("invalid value in field justify: %s", value)
            }
        }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Style != nil {
        switch *n.Style {
        case FontStyleChoicesPLAIN, FontStyleChoicesBOLD, FontStyleChoicesITALIC, FontStyleChoicesBOLDITALIC: // valid
        default: return fmt.Errorf("invalid value for field style: %s", *n.Style)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *FontStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.Family != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "family"}, Value: fmt.Sprintf("%v", n.Family)}) }
    if n.Horizontal != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "horizontal"}, Value: fmt.Sprintf("%v", *n.Horizontal)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Justify != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "justify"}, Value: fmt.Sprintf("%v", n.Justify)}) }
    if n.Language != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "language"}, Value: fmt.Sprintf("%v", *n.Language)}) }
    if n.LeftToRight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "leftToRight"}, Value: fmt.Sprintf("%v", *n.LeftToRight)}) }
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", *n.Size)}) }
    if n.Spacing != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "spacing"}, Value: fmt.Sprintf("%v", *n.Spacing)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.TopToBottom != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "topToBottom"}, Value: fmt.Sprintf("%v", *n.TopToBottom)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ForcePhysicsModel: ForcePhysicsModel applies a constant force value to the particles.
type ForcePhysicsModel struct {
    CoreX3DNode
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Force *SFVec3f `xml:"force,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
}

func (n *ForcePhysicsModel) GetNodeName() string { return "ForcePhysicsModel" }
func (n *ForcePhysicsModel) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#ForcePhysicsModel" }
func (n *ForcePhysicsModel) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ForcePhysicsModel) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Force != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "force"}, Value: fmt.Sprintf("%v", *n.Force)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Gain: The Gain node amplifies or deamplifies the input signal.
type Gain struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    TailTime *float64 `xml:"tailTime,attr,omitempty""`
}

func (n *Gain) GetNodeName() string { return "Gain" }
func (n *Gain) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Gain" }
func (n *Gain) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Gain) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.TailTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tailTime"}, Value: fmt.Sprintf("%v", *n.TailTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// GeneratedCubeMapTexture: GeneratedCubeMapTexture is a texture node that defines a cubic environment map that sources its data from internally generated images.
type GeneratedCubeMapTexture struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Size *int32 `xml:"size,attr,omitempty""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
    Update *string `xml:"update,attr,omitempty""`
}

func (n *GeneratedCubeMapTexture) GetNodeName() string { return "GeneratedCubeMapTexture" }
func (n *GeneratedCubeMapTexture) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalTexturing.html#GeneratedCubeMapTexture" }
func (n *GeneratedCubeMapTexture) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    if n.Update != nil {
        switch *n.Update {
        case GeneratedCubeMapTextureUpdateChoicesNONE, GeneratedCubeMapTextureUpdateChoicesNEXTFRAMEONLY, GeneratedCubeMapTextureUpdateChoicesALWAYS: // valid
        default: return fmt.Errorf("invalid value for field update: %s", *n.Update)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeneratedCubeMapTexture) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", *n.Size)}) }
    if n.Update != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "update"}, Value: fmt.Sprintf("%v", *n.Update)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// GeoCoordinate: GeoCoordinate builds geometry as a set of geographic 3D coordinates.
type GeoCoordinate struct {
    CoreX3DNode
    GeoOrigin X3DNode `xml:"geoOrigin,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Point *MFVec3d `xml:"point,attr,omitempty""`
}

func (n *GeoCoordinate) GetNodeName() string { return "GeoCoordinate" }
func (n *GeoCoordinate) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoCoordinate" }
func (n *GeoCoordinate) Validate() error {
    if n.GeoOrigin != nil {
        if err := n.GeoOrigin.Validate(); err != nil { return fmt.Errorf("validation error in GeoOrigin: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoCoordinate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.Point != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "point"}, Value: fmt.Sprintf("%v", *n.Point)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.GeoOrigin != nil {
        if err := e.EncodeElement(n.GeoOrigin, xml.StartElement{Name: xml.Name{Local: n.GeoOrigin.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// GeoElevationGrid: GeoElevationGrid is a geometry node defining a rectangular height field, with default values for a 1m by 1m square at height 0.
type GeoElevationGrid struct {
    CoreX3DNode
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    CreaseAngle *float64 `xml:"creaseAngle,attr,omitempty""`
    GeoGridOrigin *SFVec3d `xml:"geoGridOrigin,attr,omitempty""`
    GeoOrigin X3DNode `xml:"geoOrigin,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    Height []float64 `xml:"height,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    SetHeight []float64 `xml:"set_height,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    XDimension *int32 `xml:"xDimension,attr,omitempty""`
    XSpacing *float64 `xml:"xSpacing,attr,omitempty""`
    YScale *float32 `xml:"yScale,attr,omitempty""`
    ZDimension *int32 `xml:"zDimension,attr,omitempty""`
    ZSpacing *float64 `xml:"zSpacing,attr,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *GeoElevationGrid) GetNodeName() string { return "GeoElevationGrid" }
func (n *GeoElevationGrid) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoElevationGrid" }
func (n *GeoElevationGrid) Validate() error {
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.GeoOrigin != nil {
        if err := n.GeoOrigin.Validate(); err != nil { return fmt.Errorf("validation error in GeoOrigin: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoElevationGrid) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.CreaseAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "creaseAngle"}, Value: fmt.Sprintf("%v", *n.CreaseAngle)}) }
    if n.GeoGridOrigin != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoGridOrigin"}, Value: fmt.Sprintf("%v", *n.GeoGridOrigin)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.Height != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "height"}, Value: fmt.Sprintf("%v", n.Height)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.SetHeight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_height"}, Value: fmt.Sprintf("%v", n.SetHeight)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.XDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "xDimension"}, Value: fmt.Sprintf("%v", *n.XDimension)}) }
    if n.XSpacing != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "xSpacing"}, Value: fmt.Sprintf("%v", *n.XSpacing)}) }
    if n.YScale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "yScale"}, Value: fmt.Sprintf("%v", *n.YScale)}) }
    if n.ZDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "zDimension"}, Value: fmt.Sprintf("%v", *n.ZDimension)}) }
    if n.ZSpacing != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "zSpacing"}, Value: fmt.Sprintf("%v", *n.ZSpacing)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.GeoOrigin != nil {
        if err := e.EncodeElement(n.GeoOrigin, xml.StartElement{Name: xml.Name{Local: n.GeoOrigin.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// GeoLocation: GeoLocation positions a regular X3D model onto earth's surface.
type GeoLocation struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    GeoCoords *SFVec3d `xml:"geoCoords,attr,omitempty""`
    GeoOrigin X3DNode `xml:"geoOrigin,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *GeoLocation) GetNodeName() string { return "GeoLocation" }
func (n *GeoLocation) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoLocation" }
func (n *GeoLocation) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.GeoOrigin != nil {
        if err := n.GeoOrigin.Validate(); err != nil { return fmt.Errorf("validation error in GeoOrigin: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoLocation) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.GeoCoords != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoCoords"}, Value: fmt.Sprintf("%v", *n.GeoCoords)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.GeoOrigin != nil {
        if err := e.EncodeElement(n.GeoOrigin, xml.StartElement{Name: xml.Name{Local: n.GeoOrigin.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// GeoLOD: Note that MFNode rootNode field can contain multiple nodes and has accessType inputOutput. Meanwhile MFNode children field is outputOnly, unlike other X3DGroupingNode exemplars.
type GeoLOD struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Center *SFVec3d `xml:"center,attr,omitempty""`
    Child1Url []string `xml:"child1Url,attr,omitempty""`
    Child2Url []string `xml:"child2Url,attr,omitempty""`
    Child3Url []string `xml:"child3Url,attr,omitempty""`
    Child4Url []string `xml:"child4Url,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    GeoOrigin X3DNode `xml:"geoOrigin,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    LevelChanged *int32 `xml:"level_changed,attr,omitempty""`
    Range *float32 `xml:"range,attr,omitempty""`
    RootNode []X3DNode `xml:",any""`
    RootUrl []string `xml:"rootUrl,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *GeoLOD) GetNodeName() string { return "GeoLOD" }
func (n *GeoLOD) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoLOD" }
func (n *GeoLOD) Validate() error {
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.GeoOrigin != nil {
        if err := n.GeoOrigin.Validate(); err != nil { return fmt.Errorf("validation error in GeoOrigin: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RootNode != nil {
        for i, child := range n.RootNode { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RootNode[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoLOD) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Child1Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "child1Url"}, Value: fmt.Sprintf("%v", n.Child1Url)}) }
    if n.Child2Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "child2Url"}, Value: fmt.Sprintf("%v", n.Child2Url)}) }
    if n.Child3Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "child3Url"}, Value: fmt.Sprintf("%v", n.Child3Url)}) }
    if n.Child4Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "child4Url"}, Value: fmt.Sprintf("%v", n.Child4Url)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.LevelChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "level_changed"}, Value: fmt.Sprintf("%v", *n.LevelChanged)}) }
    if n.Range != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "range"}, Value: fmt.Sprintf("%v", *n.Range)}) }
    if n.RootUrl != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rootUrl"}, Value: fmt.Sprintf("%v", n.RootUrl)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.GeoOrigin != nil {
        if err := e.EncodeElement(n.GeoOrigin, xml.StartElement{Name: xml.Name{Local: n.GeoOrigin.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RootNode != nil {
        for _, child := range n.RootNode { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// GeoMetadata: GeoMetadata includes a generic subset of metadata about the geographic data.
type GeoMetadata struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Data []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    Summary []string `xml:"summary,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *GeoMetadata) GetNodeName() string { return "GeoMetadata" }
func (n *GeoMetadata) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoMetadata" }
func (n *GeoMetadata) Validate() error {
    if n.Data != nil {
        for i, child := range n.Data { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Data[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoMetadata) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Summary != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "summary"}, Value: fmt.Sprintf("%v", n.Summary)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Data != nil {
        for _, child := range n.Data { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// GeoOrigin: GeoOrigin is deprecated and discouraged (but nevertheless allowed) in X3D version 3.3. GeoOrigin is restored in X3D version 4.0 for special use on devices with limited floating-point resolution.
type GeoOrigin struct {
    CoreX3DNode
    GeoCoords *SFVec3d `xml:"geoCoords,attr,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RotateYUp *bool `xml:"rotateYUp,attr,omitempty""`
}

func (n *GeoOrigin) GetNodeName() string { return "GeoOrigin" }
func (n *GeoOrigin) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoOrigin" }
func (n *GeoOrigin) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoOrigin) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.GeoCoords != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoCoords"}, Value: fmt.Sprintf("%v", *n.GeoCoords)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.RotateYUp != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotateYUp"}, Value: fmt.Sprintf("%v", *n.RotateYUp)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// GeoPositionInterpolator: GeoPositionInterpolator animates objects within a geographic coordinate system.
type GeoPositionInterpolator struct {
    CoreX3DNode
    GeoOrigin X3DNode `xml:"geoOrigin,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    GeovalueChanged *SFVec3d `xml:"geovalue_changed,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFVec3d `xml:"keyValue,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFVec3f `xml:"value_changed,attr,omitempty""`
}

func (n *GeoPositionInterpolator) GetNodeName() string { return "GeoPositionInterpolator" }
func (n *GeoPositionInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoPositionInterpolator" }
func (n *GeoPositionInterpolator) Validate() error {
    if n.GeoOrigin != nil {
        if err := n.GeoOrigin.Validate(); err != nil { return fmt.Errorf("validation error in GeoOrigin: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoPositionInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.GeovalueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geovalue_changed"}, Value: fmt.Sprintf("%v", *n.GeovalueChanged)}) }
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.GeoOrigin != nil {
        if err := e.EncodeElement(n.GeoOrigin, xml.StartElement{Name: xml.Name{Local: n.GeoOrigin.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// GeoProximitySensor: GeoProximitySensor generates events when the viewer enters, exits and moves within a region of space (defined by a box).
type GeoProximitySensor struct {
    CoreX3DNode
    Center *SFVec3d `xml:"center,attr,omitempty""`
    CenterOfRotationChanged *SFVec3f `xml:"centerOfRotation_changed,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EnterTime *float64 `xml:"enterTime,attr,omitempty""`
    ExitTime *float64 `xml:"exitTime,attr,omitempty""`
    GeoCenter *SFVec3d `xml:"geoCenter,attr,omitempty""`
    GeoCoordChanged *SFVec3d `xml:"geoCoord_changed,attr,omitempty""`
    GeoOrigin X3DNode `xml:"geoOrigin,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    OrientationChanged *SFRotation `xml:"orientation_changed,attr,omitempty""`
    PositionChanged *SFVec3f `xml:"position_changed,attr,omitempty""`
    Size *SFVec3f `xml:"size,attr,omitempty""`
}

func (n *GeoProximitySensor) GetNodeName() string { return "GeoProximitySensor" }
func (n *GeoProximitySensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoProximitySensor" }
func (n *GeoProximitySensor) Validate() error {
    if n.GeoOrigin != nil {
        if err := n.GeoOrigin.Validate(); err != nil { return fmt.Errorf("validation error in GeoOrigin: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoProximitySensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.CenterOfRotationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "centerOfRotation_changed"}, Value: fmt.Sprintf("%v", *n.CenterOfRotationChanged)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EnterTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enterTime"}, Value: fmt.Sprintf("%v", *n.EnterTime)}) }
    if n.ExitTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "exitTime"}, Value: fmt.Sprintf("%v", *n.ExitTime)}) }
    if n.GeoCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoCenter"}, Value: fmt.Sprintf("%v", *n.GeoCenter)}) }
    if n.GeoCoordChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoCoord_changed"}, Value: fmt.Sprintf("%v", *n.GeoCoordChanged)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.OrientationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orientation_changed"}, Value: fmt.Sprintf("%v", *n.OrientationChanged)}) }
    if n.PositionChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position_changed"}, Value: fmt.Sprintf("%v", *n.PositionChanged)}) }
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", *n.Size)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.GeoOrigin != nil {
        if err := e.EncodeElement(n.GeoOrigin, xml.StartElement{Name: xml.Name{Local: n.GeoOrigin.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// GeoTouchSensor: GeoTouchSensor returns geographic coordinates for the object being selected.
type GeoTouchSensor struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    GeoOrigin X3DNode `xml:"geoOrigin,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    HitGeoCoordChanged *SFVec3d `xml:"hitGeoCoord_changed,attr,omitempty""`
    HitNormalChanged *SFVec3f `xml:"hitNormal_changed,attr,omitempty""`
    HitPointChanged *SFVec3f `xml:"hitPoint_changed,attr,omitempty""`
    HitTexCoordChanged *SFVec2f `xml:"hitTexCoord_changed,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsOver *bool `xml:"isOver,attr,omitempty""`
    TouchTime *float64 `xml:"touchTime,attr,omitempty""`
}

func (n *GeoTouchSensor) GetNodeName() string { return "GeoTouchSensor" }
func (n *GeoTouchSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoTouchSensor" }
func (n *GeoTouchSensor) Validate() error {
    if n.GeoOrigin != nil {
        if err := n.GeoOrigin.Validate(); err != nil { return fmt.Errorf("validation error in GeoOrigin: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoTouchSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.HitGeoCoordChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hitGeoCoord_changed"}, Value: fmt.Sprintf("%v", *n.HitGeoCoordChanged)}) }
    if n.HitNormalChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hitNormal_changed"}, Value: fmt.Sprintf("%v", *n.HitNormalChanged)}) }
    if n.HitPointChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hitPoint_changed"}, Value: fmt.Sprintf("%v", *n.HitPointChanged)}) }
    if n.HitTexCoordChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hitTexCoord_changed"}, Value: fmt.Sprintf("%v", *n.HitTexCoordChanged)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsOver != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isOver"}, Value: fmt.Sprintf("%v", *n.IsOver)}) }
    if n.TouchTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "touchTime"}, Value: fmt.Sprintf("%v", *n.TouchTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.GeoOrigin != nil {
        if err := e.EncodeElement(n.GeoOrigin, xml.StartElement{Name: xml.Name{Local: n.GeoOrigin.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// GeoTransform: GeoTransform is a Grouping node that can contain most nodes.
type GeoTransform struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    GeoCenter *SFVec3d `xml:"geoCenter,attr,omitempty""`
    GeoOrigin X3DNode `xml:"geoOrigin,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    Scale *SFVec3f `xml:"scale,attr,omitempty""`
    ScaleOrientation *SFRotation `xml:"scaleOrientation,attr,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *GeoTransform) GetNodeName() string { return "GeoTransform" }
func (n *GeoTransform) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoTransform" }
func (n *GeoTransform) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.GeoOrigin != nil {
        if err := n.GeoOrigin.Validate(); err != nil { return fmt.Errorf("validation error in GeoOrigin: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoTransform) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.GeoCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoCenter"}, Value: fmt.Sprintf("%v", *n.GeoCenter)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.ScaleOrientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scaleOrientation"}, Value: fmt.Sprintf("%v", *n.ScaleOrientation)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.GeoOrigin != nil {
        if err := e.EncodeElement(n.GeoOrigin, xml.StartElement{Name: xml.Name{Local: n.GeoOrigin.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// GeoViewpoint: GeoViewpoint specifies viewpoints using geographic coordinates.
type GeoViewpoint struct {
    CoreX3DNode
    BindTime *float64 `xml:"bindTime,attr,omitempty""`
    CenterOfRotation *SFVec3d `xml:"centerOfRotation,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    FarDistance *float32 `xml:"farDistance,attr,omitempty""`
    FieldOfView *float32 `xml:"fieldOfView,attr,omitempty""`
    GeoOrigin X3DNode `xml:"geoOrigin,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsBound *bool `xml:"isBound,attr,omitempty""`
    Jump *bool `xml:"jump,attr,omitempty""`
    NavigationInfo X3DNode `xml:"navigationInfo,omitempty""`
    NearDistance *float32 `xml:"nearDistance,attr,omitempty""`
    Orientation *SFRotation `xml:"orientation,attr,omitempty""`
    Position *SFVec3d `xml:"position,attr,omitempty""`
    RetainUserOffsets *bool `xml:"retainUserOffsets,attr,omitempty""`
    SetBind *bool `xml:"set_bind,attr,omitempty""`
    SpeedFactor *float32 `xml:"speedFactor,attr,omitempty""`
    ViewAll *bool `xml:"viewAll,attr,omitempty""`
}

func (n *GeoViewpoint) GetNodeName() string { return "GeoViewpoint" }
func (n *GeoViewpoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geospatial.html#GeoViewpoint" }
func (n *GeoViewpoint) Validate() error {
    if n.GeoOrigin != nil {
        if err := n.GeoOrigin.Validate(); err != nil { return fmt.Errorf("validation error in GeoOrigin: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.NavigationInfo != nil {
        if err := n.NavigationInfo.Validate(); err != nil { return fmt.Errorf("validation error in NavigationInfo: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *GeoViewpoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BindTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bindTime"}, Value: fmt.Sprintf("%v", *n.BindTime)}) }
    if n.CenterOfRotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "centerOfRotation"}, Value: fmt.Sprintf("%v", *n.CenterOfRotation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.FarDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "farDistance"}, Value: fmt.Sprintf("%v", *n.FarDistance)}) }
    if n.FieldOfView != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fieldOfView"}, Value: fmt.Sprintf("%v", *n.FieldOfView)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.IsBound != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isBound"}, Value: fmt.Sprintf("%v", *n.IsBound)}) }
    if n.Jump != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "jump"}, Value: fmt.Sprintf("%v", *n.Jump)}) }
    if n.NearDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "nearDistance"}, Value: fmt.Sprintf("%v", *n.NearDistance)}) }
    if n.Orientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orientation"}, Value: fmt.Sprintf("%v", *n.Orientation)}) }
    if n.Position != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position"}, Value: fmt.Sprintf("%v", *n.Position)}) }
    if n.RetainUserOffsets != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "retainUserOffsets"}, Value: fmt.Sprintf("%v", *n.RetainUserOffsets)}) }
    if n.SetBind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_bind"}, Value: fmt.Sprintf("%v", *n.SetBind)}) }
    if n.SpeedFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speedFactor"}, Value: fmt.Sprintf("%v", *n.SpeedFactor)}) }
    if n.ViewAll != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "viewAll"}, Value: fmt.Sprintf("%v", *n.ViewAll)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.GeoOrigin != nil {
        if err := e.EncodeElement(n.GeoOrigin, xml.StartElement{Name: xml.Name{Local: n.GeoOrigin.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.NavigationInfo != nil {
        if err := e.EncodeElement(n.NavigationInfo, xml.StartElement{Name: xml.Name{Local: n.NavigationInfo.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Group: Group is a Grouping node that can contain most nodes.
type Group struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *Group) GetNodeName() string { return "Group" }
func (n *Group) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#Group" }
func (n *Group) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Group) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// HAnimDisplacer: HAnimDisplacer nodes alter the shape of coordinate-based geometry within parent HAnimJoint or HAnimSegment nodes.
type HAnimDisplacer struct {
    CoreX3DNode
    CoordIndex []int32 `xml:"coordIndex,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Displacements *MFVec3f `xml:"displacements,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Weight *float32 `xml:"weight,attr,omitempty""`
}

func (n *HAnimDisplacer) GetNodeName() string { return "HAnimDisplacer" }
func (n *HAnimDisplacer) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimDisplacer" }
func (n *HAnimDisplacer) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *HAnimDisplacer) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.CoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "coordIndex"}, Value: fmt.Sprintf("%v", n.CoordIndex)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Displacements != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "displacements"}, Value: fmt.Sprintf("%v", *n.Displacements)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Weight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weight"}, Value: fmt.Sprintf("%v", *n.Weight)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// HAnimHumanoid: The HAnimHumanoid node is used to: (a) store references to the joints, segments, sites, skeleton, optional skin, and fixed viewpoints, (b) serve as a container for the entire humanoid, (c) provide a convenient way of moving the humanoid through its environment, and (d) store human-readable metadata such as name, version, author, copyright, age, gender and other information.
type HAnimHumanoid struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Info []string `xml:"info,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    JointBindingPositions *MFVec3f `xml:"jointBindingPositions,attr,omitempty""`
    JointBindingRotations *MFRotation `xml:"jointBindingRotations,attr,omitempty""`
    JointBindingScales *MFVec3f `xml:"jointBindingScales,attr,omitempty""`
    Joints []X3DNode `xml:",any""`
    Loa *int32 `xml:"loa,attr,omitempty""`
    Motions []X3DNode `xml:",any""`
    MotionsEnabled []bool `xml:"motionsEnabled,attr,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    Scale *SFVec3f `xml:"scale,attr,omitempty""`
    ScaleOrientation *SFRotation `xml:"scaleOrientation,attr,omitempty""`
    Segments []X3DNode `xml:",any""`
    Sites []X3DNode `xml:",any""`
    SkeletalConfiguration *string `xml:"skeletalConfiguration,attr,omitempty""`
    Skeleton []X3DNode `xml:",any""`
    Skin []X3DNode `xml:",any""`
    SkinBindingCoords X3DNode `xml:"skinBindingCoords,omitempty""`
    SkinBindingNormals X3DNode `xml:"skinBindingNormals,omitempty""`
    SkinCoord X3DNode `xml:"skinCoord,omitempty""`
    SkinNormal X3DNode `xml:"skinNormal,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
    Version *string `xml:"version,attr,omitempty""`
    Viewpoints []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *HAnimHumanoid) GetNodeName() string { return "HAnimHumanoid" }
func (n *HAnimHumanoid) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimHumanoid" }
func (n *HAnimHumanoid) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Joints != nil {
        for i, child := range n.Joints { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Joints[%d]: %w", i, err) } }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Motions != nil {
        for i, child := range n.Motions { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Motions[%d]: %w", i, err) } }
    }
    if n.Segments != nil {
        for i, child := range n.Segments { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Segments[%d]: %w", i, err) } }
    }
    if n.Sites != nil {
        for i, child := range n.Sites { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Sites[%d]: %w", i, err) } }
    }
    if n.Skeleton != nil {
        for i, child := range n.Skeleton { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Skeleton[%d]: %w", i, err) } }
    }
    if n.Skin != nil {
        for i, child := range n.Skin { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Skin[%d]: %w", i, err) } }
    }
    if n.SkinBindingCoords != nil {
        if err := n.SkinBindingCoords.Validate(); err != nil { return fmt.Errorf("validation error in SkinBindingCoords: %w", err) }
    }
    if n.SkinBindingNormals != nil {
        if err := n.SkinBindingNormals.Validate(); err != nil { return fmt.Errorf("validation error in SkinBindingNormals: %w", err) }
    }
    if n.SkinCoord != nil {
        if err := n.SkinCoord.Validate(); err != nil { return fmt.Errorf("validation error in SkinCoord: %w", err) }
    }
    if n.SkinNormal != nil {
        if err := n.SkinNormal.Validate(); err != nil { return fmt.Errorf("validation error in SkinNormal: %w", err) }
    }
    if n.Version != nil {
        switch *n.Version {
        case HanimVersionChoices20: // valid
        default: return fmt.Errorf("invalid value for field version: %s", *n.Version)
        }
    }
    if n.Viewpoints != nil {
        for i, child := range n.Viewpoints { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Viewpoints[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *HAnimHumanoid) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Info != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "info"}, Value: fmt.Sprintf("%v", n.Info)}) }
    if n.JointBindingPositions != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "jointBindingPositions"}, Value: fmt.Sprintf("%v", *n.JointBindingPositions)}) }
    if n.JointBindingRotations != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "jointBindingRotations"}, Value: fmt.Sprintf("%v", *n.JointBindingRotations)}) }
    if n.JointBindingScales != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "jointBindingScales"}, Value: fmt.Sprintf("%v", *n.JointBindingScales)}) }
    if n.Loa != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loa"}, Value: fmt.Sprintf("%v", *n.Loa)}) }
    if n.MotionsEnabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motionsEnabled"}, Value: fmt.Sprintf("%v", n.MotionsEnabled)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.ScaleOrientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scaleOrientation"}, Value: fmt.Sprintf("%v", *n.ScaleOrientation)}) }
    if n.SkeletalConfiguration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "skeletalConfiguration"}, Value: fmt.Sprintf("%v", *n.SkeletalConfiguration)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.Version != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "version"}, Value: fmt.Sprintf("%v", *n.Version)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Joints != nil {
        for _, child := range n.Joints { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Motions != nil {
        for _, child := range n.Motions { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Segments != nil {
        for _, child := range n.Segments { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Sites != nil {
        for _, child := range n.Sites { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Skeleton != nil {
        for _, child := range n.Skeleton { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Skin != nil {
        for _, child := range n.Skin { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.SkinBindingCoords != nil {
        if err := e.EncodeElement(n.SkinBindingCoords, xml.StartElement{Name: xml.Name{Local: n.SkinBindingCoords.GetNodeName()}}); err != nil { return err }
    }
    if n.SkinBindingNormals != nil {
        if err := e.EncodeElement(n.SkinBindingNormals, xml.StartElement{Name: xml.Name{Local: n.SkinBindingNormals.GetNodeName()}}); err != nil { return err }
    }
    if n.SkinCoord != nil {
        if err := e.EncodeElement(n.SkinCoord, xml.StartElement{Name: xml.Name{Local: n.SkinCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.SkinNormal != nil {
        if err := e.EncodeElement(n.SkinNormal, xml.StartElement{Name: xml.Name{Local: n.SkinNormal.GetNodeName()}}); err != nil { return err }
    }
    if n.Viewpoints != nil {
        for _, child := range n.Viewpoints { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// HAnimJoint: HAnimJoint node can represent each joint in a body.
type HAnimJoint struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Displacers []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    LimitOrientation *SFRotation `xml:"limitOrientation,attr,omitempty""`
    Llimit []float32 `xml:"llimit,attr,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    Scale *SFVec3f `xml:"scale,attr,omitempty""`
    ScaleOrientation *SFRotation `xml:"scaleOrientation,attr,omitempty""`
    SkinCoordIndex []int32 `xml:"skinCoordIndex,attr,omitempty""`
    SkinCoordWeight []float32 `xml:"skinCoordWeight,attr,omitempty""`
    Stiffness []float32 `xml:"stiffness,attr,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
    Ulimit []float32 `xml:"ulimit,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *HAnimJoint) GetNodeName() string { return "HAnimJoint" }
func (n *HAnimJoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimJoint" }
func (n *HAnimJoint) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.Displacers != nil {
        for i, child := range n.Displacers { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Displacers[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *HAnimJoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.LimitOrientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "limitOrientation"}, Value: fmt.Sprintf("%v", *n.LimitOrientation)}) }
    if n.Llimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "llimit"}, Value: fmt.Sprintf("%v", n.Llimit)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.ScaleOrientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scaleOrientation"}, Value: fmt.Sprintf("%v", *n.ScaleOrientation)}) }
    if n.SkinCoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "skinCoordIndex"}, Value: fmt.Sprintf("%v", n.SkinCoordIndex)}) }
    if n.SkinCoordWeight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "skinCoordWeight"}, Value: fmt.Sprintf("%v", n.SkinCoordWeight)}) }
    if n.Stiffness != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stiffness"}, Value: fmt.Sprintf("%v", n.Stiffness)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.Ulimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ulimit"}, Value: fmt.Sprintf("%v", n.Ulimit)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Displacers != nil {
        for _, child := range n.Displacers { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// HAnimMotion: An HAnimMotion node supports discrete frame-by-frame playback for HAnim motion data animation.
type HAnimMotion struct {
    CoreX3DNode
    Channels *string `xml:"channels,attr,omitempty""`
    ChannelsEnabled []bool `xml:"channelsEnabled,attr,omitempty""`
    CycleTime *float64 `xml:"cycleTime,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EndFrame *int32 `xml:"endFrame,attr,omitempty""`
    FrameCount *int32 `xml:"frameCount,attr,omitempty""`
    FrameDuration *float64 `xml:"frameDuration,attr,omitempty""`
    FrameIncrement *int32 `xml:"frameIncrement,attr,omitempty""`
    FrameIndex *int32 `xml:"frameIndex,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Joints *string `xml:"joints,attr,omitempty""`
    Loa *int32 `xml:"loa,attr,omitempty""`
    Loop *bool `xml:"loop,attr,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Next *bool `xml:"next,attr,omitempty""`
    Previous *bool `xml:"previous,attr,omitempty""`
    StartFrame *int32 `xml:"startFrame,attr,omitempty""`
    Values []float32 `xml:"values,attr,omitempty""`
}

func (n *HAnimMotion) GetNodeName() string { return "HAnimMotion" }
func (n *HAnimMotion) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimMotion" }
func (n *HAnimMotion) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *HAnimMotion) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Channels != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channels"}, Value: fmt.Sprintf("%v", *n.Channels)}) }
    if n.ChannelsEnabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelsEnabled"}, Value: fmt.Sprintf("%v", n.ChannelsEnabled)}) }
    if n.CycleTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "cycleTime"}, Value: fmt.Sprintf("%v", *n.CycleTime)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EndFrame != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "endFrame"}, Value: fmt.Sprintf("%v", *n.EndFrame)}) }
    if n.FrameCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frameCount"}, Value: fmt.Sprintf("%v", *n.FrameCount)}) }
    if n.FrameDuration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frameDuration"}, Value: fmt.Sprintf("%v", *n.FrameDuration)}) }
    if n.FrameIncrement != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frameIncrement"}, Value: fmt.Sprintf("%v", *n.FrameIncrement)}) }
    if n.FrameIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frameIndex"}, Value: fmt.Sprintf("%v", *n.FrameIndex)}) }
    if n.Joints != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "joints"}, Value: fmt.Sprintf("%v", *n.Joints)}) }
    if n.Loa != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loa"}, Value: fmt.Sprintf("%v", *n.Loa)}) }
    if n.Loop != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loop"}, Value: fmt.Sprintf("%v", *n.Loop)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Next != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "next"}, Value: fmt.Sprintf("%v", *n.Next)}) }
    if n.Previous != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "previous"}, Value: fmt.Sprintf("%v", *n.Previous)}) }
    if n.StartFrame != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startFrame"}, Value: fmt.Sprintf("%v", *n.StartFrame)}) }
    if n.Values != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "values"}, Value: fmt.Sprintf("%v", n.Values)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// HAnimSegment: HAnimSegment node contains Shape geometry for each body segment, providing a visual representation of the skeleton segment.
type HAnimSegment struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    CenterOfMass *SFVec3f `xml:"centerOfMass,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Coord X3DNode `xml:"coord,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Displacers []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Mass *float32 `xml:"mass,attr,omitempty""`
    MomentsOfInertia []float32 `xml:"momentsOfInertia,attr,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *HAnimSegment) GetNodeName() string { return "HAnimSegment" }
func (n *HAnimSegment) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimSegment" }
func (n *HAnimSegment) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.Displacers != nil {
        for i, child := range n.Displacers { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Displacers[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *HAnimSegment) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.CenterOfMass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "centerOfMass"}, Value: fmt.Sprintf("%v", *n.CenterOfMass)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Mass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mass"}, Value: fmt.Sprintf("%v", *n.Mass)}) }
    if n.MomentsOfInertia != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "momentsOfInertia"}, Value: fmt.Sprintf("%v", n.MomentsOfInertia)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.Displacers != nil {
        for _, child := range n.Displacers { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// HAnimSite: An HAnimSite node serves three purposes: (a) define an "end effector" location which can be used by an inverse kinematics system, (b) define an attachment point for accessories such as jewelry and clothing, and (c) define a location for a Viewpoint virtual camera in the reference frame of an HAnimSegment (such as a view "through the eyes" of the humanoid for use in multi-user worlds).
type HAnimSite struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    Scale *SFVec3f `xml:"scale,attr,omitempty""`
    ScaleOrientation *SFRotation `xml:"scaleOrientation,attr,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *HAnimSite) GetNodeName() string { return "HAnimSite" }
func (n *HAnimSite) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/hanim.html#HAnimSite" }
func (n *HAnimSite) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *HAnimSite) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.ScaleOrientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scaleOrientation"}, Value: fmt.Sprintf("%v", *n.ScaleOrientation)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// ImageCubeMapTexture: ImageCubeMapTexture is a texture node that defines a cubic environment map source as a single file format that contains multiple images, one for each side.
type ImageCubeMapTexture struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *ImageCubeMapTexture) GetNodeName() string { return "ImageCubeMapTexture" }
func (n *ImageCubeMapTexture) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalTexturing.html#ImageCubeMapTexture" }
func (n *ImageCubeMapTexture) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ImageCubeMapTexture) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ImageTexture: ImageTexture maps a 2D-image file onto a geometric shape.
type ImageTexture struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    RepeatS *bool `xml:"repeatS,attr,omitempty""`
    RepeatT *bool `xml:"repeatT,attr,omitempty""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
    ColorSpaceConversion *bool `xml:"colorSpaceConversion,attr,omitempty""`
}

func (n *ImageTexture) GetNodeName() string { return "ImageTexture" }
func (n *ImageTexture) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#ImageTexture" }
func (n *ImageTexture) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ImageTexture) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.RepeatS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatS"}, Value: fmt.Sprintf("%v", *n.RepeatS)}) }
    if n.RepeatT != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatT"}, Value: fmt.Sprintf("%v", *n.RepeatT)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.ColorSpaceConversion != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorSpaceConversion"}, Value: fmt.Sprintf("%v", *n.ColorSpaceConversion)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ImageTexture3D: ImageTexture3D defines a 3D image-based texture map by specifying a single image file that contains complete 3D data.
type ImageTexture3D struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    RepeatR *bool `xml:"repeatR,attr,omitempty""`
    RepeatS *bool `xml:"repeatS,attr,omitempty""`
    RepeatT *bool `xml:"repeatT,attr,omitempty""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *ImageTexture3D) GetNodeName() string { return "ImageTexture3D" }
func (n *ImageTexture3D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#ImageTexture3D" }
func (n *ImageTexture3D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ImageTexture3D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.RepeatR != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatR"}, Value: fmt.Sprintf("%v", *n.RepeatR)}) }
    if n.RepeatS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatS"}, Value: fmt.Sprintf("%v", *n.RepeatS)}) }
    if n.RepeatT != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatT"}, Value: fmt.Sprintf("%v", *n.RepeatT)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IndexedFaceSet: IndexedFaceSet defines polygons using index lists corresponding to vertex coordinates.
type IndexedFaceSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorIndex []int32 `xml:"colorIndex,attr,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Convex *bool `xml:"convex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    CoordIndex []int32 `xml:"coordIndex,attr,omitempty""`
    CreaseAngle *float32 `xml:"creaseAngle,attr,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalIndex []int32 `xml:"normalIndex,attr,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    SetColorIndex []int32 `xml:"set_colorIndex,attr,omitempty""`
    SetCoordIndex []int32 `xml:"set_coordIndex,attr,omitempty""`
    SetNormalIndex []int32 `xml:"set_normalIndex,attr,omitempty""`
    SetTexCoordIndex []int32 `xml:"set_texCoordIndex,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    TexCoordIndex []int32 `xml:"texCoordIndex,attr,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *IndexedFaceSet) GetNodeName() string { return "IndexedFaceSet" }
func (n *IndexedFaceSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#IndexedFaceSet" }
func (n *IndexedFaceSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IndexedFaceSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorIndex"}, Value: fmt.Sprintf("%v", n.ColorIndex)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.Convex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "convex"}, Value: fmt.Sprintf("%v", *n.Convex)}) }
    if n.CoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "coordIndex"}, Value: fmt.Sprintf("%v", n.CoordIndex)}) }
    if n.CreaseAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "creaseAngle"}, Value: fmt.Sprintf("%v", *n.CreaseAngle)}) }
    if n.NormalIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalIndex"}, Value: fmt.Sprintf("%v", n.NormalIndex)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.SetColorIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_colorIndex"}, Value: fmt.Sprintf("%v", n.SetColorIndex)}) }
    if n.SetCoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_coordIndex"}, Value: fmt.Sprintf("%v", n.SetCoordIndex)}) }
    if n.SetNormalIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_normalIndex"}, Value: fmt.Sprintf("%v", n.SetNormalIndex)}) }
    if n.SetTexCoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_texCoordIndex"}, Value: fmt.Sprintf("%v", n.SetTexCoordIndex)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.TexCoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "texCoordIndex"}, Value: fmt.Sprintf("%v", n.TexCoordIndex)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IndexedLineSet: IndexedLineSet defines polyline segments using index lists corresponding to vertex coordinates.
type IndexedLineSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Color X3DNode `xml:"color,omitempty""`
    ColorIndex []int32 `xml:"colorIndex,attr,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    CoordIndex []int32 `xml:"coordIndex,attr,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    SetColorIndex []int32 `xml:"set_colorIndex,attr,omitempty""`
    SetCoordIndex []int32 `xml:"set_coordIndex,attr,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *IndexedLineSet) GetNodeName() string { return "IndexedLineSet" }
func (n *IndexedLineSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#IndexedLineSet" }
func (n *IndexedLineSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IndexedLineSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ColorIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorIndex"}, Value: fmt.Sprintf("%v", n.ColorIndex)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.CoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "coordIndex"}, Value: fmt.Sprintf("%v", n.CoordIndex)}) }
    if n.SetColorIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_colorIndex"}, Value: fmt.Sprintf("%v", n.SetColorIndex)}) }
    if n.SetCoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_coordIndex"}, Value: fmt.Sprintf("%v", n.SetCoordIndex)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IndexedQuadSet: IndexedQuadSet is a geometry node that defines quadrilaterals.
type IndexedQuadSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    Index []int32 `xml:"index,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    SetIndex []int32 `xml:"set_index,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *IndexedQuadSet) GetNodeName() string { return "IndexedQuadSet" }
func (n *IndexedQuadSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#IndexedQuadSet" }
func (n *IndexedQuadSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IndexedQuadSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.Index != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "index"}, Value: fmt.Sprintf("%v", n.Index)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.SetIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_index"}, Value: fmt.Sprintf("%v", n.SetIndex)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IndexedTriangleFanSet: IndexedTriangleFanSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
type IndexedTriangleFanSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    Index []int32 `xml:"index,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    SetIndex []int32 `xml:"set_index,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *IndexedTriangleFanSet) GetNodeName() string { return "IndexedTriangleFanSet" }
func (n *IndexedTriangleFanSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#IndexedTriangleFanSet" }
func (n *IndexedTriangleFanSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IndexedTriangleFanSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.Index != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "index"}, Value: fmt.Sprintf("%v", n.Index)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.SetIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_index"}, Value: fmt.Sprintf("%v", n.SetIndex)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IndexedTriangleSet: IndexedTriangleSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
type IndexedTriangleSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    Index []int32 `xml:"index,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    SetIndex []int32 `xml:"set_index,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *IndexedTriangleSet) GetNodeName() string { return "IndexedTriangleSet" }
func (n *IndexedTriangleSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#IndexedTriangleSet" }
func (n *IndexedTriangleSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IndexedTriangleSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.Index != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "index"}, Value: fmt.Sprintf("%v", n.Index)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.SetIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_index"}, Value: fmt.Sprintf("%v", n.SetIndex)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IndexedTriangleStripSet: IndexedTriangleStripSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
type IndexedTriangleStripSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    Index []int32 `xml:"index,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    SetIndex []int32 `xml:"set_index,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *IndexedTriangleStripSet) GetNodeName() string { return "IndexedTriangleStripSet" }
func (n *IndexedTriangleStripSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#IndexedTriangleStripSet" }
func (n *IndexedTriangleStripSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IndexedTriangleStripSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.Index != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "index"}, Value: fmt.Sprintf("%v", n.Index)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.SetIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_index"}, Value: fmt.Sprintf("%v", n.SetIndex)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Inline: Inline can load another X3D or VRML model into the current scene via url.
type Inline struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Global *bool `xml:"global,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *Inline) GetNodeName() string { return "Inline" }
func (n *Inline) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/networking.html#Inline" }
func (n *Inline) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Inline) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Global != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "global"}, Value: fmt.Sprintf("%v", *n.Global)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IntegerSequencer: IntegerSequencer generates periodic discrete integer values.
type IntegerSequencer struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue []int32 `xml:"keyValue,attr,omitempty""`
    Next *bool `xml:"next,attr,omitempty""`
    Previous *bool `xml:"previous,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *int32 `xml:"value_changed,attr,omitempty""`
}

func (n *IntegerSequencer) GetNodeName() string { return "IntegerSequencer" }
func (n *IntegerSequencer) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#IntegerSequencer" }
func (n *IntegerSequencer) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IntegerSequencer) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", n.KeyValue)}) }
    if n.Next != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "next"}, Value: fmt.Sprintf("%v", *n.Next)}) }
    if n.Previous != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "previous"}, Value: fmt.Sprintf("%v", *n.Previous)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IntegerTrigger: IntegerTrigger converts set_boolean true input events to an integer value (for example, useful when animating whichChoice in a Switch node).
type IntegerTrigger struct {
    CoreX3DNode
    IntegerKey *int32 `xml:"integerKey,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    SetBoolean *bool `xml:"set_boolean,attr,omitempty""`
    TriggerValue *int32 `xml:"triggerValue,attr,omitempty""`
}

func (n *IntegerTrigger) GetNodeName() string { return "IntegerTrigger" }
func (n *IntegerTrigger) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#IntegerTrigger" }
func (n *IntegerTrigger) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IntegerTrigger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.IntegerKey != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "integerKey"}, Value: fmt.Sprintf("%v", *n.IntegerKey)}) }
    if n.SetBoolean != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_boolean"}, Value: fmt.Sprintf("%v", *n.SetBoolean)}) }
    if n.TriggerValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "triggerValue"}, Value: fmt.Sprintf("%v", *n.TriggerValue)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IsoSurfaceVolumeData: IsoSurfaceVolumeData displays one or more surfaces extracted from a voxel dataset.
type IsoSurfaceVolumeData struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    ContourStepSize *float32 `xml:"contourStepSize,attr,omitempty""`
    Dimensions *SFVec3f `xml:"dimensions,attr,omitempty""`
    Gradients X3DNode `xml:"gradients,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RenderStyle []X3DNode `xml:",any""`
    SurfaceTolerance *float32 `xml:"surfaceTolerance,attr,omitempty""`
    SurfaceValues []float32 `xml:"surfaceValues,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    Voxels X3DNode `xml:"voxels,omitempty""`
}

func (n *IsoSurfaceVolumeData) GetNodeName() string { return "IsoSurfaceVolumeData" }
func (n *IsoSurfaceVolumeData) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#IsoSurfaceVolumeData" }
func (n *IsoSurfaceVolumeData) Validate() error {
    if n.Gradients != nil {
        if err := n.Gradients.Validate(); err != nil { return fmt.Errorf("validation error in Gradients: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RenderStyle != nil {
        for i, child := range n.RenderStyle { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RenderStyle[%d]: %w", i, err) } }
    }
    if n.Voxels != nil {
        if err := n.Voxels.Validate(); err != nil { return fmt.Errorf("validation error in Voxels: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IsoSurfaceVolumeData) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.ContourStepSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "contourStepSize"}, Value: fmt.Sprintf("%v", *n.ContourStepSize)}) }
    if n.Dimensions != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "dimensions"}, Value: fmt.Sprintf("%v", *n.Dimensions)}) }
    if n.SurfaceTolerance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceTolerance"}, Value: fmt.Sprintf("%v", *n.SurfaceTolerance)}) }
    if n.SurfaceValues != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceValues"}, Value: fmt.Sprintf("%v", n.SurfaceValues)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Gradients != nil {
        if err := e.EncodeElement(n.Gradients, xml.StartElement{Name: xml.Name{Local: n.Gradients.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RenderStyle != nil {
        for _, child := range n.RenderStyle { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Voxels != nil {
        if err := e.EncodeElement(n.Voxels, xml.StartElement{Name: xml.Name{Local: n.Voxels.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// KeySensor: KeySensor generates events as the user presses keys on the keyboard.
type KeySensor struct {
    CoreX3DNode
    ActionKeyPress *int32 `xml:"actionKeyPress,attr,omitempty""`
    ActionKeyRelease *int32 `xml:"actionKeyRelease,attr,omitempty""`
    AltKey *bool `xml:"altKey,attr,omitempty""`
    ControlKey *bool `xml:"controlKey,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    KeyPress *string `xml:"keyPress,attr,omitempty""`
    KeyRelease *string `xml:"keyRelease,attr,omitempty""`
    ShiftKey *bool `xml:"shiftKey,attr,omitempty""`
}

func (n *KeySensor) GetNodeName() string { return "KeySensor" }
func (n *KeySensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/keyDeviceSensor.html#KeySensor" }
func (n *KeySensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *KeySensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ActionKeyPress != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "actionKeyPress"}, Value: fmt.Sprintf("%v", *n.ActionKeyPress)}) }
    if n.ActionKeyRelease != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "actionKeyRelease"}, Value: fmt.Sprintf("%v", *n.ActionKeyRelease)}) }
    if n.AltKey != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "altKey"}, Value: fmt.Sprintf("%v", *n.AltKey)}) }
    if n.ControlKey != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "controlKey"}, Value: fmt.Sprintf("%v", *n.ControlKey)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.KeyPress != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyPress"}, Value: fmt.Sprintf("%v", *n.KeyPress)}) }
    if n.KeyRelease != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyRelease"}, Value: fmt.Sprintf("%v", *n.KeyRelease)}) }
    if n.ShiftKey != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shiftKey"}, Value: fmt.Sprintf("%v", *n.ShiftKey)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Layer: Layer contains a list of children nodes that define the contents of the layer.
type Layer struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    ObjectType []string `xml:"objectType,attr,omitempty""`
    Pickable *bool `xml:"pickable,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Viewport X3DNode `xml:"viewport,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *Layer) GetNodeName() string { return "Layer" }
func (n *Layer) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layering.html#Layer" }
func (n *Layer) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    if n.Viewport != nil {
        if err := n.Viewport.Validate(); err != nil { return fmt.Errorf("validation error in Viewport: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Layer) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ObjectType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "objectType"}, Value: fmt.Sprintf("%v", n.ObjectType)}) }
    if n.Pickable != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pickable"}, Value: fmt.Sprintf("%v", *n.Pickable)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Viewport != nil {
        if err := e.EncodeElement(n.Viewport, xml.StartElement{Name: xml.Name{Local: n.Viewport.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// LayerSet: LayerSet defines a list of layers and a rendering order.
type LayerSet struct {
    CoreX3DNode
    ActiveLayer *int32 `xml:"activeLayer,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Layers []X3DNode `xml:",any""`
    Order []int32 `xml:"order,attr,omitempty""`
}

func (n *LayerSet) GetNodeName() string { return "LayerSet" }
func (n *LayerSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layering.html#LayerSet" }
func (n *LayerSet) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Layers != nil {
        for i, child := range n.Layers { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Layers[%d]: %w", i, err) } }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *LayerSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ActiveLayer != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "activeLayer"}, Value: fmt.Sprintf("%v", *n.ActiveLayer)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", n.Order)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Layers != nil {
        for _, child := range n.Layers { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Layout: Layout node is used as layout field of LayoutLayer and LayoutGroup nodes.
type Layout struct {
    CoreX3DNode
    Align []string `xml:"align,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Offset []float32 `xml:"offset,attr,omitempty""`
    OffsetUnits []string `xml:"offsetUnits,attr,omitempty""`
    ScaleMode []string `xml:"scaleMode,attr,omitempty""`
    Size []float32 `xml:"size,attr,omitempty""`
    SizeUnits []string `xml:"sizeUnits,attr,omitempty""`
}

func (n *Layout) GetNodeName() string { return "Layout" }
func (n *Layout) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#Layout" }
func (n *Layout) Validate() error {
    if n.Align != nil {
        for _, value := range n.Align {
            switch value {
            case LayoutAlignChoicesLEFTBOTTOM, LayoutAlignChoicesLEFTCENTER, LayoutAlignChoicesLEFTTOP, LayoutAlignChoicesCENTERBOTTOM, LayoutAlignChoicesCENTERCENTER, LayoutAlignChoicesCENTERTOP, LayoutAlignChoicesRIGHTBOTTOM, LayoutAlignChoicesRIGHTCENTER, LayoutAlignChoicesRIGHTTOP: // valid
            default: return fmt.Errorf("invalid value in field align: %s", value)
            }
        }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.OffsetUnits != nil {
        for _, value := range n.OffsetUnits {
            switch value {
            case LayoutUnitsChoicesWORLDWORLD, LayoutUnitsChoicesWORLDFRACTION, LayoutUnitsChoicesWORLDPIXEL, LayoutUnitsChoicesFRACTIONWORLD, LayoutUnitsChoicesFRACTIONFRACTION, LayoutUnitsChoicesFRACTIONPIXEL, LayoutUnitsChoicesPIXELWORLD, LayoutUnitsChoicesPIXELFRACTION, LayoutUnitsChoicesPIXELPIXEL: // valid
            default: return fmt.Errorf("invalid value in field offsetUnits: %s", value)
            }
        }
    }
    if n.ScaleMode != nil {
        for _, value := range n.ScaleMode {
            switch value {
            case LayoutScaleModeChoicesNONENONE, LayoutScaleModeChoicesNONEFRACTION, LayoutScaleModeChoicesNONESTRETCH, LayoutScaleModeChoicesNONEPIXEL, LayoutScaleModeChoicesFRACTIONNONE, LayoutScaleModeChoicesFRACTIONFRACTION, LayoutScaleModeChoicesFRACTIONSTRETCH, LayoutScaleModeChoicesFRACTIONPIXEL, LayoutScaleModeChoicesSTRETCHNONE, LayoutScaleModeChoicesSTRETCHFRACTION, LayoutScaleModeChoicesSTRETCHSTRETCH, LayoutScaleModeChoicesSTRETCHPIXEL, LayoutScaleModeChoicesPIXELNONE, LayoutScaleModeChoicesPIXELFRACTION, LayoutScaleModeChoicesPIXELSTRETCH, LayoutScaleModeChoicesPIXELPIXEL: // valid
            default: return fmt.Errorf("invalid value in field scaleMode: %s", value)
            }
        }
    }
    if n.SizeUnits != nil {
        for _, value := range n.SizeUnits {
            switch value {
            case LayoutUnitsChoicesWORLDWORLD, LayoutUnitsChoicesWORLDFRACTION, LayoutUnitsChoicesWORLDPIXEL, LayoutUnitsChoicesFRACTIONWORLD, LayoutUnitsChoicesFRACTIONFRACTION, LayoutUnitsChoicesFRACTIONPIXEL, LayoutUnitsChoicesPIXELWORLD, LayoutUnitsChoicesPIXELFRACTION, LayoutUnitsChoicesPIXELPIXEL: // valid
            default: return fmt.Errorf("invalid value in field sizeUnits: %s", value)
            }
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Layout) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Align != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "align"}, Value: fmt.Sprintf("%v", n.Align)}) }
    if n.Offset != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "offset"}, Value: fmt.Sprintf("%v", n.Offset)}) }
    if n.OffsetUnits != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "offsetUnits"}, Value: fmt.Sprintf("%v", n.OffsetUnits)}) }
    if n.ScaleMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scaleMode"}, Value: fmt.Sprintf("%v", n.ScaleMode)}) }
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", n.Size)}) }
    if n.SizeUnits != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sizeUnits"}, Value: fmt.Sprintf("%v", n.SizeUnits)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// LayoutGroup: LayoutGroup is a Grouping node that can contain most nodes, whose children are related by a common layout within a parent layout.
type LayoutGroup struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Layout X3DNode `xml:"layout,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Viewport X3DNode `xml:"viewport,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *LayoutGroup) GetNodeName() string { return "LayoutGroup" }
func (n *LayoutGroup) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#LayoutGroup" }
func (n *LayoutGroup) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Layout != nil {
        if err := n.Layout.Validate(); err != nil { return fmt.Errorf("validation error in Layout: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    if n.Viewport != nil {
        if err := n.Viewport.Validate(); err != nil { return fmt.Errorf("validation error in Viewport: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *LayoutGroup) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Layout != nil {
        if err := e.EncodeElement(n.Layout, xml.StartElement{Name: xml.Name{Local: n.Layout.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Viewport != nil {
        if err := e.EncodeElement(n.Viewport, xml.StartElement{Name: xml.Name{Local: n.Viewport.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// LayoutLayer: LayoutLayer is a Grouping node that can contain most nodes.
type LayoutLayer struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Layout X3DNode `xml:"layout,omitempty""`
    ObjectType []string `xml:"objectType,attr,omitempty""`
    Pickable *bool `xml:"pickable,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Viewport X3DNode `xml:"viewport,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *LayoutLayer) GetNodeName() string { return "LayoutLayer" }
func (n *LayoutLayer) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#LayoutLayer" }
func (n *LayoutLayer) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Layout != nil {
        if err := n.Layout.Validate(); err != nil { return fmt.Errorf("validation error in Layout: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    if n.Viewport != nil {
        if err := n.Viewport.Validate(); err != nil { return fmt.Errorf("validation error in Viewport: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *LayoutLayer) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ObjectType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "objectType"}, Value: fmt.Sprintf("%v", n.ObjectType)}) }
    if n.Pickable != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pickable"}, Value: fmt.Sprintf("%v", *n.Pickable)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Layout != nil {
        if err := e.EncodeElement(n.Layout, xml.StartElement{Name: xml.Name{Local: n.Layout.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Viewport != nil {
        if err := e.EncodeElement(n.Viewport, xml.StartElement{Name: xml.Name{Local: n.Viewport.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// LinePickSensor: LinePickSensor uses one or more pickingGeometry line segments to compute intersections with pickTarget shapes.
type LinePickSensor struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IntersectionType *string `xml:"intersectionType,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    MatchCriterion *string `xml:"matchCriterion,attr,omitempty""`
    ObjectType []string `xml:"objectType,attr,omitempty""`
    PickedGeometry []X3DNode `xml:",any""`
    PickedNormal *MFVec3f `xml:"pickedNormal,attr,omitempty""`
    PickedPoint *MFVec3f `xml:"pickedPoint,attr,omitempty""`
    PickedTextureCoordinate *MFVec3f `xml:"pickedTextureCoordinate,attr,omitempty""`
    PickingGeometry X3DNode `xml:"pickingGeometry,omitempty""`
    PickTarget []X3DNode `xml:",any""`
    SortOrder *string `xml:"sortOrder,attr,omitempty""`
}

func (n *LinePickSensor) GetNodeName() string { return "LinePickSensor" }
func (n *LinePickSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#LinePickSensor" }
func (n *LinePickSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.MatchCriterion != nil {
        switch *n.MatchCriterion {
        case PickSensorMatchCriterionChoicesMATCHANY, PickSensorMatchCriterionChoicesMATCHEVERY, PickSensorMatchCriterionChoicesMATCHONLYONE: // valid
        default: return fmt.Errorf("invalid value for field matchCriterion: %s", *n.MatchCriterion)
        }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.PickedGeometry != nil {
        for i, child := range n.PickedGeometry { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in PickedGeometry[%d]: %w", i, err) } }
    }
    if n.PickingGeometry != nil {
        if err := n.PickingGeometry.Validate(); err != nil { return fmt.Errorf("validation error in PickingGeometry: %w", err) }
    }
    if n.PickTarget != nil {
        for i, child := range n.PickTarget { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in PickTarget[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *LinePickSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IntersectionType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intersectionType"}, Value: fmt.Sprintf("%v", *n.IntersectionType)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.MatchCriterion != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "matchCriterion"}, Value: fmt.Sprintf("%v", *n.MatchCriterion)}) }
    if n.ObjectType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "objectType"}, Value: fmt.Sprintf("%v", n.ObjectType)}) }
    if n.PickedNormal != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pickedNormal"}, Value: fmt.Sprintf("%v", *n.PickedNormal)}) }
    if n.PickedPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pickedPoint"}, Value: fmt.Sprintf("%v", *n.PickedPoint)}) }
    if n.PickedTextureCoordinate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pickedTextureCoordinate"}, Value: fmt.Sprintf("%v", *n.PickedTextureCoordinate)}) }
    if n.SortOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sortOrder"}, Value: fmt.Sprintf("%v", *n.SortOrder)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.PickedGeometry != nil {
        for _, child := range n.PickedGeometry { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.PickingGeometry != nil {
        if err := e.EncodeElement(n.PickingGeometry, xml.StartElement{Name: xml.Name{Local: n.PickingGeometry.GetNodeName()}}); err != nil { return err }
    }
    if n.PickTarget != nil {
        for _, child := range n.PickTarget { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// LineProperties: LineProperties allows precise fine-grained control over the rendering style of lines and edges for associated geometry nodes inside the same Shape.
type LineProperties struct {
    CoreX3DNode
    Applied *bool `xml:"applied,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Linetype *int32 `xml:"linetype,attr,omitempty""`
    LinewidthScaleFactor *float32 `xml:"linewidthScaleFactor,attr,omitempty""`
}

func (n *LineProperties) GetNodeName() string { return "LineProperties" }
func (n *LineProperties) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#LineProperties" }
func (n *LineProperties) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *LineProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Applied != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "applied"}, Value: fmt.Sprintf("%v", *n.Applied)}) }
    if n.Linetype != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "linetype"}, Value: fmt.Sprintf("%v", *n.Linetype)}) }
    if n.LinewidthScaleFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "linewidthScaleFactor"}, Value: fmt.Sprintf("%v", *n.LinewidthScaleFactor)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// LineSet: LineSet is a geometry node that can contain a Coordinate|CoordinateDouble node and optionally a Color|ColorRGBA node.
type LineSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Color X3DNode `xml:"color,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    VertexCount []int32 `xml:"vertexCount,attr,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *LineSet) GetNodeName() string { return "LineSet" }
func (n *LineSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#LineSet" }
func (n *LineSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *LineSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.VertexCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vertexCount"}, Value: fmt.Sprintf("%v", n.VertexCount)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ListenerPointSource: ListenerPointSource node represents position and orientation of a person listening to virtual sound in the audio scene, and provides single or multiple sound channels as output.
type ListenerPointSource struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    DopplerEnabled *bool `xml:"dopplerEnabled,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    InterauralDistance *float32 `xml:"interauralDistance,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    Orientation *SFRotation `xml:"orientation,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    Position *SFVec3f `xml:"position,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    TrackCurrentView *bool `xml:"trackCurrentView,attr,omitempty""`
}

func (n *ListenerPointSource) GetNodeName() string { return "ListenerPointSource" }
func (n *ListenerPointSource) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#ListenerPointSource" }
func (n *ListenerPointSource) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ListenerPointSource) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.DopplerEnabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "dopplerEnabled"}, Value: fmt.Sprintf("%v", *n.DopplerEnabled)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.InterauralDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "interauralDistance"}, Value: fmt.Sprintf("%v", *n.InterauralDistance)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.Orientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orientation"}, Value: fmt.Sprintf("%v", *n.Orientation)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.Position != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position"}, Value: fmt.Sprintf("%v", *n.Position)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.TrackCurrentView != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "trackCurrentView"}, Value: fmt.Sprintf("%v", *n.TrackCurrentView)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// LoadSensor: LoadSensor generates events as watchList child nodes are either loaded or fail to load.
type LoadSensor struct {
    CoreX3DNode
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsLoaded *bool `xml:"isLoaded,attr,omitempty""`
    LoadTime *float64 `xml:"loadTime,attr,omitempty""`
    Progress *float32 `xml:"progress,attr,omitempty""`
    TimeOut *float64 `xml:"timeOut,attr,omitempty""`
}

func (n *LoadSensor) GetNodeName() string { return "LoadSensor" }
func (n *LoadSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/networking.html#LoadSensor" }
func (n *LoadSensor) Validate() error {
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *LoadSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsLoaded != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isLoaded"}, Value: fmt.Sprintf("%v", *n.IsLoaded)}) }
    if n.LoadTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loadTime"}, Value: fmt.Sprintf("%v", *n.LoadTime)}) }
    if n.Progress != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "progress"}, Value: fmt.Sprintf("%v", *n.Progress)}) }
    if n.TimeOut != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "timeOut"}, Value: fmt.Sprintf("%v", *n.TimeOut)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// LocalFog: LocalFog simulates atmospheric effects by blending distant objects with fog color.
type LocalFog struct {
    CoreX3DNode
    Color *SFColor `xml:"color,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    FogType *string `xml:"fogType,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    VisibilityRange *float32 `xml:"visibilityRange,attr,omitempty""`
}

func (n *LocalFog) GetNodeName() string { return "LocalFog" }
func (n *LocalFog) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#LocalFog" }
func (n *LocalFog) Validate() error {
    if n.FogType != nil {
        switch *n.FogType {
        case FogTypeChoicesLINEAR, FogTypeChoicesEXPONENTIAL: // valid
        default: return fmt.Errorf("invalid value for field fogType: %s", *n.FogType)
        }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *LocalFog) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.FogType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fogType"}, Value: fmt.Sprintf("%v", *n.FogType)}) }
    if n.VisibilityRange != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visibilityRange"}, Value: fmt.Sprintf("%v", *n.VisibilityRange)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// LOD: LOD (Level Of Detail) uses camera-to-object distance to switch among contained child levels.
type LOD struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    ForceTransitions *bool `xml:"forceTransitions,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    LevelChanged *int32 `xml:"level_changed,attr,omitempty""`
    Range []float32 `xml:"range,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *LOD) GetNodeName() string { return "LOD" }
func (n *LOD) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#LOD" }
func (n *LOD) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *LOD) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.ForceTransitions != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "forceTransitions"}, Value: fmt.Sprintf("%v", *n.ForceTransitions)}) }
    if n.LevelChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "level_changed"}, Value: fmt.Sprintf("%v", *n.LevelChanged)}) }
    if n.Range != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "range"}, Value: fmt.Sprintf("%v", n.Range)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// Material: Material specifies surface rendering properties for associated geometry nodes.
type Material struct {
    CoreX3DNode
    AmbientIntensity *float32 `xml:"ambientIntensity,attr,omitempty""`
    AmbientTexture X3DNode `xml:"ambientTexture,omitempty""`
    AmbientTextureMapping *string `xml:"ambientTextureMapping,attr,omitempty""`
    DiffuseColor *SFColor `xml:"diffuseColor,attr,omitempty""`
    DiffuseTexture X3DNode `xml:"diffuseTexture,omitempty""`
    DiffuseTextureMapping *string `xml:"diffuseTextureMapping,attr,omitempty""`
    EmissiveColor *SFColor `xml:"emissiveColor,attr,omitempty""`
    EmissiveTexture X3DNode `xml:"emissiveTexture,omitempty""`
    EmissiveTextureMapping *string `xml:"emissiveTextureMapping,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    NormalScale *float32 `xml:"normalScale,attr,omitempty""`
    NormalTexture X3DNode `xml:"normalTexture,omitempty""`
    NormalTextureMapping *string `xml:"normalTextureMapping,attr,omitempty""`
    OcclusionStrength *float32 `xml:"occlusionStrength,attr,omitempty""`
    OcclusionTexture X3DNode `xml:"occlusionTexture,omitempty""`
    OcclusionTextureMapping *string `xml:"occlusionTextureMapping,attr,omitempty""`
    Shininess *float32 `xml:"shininess,attr,omitempty""`
    ShininessTexture X3DNode `xml:"shininessTexture,omitempty""`
    ShininessTextureMapping *string `xml:"shininessTextureMapping,attr,omitempty""`
    SpecularColor *SFColor `xml:"specularColor,attr,omitempty""`
    SpecularTexture X3DNode `xml:"specularTexture,omitempty""`
    SpecularTextureMapping *string `xml:"specularTextureMapping,attr,omitempty""`
    Transparency *float32 `xml:"transparency,attr,omitempty""`
}

func (n *Material) GetNodeName() string { return "Material" }
func (n *Material) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#Material" }
func (n *Material) Validate() error {
    if n.AmbientTexture != nil {
        if err := n.AmbientTexture.Validate(); err != nil { return fmt.Errorf("validation error in AmbientTexture: %w", err) }
    }
    if n.DiffuseTexture != nil {
        if err := n.DiffuseTexture.Validate(); err != nil { return fmt.Errorf("validation error in DiffuseTexture: %w", err) }
    }
    if n.EmissiveTexture != nil {
        if err := n.EmissiveTexture.Validate(); err != nil { return fmt.Errorf("validation error in EmissiveTexture: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.NormalTexture != nil {
        if err := n.NormalTexture.Validate(); err != nil { return fmt.Errorf("validation error in NormalTexture: %w", err) }
    }
    if n.OcclusionTexture != nil {
        if err := n.OcclusionTexture.Validate(); err != nil { return fmt.Errorf("validation error in OcclusionTexture: %w", err) }
    }
    if n.ShininessTexture != nil {
        if err := n.ShininessTexture.Validate(); err != nil { return fmt.Errorf("validation error in ShininessTexture: %w", err) }
    }
    if n.SpecularTexture != nil {
        if err := n.SpecularTexture.Validate(); err != nil { return fmt.Errorf("validation error in SpecularTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Material) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AmbientIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ambientIntensity"}, Value: fmt.Sprintf("%v", *n.AmbientIntensity)}) }
    if n.AmbientTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ambientTextureMapping"}, Value: fmt.Sprintf("%v", *n.AmbientTextureMapping)}) }
    if n.DiffuseColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseColor"}, Value: fmt.Sprintf("%v", *n.DiffuseColor)}) }
    if n.DiffuseTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseTextureMapping"}, Value: fmt.Sprintf("%v", *n.DiffuseTextureMapping)}) }
    if n.EmissiveColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveColor"}, Value: fmt.Sprintf("%v", *n.EmissiveColor)}) }
    if n.EmissiveTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveTextureMapping"}, Value: fmt.Sprintf("%v", *n.EmissiveTextureMapping)}) }
    if n.NormalScale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalScale"}, Value: fmt.Sprintf("%v", *n.NormalScale)}) }
    if n.NormalTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalTextureMapping"}, Value: fmt.Sprintf("%v", *n.NormalTextureMapping)}) }
    if n.OcclusionStrength != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "occlusionStrength"}, Value: fmt.Sprintf("%v", *n.OcclusionStrength)}) }
    if n.OcclusionTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "occlusionTextureMapping"}, Value: fmt.Sprintf("%v", *n.OcclusionTextureMapping)}) }
    if n.Shininess != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shininess"}, Value: fmt.Sprintf("%v", *n.Shininess)}) }
    if n.ShininessTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shininessTextureMapping"}, Value: fmt.Sprintf("%v", *n.ShininessTextureMapping)}) }
    if n.SpecularColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specularColor"}, Value: fmt.Sprintf("%v", *n.SpecularColor)}) }
    if n.SpecularTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specularTextureMapping"}, Value: fmt.Sprintf("%v", *n.SpecularTextureMapping)}) }
    if n.Transparency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transparency"}, Value: fmt.Sprintf("%v", *n.Transparency)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AmbientTexture != nil {
        if err := e.EncodeElement(n.AmbientTexture, xml.StartElement{Name: xml.Name{Local: n.AmbientTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.DiffuseTexture != nil {
        if err := e.EncodeElement(n.DiffuseTexture, xml.StartElement{Name: xml.Name{Local: n.DiffuseTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.EmissiveTexture != nil {
        if err := e.EncodeElement(n.EmissiveTexture, xml.StartElement{Name: xml.Name{Local: n.EmissiveTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.NormalTexture != nil {
        if err := e.EncodeElement(n.NormalTexture, xml.StartElement{Name: xml.Name{Local: n.NormalTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.OcclusionTexture != nil {
        if err := e.EncodeElement(n.OcclusionTexture, xml.StartElement{Name: xml.Name{Local: n.OcclusionTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.ShininessTexture != nil {
        if err := e.EncodeElement(n.ShininessTexture, xml.StartElement{Name: xml.Name{Local: n.ShininessTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.SpecularTexture != nil {
        if err := e.EncodeElement(n.SpecularTexture, xml.StartElement{Name: xml.Name{Local: n.SpecularTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Matrix3VertexAttribute: Matrix3VertexAttribute defines a set of per-vertex 3x3 matrix attributes.
type Matrix3VertexAttribute struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Value *MFMatrix3f `xml:"value,attr,omitempty""`
}

func (n *Matrix3VertexAttribute) GetNodeName() string { return "Matrix3VertexAttribute" }
func (n *Matrix3VertexAttribute) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#Matrix3VertexAttribute" }
func (n *Matrix3VertexAttribute) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Matrix3VertexAttribute) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", *n.Value)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Matrix4VertexAttribute: Matrix4VertexAttribute defines a set of per-vertex 4x4 matrix attributes.
type Matrix4VertexAttribute struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Value *MFMatrix4f `xml:"value,attr,omitempty""`
}

func (n *Matrix4VertexAttribute) GetNodeName() string { return "Matrix4VertexAttribute" }
func (n *Matrix4VertexAttribute) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#Matrix4VertexAttribute" }
func (n *Matrix4VertexAttribute) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Matrix4VertexAttribute) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", *n.Value)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// MetadataBoolean: The metadata provided by this node is contained in the Boolean values of the value field.
type MetadataBoolean struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Reference *string `xml:"reference,attr,omitempty""`
    Value []bool `xml:"value,attr,omitempty""`
}

func (n *MetadataBoolean) GetNodeName() string { return "MetadataBoolean" }
func (n *MetadataBoolean) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataBoolean" }
func (n *MetadataBoolean) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MetadataBoolean) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Reference != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "reference"}, Value: fmt.Sprintf("%v", *n.Reference)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", n.Value)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// MetadataDouble: The metadata provided by this node is contained in the double-precision floating point numbers of the value field.
type MetadataDouble struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Reference *string `xml:"reference,attr,omitempty""`
    Value []float64 `xml:"value,attr,omitempty""`
}

func (n *MetadataDouble) GetNodeName() string { return "MetadataDouble" }
func (n *MetadataDouble) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataDouble" }
func (n *MetadataDouble) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MetadataDouble) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Reference != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "reference"}, Value: fmt.Sprintf("%v", *n.Reference)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", n.Value)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// MetadataFloat: The metadata provided by this node is contained in the single-precision floating point numbers of the value field.
type MetadataFloat struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Reference *string `xml:"reference,attr,omitempty""`
    Value []float32 `xml:"value,attr,omitempty""`
}

func (n *MetadataFloat) GetNodeName() string { return "MetadataFloat" }
func (n *MetadataFloat) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataFloat" }
func (n *MetadataFloat) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MetadataFloat) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Reference != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "reference"}, Value: fmt.Sprintf("%v", *n.Reference)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", n.Value)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// MetadataInteger: The metadata provided by this node is contained in the integer numbers of the value field.
type MetadataInteger struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Reference *string `xml:"reference,attr,omitempty""`
    Value []int32 `xml:"value,attr,omitempty""`
}

func (n *MetadataInteger) GetNodeName() string { return "MetadataInteger" }
func (n *MetadataInteger) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataInteger" }
func (n *MetadataInteger) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MetadataInteger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Reference != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "reference"}, Value: fmt.Sprintf("%v", *n.Reference)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", n.Value)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// MetadataSet: The metadata provided by this node is contained in the metadata nodes of the value field.
type MetadataSet struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Reference *string `xml:"reference,attr,omitempty""`
    Value []X3DNode `xml:",any""`
}

func (n *MetadataSet) GetNodeName() string { return "MetadataSet" }
func (n *MetadataSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataSet" }
func (n *MetadataSet) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Value != nil {
        for i, child := range n.Value { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Value[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MetadataSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Reference != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "reference"}, Value: fmt.Sprintf("%v", *n.Reference)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Value != nil {
        for _, child := range n.Value { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// MetadataString: The metadata provided by this node is contained in the strings of the value field.
type MetadataString struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
    Reference *string `xml:"reference,attr,omitempty""`
    Value []string `xml:"value,attr,omitempty""`
}

func (n *MetadataString) GetNodeName() string { return "MetadataString" }
func (n *MetadataString) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#MetadataString" }
func (n *MetadataString) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MetadataString) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.Reference != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "reference"}, Value: fmt.Sprintf("%v", *n.Reference)}) }
    if n.Value != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: fmt.Sprintf("%v", n.Value)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// MicrophoneSource: MicrophoneSource captures input from a physical microphone in the real world.
type MicrophoneSource struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    MediaDeviceID *string `xml:"mediaDeviceID,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
}

func (n *MicrophoneSource) GetNodeName() string { return "MicrophoneSource" }
func (n *MicrophoneSource) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#MicrophoneSource" }
func (n *MicrophoneSource) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MicrophoneSource) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.MediaDeviceID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mediaDeviceID"}, Value: fmt.Sprintf("%v", *n.MediaDeviceID)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// MotorJoint: MotorJoint drives relative angular velocities between body1 and body2 within a common reference frame.
type MotorJoint struct {
    CoreX3DNode
    AutoCalc *bool `xml:"autoCalc,attr,omitempty""`
    Axis1Angle *float32 `xml:"axis1Angle,attr,omitempty""`
    Axis1Torque *float32 `xml:"axis1Torque,attr,omitempty""`
    Axis2Angle *float32 `xml:"axis2Angle,attr,omitempty""`
    Axis2Torque *float32 `xml:"axis2Torque,attr,omitempty""`
    Axis3Angle *float32 `xml:"axis3Angle,attr,omitempty""`
    Axis3Torque *float32 `xml:"axis3Torque,attr,omitempty""`
    Body1 X3DNode `xml:"body1,omitempty""`
    Body2 X3DNode `xml:"body2,omitempty""`
    EnabledAxes *int32 `xml:"enabledAxes,attr,omitempty""`
    ForceOutput []string `xml:"forceOutput,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Motor1Angle *float32 `xml:"motor1Angle,attr,omitempty""`
    Motor1AngleRate *float32 `xml:"motor1AngleRate,attr,omitempty""`
    Motor1Axis *SFVec3f `xml:"motor1Axis,attr,omitempty""`
    Motor2Angle *float32 `xml:"motor2Angle,attr,omitempty""`
    Motor2AngleRate *float32 `xml:"motor2AngleRate,attr,omitempty""`
    Motor2Axis *SFVec3f `xml:"motor2Axis,attr,omitempty""`
    Motor3Angle *float32 `xml:"motor3Angle,attr,omitempty""`
    Motor3AngleRate *float32 `xml:"motor3AngleRate,attr,omitempty""`
    Motor3Axis *SFVec3f `xml:"motor3Axis,attr,omitempty""`
    Stop1Bounce *float32 `xml:"stop1Bounce,attr,omitempty""`
    Stop1ErrorCorrection *float32 `xml:"stop1ErrorCorrection,attr,omitempty""`
    Stop2Bounce *float32 `xml:"stop2Bounce,attr,omitempty""`
    Stop2ErrorCorrection *float32 `xml:"stop2ErrorCorrection,attr,omitempty""`
    Stop3Bounce *float32 `xml:"stop3Bounce,attr,omitempty""`
    Stop3ErrorCorrection *float32 `xml:"stop3ErrorCorrection,attr,omitempty""`
}

func (n *MotorJoint) GetNodeName() string { return "MotorJoint" }
func (n *MotorJoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#MotorJoint" }
func (n *MotorJoint) Validate() error {
    if n.Body1 != nil {
        if err := n.Body1.Validate(); err != nil { return fmt.Errorf("validation error in Body1: %w", err) }
    }
    if n.Body2 != nil {
        if err := n.Body2.Validate(); err != nil { return fmt.Errorf("validation error in Body2: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MotorJoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoCalc != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoCalc"}, Value: fmt.Sprintf("%v", *n.AutoCalc)}) }
    if n.Axis1Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis1Angle"}, Value: fmt.Sprintf("%v", *n.Axis1Angle)}) }
    if n.Axis1Torque != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis1Torque"}, Value: fmt.Sprintf("%v", *n.Axis1Torque)}) }
    if n.Axis2Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis2Angle"}, Value: fmt.Sprintf("%v", *n.Axis2Angle)}) }
    if n.Axis2Torque != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis2Torque"}, Value: fmt.Sprintf("%v", *n.Axis2Torque)}) }
    if n.Axis3Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis3Angle"}, Value: fmt.Sprintf("%v", *n.Axis3Angle)}) }
    if n.Axis3Torque != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis3Torque"}, Value: fmt.Sprintf("%v", *n.Axis3Torque)}) }
    if n.EnabledAxes != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabledAxes"}, Value: fmt.Sprintf("%v", *n.EnabledAxes)}) }
    if n.ForceOutput != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "forceOutput"}, Value: fmt.Sprintf("%v", n.ForceOutput)}) }
    if n.Motor1Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motor1Angle"}, Value: fmt.Sprintf("%v", *n.Motor1Angle)}) }
    if n.Motor1AngleRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motor1AngleRate"}, Value: fmt.Sprintf("%v", *n.Motor1AngleRate)}) }
    if n.Motor1Axis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motor1Axis"}, Value: fmt.Sprintf("%v", *n.Motor1Axis)}) }
    if n.Motor2Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motor2Angle"}, Value: fmt.Sprintf("%v", *n.Motor2Angle)}) }
    if n.Motor2AngleRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motor2AngleRate"}, Value: fmt.Sprintf("%v", *n.Motor2AngleRate)}) }
    if n.Motor2Axis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motor2Axis"}, Value: fmt.Sprintf("%v", *n.Motor2Axis)}) }
    if n.Motor3Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motor3Angle"}, Value: fmt.Sprintf("%v", *n.Motor3Angle)}) }
    if n.Motor3AngleRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motor3AngleRate"}, Value: fmt.Sprintf("%v", *n.Motor3AngleRate)}) }
    if n.Motor3Axis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "motor3Axis"}, Value: fmt.Sprintf("%v", *n.Motor3Axis)}) }
    if n.Stop1Bounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop1Bounce"}, Value: fmt.Sprintf("%v", *n.Stop1Bounce)}) }
    if n.Stop1ErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop1ErrorCorrection"}, Value: fmt.Sprintf("%v", *n.Stop1ErrorCorrection)}) }
    if n.Stop2Bounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop2Bounce"}, Value: fmt.Sprintf("%v", *n.Stop2Bounce)}) }
    if n.Stop2ErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop2ErrorCorrection"}, Value: fmt.Sprintf("%v", *n.Stop2ErrorCorrection)}) }
    if n.Stop3Bounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop3Bounce"}, Value: fmt.Sprintf("%v", *n.Stop3Bounce)}) }
    if n.Stop3ErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop3ErrorCorrection"}, Value: fmt.Sprintf("%v", *n.Stop3ErrorCorrection)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Body1 != nil {
        if err := e.EncodeElement(n.Body1, xml.StartElement{Name: xml.Name{Local: n.Body1.GetNodeName()}}); err != nil { return err }
    }
    if n.Body2 != nil {
        if err := e.EncodeElement(n.Body2, xml.StartElement{Name: xml.Name{Local: n.Body2.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// MovieTexture: MovieTexture applies a 2D movie image to surface geometry, or provides audio for a Sound node.
type MovieTexture struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    DurationChanged *float64 `xml:"duration_changed,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    Loop *bool `xml:"loop,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    Pitch *float32 `xml:"pitch,attr,omitempty""`
    RepeatS *bool `xml:"repeatS,attr,omitempty""`
    RepeatT *bool `xml:"repeatT,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    Speed *float32 `xml:"speed,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *MovieTexture) GetNodeName() string { return "MovieTexture" }
func (n *MovieTexture) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#MovieTexture" }
func (n *MovieTexture) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MovieTexture) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.DurationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "duration_changed"}, Value: fmt.Sprintf("%v", *n.DurationChanged)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Loop != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loop"}, Value: fmt.Sprintf("%v", *n.Loop)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.Pitch != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pitch"}, Value: fmt.Sprintf("%v", *n.Pitch)}) }
    if n.RepeatS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatS"}, Value: fmt.Sprintf("%v", *n.RepeatS)}) }
    if n.RepeatT != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatT"}, Value: fmt.Sprintf("%v", *n.RepeatT)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.Speed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speed"}, Value: fmt.Sprintf("%v", *n.Speed)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// MultiTexture: MultiTexture applies several individual textures to a single geometry node, enabling a variety of visual effects that include light mapping and environment mapping.
type MultiTexture struct {
    CoreX3DNode
    Alpha *float32 `xml:"alpha,attr,omitempty""`
    Color *SFColor `xml:"color,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Function []string `xml:"function,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Mode []string `xml:"mode,attr,omitempty""`
    Source []string `xml:"source,attr,omitempty""`
    Texture []X3DNode `xml:",any""`
}

func (n *MultiTexture) GetNodeName() string { return "MultiTexture" }
func (n *MultiTexture) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#MultiTexture" }
func (n *MultiTexture) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Texture != nil {
        for i, child := range n.Texture { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Texture[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MultiTexture) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Alpha != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "alpha"}, Value: fmt.Sprintf("%v", *n.Alpha)}) }
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Function != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "function"}, Value: fmt.Sprintf("%v", n.Function)}) }
    if n.Mode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mode"}, Value: fmt.Sprintf("%v", n.Mode)}) }
    if n.Source != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "source"}, Value: fmt.Sprintf("%v", n.Source)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Texture != nil {
        for _, child := range n.Texture { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// MultiTextureCoordinate: MultiTextureCoordinate contains multiple TextureCoordinate or TextureCoordinateGenerator nodes, for use by a parent polygonal geometry node such as IndexedFaceSet or a Triangle* node.
type MultiTextureCoordinate struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    TexCoord []X3DNode `xml:",any""`
}

func (n *MultiTextureCoordinate) GetNodeName() string { return "MultiTextureCoordinate" }
func (n *MultiTextureCoordinate) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#MultiTextureCoordinate" }
func (n *MultiTextureCoordinate) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TexCoord != nil {
        for i, child := range n.TexCoord { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MultiTextureCoordinate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        for _, child := range n.TexCoord { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// MultiTextureTransform: MultiTextureTransform contains multiple TextureTransform nodes, each provided for use by corresponding ImageTexture MovieTexture or PixelTexture nodes within a sibling MultiTexture node.
type MultiTextureTransform struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    TextureTransform []X3DNode `xml:",any""`
}

func (n *MultiTextureTransform) GetNodeName() string { return "MultiTextureTransform" }
func (n *MultiTextureTransform) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#MultiTextureTransform" }
func (n *MultiTextureTransform) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TextureTransform != nil {
        for i, child := range n.TextureTransform { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in TextureTransform[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *MultiTextureTransform) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureTransform != nil {
        for _, child := range n.TextureTransform { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// NavigationInfo: NavigationInfo describes the user's viewing model, user navigation-interaction modalities, and also dimensional characteristics of the user's (typically invisible) avatar.
type NavigationInfo struct {
    CoreX3DNode
    AvatarSize []float32 `xml:"avatarSize,attr,omitempty""`
    BindTime *float64 `xml:"bindTime,attr,omitempty""`
    Headlight *bool `xml:"headlight,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsBound *bool `xml:"isBound,attr,omitempty""`
    SetBind *bool `xml:"set_bind,attr,omitempty""`
    Speed *float32 `xml:"speed,attr,omitempty""`
    TransitionComplete *bool `xml:"transitionComplete,attr,omitempty""`
    TransitionTime *float64 `xml:"transitionTime,attr,omitempty""`
    TransitionType []string `xml:"transitionType,attr,omitempty""`
    Type []string `xml:"type,attr,omitempty""`
    VisibilityLimit *float32 `xml:"visibilityLimit,attr,omitempty""`
}

func (n *NavigationInfo) GetNodeName() string { return "NavigationInfo" }
func (n *NavigationInfo) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#NavigationInfo" }
func (n *NavigationInfo) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NavigationInfo) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AvatarSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "avatarSize"}, Value: fmt.Sprintf("%v", n.AvatarSize)}) }
    if n.BindTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bindTime"}, Value: fmt.Sprintf("%v", *n.BindTime)}) }
    if n.Headlight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "headlight"}, Value: fmt.Sprintf("%v", *n.Headlight)}) }
    if n.IsBound != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isBound"}, Value: fmt.Sprintf("%v", *n.IsBound)}) }
    if n.SetBind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_bind"}, Value: fmt.Sprintf("%v", *n.SetBind)}) }
    if n.Speed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speed"}, Value: fmt.Sprintf("%v", *n.Speed)}) }
    if n.TransitionComplete != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transitionComplete"}, Value: fmt.Sprintf("%v", *n.TransitionComplete)}) }
    if n.TransitionTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transitionTime"}, Value: fmt.Sprintf("%v", *n.TransitionTime)}) }
    if n.TransitionType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transitionType"}, Value: fmt.Sprintf("%v", n.TransitionType)}) }
    if n.Type != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "type"}, Value: fmt.Sprintf("%v", n.Type)}) }
    if n.VisibilityLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visibilityLimit"}, Value: fmt.Sprintf("%v", *n.VisibilityLimit)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Normal: Normal defines a set of 3D surface-normal vectors that apply either to a sibling Coordinate|CoordinateDouble node, or else to a parent ElevationGrid node.
type Normal struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Vector *MFVec3f `xml:"vector,attr,omitempty""`
}

func (n *Normal) GetNodeName() string { return "Normal" }
func (n *Normal) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#Normal" }
func (n *Normal) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Normal) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Vector != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vector"}, Value: fmt.Sprintf("%v", *n.Vector)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NormalInterpolator: NormalInterpolator generates a series of normal (perpendicular) 3-tuple SFVec3f values.
type NormalInterpolator struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFVec3f `xml:"keyValue,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *MFVec3f `xml:"value_changed,attr,omitempty""`
}

func (n *NormalInterpolator) GetNodeName() string { return "NormalInterpolator" }
func (n *NormalInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#NormalInterpolator" }
func (n *NormalInterpolator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NormalInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsCurve: NurbsCurve is a 3D curve analogous to NurbsPatchSurface.
type NurbsCurve struct {
    CoreX3DNode
    Closed *bool `xml:"closed,attr,omitempty""`
    ControlPoint X3DNode `xml:"controlPoint,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Knot []float64 `xml:"knot,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    Tessellation *int32 `xml:"tessellation,attr,omitempty""`
    Weight []float64 `xml:"weight,attr,omitempty""`
}

func (n *NurbsCurve) GetNodeName() string { return "NurbsCurve" }
func (n *NurbsCurve) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsCurve" }
func (n *NurbsCurve) Validate() error {
    if n.ControlPoint != nil {
        if err := n.ControlPoint.Validate(); err != nil { return fmt.Errorf("validation error in ControlPoint: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsCurve) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Closed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "closed"}, Value: fmt.Sprintf("%v", *n.Closed)}) }
    if n.Knot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "knot"}, Value: fmt.Sprintf("%v", n.Knot)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.Tessellation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tessellation"}, Value: fmt.Sprintf("%v", *n.Tessellation)}) }
    if n.Weight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weight"}, Value: fmt.Sprintf("%v", n.Weight)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.ControlPoint != nil {
        if err := e.EncodeElement(n.ControlPoint, xml.StartElement{Name: xml.Name{Local: n.ControlPoint.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsCurve2D: NurbsCurve2D defines a trimming segment that is part of a trimming contour in the u-v domain of a surface.
type NurbsCurve2D struct {
    CoreX3DNode
    Closed *bool `xml:"closed,attr,omitempty""`
    ControlPoint *MFVec2d `xml:"controlPoint,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Knot []float64 `xml:"knot,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    Tessellation *int32 `xml:"tessellation,attr,omitempty""`
    Weight []float64 `xml:"weight,attr,omitempty""`
}

func (n *NurbsCurve2D) GetNodeName() string { return "NurbsCurve2D" }
func (n *NurbsCurve2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsCurve2D" }
func (n *NurbsCurve2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsCurve2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Closed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "closed"}, Value: fmt.Sprintf("%v", *n.Closed)}) }
    if n.ControlPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "controlPoint"}, Value: fmt.Sprintf("%v", *n.ControlPoint)}) }
    if n.Knot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "knot"}, Value: fmt.Sprintf("%v", n.Knot)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.Tessellation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tessellation"}, Value: fmt.Sprintf("%v", *n.Tessellation)}) }
    if n.Weight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weight"}, Value: fmt.Sprintf("%v", n.Weight)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsOrientationInterpolator: NurbsOrientationInterpolator describes a 3D NURBS curve and outputs interpolated orientation values.
type NurbsOrientationInterpolator struct {
    CoreX3DNode
    ControlPoint X3DNode `xml:"controlPoint,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Knot []float64 `xml:"knot,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFRotation `xml:"value_changed,attr,omitempty""`
    Weight []float64 `xml:"weight,attr,omitempty""`
}

func (n *NurbsOrientationInterpolator) GetNodeName() string { return "NurbsOrientationInterpolator" }
func (n *NurbsOrientationInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsOrientationInterpolator" }
func (n *NurbsOrientationInterpolator) Validate() error {
    if n.ControlPoint != nil {
        if err := n.ControlPoint.Validate(); err != nil { return fmt.Errorf("validation error in ControlPoint: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsOrientationInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Knot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "knot"}, Value: fmt.Sprintf("%v", n.Knot)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.Weight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weight"}, Value: fmt.Sprintf("%v", n.Weight)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.ControlPoint != nil {
        if err := e.EncodeElement(n.ControlPoint, xml.StartElement{Name: xml.Name{Local: n.ControlPoint.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsPatchSurface: NurbsPatchSurface defines a contiguous 3D Non-Uniform Rational B-Spline (NURBS) surface.
type NurbsPatchSurface struct {
    CoreX3DNode
    ControlPoint X3DNode `xml:"controlPoint,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    UClosed *bool `xml:"uClosed,attr,omitempty""`
    UDimension *int32 `xml:"uDimension,attr,omitempty""`
    UKnot []float64 `xml:"uKnot,attr,omitempty""`
    UOrder *int32 `xml:"uOrder,attr,omitempty""`
    UTessellation *int32 `xml:"uTessellation,attr,omitempty""`
    VClosed *bool `xml:"vClosed,attr,omitempty""`
    VDimension *int32 `xml:"vDimension,attr,omitempty""`
    VKnot []float64 `xml:"vKnot,attr,omitempty""`
    VOrder *int32 `xml:"vOrder,attr,omitempty""`
    VTessellation *int32 `xml:"vTessellation,attr,omitempty""`
    Weight []float64 `xml:"weight,attr,omitempty""`
}

func (n *NurbsPatchSurface) GetNodeName() string { return "NurbsPatchSurface" }
func (n *NurbsPatchSurface) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsPatchSurface" }
func (n *NurbsPatchSurface) Validate() error {
    if n.ControlPoint != nil {
        if err := n.ControlPoint.Validate(); err != nil { return fmt.Errorf("validation error in ControlPoint: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsPatchSurface) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.UClosed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uClosed"}, Value: fmt.Sprintf("%v", *n.UClosed)}) }
    if n.UDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uDimension"}, Value: fmt.Sprintf("%v", *n.UDimension)}) }
    if n.UKnot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uKnot"}, Value: fmt.Sprintf("%v", n.UKnot)}) }
    if n.UOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uOrder"}, Value: fmt.Sprintf("%v", *n.UOrder)}) }
    if n.UTessellation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uTessellation"}, Value: fmt.Sprintf("%v", *n.UTessellation)}) }
    if n.VClosed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vClosed"}, Value: fmt.Sprintf("%v", *n.VClosed)}) }
    if n.VDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vDimension"}, Value: fmt.Sprintf("%v", *n.VDimension)}) }
    if n.VKnot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vKnot"}, Value: fmt.Sprintf("%v", n.VKnot)}) }
    if n.VOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vOrder"}, Value: fmt.Sprintf("%v", *n.VOrder)}) }
    if n.VTessellation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vTessellation"}, Value: fmt.Sprintf("%v", *n.VTessellation)}) }
    if n.Weight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weight"}, Value: fmt.Sprintf("%v", n.Weight)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.ControlPoint != nil {
        if err := e.EncodeElement(n.ControlPoint, xml.StartElement{Name: xml.Name{Local: n.ControlPoint.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsPositionInterpolator: NurbsPositionInterpolator describes a 3D NURBS curve and outputs interpolated position values.
type NurbsPositionInterpolator struct {
    CoreX3DNode
    ControlPoint X3DNode `xml:"controlPoint,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Knot []float64 `xml:"knot,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFVec3f `xml:"value_changed,attr,omitempty""`
    Weight []float64 `xml:"weight,attr,omitempty""`
}

func (n *NurbsPositionInterpolator) GetNodeName() string { return "NurbsPositionInterpolator" }
func (n *NurbsPositionInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsPositionInterpolator" }
func (n *NurbsPositionInterpolator) Validate() error {
    if n.ControlPoint != nil {
        if err := n.ControlPoint.Validate(); err != nil { return fmt.Errorf("validation error in ControlPoint: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsPositionInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Knot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "knot"}, Value: fmt.Sprintf("%v", n.Knot)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.Weight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weight"}, Value: fmt.Sprintf("%v", n.Weight)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.ControlPoint != nil {
        if err := e.EncodeElement(n.ControlPoint, xml.StartElement{Name: xml.Name{Local: n.ControlPoint.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsSet: NurbsSet collects a set of NurbsSurface nodes into a common group and treats NurbsSurface set as a unit during tessellation, thereby enforcing tessellation continuity along borders.
type NurbsSet struct {
    CoreX3DNode
    AddGeometry []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Geometry []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveGeometry []X3DNode `xml:",any""`
    TessellationScale *float32 `xml:"tessellationScale,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *NurbsSet) GetNodeName() string { return "NurbsSet" }
func (n *NurbsSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsSet" }
func (n *NurbsSet) Validate() error {
    if n.AddGeometry != nil {
        for i, child := range n.AddGeometry { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddGeometry[%d]: %w", i, err) } }
    }
    if n.Geometry != nil {
        for i, child := range n.Geometry { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Geometry[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveGeometry != nil {
        for i, child := range n.RemoveGeometry { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveGeometry[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.TessellationScale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tessellationScale"}, Value: fmt.Sprintf("%v", *n.TessellationScale)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddGeometry != nil {
        for _, child := range n.AddGeometry { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Geometry != nil {
        for _, child := range n.Geometry { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveGeometry != nil {
        for _, child := range n.RemoveGeometry { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// NurbsSurfaceInterpolator: NurbsSurfaceInterpolator describes a 3D NURBS curve and outputs interpolated position and normal values.
type NurbsSurfaceInterpolator struct {
    CoreX3DNode
    ControlPoint X3DNode `xml:"controlPoint,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    NormalChanged *SFVec3f `xml:"normal_changed,attr,omitempty""`
    PositionChanged *SFVec3f `xml:"position_changed,attr,omitempty""`
    SetFraction *SFVec2f `xml:"set_fraction,attr,omitempty""`
    UDimension *int32 `xml:"uDimension,attr,omitempty""`
    UKnot []float64 `xml:"uKnot,attr,omitempty""`
    UOrder *int32 `xml:"uOrder,attr,omitempty""`
    VDimension *int32 `xml:"vDimension,attr,omitempty""`
    VKnot []float64 `xml:"vKnot,attr,omitempty""`
    VOrder *int32 `xml:"vOrder,attr,omitempty""`
    Weight []float64 `xml:"weight,attr,omitempty""`
}

func (n *NurbsSurfaceInterpolator) GetNodeName() string { return "NurbsSurfaceInterpolator" }
func (n *NurbsSurfaceInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsSurfaceInterpolator" }
func (n *NurbsSurfaceInterpolator) Validate() error {
    if n.ControlPoint != nil {
        if err := n.ControlPoint.Validate(); err != nil { return fmt.Errorf("validation error in ControlPoint: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsSurfaceInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.NormalChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normal_changed"}, Value: fmt.Sprintf("%v", *n.NormalChanged)}) }
    if n.PositionChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position_changed"}, Value: fmt.Sprintf("%v", *n.PositionChanged)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.UDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uDimension"}, Value: fmt.Sprintf("%v", *n.UDimension)}) }
    if n.UKnot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uKnot"}, Value: fmt.Sprintf("%v", n.UKnot)}) }
    if n.UOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uOrder"}, Value: fmt.Sprintf("%v", *n.UOrder)}) }
    if n.VDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vDimension"}, Value: fmt.Sprintf("%v", *n.VDimension)}) }
    if n.VKnot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vKnot"}, Value: fmt.Sprintf("%v", n.VKnot)}) }
    if n.VOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vOrder"}, Value: fmt.Sprintf("%v", *n.VOrder)}) }
    if n.Weight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weight"}, Value: fmt.Sprintf("%v", n.Weight)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.ControlPoint != nil {
        if err := e.EncodeElement(n.ControlPoint, xml.StartElement{Name: xml.Name{Local: n.ControlPoint.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsSweptSurface: NurbsSweptSurface uses a trajectoryCurve path to describe a generalized surface that is swept by a crossSectionCurve.
type NurbsSweptSurface struct {
    CoreX3DNode
    Ccw *bool `xml:"ccw,attr,omitempty""`
    CrossSectionCurve X3DNode `xml:"crossSectionCurve,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TrajectoryCurve X3DNode `xml:"trajectoryCurve,omitempty""`
}

func (n *NurbsSweptSurface) GetNodeName() string { return "NurbsSweptSurface" }
func (n *NurbsSweptSurface) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsSweptSurface" }
func (n *NurbsSweptSurface) Validate() error {
    if n.CrossSectionCurve != nil {
        if err := n.CrossSectionCurve.Validate(); err != nil { return fmt.Errorf("validation error in CrossSectionCurve: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TrajectoryCurve != nil {
        if err := n.TrajectoryCurve.Validate(); err != nil { return fmt.Errorf("validation error in TrajectoryCurve: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsSweptSurface) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.CrossSectionCurve != nil {
        if err := e.EncodeElement(n.CrossSectionCurve, xml.StartElement{Name: xml.Name{Local: n.CrossSectionCurve.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TrajectoryCurve != nil {
        if err := e.EncodeElement(n.TrajectoryCurve, xml.StartElement{Name: xml.Name{Local: n.TrajectoryCurve.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsSwungSurface: NurbsSwungSurface contains a profileCurve and a trajectoryCurve [X3DNurbsControlCurveNode].
type NurbsSwungSurface struct {
    CoreX3DNode
    Ccw *bool `xml:"ccw,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    ProfileCurve X3DNode `xml:"profileCurve,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TrajectoryCurve X3DNode `xml:"trajectoryCurve,omitempty""`
}

func (n *NurbsSwungSurface) GetNodeName() string { return "NurbsSwungSurface" }
func (n *NurbsSwungSurface) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsSwungSurface" }
func (n *NurbsSwungSurface) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.ProfileCurve != nil {
        if err := n.ProfileCurve.Validate(); err != nil { return fmt.Errorf("validation error in ProfileCurve: %w", err) }
    }
    if n.TrajectoryCurve != nil {
        if err := n.TrajectoryCurve.Validate(); err != nil { return fmt.Errorf("validation error in TrajectoryCurve: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsSwungSurface) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.ProfileCurve != nil {
        if err := e.EncodeElement(n.ProfileCurve, xml.StartElement{Name: xml.Name{Local: n.ProfileCurve.GetNodeName()}}); err != nil { return err }
    }
    if n.TrajectoryCurve != nil {
        if err := e.EncodeElement(n.TrajectoryCurve, xml.StartElement{Name: xml.Name{Local: n.TrajectoryCurve.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsTextureCoordinate: NurbsTextureCoordinate describes a 3D NURBS surface in the parametric domain of its surface host, specifying mapping of texture onto the surface.
type NurbsTextureCoordinate struct {
    CoreX3DNode
    ControlPoint *MFVec2f `xml:"controlPoint,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    UDimension *int32 `xml:"uDimension,attr,omitempty""`
    UKnot []float64 `xml:"uKnot,attr,omitempty""`
    UOrder *int32 `xml:"uOrder,attr,omitempty""`
    VDimension *int32 `xml:"vDimension,attr,omitempty""`
    VKnot []float64 `xml:"vKnot,attr,omitempty""`
    VOrder *int32 `xml:"vOrder,attr,omitempty""`
    Weight []float64 `xml:"weight,attr,omitempty""`
}

func (n *NurbsTextureCoordinate) GetNodeName() string { return "NurbsTextureCoordinate" }
func (n *NurbsTextureCoordinate) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsTextureCoordinate" }
func (n *NurbsTextureCoordinate) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsTextureCoordinate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ControlPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "controlPoint"}, Value: fmt.Sprintf("%v", *n.ControlPoint)}) }
    if n.UDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uDimension"}, Value: fmt.Sprintf("%v", *n.UDimension)}) }
    if n.UKnot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uKnot"}, Value: fmt.Sprintf("%v", n.UKnot)}) }
    if n.UOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uOrder"}, Value: fmt.Sprintf("%v", *n.UOrder)}) }
    if n.VDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vDimension"}, Value: fmt.Sprintf("%v", *n.VDimension)}) }
    if n.VKnot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vKnot"}, Value: fmt.Sprintf("%v", n.VKnot)}) }
    if n.VOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vOrder"}, Value: fmt.Sprintf("%v", *n.VOrder)}) }
    if n.Weight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weight"}, Value: fmt.Sprintf("%v", n.Weight)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// NurbsTrimmedSurface: NurbsTrimmedSurface generates texture coordinates from a Non-Uniform Rational B-Spline (NURBS) surface.
type NurbsTrimmedSurface struct {
    CoreX3DNode
    AddTrimmingContour []X3DNode `xml:",any""`
    ControlPoint X3DNode `xml:"controlPoint,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveTrimmingContour []X3DNode `xml:",any""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    TrimmingContour []X3DNode `xml:",any""`
    UClosed *bool `xml:"uClosed,attr,omitempty""`
    UDimension *int32 `xml:"uDimension,attr,omitempty""`
    UKnot []float64 `xml:"uKnot,attr,omitempty""`
    UOrder *int32 `xml:"uOrder,attr,omitempty""`
    UTessellation *int32 `xml:"uTessellation,attr,omitempty""`
    VClosed *bool `xml:"vClosed,attr,omitempty""`
    VDimension *int32 `xml:"vDimension,attr,omitempty""`
    VKnot []float64 `xml:"vKnot,attr,omitempty""`
    VOrder *int32 `xml:"vOrder,attr,omitempty""`
    VTessellation *int32 `xml:"vTessellation,attr,omitempty""`
    Weight []float64 `xml:"weight,attr,omitempty""`
}

func (n *NurbsTrimmedSurface) GetNodeName() string { return "NurbsTrimmedSurface" }
func (n *NurbsTrimmedSurface) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/nurbs.html#NurbsTrimmedSurface" }
func (n *NurbsTrimmedSurface) Validate() error {
    if n.AddTrimmingContour != nil {
        for i, child := range n.AddTrimmingContour { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddTrimmingContour[%d]: %w", i, err) } }
    }
    if n.ControlPoint != nil {
        if err := n.ControlPoint.Validate(); err != nil { return fmt.Errorf("validation error in ControlPoint: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveTrimmingContour != nil {
        for i, child := range n.RemoveTrimmingContour { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveTrimmingContour[%d]: %w", i, err) } }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.TrimmingContour != nil {
        for i, child := range n.TrimmingContour { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in TrimmingContour[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *NurbsTrimmedSurface) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.UClosed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uClosed"}, Value: fmt.Sprintf("%v", *n.UClosed)}) }
    if n.UDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uDimension"}, Value: fmt.Sprintf("%v", *n.UDimension)}) }
    if n.UKnot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uKnot"}, Value: fmt.Sprintf("%v", n.UKnot)}) }
    if n.UOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uOrder"}, Value: fmt.Sprintf("%v", *n.UOrder)}) }
    if n.UTessellation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "uTessellation"}, Value: fmt.Sprintf("%v", *n.UTessellation)}) }
    if n.VClosed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vClosed"}, Value: fmt.Sprintf("%v", *n.VClosed)}) }
    if n.VDimension != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vDimension"}, Value: fmt.Sprintf("%v", *n.VDimension)}) }
    if n.VKnot != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vKnot"}, Value: fmt.Sprintf("%v", n.VKnot)}) }
    if n.VOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vOrder"}, Value: fmt.Sprintf("%v", *n.VOrder)}) }
    if n.VTessellation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vTessellation"}, Value: fmt.Sprintf("%v", *n.VTessellation)}) }
    if n.Weight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "weight"}, Value: fmt.Sprintf("%v", n.Weight)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddTrimmingContour != nil {
        for _, child := range n.AddTrimmingContour { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.ControlPoint != nil {
        if err := e.EncodeElement(n.ControlPoint, xml.StartElement{Name: xml.Name{Local: n.ControlPoint.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveTrimmingContour != nil {
        for _, child := range n.RemoveTrimmingContour { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.TrimmingContour != nil {
        for _, child := range n.TrimmingContour { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// OpacityMapVolumeStyle: OpacityMapVolumeStyle specifies that volumetric data is rendered using opacity mapped to a transfer function texture.
type OpacityMapVolumeStyle struct {
    CoreX3DNode
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    TransferFunction X3DNode `xml:"transferFunction,omitempty""`
}

func (n *OpacityMapVolumeStyle) GetNodeName() string { return "OpacityMapVolumeStyle" }
func (n *OpacityMapVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#OpacityMapVolumeStyle" }
func (n *OpacityMapVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TransferFunction != nil {
        if err := n.TransferFunction.Validate(); err != nil { return fmt.Errorf("validation error in TransferFunction: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *OpacityMapVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TransferFunction != nil {
        if err := e.EncodeElement(n.TransferFunction, xml.StartElement{Name: xml.Name{Local: n.TransferFunction.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// OrientationChaser: OrientationChaser generates a series of 4-tuple axis-angle SFRotation values that progressively change from initial value to destination value.
type OrientationChaser struct {
    CoreX3DNode
    Duration *float64 `xml:"duration,attr,omitempty""`
    InitialDestination *SFRotation `xml:"initialDestination,attr,omitempty""`
    InitialValue *SFRotation `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    SetDestination *SFRotation `xml:"set_destination,attr,omitempty""`
    SetValue *SFRotation `xml:"set_value,attr,omitempty""`
    ValueChanged *SFRotation `xml:"value_changed,attr,omitempty""`
}

func (n *OrientationChaser) GetNodeName() string { return "OrientationChaser" }
func (n *OrientationChaser) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#OrientationChaser" }
func (n *OrientationChaser) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *OrientationChaser) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Duration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "duration"}, Value: fmt.Sprintf("%v", *n.Duration)}) }
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// OrientationDamper: OrientationDamper generates a series of 4-tuple axis-angle SFRotation values that progressively change from initial value to destination value.
type OrientationDamper struct {
    CoreX3DNode
    InitialDestination *SFRotation `xml:"initialDestination,attr,omitempty""`
    InitialValue *SFRotation `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    SetDestination *SFRotation `xml:"set_destination,attr,omitempty""`
    SetValue *SFRotation `xml:"set_value,attr,omitempty""`
    Tau *float64 `xml:"tau,attr,omitempty""`
    Tolerance *float32 `xml:"tolerance,attr,omitempty""`
    ValueChanged *SFRotation `xml:"value_changed,attr,omitempty""`
}

func (n *OrientationDamper) GetNodeName() string { return "OrientationDamper" }
func (n *OrientationDamper) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#OrientationDamper" }
func (n *OrientationDamper) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *OrientationDamper) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.Tau != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tau"}, Value: fmt.Sprintf("%v", *n.Tau)}) }
    if n.Tolerance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tolerance"}, Value: fmt.Sprintf("%v", *n.Tolerance)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// OrientationInterpolator: OrientationInterpolator generates a series of 4-tuple axis-angle SFRotation values.
type OrientationInterpolator struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFRotation `xml:"keyValue,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFRotation `xml:"value_changed,attr,omitempty""`
}

func (n *OrientationInterpolator) GetNodeName() string { return "OrientationInterpolator" }
func (n *OrientationInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#OrientationInterpolator" }
func (n *OrientationInterpolator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *OrientationInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// OrthoViewpoint: OrthoViewpoint provides an orthographic perspective-free view of a scene from a specific location and direction.
type OrthoViewpoint struct {
    CoreX3DNode
    BindTime *float64 `xml:"bindTime,attr,omitempty""`
    CenterOfRotation *SFVec3f `xml:"centerOfRotation,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    FarDistance *float32 `xml:"farDistance,attr,omitempty""`
    FieldOfView []float32 `xml:"fieldOfView,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsBound *bool `xml:"isBound,attr,omitempty""`
    Jump *bool `xml:"jump,attr,omitempty""`
    NavigationInfo X3DNode `xml:"navigationInfo,omitempty""`
    NearDistance *float32 `xml:"nearDistance,attr,omitempty""`
    Orientation *SFRotation `xml:"orientation,attr,omitempty""`
    Position *SFVec3f `xml:"position,attr,omitempty""`
    RetainUserOffsets *bool `xml:"retainUserOffsets,attr,omitempty""`
    SetBind *bool `xml:"set_bind,attr,omitempty""`
    ViewAll *bool `xml:"viewAll,attr,omitempty""`
}

func (n *OrthoViewpoint) GetNodeName() string { return "OrthoViewpoint" }
func (n *OrthoViewpoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#OrthoViewpoint" }
func (n *OrthoViewpoint) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.NavigationInfo != nil {
        if err := n.NavigationInfo.Validate(); err != nil { return fmt.Errorf("validation error in NavigationInfo: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *OrthoViewpoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BindTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bindTime"}, Value: fmt.Sprintf("%v", *n.BindTime)}) }
    if n.CenterOfRotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "centerOfRotation"}, Value: fmt.Sprintf("%v", *n.CenterOfRotation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.FarDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "farDistance"}, Value: fmt.Sprintf("%v", *n.FarDistance)}) }
    if n.FieldOfView != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fieldOfView"}, Value: fmt.Sprintf("%v", n.FieldOfView)}) }
    if n.IsBound != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isBound"}, Value: fmt.Sprintf("%v", *n.IsBound)}) }
    if n.Jump != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "jump"}, Value: fmt.Sprintf("%v", *n.Jump)}) }
    if n.NearDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "nearDistance"}, Value: fmt.Sprintf("%v", *n.NearDistance)}) }
    if n.Orientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orientation"}, Value: fmt.Sprintf("%v", *n.Orientation)}) }
    if n.Position != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position"}, Value: fmt.Sprintf("%v", *n.Position)}) }
    if n.RetainUserOffsets != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "retainUserOffsets"}, Value: fmt.Sprintf("%v", *n.RetainUserOffsets)}) }
    if n.SetBind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_bind"}, Value: fmt.Sprintf("%v", *n.SetBind)}) }
    if n.ViewAll != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "viewAll"}, Value: fmt.Sprintf("%v", *n.ViewAll)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.NavigationInfo != nil {
        if err := e.EncodeElement(n.NavigationInfo, xml.StartElement{Name: xml.Name{Local: n.NavigationInfo.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// OscillatorSource: OscillatorSource node represents an audio source generating a periodic waveform, providing a constant tone.
type OscillatorSource struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Detune *float32 `xml:"detune,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Frequency *float32 `xml:"frequency,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
}

func (n *OscillatorSource) GetNodeName() string { return "OscillatorSource" }
func (n *OscillatorSource) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#OscillatorSource" }
func (n *OscillatorSource) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *OscillatorSource) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Detune != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "detune"}, Value: fmt.Sprintf("%v", *n.Detune)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Frequency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frequency"}, Value: fmt.Sprintf("%v", *n.Frequency)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PackagedShader: PackagedShader can contain field declarations, but no CDATA section of plain-text source code.
type PackagedShader struct {
    CoreX3DNode
    Activate *bool `xml:"activate,attr,omitempty""`
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Field []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    IsSelected *bool `xml:"isSelected,attr,omitempty""`
    IsValid *bool `xml:"isValid,attr,omitempty""`
    Language *string `xml:"language,attr,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *PackagedShader) GetNodeName() string { return "PackagedShader" }
func (n *PackagedShader) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#PackagedShader" }
func (n *PackagedShader) Validate() error {
    if n.Field != nil {
        for i, child := range n.Field { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Field[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PackagedShader) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Activate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "activate"}, Value: fmt.Sprintf("%v", *n.Activate)}) }
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.IsSelected != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isSelected"}, Value: fmt.Sprintf("%v", *n.IsSelected)}) }
    if n.IsValid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isValid"}, Value: fmt.Sprintf("%v", *n.IsValid)}) }
    if n.Language != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "language"}, Value: fmt.Sprintf("%v", *n.Language)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Field != nil {
        for _, child := range n.Field { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ParticleSystem: ParticleSystem specifies a complete particle system.
type ParticleSystem struct {
    CoreX3DNode
    Appearance X3DNode `xml:"appearance,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    CastShadow *bool `xml:"castShadow,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorKey []float32 `xml:"colorKey,attr,omitempty""`
    CreateParticles *bool `xml:"createParticles,attr,omitempty""`
    Emitter X3DNode `xml:"emitter,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Geometry X3DNode `xml:"geometry,omitempty""`
    GeometryType *string `xml:"geometryType,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    LifetimeVariation *float32 `xml:"lifetimeVariation,attr,omitempty""`
    MaxParticles *int32 `xml:"maxParticles,attr,omitempty""`
    ParticleLifetime *float32 `xml:"particleLifetime,attr,omitempty""`
    ParticleSize *SFVec2f `xml:"particleSize,attr,omitempty""`
    Physics []X3DNode `xml:",any""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    TexCoordKey []float32 `xml:"texCoordKey,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    PointerEvents *bool `xml:"pointerEvents,attr,omitempty""`
}

func (n *ParticleSystem) GetNodeName() string { return "ParticleSystem" }
func (n *ParticleSystem) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#ParticleSystem" }
func (n *ParticleSystem) Validate() error {
    if n.Appearance != nil {
        if err := n.Appearance.Validate(); err != nil { return fmt.Errorf("validation error in Appearance: %w", err) }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Emitter != nil {
        if err := n.Emitter.Validate(); err != nil { return fmt.Errorf("validation error in Emitter: %w", err) }
    }
    if n.Geometry != nil {
        if err := n.Geometry.Validate(); err != nil { return fmt.Errorf("validation error in Geometry: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Physics != nil {
        for i, child := range n.Physics { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Physics[%d]: %w", i, err) } }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ParticleSystem) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.CastShadow != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "castShadow"}, Value: fmt.Sprintf("%v", *n.CastShadow)}) }
    if n.ColorKey != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorKey"}, Value: fmt.Sprintf("%v", n.ColorKey)}) }
    if n.CreateParticles != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "createParticles"}, Value: fmt.Sprintf("%v", *n.CreateParticles)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.GeometryType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geometryType"}, Value: fmt.Sprintf("%v", *n.GeometryType)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.LifetimeVariation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "lifetimeVariation"}, Value: fmt.Sprintf("%v", *n.LifetimeVariation)}) }
    if n.MaxParticles != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxParticles"}, Value: fmt.Sprintf("%v", *n.MaxParticles)}) }
    if n.ParticleLifetime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "particleLifetime"}, Value: fmt.Sprintf("%v", *n.ParticleLifetime)}) }
    if n.ParticleSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "particleSize"}, Value: fmt.Sprintf("%v", *n.ParticleSize)}) }
    if n.TexCoordKey != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "texCoordKey"}, Value: fmt.Sprintf("%v", n.TexCoordKey)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.PointerEvents != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pointerEvents"}, Value: fmt.Sprintf("%v", *n.PointerEvents)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Appearance != nil {
        if err := e.EncodeElement(n.Appearance, xml.StartElement{Name: xml.Name{Local: n.Appearance.GetNodeName()}}); err != nil { return err }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Emitter != nil {
        if err := e.EncodeElement(n.Emitter, xml.StartElement{Name: xml.Name{Local: n.Emitter.GetNodeName()}}); err != nil { return err }
    }
    if n.Geometry != nil {
        if err := e.EncodeElement(n.Geometry, xml.StartElement{Name: xml.Name{Local: n.Geometry.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Physics != nil {
        for _, child := range n.Physics { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PeriodicWave: PeriodicWave defines a periodic waveform that can be used to shape the output of an Oscillator.
type PeriodicWave struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    OptionsImag []float32 `xml:"optionsImag,attr,omitempty""`
    OptionsReal []float32 `xml:"optionsReal,attr,omitempty""`
    Type *string `xml:"type,attr,omitempty""`
}

func (n *PeriodicWave) GetNodeName() string { return "PeriodicWave" }
func (n *PeriodicWave) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#PeriodicWave" }
func (n *PeriodicWave) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Type != nil {
        switch *n.Type {
        case PeriodicWaveTypeChoicesSINE, PeriodicWaveTypeChoicesSQUARE, PeriodicWaveTypeChoicesSAWTOOTH, PeriodicWaveTypeChoicesTRIANGLE, PeriodicWaveTypeChoicesCUSTOM: // valid
        default: return fmt.Errorf("invalid value for field type: %s", *n.Type)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PeriodicWave) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.OptionsImag != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "optionsImag"}, Value: fmt.Sprintf("%v", n.OptionsImag)}) }
    if n.OptionsReal != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "optionsReal"}, Value: fmt.Sprintf("%v", n.OptionsReal)}) }
    if n.Type != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "type"}, Value: fmt.Sprintf("%v", *n.Type)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PhysicalMaterial: PhysicalMaterial specifies surface rendering properties for associated geometry nodes.
type PhysicalMaterial struct {
    CoreX3DNode
    BaseColor *SFColor `xml:"baseColor,attr,omitempty""`
    BaseTexture X3DNode `xml:"baseTexture,omitempty""`
    BaseTextureMapping *string `xml:"baseTextureMapping,attr,omitempty""`
    EmissiveColor *SFColor `xml:"emissiveColor,attr,omitempty""`
    EmissiveTexture X3DNode `xml:"emissiveTexture,omitempty""`
    EmissiveTextureMapping *string `xml:"emissiveTextureMapping,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Metallic *float32 `xml:"metallic,attr,omitempty""`
    MetallicRoughnessTexture X3DNode `xml:"metallicRoughnessTexture,omitempty""`
    MetallicRoughnessTextureMapping *string `xml:"metallicRoughnessTextureMapping,attr,omitempty""`
    NormalScale *float32 `xml:"normalScale,attr,omitempty""`
    NormalTexture X3DNode `xml:"normalTexture,omitempty""`
    NormalTextureMapping *string `xml:"normalTextureMapping,attr,omitempty""`
    OcclusionStrength *float32 `xml:"occlusionStrength,attr,omitempty""`
    OcclusionTexture X3DNode `xml:"occlusionTexture,omitempty""`
    OcclusionTextureMapping *string `xml:"occlusionTextureMapping,attr,omitempty""`
    Roughness *float32 `xml:"roughness,attr,omitempty""`
    Transparency *float32 `xml:"transparency,attr,omitempty""`
    Extensions []X3DNode `xml:",any""`
}

func (n *PhysicalMaterial) GetNodeName() string { return "PhysicalMaterial" }
func (n *PhysicalMaterial) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#PhysicalMaterial" }
func (n *PhysicalMaterial) Validate() error {
    if n.BaseTexture != nil {
        if err := n.BaseTexture.Validate(); err != nil { return fmt.Errorf("validation error in BaseTexture: %w", err) }
    }
    if n.EmissiveTexture != nil {
        if err := n.EmissiveTexture.Validate(); err != nil { return fmt.Errorf("validation error in EmissiveTexture: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.MetallicRoughnessTexture != nil {
        if err := n.MetallicRoughnessTexture.Validate(); err != nil { return fmt.Errorf("validation error in MetallicRoughnessTexture: %w", err) }
    }
    if n.NormalTexture != nil {
        if err := n.NormalTexture.Validate(); err != nil { return fmt.Errorf("validation error in NormalTexture: %w", err) }
    }
    if n.OcclusionTexture != nil {
        if err := n.OcclusionTexture.Validate(); err != nil { return fmt.Errorf("validation error in OcclusionTexture: %w", err) }
    }
    if n.Extensions != nil {
        for i, child := range n.Extensions { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Extensions[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PhysicalMaterial) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BaseColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "baseColor"}, Value: fmt.Sprintf("%v", *n.BaseColor)}) }
    if n.BaseTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "baseTextureMapping"}, Value: fmt.Sprintf("%v", *n.BaseTextureMapping)}) }
    if n.EmissiveColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveColor"}, Value: fmt.Sprintf("%v", *n.EmissiveColor)}) }
    if n.EmissiveTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveTextureMapping"}, Value: fmt.Sprintf("%v", *n.EmissiveTextureMapping)}) }
    if n.Metallic != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "metallic"}, Value: fmt.Sprintf("%v", *n.Metallic)}) }
    if n.MetallicRoughnessTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "metallicRoughnessTextureMapping"}, Value: fmt.Sprintf("%v", *n.MetallicRoughnessTextureMapping)}) }
    if n.NormalScale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalScale"}, Value: fmt.Sprintf("%v", *n.NormalScale)}) }
    if n.NormalTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalTextureMapping"}, Value: fmt.Sprintf("%v", *n.NormalTextureMapping)}) }
    if n.OcclusionStrength != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "occlusionStrength"}, Value: fmt.Sprintf("%v", *n.OcclusionStrength)}) }
    if n.OcclusionTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "occlusionTextureMapping"}, Value: fmt.Sprintf("%v", *n.OcclusionTextureMapping)}) }
    if n.Roughness != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "roughness"}, Value: fmt.Sprintf("%v", *n.Roughness)}) }
    if n.Transparency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transparency"}, Value: fmt.Sprintf("%v", *n.Transparency)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.BaseTexture != nil {
        if err := e.EncodeElement(n.BaseTexture, xml.StartElement{Name: xml.Name{Local: n.BaseTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.EmissiveTexture != nil {
        if err := e.EncodeElement(n.EmissiveTexture, xml.StartElement{Name: xml.Name{Local: n.EmissiveTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.MetallicRoughnessTexture != nil {
        if err := e.EncodeElement(n.MetallicRoughnessTexture, xml.StartElement{Name: xml.Name{Local: n.MetallicRoughnessTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.NormalTexture != nil {
        if err := e.EncodeElement(n.NormalTexture, xml.StartElement{Name: xml.Name{Local: n.NormalTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.OcclusionTexture != nil {
        if err := e.EncodeElement(n.OcclusionTexture, xml.StartElement{Name: xml.Name{Local: n.OcclusionTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.Extensions != nil {
        for _, child := range n.Extensions { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// PickableGroup: PickableGroup is a Grouping node that can contain most nodes.
type PickableGroup struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    ObjectType []string `xml:"objectType,attr,omitempty""`
    Pickable *bool `xml:"pickable,attr,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *PickableGroup) GetNodeName() string { return "PickableGroup" }
func (n *PickableGroup) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#PickableGroup" }
func (n *PickableGroup) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PickableGroup) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ObjectType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "objectType"}, Value: fmt.Sprintf("%v", n.ObjectType)}) }
    if n.Pickable != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pickable"}, Value: fmt.Sprintf("%v", *n.Pickable)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// PixelTexture: PixelTexture creates a 2D-image texture map using a numeric array of pixel values.
type PixelTexture struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Image *SFImage `xml:"image,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RepeatS *bool `xml:"repeatS,attr,omitempty""`
    RepeatT *bool `xml:"repeatT,attr,omitempty""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
}

func (n *PixelTexture) GetNodeName() string { return "PixelTexture" }
func (n *PixelTexture) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#PixelTexture" }
func (n *PixelTexture) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PixelTexture) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Image != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "image"}, Value: fmt.Sprintf("%v", *n.Image)}) }
    if n.RepeatS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatS"}, Value: fmt.Sprintf("%v", *n.RepeatS)}) }
    if n.RepeatT != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatT"}, Value: fmt.Sprintf("%v", *n.RepeatT)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PixelTexture3D: PixelTexture3D defines a 3D image-based texture map as an explicit array of pixel values (image field).
type PixelTexture3D struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Image []int32 `xml:"image,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RepeatR *bool `xml:"repeatR,attr,omitempty""`
    RepeatS *bool `xml:"repeatS,attr,omitempty""`
    RepeatT *bool `xml:"repeatT,attr,omitempty""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
}

func (n *PixelTexture3D) GetNodeName() string { return "PixelTexture3D" }
func (n *PixelTexture3D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#PixelTexture3D" }
func (n *PixelTexture3D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PixelTexture3D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Image != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "image"}, Value: fmt.Sprintf("%v", n.Image)}) }
    if n.RepeatR != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatR"}, Value: fmt.Sprintf("%v", *n.RepeatR)}) }
    if n.RepeatS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatS"}, Value: fmt.Sprintf("%v", *n.RepeatS)}) }
    if n.RepeatT != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatT"}, Value: fmt.Sprintf("%v", *n.RepeatT)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PlaneSensor: PlaneSensor converts pointing device motion into 2D translation parallel to the local Z=0 plane.
type PlaneSensor struct {
    CoreX3DNode
    AutoOffset *bool `xml:"autoOffset,attr,omitempty""`
    AxisRotation *SFRotation `xml:"axisRotation,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsOver *bool `xml:"isOver,attr,omitempty""`
    MaxPosition *SFVec2f `xml:"maxPosition,attr,omitempty""`
    MinPosition *SFVec2f `xml:"minPosition,attr,omitempty""`
    Offset *SFVec3f `xml:"offset,attr,omitempty""`
    TrackPointChanged *SFVec3f `xml:"trackPoint_changed,attr,omitempty""`
    TranslationChanged *SFVec3f `xml:"translation_changed,attr,omitempty""`
}

func (n *PlaneSensor) GetNodeName() string { return "PlaneSensor" }
func (n *PlaneSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#PlaneSensor" }
func (n *PlaneSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PlaneSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoOffset != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoOffset"}, Value: fmt.Sprintf("%v", *n.AutoOffset)}) }
    if n.AxisRotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axisRotation"}, Value: fmt.Sprintf("%v", *n.AxisRotation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsOver != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isOver"}, Value: fmt.Sprintf("%v", *n.IsOver)}) }
    if n.MaxPosition != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxPosition"}, Value: fmt.Sprintf("%v", *n.MaxPosition)}) }
    if n.MinPosition != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minPosition"}, Value: fmt.Sprintf("%v", *n.MinPosition)}) }
    if n.Offset != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "offset"}, Value: fmt.Sprintf("%v", *n.Offset)}) }
    if n.TrackPointChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "trackPoint_changed"}, Value: fmt.Sprintf("%v", *n.TrackPointChanged)}) }
    if n.TranslationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation_changed"}, Value: fmt.Sprintf("%v", *n.TranslationChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PointEmitter: PointEmitter generates particles from a specific point in space using the specified direction and speed.
type PointEmitter struct {
    CoreX3DNode
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Mass *float32 `xml:"mass,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    Position *SFVec3f `xml:"position,attr,omitempty""`
    Speed *float32 `xml:"speed,attr,omitempty""`
    SurfaceArea *float32 `xml:"surfaceArea,attr,omitempty""`
    Variation *float32 `xml:"variation,attr,omitempty""`
}

func (n *PointEmitter) GetNodeName() string { return "PointEmitter" }
func (n *PointEmitter) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#PointEmitter" }
func (n *PointEmitter) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PointEmitter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.Mass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mass"}, Value: fmt.Sprintf("%v", *n.Mass)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.Position != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position"}, Value: fmt.Sprintf("%v", *n.Position)}) }
    if n.Speed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speed"}, Value: fmt.Sprintf("%v", *n.Speed)}) }
    if n.SurfaceArea != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceArea"}, Value: fmt.Sprintf("%v", *n.SurfaceArea)}) }
    if n.Variation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "variation"}, Value: fmt.Sprintf("%v", *n.Variation)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PointLight: Linear attenuation may occur at level 2, full support at level 3.
type PointLight struct {
    CoreX3DNode
    AmbientIntensity *float32 `xml:"ambientIntensity,attr,omitempty""`
    Attenuation *SFVec3f `xml:"attenuation,attr,omitempty""`
    Color *SFColor `xml:"color,attr,omitempty""`
    Global *bool `xml:"global,attr,omitempty""`
    Intensity *float32 `xml:"intensity,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Location *SFVec3f `xml:"location,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    Radius *float32 `xml:"radius,attr,omitempty""`
    ShadowIntensity *float32 `xml:"shadowIntensity,attr,omitempty""`
    Shadows *bool `xml:"shadows,attr,omitempty""`
}

func (n *PointLight) GetNodeName() string { return "PointLight" }
func (n *PointLight) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/lighting.html#PointLight" }
func (n *PointLight) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PointLight) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AmbientIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ambientIntensity"}, Value: fmt.Sprintf("%v", *n.AmbientIntensity)}) }
    if n.Attenuation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "attenuation"}, Value: fmt.Sprintf("%v", *n.Attenuation)}) }
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.Global != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "global"}, Value: fmt.Sprintf("%v", *n.Global)}) }
    if n.Intensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intensity"}, Value: fmt.Sprintf("%v", *n.Intensity)}) }
    if n.Location != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "location"}, Value: fmt.Sprintf("%v", *n.Location)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.Radius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radius"}, Value: fmt.Sprintf("%v", *n.Radius)}) }
    if n.ShadowIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadowIntensity"}, Value: fmt.Sprintf("%v", *n.ShadowIntensity)}) }
    if n.Shadows != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadows"}, Value: fmt.Sprintf("%v", *n.Shadows)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PointPickSensor: PointPickSensor tests one or more pickingGeometry points in space as lying inside the provided pickTarget geometry.
type PointPickSensor struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IntersectionType *string `xml:"intersectionType,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    MatchCriterion *string `xml:"matchCriterion,attr,omitempty""`
    ObjectType []string `xml:"objectType,attr,omitempty""`
    PickedGeometry []X3DNode `xml:",any""`
    PickedPoint *MFVec3f `xml:"pickedPoint,attr,omitempty""`
    PickingGeometry X3DNode `xml:"pickingGeometry,omitempty""`
    PickTarget []X3DNode `xml:",any""`
    SortOrder *string `xml:"sortOrder,attr,omitempty""`
}

func (n *PointPickSensor) GetNodeName() string { return "PointPickSensor" }
func (n *PointPickSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#PointPickSensor" }
func (n *PointPickSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.MatchCriterion != nil {
        switch *n.MatchCriterion {
        case PickSensorMatchCriterionChoicesMATCHANY, PickSensorMatchCriterionChoicesMATCHEVERY, PickSensorMatchCriterionChoicesMATCHONLYONE: // valid
        default: return fmt.Errorf("invalid value for field matchCriterion: %s", *n.MatchCriterion)
        }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.PickedGeometry != nil {
        for i, child := range n.PickedGeometry { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in PickedGeometry[%d]: %w", i, err) } }
    }
    if n.PickingGeometry != nil {
        if err := n.PickingGeometry.Validate(); err != nil { return fmt.Errorf("validation error in PickingGeometry: %w", err) }
    }
    if n.PickTarget != nil {
        for i, child := range n.PickTarget { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in PickTarget[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PointPickSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IntersectionType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intersectionType"}, Value: fmt.Sprintf("%v", *n.IntersectionType)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.MatchCriterion != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "matchCriterion"}, Value: fmt.Sprintf("%v", *n.MatchCriterion)}) }
    if n.ObjectType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "objectType"}, Value: fmt.Sprintf("%v", n.ObjectType)}) }
    if n.PickedPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pickedPoint"}, Value: fmt.Sprintf("%v", *n.PickedPoint)}) }
    if n.SortOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sortOrder"}, Value: fmt.Sprintf("%v", *n.SortOrder)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.PickedGeometry != nil {
        for _, child := range n.PickedGeometry { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.PickingGeometry != nil {
        if err := e.EncodeElement(n.PickingGeometry, xml.StartElement{Name: xml.Name{Local: n.PickingGeometry.GetNodeName()}}); err != nil { return err }
    }
    if n.PickTarget != nil {
        for _, child := range n.PickTarget { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// PointProperties: PointProperties allows precise fine-grained control over the rendering style of PointSet node points inside the same Shape.
type PointProperties struct {
    CoreX3DNode
    Attenuation *SFVec3f `xml:"attenuation,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    PointSizeMaxValue *float32 `xml:"pointSizeMaxValue,attr,omitempty""`
    PointSizeMinValue *float32 `xml:"pointSizeMinValue,attr,omitempty""`
    PointSizeScaleFactor *float32 `xml:"pointSizeScaleFactor,attr,omitempty""`
}

func (n *PointProperties) GetNodeName() string { return "PointProperties" }
func (n *PointProperties) GetSpecificationURL() string { return "https://github.com/Web3DConsortium/X3D/blob/master/ISO-IEC19775/ISO-IEC19775-1/ISO-IEC19775-1v4.0/ISO-IEC19775-1v4-WD1/Part01/components/shape.html" }
func (n *PointProperties) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PointProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Attenuation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "attenuation"}, Value: fmt.Sprintf("%v", *n.Attenuation)}) }
    if n.PointSizeMaxValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pointSizeMaxValue"}, Value: fmt.Sprintf("%v", *n.PointSizeMaxValue)}) }
    if n.PointSizeMinValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pointSizeMinValue"}, Value: fmt.Sprintf("%v", *n.PointSizeMinValue)}) }
    if n.PointSizeScaleFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pointSizeScaleFactor"}, Value: fmt.Sprintf("%v", *n.PointSizeScaleFactor)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PointSet: PointSet is a node that contains a set of colored 3D points, represented by contained Color|ColorRGBA and Coordinate|CoordinateDouble nodes.
type PointSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Color X3DNode `xml:"color,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *PointSet) GetNodeName() string { return "PointSet" }
func (n *PointSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#PointSet" }
func (n *PointSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PointSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Polyline2D: Polyline2D is a geometry node that defines a connected set of vertices in a contiguous set of line segments in X-Y plane.
type Polyline2D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    LineSegments *MFVec2f `xml:"lineSegments,attr,omitempty""`
}

func (n *Polyline2D) GetNodeName() string { return "Polyline2D" }
func (n *Polyline2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Polyline2D" }
func (n *Polyline2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Polyline2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.LineSegments != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "lineSegments"}, Value: fmt.Sprintf("%v", *n.LineSegments)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PolylineEmitter: PolylineEmitter emits particles along a single polyline.
type PolylineEmitter struct {
    CoreX3DNode
    Coord X3DNode `xml:"coord,omitempty""`
    CoordIndex []int32 `xml:"coordIndex,attr,omitempty""`
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Mass *float32 `xml:"mass,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    SetCoordIndex []int32 `xml:"set_coordIndex,attr,omitempty""`
    Speed *float32 `xml:"speed,attr,omitempty""`
    SurfaceArea *float32 `xml:"surfaceArea,attr,omitempty""`
    Variation *float32 `xml:"variation,attr,omitempty""`
}

func (n *PolylineEmitter) GetNodeName() string { return "PolylineEmitter" }
func (n *PolylineEmitter) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#PolylineEmitter" }
func (n *PolylineEmitter) Validate() error {
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PolylineEmitter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.CoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "coordIndex"}, Value: fmt.Sprintf("%v", n.CoordIndex)}) }
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.Mass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mass"}, Value: fmt.Sprintf("%v", *n.Mass)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.SetCoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_coordIndex"}, Value: fmt.Sprintf("%v", n.SetCoordIndex)}) }
    if n.Speed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speed"}, Value: fmt.Sprintf("%v", *n.Speed)}) }
    if n.SurfaceArea != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceArea"}, Value: fmt.Sprintf("%v", *n.SurfaceArea)}) }
    if n.Variation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "variation"}, Value: fmt.Sprintf("%v", *n.Variation)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Polypoint2D: Polypoint2D is a geometry node that defines a set of 2D points in X-Y plane.
type Polypoint2D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Point *MFVec2f `xml:"point,attr,omitempty""`
}

func (n *Polypoint2D) GetNodeName() string { return "Polypoint2D" }
func (n *Polypoint2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Polypoint2D" }
func (n *Polypoint2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Polypoint2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Point != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "point"}, Value: fmt.Sprintf("%v", *n.Point)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PositionChaser: PositionChaser generates a series of position values that progressively change from initial value to destination value.
type PositionChaser struct {
    CoreX3DNode
    Duration *float64 `xml:"duration,attr,omitempty""`
    InitialDestination *SFVec3f `xml:"initialDestination,attr,omitempty""`
    InitialValue *SFVec3f `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    SetDestination *SFVec3f `xml:"set_destination,attr,omitempty""`
    SetValue *SFVec3f `xml:"set_value,attr,omitempty""`
    ValueChanged *SFVec3f `xml:"value_changed,attr,omitempty""`
}

func (n *PositionChaser) GetNodeName() string { return "PositionChaser" }
func (n *PositionChaser) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#PositionChaser" }
func (n *PositionChaser) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PositionChaser) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Duration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "duration"}, Value: fmt.Sprintf("%v", *n.Duration)}) }
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PositionChaser2D: PositionChaser2D generates a series of 2D position values that progressively change from initial value to destination value.
type PositionChaser2D struct {
    CoreX3DNode
    Duration *float64 `xml:"duration,attr,omitempty""`
    InitialDestination *SFVec2f `xml:"initialDestination,attr,omitempty""`
    InitialValue *SFVec2f `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    SetDestination *SFVec2f `xml:"set_destination,attr,omitempty""`
    SetValue *SFVec2f `xml:"set_value,attr,omitempty""`
    ValueChanged *SFVec2f `xml:"value_changed,attr,omitempty""`
}

func (n *PositionChaser2D) GetNodeName() string { return "PositionChaser2D" }
func (n *PositionChaser2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#PositionChaser2D" }
func (n *PositionChaser2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PositionChaser2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Duration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "duration"}, Value: fmt.Sprintf("%v", *n.Duration)}) }
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PositionDamper: PositionDamper generates a series of position values that progressively change from initial value to destination value.
type PositionDamper struct {
    CoreX3DNode
    InitialDestination *SFVec3f `xml:"initialDestination,attr,omitempty""`
    InitialValue *SFVec3f `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    SetDestination *SFVec3f `xml:"set_destination,attr,omitempty""`
    SetValue *SFVec3f `xml:"set_value,attr,omitempty""`
    Tau *float64 `xml:"tau,attr,omitempty""`
    Tolerance *float32 `xml:"tolerance,attr,omitempty""`
    ValueChanged *SFVec3f `xml:"value_changed,attr,omitempty""`
}

func (n *PositionDamper) GetNodeName() string { return "PositionDamper" }
func (n *PositionDamper) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#PositionDamper" }
func (n *PositionDamper) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PositionDamper) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.Tau != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tau"}, Value: fmt.Sprintf("%v", *n.Tau)}) }
    if n.Tolerance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tolerance"}, Value: fmt.Sprintf("%v", *n.Tolerance)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PositionDamper2D: PositionDamper2D generates a series of 2D floating-point values that progressively change from initial value to destination value.
type PositionDamper2D struct {
    CoreX3DNode
    InitialDestination *SFVec2f `xml:"initialDestination,attr,omitempty""`
    InitialValue *SFVec2f `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    SetDestination *SFVec2f `xml:"set_destination,attr,omitempty""`
    SetValue *SFVec2f `xml:"set_value,attr,omitempty""`
    Tau *float64 `xml:"tau,attr,omitempty""`
    Tolerance *float32 `xml:"tolerance,attr,omitempty""`
    ValueChanged *SFVec2f `xml:"value_changed,attr,omitempty""`
}

func (n *PositionDamper2D) GetNodeName() string { return "PositionDamper2D" }
func (n *PositionDamper2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#PositionDamper2D" }
func (n *PositionDamper2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PositionDamper2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.Tau != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tau"}, Value: fmt.Sprintf("%v", *n.Tau)}) }
    if n.Tolerance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tolerance"}, Value: fmt.Sprintf("%v", *n.Tolerance)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PositionInterpolator: PositionInterpolator generates a series of 3-tuple SFVec3f values.
type PositionInterpolator struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFVec3f `xml:"keyValue,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFVec3f `xml:"value_changed,attr,omitempty""`
}

func (n *PositionInterpolator) GetNodeName() string { return "PositionInterpolator" }
func (n *PositionInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#PositionInterpolator" }
func (n *PositionInterpolator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PositionInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PositionInterpolator2D: PositionInterpolator2D generates a series of SFVec2f values.
type PositionInterpolator2D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFVec2f `xml:"keyValue,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFVec2f `xml:"value_changed,attr,omitempty""`
}

func (n *PositionInterpolator2D) GetNodeName() string { return "PositionInterpolator2D" }
func (n *PositionInterpolator2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#PositionInterpolator2D" }
func (n *PositionInterpolator2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PositionInterpolator2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// PrimitivePickSensor: If a non-uniform scale is applied to the pick sensor, correct results may require level 3 support.
type PrimitivePickSensor struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IntersectionType *string `xml:"intersectionType,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    MatchCriterion *string `xml:"matchCriterion,attr,omitempty""`
    ObjectType []string `xml:"objectType,attr,omitempty""`
    PickedGeometry []X3DNode `xml:",any""`
    PickingGeometry X3DNode `xml:"pickingGeometry,omitempty""`
    PickTarget []X3DNode `xml:",any""`
    SortOrder *string `xml:"sortOrder,attr,omitempty""`
}

func (n *PrimitivePickSensor) GetNodeName() string { return "PrimitivePickSensor" }
func (n *PrimitivePickSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#PrimitivePickSensor" }
func (n *PrimitivePickSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.MatchCriterion != nil {
        switch *n.MatchCriterion {
        case PickSensorMatchCriterionChoicesMATCHANY, PickSensorMatchCriterionChoicesMATCHEVERY, PickSensorMatchCriterionChoicesMATCHONLYONE: // valid
        default: return fmt.Errorf("invalid value for field matchCriterion: %s", *n.MatchCriterion)
        }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.PickedGeometry != nil {
        for i, child := range n.PickedGeometry { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in PickedGeometry[%d]: %w", i, err) } }
    }
    if n.PickingGeometry != nil {
        if err := n.PickingGeometry.Validate(); err != nil { return fmt.Errorf("validation error in PickingGeometry: %w", err) }
    }
    if n.PickTarget != nil {
        for i, child := range n.PickTarget { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in PickTarget[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *PrimitivePickSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IntersectionType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intersectionType"}, Value: fmt.Sprintf("%v", *n.IntersectionType)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.MatchCriterion != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "matchCriterion"}, Value: fmt.Sprintf("%v", *n.MatchCriterion)}) }
    if n.ObjectType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "objectType"}, Value: fmt.Sprintf("%v", n.ObjectType)}) }
    if n.SortOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sortOrder"}, Value: fmt.Sprintf("%v", *n.SortOrder)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.PickedGeometry != nil {
        for _, child := range n.PickedGeometry { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.PickingGeometry != nil {
        if err := e.EncodeElement(n.PickingGeometry, xml.StartElement{Name: xml.Name{Local: n.PickingGeometry.GetNodeName()}}); err != nil { return err }
    }
    if n.PickTarget != nil {
        for _, child := range n.PickTarget { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// ProgramShader: ProgramShader contains no field declarations and no plain-text source code.
type ProgramShader struct {
    CoreX3DNode
    Activate *bool `xml:"activate,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsSelected *bool `xml:"isSelected,attr,omitempty""`
    IsValid *bool `xml:"isValid,attr,omitempty""`
    Language *string `xml:"language,attr,omitempty""`
    Programs []X3DNode `xml:",any""`
}

func (n *ProgramShader) GetNodeName() string { return "ProgramShader" }
func (n *ProgramShader) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#ProgramShader" }
func (n *ProgramShader) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Programs != nil {
        for i, child := range n.Programs { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Programs[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ProgramShader) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Activate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "activate"}, Value: fmt.Sprintf("%v", *n.Activate)}) }
    if n.IsSelected != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isSelected"}, Value: fmt.Sprintf("%v", *n.IsSelected)}) }
    if n.IsValid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isValid"}, Value: fmt.Sprintf("%v", *n.IsValid)}) }
    if n.Language != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "language"}, Value: fmt.Sprintf("%v", *n.Language)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Programs != nil {
        for _, child := range n.Programs { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// ProjectionVolumeStyle: ProjectionVolumeStyle uses voxel data to directly generate output color.
type ProjectionVolumeStyle struct {
    CoreX3DNode
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IntensityThreshold *float32 `xml:"intensityThreshold,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Type *string `xml:"type,attr,omitempty""`
}

func (n *ProjectionVolumeStyle) GetNodeName() string { return "ProjectionVolumeStyle" }
func (n *ProjectionVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#ProjectionVolumeStyle" }
func (n *ProjectionVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Type != nil {
        switch *n.Type {
        case ProjectionVolumeStyleTypeChoicesMAX, ProjectionVolumeStyleTypeChoicesMIN, ProjectionVolumeStyleTypeChoicesAVERAGE: // valid
        default: return fmt.Errorf("invalid value for field type: %s", *n.Type)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ProjectionVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IntensityThreshold != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intensityThreshold"}, Value: fmt.Sprintf("%v", *n.IntensityThreshold)}) }
    if n.Type != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "type"}, Value: fmt.Sprintf("%v", *n.Type)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ProtoInstance: ProtoInstance can override field default values via fieldValue initializations. Non-recursive nested ProtoInstance and ProtoDeclare statements are allowed within a ProtoDeclare.
type ProtoInstance struct {
    CoreX3DNode
    FieldValue []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Name *string `xml:"name,attr,omitempty""`
}

func (n *ProtoInstance) GetNodeName() string { return "ProtoInstance" }
func (n *ProtoInstance) GetSpecificationURL() string { return "https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#ProtoInstanceAndFieldValueStatement" }
func (n *ProtoInstance) Validate() error {
    if n.FieldValue != nil {
        for i, child := range n.FieldValue { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in FieldValue[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ProtoInstance) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Name != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "name"}, Value: fmt.Sprintf("%v", *n.Name)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.FieldValue != nil {
        for _, child := range n.FieldValue { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ProximitySensor: ProximitySensor generates events when the viewer enters, exits and moves within a region of space (defined by a box).
type ProximitySensor struct {
    CoreX3DNode
    Center *SFVec3f `xml:"center,attr,omitempty""`
    CenterOfRotationChanged *SFVec3f `xml:"centerOfRotation_changed,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EnterTime *float64 `xml:"enterTime,attr,omitempty""`
    ExitTime *float64 `xml:"exitTime,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    OrientationChanged *SFRotation `xml:"orientation_changed,attr,omitempty""`
    PositionChanged *SFVec3f `xml:"position_changed,attr,omitempty""`
    Size *SFVec3f `xml:"size,attr,omitempty""`
}

func (n *ProximitySensor) GetNodeName() string { return "ProximitySensor" }
func (n *ProximitySensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalSensor.html#ProximitySensor" }
func (n *ProximitySensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ProximitySensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.CenterOfRotationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "centerOfRotation_changed"}, Value: fmt.Sprintf("%v", *n.CenterOfRotationChanged)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EnterTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enterTime"}, Value: fmt.Sprintf("%v", *n.EnterTime)}) }
    if n.ExitTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "exitTime"}, Value: fmt.Sprintf("%v", *n.ExitTime)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.OrientationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orientation_changed"}, Value: fmt.Sprintf("%v", *n.OrientationChanged)}) }
    if n.PositionChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position_changed"}, Value: fmt.Sprintf("%v", *n.PositionChanged)}) }
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", *n.Size)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// QuadSet: QuadSet is a geometry node that defines quadrilaterals.
type QuadSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *QuadSet) GetNodeName() string { return "QuadSet" }
func (n *QuadSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/CADGeometry.html#QuadSet" }
func (n *QuadSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *QuadSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ReceiverPdu: ReceiverPdu is a networked Protocol Data Unit (PDU) information node that transmits the state of radio frequency (RF) receivers modeled in a simulation.
type ReceiverPdu struct {
    CoreX3DNode
    Address *string `xml:"address,attr,omitempty""`
    ApplicationID *int32 `xml:"applicationID,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EntityID *int32 `xml:"entityID,attr,omitempty""`
    GeoCoords *SFVec3d `xml:"geoCoords,attr,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsNetworkReader *bool `xml:"isNetworkReader,attr,omitempty""`
    IsNetworkWriter *bool `xml:"isNetworkWriter,attr,omitempty""`
    IsRtpHeaderHeard *bool `xml:"isRtpHeaderHeard,attr,omitempty""`
    IsStandAlone *bool `xml:"isStandAlone,attr,omitempty""`
    MulticastRelayHost *string `xml:"multicastRelayHost,attr,omitempty""`
    MulticastRelayPort *int32 `xml:"multicastRelayPort,attr,omitempty""`
    NetworkMode *string `xml:"networkMode,attr,omitempty""`
    Port *int32 `xml:"port,attr,omitempty""`
    RadioID *int32 `xml:"radioID,attr,omitempty""`
    ReadInterval *float64 `xml:"readInterval,attr,omitempty""`
    ReceivedPower *float32 `xml:"receivedPower,attr,omitempty""`
    ReceiverState *int32 `xml:"receiverState,attr,omitempty""`
    RtpHeaderExpected *bool `xml:"rtpHeaderExpected,attr,omitempty""`
    SiteID *int32 `xml:"siteID,attr,omitempty""`
    Timestamp *float64 `xml:"timestamp,attr,omitempty""`
    TransmitterApplicationID *int32 `xml:"transmitterApplicationID,attr,omitempty""`
    TransmitterEntityID *int32 `xml:"transmitterEntityID,attr,omitempty""`
    TransmitterRadioID *int32 `xml:"transmitterRadioID,attr,omitempty""`
    TransmitterSiteID *int32 `xml:"transmitterSiteID,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    WhichGeometry *int32 `xml:"whichGeometry,attr,omitempty""`
    WriteInterval *float64 `xml:"writeInterval,attr,omitempty""`
}

func (n *ReceiverPdu) GetNodeName() string { return "ReceiverPdu" }
func (n *ReceiverPdu) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#ReceiverPdu" }
func (n *ReceiverPdu) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.NetworkMode != nil {
        switch *n.NetworkMode {
        case NetworkModeChoicesStandAlone, NetworkModeChoicesNetworkReader, NetworkModeChoicesNetworkWriter: // valid
        default: return fmt.Errorf("invalid value for field networkMode: %s", *n.NetworkMode)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ReceiverPdu) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Address != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "address"}, Value: fmt.Sprintf("%v", *n.Address)}) }
    if n.ApplicationID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "applicationID"}, Value: fmt.Sprintf("%v", *n.ApplicationID)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EntityID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entityID"}, Value: fmt.Sprintf("%v", *n.EntityID)}) }
    if n.GeoCoords != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoCoords"}, Value: fmt.Sprintf("%v", *n.GeoCoords)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsNetworkReader != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isNetworkReader"}, Value: fmt.Sprintf("%v", *n.IsNetworkReader)}) }
    if n.IsNetworkWriter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isNetworkWriter"}, Value: fmt.Sprintf("%v", *n.IsNetworkWriter)}) }
    if n.IsRtpHeaderHeard != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isRtpHeaderHeard"}, Value: fmt.Sprintf("%v", *n.IsRtpHeaderHeard)}) }
    if n.IsStandAlone != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isStandAlone"}, Value: fmt.Sprintf("%v", *n.IsStandAlone)}) }
    if n.MulticastRelayHost != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "multicastRelayHost"}, Value: fmt.Sprintf("%v", *n.MulticastRelayHost)}) }
    if n.MulticastRelayPort != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "multicastRelayPort"}, Value: fmt.Sprintf("%v", *n.MulticastRelayPort)}) }
    if n.NetworkMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "networkMode"}, Value: fmt.Sprintf("%v", *n.NetworkMode)}) }
    if n.Port != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "port"}, Value: fmt.Sprintf("%v", *n.Port)}) }
    if n.RadioID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radioID"}, Value: fmt.Sprintf("%v", *n.RadioID)}) }
    if n.ReadInterval != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "readInterval"}, Value: fmt.Sprintf("%v", *n.ReadInterval)}) }
    if n.ReceivedPower != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "receivedPower"}, Value: fmt.Sprintf("%v", *n.ReceivedPower)}) }
    if n.ReceiverState != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "receiverState"}, Value: fmt.Sprintf("%v", *n.ReceiverState)}) }
    if n.RtpHeaderExpected != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rtpHeaderExpected"}, Value: fmt.Sprintf("%v", *n.RtpHeaderExpected)}) }
    if n.SiteID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "siteID"}, Value: fmt.Sprintf("%v", *n.SiteID)}) }
    if n.Timestamp != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "timestamp"}, Value: fmt.Sprintf("%v", *n.Timestamp)}) }
    if n.TransmitterApplicationID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transmitterApplicationID"}, Value: fmt.Sprintf("%v", *n.TransmitterApplicationID)}) }
    if n.TransmitterEntityID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transmitterEntityID"}, Value: fmt.Sprintf("%v", *n.TransmitterEntityID)}) }
    if n.TransmitterRadioID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transmitterRadioID"}, Value: fmt.Sprintf("%v", *n.TransmitterRadioID)}) }
    if n.TransmitterSiteID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transmitterSiteID"}, Value: fmt.Sprintf("%v", *n.TransmitterSiteID)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.WhichGeometry != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "whichGeometry"}, Value: fmt.Sprintf("%v", *n.WhichGeometry)}) }
    if n.WriteInterval != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "writeInterval"}, Value: fmt.Sprintf("%v", *n.WriteInterval)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Rectangle2D: Rectangle2D is a geometry node that defines a 2D rectangle in X-Y plane.
type Rectangle2D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Size *SFVec2f `xml:"size,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
}

func (n *Rectangle2D) GetNodeName() string { return "Rectangle2D" }
func (n *Rectangle2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#Rectangle2D" }
func (n *Rectangle2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Rectangle2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", *n.Size)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// RigidBody: RigidBody describes a collection of shapes with a mass distribution that is affected by the physics model.
type RigidBody struct {
    CoreX3DNode
    AngularDampingFactor *float32 `xml:"angularDampingFactor,attr,omitempty""`
    AngularVelocity *SFVec3f `xml:"angularVelocity,attr,omitempty""`
    AutoDamp *bool `xml:"autoDamp,attr,omitempty""`
    AutoDisable *bool `xml:"autoDisable,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    CenterOfMass *SFVec3f `xml:"centerOfMass,attr,omitempty""`
    DisableAngularSpeed *float32 `xml:"disableAngularSpeed,attr,omitempty""`
    DisableLinearSpeed *float32 `xml:"disableLinearSpeed,attr,omitempty""`
    DisableTime *float64 `xml:"disableTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    FiniteRotationAxis *SFVec3f `xml:"finiteRotationAxis,attr,omitempty""`
    Fixed *bool `xml:"fixed,attr,omitempty""`
    Forces *MFVec3f `xml:"forces,attr,omitempty""`
    Geometry []X3DNode `xml:",any""`
    Inertia *SFMatrix3f `xml:"inertia,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    LinearDampingFactor *float32 `xml:"linearDampingFactor,attr,omitempty""`
    LinearVelocity *SFVec3f `xml:"linearVelocity,attr,omitempty""`
    Mass *float32 `xml:"mass,attr,omitempty""`
    MassDensityModel X3DNode `xml:"massDensityModel,omitempty""`
    Orientation *SFRotation `xml:"orientation,attr,omitempty""`
    Position *SFVec3f `xml:"position,attr,omitempty""`
    Torques *MFVec3f `xml:"torques,attr,omitempty""`
    UseFiniteRotation *bool `xml:"useFiniteRotation,attr,omitempty""`
    UseGlobalGravity *bool `xml:"useGlobalGravity,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *RigidBody) GetNodeName() string { return "RigidBody" }
func (n *RigidBody) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#RigidBody" }
func (n *RigidBody) Validate() error {
    if n.Geometry != nil {
        for i, child := range n.Geometry { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Geometry[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.MassDensityModel != nil {
        if err := n.MassDensityModel.Validate(); err != nil { return fmt.Errorf("validation error in MassDensityModel: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *RigidBody) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AngularDampingFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "angularDampingFactor"}, Value: fmt.Sprintf("%v", *n.AngularDampingFactor)}) }
    if n.AngularVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "angularVelocity"}, Value: fmt.Sprintf("%v", *n.AngularVelocity)}) }
    if n.AutoDamp != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoDamp"}, Value: fmt.Sprintf("%v", *n.AutoDamp)}) }
    if n.AutoDisable != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoDisable"}, Value: fmt.Sprintf("%v", *n.AutoDisable)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.CenterOfMass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "centerOfMass"}, Value: fmt.Sprintf("%v", *n.CenterOfMass)}) }
    if n.DisableAngularSpeed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "disableAngularSpeed"}, Value: fmt.Sprintf("%v", *n.DisableAngularSpeed)}) }
    if n.DisableLinearSpeed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "disableLinearSpeed"}, Value: fmt.Sprintf("%v", *n.DisableLinearSpeed)}) }
    if n.DisableTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "disableTime"}, Value: fmt.Sprintf("%v", *n.DisableTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.FiniteRotationAxis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "finiteRotationAxis"}, Value: fmt.Sprintf("%v", *n.FiniteRotationAxis)}) }
    if n.Fixed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fixed"}, Value: fmt.Sprintf("%v", *n.Fixed)}) }
    if n.Forces != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "forces"}, Value: fmt.Sprintf("%v", *n.Forces)}) }
    if n.Inertia != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "inertia"}, Value: fmt.Sprintf("%v", *n.Inertia)}) }
    if n.LinearDampingFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "linearDampingFactor"}, Value: fmt.Sprintf("%v", *n.LinearDampingFactor)}) }
    if n.LinearVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "linearVelocity"}, Value: fmt.Sprintf("%v", *n.LinearVelocity)}) }
    if n.Mass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mass"}, Value: fmt.Sprintf("%v", *n.Mass)}) }
    if n.Orientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orientation"}, Value: fmt.Sprintf("%v", *n.Orientation)}) }
    if n.Position != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position"}, Value: fmt.Sprintf("%v", *n.Position)}) }
    if n.Torques != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "torques"}, Value: fmt.Sprintf("%v", *n.Torques)}) }
    if n.UseFiniteRotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "useFiniteRotation"}, Value: fmt.Sprintf("%v", *n.UseFiniteRotation)}) }
    if n.UseGlobalGravity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "useGlobalGravity"}, Value: fmt.Sprintf("%v", *n.UseGlobalGravity)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Geometry != nil {
        for _, child := range n.Geometry { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.MassDensityModel != nil {
        if err := e.EncodeElement(n.MassDensityModel, xml.StartElement{Name: xml.Name{Local: n.MassDensityModel.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// RigidBodyCollection: RigidBodyCollection represents a system of bodies that interact within a single physics model.
type RigidBodyCollection struct {
    CoreX3DNode
    AutoDisable *bool `xml:"autoDisable,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Bodies []X3DNode `xml:",any""`
    Collider X3DNode `xml:"collider,omitempty""`
    ConstantForceMix *float32 `xml:"constantForceMix,attr,omitempty""`
    ContactSurfaceThickness *float32 `xml:"contactSurfaceThickness,attr,omitempty""`
    DisableAngularSpeed *float32 `xml:"disableAngularSpeed,attr,omitempty""`
    DisableLinearSpeed *float32 `xml:"disableLinearSpeed,attr,omitempty""`
    DisableTime *float64 `xml:"disableTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    ErrorCorrection *float32 `xml:"errorCorrection,attr,omitempty""`
    Gravity *SFVec3f `xml:"gravity,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Iterations *int32 `xml:"iterations,attr,omitempty""`
    Joints []X3DNode `xml:",any""`
    MaxCorrectionSpeed *float32 `xml:"maxCorrectionSpeed,attr,omitempty""`
    PreferAccuracy *bool `xml:"preferAccuracy,attr,omitempty""`
    SetContacts []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *RigidBodyCollection) GetNodeName() string { return "RigidBodyCollection" }
func (n *RigidBodyCollection) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#RigidBodyCollection" }
func (n *RigidBodyCollection) Validate() error {
    if n.Bodies != nil {
        for i, child := range n.Bodies { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Bodies[%d]: %w", i, err) } }
    }
    if n.Collider != nil {
        if err := n.Collider.Validate(); err != nil { return fmt.Errorf("validation error in Collider: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Joints != nil {
        for i, child := range n.Joints { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Joints[%d]: %w", i, err) } }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.SetContacts != nil {
        for i, child := range n.SetContacts { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in SetContacts[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *RigidBodyCollection) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoDisable != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoDisable"}, Value: fmt.Sprintf("%v", *n.AutoDisable)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.ConstantForceMix != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "constantForceMix"}, Value: fmt.Sprintf("%v", *n.ConstantForceMix)}) }
    if n.ContactSurfaceThickness != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "contactSurfaceThickness"}, Value: fmt.Sprintf("%v", *n.ContactSurfaceThickness)}) }
    if n.DisableAngularSpeed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "disableAngularSpeed"}, Value: fmt.Sprintf("%v", *n.DisableAngularSpeed)}) }
    if n.DisableLinearSpeed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "disableLinearSpeed"}, Value: fmt.Sprintf("%v", *n.DisableLinearSpeed)}) }
    if n.DisableTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "disableTime"}, Value: fmt.Sprintf("%v", *n.DisableTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.ErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "errorCorrection"}, Value: fmt.Sprintf("%v", *n.ErrorCorrection)}) }
    if n.Gravity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gravity"}, Value: fmt.Sprintf("%v", *n.Gravity)}) }
    if n.Iterations != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "iterations"}, Value: fmt.Sprintf("%v", *n.Iterations)}) }
    if n.MaxCorrectionSpeed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxCorrectionSpeed"}, Value: fmt.Sprintf("%v", *n.MaxCorrectionSpeed)}) }
    if n.PreferAccuracy != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "preferAccuracy"}, Value: fmt.Sprintf("%v", *n.PreferAccuracy)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Bodies != nil {
        for _, child := range n.Bodies { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Collider != nil {
        if err := e.EncodeElement(n.Collider, xml.StartElement{Name: xml.Name{Local: n.Collider.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Joints != nil {
        for _, child := range n.Joints { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.SetContacts != nil {
        for _, child := range n.SetContacts { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// ScalarChaser: ScalarChaser generates a series of single floating-point values that progressively change from initial value to destination value.
type ScalarChaser struct {
    CoreX3DNode
    Duration *float64 `xml:"duration,attr,omitempty""`
    InitialDestination *float32 `xml:"initialDestination,attr,omitempty""`
    InitialValue *float32 `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    SetDestination *float32 `xml:"set_destination,attr,omitempty""`
    SetValue *float32 `xml:"set_value,attr,omitempty""`
    ValueChanged *float32 `xml:"value_changed,attr,omitempty""`
}

func (n *ScalarChaser) GetNodeName() string { return "ScalarChaser" }
func (n *ScalarChaser) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#ScalarChaser" }
func (n *ScalarChaser) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ScalarChaser) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Duration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "duration"}, Value: fmt.Sprintf("%v", *n.Duration)}) }
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ScalarDamper: ScalarDamper generates a series of floating-point values that progressively change from initial value to destination value.
type ScalarDamper struct {
    CoreX3DNode
    InitialDestination *float32 `xml:"initialDestination,attr,omitempty""`
    InitialValue *float32 `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    SetDestination *float32 `xml:"set_destination,attr,omitempty""`
    SetValue *float32 `xml:"set_value,attr,omitempty""`
    Tau *float64 `xml:"tau,attr,omitempty""`
    Tolerance *float32 `xml:"tolerance,attr,omitempty""`
    ValueChanged *float32 `xml:"value_changed,attr,omitempty""`
}

func (n *ScalarDamper) GetNodeName() string { return "ScalarDamper" }
func (n *ScalarDamper) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#ScalarDamper" }
func (n *ScalarDamper) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ScalarDamper) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.Tau != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tau"}, Value: fmt.Sprintf("%v", *n.Tau)}) }
    if n.Tolerance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tolerance"}, Value: fmt.Sprintf("%v", *n.Tolerance)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ScalarInterpolator: ScalarInterpolator generates piecewise-linear SFFloat values.
type ScalarInterpolator struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue []float32 `xml:"keyValue,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *float32 `xml:"value_changed,attr,omitempty""`
}

func (n *ScalarInterpolator) GetNodeName() string { return "ScalarInterpolator" }
func (n *ScalarInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#ScalarInterpolator" }
func (n *ScalarInterpolator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ScalarInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", n.KeyValue)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ScreenFontStyle: ScreenFontStyle is an X3DFontStyleNode defines the size, family, justification, and other styles used within a screen layout.
type ScreenFontStyle struct {
    CoreX3DNode
    Family []string `xml:"family,attr,omitempty""`
    Horizontal *bool `xml:"horizontal,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Justify []string `xml:"justify,attr,omitempty""`
    Language *string `xml:"language,attr,omitempty""`
    LeftToRight *bool `xml:"leftToRight,attr,omitempty""`
    PointSize *float32 `xml:"pointSize,attr,omitempty""`
    Spacing *float32 `xml:"spacing,attr,omitempty""`
    TopToBottom *bool `xml:"topToBottom,attr,omitempty""`
}

func (n *ScreenFontStyle) GetNodeName() string { return "ScreenFontStyle" }
func (n *ScreenFontStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#ScreenFontStyle" }
func (n *ScreenFontStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Justify != nil {
        for _, value := range n.Justify {
            switch value {
            case JustifyChoicesMIDDLE, JustifyChoicesMIDDLEBEGIN, JustifyChoicesMIDDLEEND, JustifyChoicesMIDDLEFIRST, JustifyChoicesMIDDLEMIDDLE, JustifyChoicesBEGIN, JustifyChoicesBEGINBEGIN, JustifyChoicesBEGINEND, JustifyChoicesBEGINFIRST, JustifyChoicesBEGINMIDDLE, JustifyChoicesEND, JustifyChoicesENDBEGIN, JustifyChoicesENDEND, JustifyChoicesENDFIRST, JustifyChoicesENDMIDDLE, JustifyChoicesFIRST, JustifyChoicesFIRSTBEGIN, JustifyChoicesFIRSTEND, JustifyChoicesFIRSTFIRST, JustifyChoicesFIRSTMIDDLE: // valid
            default: return fmt.Errorf("invalid value in field justify: %s", value)
            }
        }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Style != nil {
        switch *n.Style {
        case FontStyleChoicesPLAIN, FontStyleChoicesBOLD, FontStyleChoicesITALIC, FontStyleChoicesBOLDITALIC: // valid
        default: return fmt.Errorf("invalid value for field style: %s", *n.Style)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ScreenFontStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.Family != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "family"}, Value: fmt.Sprintf("%v", n.Family)}) }
    if n.Horizontal != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "horizontal"}, Value: fmt.Sprintf("%v", *n.Horizontal)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Justify != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "justify"}, Value: fmt.Sprintf("%v", n.Justify)}) }
    if n.Language != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "language"}, Value: fmt.Sprintf("%v", *n.Language)}) }
    if n.LeftToRight != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "leftToRight"}, Value: fmt.Sprintf("%v", *n.LeftToRight)}) }
    if n.PointSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pointSize"}, Value: fmt.Sprintf("%v", *n.PointSize)}) }
    if n.Spacing != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "spacing"}, Value: fmt.Sprintf("%v", *n.Spacing)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.TopToBottom != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "topToBottom"}, Value: fmt.Sprintf("%v", *n.TopToBottom)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ScreenGroup: ScreenGroup is a Grouping node that can contain most nodes.
type ScreenGroup struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *ScreenGroup) GetNodeName() string { return "ScreenGroup" }
func (n *ScreenGroup) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layout.html#ScreenGroup" }
func (n *ScreenGroup) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ScreenGroup) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// Script: Script contains author-programmed event behaviors for a scene.
type Script struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    DirectOutput *bool `xml:"directOutput,attr,omitempty""`
    Field []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    MustEvaluate *bool `xml:"mustEvaluate,attr,omitempty""`
    SourceCode *string `xml:"sourceCode,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *Script) GetNodeName() string { return "Script" }
func (n *Script) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/scripting.html#Script" }
func (n *Script) Validate() error {
    if n.Field != nil {
        for i, child := range n.Field { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Field[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Script) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.DirectOutput != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "directOutput"}, Value: fmt.Sprintf("%v", *n.DirectOutput)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.MustEvaluate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mustEvaluate"}, Value: fmt.Sprintf("%v", *n.MustEvaluate)}) }
    if n.SourceCode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sourceCode"}, Value: fmt.Sprintf("%v", *n.SourceCode)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Field != nil {
        for _, child := range n.Field { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SegmentedVolumeData: SegmentedVolumeData displays a segmented voxel dataset with different RenderStyle nodes.
type SegmentedVolumeData struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Dimensions *SFVec3f `xml:"dimensions,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RenderStyle []X3DNode `xml:",any""`
    SegmentEnabled []bool `xml:"segmentEnabled,attr,omitempty""`
    SegmentIdentifiers X3DNode `xml:"segmentIdentifiers,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    Voxels X3DNode `xml:"voxels,omitempty""`
}

func (n *SegmentedVolumeData) GetNodeName() string { return "SegmentedVolumeData" }
func (n *SegmentedVolumeData) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#SegmentedVolumeData" }
func (n *SegmentedVolumeData) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RenderStyle != nil {
        for i, child := range n.RenderStyle { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RenderStyle[%d]: %w", i, err) } }
    }
    if n.SegmentIdentifiers != nil {
        if err := n.SegmentIdentifiers.Validate(); err != nil { return fmt.Errorf("validation error in SegmentIdentifiers: %w", err) }
    }
    if n.Voxels != nil {
        if err := n.Voxels.Validate(); err != nil { return fmt.Errorf("validation error in Voxels: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SegmentedVolumeData) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Dimensions != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "dimensions"}, Value: fmt.Sprintf("%v", *n.Dimensions)}) }
    if n.SegmentEnabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "segmentEnabled"}, Value: fmt.Sprintf("%v", n.SegmentEnabled)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RenderStyle != nil {
        for _, child := range n.RenderStyle { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.SegmentIdentifiers != nil {
        if err := e.EncodeElement(n.SegmentIdentifiers, xml.StartElement{Name: xml.Name{Local: n.SegmentIdentifiers.GetNodeName()}}); err != nil { return err }
    }
    if n.Voxels != nil {
        if err := e.EncodeElement(n.Voxels, xml.StartElement{Name: xml.Name{Local: n.Voxels.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ShadedVolumeStyle: All fields fully supported except shadows supported with at least Phong shading at level 3. All fields fully supported with at least Phong shading and Henyey-Greenstein phase function, shadows fully supported at level 4.
type ShadedVolumeStyle struct {
    CoreX3DNode
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Lighting *bool `xml:"lighting,attr,omitempty""`
    Material X3DNode `xml:"material,omitempty""`
    PhaseFunction *string `xml:"phaseFunction,attr,omitempty""`
    Shadows *bool `xml:"shadows,attr,omitempty""`
    SurfaceNormals X3DNode `xml:"surfaceNormals,omitempty""`
}

func (n *ShadedVolumeStyle) GetNodeName() string { return "ShadedVolumeStyle" }
func (n *ShadedVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#ShadedVolumeStyle" }
func (n *ShadedVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Material != nil {
        if err := n.Material.Validate(); err != nil { return fmt.Errorf("validation error in Material: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.SurfaceNormals != nil {
        if err := n.SurfaceNormals.Validate(); err != nil { return fmt.Errorf("validation error in SurfaceNormals: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ShadedVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Lighting != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "lighting"}, Value: fmt.Sprintf("%v", *n.Lighting)}) }
    if n.PhaseFunction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "phaseFunction"}, Value: fmt.Sprintf("%v", *n.PhaseFunction)}) }
    if n.Shadows != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadows"}, Value: fmt.Sprintf("%v", *n.Shadows)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Material != nil {
        if err := e.EncodeElement(n.Material, xml.StartElement{Name: xml.Name{Local: n.Material.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.SurfaceNormals != nil {
        if err := e.EncodeElement(n.SurfaceNormals, xml.StartElement{Name: xml.Name{Local: n.SurfaceNormals.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ShaderPart: ShaderPart can contain a CDATA section of plain-text source code.
type ShaderPart struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    SourceCode *string `xml:"sourceCode,attr,omitempty""`
    Type *string `xml:"type,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *ShaderPart) GetNodeName() string { return "ShaderPart" }
func (n *ShaderPart) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#ShaderPart" }
func (n *ShaderPart) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ShaderPart) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.SourceCode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sourceCode"}, Value: fmt.Sprintf("%v", *n.SourceCode)}) }
    if n.Type != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "type"}, Value: fmt.Sprintf("%v", *n.Type)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ShaderProgram: ShaderProgram can contain field declarations and a CDATA section of plain-text source code.
type ShaderProgram struct {
    CoreX3DNode
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Field []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    SourceCode *string `xml:"sourceCode,attr,omitempty""`
    Type *string `xml:"type,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
}

func (n *ShaderProgram) GetNodeName() string { return "ShaderProgram" }
func (n *ShaderProgram) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shaders.html#ShaderProgram" }
func (n *ShaderProgram) Validate() error {
    if n.Field != nil {
        for i, child := range n.Field { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Field[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ShaderProgram) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.SourceCode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sourceCode"}, Value: fmt.Sprintf("%v", *n.SourceCode)}) }
    if n.Type != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "type"}, Value: fmt.Sprintf("%v", *n.Type)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Field != nil {
        for _, child := range n.Field { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Shape: Shape can appear under any grouping node.
type Shape struct {
    CoreX3DNode
    Appearance X3DNode `xml:"appearance,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    CastShadow *bool `xml:"castShadow,attr,omitempty""`
    Geometry X3DNode `xml:"geometry,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    PointerEvents *bool `xml:"pointerEvents,attr,omitempty""`
}

func (n *Shape) GetNodeName() string { return "Shape" }
func (n *Shape) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#Shape" }
func (n *Shape) Validate() error {
    if n.Appearance != nil {
        if err := n.Appearance.Validate(); err != nil { return fmt.Errorf("validation error in Appearance: %w", err) }
    }
    if n.Geometry != nil {
        if err := n.Geometry.Validate(); err != nil { return fmt.Errorf("validation error in Geometry: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Shape) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.CastShadow != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "castShadow"}, Value: fmt.Sprintf("%v", *n.CastShadow)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if n.PointerEvents != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pointerEvents"}, Value: fmt.Sprintf("%v", *n.PointerEvents)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Appearance != nil {
        if err := e.EncodeElement(n.Appearance, xml.StartElement{Name: xml.Name{Local: n.Appearance.GetNodeName()}}); err != nil { return err }
    }
    if n.Geometry != nil {
        if err := e.EncodeElement(n.Geometry, xml.StartElement{Name: xml.Name{Local: n.Geometry.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SignalPdu: SignalPdu is a networked Protocol Data Unit (PDU) information node that communicates the transmission of voice, audio or other data modeled in a simulation.
type SignalPdu struct {
    CoreX3DNode
    Address *string `xml:"address,attr,omitempty""`
    ApplicationID *int32 `xml:"applicationID,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Data []int32 `xml:"data,attr,omitempty""`
    DataLength *int32 `xml:"dataLength,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EncodingScheme *int32 `xml:"encodingScheme,attr,omitempty""`
    EntityID *int32 `xml:"entityID,attr,omitempty""`
    GeoCoords *SFVec3d `xml:"geoCoords,attr,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsNetworkReader *bool `xml:"isNetworkReader,attr,omitempty""`
    IsNetworkWriter *bool `xml:"isNetworkWriter,attr,omitempty""`
    IsRtpHeaderHeard *bool `xml:"isRtpHeaderHeard,attr,omitempty""`
    IsStandAlone *bool `xml:"isStandAlone,attr,omitempty""`
    MulticastRelayHost *string `xml:"multicastRelayHost,attr,omitempty""`
    MulticastRelayPort *int32 `xml:"multicastRelayPort,attr,omitempty""`
    NetworkMode *string `xml:"networkMode,attr,omitempty""`
    Port *int32 `xml:"port,attr,omitempty""`
    RadioID *int32 `xml:"radioID,attr,omitempty""`
    ReadInterval *float64 `xml:"readInterval,attr,omitempty""`
    RtpHeaderExpected *bool `xml:"rtpHeaderExpected,attr,omitempty""`
    SampleRate *int32 `xml:"sampleRate,attr,omitempty""`
    Samples *int32 `xml:"samples,attr,omitempty""`
    SiteID *int32 `xml:"siteID,attr,omitempty""`
    TdlType *int32 `xml:"tdlType,attr,omitempty""`
    Timestamp *float64 `xml:"timestamp,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    WhichGeometry *int32 `xml:"whichGeometry,attr,omitempty""`
    WriteInterval *float64 `xml:"writeInterval,attr,omitempty""`
}

func (n *SignalPdu) GetNodeName() string { return "SignalPdu" }
func (n *SignalPdu) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#SignalPdu" }
func (n *SignalPdu) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.NetworkMode != nil {
        switch *n.NetworkMode {
        case NetworkModeChoicesStandAlone, NetworkModeChoicesNetworkReader, NetworkModeChoicesNetworkWriter: // valid
        default: return fmt.Errorf("invalid value for field networkMode: %s", *n.NetworkMode)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SignalPdu) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Address != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "address"}, Value: fmt.Sprintf("%v", *n.Address)}) }
    if n.ApplicationID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "applicationID"}, Value: fmt.Sprintf("%v", *n.ApplicationID)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Data != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "data"}, Value: fmt.Sprintf("%v", n.Data)}) }
    if n.DataLength != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "dataLength"}, Value: fmt.Sprintf("%v", *n.DataLength)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EncodingScheme != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "encodingScheme"}, Value: fmt.Sprintf("%v", *n.EncodingScheme)}) }
    if n.EntityID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entityID"}, Value: fmt.Sprintf("%v", *n.EntityID)}) }
    if n.GeoCoords != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoCoords"}, Value: fmt.Sprintf("%v", *n.GeoCoords)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsNetworkReader != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isNetworkReader"}, Value: fmt.Sprintf("%v", *n.IsNetworkReader)}) }
    if n.IsNetworkWriter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isNetworkWriter"}, Value: fmt.Sprintf("%v", *n.IsNetworkWriter)}) }
    if n.IsRtpHeaderHeard != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isRtpHeaderHeard"}, Value: fmt.Sprintf("%v", *n.IsRtpHeaderHeard)}) }
    if n.IsStandAlone != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isStandAlone"}, Value: fmt.Sprintf("%v", *n.IsStandAlone)}) }
    if n.MulticastRelayHost != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "multicastRelayHost"}, Value: fmt.Sprintf("%v", *n.MulticastRelayHost)}) }
    if n.MulticastRelayPort != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "multicastRelayPort"}, Value: fmt.Sprintf("%v", *n.MulticastRelayPort)}) }
    if n.NetworkMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "networkMode"}, Value: fmt.Sprintf("%v", *n.NetworkMode)}) }
    if n.Port != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "port"}, Value: fmt.Sprintf("%v", *n.Port)}) }
    if n.RadioID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radioID"}, Value: fmt.Sprintf("%v", *n.RadioID)}) }
    if n.ReadInterval != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "readInterval"}, Value: fmt.Sprintf("%v", *n.ReadInterval)}) }
    if n.RtpHeaderExpected != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rtpHeaderExpected"}, Value: fmt.Sprintf("%v", *n.RtpHeaderExpected)}) }
    if n.SampleRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sampleRate"}, Value: fmt.Sprintf("%v", *n.SampleRate)}) }
    if n.Samples != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "samples"}, Value: fmt.Sprintf("%v", *n.Samples)}) }
    if n.SiteID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "siteID"}, Value: fmt.Sprintf("%v", *n.SiteID)}) }
    if n.TdlType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tdlType"}, Value: fmt.Sprintf("%v", *n.TdlType)}) }
    if n.Timestamp != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "timestamp"}, Value: fmt.Sprintf("%v", *n.Timestamp)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.WhichGeometry != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "whichGeometry"}, Value: fmt.Sprintf("%v", *n.WhichGeometry)}) }
    if n.WriteInterval != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "writeInterval"}, Value: fmt.Sprintf("%v", *n.WriteInterval)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SilhouetteEnhancementVolumeStyle: SilhouetteEnhancementVolumeStyle specifies that volumetric data is rendered with silhouette enhancement.
type SilhouetteEnhancementVolumeStyle struct {
    CoreX3DNode
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    SilhouetteBoundaryOpacity *float32 `xml:"silhouetteBoundaryOpacity,attr,omitempty""`
    SilhouetteRetainedOpacity *float32 `xml:"silhouetteRetainedOpacity,attr,omitempty""`
    SilhouetteSharpness *float32 `xml:"silhouetteSharpness,attr,omitempty""`
    SurfaceNormals X3DNode `xml:"surfaceNormals,omitempty""`
}

func (n *SilhouetteEnhancementVolumeStyle) GetNodeName() string { return "SilhouetteEnhancementVolumeStyle" }
func (n *SilhouetteEnhancementVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#SilhouetteEnhancementVolumeStyle" }
func (n *SilhouetteEnhancementVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.SurfaceNormals != nil {
        if err := n.SurfaceNormals.Validate(); err != nil { return fmt.Errorf("validation error in SurfaceNormals: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SilhouetteEnhancementVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.SilhouetteBoundaryOpacity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "silhouetteBoundaryOpacity"}, Value: fmt.Sprintf("%v", *n.SilhouetteBoundaryOpacity)}) }
    if n.SilhouetteRetainedOpacity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "silhouetteRetainedOpacity"}, Value: fmt.Sprintf("%v", *n.SilhouetteRetainedOpacity)}) }
    if n.SilhouetteSharpness != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "silhouetteSharpness"}, Value: fmt.Sprintf("%v", *n.SilhouetteSharpness)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.SurfaceNormals != nil {
        if err := e.EncodeElement(n.SurfaceNormals, xml.StartElement{Name: xml.Name{Local: n.SurfaceNormals.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SingleAxisHingeJoint: SingleAxisHingeJoint has single axis about which to rotate, similar to a traditional door hinge. Contains two RigidBody nodes (containerField values body1, body2).
type SingleAxisHingeJoint struct {
    CoreX3DNode
    AnchorPoint *SFVec3f `xml:"anchorPoint,attr,omitempty""`
    Angle *float32 `xml:"angle,attr,omitempty""`
    AngleRate *float32 `xml:"angleRate,attr,omitempty""`
    Axis *SFVec3f `xml:"axis,attr,omitempty""`
    Body1 X3DNode `xml:"body1,omitempty""`
    Body1AnchorPoint *SFVec3f `xml:"body1AnchorPoint,attr,omitempty""`
    Body2 X3DNode `xml:"body2,omitempty""`
    Body2AnchorPoint *SFVec3f `xml:"body2AnchorPoint,attr,omitempty""`
    ForceOutput []string `xml:"forceOutput,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    MaxAngle *float32 `xml:"maxAngle,attr,omitempty""`
    MinAngle *float32 `xml:"minAngle,attr,omitempty""`
    StopBounce *float32 `xml:"stopBounce,attr,omitempty""`
    StopErrorCorrection *float32 `xml:"stopErrorCorrection,attr,omitempty""`
}

func (n *SingleAxisHingeJoint) GetNodeName() string { return "SingleAxisHingeJoint" }
func (n *SingleAxisHingeJoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#SingleAxisHingeJoint" }
func (n *SingleAxisHingeJoint) Validate() error {
    if n.Body1 != nil {
        if err := n.Body1.Validate(); err != nil { return fmt.Errorf("validation error in Body1: %w", err) }
    }
    if n.Body2 != nil {
        if err := n.Body2.Validate(); err != nil { return fmt.Errorf("validation error in Body2: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SingleAxisHingeJoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "anchorPoint"}, Value: fmt.Sprintf("%v", *n.AnchorPoint)}) }
    if n.Angle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "angle"}, Value: fmt.Sprintf("%v", *n.Angle)}) }
    if n.AngleRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "angleRate"}, Value: fmt.Sprintf("%v", *n.AngleRate)}) }
    if n.Axis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis"}, Value: fmt.Sprintf("%v", *n.Axis)}) }
    if n.Body1AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body1AnchorPoint"}, Value: fmt.Sprintf("%v", *n.Body1AnchorPoint)}) }
    if n.Body2AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body2AnchorPoint"}, Value: fmt.Sprintf("%v", *n.Body2AnchorPoint)}) }
    if n.ForceOutput != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "forceOutput"}, Value: fmt.Sprintf("%v", n.ForceOutput)}) }
    if n.MaxAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxAngle"}, Value: fmt.Sprintf("%v", *n.MaxAngle)}) }
    if n.MinAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minAngle"}, Value: fmt.Sprintf("%v", *n.MinAngle)}) }
    if n.StopBounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopBounce"}, Value: fmt.Sprintf("%v", *n.StopBounce)}) }
    if n.StopErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopErrorCorrection"}, Value: fmt.Sprintf("%v", *n.StopErrorCorrection)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Body1 != nil {
        if err := e.EncodeElement(n.Body1, xml.StartElement{Name: xml.Name{Local: n.Body1.GetNodeName()}}); err != nil { return err }
    }
    if n.Body2 != nil {
        if err := e.EncodeElement(n.Body2, xml.StartElement{Name: xml.Name{Local: n.Body2.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SliderJoint: SliderJoint constrains all movement between body1 and body2 along a single axis. Contains two RigidBody nodes (containerField values body1, body2).
type SliderJoint struct {
    CoreX3DNode
    Axis *SFVec3f `xml:"axis,attr,omitempty""`
    Body1 X3DNode `xml:"body1,omitempty""`
    Body2 X3DNode `xml:"body2,omitempty""`
    ForceOutput []string `xml:"forceOutput,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    MaxSeparation *float32 `xml:"maxSeparation,attr,omitempty""`
    MinSeparation *float32 `xml:"minSeparation,attr,omitempty""`
    Separation *float32 `xml:"separation,attr,omitempty""`
    SeparationRate *float32 `xml:"separationRate,attr,omitempty""`
    SliderForce *float32 `xml:"sliderForce,attr,omitempty""`
    StopBounce *float32 `xml:"stopBounce,attr,omitempty""`
    StopErrorCorrection *float32 `xml:"stopErrorCorrection,attr,omitempty""`
}

func (n *SliderJoint) GetNodeName() string { return "SliderJoint" }
func (n *SliderJoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#SliderJoint" }
func (n *SliderJoint) Validate() error {
    if n.Body1 != nil {
        if err := n.Body1.Validate(); err != nil { return fmt.Errorf("validation error in Body1: %w", err) }
    }
    if n.Body2 != nil {
        if err := n.Body2.Validate(); err != nil { return fmt.Errorf("validation error in Body2: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SliderJoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Axis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis"}, Value: fmt.Sprintf("%v", *n.Axis)}) }
    if n.ForceOutput != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "forceOutput"}, Value: fmt.Sprintf("%v", n.ForceOutput)}) }
    if n.MaxSeparation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxSeparation"}, Value: fmt.Sprintf("%v", *n.MaxSeparation)}) }
    if n.MinSeparation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minSeparation"}, Value: fmt.Sprintf("%v", *n.MinSeparation)}) }
    if n.Separation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "separation"}, Value: fmt.Sprintf("%v", *n.Separation)}) }
    if n.SeparationRate != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "separationRate"}, Value: fmt.Sprintf("%v", *n.SeparationRate)}) }
    if n.SliderForce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sliderForce"}, Value: fmt.Sprintf("%v", *n.SliderForce)}) }
    if n.StopBounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopBounce"}, Value: fmt.Sprintf("%v", *n.StopBounce)}) }
    if n.StopErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopErrorCorrection"}, Value: fmt.Sprintf("%v", *n.StopErrorCorrection)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Body1 != nil {
        if err := e.EncodeElement(n.Body1, xml.StartElement{Name: xml.Name{Local: n.Body1.GetNodeName()}}); err != nil { return err }
    }
    if n.Body2 != nil {
        if err := e.EncodeElement(n.Body2, xml.StartElement{Name: xml.Name{Local: n.Body2.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Sound: The Sound node controls the 3D spatialization of sound playback by a child AudioClip or MovieTexture node.
type Sound struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Intensity *float32 `xml:"intensity,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Location *SFVec3f `xml:"location,attr,omitempty""`
    MaxBack *float32 `xml:"maxBack,attr,omitempty""`
    MaxFront *float32 `xml:"maxFront,attr,omitempty""`
    MinBack *float32 `xml:"minBack,attr,omitempty""`
    MinFront *float32 `xml:"minFront,attr,omitempty""`
    Priority *float32 `xml:"priority,attr,omitempty""`
    Source X3DNode `xml:"source,omitempty""`
    Spatialize *bool `xml:"spatialize,attr,omitempty""`
}

func (n *Sound) GetNodeName() string { return "Sound" }
func (n *Sound) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Sound" }
func (n *Sound) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Source != nil {
        if err := n.Source.Validate(); err != nil { return fmt.Errorf("validation error in Source: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Sound) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Intensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intensity"}, Value: fmt.Sprintf("%v", *n.Intensity)}) }
    if n.Location != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "location"}, Value: fmt.Sprintf("%v", *n.Location)}) }
    if n.MaxBack != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxBack"}, Value: fmt.Sprintf("%v", *n.MaxBack)}) }
    if n.MaxFront != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxFront"}, Value: fmt.Sprintf("%v", *n.MaxFront)}) }
    if n.MinBack != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minBack"}, Value: fmt.Sprintf("%v", *n.MinBack)}) }
    if n.MinFront != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minFront"}, Value: fmt.Sprintf("%v", *n.MinFront)}) }
    if n.Priority != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "priority"}, Value: fmt.Sprintf("%v", *n.Priority)}) }
    if n.Spatialize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "spatialize"}, Value: fmt.Sprintf("%v", *n.Spatialize)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Source != nil {
        if err := e.EncodeElement(n.Source, xml.StartElement{Name: xml.Name{Local: n.Source.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SpatialSound: The SpatialSound node controls the 3D spatialization of sound playback by a child AudioClip or MovieTexture node.
type SpatialSound struct {
    CoreX3DNode
    Children []X3DNode `xml:",any""`
    ConeInnerAngle *float32 `xml:"coneInnerAngle,attr,omitempty""`
    ConeOuterAngle *float32 `xml:"coneOuterAngle,attr,omitempty""`
    ConeOuterGain *float32 `xml:"coneOuterGain,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    DistanceModel *string `xml:"distanceModel,attr,omitempty""`
    DopplerEnabled *bool `xml:"dopplerEnabled,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EnableHRTF *bool `xml:"enableHRTF,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    Intensity *float32 `xml:"intensity,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Location *SFVec3f `xml:"location,attr,omitempty""`
    MaxDistance *float32 `xml:"maxDistance,attr,omitempty""`
    Priority *float32 `xml:"priority,attr,omitempty""`
    ReferenceDistance *float32 `xml:"referenceDistance,attr,omitempty""`
    RolloffFactor *float32 `xml:"rolloffFactor,attr,omitempty""`
    Spatialize *bool `xml:"spatialize,attr,omitempty""`
}

func (n *SpatialSound) GetNodeName() string { return "SpatialSound" }
func (n *SpatialSound) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#Sound" }
func (n *SpatialSound) Validate() error {
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.DistanceModel != nil {
        switch *n.DistanceModel {
        case DistanceModelChoicesLINEAR, DistanceModelChoicesINVERSE, DistanceModelChoicesEXPONENTIAL: // valid
        default: return fmt.Errorf("invalid value for field distanceModel: %s", *n.DistanceModel)
        }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SpatialSound) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ConeInnerAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "coneInnerAngle"}, Value: fmt.Sprintf("%v", *n.ConeInnerAngle)}) }
    if n.ConeOuterAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "coneOuterAngle"}, Value: fmt.Sprintf("%v", *n.ConeOuterAngle)}) }
    if n.ConeOuterGain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "coneOuterGain"}, Value: fmt.Sprintf("%v", *n.ConeOuterGain)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.DistanceModel != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "distanceModel"}, Value: fmt.Sprintf("%v", *n.DistanceModel)}) }
    if n.DopplerEnabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "dopplerEnabled"}, Value: fmt.Sprintf("%v", *n.DopplerEnabled)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EnableHRTF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enableHRTF"}, Value: fmt.Sprintf("%v", *n.EnableHRTF)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.Intensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intensity"}, Value: fmt.Sprintf("%v", *n.Intensity)}) }
    if n.Location != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "location"}, Value: fmt.Sprintf("%v", *n.Location)}) }
    if n.MaxDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxDistance"}, Value: fmt.Sprintf("%v", *n.MaxDistance)}) }
    if n.Priority != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "priority"}, Value: fmt.Sprintf("%v", *n.Priority)}) }
    if n.ReferenceDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "referenceDistance"}, Value: fmt.Sprintf("%v", *n.ReferenceDistance)}) }
    if n.RolloffFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rolloffFactor"}, Value: fmt.Sprintf("%v", *n.RolloffFactor)}) }
    if n.Spatialize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "spatialize"}, Value: fmt.Sprintf("%v", *n.Spatialize)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Sphere: Sphere is a geometry node, representing a perfectly round geometrical object that is the surface of a completely round ball.
type Sphere struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Radius *float32 `xml:"radius,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
}

func (n *Sphere) GetNodeName() string { return "Sphere" }
func (n *Sphere) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry3D.html#Sphere" }
func (n *Sphere) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Sphere) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Radius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radius"}, Value: fmt.Sprintf("%v", *n.Radius)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SphereSensor: SphereSensor converts pointing device motion into a spherical rotation about the origin of the local coordinate system.
type SphereSensor struct {
    CoreX3DNode
    AutoOffset *bool `xml:"autoOffset,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsOver *bool `xml:"isOver,attr,omitempty""`
    Offset *SFRotation `xml:"offset,attr,omitempty""`
    RotationChanged *SFRotation `xml:"rotation_changed,attr,omitempty""`
    TrackPointChanged *SFVec3f `xml:"trackPoint_changed,attr,omitempty""`
}

func (n *SphereSensor) GetNodeName() string { return "SphereSensor" }
func (n *SphereSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#SphereSensor" }
func (n *SphereSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SphereSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AutoOffset != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoOffset"}, Value: fmt.Sprintf("%v", *n.AutoOffset)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsOver != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isOver"}, Value: fmt.Sprintf("%v", *n.IsOver)}) }
    if n.Offset != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "offset"}, Value: fmt.Sprintf("%v", *n.Offset)}) }
    if n.RotationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation_changed"}, Value: fmt.Sprintf("%v", *n.RotationChanged)}) }
    if n.TrackPointChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "trackPoint_changed"}, Value: fmt.Sprintf("%v", *n.TrackPointChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SplinePositionInterpolator: SplinePositionInterpolator performs non-linear interpolation among paired lists of 3-tuple values and velocities to produce an SFVec3f value_changed output event.
type SplinePositionInterpolator struct {
    CoreX3DNode
    Closed *bool `xml:"closed,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFVec3f `xml:"keyValue,attr,omitempty""`
    KeyVelocity *MFVec3f `xml:"keyVelocity,attr,omitempty""`
    NormalizeVelocity *bool `xml:"normalizeVelocity,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFVec3f `xml:"value_changed,attr,omitempty""`
}

func (n *SplinePositionInterpolator) GetNodeName() string { return "SplinePositionInterpolator" }
func (n *SplinePositionInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#SplinePositionInterpolator" }
func (n *SplinePositionInterpolator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SplinePositionInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Closed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "closed"}, Value: fmt.Sprintf("%v", *n.Closed)}) }
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.KeyVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyVelocity"}, Value: fmt.Sprintf("%v", *n.KeyVelocity)}) }
    if n.NormalizeVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalizeVelocity"}, Value: fmt.Sprintf("%v", *n.NormalizeVelocity)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SplinePositionInterpolator2D: SplinePositionInterpolator2D performs non-linear interpolation among paired lists of 2-tuple values and velocities to produce an SFVec2f value_changed output event.
type SplinePositionInterpolator2D struct {
    CoreX3DNode
    Closed *bool `xml:"closed,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFVec2f `xml:"keyValue,attr,omitempty""`
    KeyVelocity *MFVec2f `xml:"keyVelocity,attr,omitempty""`
    NormalizeVelocity *bool `xml:"normalizeVelocity,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFVec2f `xml:"value_changed,attr,omitempty""`
}

func (n *SplinePositionInterpolator2D) GetNodeName() string { return "SplinePositionInterpolator2D" }
func (n *SplinePositionInterpolator2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#SplinePositionInterpolator2D" }
func (n *SplinePositionInterpolator2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SplinePositionInterpolator2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Closed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "closed"}, Value: fmt.Sprintf("%v", *n.Closed)}) }
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.KeyVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyVelocity"}, Value: fmt.Sprintf("%v", *n.KeyVelocity)}) }
    if n.NormalizeVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalizeVelocity"}, Value: fmt.Sprintf("%v", *n.NormalizeVelocity)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SplineScalarInterpolator: SplineScalarInterpolator performs non-linear interpolation among paired lists of float values and velocities to produce an SFFloat value_changed output event.
type SplineScalarInterpolator struct {
    CoreX3DNode
    Closed *bool `xml:"closed,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue []float32 `xml:"keyValue,attr,omitempty""`
    KeyVelocity []float32 `xml:"keyVelocity,attr,omitempty""`
    NormalizeVelocity *bool `xml:"normalizeVelocity,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *float32 `xml:"value_changed,attr,omitempty""`
}

func (n *SplineScalarInterpolator) GetNodeName() string { return "SplineScalarInterpolator" }
func (n *SplineScalarInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#SplineScalarInterpolator" }
func (n *SplineScalarInterpolator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SplineScalarInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Closed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "closed"}, Value: fmt.Sprintf("%v", *n.Closed)}) }
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", n.KeyValue)}) }
    if n.KeyVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyVelocity"}, Value: fmt.Sprintf("%v", n.KeyVelocity)}) }
    if n.NormalizeVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalizeVelocity"}, Value: fmt.Sprintf("%v", *n.NormalizeVelocity)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SpotLight: Linear attenuation may occur at level 2, full support at level 3.
type SpotLight struct {
    CoreX3DNode
    AmbientIntensity *float32 `xml:"ambientIntensity,attr,omitempty""`
    Attenuation *SFVec3f `xml:"attenuation,attr,omitempty""`
    BeamWidth *float32 `xml:"beamWidth,attr,omitempty""`
    Color *SFColor `xml:"color,attr,omitempty""`
    CutOffAngle *float32 `xml:"cutOffAngle,attr,omitempty""`
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    Global *bool `xml:"global,attr,omitempty""`
    Intensity *float32 `xml:"intensity,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Location *SFVec3f `xml:"location,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    Radius *float32 `xml:"radius,attr,omitempty""`
    ShadowIntensity *float32 `xml:"shadowIntensity,attr,omitempty""`
    Shadows *bool `xml:"shadows,attr,omitempty""`
}

func (n *SpotLight) GetNodeName() string { return "SpotLight" }
func (n *SpotLight) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/lighting.html#SpotLight" }
func (n *SpotLight) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SpotLight) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AmbientIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ambientIntensity"}, Value: fmt.Sprintf("%v", *n.AmbientIntensity)}) }
    if n.Attenuation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "attenuation"}, Value: fmt.Sprintf("%v", *n.Attenuation)}) }
    if n.BeamWidth != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "beamWidth"}, Value: fmt.Sprintf("%v", *n.BeamWidth)}) }
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.CutOffAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "cutOffAngle"}, Value: fmt.Sprintf("%v", *n.CutOffAngle)}) }
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.Global != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "global"}, Value: fmt.Sprintf("%v", *n.Global)}) }
    if n.Intensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intensity"}, Value: fmt.Sprintf("%v", *n.Intensity)}) }
    if n.Location != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "location"}, Value: fmt.Sprintf("%v", *n.Location)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.Radius != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radius"}, Value: fmt.Sprintf("%v", *n.Radius)}) }
    if n.ShadowIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadowIntensity"}, Value: fmt.Sprintf("%v", *n.ShadowIntensity)}) }
    if n.Shadows != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadows"}, Value: fmt.Sprintf("%v", *n.Shadows)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SquadOrientationInterpolator: SquadOrientationInterpolator performs non-linear interpolation among paired lists of rotation values to produce an SFRotation value_changed output event.
type SquadOrientationInterpolator struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Key []float32 `xml:"key,attr,omitempty""`
    KeyValue *MFRotation `xml:"keyValue,attr,omitempty""`
    NormalizeVelocity *bool `xml:"normalizeVelocity,attr,omitempty""`
    SetFraction *float32 `xml:"set_fraction,attr,omitempty""`
    ValueChanged *SFRotation `xml:"value_changed,attr,omitempty""`
}

func (n *SquadOrientationInterpolator) GetNodeName() string { return "SquadOrientationInterpolator" }
func (n *SquadOrientationInterpolator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/interpolators.html#SquadOrientationInterpolator" }
func (n *SquadOrientationInterpolator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SquadOrientationInterpolator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Key != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "key"}, Value: fmt.Sprintf("%v", n.Key)}) }
    if n.KeyValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "keyValue"}, Value: fmt.Sprintf("%v", *n.KeyValue)}) }
    if n.NormalizeVelocity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalizeVelocity"}, Value: fmt.Sprintf("%v", *n.NormalizeVelocity)}) }
    if n.SetFraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_fraction"}, Value: fmt.Sprintf("%v", *n.SetFraction)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// StaticGroup: StaticGroup is similar to Group node but does not allow access to children after creation time.
type StaticGroup struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *StaticGroup) GetNodeName() string { return "StaticGroup" }
func (n *StaticGroup) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#StaticGroup" }
func (n *StaticGroup) Validate() error {
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *StaticGroup) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// StreamAudioDestination: StreamAudioDestination node represents the final audio destination via a media stream.
type StreamAudioDestination struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    MediaDeviceID *string `xml:"mediaDeviceID,attr,omitempty""`
    StreamIdentifier []string `xml:"streamIdentifier,attr,omitempty""`
}

func (n *StreamAudioDestination) GetNodeName() string { return "StreamAudioDestination" }
func (n *StreamAudioDestination) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#StreamAudioDestination" }
func (n *StreamAudioDestination) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *StreamAudioDestination) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.MediaDeviceID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mediaDeviceID"}, Value: fmt.Sprintf("%v", *n.MediaDeviceID)}) }
    if n.StreamIdentifier != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "streamIdentifier"}, Value: fmt.Sprintf("%v", n.StreamIdentifier)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// StreamAudioSource: StreamAudioSource operates as an audio source whose media is received from a MediaStream obtained using the WebRTC or Media Capture and Streams APIs.
type StreamAudioSource struct {
    CoreX3DNode
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    StreamIdentifier []string `xml:"streamIdentifier,attr,omitempty""`
}

func (n *StreamAudioSource) GetNodeName() string { return "StreamAudioSource" }
func (n *StreamAudioSource) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#StreamAudioSource" }
func (n *StreamAudioSource) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *StreamAudioSource) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.StreamIdentifier != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "streamIdentifier"}, Value: fmt.Sprintf("%v", n.StreamIdentifier)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// StringSensor: StringSensor generates events as the user presses keys on the keyboard.
type StringSensor struct {
    CoreX3DNode
    DeletionAllowed *bool `xml:"deletionAllowed,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EnteredText *string `xml:"enteredText,attr,omitempty""`
    FinalText *string `xml:"finalText,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
}

func (n *StringSensor) GetNodeName() string { return "StringSensor" }
func (n *StringSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/keyDeviceSensor.html#StringSensor" }
func (n *StringSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *StringSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.DeletionAllowed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "deletionAllowed"}, Value: fmt.Sprintf("%v", *n.DeletionAllowed)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EnteredText != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enteredText"}, Value: fmt.Sprintf("%v", *n.EnteredText)}) }
    if n.FinalText != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "finalText"}, Value: fmt.Sprintf("%v", *n.FinalText)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SurfaceEmitter: SurfaceEmitter generates particles from the surface of an object.
type SurfaceEmitter struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Mass *float32 `xml:"mass,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    Speed *float32 `xml:"speed,attr,omitempty""`
    Surface X3DNode `xml:"surface,omitempty""`
    SurfaceArea *float32 `xml:"surfaceArea,attr,omitempty""`
    Variation *float32 `xml:"variation,attr,omitempty""`
}

func (n *SurfaceEmitter) GetNodeName() string { return "SurfaceEmitter" }
func (n *SurfaceEmitter) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#SurfaceEmitter" }
func (n *SurfaceEmitter) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Surface != nil {
        if err := n.Surface.Validate(); err != nil { return fmt.Errorf("validation error in Surface: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SurfaceEmitter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Mass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mass"}, Value: fmt.Sprintf("%v", *n.Mass)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.Speed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speed"}, Value: fmt.Sprintf("%v", *n.Speed)}) }
    if n.SurfaceArea != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceArea"}, Value: fmt.Sprintf("%v", *n.SurfaceArea)}) }
    if n.Variation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "variation"}, Value: fmt.Sprintf("%v", *n.Variation)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Surface != nil {
        if err := e.EncodeElement(n.Surface, xml.StartElement{Name: xml.Name{Local: n.Surface.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Switch: Switch is a Grouping node that only renders one (or zero) child at a time.
type Switch struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
    WhichChoice *int32 `xml:"whichChoice,attr,omitempty""`
}

func (n *Switch) GetNodeName() string { return "Switch" }
func (n *Switch) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#Switch" }
func (n *Switch) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Switch) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.WhichChoice != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "whichChoice"}, Value: fmt.Sprintf("%v", *n.WhichChoice)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// TexCoordChaser2D: TexCoordChaser2D generates a series of single floating-point values that progressively change from initial value to destination value.
type TexCoordChaser2D struct {
    CoreX3DNode
    Duration *float64 `xml:"duration,attr,omitempty""`
    InitialDestination *MFVec2f `xml:"initialDestination,attr,omitempty""`
    InitialValue *MFVec2f `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    SetDestination *MFVec2f `xml:"set_destination,attr,omitempty""`
    SetValue *MFVec2f `xml:"set_value,attr,omitempty""`
    ValueChanged *MFVec2f `xml:"value_changed,attr,omitempty""`
}

func (n *TexCoordChaser2D) GetNodeName() string { return "TexCoordChaser2D" }
func (n *TexCoordChaser2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#TexCoordChaser2D" }
func (n *TexCoordChaser2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TexCoordChaser2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Duration != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "duration"}, Value: fmt.Sprintf("%v", *n.Duration)}) }
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TexCoordDamper2D: TexCoordDamper2D generates a series of 2D floating-point arrays that progressively change from initial value to destination value.
type TexCoordDamper2D struct {
    CoreX3DNode
    InitialDestination *MFVec2f `xml:"initialDestination,attr,omitempty""`
    InitialValue *MFVec2f `xml:"initialValue,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    Order *int32 `xml:"order,attr,omitempty""`
    SetDestination *MFVec2f `xml:"set_destination,attr,omitempty""`
    SetValue *MFVec2f `xml:"set_value,attr,omitempty""`
    Tau *float64 `xml:"tau,attr,omitempty""`
    Tolerance *float32 `xml:"tolerance,attr,omitempty""`
    ValueChanged *MFVec2f `xml:"value_changed,attr,omitempty""`
}

func (n *TexCoordDamper2D) GetNodeName() string { return "TexCoordDamper2D" }
func (n *TexCoordDamper2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/followers.html#TexCoordDamper2D" }
func (n *TexCoordDamper2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TexCoordDamper2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.InitialDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialDestination"}, Value: fmt.Sprintf("%v", *n.InitialDestination)}) }
    if n.InitialValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "initialValue"}, Value: fmt.Sprintf("%v", *n.InitialValue)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.Order != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "order"}, Value: fmt.Sprintf("%v", *n.Order)}) }
    if n.SetDestination != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_destination"}, Value: fmt.Sprintf("%v", *n.SetDestination)}) }
    if n.SetValue != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_value"}, Value: fmt.Sprintf("%v", *n.SetValue)}) }
    if n.Tau != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tau"}, Value: fmt.Sprintf("%v", *n.Tau)}) }
    if n.Tolerance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tolerance"}, Value: fmt.Sprintf("%v", *n.Tolerance)}) }
    if n.ValueChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value_changed"}, Value: fmt.Sprintf("%v", *n.ValueChanged)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Text: Text is a 2D (flat) geometry node that can contain multiple lines of string values.
type Text struct {
    CoreX3DNode
    FontStyle X3DNode `xml:"fontStyle,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Length []float32 `xml:"length,attr,omitempty""`
    LineBounds *MFVec2f `xml:"lineBounds,attr,omitempty""`
    MaxExtent *float32 `xml:"maxExtent,attr,omitempty""`
    Origin *SFVec3f `xml:"origin,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    String []string `xml:"string,attr,omitempty""`
    TextBounds *SFVec2f `xml:"textBounds,attr,omitempty""`
}

func (n *Text) GetNodeName() string { return "Text" }
func (n *Text) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/text.html#Text" }
func (n *Text) Validate() error {
    if n.FontStyle != nil {
        if err := n.FontStyle.Validate(); err != nil { return fmt.Errorf("validation error in FontStyle: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Text) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Length != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "length"}, Value: fmt.Sprintf("%v", n.Length)}) }
    if n.LineBounds != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "lineBounds"}, Value: fmt.Sprintf("%v", *n.LineBounds)}) }
    if n.MaxExtent != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "maxExtent"}, Value: fmt.Sprintf("%v", *n.MaxExtent)}) }
    if n.Origin != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "origin"}, Value: fmt.Sprintf("%v", *n.Origin)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.String != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "string"}, Value: fmt.Sprintf("%v", n.String)}) }
    if n.TextBounds != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "textBounds"}, Value: fmt.Sprintf("%v", *n.TextBounds)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.FontStyle != nil {
        if err := e.EncodeElement(n.FontStyle, xml.StartElement{Name: xml.Name{Local: n.FontStyle.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureBackground: TextureBackground simulates ground and sky, using vertical arrays of wraparound color values, TextureBackground can also provide backdrop texture images on all six sides.
type TextureBackground struct {
    CoreX3DNode
    BackTexture X3DNode `xml:"backTexture,omitempty""`
    BindTime *float64 `xml:"bindTime,attr,omitempty""`
    BottomTexture X3DNode `xml:"bottomTexture,omitempty""`
    FrontTexture X3DNode `xml:"frontTexture,omitempty""`
    GroundAngle []float32 `xml:"groundAngle,attr,omitempty""`
    GroundColor *MFColor `xml:"groundColor,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsBound *bool `xml:"isBound,attr,omitempty""`
    LeftTexture X3DNode `xml:"leftTexture,omitempty""`
    RightTexture X3DNode `xml:"rightTexture,omitempty""`
    SetBind *bool `xml:"set_bind,attr,omitempty""`
    SkyAngle []float32 `xml:"skyAngle,attr,omitempty""`
    SkyColor *MFColor `xml:"skyColor,attr,omitempty""`
    TopTexture X3DNode `xml:"topTexture,omitempty""`
    Transparency *float32 `xml:"transparency,attr,omitempty""`
}

func (n *TextureBackground) GetNodeName() string { return "TextureBackground" }
func (n *TextureBackground) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalEffects.html#TextureBackground" }
func (n *TextureBackground) Validate() error {
    if n.BackTexture != nil {
        if err := n.BackTexture.Validate(); err != nil { return fmt.Errorf("validation error in BackTexture: %w", err) }
    }
    if n.BottomTexture != nil {
        if err := n.BottomTexture.Validate(); err != nil { return fmt.Errorf("validation error in BottomTexture: %w", err) }
    }
    if n.FrontTexture != nil {
        if err := n.FrontTexture.Validate(); err != nil { return fmt.Errorf("validation error in FrontTexture: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.LeftTexture != nil {
        if err := n.LeftTexture.Validate(); err != nil { return fmt.Errorf("validation error in LeftTexture: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RightTexture != nil {
        if err := n.RightTexture.Validate(); err != nil { return fmt.Errorf("validation error in RightTexture: %w", err) }
    }
    if n.TopTexture != nil {
        if err := n.TopTexture.Validate(); err != nil { return fmt.Errorf("validation error in TopTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureBackground) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BindTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bindTime"}, Value: fmt.Sprintf("%v", *n.BindTime)}) }
    if n.GroundAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "groundAngle"}, Value: fmt.Sprintf("%v", n.GroundAngle)}) }
    if n.GroundColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "groundColor"}, Value: fmt.Sprintf("%v", *n.GroundColor)}) }
    if n.IsBound != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isBound"}, Value: fmt.Sprintf("%v", *n.IsBound)}) }
    if n.SetBind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_bind"}, Value: fmt.Sprintf("%v", *n.SetBind)}) }
    if n.SkyAngle != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "skyAngle"}, Value: fmt.Sprintf("%v", n.SkyAngle)}) }
    if n.SkyColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "skyColor"}, Value: fmt.Sprintf("%v", *n.SkyColor)}) }
    if n.Transparency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transparency"}, Value: fmt.Sprintf("%v", *n.Transparency)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.BackTexture != nil {
        if err := e.EncodeElement(n.BackTexture, xml.StartElement{Name: xml.Name{Local: n.BackTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.BottomTexture != nil {
        if err := e.EncodeElement(n.BottomTexture, xml.StartElement{Name: xml.Name{Local: n.BottomTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.FrontTexture != nil {
        if err := e.EncodeElement(n.FrontTexture, xml.StartElement{Name: xml.Name{Local: n.FrontTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.LeftTexture != nil {
        if err := e.EncodeElement(n.LeftTexture, xml.StartElement{Name: xml.Name{Local: n.LeftTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RightTexture != nil {
        if err := e.EncodeElement(n.RightTexture, xml.StartElement{Name: xml.Name{Local: n.RightTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.TopTexture != nil {
        if err := e.EncodeElement(n.TopTexture, xml.StartElement{Name: xml.Name{Local: n.TopTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureCoordinate: TextureCoordinate specifies 2D (s,t) texture-coordinate points, used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map textures to vertices (and patches to NURBS surfaces).
type TextureCoordinate struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Mapping *string `xml:"mapping,attr,omitempty""`
    Point *MFVec2f `xml:"point,attr,omitempty""`
}

func (n *TextureCoordinate) GetNodeName() string { return "TextureCoordinate" }
func (n *TextureCoordinate) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#TextureCoordinate" }
func (n *TextureCoordinate) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureCoordinate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Mapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mapping"}, Value: fmt.Sprintf("%v", *n.Mapping)}) }
    if n.Point != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "point"}, Value: fmt.Sprintf("%v", *n.Point)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureCoordinate3D: TextureCoordinate3D specifies a set of 3D texture coordinates used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map 3D textures to vertices.
type TextureCoordinate3D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Mapping *string `xml:"mapping,attr,omitempty""`
    Point *MFVec3f `xml:"point,attr,omitempty""`
}

func (n *TextureCoordinate3D) GetNodeName() string { return "TextureCoordinate3D" }
func (n *TextureCoordinate3D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#TextureCoordinate3D" }
func (n *TextureCoordinate3D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureCoordinate3D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Mapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mapping"}, Value: fmt.Sprintf("%v", *n.Mapping)}) }
    if n.Point != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "point"}, Value: fmt.Sprintf("%v", *n.Point)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureCoordinate4D: TextureCoordinate4D specifies a set of 4D (homogeneous 3D) texture coordinates used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map 3D textures to vertices.
type TextureCoordinate4D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Mapping *string `xml:"mapping,attr,omitempty""`
    Point *MFVec4f `xml:"point,attr,omitempty""`
}

func (n *TextureCoordinate4D) GetNodeName() string { return "TextureCoordinate4D" }
func (n *TextureCoordinate4D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#TextureCoordinate4D" }
func (n *TextureCoordinate4D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureCoordinate4D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Mapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mapping"}, Value: fmt.Sprintf("%v", *n.Mapping)}) }
    if n.Point != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "point"}, Value: fmt.Sprintf("%v", *n.Point)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureCoordinateGenerator: TextureCoordinateGenerator computes 2D (s,t) texture-coordinate points, used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map textures to vertices (and patches to NURBS surfaces).
type TextureCoordinateGenerator struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Mapping *string `xml:"mapping,attr,omitempty""`
    Mode *string `xml:"mode,attr,omitempty""`
    Parameter []float32 `xml:"parameter,attr,omitempty""`
}

func (n *TextureCoordinateGenerator) GetNodeName() string { return "TextureCoordinateGenerator" }
func (n *TextureCoordinateGenerator) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#TextureCoordinateGenerator" }
func (n *TextureCoordinateGenerator) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Mode != nil {
        switch *n.Mode {
        case TextureCoordinateGeneratorModeChoicesSPHERE, TextureCoordinateGeneratorModeChoicesCAMERASPACENORMAL, TextureCoordinateGeneratorModeChoicesCAMERASPACEPOSITION, TextureCoordinateGeneratorModeChoicesCAMERASPACEREFLECTIONVECTOR, TextureCoordinateGeneratorModeChoicesSPHERELOCAL, TextureCoordinateGeneratorModeChoicesCOORD, TextureCoordinateGeneratorModeChoicesCOORDEYE, TextureCoordinateGeneratorModeChoicesNOISE, TextureCoordinateGeneratorModeChoicesNOISEEYE, TextureCoordinateGeneratorModeChoicesSPHEREREFLECT, TextureCoordinateGeneratorModeChoicesSPHEREREFLECTLOCAL: // valid
        default: return fmt.Errorf("invalid value for field mode: %s", *n.Mode)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureCoordinateGenerator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Mapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mapping"}, Value: fmt.Sprintf("%v", *n.Mapping)}) }
    if n.Mode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mode"}, Value: fmt.Sprintf("%v", *n.Mode)}) }
    if n.Parameter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "parameter"}, Value: fmt.Sprintf("%v", n.Parameter)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureProjector: TextureProjector is similar to a light that projects a texture into the scene, illuminating geometry that intersects the perspective projection volume.
type TextureProjector struct {
    CoreX3DNode
    AmbientIntensity *float32 `xml:"ambientIntensity,attr,omitempty""`
    AspectRatio *float32 `xml:"aspectRatio,attr,omitempty""`
    Color *SFColor `xml:"color,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    FarDistance *float32 `xml:"farDistance,attr,omitempty""`
    FieldOfView *float32 `xml:"fieldOfView,attr,omitempty""`
    Global *bool `xml:"global,attr,omitempty""`
    Intensity *float32 `xml:"intensity,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Location *SFVec3f `xml:"location,attr,omitempty""`
    NearDistance *float32 `xml:"nearDistance,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    ShadowIntensity *float32 `xml:"shadowIntensity,attr,omitempty""`
    Shadows *bool `xml:"shadows,attr,omitempty""`
    Texture X3DNode `xml:"texture,omitempty""`
    UpVector *SFVec3f `xml:"upVector,attr,omitempty""`
}

func (n *TextureProjector) GetNodeName() string { return "TextureProjector" }
func (n *TextureProjector) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/textureProjector.html#TextureProjector" }
func (n *TextureProjector) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Texture != nil {
        if err := n.Texture.Validate(); err != nil { return fmt.Errorf("validation error in Texture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureProjector) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AmbientIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ambientIntensity"}, Value: fmt.Sprintf("%v", *n.AmbientIntensity)}) }
    if n.AspectRatio != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "aspectRatio"}, Value: fmt.Sprintf("%v", *n.AspectRatio)}) }
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.FarDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "farDistance"}, Value: fmt.Sprintf("%v", *n.FarDistance)}) }
    if n.FieldOfView != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fieldOfView"}, Value: fmt.Sprintf("%v", *n.FieldOfView)}) }
    if n.Global != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "global"}, Value: fmt.Sprintf("%v", *n.Global)}) }
    if n.Intensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intensity"}, Value: fmt.Sprintf("%v", *n.Intensity)}) }
    if n.Location != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "location"}, Value: fmt.Sprintf("%v", *n.Location)}) }
    if n.NearDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "nearDistance"}, Value: fmt.Sprintf("%v", *n.NearDistance)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.ShadowIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadowIntensity"}, Value: fmt.Sprintf("%v", *n.ShadowIntensity)}) }
    if n.Shadows != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadows"}, Value: fmt.Sprintf("%v", *n.Shadows)}) }
    if n.UpVector != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "upVector"}, Value: fmt.Sprintf("%v", *n.UpVector)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Texture != nil {
        if err := e.EncodeElement(n.Texture, xml.StartElement{Name: xml.Name{Local: n.Texture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureProjectorParallel: TextureProjectorParallel is similar to a light that projects a texture into the scene, illuminating geometry that intersects the parallel projection volume.
type TextureProjectorParallel struct {
    CoreX3DNode
    AmbientIntensity *float32 `xml:"ambientIntensity,attr,omitempty""`
    AspectRatio *float32 `xml:"aspectRatio,attr,omitempty""`
    Color *SFColor `xml:"color,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    FarDistance *float32 `xml:"farDistance,attr,omitempty""`
    FieldOfView *SFVec4f `xml:"fieldOfView,attr,omitempty""`
    Global *bool `xml:"global,attr,omitempty""`
    Intensity *float32 `xml:"intensity,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Location *SFVec3f `xml:"location,attr,omitempty""`
    NearDistance *float32 `xml:"nearDistance,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    ShadowIntensity *float32 `xml:"shadowIntensity,attr,omitempty""`
    Shadows *bool `xml:"shadows,attr,omitempty""`
    Texture X3DNode `xml:"texture,omitempty""`
    UpVector *SFVec3f `xml:"upVector,attr,omitempty""`
}

func (n *TextureProjectorParallel) GetNodeName() string { return "TextureProjectorParallel" }
func (n *TextureProjectorParallel) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/textureProjector.html#TextureProjectorParallel" }
func (n *TextureProjectorParallel) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Texture != nil {
        if err := n.Texture.Validate(); err != nil { return fmt.Errorf("validation error in Texture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureProjectorParallel) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AmbientIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ambientIntensity"}, Value: fmt.Sprintf("%v", *n.AmbientIntensity)}) }
    if n.AspectRatio != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "aspectRatio"}, Value: fmt.Sprintf("%v", *n.AspectRatio)}) }
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.FarDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "farDistance"}, Value: fmt.Sprintf("%v", *n.FarDistance)}) }
    if n.FieldOfView != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fieldOfView"}, Value: fmt.Sprintf("%v", *n.FieldOfView)}) }
    if n.Global != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "global"}, Value: fmt.Sprintf("%v", *n.Global)}) }
    if n.Intensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intensity"}, Value: fmt.Sprintf("%v", *n.Intensity)}) }
    if n.Location != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "location"}, Value: fmt.Sprintf("%v", *n.Location)}) }
    if n.NearDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "nearDistance"}, Value: fmt.Sprintf("%v", *n.NearDistance)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.ShadowIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadowIntensity"}, Value: fmt.Sprintf("%v", *n.ShadowIntensity)}) }
    if n.Shadows != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadows"}, Value: fmt.Sprintf("%v", *n.Shadows)}) }
    if n.UpVector != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "upVector"}, Value: fmt.Sprintf("%v", *n.UpVector)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Texture != nil {
        if err := e.EncodeElement(n.Texture, xml.StartElement{Name: xml.Name{Local: n.Texture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureProperties: TextureProperties allows precise fine-grained control over application of image textures to geometry.
type TextureProperties struct {
    CoreX3DNode
    AnisotropicDegree *float32 `xml:"anisotropicDegree,attr,omitempty""`
    BorderColor *SFColorRGBA `xml:"borderColor,attr,omitempty""`
    BorderWidth *int32 `xml:"borderWidth,attr,omitempty""`
    BoundaryModeR *string `xml:"boundaryModeR,attr,omitempty""`
    BoundaryModeS *string `xml:"boundaryModeS,attr,omitempty""`
    BoundaryModeT *string `xml:"boundaryModeT,attr,omitempty""`
    GenerateMipMaps *bool `xml:"generateMipMaps,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    MagnificationFilter *string `xml:"magnificationFilter,attr,omitempty""`
    MinificationFilter *string `xml:"minificationFilter,attr,omitempty""`
    TextureCompression *string `xml:"textureCompression,attr,omitempty""`
    TexturePriority *float32 `xml:"texturePriority,attr,omitempty""`
}

func (n *TextureProperties) GetNodeName() string { return "TextureProperties" }
func (n *TextureProperties) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#TextureProperties" }
func (n *TextureProperties) Validate() error {
    if n.BoundaryModeR != nil {
        switch *n.BoundaryModeR {
        case TextureBoundaryModeChoicesCLAMP, TextureBoundaryModeChoicesCLAMPTOEDGE, TextureBoundaryModeChoicesCLAMPTOBOUNDARY, TextureBoundaryModeChoicesMIRROREDREPEAT, TextureBoundaryModeChoicesREPEAT: // valid
        default: return fmt.Errorf("invalid value for field boundaryModeR: %s", *n.BoundaryModeR)
        }
    }
    if n.BoundaryModeS != nil {
        switch *n.BoundaryModeS {
        case TextureBoundaryModeChoicesCLAMP, TextureBoundaryModeChoicesCLAMPTOEDGE, TextureBoundaryModeChoicesCLAMPTOBOUNDARY, TextureBoundaryModeChoicesMIRROREDREPEAT, TextureBoundaryModeChoicesREPEAT: // valid
        default: return fmt.Errorf("invalid value for field boundaryModeS: %s", *n.BoundaryModeS)
        }
    }
    if n.BoundaryModeT != nil {
        switch *n.BoundaryModeT {
        case TextureBoundaryModeChoicesCLAMP, TextureBoundaryModeChoicesCLAMPTOEDGE, TextureBoundaryModeChoicesCLAMPTOBOUNDARY, TextureBoundaryModeChoicesMIRROREDREPEAT, TextureBoundaryModeChoicesREPEAT: // valid
        default: return fmt.Errorf("invalid value for field boundaryModeT: %s", *n.BoundaryModeT)
        }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.MagnificationFilter != nil {
        switch *n.MagnificationFilter {
        case TextureMagnificationModeChoicesAVGPIXEL, TextureMagnificationModeChoicesDEFAULT, TextureMagnificationModeChoicesFASTEST, TextureMagnificationModeChoicesNEARESTPIXEL, TextureMagnificationModeChoicesNICEST: // valid
        default: return fmt.Errorf("invalid value for field magnificationFilter: %s", *n.MagnificationFilter)
        }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.MinificationFilter != nil {
        switch *n.MinificationFilter {
        case TextureMinificationModeChoicesAVGPIXEL, TextureMinificationModeChoicesAVGPIXELAVGMIPMAP, TextureMinificationModeChoicesAVGPIXELNEARESTMIPMAP, TextureMinificationModeChoicesDEFAULT, TextureMinificationModeChoicesFASTEST, TextureMinificationModeChoicesNEARESTPIXEL, TextureMinificationModeChoicesNEARESTPIXELAVGMIPMAP, TextureMinificationModeChoicesNEARESTPIXELNEARESTMIPMAP, TextureMinificationModeChoicesNICEST: // valid
        default: return fmt.Errorf("invalid value for field minificationFilter: %s", *n.MinificationFilter)
        }
    }
    if n.TextureCompression != nil {
        switch *n.TextureCompression {
        case TextureCompressionModeChoicesDEFAULT, TextureCompressionModeChoicesFASTEST, TextureCompressionModeChoicesHIGH, TextureCompressionModeChoicesLOW, TextureCompressionModeChoicesMEDIUM, TextureCompressionModeChoicesNICEST: // valid
        default: return fmt.Errorf("invalid value for field textureCompression: %s", *n.TextureCompression)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AnisotropicDegree != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "anisotropicDegree"}, Value: fmt.Sprintf("%v", *n.AnisotropicDegree)}) }
    if n.BorderColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "borderColor"}, Value: fmt.Sprintf("%v", *n.BorderColor)}) }
    if n.BorderWidth != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "borderWidth"}, Value: fmt.Sprintf("%v", *n.BorderWidth)}) }
    if n.BoundaryModeR != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "boundaryModeR"}, Value: fmt.Sprintf("%v", *n.BoundaryModeR)}) }
    if n.BoundaryModeS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "boundaryModeS"}, Value: fmt.Sprintf("%v", *n.BoundaryModeS)}) }
    if n.BoundaryModeT != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "boundaryModeT"}, Value: fmt.Sprintf("%v", *n.BoundaryModeT)}) }
    if n.GenerateMipMaps != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "generateMipMaps"}, Value: fmt.Sprintf("%v", *n.GenerateMipMaps)}) }
    if n.MagnificationFilter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "magnificationFilter"}, Value: fmt.Sprintf("%v", *n.MagnificationFilter)}) }
    if n.MinificationFilter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "minificationFilter"}, Value: fmt.Sprintf("%v", *n.MinificationFilter)}) }
    if n.TextureCompression != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "textureCompression"}, Value: fmt.Sprintf("%v", *n.TextureCompression)}) }
    if n.TexturePriority != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "texturePriority"}, Value: fmt.Sprintf("%v", *n.TexturePriority)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureTransform: TextureTransform shifts 2D texture coordinates for positioning, orienting and scaling image textures on geometry.
type TextureTransform struct {
    CoreX3DNode
    Center *SFVec2f `xml:"center,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Mapping *string `xml:"mapping,attr,omitempty""`
    Rotation *float32 `xml:"rotation,attr,omitempty""`
    Scale *SFVec2f `xml:"scale,attr,omitempty""`
    Translation *SFVec2f `xml:"translation,attr,omitempty""`
}

func (n *TextureTransform) GetNodeName() string { return "TextureTransform" }
func (n *TextureTransform) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texturing.html#TextureTransform" }
func (n *TextureTransform) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureTransform) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Mapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mapping"}, Value: fmt.Sprintf("%v", *n.Mapping)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureTransform3D: TextureTransform3D applies a 3D transformation to texture coordinates.
type TextureTransform3D struct {
    CoreX3DNode
    Center *SFVec3f `xml:"center,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Mapping *string `xml:"mapping,attr,omitempty""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    Scale *SFVec3f `xml:"scale,attr,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
}

func (n *TextureTransform3D) GetNodeName() string { return "TextureTransform3D" }
func (n *TextureTransform3D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#TextureTransform3D" }
func (n *TextureTransform3D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureTransform3D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Mapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mapping"}, Value: fmt.Sprintf("%v", *n.Mapping)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TextureTransformMatrix3D: TextureTransformMatrix3D applies a 3D transformation to texture coordinates.
type TextureTransformMatrix3D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Mapping *string `xml:"mapping,attr,omitempty""`
    Matrix *SFMatrix4f `xml:"matrix,attr,omitempty""`
}

func (n *TextureTransformMatrix3D) GetNodeName() string { return "TextureTransformMatrix3D" }
func (n *TextureTransformMatrix3D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/texture3D.html#TextureTransformMatrix3D" }
func (n *TextureTransformMatrix3D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TextureTransformMatrix3D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Mapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mapping"}, Value: fmt.Sprintf("%v", *n.Mapping)}) }
    if n.Matrix != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "matrix"}, Value: fmt.Sprintf("%v", *n.Matrix)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TimeSensor: TimeSensor continuously generates events as time passes.
type TimeSensor struct {
    CoreX3DNode
    CycleInterval *float64 `xml:"cycleInterval,attr,omitempty""`
    CycleTime *float64 `xml:"cycleTime,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    FractionChanged *float32 `xml:"fraction_changed,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    Loop *bool `xml:"loop,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    Time *float64 `xml:"time,attr,omitempty""`
}

func (n *TimeSensor) GetNodeName() string { return "TimeSensor" }
func (n *TimeSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/time.html#TimeSensor" }
func (n *TimeSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TimeSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.CycleInterval != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "cycleInterval"}, Value: fmt.Sprintf("%v", *n.CycleInterval)}) }
    if n.CycleTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "cycleTime"}, Value: fmt.Sprintf("%v", *n.CycleTime)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.FractionChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fraction_changed"}, Value: fmt.Sprintf("%v", *n.FractionChanged)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.Loop != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "loop"}, Value: fmt.Sprintf("%v", *n.Loop)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.Time != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "time"}, Value: fmt.Sprintf("%v", *n.Time)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TimeTrigger: TimeTrigger converts boolean true events to time events.
type TimeTrigger struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    SetBoolean *bool `xml:"set_boolean,attr,omitempty""`
    TriggerTime *float64 `xml:"triggerTime,attr,omitempty""`
}

func (n *TimeTrigger) GetNodeName() string { return "TimeTrigger" }
func (n *TimeTrigger) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/eventUtilities.html#TimeTrigger" }
func (n *TimeTrigger) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TimeTrigger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.SetBoolean != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_boolean"}, Value: fmt.Sprintf("%v", *n.SetBoolean)}) }
    if n.TriggerTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "triggerTime"}, Value: fmt.Sprintf("%v", *n.TriggerTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ToneMappedVolumeStyle: ToneMappedVolumeStyle specifies that volumetric data is rendered with Gooch shading model of two-toned warm/cool coloring.
type ToneMappedVolumeStyle struct {
    CoreX3DNode
    CoolColor *SFColorRGBA `xml:"coolColor,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    SurfaceNormals X3DNode `xml:"surfaceNormals,omitempty""`
    WarmColor *SFColorRGBA `xml:"warmColor,attr,omitempty""`
}

func (n *ToneMappedVolumeStyle) GetNodeName() string { return "ToneMappedVolumeStyle" }
func (n *ToneMappedVolumeStyle) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#ToneMappedVolumeStyle" }
func (n *ToneMappedVolumeStyle) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.SurfaceNormals != nil {
        if err := n.SurfaceNormals.Validate(); err != nil { return fmt.Errorf("validation error in SurfaceNormals: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ToneMappedVolumeStyle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.CoolColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "coolColor"}, Value: fmt.Sprintf("%v", *n.CoolColor)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.WarmColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "warmColor"}, Value: fmt.Sprintf("%v", *n.WarmColor)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.SurfaceNormals != nil {
        if err := e.EncodeElement(n.SurfaceNormals, xml.StartElement{Name: xml.Name{Local: n.SurfaceNormals.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TouchSensor: TouchSensor tracks location and state of the pointing device, detecting when a user points at or selects (activates) geometry.
type TouchSensor struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    HitNormalChanged *SFVec3f `xml:"hitNormal_changed,attr,omitempty""`
    HitPointChanged *SFVec3f `xml:"hitPoint_changed,attr,omitempty""`
    HitTexCoordChanged *SFVec2f `xml:"hitTexCoord_changed,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsOver *bool `xml:"isOver,attr,omitempty""`
    TouchTime *float64 `xml:"touchTime,attr,omitempty""`
}

func (n *TouchSensor) GetNodeName() string { return "TouchSensor" }
func (n *TouchSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/pointingDeviceSensor.html#TouchSensor" }
func (n *TouchSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TouchSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.HitNormalChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hitNormal_changed"}, Value: fmt.Sprintf("%v", *n.HitNormalChanged)}) }
    if n.HitPointChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hitPoint_changed"}, Value: fmt.Sprintf("%v", *n.HitPointChanged)}) }
    if n.HitTexCoordChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "hitTexCoord_changed"}, Value: fmt.Sprintf("%v", *n.HitTexCoordChanged)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsOver != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isOver"}, Value: fmt.Sprintf("%v", *n.IsOver)}) }
    if n.TouchTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "touchTime"}, Value: fmt.Sprintf("%v", *n.TouchTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Transform: Transform is a Grouping node that can contain most nodes.
type Transform struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    Scale *SFVec3f `xml:"scale,attr,omitempty""`
    ScaleOrientation *SFRotation `xml:"scaleOrientation,attr,omitempty""`
    Translation *SFVec3f `xml:"translation,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *Transform) GetNodeName() string { return "Transform" }
func (n *Transform) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/grouping.html#Transform" }
func (n *Transform) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Transform) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.Scale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scale"}, Value: fmt.Sprintf("%v", *n.Scale)}) }
    if n.ScaleOrientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scaleOrientation"}, Value: fmt.Sprintf("%v", *n.ScaleOrientation)}) }
    if n.Translation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translation"}, Value: fmt.Sprintf("%v", *n.Translation)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// TransformSensor: TransformSensor generates output events when its targetObject enters, exits, and moves within a region in space (defined by a box).
type TransformSensor struct {
    CoreX3DNode
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EnterTime *float64 `xml:"enterTime,attr,omitempty""`
    ExitTime *float64 `xml:"exitTime,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    OrientationChanged *SFRotation `xml:"orientation_changed,attr,omitempty""`
    PositionChanged *SFVec3f `xml:"position_changed,attr,omitempty""`
    Size *SFVec3f `xml:"size,attr,omitempty""`
    TargetObject X3DNode `xml:"targetObject,omitempty""`
}

func (n *TransformSensor) GetNodeName() string { return "TransformSensor" }
func (n *TransformSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalSensor.html#TransformSensor" }
func (n *TransformSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TargetObject != nil {
        if err := n.TargetObject.Validate(); err != nil { return fmt.Errorf("validation error in TargetObject: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TransformSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EnterTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enterTime"}, Value: fmt.Sprintf("%v", *n.EnterTime)}) }
    if n.ExitTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "exitTime"}, Value: fmt.Sprintf("%v", *n.ExitTime)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.OrientationChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orientation_changed"}, Value: fmt.Sprintf("%v", *n.OrientationChanged)}) }
    if n.PositionChanged != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position_changed"}, Value: fmt.Sprintf("%v", *n.PositionChanged)}) }
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", *n.Size)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TargetObject != nil {
        if err := e.EncodeElement(n.TargetObject, xml.StartElement{Name: xml.Name{Local: n.TargetObject.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TransmitterPdu: TransmitterPdu is a networked Protocol Data Unit (PDU) information node that provides detailed information about a radio transmitter modeled in a simulation.
type TransmitterPdu struct {
    CoreX3DNode
    Address *string `xml:"address,attr,omitempty""`
    AntennaLocation *SFVec3f `xml:"antennaLocation,attr,omitempty""`
    AntennaPatternLength *int32 `xml:"antennaPatternLength,attr,omitempty""`
    AntennaPatternType *int32 `xml:"antennaPatternType,attr,omitempty""`
    ApplicationID *int32 `xml:"applicationID,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    CryptoKeyID *int32 `xml:"cryptoKeyID,attr,omitempty""`
    CryptoSystem *int32 `xml:"cryptoSystem,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EntityID *int32 `xml:"entityID,attr,omitempty""`
    Frequency *int32 `xml:"frequency,attr,omitempty""`
    GeoCoords *SFVec3d `xml:"geoCoords,attr,omitempty""`
    GeoSystem []string `xml:"geoSystem,attr,omitempty""`
    InputSource *int32 `xml:"inputSource,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsNetworkReader *bool `xml:"isNetworkReader,attr,omitempty""`
    IsNetworkWriter *bool `xml:"isNetworkWriter,attr,omitempty""`
    IsRtpHeaderHeard *bool `xml:"isRtpHeaderHeard,attr,omitempty""`
    IsStandAlone *bool `xml:"isStandAlone,attr,omitempty""`
    LengthOfModulationParameters *int32 `xml:"lengthOfModulationParameters,attr,omitempty""`
    ModulationTypeDetail *int32 `xml:"modulationTypeDetail,attr,omitempty""`
    ModulationTypeMajor *int32 `xml:"modulationTypeMajor,attr,omitempty""`
    ModulationTypeSpreadSpectrum *int32 `xml:"modulationTypeSpreadSpectrum,attr,omitempty""`
    ModulationTypeSystem *int32 `xml:"modulationTypeSystem,attr,omitempty""`
    MulticastRelayHost *string `xml:"multicastRelayHost,attr,omitempty""`
    MulticastRelayPort *int32 `xml:"multicastRelayPort,attr,omitempty""`
    NetworkMode *string `xml:"networkMode,attr,omitempty""`
    Port *int32 `xml:"port,attr,omitempty""`
    Power *float32 `xml:"power,attr,omitempty""`
    RadioEntityTypeCategory *int32 `xml:"radioEntityTypeCategory,attr,omitempty""`
    RadioEntityTypeCountry *int32 `xml:"radioEntityTypeCountry,attr,omitempty""`
    RadioEntityTypeDomain *int32 `xml:"radioEntityTypeDomain,attr,omitempty""`
    RadioEntityTypeKind *int32 `xml:"radioEntityTypeKind,attr,omitempty""`
    RadioEntityTypeNomenclature *int32 `xml:"radioEntityTypeNomenclature,attr,omitempty""`
    RadioEntityTypeNomenclatureVersion *int32 `xml:"radioEntityTypeNomenclatureVersion,attr,omitempty""`
    RadioID *int32 `xml:"radioID,attr,omitempty""`
    ReadInterval *float64 `xml:"readInterval,attr,omitempty""`
    RelativeAntennaLocation *SFVec3f `xml:"relativeAntennaLocation,attr,omitempty""`
    RtpHeaderExpected *bool `xml:"rtpHeaderExpected,attr,omitempty""`
    SiteID *int32 `xml:"siteID,attr,omitempty""`
    Timestamp *float64 `xml:"timestamp,attr,omitempty""`
    TransmitFrequencyBandwidth *float32 `xml:"transmitFrequencyBandwidth,attr,omitempty""`
    TransmitState *int32 `xml:"transmitState,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    WhichGeometry *int32 `xml:"whichGeometry,attr,omitempty""`
    WriteInterval *float64 `xml:"writeInterval,attr,omitempty""`
}

func (n *TransmitterPdu) GetNodeName() string { return "TransmitterPdu" }
func (n *TransmitterPdu) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/dis.html#TransmitterPdu" }
func (n *TransmitterPdu) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.NetworkMode != nil {
        switch *n.NetworkMode {
        case NetworkModeChoicesStandAlone, NetworkModeChoicesNetworkReader, NetworkModeChoicesNetworkWriter: // valid
        default: return fmt.Errorf("invalid value for field networkMode: %s", *n.NetworkMode)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TransmitterPdu) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Address != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "address"}, Value: fmt.Sprintf("%v", *n.Address)}) }
    if n.AntennaLocation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "antennaLocation"}, Value: fmt.Sprintf("%v", *n.AntennaLocation)}) }
    if n.AntennaPatternLength != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "antennaPatternLength"}, Value: fmt.Sprintf("%v", *n.AntennaPatternLength)}) }
    if n.AntennaPatternType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "antennaPatternType"}, Value: fmt.Sprintf("%v", *n.AntennaPatternType)}) }
    if n.ApplicationID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "applicationID"}, Value: fmt.Sprintf("%v", *n.ApplicationID)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.CryptoKeyID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "cryptoKeyID"}, Value: fmt.Sprintf("%v", *n.CryptoKeyID)}) }
    if n.CryptoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "cryptoSystem"}, Value: fmt.Sprintf("%v", *n.CryptoSystem)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EntityID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "entityID"}, Value: fmt.Sprintf("%v", *n.EntityID)}) }
    if n.Frequency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "frequency"}, Value: fmt.Sprintf("%v", *n.Frequency)}) }
    if n.GeoCoords != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoCoords"}, Value: fmt.Sprintf("%v", *n.GeoCoords)}) }
    if n.GeoSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "geoSystem"}, Value: fmt.Sprintf("%v", n.GeoSystem)}) }
    if n.InputSource != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "inputSource"}, Value: fmt.Sprintf("%v", *n.InputSource)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsNetworkReader != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isNetworkReader"}, Value: fmt.Sprintf("%v", *n.IsNetworkReader)}) }
    if n.IsNetworkWriter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isNetworkWriter"}, Value: fmt.Sprintf("%v", *n.IsNetworkWriter)}) }
    if n.IsRtpHeaderHeard != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isRtpHeaderHeard"}, Value: fmt.Sprintf("%v", *n.IsRtpHeaderHeard)}) }
    if n.IsStandAlone != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isStandAlone"}, Value: fmt.Sprintf("%v", *n.IsStandAlone)}) }
    if n.LengthOfModulationParameters != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "lengthOfModulationParameters"}, Value: fmt.Sprintf("%v", *n.LengthOfModulationParameters)}) }
    if n.ModulationTypeDetail != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "modulationTypeDetail"}, Value: fmt.Sprintf("%v", *n.ModulationTypeDetail)}) }
    if n.ModulationTypeMajor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "modulationTypeMajor"}, Value: fmt.Sprintf("%v", *n.ModulationTypeMajor)}) }
    if n.ModulationTypeSpreadSpectrum != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "modulationTypeSpreadSpectrum"}, Value: fmt.Sprintf("%v", *n.ModulationTypeSpreadSpectrum)}) }
    if n.ModulationTypeSystem != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "modulationTypeSystem"}, Value: fmt.Sprintf("%v", *n.ModulationTypeSystem)}) }
    if n.MulticastRelayHost != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "multicastRelayHost"}, Value: fmt.Sprintf("%v", *n.MulticastRelayHost)}) }
    if n.MulticastRelayPort != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "multicastRelayPort"}, Value: fmt.Sprintf("%v", *n.MulticastRelayPort)}) }
    if n.NetworkMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "networkMode"}, Value: fmt.Sprintf("%v", *n.NetworkMode)}) }
    if n.Port != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "port"}, Value: fmt.Sprintf("%v", *n.Port)}) }
    if n.Power != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "power"}, Value: fmt.Sprintf("%v", *n.Power)}) }
    if n.RadioEntityTypeCategory != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radioEntityTypeCategory"}, Value: fmt.Sprintf("%v", *n.RadioEntityTypeCategory)}) }
    if n.RadioEntityTypeCountry != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radioEntityTypeCountry"}, Value: fmt.Sprintf("%v", *n.RadioEntityTypeCountry)}) }
    if n.RadioEntityTypeDomain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radioEntityTypeDomain"}, Value: fmt.Sprintf("%v", *n.RadioEntityTypeDomain)}) }
    if n.RadioEntityTypeKind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radioEntityTypeKind"}, Value: fmt.Sprintf("%v", *n.RadioEntityTypeKind)}) }
    if n.RadioEntityTypeNomenclature != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radioEntityTypeNomenclature"}, Value: fmt.Sprintf("%v", *n.RadioEntityTypeNomenclature)}) }
    if n.RadioEntityTypeNomenclatureVersion != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radioEntityTypeNomenclatureVersion"}, Value: fmt.Sprintf("%v", *n.RadioEntityTypeNomenclatureVersion)}) }
    if n.RadioID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "radioID"}, Value: fmt.Sprintf("%v", *n.RadioID)}) }
    if n.ReadInterval != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "readInterval"}, Value: fmt.Sprintf("%v", *n.ReadInterval)}) }
    if n.RelativeAntennaLocation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "relativeAntennaLocation"}, Value: fmt.Sprintf("%v", *n.RelativeAntennaLocation)}) }
    if n.RtpHeaderExpected != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rtpHeaderExpected"}, Value: fmt.Sprintf("%v", *n.RtpHeaderExpected)}) }
    if n.SiteID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "siteID"}, Value: fmt.Sprintf("%v", *n.SiteID)}) }
    if n.Timestamp != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "timestamp"}, Value: fmt.Sprintf("%v", *n.Timestamp)}) }
    if n.TransmitFrequencyBandwidth != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transmitFrequencyBandwidth"}, Value: fmt.Sprintf("%v", *n.TransmitFrequencyBandwidth)}) }
    if n.TransmitState != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transmitState"}, Value: fmt.Sprintf("%v", *n.TransmitState)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.WhichGeometry != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "whichGeometry"}, Value: fmt.Sprintf("%v", *n.WhichGeometry)}) }
    if n.WriteInterval != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "writeInterval"}, Value: fmt.Sprintf("%v", *n.WriteInterval)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TriangleFanSet: TriangleFanSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
type TriangleFanSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FanCount []int32 `xml:"fanCount,attr,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *TriangleFanSet) GetNodeName() string { return "TriangleFanSet" }
func (n *TriangleFanSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#TriangleFanSet" }
func (n *TriangleFanSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TriangleFanSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.FanCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fanCount"}, Value: fmt.Sprintf("%v", n.FanCount)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TriangleSet: TriangleSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
type TriangleSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *TriangleSet) GetNodeName() string { return "TriangleSet" }
func (n *TriangleSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#TriangleSet" }
func (n *TriangleSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TriangleSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TriangleSet2D: TriangleSet2D is a geometry node that defines a set of filled 2D triangles in X-Y plane.
type TriangleSet2D struct {
    CoreX3DNode
    IS X3DNode `xml:"IS,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    Vertices *MFVec2f `xml:"vertices,attr,omitempty""`
}

func (n *TriangleSet2D) GetNodeName() string { return "TriangleSet2D" }
func (n *TriangleSet2D) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/geometry2D.html#TriangleSet2D" }
func (n *TriangleSet2D) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TriangleSet2D) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.Vertices != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vertices"}, Value: fmt.Sprintf("%v", *n.Vertices)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TriangleStripSet: TriangleStripSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
type TriangleStripSet struct {
    CoreX3DNode
    Attrib []X3DNode `xml:",any""`
    Ccw *bool `xml:"ccw,attr,omitempty""`
    Color X3DNode `xml:"color,omitempty""`
    ColorPerVertex *bool `xml:"colorPerVertex,attr,omitempty""`
    Coord X3DNode `xml:"coord,omitempty""`
    FogCoord X3DNode `xml:"fogCoord,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Normal X3DNode `xml:"normal,omitempty""`
    NormalPerVertex *bool `xml:"normalPerVertex,attr,omitempty""`
    Solid *bool `xml:"solid,attr,omitempty""`
    StripCount []int32 `xml:"stripCount,attr,omitempty""`
    TexCoord X3DNode `xml:"texCoord,omitempty""`
    Tangent X3DNode `xml:"tangent,omitempty""`
}

func (n *TriangleStripSet) GetNodeName() string { return "TriangleStripSet" }
func (n *TriangleStripSet) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rendering.html#TriangleStripSet" }
func (n *TriangleStripSet) Validate() error {
    if n.Attrib != nil {
        for i, child := range n.Attrib { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Attrib[%d]: %w", i, err) } }
    }
    if n.Color != nil {
        if err := n.Color.Validate(); err != nil { return fmt.Errorf("validation error in Color: %w", err) }
    }
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.FogCoord != nil {
        if err := n.FogCoord.Validate(); err != nil { return fmt.Errorf("validation error in FogCoord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Normal != nil {
        if err := n.Normal.Validate(); err != nil { return fmt.Errorf("validation error in Normal: %w", err) }
    }
    if n.TexCoord != nil {
        if err := n.TexCoord.Validate(); err != nil { return fmt.Errorf("validation error in TexCoord: %w", err) }
    }
    if n.Tangent != nil {
        if err := n.Tangent.Validate(); err != nil { return fmt.Errorf("validation error in Tangent: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TriangleStripSet) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Ccw != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ccw"}, Value: fmt.Sprintf("%v", *n.Ccw)}) }
    if n.ColorPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorPerVertex"}, Value: fmt.Sprintf("%v", *n.ColorPerVertex)}) }
    if n.NormalPerVertex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalPerVertex"}, Value: fmt.Sprintf("%v", *n.NormalPerVertex)}) }
    if n.Solid != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "solid"}, Value: fmt.Sprintf("%v", *n.Solid)}) }
    if n.StripCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stripCount"}, Value: fmt.Sprintf("%v", n.StripCount)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Attrib != nil {
        for _, child := range n.Attrib { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Color != nil {
        if err := e.EncodeElement(n.Color, xml.StartElement{Name: xml.Name{Local: n.Color.GetNodeName()}}); err != nil { return err }
    }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.FogCoord != nil {
        if err := e.EncodeElement(n.FogCoord, xml.StartElement{Name: xml.Name{Local: n.FogCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Normal != nil {
        if err := e.EncodeElement(n.Normal, xml.StartElement{Name: xml.Name{Local: n.Normal.GetNodeName()}}); err != nil { return err }
    }
    if n.TexCoord != nil {
        if err := e.EncodeElement(n.TexCoord, xml.StartElement{Name: xml.Name{Local: n.TexCoord.GetNodeName()}}); err != nil { return err }
    }
    if n.Tangent != nil {
        if err := e.EncodeElement(n.Tangent, xml.StartElement{Name: xml.Name{Local: n.Tangent.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TwoSidedMaterial: TwoSidedMaterial specifies surface rendering properties for associated geometry nodes, for outer (front) and inner (back) sides of polygons.
type TwoSidedMaterial struct {
    CoreX3DNode
    AmbientIntensity *float32 `xml:"ambientIntensity,attr,omitempty""`
    BackAmbientIntensity *float32 `xml:"backAmbientIntensity,attr,omitempty""`
    BackDiffuseColor *SFColor `xml:"backDiffuseColor,attr,omitempty""`
    BackEmissiveColor *SFColor `xml:"backEmissiveColor,attr,omitempty""`
    BackShininess *float32 `xml:"backShininess,attr,omitempty""`
    BackSpecularColor *SFColor `xml:"backSpecularColor,attr,omitempty""`
    BackTransparency *float32 `xml:"backTransparency,attr,omitempty""`
    DiffuseColor *SFColor `xml:"diffuseColor,attr,omitempty""`
    EmissiveColor *SFColor `xml:"emissiveColor,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    SeparateBackColor *bool `xml:"separateBackColor,attr,omitempty""`
    Shininess *float32 `xml:"shininess,attr,omitempty""`
    SpecularColor *SFColor `xml:"specularColor,attr,omitempty""`
    Transparency *float32 `xml:"transparency,attr,omitempty""`
}

func (n *TwoSidedMaterial) GetNodeName() string { return "TwoSidedMaterial" }
func (n *TwoSidedMaterial) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#TwoSidedMaterial" }
func (n *TwoSidedMaterial) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TwoSidedMaterial) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AmbientIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ambientIntensity"}, Value: fmt.Sprintf("%v", *n.AmbientIntensity)}) }
    if n.BackAmbientIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "backAmbientIntensity"}, Value: fmt.Sprintf("%v", *n.BackAmbientIntensity)}) }
    if n.BackDiffuseColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "backDiffuseColor"}, Value: fmt.Sprintf("%v", *n.BackDiffuseColor)}) }
    if n.BackEmissiveColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "backEmissiveColor"}, Value: fmt.Sprintf("%v", *n.BackEmissiveColor)}) }
    if n.BackShininess != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "backShininess"}, Value: fmt.Sprintf("%v", *n.BackShininess)}) }
    if n.BackSpecularColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "backSpecularColor"}, Value: fmt.Sprintf("%v", *n.BackSpecularColor)}) }
    if n.BackTransparency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "backTransparency"}, Value: fmt.Sprintf("%v", *n.BackTransparency)}) }
    if n.DiffuseColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseColor"}, Value: fmt.Sprintf("%v", *n.DiffuseColor)}) }
    if n.EmissiveColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveColor"}, Value: fmt.Sprintf("%v", *n.EmissiveColor)}) }
    if n.SeparateBackColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "separateBackColor"}, Value: fmt.Sprintf("%v", *n.SeparateBackColor)}) }
    if n.Shininess != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shininess"}, Value: fmt.Sprintf("%v", *n.Shininess)}) }
    if n.SpecularColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specularColor"}, Value: fmt.Sprintf("%v", *n.SpecularColor)}) }
    if n.Transparency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transparency"}, Value: fmt.Sprintf("%v", *n.Transparency)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// UniversalJoint: UniversalJoint is like a BallJoint that constrains an extra degree of rotational freedom.
type UniversalJoint struct {
    CoreX3DNode
    AnchorPoint *SFVec3f `xml:"anchorPoint,attr,omitempty""`
    Axis1 *SFVec3f `xml:"axis1,attr,omitempty""`
    Axis2 *SFVec3f `xml:"axis2,attr,omitempty""`
    Body1 X3DNode `xml:"body1,omitempty""`
    Body1AnchorPoint *SFVec3f `xml:"body1AnchorPoint,attr,omitempty""`
    Body1Axis *SFVec3f `xml:"body1Axis,attr,omitempty""`
    Body2 X3DNode `xml:"body2,omitempty""`
    Body2AnchorPoint *SFVec3f `xml:"body2AnchorPoint,attr,omitempty""`
    Body2Axis *SFVec3f `xml:"body2Axis,attr,omitempty""`
    ForceOutput []string `xml:"forceOutput,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Stop1Bounce *float32 `xml:"stop1Bounce,attr,omitempty""`
    Stop1ErrorCorrection *float32 `xml:"stop1ErrorCorrection,attr,omitempty""`
    Stop2Bounce *float32 `xml:"stop2Bounce,attr,omitempty""`
    Stop2ErrorCorrection *float32 `xml:"stop2ErrorCorrection,attr,omitempty""`
}

func (n *UniversalJoint) GetNodeName() string { return "UniversalJoint" }
func (n *UniversalJoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/rigidBodyPhysics.html#UniversalJoint" }
func (n *UniversalJoint) Validate() error {
    if n.Body1 != nil {
        if err := n.Body1.Validate(); err != nil { return fmt.Errorf("validation error in Body1: %w", err) }
    }
    if n.Body2 != nil {
        if err := n.Body2.Validate(); err != nil { return fmt.Errorf("validation error in Body2: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *UniversalJoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "anchorPoint"}, Value: fmt.Sprintf("%v", *n.AnchorPoint)}) }
    if n.Axis1 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis1"}, Value: fmt.Sprintf("%v", *n.Axis1)}) }
    if n.Axis2 != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "axis2"}, Value: fmt.Sprintf("%v", *n.Axis2)}) }
    if n.Body1AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body1AnchorPoint"}, Value: fmt.Sprintf("%v", *n.Body1AnchorPoint)}) }
    if n.Body1Axis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body1Axis"}, Value: fmt.Sprintf("%v", *n.Body1Axis)}) }
    if n.Body2AnchorPoint != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body2AnchorPoint"}, Value: fmt.Sprintf("%v", *n.Body2AnchorPoint)}) }
    if n.Body2Axis != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "body2Axis"}, Value: fmt.Sprintf("%v", *n.Body2Axis)}) }
    if n.ForceOutput != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "forceOutput"}, Value: fmt.Sprintf("%v", n.ForceOutput)}) }
    if n.Stop1Bounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop1Bounce"}, Value: fmt.Sprintf("%v", *n.Stop1Bounce)}) }
    if n.Stop1ErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop1ErrorCorrection"}, Value: fmt.Sprintf("%v", *n.Stop1ErrorCorrection)}) }
    if n.Stop2Bounce != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop2Bounce"}, Value: fmt.Sprintf("%v", *n.Stop2Bounce)}) }
    if n.Stop2ErrorCorrection != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stop2ErrorCorrection"}, Value: fmt.Sprintf("%v", *n.Stop2ErrorCorrection)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Body1 != nil {
        if err := e.EncodeElement(n.Body1, xml.StartElement{Name: xml.Name{Local: n.Body1.GetNodeName()}}); err != nil { return err }
    }
    if n.Body2 != nil {
        if err := e.EncodeElement(n.Body2, xml.StartElement{Name: xml.Name{Local: n.Body2.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// UnlitMaterial: UnlitMaterial specifies surface rendering properties for associated geometry nodes.
type UnlitMaterial struct {
    CoreX3DNode
    EmissiveColor *SFColor `xml:"emissiveColor,attr,omitempty""`
    EmissiveTexture X3DNode `xml:"emissiveTexture,omitempty""`
    EmissiveTextureMapping *string `xml:"emissiveTextureMapping,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    NormalScale *float32 `xml:"normalScale,attr,omitempty""`
    NormalTexture X3DNode `xml:"normalTexture,omitempty""`
    NormalTextureMapping *string `xml:"normalTextureMapping,attr,omitempty""`
    Transparency *float32 `xml:"transparency,attr,omitempty""`
}

func (n *UnlitMaterial) GetNodeName() string { return "UnlitMaterial" }
func (n *UnlitMaterial) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/shape.html#UnlitMaterial" }
func (n *UnlitMaterial) Validate() error {
    if n.EmissiveTexture != nil {
        if err := n.EmissiveTexture.Validate(); err != nil { return fmt.Errorf("validation error in EmissiveTexture: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.NormalTexture != nil {
        if err := n.NormalTexture.Validate(); err != nil { return fmt.Errorf("validation error in NormalTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *UnlitMaterial) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.EmissiveColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveColor"}, Value: fmt.Sprintf("%v", *n.EmissiveColor)}) }
    if n.EmissiveTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveTextureMapping"}, Value: fmt.Sprintf("%v", *n.EmissiveTextureMapping)}) }
    if n.NormalScale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalScale"}, Value: fmt.Sprintf("%v", *n.NormalScale)}) }
    if n.NormalTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalTextureMapping"}, Value: fmt.Sprintf("%v", *n.NormalTextureMapping)}) }
    if n.Transparency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transparency"}, Value: fmt.Sprintf("%v", *n.Transparency)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.EmissiveTexture != nil {
        if err := e.EncodeElement(n.EmissiveTexture, xml.StartElement{Name: xml.Name{Local: n.EmissiveTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.NormalTexture != nil {
        if err := e.EncodeElement(n.NormalTexture, xml.StartElement{Name: xml.Name{Local: n.NormalTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Viewpoint: Viewpoint provides a specific location and direction where the user may view the scene.
type Viewpoint struct {
    CoreX3DNode
    BindTime *float64 `xml:"bindTime,attr,omitempty""`
    CenterOfRotation *SFVec3f `xml:"centerOfRotation,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    FarDistance *float32 `xml:"farDistance,attr,omitempty""`
    FieldOfView *float32 `xml:"fieldOfView,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsBound *bool `xml:"isBound,attr,omitempty""`
    Jump *bool `xml:"jump,attr,omitempty""`
    NavigationInfo X3DNode `xml:"navigationInfo,omitempty""`
    NearDistance *float32 `xml:"nearDistance,attr,omitempty""`
    Orientation *SFRotation `xml:"orientation,attr,omitempty""`
    Position *SFVec3f `xml:"position,attr,omitempty""`
    RetainUserOffsets *bool `xml:"retainUserOffsets,attr,omitempty""`
    SetBind *bool `xml:"set_bind,attr,omitempty""`
    ViewAll *bool `xml:"viewAll,attr,omitempty""`
}

func (n *Viewpoint) GetNodeName() string { return "Viewpoint" }
func (n *Viewpoint) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#Viewpoint" }
func (n *Viewpoint) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.NavigationInfo != nil {
        if err := n.NavigationInfo.Validate(); err != nil { return fmt.Errorf("validation error in NavigationInfo: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Viewpoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BindTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bindTime"}, Value: fmt.Sprintf("%v", *n.BindTime)}) }
    if n.CenterOfRotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "centerOfRotation"}, Value: fmt.Sprintf("%v", *n.CenterOfRotation)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.FarDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "farDistance"}, Value: fmt.Sprintf("%v", *n.FarDistance)}) }
    if n.FieldOfView != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "fieldOfView"}, Value: fmt.Sprintf("%v", *n.FieldOfView)}) }
    if n.IsBound != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isBound"}, Value: fmt.Sprintf("%v", *n.IsBound)}) }
    if n.Jump != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "jump"}, Value: fmt.Sprintf("%v", *n.Jump)}) }
    if n.NearDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "nearDistance"}, Value: fmt.Sprintf("%v", *n.NearDistance)}) }
    if n.Orientation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "orientation"}, Value: fmt.Sprintf("%v", *n.Orientation)}) }
    if n.Position != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "position"}, Value: fmt.Sprintf("%v", *n.Position)}) }
    if n.RetainUserOffsets != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "retainUserOffsets"}, Value: fmt.Sprintf("%v", *n.RetainUserOffsets)}) }
    if n.SetBind != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_bind"}, Value: fmt.Sprintf("%v", *n.SetBind)}) }
    if n.ViewAll != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "viewAll"}, Value: fmt.Sprintf("%v", *n.ViewAll)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.NavigationInfo != nil {
        if err := e.EncodeElement(n.NavigationInfo, xml.StartElement{Name: xml.Name{Local: n.NavigationInfo.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ViewpointGroup: ViewpointGroup can contain Viewpoint, OrthoViewpoint, GeoViewpoint and other ViewpointGroup nodes for better user-navigation support with a shared description on the viewpoint list.
type ViewpointGroup struct {
    CoreX3DNode
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Description *string `xml:"description,attr,omitempty""`
    Displayed *bool `xml:"displayed,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RetainUserOffsets *bool `xml:"retainUserOffsets,attr,omitempty""`
    Size *SFVec3f `xml:"size,attr,omitempty""`
}

func (n *ViewpointGroup) GetNodeName() string { return "ViewpointGroup" }
func (n *ViewpointGroup) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/navigation.html#ViewpointGroup" }
func (n *ViewpointGroup) Validate() error {
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ViewpointGroup) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Displayed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "displayed"}, Value: fmt.Sprintf("%v", *n.Displayed)}) }
    if n.RetainUserOffsets != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "retainUserOffsets"}, Value: fmt.Sprintf("%v", *n.RetainUserOffsets)}) }
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", *n.Size)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Viewport: Viewport is a Grouping node that can contain most nodes.
type Viewport struct {
    CoreX3DNode
    AddChildren []X3DNode `xml:",any""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    ClipBoundary []float32 `xml:"clipBoundary,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RemoveChildren []X3DNode `xml:",any""`
    Visible *bool `xml:"visible,attr,omitempty""`
}

func (n *Viewport) GetNodeName() string { return "Viewport" }
func (n *Viewport) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/layering.html#Viewport" }
func (n *Viewport) Validate() error {
    if n.AddChildren != nil {
        for i, child := range n.AddChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in AddChildren[%d]: %w", i, err) } }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RemoveChildren != nil {
        for i, child := range n.RemoveChildren { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in RemoveChildren[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Viewport) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.ClipBoundary != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "clipBoundary"}, Value: fmt.Sprintf("%v", n.ClipBoundary)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.AddChildren != nil {
        for _, child := range n.AddChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RemoveChildren != nil {
        for _, child := range n.RemoveChildren { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// VisibilitySensor: VisibilitySensor detects when user can see a specific object or region as they navigate the world.
type VisibilitySensor struct {
    CoreX3DNode
    Center *SFVec3f `xml:"center,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    EnterTime *float64 `xml:"enterTime,attr,omitempty""`
    ExitTime *float64 `xml:"exitTime,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    Size *SFVec3f `xml:"size,attr,omitempty""`
}

func (n *VisibilitySensor) GetNodeName() string { return "VisibilitySensor" }
func (n *VisibilitySensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/environmentalSensor.html#VisibilitySensor" }
func (n *VisibilitySensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *VisibilitySensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Center != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "center"}, Value: fmt.Sprintf("%v", *n.Center)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.EnterTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enterTime"}, Value: fmt.Sprintf("%v", *n.EnterTime)}) }
    if n.ExitTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "exitTime"}, Value: fmt.Sprintf("%v", *n.ExitTime)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.Size != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "size"}, Value: fmt.Sprintf("%v", *n.Size)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// VolumeData: VolumeData displays a simple non-segmented voxel dataset with a single RenderStyle node.
type VolumeData struct {
    CoreX3DNode
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    Dimensions *SFVec3f `xml:"dimensions,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    RenderStyle X3DNode `xml:"renderStyle,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    Voxels X3DNode `xml:"voxels,omitempty""`
}

func (n *VolumeData) GetNodeName() string { return "VolumeData" }
func (n *VolumeData) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/volume.html#VolumeData" }
func (n *VolumeData) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.RenderStyle != nil {
        if err := n.RenderStyle.Validate(); err != nil { return fmt.Errorf("validation error in RenderStyle: %w", err) }
    }
    if n.Voxels != nil {
        if err := n.Voxels.Validate(); err != nil { return fmt.Errorf("validation error in Voxels: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *VolumeData) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.Dimensions != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "dimensions"}, Value: fmt.Sprintf("%v", *n.Dimensions)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.RenderStyle != nil {
        if err := e.EncodeElement(n.RenderStyle, xml.StartElement{Name: xml.Name{Local: n.RenderStyle.GetNodeName()}}); err != nil { return err }
    }
    if n.Voxels != nil {
        if err := e.EncodeElement(n.Voxels, xml.StartElement{Name: xml.Name{Local: n.Voxels.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// VolumeEmitter: VolumeEmitter emits particles from a random position confined within the given closed geometry volume.
type VolumeEmitter struct {
    CoreX3DNode
    Coord X3DNode `xml:"coord,omitempty""`
    CoordIndex []int32 `xml:"coordIndex,attr,omitempty""`
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    Internal *bool `xml:"internal,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Mass *float32 `xml:"mass,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    SetCoordIndex []int32 `xml:"set_coordIndex,attr,omitempty""`
    Speed *float32 `xml:"speed,attr,omitempty""`
    SurfaceArea *float32 `xml:"surfaceArea,attr,omitempty""`
    Variation *float32 `xml:"variation,attr,omitempty""`
}

func (n *VolumeEmitter) GetNodeName() string { return "VolumeEmitter" }
func (n *VolumeEmitter) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#VolumeEmitter" }
func (n *VolumeEmitter) Validate() error {
    if n.Coord != nil {
        if err := n.Coord.Validate(); err != nil { return fmt.Errorf("validation error in Coord: %w", err) }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *VolumeEmitter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.CoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "coordIndex"}, Value: fmt.Sprintf("%v", n.CoordIndex)}) }
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.Internal != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "internal"}, Value: fmt.Sprintf("%v", *n.Internal)}) }
    if n.Mass != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "mass"}, Value: fmt.Sprintf("%v", *n.Mass)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.SetCoordIndex != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "set_coordIndex"}, Value: fmt.Sprintf("%v", n.SetCoordIndex)}) }
    if n.Speed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speed"}, Value: fmt.Sprintf("%v", *n.Speed)}) }
    if n.SurfaceArea != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "surfaceArea"}, Value: fmt.Sprintf("%v", *n.SurfaceArea)}) }
    if n.Variation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "variation"}, Value: fmt.Sprintf("%v", *n.Variation)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Coord != nil {
        if err := e.EncodeElement(n.Coord, xml.StartElement{Name: xml.Name{Local: n.Coord.GetNodeName()}}); err != nil { return err }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// VolumePickSensor: VolumePickSensor tests picking intersections using the pickingGeometry against the pickTarget geometry volume.
type VolumePickSensor struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    IntersectionType *string `xml:"intersectionType,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    MatchCriterion *string `xml:"matchCriterion,attr,omitempty""`
    ObjectType []string `xml:"objectType,attr,omitempty""`
    PickedGeometry []X3DNode `xml:",any""`
    PickingGeometry X3DNode `xml:"pickingGeometry,omitempty""`
    PickTarget []X3DNode `xml:",any""`
    SortOrder *string `xml:"sortOrder,attr,omitempty""`
}

func (n *VolumePickSensor) GetNodeName() string { return "VolumePickSensor" }
func (n *VolumePickSensor) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/picking.html#VolumePickSensor" }
func (n *VolumePickSensor) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.MatchCriterion != nil {
        switch *n.MatchCriterion {
        case PickSensorMatchCriterionChoicesMATCHANY, PickSensorMatchCriterionChoicesMATCHEVERY, PickSensorMatchCriterionChoicesMATCHONLYONE: // valid
        default: return fmt.Errorf("invalid value for field matchCriterion: %s", *n.MatchCriterion)
        }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.PickedGeometry != nil {
        for i, child := range n.PickedGeometry { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in PickedGeometry[%d]: %w", i, err) } }
    }
    if n.PickingGeometry != nil {
        if err := n.PickingGeometry.Validate(); err != nil { return fmt.Errorf("validation error in PickingGeometry: %w", err) }
    }
    if n.PickTarget != nil {
        for i, child := range n.PickTarget { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in PickTarget[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *VolumePickSensor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.IntersectionType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intersectionType"}, Value: fmt.Sprintf("%v", *n.IntersectionType)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.MatchCriterion != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "matchCriterion"}, Value: fmt.Sprintf("%v", *n.MatchCriterion)}) }
    if n.ObjectType != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "objectType"}, Value: fmt.Sprintf("%v", n.ObjectType)}) }
    if n.SortOrder != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sortOrder"}, Value: fmt.Sprintf("%v", *n.SortOrder)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.PickedGeometry != nil {
        for _, child := range n.PickedGeometry { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.PickingGeometry != nil {
        if err := e.EncodeElement(n.PickingGeometry, xml.StartElement{Name: xml.Name{Local: n.PickingGeometry.GetNodeName()}}); err != nil { return err }
    }
    if n.PickTarget != nil {
        for _, child := range n.PickTarget { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// WaveShaper: WaveShaper node represents a nonlinear distorter that applies a wave-shaping distortion curve to the signal.
type WaveShaper struct {
    CoreX3DNode
    ChannelCount *int32 `xml:"channelCount,attr,omitempty""`
    ChannelCountMode *string `xml:"channelCountMode,attr,omitempty""`
    ChannelInterpretation *string `xml:"channelInterpretation,attr,omitempty""`
    Children []X3DNode `xml:",any""`
    Curve []float32 `xml:"curve,attr,omitempty""`
    Description *string `xml:"description,attr,omitempty""`
    ElapsedTime *float64 `xml:"elapsedTime,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gain *float32 `xml:"gain,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    IsActive *bool `xml:"isActive,attr,omitempty""`
    IsPaused *bool `xml:"isPaused,attr,omitempty""`
    Oversample *string `xml:"oversample,attr,omitempty""`
    PauseTime *float64 `xml:"pauseTime,attr,omitempty""`
    ResumeTime *float64 `xml:"resumeTime,attr,omitempty""`
    StartTime *float64 `xml:"startTime,attr,omitempty""`
    StopTime *float64 `xml:"stopTime,attr,omitempty""`
    TailTime *float64 `xml:"tailTime,attr,omitempty""`
}

func (n *WaveShaper) GetNodeName() string { return "WaveShaper" }
func (n *WaveShaper) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/sound.html#WaveShaper" }
func (n *WaveShaper) Validate() error {
    if n.ChannelCountMode != nil {
        switch *n.ChannelCountMode {
        case ChannelCountModeChoicesMAX, ChannelCountModeChoicesCLAMPEDMAX, ChannelCountModeChoicesEXPLICIT: // valid
        default: return fmt.Errorf("invalid value for field channelCountMode: %s", *n.ChannelCountMode)
        }
    }
    if n.ChannelInterpretation != nil {
        switch *n.ChannelInterpretation {
        case ChannelInterpretationChoicesSPEAKERS, ChannelInterpretationChoicesDISCRETE: // valid
        default: return fmt.Errorf("invalid value for field channelInterpretation: %s", *n.ChannelInterpretation)
        }
    }
    if n.Children != nil {
        for i, child := range n.Children { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Children[%d]: %w", i, err) } }
    }
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Oversample != nil {
        switch *n.Oversample {
        case WaveShaperOversampleChoicesNONE, WaveShaperOversampleChoices2X, WaveShaperOversampleChoices4X: // valid
        default: return fmt.Errorf("invalid value for field oversample: %s", *n.Oversample)
        }
    }
    return n.CoreX3DNode.Validate()
}

func (n *WaveShaper) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.ChannelCount != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCount"}, Value: fmt.Sprintf("%v", *n.ChannelCount)}) }
    if n.ChannelCountMode != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelCountMode"}, Value: fmt.Sprintf("%v", *n.ChannelCountMode)}) }
    if n.ChannelInterpretation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "channelInterpretation"}, Value: fmt.Sprintf("%v", *n.ChannelInterpretation)}) }
    if n.Curve != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "curve"}, Value: fmt.Sprintf("%v", n.Curve)}) }
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.ElapsedTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "elapsedTime"}, Value: fmt.Sprintf("%v", *n.ElapsedTime)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gain != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gain"}, Value: fmt.Sprintf("%v", *n.Gain)}) }
    if n.IsActive != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isActive"}, Value: fmt.Sprintf("%v", *n.IsActive)}) }
    if n.IsPaused != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "isPaused"}, Value: fmt.Sprintf("%v", *n.IsPaused)}) }
    if n.Oversample != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "oversample"}, Value: fmt.Sprintf("%v", *n.Oversample)}) }
    if n.PauseTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pauseTime"}, Value: fmt.Sprintf("%v", *n.PauseTime)}) }
    if n.ResumeTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "resumeTime"}, Value: fmt.Sprintf("%v", *n.ResumeTime)}) }
    if n.StartTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "startTime"}, Value: fmt.Sprintf("%v", *n.StartTime)}) }
    if n.StopTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "stopTime"}, Value: fmt.Sprintf("%v", *n.StopTime)}) }
    if n.TailTime != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "tailTime"}, Value: fmt.Sprintf("%v", *n.TailTime)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Children != nil {
        for _, child := range n.Children { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// WindPhysicsModel: WindPhysicsModel applies a wind effect to the particles.
type WindPhysicsModel struct {
    CoreX3DNode
    Direction *SFVec3f `xml:"direction,attr,omitempty""`
    Enabled *bool `xml:"enabled,attr,omitempty""`
    Gustiness *float32 `xml:"gustiness,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Speed *float32 `xml:"speed,attr,omitempty""`
    Turbulence *float32 `xml:"turbulence,attr,omitempty""`
}

func (n *WindPhysicsModel) GetNodeName() string { return "WindPhysicsModel" }
func (n *WindPhysicsModel) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/particleSystems.html#WindPhysicsModel" }
func (n *WindPhysicsModel) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *WindPhysicsModel) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Direction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "direction"}, Value: fmt.Sprintf("%v", *n.Direction)}) }
    if n.Enabled != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "enabled"}, Value: fmt.Sprintf("%v", *n.Enabled)}) }
    if n.Gustiness != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "gustiness"}, Value: fmt.Sprintf("%v", *n.Gustiness)}) }
    if n.Speed != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "speed"}, Value: fmt.Sprintf("%v", *n.Speed)}) }
    if n.Turbulence != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "turbulence"}, Value: fmt.Sprintf("%v", *n.Turbulence)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// WorldInfo: WorldInfo contains a title and simple persistent metadata information about an X3D scene. This node is strictly for documentation purposes and has no effect on the visual appearance or behaviour of the world.
type WorldInfo struct {
    CoreX3DNode
    Info []string `xml:"info,attr,omitempty""`
    IS X3DNode `xml:"IS,omitempty""`
    Title *string `xml:"title,attr,omitempty""`
}

func (n *WorldInfo) GetNodeName() string { return "WorldInfo" }
func (n *WorldInfo) GetSpecificationURL() string { return "https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#WorldInfo" }
func (n *WorldInfo) Validate() error {
    if n.IS != nil {
        if err := n.IS.Validate(); err != nil { return fmt.Errorf("validation error in IS: %w", err) }
    }
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *WorldInfo) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Info != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "info"}, Value: fmt.Sprintf("%v", n.Info)}) }
    if n.Title != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "title"}, Value: fmt.Sprintf("%v", *n.Title)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if n.Class != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "class"}, Value: fmt.Sprintf("%v", *n.Class)}) }
    if n.ID != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: fmt.Sprintf("%v", *n.ID)}) }
    if n.Style != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "style"}, Value: fmt.Sprintf("%v", *n.Style)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.IS != nil {
        if err := e.EncodeElement(n.IS, xml.StartElement{Name: xml.Name{Local: n.IS.GetNodeName()}}); err != nil { return err }
    }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// EnvironmentLight: EnvironmentLight ... This node only affects the PhysicalMaterial and SpecularGlossinessMaterial nodes.
type EnvironmentLight struct {
    CoreX3DNode
    Global *bool `xml:"global,attr,omitempty""`
    On *bool `xml:"on,attr,omitempty""`
    Color *SFColor `xml:"color,attr,omitempty""`
    Intensity *float32 `xml:"intensity,attr,omitempty""`
    AmbientIntensity *float32 `xml:"ambientIntensity,attr,omitempty""`
    Rotation *SFRotation `xml:"rotation,attr,omitempty""`
    DiffuseTexture X3DNode `xml:"diffuseTexture,omitempty""`
    DiffuseCoefficients []float32 `xml:"diffuseCoefficients,attr,omitempty""`
    SpecularTexture X3DNode `xml:"specularTexture,omitempty""`
    Shadows *bool `xml:"shadows,attr,omitempty""`
    ShadowIntensity *float32 `xml:"shadowIntensity,attr,omitempty""`
}

func (n *EnvironmentLight) GetNodeName() string { return "EnvironmentLight" }
func (n *EnvironmentLight) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/lighting/environmentlight" }
func (n *EnvironmentLight) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.DiffuseTexture != nil {
        if err := n.DiffuseTexture.Validate(); err != nil { return fmt.Errorf("validation error in DiffuseTexture: %w", err) }
    }
    if n.SpecularTexture != nil {
        if err := n.SpecularTexture.Validate(); err != nil { return fmt.Errorf("validation error in SpecularTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *EnvironmentLight) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Global != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "global"}, Value: fmt.Sprintf("%v", *n.Global)}) }
    if n.On != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "on"}, Value: fmt.Sprintf("%v", *n.On)}) }
    if n.Color != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "color"}, Value: fmt.Sprintf("%v", *n.Color)}) }
    if n.Intensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "intensity"}, Value: fmt.Sprintf("%v", *n.Intensity)}) }
    if n.AmbientIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "ambientIntensity"}, Value: fmt.Sprintf("%v", *n.AmbientIntensity)}) }
    if n.Rotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotation"}, Value: fmt.Sprintf("%v", *n.Rotation)}) }
    if n.DiffuseCoefficients != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseCoefficients"}, Value: fmt.Sprintf("%v", n.DiffuseCoefficients)}) }
    if n.Shadows != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadows"}, Value: fmt.Sprintf("%v", *n.Shadows)}) }
    if n.ShadowIntensity != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "shadowIntensity"}, Value: fmt.Sprintf("%v", *n.ShadowIntensity)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.DiffuseTexture != nil {
        if err := e.EncodeElement(n.DiffuseTexture, xml.StartElement{Name: xml.Name{Local: n.DiffuseTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.SpecularTexture != nil {
        if err := e.EncodeElement(n.SpecularTexture, xml.StartElement{Name: xml.Name{Local: n.SpecularTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// Tangent: Tangent.
type Tangent struct {
    CoreX3DNode
    Vector *MFVec4f `xml:"vector,attr,omitempty""`
}

func (n *Tangent) GetNodeName() string { return "Tangent" }
func (n *Tangent) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/rendering/tangent" }
func (n *Tangent) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *Tangent) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Vector != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "vector"}, Value: fmt.Sprintf("%v", *n.Vector)}) }
    if n.DEF != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "DEF"}, Value: fmt.Sprintf("%v", *n.DEF)}) }
    if n.USE != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "USE"}, Value: fmt.Sprintf("%v", *n.USE)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ImageTextureAtlas: ImageTextureAtlas defines a 3D image-based texture map by specifying a single image file that contains slices for complete 3D data.
type ImageTextureAtlas struct {
    CoreX3DNode
    Description *string `xml:"description,attr,omitempty""`
    Load *bool `xml:"load,attr,omitempty""`
    Url []string `xml:"url,attr,omitempty""`
    AutoRefresh *float64 `xml:"autoRefresh,attr,omitempty""`
    AutoRefreshTimeLimit *float64 `xml:"autoRefreshTimeLimit,attr,omitempty""`
    SlicesOverX *int32 `xml:"slicesOverX,attr,omitempty""`
    SlicesOverY *int32 `xml:"slicesOverY,attr,omitempty""`
    NumberOfSlices *int32 `xml:"numberOfSlices,attr,omitempty""`
    RepeatS *bool `xml:"repeatS,attr,omitempty""`
    RepeatT *bool `xml:"repeatT,attr,omitempty""`
    RepeatR *bool `xml:"repeatR,attr,omitempty""`
    TextureProperties X3DNode `xml:"textureProperties,omitempty""`
}

func (n *ImageTextureAtlas) GetNodeName() string { return "ImageTextureAtlas" }
func (n *ImageTextureAtlas) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/texturing3d/imagetextureatlas" }
func (n *ImageTextureAtlas) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TextureProperties != nil {
        if err := n.TextureProperties.Validate(); err != nil { return fmt.Errorf("validation error in TextureProperties: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ImageTextureAtlas) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Description != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "description"}, Value: fmt.Sprintf("%v", *n.Description)}) }
    if n.Load != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "load"}, Value: fmt.Sprintf("%v", *n.Load)}) }
    if n.Url != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: fmt.Sprintf("%v", n.Url)}) }
    if n.AutoRefresh != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefresh"}, Value: fmt.Sprintf("%v", *n.AutoRefresh)}) }
    if n.AutoRefreshTimeLimit != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "autoRefreshTimeLimit"}, Value: fmt.Sprintf("%v", *n.AutoRefreshTimeLimit)}) }
    if n.SlicesOverX != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "slicesOverX"}, Value: fmt.Sprintf("%v", *n.SlicesOverX)}) }
    if n.SlicesOverY != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "slicesOverY"}, Value: fmt.Sprintf("%v", *n.SlicesOverY)}) }
    if n.NumberOfSlices != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "numberOfSlices"}, Value: fmt.Sprintf("%v", *n.NumberOfSlices)}) }
    if n.RepeatS != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatS"}, Value: fmt.Sprintf("%v", *n.RepeatS)}) }
    if n.RepeatT != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatT"}, Value: fmt.Sprintf("%v", *n.RepeatT)}) }
    if n.RepeatR != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "repeatR"}, Value: fmt.Sprintf("%v", *n.RepeatR)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TextureProperties != nil {
        if err := e.EncodeElement(n.TextureProperties, xml.StartElement{Name: xml.Name{Local: n.TextureProperties.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// AnisotropyMaterialExtension: AnisotropyMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type AnisotropyMaterialExtension struct {
    CoreX3DNode
    AnisotropyStrength *float32 `xml:"anisotropyStrength,attr,omitempty""`
    AnisotropyRotation *float32 `xml:"anisotropyRotation,attr,omitempty""`
    AnisotropyTextureMapping *string `xml:"anisotropyTextureMapping,attr,omitempty""`
    AnisotropyTexture X3DNode `xml:"anisotropyTexture,omitempty""`
}

func (n *AnisotropyMaterialExtension) GetNodeName() string { return "AnisotropyMaterialExtension" }
func (n *AnisotropyMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/anisotropymaterialextension" }
func (n *AnisotropyMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.AnisotropyTexture != nil {
        if err := n.AnisotropyTexture.Validate(); err != nil { return fmt.Errorf("validation error in AnisotropyTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *AnisotropyMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.AnisotropyStrength != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "anisotropyStrength"}, Value: fmt.Sprintf("%v", *n.AnisotropyStrength)}) }
    if n.AnisotropyRotation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "anisotropyRotation"}, Value: fmt.Sprintf("%v", *n.AnisotropyRotation)}) }
    if n.AnisotropyTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "anisotropyTextureMapping"}, Value: fmt.Sprintf("%v", *n.AnisotropyTextureMapping)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.AnisotropyTexture != nil {
        if err := e.EncodeElement(n.AnisotropyTexture, xml.StartElement{Name: xml.Name{Local: n.AnisotropyTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// BlendMode: BlendMode controls how pixels of an objects are drawn. Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). BlendMode is an X3DAppearanceChildNode node that handles blend operations.
type BlendMode struct {
    CoreX3DNode
    BlendColor *SFColorRGBA `xml:"blendColor,attr,omitempty""`
    SourceColorFactor *string `xml:"sourceColorFactor,attr,omitempty""`
    SourceAlphaFactor *string `xml:"sourceAlphaFactor,attr,omitempty""`
    DestinationColorFactor *string `xml:"destinationColorFactor,attr,omitempty""`
    DestinationAlphaFactor *string `xml:"destinationAlphaFactor,attr,omitempty""`
    ColorEquation *string `xml:"colorEquation,attr,omitempty""`
    AlphaEquation *string `xml:"alphaEquation,attr,omitempty""`
}

func (n *BlendMode) GetNodeName() string { return "BlendMode" }
func (n *BlendMode) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/blendmode" }
func (n *BlendMode) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *BlendMode) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.BlendColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "blendColor"}, Value: fmt.Sprintf("%v", *n.BlendColor)}) }
    if n.SourceColorFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sourceColorFactor"}, Value: fmt.Sprintf("%v", *n.SourceColorFactor)}) }
    if n.SourceAlphaFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sourceAlphaFactor"}, Value: fmt.Sprintf("%v", *n.SourceAlphaFactor)}) }
    if n.DestinationColorFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "destinationColorFactor"}, Value: fmt.Sprintf("%v", *n.DestinationColorFactor)}) }
    if n.DestinationAlphaFactor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "destinationAlphaFactor"}, Value: fmt.Sprintf("%v", *n.DestinationAlphaFactor)}) }
    if n.ColorEquation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "colorEquation"}, Value: fmt.Sprintf("%v", *n.ColorEquation)}) }
    if n.AlphaEquation != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "alphaEquation"}, Value: fmt.Sprintf("%v", *n.AlphaEquation)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// ClearcoatMaterialExtension: ClearcoatMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type ClearcoatMaterialExtension struct {
    CoreX3DNode
    Clearcoat *float32 `xml:"clearcoat,attr,omitempty""`
    ClearcoatTextureMapping *string `xml:"clearcoatTextureMapping,attr,omitempty""`
    ClearcoatTexture X3DNode `xml:"clearcoatTexture,omitempty""`
    ClearcoatRoughness *float32 `xml:"clearcoatRoughness,attr,omitempty""`
    ClearcoatRoughnessTextureMapping *string `xml:"clearcoatRoughnessTextureMapping,attr,omitempty""`
    ClearcoatRoughnessTexture X3DNode `xml:"clearcoatRoughnessTexture,omitempty""`
    ClearcoatNormalTextureMapping *string `xml:"clearcoatNormalTextureMapping,attr,omitempty""`
    ClearcoatNormalTexture X3DNode `xml:"clearcoatNormalTexture,omitempty""`
}

func (n *ClearcoatMaterialExtension) GetNodeName() string { return "ClearcoatMaterialExtension" }
func (n *ClearcoatMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/clearcoatmaterialextension" }
func (n *ClearcoatMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.ClearcoatTexture != nil {
        if err := n.ClearcoatTexture.Validate(); err != nil { return fmt.Errorf("validation error in ClearcoatTexture: %w", err) }
    }
    if n.ClearcoatRoughnessTexture != nil {
        if err := n.ClearcoatRoughnessTexture.Validate(); err != nil { return fmt.Errorf("validation error in ClearcoatRoughnessTexture: %w", err) }
    }
    if n.ClearcoatNormalTexture != nil {
        if err := n.ClearcoatNormalTexture.Validate(); err != nil { return fmt.Errorf("validation error in ClearcoatNormalTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *ClearcoatMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Clearcoat != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "clearcoat"}, Value: fmt.Sprintf("%v", *n.Clearcoat)}) }
    if n.ClearcoatTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "clearcoatTextureMapping"}, Value: fmt.Sprintf("%v", *n.ClearcoatTextureMapping)}) }
    if n.ClearcoatRoughness != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "clearcoatRoughness"}, Value: fmt.Sprintf("%v", *n.ClearcoatRoughness)}) }
    if n.ClearcoatRoughnessTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "clearcoatRoughnessTextureMapping"}, Value: fmt.Sprintf("%v", *n.ClearcoatRoughnessTextureMapping)}) }
    if n.ClearcoatNormalTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "clearcoatNormalTextureMapping"}, Value: fmt.Sprintf("%v", *n.ClearcoatNormalTextureMapping)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.ClearcoatTexture != nil {
        if err := e.EncodeElement(n.ClearcoatTexture, xml.StartElement{Name: xml.Name{Local: n.ClearcoatTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.ClearcoatRoughnessTexture != nil {
        if err := e.EncodeElement(n.ClearcoatRoughnessTexture, xml.StartElement{Name: xml.Name{Local: n.ClearcoatRoughnessTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.ClearcoatNormalTexture != nil {
        if err := e.EncodeElement(n.ClearcoatNormalTexture, xml.StartElement{Name: xml.Name{Local: n.ClearcoatNormalTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// DepthMode: DepthMode contains parameters that are specific for depth control, like the value used for depth buffer comparisons.
type DepthMode struct {
    CoreX3DNode
    PolygonOffset *SFVec2f `xml:"polygonOffset,attr,omitempty""`
    DepthRange *SFVec2f `xml:"depthRange,attr,omitempty""`
    DepthTest *bool `xml:"depthTest,attr,omitempty""`
    DepthFunction *string `xml:"depthFunction,attr,omitempty""`
    DepthMask *bool `xml:"depthMask,attr,omitempty""`
}

func (n *DepthMode) GetNodeName() string { return "DepthMode" }
func (n *DepthMode) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/depthmode" }
func (n *DepthMode) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *DepthMode) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.PolygonOffset != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "polygonOffset"}, Value: fmt.Sprintf("%v", *n.PolygonOffset)}) }
    if n.DepthRange != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "depthRange"}, Value: fmt.Sprintf("%v", *n.DepthRange)}) }
    if n.DepthTest != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "depthTest"}, Value: fmt.Sprintf("%v", *n.DepthTest)}) }
    if n.DepthFunction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "depthFunction"}, Value: fmt.Sprintf("%v", *n.DepthFunction)}) }
    if n.DepthMask != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "depthMask"}, Value: fmt.Sprintf("%v", *n.DepthMask)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// DispersionMaterialExtension: DispersionMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type DispersionMaterialExtension struct {
    CoreX3DNode
    Dispersion *float32 `xml:"dispersion,attr,omitempty""`
}

func (n *DispersionMaterialExtension) GetNodeName() string { return "DispersionMaterialExtension" }
func (n *DispersionMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/dispersionmaterialextension" }
func (n *DispersionMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *DispersionMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Dispersion != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "dispersion"}, Value: fmt.Sprintf("%v", *n.Dispersion)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// EmissiveStrengthMaterialExtension: EmissiveStrengthMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes.
type EmissiveStrengthMaterialExtension struct {
    CoreX3DNode
    EmissiveStrength *float32 `xml:"emissiveStrength,attr,omitempty""`
}

func (n *EmissiveStrengthMaterialExtension) GetNodeName() string { return "EmissiveStrengthMaterialExtension" }
func (n *EmissiveStrengthMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/emissivestrengthmaterialextension" }
func (n *EmissiveStrengthMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *EmissiveStrengthMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.EmissiveStrength != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveStrength"}, Value: fmt.Sprintf("%v", *n.EmissiveStrength)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IORMaterialExtension: IORMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type IORMaterialExtension struct {
    CoreX3DNode
    IndexOfRefraction *float32 `xml:"indexOfRefraction,attr,omitempty""`
}

func (n *IORMaterialExtension) GetNodeName() string { return "IORMaterialExtension" }
func (n *IORMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/iormaterialextension" }
func (n *IORMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IORMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.IndexOfRefraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "indexOfRefraction"}, Value: fmt.Sprintf("%v", *n.IndexOfRefraction)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// InstancedShape: InstancedShape can appear under any grouping node. InstancedShape can contain an Appearance node and a geometry node (for example one of the primitives Box Cone Cylinder Sphere Text, one of ElevationGrid Extrusion IndexedFaceSet IndexedLineSet LineSet PointSet, or one of the other geometry nodes) and this geometry node is instantiated as often as transformations are provided.
type InstancedShape struct {
    CoreX3DNode
    Translations *MFVec3f `xml:"translations,attr,omitempty""`
    Rotations *MFRotation `xml:"rotations,attr,omitempty""`
    Scales *MFVec3f `xml:"scales,attr,omitempty""`
    ScaleOrientations *MFRotation `xml:"scaleOrientations,attr,omitempty""`
    Centers *MFVec3f `xml:"centers,attr,omitempty""`
    PointerEvents *bool `xml:"pointerEvents,attr,omitempty""`
    CastShadow *bool `xml:"castShadow,attr,omitempty""`
    Visible *bool `xml:"visible,attr,omitempty""`
    BboxDisplay *bool `xml:"bboxDisplay,attr,omitempty""`
    BboxSize *SFVec3f `xml:"bboxSize,attr,omitempty""`
    BboxCenter *SFVec3f `xml:"bboxCenter,attr,omitempty""`
    Appearance X3DNode `xml:"appearance,omitempty""`
    Geometry X3DNode `xml:"geometry,omitempty""`
}

func (n *InstancedShape) GetNodeName() string { return "InstancedShape" }
func (n *InstancedShape) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/instancedshape" }
func (n *InstancedShape) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.Appearance != nil {
        if err := n.Appearance.Validate(); err != nil { return fmt.Errorf("validation error in Appearance: %w", err) }
    }
    if n.Geometry != nil {
        if err := n.Geometry.Validate(); err != nil { return fmt.Errorf("validation error in Geometry: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *InstancedShape) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Translations != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "translations"}, Value: fmt.Sprintf("%v", *n.Translations)}) }
    if n.Rotations != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "rotations"}, Value: fmt.Sprintf("%v", *n.Rotations)}) }
    if n.Scales != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scales"}, Value: fmt.Sprintf("%v", *n.Scales)}) }
    if n.ScaleOrientations != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "scaleOrientations"}, Value: fmt.Sprintf("%v", *n.ScaleOrientations)}) }
    if n.Centers != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "centers"}, Value: fmt.Sprintf("%v", *n.Centers)}) }
    if n.PointerEvents != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "pointerEvents"}, Value: fmt.Sprintf("%v", *n.PointerEvents)}) }
    if n.CastShadow != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "castShadow"}, Value: fmt.Sprintf("%v", *n.CastShadow)}) }
    if n.Visible != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "visible"}, Value: fmt.Sprintf("%v", *n.Visible)}) }
    if n.BboxDisplay != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxDisplay"}, Value: fmt.Sprintf("%v", *n.BboxDisplay)}) }
    if n.BboxSize != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxSize"}, Value: fmt.Sprintf("%v", *n.BboxSize)}) }
    if n.BboxCenter != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "bboxCenter"}, Value: fmt.Sprintf("%v", *n.BboxCenter)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.Appearance != nil {
        if err := e.EncodeElement(n.Appearance, xml.StartElement{Name: xml.Name{Local: n.Appearance.GetNodeName()}}); err != nil { return err }
    }
    if n.Geometry != nil {
        if err := e.EncodeElement(n.Geometry, xml.StartElement{Name: xml.Name{Local: n.Geometry.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// IridescenceMaterialExtension: IridescenceMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type IridescenceMaterialExtension struct {
    CoreX3DNode
    Iridescence *float32 `xml:"iridescence,attr,omitempty""`
    IridescenceTextureMapping *string `xml:"iridescenceTextureMapping,attr,omitempty""`
    IridescenceTexture X3DNode `xml:"iridescenceTexture,omitempty""`
    IridescenceIndexOfRefraction *float32 `xml:"iridescenceIndexOfRefraction,attr,omitempty""`
    IridescenceThicknessMinimum *float32 `xml:"iridescenceThicknessMinimum,attr,omitempty""`
    IridescenceThicknessMaximum *float32 `xml:"iridescenceThicknessMaximum,attr,omitempty""`
    IridescenceThicknessTextureMapping *string `xml:"iridescenceThicknessTextureMapping,attr,omitempty""`
    IridescenceThicknessTexture X3DNode `xml:"iridescenceThicknessTexture,omitempty""`
}

func (n *IridescenceMaterialExtension) GetNodeName() string { return "IridescenceMaterialExtension" }
func (n *IridescenceMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/iridescencematerialextension" }
func (n *IridescenceMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.IridescenceTexture != nil {
        if err := n.IridescenceTexture.Validate(); err != nil { return fmt.Errorf("validation error in IridescenceTexture: %w", err) }
    }
    if n.IridescenceThicknessTexture != nil {
        if err := n.IridescenceThicknessTexture.Validate(); err != nil { return fmt.Errorf("validation error in IridescenceThicknessTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *IridescenceMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Iridescence != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "iridescence"}, Value: fmt.Sprintf("%v", *n.Iridescence)}) }
    if n.IridescenceTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "iridescenceTextureMapping"}, Value: fmt.Sprintf("%v", *n.IridescenceTextureMapping)}) }
    if n.IridescenceIndexOfRefraction != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "iridescenceIndexOfRefraction"}, Value: fmt.Sprintf("%v", *n.IridescenceIndexOfRefraction)}) }
    if n.IridescenceThicknessMinimum != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "iridescenceThicknessMinimum"}, Value: fmt.Sprintf("%v", *n.IridescenceThicknessMinimum)}) }
    if n.IridescenceThicknessMaximum != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "iridescenceThicknessMaximum"}, Value: fmt.Sprintf("%v", *n.IridescenceThicknessMaximum)}) }
    if n.IridescenceThicknessTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "iridescenceThicknessTextureMapping"}, Value: fmt.Sprintf("%v", *n.IridescenceThicknessTextureMapping)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.IridescenceTexture != nil {
        if err := e.EncodeElement(n.IridescenceTexture, xml.StartElement{Name: xml.Name{Local: n.IridescenceTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.IridescenceThicknessTexture != nil {
        if err := e.EncodeElement(n.IridescenceThicknessTexture, xml.StartElement{Name: xml.Name{Local: n.IridescenceThicknessTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SheenMaterialExtension: SheenMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type SheenMaterialExtension struct {
    CoreX3DNode
    SheenColor *SFColor `xml:"sheenColor,attr,omitempty""`
    SheenColorTextureMapping *string `xml:"sheenColorTextureMapping,attr,omitempty""`
    SheenColorTexture X3DNode `xml:"sheenColorTexture,omitempty""`
    SheenRoughness *float32 `xml:"sheenRoughness,attr,omitempty""`
    SheenRoughnessTextureMapping *string `xml:"sheenRoughnessTextureMapping,attr,omitempty""`
    SheenRoughnessTexture X3DNode `xml:"sheenRoughnessTexture,omitempty""`
}

func (n *SheenMaterialExtension) GetNodeName() string { return "SheenMaterialExtension" }
func (n *SheenMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/sheenmaterialextension" }
func (n *SheenMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.SheenColorTexture != nil {
        if err := n.SheenColorTexture.Validate(); err != nil { return fmt.Errorf("validation error in SheenColorTexture: %w", err) }
    }
    if n.SheenRoughnessTexture != nil {
        if err := n.SheenRoughnessTexture.Validate(); err != nil { return fmt.Errorf("validation error in SheenRoughnessTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SheenMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.SheenColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sheenColor"}, Value: fmt.Sprintf("%v", *n.SheenColor)}) }
    if n.SheenColorTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sheenColorTextureMapping"}, Value: fmt.Sprintf("%v", *n.SheenColorTextureMapping)}) }
    if n.SheenRoughness != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sheenRoughness"}, Value: fmt.Sprintf("%v", *n.SheenRoughness)}) }
    if n.SheenRoughnessTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "sheenRoughnessTextureMapping"}, Value: fmt.Sprintf("%v", *n.SheenRoughnessTextureMapping)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.SheenColorTexture != nil {
        if err := e.EncodeElement(n.SheenColorTexture, xml.StartElement{Name: xml.Name{Local: n.SheenColorTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.SheenRoughnessTexture != nil {
        if err := e.EncodeElement(n.SheenRoughnessTexture, xml.StartElement{Name: xml.Name{Local: n.SheenRoughnessTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// SpecularGlossinessMaterial: SpecularGlossinessMaterial specifies surface rendering properties for associated geometry nodes. Material attributes are used by the X3D lighting equations during rendering.
type SpecularGlossinessMaterial struct {
    CoreX3DNode
    DiffuseColor *SFColor `xml:"diffuseColor,attr,omitempty""`
    DiffuseTextureMapping *string `xml:"diffuseTextureMapping,attr,omitempty""`
    DiffuseTexture X3DNode `xml:"diffuseTexture,omitempty""`
    SpecularColor *SFColor `xml:"specularColor,attr,omitempty""`
    Glossiness *float32 `xml:"glossiness,attr,omitempty""`
    SpecularGlossinessTextureMapping *string `xml:"specularGlossinessTextureMapping,attr,omitempty""`
    SpecularGlossinessTexture X3DNode `xml:"specularGlossinessTexture,omitempty""`
    EmissiveColor *SFColor `xml:"emissiveColor,attr,omitempty""`
    EmissiveTextureMapping *string `xml:"emissiveTextureMapping,attr,omitempty""`
    EmissiveTexture X3DNode `xml:"emissiveTexture,omitempty""`
    OcclusionStrength *float32 `xml:"occlusionStrength,attr,omitempty""`
    OcclusionTextureMapping *string `xml:"occlusionTextureMapping,attr,omitempty""`
    OcclusionTexture X3DNode `xml:"occlusionTexture,omitempty""`
    NormalScale *float32 `xml:"normalScale,attr,omitempty""`
    NormalTextureMapping *string `xml:"normalTextureMapping,attr,omitempty""`
    NormalTexture X3DNode `xml:"normalTexture,omitempty""`
    Transparency *float32 `xml:"transparency,attr,omitempty""`
    Extensions []X3DNode `xml:",any""`
}

func (n *SpecularGlossinessMaterial) GetNodeName() string { return "SpecularGlossinessMaterial" }
func (n *SpecularGlossinessMaterial) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/specularglossinessmaterial" }
func (n *SpecularGlossinessMaterial) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.DiffuseTexture != nil {
        if err := n.DiffuseTexture.Validate(); err != nil { return fmt.Errorf("validation error in DiffuseTexture: %w", err) }
    }
    if n.SpecularGlossinessTexture != nil {
        if err := n.SpecularGlossinessTexture.Validate(); err != nil { return fmt.Errorf("validation error in SpecularGlossinessTexture: %w", err) }
    }
    if n.EmissiveTexture != nil {
        if err := n.EmissiveTexture.Validate(); err != nil { return fmt.Errorf("validation error in EmissiveTexture: %w", err) }
    }
    if n.OcclusionTexture != nil {
        if err := n.OcclusionTexture.Validate(); err != nil { return fmt.Errorf("validation error in OcclusionTexture: %w", err) }
    }
    if n.NormalTexture != nil {
        if err := n.NormalTexture.Validate(); err != nil { return fmt.Errorf("validation error in NormalTexture: %w", err) }
    }
    if n.Extensions != nil {
        for i, child := range n.Extensions { if err := child.Validate(); err != nil { return fmt.Errorf("validation error in Extensions[%d]: %w", i, err) } }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SpecularGlossinessMaterial) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.DiffuseColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseColor"}, Value: fmt.Sprintf("%v", *n.DiffuseColor)}) }
    if n.DiffuseTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseTextureMapping"}, Value: fmt.Sprintf("%v", *n.DiffuseTextureMapping)}) }
    if n.SpecularColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specularColor"}, Value: fmt.Sprintf("%v", *n.SpecularColor)}) }
    if n.Glossiness != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "glossiness"}, Value: fmt.Sprintf("%v", *n.Glossiness)}) }
    if n.SpecularGlossinessTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specularGlossinessTextureMapping"}, Value: fmt.Sprintf("%v", *n.SpecularGlossinessTextureMapping)}) }
    if n.EmissiveColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveColor"}, Value: fmt.Sprintf("%v", *n.EmissiveColor)}) }
    if n.EmissiveTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "emissiveTextureMapping"}, Value: fmt.Sprintf("%v", *n.EmissiveTextureMapping)}) }
    if n.OcclusionStrength != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "occlusionStrength"}, Value: fmt.Sprintf("%v", *n.OcclusionStrength)}) }
    if n.OcclusionTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "occlusionTextureMapping"}, Value: fmt.Sprintf("%v", *n.OcclusionTextureMapping)}) }
    if n.NormalScale != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalScale"}, Value: fmt.Sprintf("%v", *n.NormalScale)}) }
    if n.NormalTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "normalTextureMapping"}, Value: fmt.Sprintf("%v", *n.NormalTextureMapping)}) }
    if n.Transparency != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transparency"}, Value: fmt.Sprintf("%v", *n.Transparency)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.DiffuseTexture != nil {
        if err := e.EncodeElement(n.DiffuseTexture, xml.StartElement{Name: xml.Name{Local: n.DiffuseTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.SpecularGlossinessTexture != nil {
        if err := e.EncodeElement(n.SpecularGlossinessTexture, xml.StartElement{Name: xml.Name{Local: n.SpecularGlossinessTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.EmissiveTexture != nil {
        if err := e.EncodeElement(n.EmissiveTexture, xml.StartElement{Name: xml.Name{Local: n.EmissiveTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.OcclusionTexture != nil {
        if err := e.EncodeElement(n.OcclusionTexture, xml.StartElement{Name: xml.Name{Local: n.OcclusionTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.NormalTexture != nil {
        if err := e.EncodeElement(n.NormalTexture, xml.StartElement{Name: xml.Name{Local: n.NormalTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.Extensions != nil {
        for _, child := range n.Extensions { if err := e.EncodeElement(child, xml.StartElement{Name: xml.Name{Local: child.GetNodeName()}}); err != nil { return err } }
    }
    return e.EncodeToken(start.End())
}

// SpecularMaterialExtension: SpecularMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type SpecularMaterialExtension struct {
    CoreX3DNode
    Specular *float32 `xml:"specular,attr,omitempty""`
    SpecularTextureMapping *string `xml:"specularTextureMapping,attr,omitempty""`
    SpecularTexture X3DNode `xml:"specularTexture,omitempty""`
    SpecularColor *SFColor `xml:"specularColor,attr,omitempty""`
    SpecularColorTextureMapping *string `xml:"specularColorTextureMapping,attr,omitempty""`
    SpecularColorTexture X3DNode `xml:"specularColorTexture,omitempty""`
}

func (n *SpecularMaterialExtension) GetNodeName() string { return "SpecularMaterialExtension" }
func (n *SpecularMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/specularmaterialextension" }
func (n *SpecularMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.SpecularTexture != nil {
        if err := n.SpecularTexture.Validate(); err != nil { return fmt.Errorf("validation error in SpecularTexture: %w", err) }
    }
    if n.SpecularColorTexture != nil {
        if err := n.SpecularColorTexture.Validate(); err != nil { return fmt.Errorf("validation error in SpecularColorTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *SpecularMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Specular != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specular"}, Value: fmt.Sprintf("%v", *n.Specular)}) }
    if n.SpecularTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specularTextureMapping"}, Value: fmt.Sprintf("%v", *n.SpecularTextureMapping)}) }
    if n.SpecularColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specularColor"}, Value: fmt.Sprintf("%v", *n.SpecularColor)}) }
    if n.SpecularColorTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "specularColorTextureMapping"}, Value: fmt.Sprintf("%v", *n.SpecularColorTextureMapping)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.SpecularTexture != nil {
        if err := e.EncodeElement(n.SpecularTexture, xml.StartElement{Name: xml.Name{Local: n.SpecularTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.SpecularColorTexture != nil {
        if err := e.EncodeElement(n.SpecularColorTexture, xml.StartElement{Name: xml.Name{Local: n.SpecularColorTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// TransmissionMaterialExtension: TransmissionMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type TransmissionMaterialExtension struct {
    CoreX3DNode
    Transmission *float32 `xml:"transmission,attr,omitempty""`
    TransmissionTextureMapping *string `xml:"transmissionTextureMapping,attr,omitempty""`
    TransmissionTexture X3DNode `xml:"transmissionTexture,omitempty""`
}

func (n *TransmissionMaterialExtension) GetNodeName() string { return "TransmissionMaterialExtension" }
func (n *TransmissionMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/transmissionmaterialextension" }
func (n *TransmissionMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.TransmissionTexture != nil {
        if err := n.TransmissionTexture.Validate(); err != nil { return fmt.Errorf("validation error in TransmissionTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *TransmissionMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Transmission != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transmission"}, Value: fmt.Sprintf("%v", *n.Transmission)}) }
    if n.TransmissionTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "transmissionTextureMapping"}, Value: fmt.Sprintf("%v", *n.TransmissionTextureMapping)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.TransmissionTexture != nil {
        if err := e.EncodeElement(n.TransmissionTexture, xml.StartElement{Name: xml.Name{Local: n.TransmissionTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// VolumeMaterialExtension: VolumeMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type VolumeMaterialExtension struct {
    CoreX3DNode
    Thickness *float32 `xml:"thickness,attr,omitempty""`
    ThicknessTextureMapping *string `xml:"thicknessTextureMapping,attr,omitempty""`
    ThicknessTexture X3DNode `xml:"thicknessTexture,omitempty""`
    AttenuationDistance *float32 `xml:"attenuationDistance,attr,omitempty""`
    AttenuationColor *SFColor `xml:"attenuationColor,attr,omitempty""`
}

func (n *VolumeMaterialExtension) GetNodeName() string { return "VolumeMaterialExtension" }
func (n *VolumeMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/volumematerialextension" }
func (n *VolumeMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.ThicknessTexture != nil {
        if err := n.ThicknessTexture.Validate(); err != nil { return fmt.Errorf("validation error in ThicknessTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *VolumeMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.Thickness != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "thickness"}, Value: fmt.Sprintf("%v", *n.Thickness)}) }
    if n.ThicknessTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "thicknessTextureMapping"}, Value: fmt.Sprintf("%v", *n.ThicknessTextureMapping)}) }
    if n.AttenuationDistance != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "attenuationDistance"}, Value: fmt.Sprintf("%v", *n.AttenuationDistance)}) }
    if n.AttenuationColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "attenuationColor"}, Value: fmt.Sprintf("%v", *n.AttenuationColor)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.ThicknessTexture != nil {
        if err := e.EncodeElement(n.ThicknessTexture, xml.StartElement{Name: xml.Name{Local: n.ThicknessTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

// DiffuseTransmissionMaterialExtension: DiffuseTransmissionMaterialExtension is an extension for the PhysicalMaterial and SpecularGlossinessMaterial nodes. For this node to have an effect, add an EnvironmentLight node.
type DiffuseTransmissionMaterialExtension struct {
    CoreX3DNode
    DiffuseTransmission *float32 `xml:"diffuseTransmission,attr,omitempty""`
    DiffuseTransmissionTextureMapping *string `xml:"diffuseTransmissionTextureMapping,attr,omitempty""`
    DiffuseTransmissionTexture X3DNode `xml:"diffuseTransmissionTexture,omitempty""`
    DiffuseTransmissionColor *SFColor `xml:"diffuseTransmissionColor,attr,omitempty""`
    DiffuseTransmissionColorTextureMapping *string `xml:"diffuseTransmissionColorTextureMapping,attr,omitempty""`
    DiffuseTransmissionColorTexture X3DNode `xml:"diffuseTransmissionColorTexture,omitempty""`
}

func (n *DiffuseTransmissionMaterialExtension) GetNodeName() string { return "DiffuseTransmissionMaterialExtension" }
func (n *DiffuseTransmissionMaterialExtension) GetSpecificationURL() string { return "https://create3000.github.io/x_ite/components/x-ite/diffusetransmissionmaterialextension" }
func (n *DiffuseTransmissionMaterialExtension) Validate() error {
    if n.Metadata != nil {
        if err := n.Metadata.Validate(); err != nil { return fmt.Errorf("validation error in Metadata: %w", err) }
    }
    if n.DiffuseTransmissionTexture != nil {
        if err := n.DiffuseTransmissionTexture.Validate(); err != nil { return fmt.Errorf("validation error in DiffuseTransmissionTexture: %w", err) }
    }
    if n.DiffuseTransmissionColorTexture != nil {
        if err := n.DiffuseTransmissionColorTexture.Validate(); err != nil { return fmt.Errorf("validation error in DiffuseTransmissionColorTexture: %w", err) }
    }
    return n.CoreX3DNode.Validate()
}

func (n *DiffuseTransmissionMaterialExtension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    start.Name.Local = n.GetNodeName()
    if n.DiffuseTransmission != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseTransmission"}, Value: fmt.Sprintf("%v", *n.DiffuseTransmission)}) }
    if n.DiffuseTransmissionTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseTransmissionTextureMapping"}, Value: fmt.Sprintf("%v", *n.DiffuseTransmissionTextureMapping)}) }
    if n.DiffuseTransmissionColor != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseTransmissionColor"}, Value: fmt.Sprintf("%v", *n.DiffuseTransmissionColor)}) }
    if n.DiffuseTransmissionColorTextureMapping != nil { start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "diffuseTransmissionColorTextureMapping"}, Value: fmt.Sprintf("%v", *n.DiffuseTransmissionColorTextureMapping)}) }
    if err := e.EncodeToken(start); err != nil { return err }
    if n.Metadata != nil {
        if err := e.EncodeElement(n.Metadata, xml.StartElement{Name: xml.Name{Local: n.Metadata.GetNodeName()}}); err != nil { return err }
    }
    if n.DiffuseTransmissionTexture != nil {
        if err := e.EncodeElement(n.DiffuseTransmissionTexture, xml.StartElement{Name: xml.Name{Local: n.DiffuseTransmissionTexture.GetNodeName()}}); err != nil { return err }
    }
    if n.DiffuseTransmissionColorTexture != nil {
        if err := e.EncodeElement(n.DiffuseTransmissionColorTexture, xml.StartElement{Name: xml.Name{Local: n.DiffuseTransmissionColorTexture.GetNodeName()}}); err != nil { return err }
    }
    return e.EncodeToken(start.End())
}

