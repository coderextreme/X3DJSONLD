<?xml version="1.0" encoding="UTF-8"?>
<!--
    title       : CreateX3dSceneAccessInterfaceJava.xslt
    created     :  6 June 2016
    creator     : Don Brutzman
    description : Create open-source X3D Java Scene Access Interface (SAI) Library (X3DJSAIL)
    reference   : build.xml target BuildSceneAuthoringInterfacesJava.saxon
    reference   : AllX3dElementsAttributes.xml
    reference   : AllX3dElementsAttributesTextTemplate.xslt
    reference   : https://www.w3.org/TR/xslt
    identifier  : https://www.web3d.org/x3d/stylesheets/CreateX3dSceneAccessInterfaceJava.xslt
    history     : https://sourceforge.net/p/x3d/code/HEAD/tree/www.web3d.org/x3d/stylesheets/CreateX3dSceneAccessInterfaceJava.xslt
    license     : license.html

Additional references of interest:

1.	Array or List in Java. Which is faster?
	https://stackoverflow.com/questions/716597/arrayf-or-list-in-java-which-is-faster
	"Answer: The common consensus is that the performance difference is minor. List interface provides more flexibility."

-->

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
                xmlns:xs ="http://www.w3.org/2001/XMLSchema"
	            xmlns:fn ="http://www.w3.org/2005/xpath-functions"
				xmlns:saxon="http://saxon.sf.net/"><!-- https://www.saxonica.com/documentation12/#!extensions/attributes -->
	<!-- extension-element-prefixes="xs" -->
	<xsl:param name="targetDirectory"><xsl:text></xsl:text></xsl:param>

	<xsl:variable name="targetPath">
		<xsl:value-of select="$targetDirectory"/>
		<xsl:if test="(string-length($targetDirectory) > 0)">
			<xsl:text>/</xsl:text>
		</xsl:if>
	</xsl:variable>

	<xsl:output method="text" encoding="UTF-8" cdata-section-elements="javadocBlock interfaceBlock implementationBlock"/> <!-- output methods:  xml html text -->

	<xsl:variable name="debug"><xsl:text>false</xsl:text></xsl:variable>

	<xsl:variable name="saiPackage"                    >           <xsl:text>org.web3d.x3d.sai</xsl:text></xsl:variable>
	<xsl:variable name="saiPackageDirectorySource"     >       <xsl:text>src/org/web3d/x3d/sai</xsl:text></xsl:variable>
	<xsl:variable name="saiPackageDirectoryBuild"      >     <xsl:text>build/org/web3d/x3d/sai</xsl:text></xsl:variable>
	<xsl:variable name="testsPackage"                  >           <xsl:text>org.web3d.x3d.tests</xsl:text></xsl:variable>
	<xsl:variable name="testsPackageDirectorySource"   >       <xsl:text>src/org/web3d/x3d/tests</xsl:text></xsl:variable>
	<xsl:variable name="testsPackageDirectoryBuild"    >     <xsl:text>build/org/web3d/x3d/tests</xsl:text></xsl:variable>

	<xsl:variable name="concreteSubpackageName"        >                         <xsl:text>jsail</xsl:text></xsl:variable>
	<xsl:variable name="concretePackage"               >           <xsl:text>org.web3d.x3d.jsail</xsl:text></xsl:variable>
	<xsl:variable name="concretePackageDirectorySource">    <xsl:text>src/org/web3d/x3d/jsail</xsl:text></xsl:variable>
	<xsl:variable name="concretePackageDirectoryBuild" >  <xsl:text>build/org/web3d/x3d/jsail</xsl:text></xsl:variable>
	<xsl:variable name="jsaiClassSuffix"    ><xsl:text></xsl:text></xsl:variable><!-- originally Object -->
	<xsl:variable name="jsaiInterfaceSuffix"><xsl:text>Interface</xsl:text></xsl:variable>

	<xsl:variable name="x3duomPackage"                 >           <xsl:text>org.web3d.x3d.util.x3duom</xsl:text></xsl:variable>
	<xsl:variable name="x3duomPackageDirectorySource"  >       <xsl:text>src/org/web3d/x3d/util/x3duom</xsl:text></xsl:variable>

	<xsl:variable name="saiJavaSpecificationRootUrl"><xsl:text>https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2</xsl:text></xsl:variable>
	<xsl:variable name="saiAbstractSpecificationRootUrl"><xsl:text>https://www.web3d.org/documents/specifications/19775-2/V3.3/Part02</xsl:text></xsl:variable>
	<xsl:variable name="x3dAbstractSpecificationRootUrl"><xsl:text>https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01</xsl:text></xsl:variable><!-- TODO X3D4 -->

	<xsl:variable name="newValue"><xsl:text>newValue</xsl:text></xsl:variable><!-- default parameter name -->
	<xsl:variable name="x3d.tooltips.path">
		<xsl:text>../tooltips/x3d-4.0.profile.xml</xsl:text>
	</xsl:variable>
	<xsl:variable name="x3d.tooltips.document" select="doc($x3d.tooltips.path)"/>

	<xsl:variable name="modifySpecificationInterfaces"><xsl:text>false</xsl:text></xsl:variable>
	<!-- false: match original Java SAI design with many root-level classes and interfaces -->
	<!--  true: experimental, match good design practice by inserting relevant subpackages -->

    <xsl:variable name="insertSourceMarkers" select="false()"/><!-- code-generation debugging support, helps determining original XSLT code block when autogenerated Java source errors occur -->

    <!-- ======================================================= -->

    <xsl:template match="/"> <!-- process root of input document -->

		<!-- diagnostics
		<xsl:variable name="x3d.object.model.path">
			<xsl:text>../../specifications/X3dUnifiedObjectModel-4.0.xml</xsl:text>
		</xsl:variable>
		<xsl:variable name="x3d.object.model.document" select="doc($x3d.object.model.path)"/>
		<xsl:message>
			<xsl:text>$x3d.object.model.document available: </xsl:text>
			<xsl:value-of select="doc-available(x3d.object.model.path)"/>
		</xsl:message>
        -->
        <xsl:message>
            <xsl:text>*** source-code autogeneration assist: $insertSourceMarkers=</xsl:text>
            <xsl:value-of select="$insertSourceMarkers"/>
        </xsl:message>

		<!-- process fixed files -->
		<xsl:call-template name="FieldDefinitions"/>
		<xsl:call-template name="BaseTypeDefinitions"/>

		<xsl:call-template name="ServiceInterfaces"/>
		<xsl:call-template name="StatementInterfaces"/>
		<xsl:call-template name="ExceptionDefinitions"/>
		<xsl:call-template name="NodeTypeDefinitions"/>
		<xsl:call-template name="ObjectTypeDefinitions"/>
		<xsl:call-template name="NodeInterfacesDefinitions"/>

		<!-- instantiable Plain Old Java Object (POJO) classes -->
		<xsl:call-template name="ConcreteNodeObjectDefinitions"/>

        <!-- process elements and comments -->
        <xsl:apply-templates select="X3dUnifiedObjectModel/* | comment()"/>

    </xsl:template>

    <!-- ===================================================== -->

    <xsl:template match="*"> <!-- rule to process each element -->

        <!-- common initial processing for each element -->
        <xsl:text disable-output-escaping="yes">&lt;</xsl:text>
        <xsl:value-of select="local-name()"/>

        <xsl:apply-templates select="@*"/> <!-- process attributes for this element -->

        <!-- <xsl:apply-templates select="*"/> no need to recurse on child elements -->

        <!-- common final processing for each element -->
        <xsl:text disable-output-escaping="yes">/&gt;</xsl:text><!-- end element -->
        <xsl:text>&#10;</xsl:text>

    </xsl:template>

    <!-- ===================================================== -->

    <xsl:template match="@*"> <!-- rule to process each attribute -->

        <!-- common processing for each attribute -->
        <xsl:text> </xsl:text>
        <xsl:value-of select="local-name()"/>
        <xsl:text>='</xsl:text>
        <xsl:value-of select="."/>
        <xsl:text>'</xsl:text>

    </xsl:template>

    <!-- ===================================================== -->

    <xsl:template match="comment()"> <!-- rule to process each comment -->

        <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
        <xsl:value-of select="."/>
        <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
        <xsl:text>&#10;</xsl:text>

    </xsl:template>

    <!-- ===================================================== -->

	<xsl:variable name="licenseBlock">
		<!-- inserted in each autogenerated source file -->
		<xsl:text>/*</xsl:text><xsl:text>&#10;</xsl:text>
			<xsl:variable name="license.filename"><xsl:text>license.txt</xsl:text></xsl:variable>
			<xsl:value-of select="unparsed-text($license.filename,'UTF-8')"/>
		<xsl:text>*/</xsl:text><xsl:text>&#10;</xsl:text>
		<xsl:text>&#10;</xsl:text>
	</xsl:variable>
    <!-- ===================================================== -->

    <xsl:template name="isX3dStatement">
		<xsl:param name="name"/>
		<!-- note that ROUTE, *Proto*, IMPORT/EXPORT and CommentsBlock are X3D Statements which are also allowed as X3DChildNode -->
		<xsl:value-of select="
			($name = 'X3D') or ($name = 'head') or ($name = 'component') or ($name = 'meta') or ($name = 'unit') or ($name = 'Scene') or
                        ($name = 'IS') or ($name = 'connect') or ($name = 'field') or ($name = 'fieldValue') or ($name = 'ROUTE') or
			($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare') or ($name = 'ProtoInstance') or ($name = 'ProtoInterface') or ($name = 'ProtoBody') or
			($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'CommentsBlock')"/>
        <!-- returns boolean or string? results seem inconsistent...  :( -->
	</xsl:template>

	<!-- ===================================================== -->

    <xsl:template name="javaType">
		<xsl:param name="x3dType"/>
		<xsl:param name="isInterface"/>
		<xsl:variable name="baseType" select="//SimpleType[@name = $x3dType]/@baseType"/>

		<xsl:choose>
			<xsl:when test="contains($x3dType,  'SFString') or ( $x3dType = 'xs:string') or ( $x3dType = 'xs:token') or starts-with( $x3dType, 'xs:ID') or starts-with( $x3dType, 'xs:NMTOKEN') or
                                   ($baseType = 'SFString') or ($baseType = 'xs:string') or ($baseType = 'xs:token') or starts-with($baseType, 'xs:ID') or starts-with($baseType, 'xs:NMTOKEN')">
				<xsl:text>String</xsl:text>
			</xsl:when>
			<xsl:when test="(($x3dType = 'MFString') or ($baseType = 'MFString')) and ($isInterface = 'true')">
				<xsl:text>String[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFString') or ($baseType = 'MFString')">
				<xsl:text disable-output-escaping="yes">ArrayList&lt;String&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'SFBool') or ($baseType = 'SFBool')">
				<xsl:text>boolean</xsl:text>
			</xsl:when>
			<xsl:when test="(($x3dType = 'MFBool') or ($baseType = 'MFBool')) and ($isInterface = 'true')">
				<xsl:text>boolean[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFBool') or ($baseType = 'MFBool')">
				<xsl:text disable-output-escaping="yes">ArrayList&lt;Boolean&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'SFInt32') or ($baseType = 'SFInt32')">
				<xsl:text>int</xsl:text>
			</xsl:when>
			<xsl:when test="(( $x3dType = 'MFInt32') or  ($x3dType = 'SFImage') or  ($x3dType = 'MFImage') or
                             ($baseType = 'MFInt32') or ($baseType = 'SFImage') or ($baseType = 'MFImage')) and ($isInterface = 'true')">
				<xsl:text>int[]</xsl:text>
			</xsl:when>
			<xsl:when test="( $x3dType = 'MFInt32') or  ($x3dType = 'SFImage') or  ($x3dType = 'MFImage') or
                            ($baseType = 'MFInt32') or ($baseType = 'SFImage') or ($baseType = 'MFImage')">
				<xsl:text>ArrayList&lt;Integer&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'SFFloat') or ($baseType = 'SFFloat')">
				<xsl:text>float</xsl:text>
			</xsl:when>
			<xsl:when test="(($x3dType = 'MFFloat') or ($baseType = 'MFFloat')) and ($isInterface = 'true')">
				<xsl:text>float[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFFloat') or ($baseType = 'MFFloat')">
				<xsl:text disable-output-escaping="yes">ArrayList&lt;Float&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="contains( $x3dType,'FVec2f') or contains( $x3dType,'FVec3f') or (@baseType='bboxSizeType') or contains( $x3dType,'FVec4f') or contains( $x3dType,'FRotation') or contains( $x3dType,'FColor') or
                                        contains($baseType,'FVec2f') or contains($baseType,'FVec3f') or ($baseType='bboxSizeType') or contains($baseType,'FVec4f') or contains($baseType,'FRotation') or contains($baseType,'FColor')">
				<xsl:text>float[]</xsl:text>
			</xsl:when>
			<xsl:when test="( $x3dType = 'SFMatrix3f') or ( $x3dType = 'MFMatrix3f') or ( $x3dType = 'SFMatrix4f') or ($ x3dType = 'MFMatrix4f') or
                                        ($baseType = 'SFMatrix3f') or ($baseType = 'MFMatrix3f') or ($baseType = 'SFMatrix4f') or ($baseType = 'MFMatrix4f')">
				<xsl:text>float[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'SFDouble') or ($x3dType = 'SFTime') or ($baseType = 'SFDouble') or ($baseType = 'SFTime')">
				<xsl:text>double</xsl:text>
			</xsl:when>
			<xsl:when test="(($x3dType = 'MFDouble') or ($x3dType = 'MFTime') or ($baseType = 'MFDouble') or ($baseType = 'MFTime')) and ($isInterface = 'true')">
				<xsl:text>double[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFDouble') or ($x3dType = 'MFTime') or ($baseType = 'MFDouble') or ($baseType = 'MFTime')">
				<xsl:text disable-output-escaping="yes">ArrayList&lt;Double&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="contains( $x3dType,'FVec2d') or contains( $x3dType,'FVec3d') or contains( $x3dType,'FVec4d') or
                                        contains($baseType,'FVec2d') or contains($baseType,'FVec3d') or contains($baseType,'FVec4d')">
				<xsl:text>double[]</xsl:text>
			</xsl:when>
			<xsl:when test="( $x3dType = 'SFMatrix3d') or ( $x3dType = 'MFMatrix3d') or ( $x3dType = 'SFMatrix4d') or ( $x3dType = 'MFMatrix4d') or
                                        ($baseType = 'SFMatrix3d') or ($baseType = 'MFMatrix3d') or ($baseType = 'SFMatrix4d') or ($baseType = 'MFMatrix4d')">
				<xsl:text>double[]</xsl:text>
			</xsl:when>
			<xsl:when test="(@name = 'head') or (@name = 'Scene') or (@name = 'IS') or (@name = 'ProtoInterface') or (@name = 'ProtoBody')">
                                <!-- statement singleton -->
				<xsl:value-of select="@name"/>
                <xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
			</xsl:when>
			<xsl:when test="(@name = 'component') or (@name = 'unit') or (@name = 'meta') or (@name = 'connect') or (@name = 'field') or (@name = 'fieldValue')">
                                <!-- statement list -->
				<xsl:text disable-output-escaping="yes">ArrayList&lt;</xsl:text><!-- ArrayList<> -->
				<xsl:value-of select="@name"/>
                                <xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
				<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
			</xsl:when>
			<!-- X3D Java Specification interface definitions are completely ambiguous, there is no benefit to
                 including unnecessarily loose node typing accessors for a single node.  Omitted the following general/harmful case:
			<xsl:when test="($x3dType = 'SFNode') and ($isInterface = 'true')">
				<xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
			</xsl:when> -->
			<xsl:when test="($x3dType = 'SFNode')">
				<xsl:choose>
					<xsl:when test="(string-length(@acceptableNodeTypes) > 0) and not(contains(@acceptableNodeTypes,'|'))">
						<!-- not always singular, example CADFace shape field (Shape|LOD|Transform) -->
                        <xsl:variable name="saiPackagePath">
                            <xsl:call-template name="saiPackage">
                                <xsl:with-param name="nodeType" select="@acceptableNodeTypes"/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:choose>
                            <xsl:when test="(string-length($saiPackagePath) > 0)">
                                <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 13a */</xsl:text></xsl:if> -->
                                <xsl:value-of select="$saiPackagePath"/>
                                <xsl:text>.</xsl:text>
                                <xsl:value-of select="@acceptableNodeTypes"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 13b, saiPackage not found */</xsl:text></xsl:if> -->
                                <xsl:value-of select="@acceptableNodeTypes"/>
                            </xsl:otherwise>
                        </xsl:choose>
						<xsl:variable name="isX3dStatement">
							<xsl:call-template name="isX3dStatement">
								<xsl:with-param name="name" select="@name"/>
							</xsl:call-template>
						</xsl:variable>
						<!-- fixed $isX3dStatement, no longer necessary?
                            <xsl:if test="($isX3dStatement = 'true')">
							<xsl:value-of select="$jsaiClassSuffix"/>append to type name
						</xsl:if> -->
                        <xsl:if test="not($isInterface = 'true') and not(contains(@acceptableNodeTypes,$jsaiClassSuffix)) and not(starts-with(@acceptableNodeTypes,'X3D'))">
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
						</xsl:if>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text><!-- TODO more precise node-typ echecks -->
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFNode') and ($isInterface = 'true')">
				<xsl:text>org.web3d.x3d.sai.Core.X3DNode[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFNode')">
				<xsl:choose>
					<xsl:when test="(string-length(@acceptableNodeTypes) > 0) and not(contains(@acceptableNodeTypes,'|'))">
						<!-- not always singular, example CADFace shape field (Shape|LOD|Transform) -->
						<xsl:text disable-output-escaping="yes">ArrayList&lt;</xsl:text><!-- ArrayList<> -->
                        <xsl:variable name="saiPackagePath">
                            <xsl:call-template name="saiPackage">
                                <xsl:with-param name="nodeType" select="@acceptableNodeTypes"/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:choose>
                            <xsl:when test="(string-length($saiPackagePath) > 0)">
                                <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 13a */</xsl:text></xsl:if> -->
                                <xsl:value-of select="$saiPackagePath"/>
                                <xsl:text>.</xsl:text>
                                <xsl:value-of select="@acceptableNodeTypes"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 13b, saiPackage not found */</xsl:text></xsl:if> -->
                                <xsl:value-of select="@acceptableNodeTypes"/>
                            </xsl:otherwise>
                        </xsl:choose>
						<xsl:variable name="isX3dStatement">
							<xsl:call-template name="isX3dStatement">
								<xsl:with-param name="name" select="@name"/>
							</xsl:call-template>
						</xsl:variable>
                        <xsl:if test="not($isInterface = 'true') and not(contains(@acceptableNodeTypes,$jsaiClassSuffix)) and not(starts-with(@acceptableNodeTypes,'X3D'))">
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
						</xsl:if>
						<!--
						<xsl:if test="not($isInterface = 'true') and not($isX3dStatement = 'true')">
							<xsl:value-of select="$jsaiInterfaceSuffix"/>
						</xsl:if>
						--><!-- append to type name -->
						<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text disable-output-escaping="yes">ArrayList&lt;org.web3d.x3d.sai.Core.X3DNode&gt;</xsl:text><!-- TODO more precise node-type checks -->
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(string-length($x3dType) = 0)">
				<xsl:text> (error: Java type not provided) </xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text> (error: Java type not found for </xsl:text>
				<xsl:value-of select="$x3dType"/>
				<xsl:text>) </xsl:text>
			</xsl:otherwise>
		</xsl:choose>
    </xsl:template>

    <!-- ===================================================== -->

    <xsl:template name="javaValue">
		<xsl:param name="x3dType"/>
		<xsl:param name="schemaValue"/>
		<xsl:param name="javadoc"><xsl:text>false</xsl:text></xsl:param>

		<xsl:variable name="xmlValue">
			<xsl:choose>
				<xsl:when test="($schemaValue='[]')">
				</xsl:when>
				<xsl:when test="starts-with($schemaValue,'[') and ends-with($schemaValue,']')">
					<xsl:value-of select="substring($schemaValue,2,(string-length($schemaValue)-2))"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$schemaValue"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
        <!-- debug
        <xsl:message>
            <xsl:text>javaValue $x3dType=</xsl:text>
            <xsl:value-of select="$x3dType"/>
            <xsl:text> schemaValue=</xsl:text>
            <xsl:value-of select="$schemaValue"/>
            <xsl:text> xmlValue=</xsl:text>
            <xsl:value-of select="$xmlValue"/>
        </xsl:message>
         -->
		<xsl:choose>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFString') or
                            contains($x3dType,'token')   or starts-with($x3dType,'xs:ID') or contains($x3dType,'NMTOKEN')">
				<xsl:text>"</xsl:text>
				<!-- enumeration value: escape each quote character as \" -->
				<xsl:call-template name="escape-quotes-recurse">
					<xsl:with-param name="inputValue" select="$xmlValue"/>
				</xsl:call-template>
				<xsl:text>"</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'EscapeQuotedSFString')">
				<!-- enumeration value: escape each quote character as \" -->
				<xsl:text>"</xsl:text>
				<xsl:call-template name="escape-quotes-recurse">
					<xsl:with-param name="inputValue" select="$xmlValue"/>
				</xsl:call-template>
				<xsl:text>"</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'UnquotedSFString')">
				<!-- enumeration value: escape each quote character as \" -->
				<xsl:value-of select="$xmlValue"/>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'MFString')">
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text disable-output-escaping="yes">new ArrayList&lt;String&gt;(Arrays.&lt;String&gt;asList(</xsl:text><!-- ArrayList<> -->
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>new String[] {</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<!-- avoid empty string when actual value is empty list -->
				<xsl:if test="(string-length(normalize-space($xmlValue)) > 0)">
					<!-- each enumeration value is quoted string, comma-separated -->
					<xsl:value-of select="translate($xmlValue,' ',',')"/>
				</xsl:if>
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text>))</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>}</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFBool')">
				<xsl:value-of select="$xmlValue"/>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'MFBool') or ($x3dType = 'MFInt32') or ($x3dType = 'SFImage') or ($x3dType = 'MFImage')">
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;(Arrays.asList(</xsl:text><!-- ArrayList<> -->
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>{</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:value-of select="translate($xmlValue,' ',',')"/>
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text>))</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>}</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFInt32')">
				<xsl:value-of select="$xmlValue"/>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFFloat')">
				<!-- Java float constants have 'f' appended, e.g. 1.0f -->
				<xsl:call-template name="append-f-to-float-values-recurse">
					<xsl:with-param name="inputValue" select="normalize-space($xmlValue)"/>
				</xsl:call-template>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFDouble') or ($x3dType = 'SFTime')">
				<xsl:value-of select="$xmlValue"/>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'MFFloat') or ($x3dType = 'MFDouble') or ($x3dType = 'MFTime')">
				<!-- Java float constants have 'f' appended, e.g. 1.0f -->
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;(Arrays.asList(</xsl:text><!-- ArrayList<> -->
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>{</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:choose>
					<xsl:when test="($x3dType = 'MFFloat')">
						<xsl:call-template name="append-f-to-float-values-recurse">
							<xsl:with-param name="inputValue" select="normalize-space($xmlValue)"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="append-zero-to-double-values-recurse">
							<xsl:with-param name="inputValue" select="normalize-space($xmlValue)"/>
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text>))</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>}</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			 <!-- ========================================
			<xsl:when test="($x3dType = 'MFDouble') or ($x3dType = 'MFTime')">
				<xsl:text>{</xsl:text>
				<xsl:value-of select="translate($xmlValue,' ',',')"/>
				<xsl:text>}</xsl:text>
			</xsl:when> -->
			 <!-- ======================================== -->
			<xsl:when test="contains($x3dType,'FVec2f') or contains($x3dType,'FVec3f') or contains($x3dType,'FVec4f') or contains($x3dType,'FRotation') or contains($x3dType,'FColor')">
				<xsl:text>{</xsl:text>
				<!-- Java float constants have 'f' appended, e.g. 1.0f -->
				<xsl:call-template name="append-f-to-float-values-recurse">
					<xsl:with-param name="inputValue" select="normalize-space($xmlValue)"/>
				</xsl:call-template>
				<xsl:text>}</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFMatrix3f') or ($x3dType = 'MFMatrix3f') or ($x3dType = 'SFMatrix4f') or ($x3dType = 'MFMatrix4f')">
				<xsl:text>{</xsl:text>
				<!-- Java float constants have 'f' appended, e.g. 1.0f -->
				<xsl:call-template name="append-f-to-float-values-recurse">
					<xsl:with-param name="inputValue" select="normalize-space($xmlValue)"/>
				</xsl:call-template>
				<xsl:text>}</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="contains($x3dType,'FVec2d') or contains($x3dType,'FVec3d') or contains($x3dType,'FVec4d')">
				<xsl:text>{</xsl:text>
				<xsl:value-of select="translate($xmlValue,' ',',')"/>
				<xsl:text>}</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFMatrix3d') or ($x3dType = 'MFMatrix3d') or ($x3dType = 'SFMatrix4d') or ($x3dType = 'MFMatrix4d')">
				<xsl:text>{</xsl:text>
				<xsl:value-of select="translate($xmlValue,' ',',')"/>
				<xsl:text>}</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFNode') and (($xmlValue = 'NULL') or (string-length($xmlValue) = 0))">
				<xsl:text>null</xsl:text><!-- Java null value, not X3D NULL value -->
                <!-- debug diagnostic -->
                <xsl:if test="(string-length($xmlValue) = 0)">
                    <xsl:message>
                        <xsl:text>Warning: SFNode default $xmlValue='</xsl:text>
                        <xsl:value-of select="$xmlValue"/>
                        <xsl:text>' instead of 'NULL'</xsl:text>
                    </xsl:message>
                </xsl:if>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:otherwise>
				<!-- default: treat as simple String -->
				<xsl:text>"</xsl:text>
				<xsl:value-of select="$xmlValue"/>
				<xsl:text>"</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
    </xsl:template>

    <!-- ===================================================== -->

    <xsl:template name="tupleSize">
        <xsl:param name="x3dType"/>

        <xsl:variable name="tupleSizeComputed">
            <xsl:choose>
                <xsl:when test="contains($x3dType,'FBool')   or contains($x3dType,'FInt32')   or contains($x3dType,'FFloat') or
                                contains($x3dType,'FDouble') or contains($x3dType,'FString')  or contains($x3dType,'FTime') or
                                contains($x3dType,'FNode')   or
                                contains($x3dType,'token')   or starts-with($x3dType,'xs:ID') or contains($x3dType,'NMTOKEN')">
                    <xsl:text>1</xsl:text>
                </xsl:when>
                <xsl:when test="contains($x3dType,'FImage')">
                    <!-- irregular tuple size, ignore -->
                    <xsl:text>1</xsl:text>
                </xsl:when>
                <xsl:when test="contains($x3dType,'FVec2')">
                    <xsl:text>2</xsl:text>
                </xsl:when>
                <xsl:when test="contains($x3dType,'FVec3') or ends-with($x3dType,'FColor') or (@baseType='bboxSizeType')">
                    <xsl:text>3</xsl:text>
                </xsl:when>
                <xsl:when test="contains($x3dType,'FVec4') or contains($x3dType,'Rotation') or ends-with($x3dType,'FColorRGBA')">
                    <xsl:text>4</xsl:text>
                </xsl:when>
                <xsl:when test="contains($x3dType,'FMatrix3')">
                    <xsl:text>9</xsl:text>
                </xsl:when>
                <xsl:when test="contains($x3dType,'FMatrix4')">
                    <xsl:text>16</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <!-- report problem -->
                    <xsl:message>
                        <xsl:text>[warning] tupleSize not computed for type=</xsl:text>
                        <xsl:value-of select="$x3dType"/>
                    </xsl:message>
                    <xsl:text>0</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:if test="(string-length(@tupleSize) > 0)">
            <!-- debug
            <xsl:message>
                <xsl:text>[warning] @tupleSize=</xsl:text>
                <xsl:value-of select="@tupleSize"/>
                <xsl:text> for type=</xsl:text>
                <xsl:value-of select="$x3dType"/>
            </xsl:message>
            -->
            <!-- diagnostic -->
            <xsl:if test="not(@tupleSize = $tupleSizeComputed)">
                <xsl:message>
                    <xsl:text>[warning] mismatched tupleSize value (X3DUOM and computed) for type=</xsl:text>
                    <xsl:value-of select="$x3dType"/>
                </xsl:message>
            </xsl:if>
        </xsl:if>
        <!-- return value -->
        <xsl:value-of select="$tupleSizeComputed"/>
    </xsl:template>

    <!-- ===================================================== -->

    <xsl:template name="saiPackage">
        <xsl:param name="nodeType"/>

        <xsl:variable name="nodeTypeBase" select="normalize-space(translate($nodeType,'[]',''))"/>

        <xsl:variable name="saiPackageComputed">
            <xsl:choose>
                <xsl:when test="starts-with($nodeTypeBase,'ArrayList')">
                    <!-- ignore, though package (if any) for contained type must be correct -->
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DNode')       or ($nodeTypeBase = 'X3DChildNode')    or ($nodeTypeBase = 'X3DInfoNode') or
                                ($nodeTypeBase = 'X3DSensorNode') or ($nodeTypeBase = 'X3DBindableNode') or ($nodeTypeBase = 'X3DMetadataObject')">
                    <xsl:text>Core</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DProductStructureChildNode') or starts-with($nodeTypeBase, 'CAD')">
                    <xsl:text>CADGeometry</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DEnvironmentTextureNode')">
                    <xsl:text>CubeMapTexturing</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'DISEntityManager') or ($nodeTypeBase = 'DISEntityTypeMapping') or ($nodeTypeBase = 'EspduTransform') or
                                ends-with($nodeTypeBase, 'Pdu')">
                    <xsl:text>DIS</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DBackgroundNode') or ($nodeTypeBase = 'X3DFogObject') or ($nodeTypeBase = 'FogCoordinate')">
                    <xsl:text>EnvironmentalEffects</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DEnvironmentalSensorNode')">
                    <xsl:text>EnvironmentalSensor</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DSequencerNode') or ($nodeTypeBase = 'X3DTriggerNode')">
                    <xsl:text>EventUtilities</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DFollowerNode') or ($nodeTypeBase = 'X3DChaserNode') or ($nodeTypeBase = 'X3DDamperNode')">
                    <xsl:text>Followers</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'GeoOrigin')">
                    <xsl:text>Geospatial</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DGroupingNode') or ($nodeTypeBase = 'X3DBoundedObject')">
                    <xsl:text>Grouping</xsl:text>
                </xsl:when>
                <xsl:when test="starts-with($nodeTypeBase, 'HAnim')">
                    <xsl:text>HAnim</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DInterpolatorNode')">
                    <xsl:text>Interpolation</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DKeyDeviceSensorNode')">
                    <xsl:text>KeyDeviceSensor</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DLayerNode') or ($nodeTypeBase = 'X3DViewportNode')">
                    <xsl:text>Layering</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DLayoutNode')">
                    <xsl:text>Layout</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DLightNode')">
                    <xsl:text>Lighting</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DViewpointNode') or ($nodeTypeBase = 'ViewpointNode') or ($nodeTypeBase = 'NavigationInfo')">
                    <xsl:text>Navigation</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DNetworkSensorNode') or ($nodeTypeBase = 'X3DUrlObject')">
                    <xsl:text>Networking</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DNurbsControlCurveNode') or ($nodeTypeBase = 'X3DParametricGeometryNode') or ($nodeTypeBase = 'X3DNurbsSurfaceGeometryNode') or
                                ($nodeTypeBase = 'Contour2D') or ($nodeTypeBase = 'ContourPolyline2D') or
                                starts-with($nodeTypeBase, 'Nurbs')">
                    <xsl:text>NURBS</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DParticleEmitterNode') or ($nodeTypeBase = 'X3DParticlePhysicsModelNode')">
                    <xsl:text>ParticleSystems</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DPickableObject') or ($nodeTypeBase = 'X3DPickSensorNode') or contains($nodeTypeBase, 'Pick')">
                    <xsl:text>Picking</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DPointingDeviceSensorNode') or ($nodeTypeBase = 'X3DDragSensorNode') or ($nodeTypeBase = 'X3DTouchSensorNode')">
                    <xsl:text>PointingDeviceSensor</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DTextureProjectorNode')">
                    <xsl:text>TextureProjection</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DColorNode')    or ($nodeTypeBase = 'X3DCoordinateNode')        or ($nodeTypeBase = 'X3DNormalNode') or
                                ($nodeTypeBase = 'X3DGeometryNode') or ($nodeTypeBase = 'X3DGeometricPropertyNode') or ($nodeTypeBase = 'X3DComposedGeometryNode') or
                                ($nodeTypeBase = 'CoordinateDouble')">
                    <xsl:text>Rendering</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DNBodyCollidableNode') or ($nodeTypeBase = 'X3DNBodyCollisionSpaceNode') or ($nodeTypeBase = 'X3DRigidJointNode') or
                                ($nodeTypeBase = 'Contact') or ($nodeTypeBase = 'RigidBody') or ($nodeTypeBase = 'CollisionCollection')">
                    <xsl:text>RigidBodyPhysics</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DScriptNode')">
                    <xsl:text>Scripting</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DProgrammableShaderObject') or ($nodeTypeBase = 'X3DShaderNode') or ($nodeTypeBase = 'X3DVertexAttributeNode') or
                                contains($nodeTypeBase, 'Shader') or ends-with($nodeTypeBase, 'VertexAttribute')">
                    <xsl:text>Shaders</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DShapeNode')       or ($nodeTypeBase = 'X3DAppearanceChildNode')  or
                                ($nodeTypeBase = 'X3DMaterialNode')    or ($nodeTypeBase = 'X3DOneSidedMaterialNode') or
                                ($nodeTypeBase = 'X3DAppearanceNode')  or ($nodeTypeBase = 'Shape')                   or
                                ($nodeTypeBase = 'FillProperties')     or ($nodeTypeBase = 'LineProperties')          or
                                ($nodeTypeBase = 'AcousticProperties') or ($nodeTypeBase = 'PointProperties')">
                    <xsl:text>Shape</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DSoundChannelNode')    or ($nodeTypeBase = 'X3DSoundDestinationNode') or ($nodeTypeBase = 'X3DSoundNode') or
                                ($nodeTypeBase = 'X3DSoundProcessingNode') or ($nodeTypeBase = 'X3DSoundSourceNode')">
                    <xsl:text>Sound</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DFontStyleNode')">
                    <xsl:text>Text</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DTextureNode')           or ($nodeTypeBase = 'X3DSingleTextureNode')           or
                                ($nodeTypeBase = 'X3DTexture2DNode')         or
                                ($nodeTypeBase = 'X3DTextureCoordinateNode') or ($nodeTypeBase = 'X3DSingleTextureCoordinateNode') or
                                ($nodeTypeBase = 'X3DTextureTransformNode')  or ($nodeTypeBase = 'X3DSingleTextureTransformNode')  or
                                ($nodeTypeBase = 'TextureCoordinate') or ($nodeTypeBase = 'TextureProperties')">
                    <xsl:text>Texturing</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DTexture3DNode')">
                    <xsl:text>Texturing3D</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DTimeDependentNode')">
                    <xsl:text>Time</xsl:text>
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DVolumeDataNode') or ($nodeTypeBase = 'X3DComposableVolumeRenderStyleNode') or ($nodeTypeBase = 'X3DVolumeRenderStyleNode')">
                    <xsl:text>VolumeRendering</xsl:text>
                </xsl:when>
                <xsl:when test="starts-with($nodeTypeBase,'org.web3d') or
                                starts-with($nodeTypeBase,'Proto') or
                                starts-with($nodeTypeBase,'Matrix') or
                               ($nodeTypeBase = 'String') or
                               ($nodeTypeBase = 'X3D') or
                               ($nodeTypeBase = 'MField') or
                               ($nodeTypeBase = 'IS') or
                               ($nodeTypeBase = 'AS') or
                               ($nodeTypeBase = 'Scene') or
                               (substring($nodeTypeBase,1,1) = lower-case(substring($nodeTypeBase,1,1)))">
                    <!-- known X3D or Java type -->
                </xsl:when>
                <xsl:when test="($nodeTypeBase = 'X3DConcreteField') or
                                ($nodeTypeBase = 'X3DField')">
                    <!-- known special X3DJSAIL type -->
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>saiPackageUnknown</xsl:text>
                <!-- debug diagnostic -->
                    <xsl:message>
                        <xsl:text>[warning] template saiPackage unable to recognize package for </xsl:text>
                        <xsl:value-of select="$nodeTypeBase"/>
                    </xsl:message>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <!-- return value -->
        <xsl:choose>
            <xsl:when test="starts-with($nodeTypeBase,'MF') or starts-with($nodeTypeBase,'SF')">
                <xsl:text> </xsl:text>
                <xsl:value-of select="$saiPackage"/><!-- field type in root directory -->
            </xsl:when>
            <xsl:when test="(string-length($saiPackageComputed) > 0)">
                <!-- debug
                <xsl:message>
                    <xsl:text>[warning] $saiPackageComputed=</xsl:text>
                    <xsl:value-of select="$saiPackageComputed"/>
                    <xsl:text> for $nodeTypeBase=</xsl:text>
                    <xsl:value-of select="$nodeTypeBase"/>
                </xsl:message>
                -->
                <xsl:text> </xsl:text>
                <xsl:value-of select="$saiPackage"/>
                <xsl:text>.</xsl:text>
                <xsl:value-of select="$saiPackageComputed"/>
            </xsl:when>
            <xsl:when test="(string-length($saiPackageComputed) = 0)">
                <!-- known type -->
            </xsl:when>
            <xsl:otherwise>
                <!-- error: report problem -->
                <xsl:message>
                    <xsl:text>[warning] saiPackage not found for type=</xsl:text>
                    <xsl:value-of select="$nodeTypeBase"/>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- ===================================================== -->

	<!-- master template to create source file containing interface or class -->
	<xsl:template name="generateSourceFile">
		<xsl:param name="name"><xsl:text>..missing name..</xsl:text></xsl:param>
		<xsl:param name="imports"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="inConcretePackage"><xsl:text>false</xsl:text></xsl:param>
		<xsl:param name="visibility"><xsl:text>public</xsl:text></xsl:param>
		<xsl:param name="isAbstract"><xsl:text>false</xsl:text></xsl:param>
		<xsl:param name="isInterface"><xsl:text>false</xsl:text></xsl:param>
		<xsl:param name="isUtilityClass"><xsl:text>false</xsl:text></xsl:param>
		<xsl:param name="extends"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="implements"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="subPackage"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="description"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:param>
		<!-- How to Write Doc Comments for the Javadoc Tool https://www.oracle.com/technetwork/articles/java/index-137868.html -->
		<xsl:param name=       "javadocBlock"/> <!-- typically has additional javadoc for each member -->
		<xsl:param name=     "interfaceBlock"/> <!-- top-level insertion for interface signatures -->
		<xsl:param name="implementationBlock"/> <!-- top-level insertion for class implementations -->

		<!-- Determine if current source is an Exception, Field or service type defined by X3D SAI specification -->
		<xsl:variable   name="isException"
					  select="starts-with($saiJavaSpecificationSection,'B.7') or ends-with($name,'Exception')"/>
		<xsl:variable   name="isFieldInterface"
					  select="starts-with($saiJavaSpecificationSection,'B.4')"/>
		<xsl:variable   name="isServiceInterface"
					  select="starts-with($saiJavaSpecificationSection,'B.5')"/>
		<xsl:variable   name="hasField"
					  select="(count(//InterfaceDefinition/field) > 0)"/>
		<xsl:variable   name="hasJavadocBlock"
					  select="(string-length(normalize-space($javadocBlock)) > 0)"/>
		<xsl:variable   name="hasInterfaceBlock"
					  select="(string-length(normalize-space($interfaceBlock)) > 0)"/>
		<xsl:variable   name="hasImplementationBlock"
					  select="(string-length(normalize-space($implementationBlock)) > 0)"/>
		<xsl:variable name="baseType" select="//ConcreteNode[@name=$name]/InterfaceDefinition/Inheritance/@baseType"/>
		<xsl:variable name="additionalInheritanceBaseType" select="//ConcreteNode[@name=$name]/InterfaceDefinition/AdditionalInheritance/@baseType"/>

		<!-- Determine if current source uses an Exception, Field or service type defined by X3D SAI specification -->
		<!-- B.4 Field interfaces -->
		<xsl:variable   name="hasFieldInterface"
					  select="(   ($isInterface = 'true') and
							   (contains($interfaceBlock,'SF')     or
								contains($interfaceBlock,'MF')     or
								contains($interfaceBlock,'Matrix'))) or
							  (not($isInterface = 'true') and
							   (contains($implementationBlock,'SF')     or
								contains($implementationBlock,'MF')     or
								contains($implementationBlock,'Matrix'))) or
							  InterfaceDefinition/field[starts-with(@type,'SF')] or
							  InterfaceDefinition/field[starts-with(@type,'MF')] or
							  InterfaceDefinition/field[contains(@type,'Matrix')]"/>
		<!-- B.5 Service interfaces -->
		<xsl:variable   name="hasServiceInterface"
					  select="(   ($isInterface = 'true') and
							   (contains($interfaceBlock,'BrowserEvent')    or
								contains($interfaceBlock,'BrowserFactory')  or
								contains($interfaceBlock,'X3DComponent')    or
								contains($interfaceBlock,'ExternalBrowser') or
								contains($interfaceBlock,'BrowserListener'))) or
							  (not($isInterface = 'true') and
							   (contains($implementationBlock,'BrowserEvent')    or
								contains($implementationBlock,'BrowserFactory')  or
								contains($implementationBlock,'X3DComponent')    or
								contains($implementationBlock,'ExternalBrowser') or
								contains($implementationBlock,'BrowserListener'))) or
							  InterfaceDefinition/field[starts-with(@type,'BrowserEvent')]    or
							  InterfaceDefinition/field[starts-with(@type,'BrowserFactory')]  or
							  InterfaceDefinition/field[starts-with(@type,'X3DComponent')]    or
							  InterfaceDefinition/field[starts-with(@type,'ExternalBrowser')] or
							  InterfaceDefinition/field[starts-with(@type,'BrowserListener')]"/>
		<!-- B.7 Exception definitions -->
		<xsl:variable   name="hasException"
					  select="(contains($interfaceBlock,'Exception') or contains($implementationBlock,'Exception'))"/>

		<xsl:variable name="thisClassName">
			<xsl:value-of select="$name"/>
			<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
						  not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not(starts-with($name,'X3DConcrete')) and not(starts-with($name,'X3DUnifiedObjectModel'))">
				<xsl:value-of select="$jsaiClassSuffix"/>
			</xsl:if>
		</xsl:variable>
		<xsl:variable name="sourceFilePath">
			<xsl:choose>
				<xsl:when test="($inConcretePackage = 'true')">
					<xsl:value-of select="$concretePackageDirectorySource"/>
				</xsl:when>
				<xsl:when test="($isInterface = 'true') or ($isException or $isServiceInterface) or ($name = 'X3DFieldEvent')">
					<xsl:value-of select="$saiPackageDirectorySource"/>
				</xsl:when>
				<xsl:when test="contains($name, 'X3DUnifiedObjectModel')">
					<xsl:value-of select="$x3duomPackageDirectorySource"/>
				</xsl:when>
				<xsl:otherwise><!-- concretes -->
					<xsl:value-of select="$concretePackageDirectorySource"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="not($isInterface = 'true') and ($isFieldInterface) and not($name = 'X3DFieldEvent')">
					<xsl:text>/</xsl:text>
					<xsl:text>fields</xsl:text>
				</xsl:when>
				<xsl:when test="(string-length($subPackage) > 0)">
					<xsl:text>/</xsl:text>
					<xsl:value-of select="translate($subPackage,'-','')"/><!-- no componentName hypens allowed (e.g. HAnim) -->
				</xsl:when>
			</xsl:choose>
			<xsl:text>/</xsl:text>
			<xsl:value-of select="$thisClassName"/>
			<xsl:text>.java</xsl:text>
		</xsl:variable>
		<xsl:variable name="canThrowFieldValueException"
                    select="(string-length(@minExclusive) > 0) or (string-length(@maxExclusive) > 0) or
                            (string-length(@minInclusive) > 0) or (string-length(@maxInclusive) > 0)"/>

		<xsl:variable name="isClassX3dStatement">
			<xsl:call-template name="isX3dStatement">
				<xsl:with-param name="name" select="$name"/>
			</xsl:call-template>
		</xsl:variable>

		<xsl:variable name="hasChildrenField" select="string((count(InterfaceDefinition/field[@name = 'children']) > 0)
														and not($name = 'CADPart'))"/>
			<!-- note that GeoLOD has outputOnly children field -->
<!-- debug diagnostic
<xsl:message>
	<xsl:text>*** outputFile/$name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text> $targetPath=</xsl:text>
	<xsl:value-of select="$targetPath"/>
	<xsl:text> $sourceFilePath=</xsl:text>
	<xsl:value-of select="$sourceFilePath"/>
	<xsl:text>, $hasChildrenField=</xsl:text>
	<xsl:value-of select="$hasChildrenField"/>
	<xsl:text>, $isInterface=</xsl:text>EXTERNALPROTOTYPE
	<xsl:value-of select="$isInterface"/>
</xsl:message>
-->
    <xsl:if test="not(ends-with($sourceFilePath, 'X3DFieldxxxxxx.java'))"><!-- TODO clean this up, prior generation no longer needed? -->
		<!-- create source file -->
		<xsl:result-document href="{$targetPath}{$sourceFilePath}" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no"
			>
            <!-- saxon:line-length="180"
                 line-length blocked from saxonHE in later editions following 9.7 :(
                 default saxonHE 9.8+ line length appears to be , which is harmful
                 https://www.saxonica.com/documentation/#!changes/serialization/9.8-9.9
                 https://www.saxonica.com/documentation/#!extensions/output-extras/serialization-parameters -->
			<!-- https://www.saxonica.com/documentation9.5/extensions/output-extras/line-length.html -->
			<!-- method="html" escapes inserted tooltips -->

			<xsl:value-of select="$licenseBlock"/>

			<xsl:text>package </xsl:text>
			<xsl:choose>
				<xsl:when test="($inConcretePackage = 'true')">
					<xsl:value-of select="$concretePackage"/>
				</xsl:when>
				<xsl:when test="($isInterface = 'true') or ($isException or $isServiceInterface) or ($name = 'X3DFieldEvent')">
					<xsl:value-of select="$saiPackage"/>
				</xsl:when>
				<xsl:when test="contains($name, 'X3DUnifiedObjectModel')">
					<xsl:value-of select="$x3duomPackage"/>
				</xsl:when>
				<xsl:otherwise><!-- concretes -->
					<xsl:value-of select="$concretePackage"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="string-length($subPackage) > 0">
				<xsl:text>.</xsl:text>
				<xsl:value-of select="translate($subPackage,'/-','.')"/><!-- trailing slash to dot., no componentName hypens allowed (e.g. HAnim) -->
			</xsl:if>
			<xsl:text>;</xsl:text>
			<xsl:text>&#10;</xsl:text>

			<xsl:if test="string-length(normalize-space($imports)) > 0">
				<xsl:value-of select="$imports" disable-output-escaping="yes"/> <!-- top-level insertion for class or interface -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<!-- imports for built-in types -->
			<xsl:if test="(not($isInterface = 'true') or //field[@type='MFNode']) and not(starts-with($name,'SF')) and not(starts-with($name,'MF')) and
							  not(starts-with($thisClassName, 'X3DConcrete')) and not($isUtilityClass = 'true') and not(starts-with($name,'X3DUnifiedObjectModel'))">
				<xsl:text>import java.util.*;</xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="true()"><!-- ($isInterface = 'true') -->
				<xsl:choose>
					<xsl:when test="($isUtilityClass = 'true')">
						<!-- no additional imports for utility class -->
					</xsl:when>
					<xsl:when test="($modifySpecificationInterfaces = 'true')">
						<xsl:if test="$hasFieldInterface">
							<xsl:text>import org.web3d.x3d.sai.fields.*;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:if>
						<xsl:if test="$hasException or $canThrowFieldValueException">
							<xsl:text>import org.web3d.x3d.sai.exceptions.*;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:if>
						<xsl:if test="$hasServiceInterface">
							<xsl:text>import org.web3d.x3d.sai.services.*;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:if>
					</xsl:when>
					<xsl:otherwise>
						<xsl:choose>
							<xsl:when test="contains($name,'FNode')">
								<xsl:text>// import org.web3d.x3d.sai.Core.*;  // making sure #0</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:if test="($inConcretePackage = 'true')">
									<xsl:text>import org.web3d.x3d.jsail.*; // again making sure #1</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
							</xsl:when>
							<xsl:when test="(($hasFieldInterface or $hasException or $hasServiceInterface or $canThrowFieldValueException) and (string-length($subPackage) > 0))
											 and not(starts-with($name,'SF')) and not(starts-with($name,'MF'))">
								<!-- TODO stronger filtering many be needed to avoid superfluous declaration -->
								<xsl:text>// import org.web3d.x3d.sai.*;      // making sure #2</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>// import org.web3d.x3d.sai.Core.*;  // making sure #2</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>import org.web3d.x3d.sai.InvalidFieldValueException;  // making sure #2</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:if test="($inConcretePackage = 'true')">
									<xsl:text>import org.web3d.x3d.jsail.*; // again making sure #2</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
							</xsl:when>
						</xsl:choose>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:if test="not($isInterface = 'true') and not($isUtilityClass = 'true')">
					<xsl:if test="($name = 'X3D')">
						<!-- X3D imports -->
						<xsl:text>
// X3D object imports ========================
// Base classes and SAX reader for EXIFICIENT
import com.siemens.ct.exi.CodingMode;
import com.siemens.ct.exi.EXIFactory;
import com.siemens.ct.exi.GrammarFactory;
import com.siemens.ct.exi.api.sax.EXIResult;
import com.siemens.ct.exi.api.sax.EXISource;
import com.siemens.ct.exi.exceptions.EXIException;
import com.siemens.ct.exi.grammars.Grammars;
import com.siemens.ct.exi.helpers.DefaultEXIFactory;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.helpers.DefaultHandler;

/* Base classes and SAX reader for OPENEXI */
import org.openexi.proc.common.AlignmentType;
import org.openexi.proc.common.EXIOptionsException;
import org.openexi.proc.common.GrammarOptions;
import org.openexi.proc.grammars.GrammarCache;
import org.openexi.sax.Transmogrifier;
import org.openexi.sax.TransmogrifierException;
import org.openexi.schema.EXISchema;
import org.openexi.scomp.EXISchemaFactoryException;
import org.openexi.scomp.EXISchemaReader;
import org.xml.sax.InputSource;
import javax.xml.parsers.SAXParser;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import org.openexi.sax.EXIReader;

// File operations
import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.logging.*;
import java.util.zip.*;

// XSLT operations: Saxon HE9
import net.sf.saxon.s9api.*;

// XSLT operations: Native Java
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.Result;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;

// XSLT operations
import org.w3c.dom.Document;
import org.xml.sax.SAXException;

// Script operations
import javax.script.ScriptEngineManager;
import javax.script.ScriptEngine;
import javax.script.ScriptException;

/*
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;
*/
import org.web3d.x3d.util.exi.SerializeEXISchema;
</xsl:text>
					</xsl:if>
					<xsl:if test="($name = 'Scene')">
						<!-- Scene imports -->
						<xsl:text>
import org.web3d.x3d.jsail.Layering.LayerSet; // special case, as are Metadata* nodes
</xsl:text>
					</xsl:if>
					<xsl:if test="ends-with($name, 'FontStyle')">
						<!-- FontStyle, ScreenFontSyle imports (since X3DNode implementation is indirect) -->
						<xsl:text>
import org.web3d.x3d.jsail.*;      // making sure, special case *FontStyle nodes
import org.web3d.x3d.jsail.Core.*; // making sure, special case *FontStyle nodes
</xsl:text>
					</xsl:if>
					<xsl:if test="($inConcretePackage = 'true') and not($thisClassName = 'X3DConcreteField') and not($thisClassName = 'CommentsBlock')">
						<xsl:text>
import java.util.Arrays;
import org.web3d.x3d.sai.Core.*;  // making sure #3
import org.web3d.x3d.jsail.*;
import org.web3d.x3d.jsail.Core.*;
</xsl:text>
						<xsl:text>&#10;</xsl:text>
					</xsl:if>
				</xsl:if>
				<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
							  not($thisClassName = 'CommentsBlock') and not(starts-with($thisClassName, 'X3DConcrete')) and
							  not($isUtilityClass = 'true') and not($thisClassName = 'ConfigurationProperties') and not(starts-with($name,'X3DUnifiedObjectModel'))">
					<xsl:text>import org.web3d.x3d.jsail.fields.*; // making sure #4</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:choose>
						<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ShaderPart') or ($name = 'ProtoInterface')">
							<xsl:text>import org.web3d.x3d.jsail.Core.field;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						</xsl:when>
						<!--
						<xsl:when test="($name = 'ProtoInstance')">
							<xsl:text>import org.web3d.x3d.jsail.Core.fieldValue;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						</xsl:when>
						-->
					</xsl:choose>
				</xsl:if>

				<!-- generalized
				<xsl:variable   name="hasCoreComponentType"
							  select="contains($interfaceBlock,'Metadata')             or contains($implementationBlock,'Metadata')             or
									  contains($interfaceBlock,'ProtoInstance')        or contains($implementationBlock,'ProtoInstance')        or
									  contains($interfaceBlock,'WorldInfo')            or contains($implementationBlock,'WorldInfo')            or
									  contains($interfaceBlock,'X3DBindableNode')      or contains($implementationBlock,'X3DBindableNode')      or
									  contains($interfaceBlock,'X3DChildNode')         or contains($implementationBlock,'X3DChildNode')         or
									  contains($interfaceBlock,'X3DInfoNode')          or contains($implementationBlock,'X3DInfoNode')          or
									  contains($interfaceBlock,'X3DNode')              or contains($implementationBlock,'X3DNode')              or
									  contains($interfaceBlock,'X3DPrototypeInstance') or contains($implementationBlock,'X3DPrototypeInstance') or
									  contains($interfaceBlock,'X3DSensorNode')        or contains($implementationBlock,'X3DSensorNode')        or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'Metadata')]  or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'ProtoInstance')]  or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'WorldInfo')]  or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DBindableNode')]      or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DChildNode')]         or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DInfoNode')]          or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DNode')]              or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DPrototypeInstance')] or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DSensorNode')]"/>
				<xsl:if test="($hasCoreComponentType) and ($subPackage != 'Core')">
					<xsl:text>// import org.web3d.x3d.sai.Core.*;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				-->

				<!-- loop over fields to find further imports -->
				<!-- TODO filter out duplicates -->
				<xsl:for-each select="InterfaceDefinition/field[not(starts-with(@name,'set'))][string-length(@acceptableNodeTypes) > 0]">

					<xsl:variable name="fieldName" select="@name"/><!-- avoid duplicates -->
					<xsl:if test="not(preceding-sibling::*[@name = $fieldName]) and not($isUtilityClass = 'true')">
						<xsl:variable name="acceptableNodeTypes"          select="@acceptableNodeTypes"/>
						<xsl:variable name="acceptableTypeComponent" select="//*[@name = $acceptableNodeTypes]/InterfaceDefinition/componentInfo/@name"/>
						<xsl:if test="(string-length($acceptableNodeTypes) > 0)">
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
	<xsl:text>*** $name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text>, field/@name=</xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:text>, $acceptableNodeTypes=</xsl:text>
	<xsl:value-of select="$acceptableNodeTypes"/>
	<xsl:text>, $acceptableTypeComponent=</xsl:text>
	<xsl:value-of select="$acceptableTypeComponent"/>
</xsl:message>
</xsl:if>
							<!-- TODO make this filter more restrictive to eliminate redundant imports, perhaps by using tokenize -->
							<xsl:if test="(string-length($acceptableTypeComponent) > 0) and
                                          (count(preceding-sibling::*[contains(//*[@name = @acceptableNodeTypes]//componentInfo/@name, $acceptableTypeComponent)]) = 0)">
								<xsl:choose>
									<xsl:when test="($isInterface = 'true') and not($inConcretePackage = 'true')">
										<xsl:text>// import org.web3d.x3d.sai.</xsl:text>
										<xsl:if test="not($acceptableTypeComponent = 'fields') or ($modifySpecificationInterfaces = 'true')">
											<xsl:value-of select="translate($acceptableTypeComponent,'-','')"/>
											<xsl:text>.</xsl:text>
										</xsl:if>
										<xsl:text>*;</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:if test="ancestor::ConcreteNode">
											<xsl:text>// import org.web3d.x3d.jsail.</xsl:text>
											<xsl:value-of select="translate(ancestor::ConcreteNode/InterfaceDefinition/componentInfo/@name,'-','')"/>
											<xsl:text>.*; // interfaces for this component</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:if>
										<!-- brute force, can't reach up into X3D Object Model from within string tokenizer -->
										<xsl:if test="//field[contains(@acceptableNodeTypes,'|')][contains(@acceptableNodeTypes,'X3DGroupingNode')][1]">
											<xsl:text>import org.web3d.x3d.jsail.Grouping.*;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:if>
										<xsl:if test="//field[contains(@acceptableNodeTypes,'|')][contains(@acceptableNodeTypes,'X3DGroupingNode')][1]">
											<xsl:text>import org.web3d.x3d.jsail.Navigation.*;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:if>
										<xsl:if test="//field[contains(@acceptableNodeTypes,'|')][contains(@acceptableNodeTypes,'X3DShapeNode')][1]">
											<xsl:text>// import org.web3d.x3d.jsail.Shape.*;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:if>
										<xsl:if test="//field[contains(@acceptableNodeTypes,'|')][contains(@acceptableNodeTypes, 'Inline')][1]">
											<xsl:text>// import org.web3d.x3d.jsail.Networking.*;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:if>

										<xsl:text>// import org.web3d.x3d.jsail.</xsl:text>
										<xsl:value-of select="translate($acceptableTypeComponent,'-','')"/>
										<xsl:text>.*;</xsl:text>
										<xsl:text>
import org.web3d.x3d.jsail.*; // again making sure #4
</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>import org.web3d.x3d.jsail.</xsl:text>
										<xsl:value-of select="translate($acceptableTypeComponent,'-','')"/>
										<xsl:text>.*;</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:if>
						</xsl:if>
					</xsl:if>
				</xsl:for-each>

				<!-- special imports -->
				<xsl:if test="InterfaceDefinition/field[(@type = 'MFNode') and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')))]">
					<xsl:text>import java.util.Arrays;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:if test="not($isInterface = 'true')">
					<xsl:choose>
						<xsl:when test="($name = 'Extrusion')">
							<xsl:text>import java.io.File;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:when>
						<xsl:when test="($baseType = 'X3DComposedGeometryNode') or ($name = 'IndexedLineSet')">
							<xsl:text>import org.web3d.x3d.jsail.Rendering.CoordinateDouble;</xsl:text>
							<xsl:text>&#10;</xsl:text>
							<xsl:text>import org.web3d.x3d.jsail.Texturing.MultiTextureCoordinate;</xsl:text>
							<xsl:text>&#10;</xsl:text>
							<xsl:text>import org.web3d.x3d.jsail.Texturing.TextureCoordinate;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:when>
					</xsl:choose>
				</xsl:if>

				<!-- TODO incorrect?
				<xsl:if test="($name = 'ROUTE')">
					<xsl:text>import org.web3d.x3d.jsail.Scripting.*; // for ROUTE</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if> -->
			</xsl:if>

			<!-- no need to include current package in imports -->
			<!-- convention: avoid adding import calls for fully qualified class references -->
			<!-- TODO confirm handling of more than one comma-separated import -->
			<!--
			<xsl:if test="(string-length($extends) > 0) and contains($extends,'.')">
				<xsl:text>import </xsl:text>
				<xsl:value-of select="$extends"/>
				<xsl:text>;</xsl:text>
				<xsl:text>&#10;</xsl:text><xsl:text>&#10;</xsl:text>
			</xsl:if>
			-->
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
	<xsl:text>*** field/@name=</xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:text>, $description=</xsl:text>
	<xsl:value-of select="$description"/>
	<xsl:text>, $javadocBlock=</xsl:text>
	<xsl:value-of select="$javadocBlock"/>
</xsl:message>
</xsl:if>
			<!-- start class/interface description, javadoc -->
			<xsl:text>&#10;</xsl:text>
			<xsl:text>/**</xsl:text><xsl:text>&#10;</xsl:text>
                        <xsl:choose>
				<xsl:when test="string-length(normalize-space($description)) > 0">
					<xsl:text> * </xsl:text><xsl:value-of select="normalize-space($description)"/>
					<xsl:text>&#10;</xsl:text>
					<xsl:text> * </xsl:text><xsl:text>&#10;</xsl:text>
					<xsl:text> * </xsl:text>
					<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
					<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
					<xsl:text>&#10;</xsl:text>
				</xsl:when>
				<xsl:when test="($isInterface = 'true') and not($inConcretePackage = 'true')">
					<xsl:text> * Abstract node interface, defined by X3D Java Scene Access Interface (SAI) Specification to support X3D Java interoperability.</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text> * </xsl:text><xsl:text>&#10;</xsl:text>
					<xsl:text> * </xsl:text>
					<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
					<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
					<xsl:text>&#10;</xsl:text>
				</xsl:when>
				<xsl:when test="($isException)">
					<!-- exception description is provided by each exception -->
				</xsl:when>
				<xsl:when test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface)">
					<!-- node description is provided by first sentence of tooltip -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:message>
						<xsl:text> [warning] </xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text> has no description...</xsl:text>
					</xsl:message>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="not($inConcretePackage = 'true') and not(starts-with($name, 'X3DUnifiedObjectModel'))">
                            <xsl:text disable-output-escaping="yes"><![CDATA[ *
 * <i>Warning:</i> this is an abstract interface that cannot be instantiated as a concrete object.
 * Java programmers typically only need to use concrete objects provided by the <code>org.web3d.x3d.jsail</code> classes.
]]></xsl:text>
                        </xsl:if>
			<xsl:variable name="isX3dStatement">
				<xsl:call-template name="isX3dStatement">
					<xsl:with-param name="name" select="@name"/>
				</xsl:call-template>
			</xsl:variable>

			<xsl:if test="doc-available($x3d.tooltips.path)">
				<xsl:variable name="tooltipText" select="replace(replace($x3d.tooltips.document//element[@name = $name]/@tooltip,'&#8734;','infinity'),'&#960;','pi')"/>

				<xsl:variable name="containsHintWarning" select="contains($tooltipText,'Hint:') or contains($tooltipText,'Warning:')"/>
				<xsl:if test="(string-length($tooltipText) > 0)">
					<xsl:text> * </xsl:text>
					<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
                                        <xsl:value-of select="@name"/>
					<xsl:text disable-output-escaping="yes"> </xsl:text>
					<xsl:choose>
						<xsl:when test="($isX3dStatement = 'true')">
							<xsl:text>statement</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text>node</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:text disable-output-escaping="yes"> tooltip&lt;/i&gt;: </xsl:text>

					<xsl:variable name="tooltipHTML">
								<!-- debug
								<xsl:if test="contains($tooltipText,'http')">
									<xsl:message>
										<xsl:text>*** found http: </xsl:text>
										<xsl:value-of select="$tooltipText" disable-output-escaping="yes"/>
									</xsl:message>
								</xsl:if>
							</xsl:with-param>
						</xsl:call-template>
								-->
						<xsl:call-template name="bulletize-hints-warnings">
							<xsl:with-param name="tooltipText">
								<xsl:call-template name="wrap-hyperlinks">
									<xsl:with-param name="string">
										<!-- xsl:text> debug: escape-javadoc-characters </xsl:text -->
										<xsl:call-template name="escape-javadoc-characters">
											<xsl:with-param name="inputValue">
												<xsl:value-of select="$tooltipText" disable-output-escaping="yes"/>
											</xsl:with-param>
										</xsl:call-template>
									</xsl:with-param>
								</xsl:call-template>
							</xsl:with-param>
						</xsl:call-template>
					</xsl:variable>
					<!-- debug diagnostic
					<xsl:if test="contains($tooltipHTML,'http')">
						<xsl:message>
							<xsl:text>  * found http, wrapped: </xsl:text>
							<xsl:value-of select="$tooltipHTML" disable-output-escaping="yes"/>
						</xsl:message>
					</xsl:if>
					-->
                                        <xsl:choose>
                                            <!-- statement tooltips themselves start with '[X3D statement]' -->
                                            <xsl:when test="starts-with($tooltipHTML,'[X3D statement] ')">
                                                <xsl:value-of select="substring-after($tooltipHTML,'[X3D statement] ')" disable-output-escaping="yes"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:value-of select="$tooltipHTML" disable-output-escaping="yes"/>
                                            </xsl:otherwise>
                                        </xsl:choose>

					<xsl:if test="not($containsHintWarning)">
						<xsl:text> * </xsl:text>
						<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
						<xsl:text>&#10;</xsl:text>
					</xsl:if>
				</xsl:if>
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
	<xsl:text>*** $name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text>, $x3d.tooltips.path=</xsl:text>
	<xsl:value-of select="$x3d.tooltips.path"/>
	<xsl:text>, doc-available($x3d.tooltips.path)=</xsl:text>
	<xsl:value-of select="doc-available($x3d.tooltips.path)"/>
	<xsl:text>, $tooltipText=</xsl:text>
	<xsl:value-of select="$tooltipText" disable-output-escaping="no"/>
	<!--
	<xsl:text>&#10;</xsl:text>
	<xsl:text>  $tooltipTextWithHyperlinks=</xsl:text>
	<xsl:copy-of select="$tooltipTextWithHyperlinks"/>
	-->
</xsl:message>
</xsl:if>
			</xsl:if> <!-- end tooltip -->

			<xsl:if test="not($isInterface = 'true') and
						  (   contains($name, 'FColor')            or contains($name, 'Background')           or
						   starts-with($name, 'ColorChaser')       or starts-with($name, 'ColorDamper')       or contains($name, 'Light')      or
						   starts-with($name, 'ColorInterpolator') or starts-with($name, 'ParticleSystem')    or
						   ($name = 'Fog') or ($name = 'LocalFog') or
						   starts-with($name, 'TextureProperties') or contains($name, 'Material')   or
						   starts-with($name, 'FillProperties')    or starts-with($name, 'LineProperties')    or starts-with($name, 'MultiTexture') or
						   starts-with($name, 'EdgeEnhancementVolumeStyle') or starts-with($name, 'CartoonVolumeStyle') or
						   starts-with($name, 'OpacityMapVolumeStyle')      or starts-with($name, 'ToneMappedVolumeStyle'))">

				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * Note that {@linkplain SFColor</xsl:text>
				<xsl:value-of select="$jsaiClassSuffix"/>
				<xsl:text>#ALICEBLUE SFColor</xsl:text><xsl:value-of select="$jsaiClassSuffix"/>
				<xsl:text>} provides a variety of color constants.</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>

			<xsl:if test="($name = 'meta')">
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes"> Metadata terms for consistent referencing:</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;ul&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; Dublin Core Metadata Initiative (DCMI): &lt;a href="https://www.dublincore.org/documents/dcmi-terms" target="_blank"&gt;Terms&lt;/a&gt; and </xsl:text>
				<xsl:text disable-output-escaping="yes"> &lt;a href="https://www.dublincore.org/documents/dces" target="_blank"&gt;Element Set&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; HTML5 section 4.2.5: &lt;a href="https://www.w3.org/TR/html5/document-metadata.html#the-meta-element" target="_blank"&gt;The meta element&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; HTML4 section 7.4.4: &lt;a href="https://www.w3.org/TR/html4/struct/global.html#h-7.4.4" target="_blank"&gt;Meta data&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; &lt;a href="https://vancouver-webpages.com/META" target="_blank"&gt;Dictionary of HTML META Tags&lt;/a&gt; </xsl:text>
				<xsl:text disable-output-escaping="yes">   (&lt;a href="https://vancouver-webpages.com/META/about-mk-metas2.html" target="_blank"&gt;About&lt;/a&gt;) &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;/ul&gt;&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes"> Metadata terms for language codes:</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;ul&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; IETF Best Current Practice (BCP) 47: &lt;a href="https://tools.ietf.org/html/bcp47" target="_blank"&gt;Tags for Identifying Languages&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; ISO 639-2: &lt;a href="https://www.loc.gov/standards/iso639-2/langhome.html" target="_blank"&gt;Codes for the Representation of Names of Languages&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; Internet Assigned Numbers Authority (IANA) Protocol Registries: &lt;a href="https://www.iana.org/protocols#index_L" target="_blank"&gt;Language Tags&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;/ul&gt;&#10;</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>

			<xsl:if test="($name = 'unit')">
				<xsl:text>&#10;</xsl:text>`
				<xsl:text disable-output-escaping="yes"> * &lt;a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#Standardunitscoordinates" target="_blank"&gt;X3D specification: 4.3.6 Standard units and coordinate system&lt;/a&gt; &#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> defines how scale factors can modify an entire scene.</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * Scale-conversion constants provide correct names and values for common conversion factors. References:</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;ul&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; &lt;a href="https://www.unit-conversion.info" target="_blank"&gt;Unit conversion&lt;/a&gt; website &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; &lt;a href="https://en.wikipedia.org/wiki/Newton_%28unit%29#Conversion_factors" target="_blank"&gt;Wikipedia Conversion factors, units of force&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; &lt;a href="https://www.unitsconversion.com.ar/massunitsconversion/index.htm" target="_blank"&gt;Unit conversion&lt;/a&gt; website &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;/ul&gt;&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>

			<xsl:if test="not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not($inConcretePackage = 'true') and not(starts-with($name,'X3DUnifiedObjectModel'))"> <!-- final entries -->
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;i&gt;Package hint:&lt;/i&gt; </xsl:text>
				<xsl:choose>
					<xsl:when test="($isInterface = 'true')">
						<xsl:text> This interface is defined by the X3D Java Language Binding Specification for the Scene Authoring Interface (SAI).</xsl:text>
					</xsl:when>
					<!-- TODO confirm wording OK in each case: -->
					<xsl:when test="($isFieldInterface or $isException or $isServiceInterface)">
						<xsl:text> This specification class is defined by the X3D Java Language Binding Specification for the Scene Authoring Interface (SAI).</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text> This </xsl:text>
						<xsl:value-of select="$concretePackage"/>
						<xsl:text> concrete class is used for implementing a standalone X3D object as a </xsl:text>
						<!-- https://stackoverflow.com/questions/1082050/linking-to-an-external-url-in-javadoc -->
						<xsl:text disable-output-escaping="yes"><![CDATA[<a href="https://en.wikipedia.org/wiki/Plain_old_Java_object" target="_blank">Plain Old Java Object (POJO)</a>.]]></xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text> * If you are writing Java code for use inside an X3D Script node, compile separate code using only the </xsl:text>
						<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
						<xsl:value-of select="$saiPackage"/>
						<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
						<xsl:text> package instead.</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			<xsl:text>&#10;</xsl:text>
			<xsl:if test="$hasJavadocBlock">
				<xsl:if test="not(starts-with(normalize-space($javadocBlock),'*'))">
					<xsl:text> * </xsl:text>
				</xsl:if>
				<xsl:value-of select="$javadocBlock" disable-output-escaping="yes"/>
				<xsl:text> * </xsl:text><xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:text> * @author Don Brutzman and Roy Walmsley</xsl:text><xsl:text>&#10;</xsl:text>

			<xsl:if test="(string-length($saiJavaSpecificationSection) > 0) or (string-length($saiJavaSpecificationRelativeUrl) > 0)">
				<!-- debug diagnostics if one is missing:S
				<xsl:if test="not($saiJavaSpecificationSection) or (string-length($saiJavaSpecificationSection) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains saiJavaSpecificationRelativeUrl='</xsl:text>
						<xsl:value-of select="$saiJavaSpecificationRelativeUrl"/>
						<xsl:text>' but not saiJavaSpecificationSection</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="not($saiJavaSpecificationRelativeUrl) or (string-length($saiJavaSpecificationRelativeUrl) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains saiJavaSpecificationSection='</xsl:text>
						<xsl:value-of select="$saiJavaSpecificationSection"/>
						<xsl:text>' but not saiJavaSpecificationRelativeUrl</xsl:text>
					</xsl:message>
				</xsl:if>
                -->
				<xsl:if test="ends-with($saiJavaSpecificationRelativeUrl,'#')">
					<xsl:message>
						<xsl:text>*** Code-generation error: saiJavaSpecificationRelativeUrl=</xsl:text>
						<xsl:value-of select="$saiJavaSpecificationRelativeUrl"/>
						<xsl:text> ends with # and is missing bookmark</xsl:text>
					</xsl:message>
				</xsl:if>
				<!-- javadoc -->
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="]]></xsl:text>
				<xsl:value-of select="$saiJavaSpecificationRootUrl"/>
				<xsl:text>/</xsl:text>
				<xsl:value-of select="$saiJavaSpecificationRelativeUrl"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[" target="_blank">SAI Java Specification]]></xsl:text>
				<xsl:if test="string-length($saiJavaSpecificationSection) > 0">
					<xsl:text>: </xsl:text>
					<xsl:value-of select="$saiJavaSpecificationSection"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="(string-length($saiAbstractSpecificationSection) > 0) or (string-length($saiAbstractSpecificationRelativeUrl) > 0)">
				<!-- diagnostics if one is missing -->
				<xsl:if test="not($saiAbstractSpecificationSection) or (string-length($saiAbstractSpecificationSection) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains saiAbstractSpecificationRelativeUrl but not saiAbstractSpecificationSection</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="not($saiAbstractSpecificationRelativeUrl) or (string-length($saiAbstractSpecificationRelativeUrl) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains saiAbstractSpecificationSection but not saiAbstractSpecificationRelativeUrl</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="ends-with($saiAbstractSpecificationRelativeUrl,'#')">
					<xsl:message>
						<xsl:text>*** Code-generation error: saiAbstractSpecificationRelativeUrl=</xsl:text>
						<xsl:value-of select="$saiAbstractSpecificationRelativeUrl"/>
						<xsl:text> ends with # and is missing bookmark</xsl:text>
					</xsl:message>
				</xsl:if>
				<!-- javadoc -->
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="]]></xsl:text>
				<xsl:value-of select="$saiAbstractSpecificationRootUrl"/>
				<xsl:text>/</xsl:text>
				<xsl:value-of select="$saiAbstractSpecificationRelativeUrl"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[" target="blank">SAI Abstract Specification]]></xsl:text>
				<xsl:if test="string-length($saiAbstractSpecificationSection) > 0">
					<xsl:text>: </xsl:text>
					<xsl:value-of select="$saiAbstractSpecificationSection"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="(string-length($x3dAbstractSpecificationSection) > 0) or (string-length($x3dAbstractSpecificationRelativeUrl) > 0)">
				<!-- debug diagnostics if one is missing
				<xsl:if test="not($x3dAbstractSpecificationSection) or (string-length($x3dAbstractSpecificationSection) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains x3dAbstractSpecificationRelativeUrl='</xsl:text>
						<xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/>
						<xsl:text>' but not x3dAbstractSpecificationSection</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="not($x3dAbstractSpecificationRelativeUrl) or (string-length($x3dAbstractSpecificationRelativeUrl) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains x3dAbstractSpecificationSection='</xsl:text>
						<xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/>
						<xsl:text>' but not x3dAbstractSpecificationRelativeUrl</xsl:text>
					</xsl:message>
				</xsl:if> -->
				<xsl:if test="ends-with($x3dAbstractSpecificationSection,'#')">
					<xsl:message>
						<xsl:text>*** Code-generation error: x3dAbstractSpecificationSection=</xsl:text>
						<xsl:value-of select="$x3dAbstractSpecificationSection"/>
						<xsl:text> ends with # and is missing bookmark</xsl:text>
					</xsl:message>
				</xsl:if>
				<!-- javadoc -->
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="]]></xsl:text>
				<xsl:if test="not(contains($x3dAbstractSpecificationRelativeUrl,'https://'))">
					<!-- full url might have been retrieved from X3D Object Model, otherwise create it -->
					<xsl:value-of select="$x3dAbstractSpecificationRootUrl"/>
					<xsl:text>/</xsl:text>
				</xsl:if>
				<xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[" target="blank">X3D Abstract Specification]]></xsl:text>
				<xsl:if test="string-length($x3dAbstractSpecificationSection) > 0">
					<xsl:text>: </xsl:text>
					<xsl:value-of select="$x3dAbstractSpecificationSection"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not(starts-with($name,'X3DUnifiedObjectModel'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html]]></xsl:text>
				<xsl:if test="not(starts-with($name, 'SF')) and not(starts-with($name, 'MF')) and
							  not(starts-with($name, 'X3D') and (string-length($name) > 3))">
					<xsl:text>#</xsl:text>
					<xsl:value-of select="$name"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[" target="_blank">X3D Tooltips]]></xsl:text>
				<xsl:if test="not(starts-with($name, 'SF')) and not(starts-with($name, 'MF')) and
							  not(starts-with($name, 'X3D') and (string-length($name) > 3))">
					<xsl:text>: </xsl:text>
					<xsl:value-of select="$name"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="starts-with($name,'SF') or starts-with($name,'MF')">
<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#field"      target="_blank">X3D Tooltips: field</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#fieldValue" target="_blank">X3D Tooltips: fieldValue</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>

			<xsl:variable name="sceneAuthoringHintSection">
					<xsl:choose>
						<xsl:when test="($name = 'AudioClip') or ($name = 'Sound')">
							<xsl:text>Audio</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'Color')">
							<xsl:text>Color</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'meta')">
							<xsl:text>metaStatements</xsl:text>
						</xsl:when>
						<xsl:when test="starts-with($name,'Metadata')">
							<xsl:text>Metadata</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'Inline') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'AS') or starts-with($name,'Proto')">
							<xsl:text>InlinesPrototypes</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'Script')">
							<xsl:text>Scripts</xsl:text>
						</xsl:when>
						<xsl:when test="contains($name, 'Texture')">
							<xsl:text>Images</xsl:text>
						</xsl:when>
						<xsl:when test="contains($name, 'Triangle') or contains($name, 'Face') or contains($name, 'Quad')">
							<xsl:text>Meshes</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'Transform')">
							<xsl:text>CoordinateSystems</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'url')">
							<xsl:text>urls</xsl:text>
						</xsl:when>
						<xsl:when test="contains($name,'Viewpoint') or ($name = 'NavigationInfo')">
							<xsl:text>Viewpoints</xsl:text>
						</xsl:when>
						<xsl:when test="contains($name, 'Volume')">
							<xsl:text>Volume</xsl:text>
						</xsl:when>
					</xsl:choose>
				</xsl:variable>

			<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html]]></xsl:text>
			<!-- append relevant bookmarks -->
			<xsl:if test="(string-length($sceneAuthoringHintSection) > 0)">
				<xsl:text>#</xsl:text>
				<xsl:value-of select="$sceneAuthoringHintSection"/>
			</xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[" target="_blank">X3D Scene Authoring Hints]]></xsl:text>
			<xsl:if test="(string-length($sceneAuthoringHintSection) > 0)">
				<xsl:text>: </xsl:text>
				<xsl:value-of select="$sceneAuthoringHintSection"/>
			</xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
			<!-- special javadoc links -->
			<xsl:choose>
				<xsl:when test="starts-with($name,'SFColor')">
					<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a>
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'IS')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
 * @see connect
 * @see ProtoDeclare
 * @see ProtoInterface
 * @see ProtoBody
 * @see ProtoInstance
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'connect')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
 * @see IS
 * @see ProtoDeclare
 * @see ProtoInterface
 * @see ProtoBody
 * @see ProtoInstance
]]></xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>&#10;</xsl:text>
				</xsl:otherwise>
			</xsl:choose>

			<xsl:text> */</xsl:text><!-- end javadoc -->
			<xsl:text>&#10;</xsl:text>

			<!-- ********************************************************************************** -->
			<!-- generate source code -->
			<xsl:value-of select="$visibility"/>
			<xsl:if test="(string-length($visibility) > 0)">
				<xsl:text> </xsl:text>
			</xsl:if>
			<xsl:if test="($isAbstract = 'true')">
				<xsl:text>abstract</xsl:text>
				<xsl:text> </xsl:text>
			</xsl:if>
			<xsl:choose>
				<xsl:when test="($isInterface = 'true')">
					<xsl:text>interface</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>class</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$name"/>
			<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
						  not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not(starts-with($name,'X3DConcrete')) and not(starts-with($name,'X3DUnifiedObjectModel'))">
				<xsl:value-of select="$jsaiClassSuffix"/>
			</xsl:if>
			<xsl:if test="(string-length($extends) > 0) and not(ends-with(normalize-space($extends),'*/'))">
				<xsl:text> extends </xsl:text>
				<xsl:choose>
					<xsl:when test="contains($extends,'.')">
						<!-- TODO substring after last . https://stackoverflow.com/questions/17468891/substring-after-last-character-in-xslt -->
						<xsl:value-of select="$extends"/>
					</xsl:when>
					<xsl:otherwise>
                        <xsl:variable name="saiPackagePath">
                            <xsl:call-template name="saiPackage">
                                <xsl:with-param name="nodeType" select="$extends"/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:choose>
                            <xsl:when test="(string-length($saiPackagePath) > 0)">
                                <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 1a */</xsl:text></xsl:if>
                                <xsl:value-of select="$saiPackagePath"/>
                                <xsl:text>.</xsl:text>
                                <xsl:value-of select="$extends"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 1b, saiPackage not found */</xsl:text></xsl:if>
                                <xsl:value-of select="$extends"/>
                            </xsl:otherwise>
                        </xsl:choose>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			<xsl:if test="string-length($implements) > 0">
				<xsl:text> implements </xsl:text>
				<xsl:value-of select="$implements"/>
			</xsl:if>

			<xsl:variable name="wrapClassBrackets">
				<!-- BrowserEvent and BrowserFactory are classes ; $isClassX3dStatement or -->
				<xsl:value-of select="(not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and not($name = 'CommentsBlock'))
                                       or ($name = 'BrowserFactory') or ($name = 'BrowserFactoryImpl') or ($name = 'BrowserListener')"/>
			</xsl:variable>
			<!-- debug or ($name = 'BrowserEvent')
<xsl:message>
	<xsl:text>*** wrapClassBrackets open: $name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text>, $isInterface=</xsl:text>
	<xsl:value-of select="$isInterface"/>
	<xsl:text>, $isFieldInterface=</xsl:text>
	<xsl:value-of select="$isFieldInterface"/>
	<xsl:text>, $isException=</xsl:text>
	<xsl:value-of select="$isException"/>
	<xsl:text>, $isServiceInterface=</xsl:text>
	<xsl:value-of select="$isServiceInterface"/>
	<xsl:text>, $wrapClassBrackets=</xsl:text>
	<xsl:value-of select="$wrapClassBrackets"/>
</xsl:message>
-->
			<xsl:if test="($wrapClassBrackets)">
				<xsl:text>&#10;</xsl:text>
				<xsl:text>{</xsl:text>
			</xsl:if>

			<!-- interfaceBlock and sourceFile completeness diagnostics -->
			<xsl:choose>
				<xsl:when test="($isInterface = 'true') and ($hasInterfaceBlock)">
					<xsl:if test="starts-with(normalize-space($interfaceBlock),'{')">
						<xsl:message>
							<xsl:text>*** Code-generation warning: $interfaceBlock starts with {</xsl:text>
						</xsl:message>
					</xsl:if>
					<xsl:value-of select="$interfaceBlock" disable-output-escaping="yes"/> <!-- typically has additional javadoc for each member -->
				</xsl:when>
				<xsl:when test="($isInterface = 'true') and not($hasField)">
					<xsl:message>
						<xsl:text>*** Code-generation warning: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> has no interfaceBlock defined, stub comment inserted</xsl:text>
						<!-- debug -->
						<xsl:text>; $hasField=</xsl:text>
						<xsl:value-of select="$hasField"/>
						<xsl:text>, $isInterface=</xsl:text>
						<xsl:value-of select="$isInterface"/>
						<xsl:text>, $hasInterfaceBlock=</xsl:text>
						<xsl:value-of select="$hasInterfaceBlock"/>
						<xsl:text>, $hasImplementationBlock=</xsl:text>
						<xsl:value-of select="$hasImplementationBlock"/>
					</xsl:message>
					<!--
					<xsl:if test="not($hasInterfaceBlock)">
						<xsl:text>

	// TODO define interfaceBlock in CreateX3dSceneAccessInterfaceJava.xslt</xsl:text>
					</xsl:if>
					-->
				</xsl:when>
				<xsl:when test="not($isInterface = 'true') and not($hasField) and not($hasImplementationBlock) and not($name = 'CommentsBlock')">
					<xsl:message>
						<xsl:text>*** Code-generation warning: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> has no implementationBlock defined, stub comment inserted</xsl:text>
						<!-- debug -->
						<xsl:text>; $hasField=</xsl:text>
						<xsl:value-of select="$hasField"/>
						<xsl:text>, $isInterface=</xsl:text>
						<xsl:value-of select="$isInterface"/>
						<xsl:text>, $hasInterfaceBlock=</xsl:text>
						<xsl:value-of select="$hasInterfaceBlock"/>
						<xsl:text>, $hasImplementationBlock=</xsl:text>
						<xsl:value-of select="$hasImplementationBlock"/>
					</xsl:message>
					<!--
					<xsl:text>
	// TODO define implementationBlock in CreateX3dSceneAccessInterfaceJava.xslt
					</xsl:text>
					-->
				</xsl:when>
				<xsl:when test="($isInterface = 'true') or not($isInterface = 'true')">
					<!-- fallthrough case, OK -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:message>
						<xsl:text>*** Code-generation warning: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> has illegal definition, $isInterface=</xsl:text>
						<xsl:value-of select="$isInterface"/>
						<xsl:text> (allowed values are true or false)</xsl:text>
					</xsl:message>
					<xsl:text>

	// TODO code-generation error, need to correctly define $isInterface as true or false in CreateX3dSceneAccessInterfaceJava.xslt
					</xsl:text>
				</xsl:otherwise>
			</xsl:choose>

			<xsl:if test="not($hasChildrenField = 'true') and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
                          not(starts-with($name, 'X3DConcrete')) and not($isUtilityClass = 'true') and
                          not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not(($isUtilityClass = 'true')) and not(starts-with($name,'X3DUnifiedObjectModel'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
    /** required by internal interface, empty list provided since no children array present in this class */
    private ArrayList<String> commentsList;
]]></xsl:text>
			</xsl:if>

			<xsl:choose>
				<xsl:when test="($isInterface = 'true') and ($inConcretePackage = 'true')">
					<!-- all done with this interface, which extends SAI interface -->
				</xsl:when>
				<xsl:when test="($isUtilityClass = 'true') or starts-with($name,'X3DUnifiedObjectModel')">
					<!-- additions for this concrete utility class -->
					<xsl:if test="($hasImplementationBlock)">
						<xsl:if test="starts-with(normalize-space($implementationBlock),'{')">
							<xsl:message>
								<xsl:text>*** Code-generation warning: $implementationBlock starts with {</xsl:text>
							</xsl:message>
						</xsl:if>
						<xsl:value-of select="$implementationBlock" disable-output-escaping="yes"/> <!-- typically has additional javadoc included -->
					</xsl:if>
				</xsl:when>
				<xsl:when test="($hasField)">

					<!-- ===================================================== -->
					<!-- Source code: Member declarations -->
					<xsl:choose>
						<!-- define default attribute types and SFString/MFString enumeration constants (if any) -->
						<xsl:when test="($isInterface = 'true') or ($name = 'CommentsBlock') or ($name = 'ConfigurationProperties')">
							<!-- no output -->
						</xsl:when>
						<xsl:when test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface)">
							<!-- Source code: member object declarations -->
							<xsl:for-each select="InterfaceDefinition/field[((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')) and
												  not(@name = 'DEF') and not(@name = 'USE') and not(@name = 'id') and not(@name = 'class') and not((@name = 'style') and not(ends-with($name, 'FontStyle')))]">

								<xsl:if test="position()=1">
									<xsl:text>&#10;</xsl:text>
									<xsl:text>    // Member value declarations are encapsulated and private, using preferred Java types for concretes library</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:variable name="isX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="memberObjectName"><!-- lower camel case, usually -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="@name"/>
										</xsl:when>
										<xsl:when test="(@name = 'AS')"><!-- special case: IMPORT, EXPORT -->
											<xsl:value-of select="@name"/>
										</xsl:when>
										<xsl:when test="(@name = 'set_boolean')"> <!-- special case: BooleanFilter, BooleanToggle, IntegerTrigger -->
											<xsl:text>booleanField</xsl:text>
										</xsl:when>
										<xsl:when test="starts-with(@name,'set_')">
											<xsl:value-of select="translate(substring(substring-after(@name,'set_'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
											<xsl:value-of select="substring(substring-after(@name,'set_'),2)"/>
										</xsl:when>
										<xsl:when test="starts-with(@name,'set')">
											<xsl:value-of select="translate(substring(substring-after(@name,'set'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
											<xsl:value-of select="substring(substring-after(@name,'set'),2)"/>
										</xsl:when>
										<xsl:when test="contains(@name,'_changed')">
											<xsl:value-of select="translate(substring(substring-before(@name,'_changed'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
											<xsl:value-of select="substring(substring-before(@name,'_changed'),2)"/>
										</xsl:when>
										<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
											<!-- unmodified -->
											<xsl:value-of select="@name"/>
										</xsl:when>
										<xsl:when test="(@name = 'id')">
											<xsl:text>HtmlID</xsl:text>
										</xsl:when>
										<xsl:when test="(@name = 'class')">
											<!-- getClass() is reserved by Java Object() class -->
											<xsl:text>cssClass</xsl:text>
										</xsl:when>
										<xsl:when test="((@name = 'style') and not(ends-with($name, 'FontStyle')))">
											<!-- similarly named for clarity, consistency -->
											<xsl:text>cssStyle</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="translate(substring(@name,1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
											<xsl:value-of select="substring(@name,2)"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:variable name="normalizedMemberObjectName">
                                    <xsl:variable name="saiPackagePath">
                                        <xsl:call-template name="saiPackage">
                                            <xsl:with-param name="nodeType" select="$memberObjectName"/>
                                        </xsl:call-template>
                                    </xsl:variable>
                                    <xsl:if test="(string-length($saiPackagePath) > 0)">
                                            <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 11a */</xsl:text></xsl:if>
                                            <xsl:value-of select="$saiPackagePath"/>
                                            <xsl:text>.</xsl:text>
                                    </xsl:if>
									<!-- translate name into legal Java form here to avoid xpath problems -->
									<xsl:value-of select="translate($memberObjectName,'-','_')"/>
									<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
										<xsl:text>List</xsl:text><!-- append to member name -->
									</xsl:if>
								</xsl:variable>
								<xsl:variable name="javaType">
                                    <!-- can include collections, must be escaped -->
                                    <xsl:call-template name="javaType">
                                        <xsl:with-param name="x3dType" select="@type"/>
                                        <xsl:with-param name="isInterface" select="$isInterface"/>
                                    </xsl:call-template>
                                </xsl:variable>
                                <xsl:variable name="listType">
                                    <xsl:choose>
                                        <xsl:when test="true() and (@type = 'MFNode') and not((@name = 'X3D') or (@name = 'head') or (@name = 'meta') or (@name = 'unit') or (@name = 'component') or (@name = 'Scene'))">
                                            <!-- TODO allow both allowed node types and ProtoInstance in same list, carefully control node type in set methods. impacts multiple methods. -->
                                            <xsl:text disable-output-escaping="yes"><![CDATA[ArrayList<org.web3d.x3d.sai.Core.X3DNode>]]></xsl:text>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="$javaType" disable-output-escaping="yes"/><!-- append to type name -->
                                            <xsl:if test="($isX3dStatement = 'true') and starts-with(@type,'X3D') and (ends-with(@type,'Node') or ends-with(@type,'Object'))">
                                                <xsl:value-of select="$jsaiInterfaceSuffix"/>
                                            </xsl:if>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:variable>
                                <xsl:variable name="javaReferenceType"><!-- base type of ArrayList -->
                                    <xsl:choose>
                                        <xsl:when test="(@type = 'MFNode') and not($isX3dStatement = 'true') and not(@name = 'field') and not(@name = 'fieldValue')"><!-- and not(contains($javaType,'X3DUrlObject'))  (contains($javaType,'Object') or (@acceptableNodeTypes = 'X3DMetadataObject')) and not(contains($javaType,'X3DMetadataObject')) and -->
                                            <xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
                                        </xsl:when>
                                        <xsl:when test="contains($javaType,'&lt;')">
                                            <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="$javaType"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:variable>
                                <xsl:variable name="javaPrimitiveType">
                                    <xsl:call-template name="javaType">
                                        <xsl:with-param name="x3dType" select="@type"/>
                                        <xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
                                    </xsl:call-template>
                                </xsl:variable>
                                <xsl:if test="not(preceding-sibling::*[@name=$memberObjectName]) and not(preceding-sibling::*[@name=concat('set',$memberObjectName)]) and not(preceding-sibling::*[@name=concat('set_',$memberObjectName)]) and not(preceding-sibling::*[@name=concat($memberObjectName,'_changed')])">
                                    <!-- debug -->
                                    <xsl:text>&#10;</xsl:text>
                                    <xsl:text>    /* </xsl:text>
                                    <xsl:text>@name=</xsl:text>
                                    <xsl:value-of select="@name"/>
                                    <xsl:text>, @type=</xsl:text>
                                    <xsl:value-of select="@type"/>
                                    <xsl:text>, $javaType=</xsl:text>
                                    <xsl:value-of select="$javaType"/>
                                    <xsl:text>, $javaReferenceType=</xsl:text>
                                    <xsl:value-of select="$javaReferenceType"/>
                                    <xsl:text>, $javaPrimitiveType=</xsl:text>
                                    <xsl:value-of select="$javaPrimitiveType"/>
                                    <xsl:text>, $normalizedMemberObjectName=</xsl:text>
                                    <xsl:value-of select="$normalizedMemberObjectName"/>
                                    <xsl:text>, $isX3dStatement=</xsl:text>
                                    <xsl:value-of select="$isX3dStatement"/>
                                    <xsl:text>, @acceptableNodeTypes=</xsl:text>
                                    <xsl:value-of select="@acceptableNodeTypes"/>
                                    <xsl:text> */ </xsl:text>

                                    <xsl:text>&#10;</xsl:text>
                                    <xsl:text>    private </xsl:text>
                                    <xsl:choose>
                                        <xsl:when test="contains($javaType,'ArrayList')">
                                            <xsl:text disable-output-escaping="yes"><![CDATA[ArrayList<]]></xsl:text>
                                            <xsl:value-of select="$javaReferenceType"/>
                                            <xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:variable name="saiPackagePath">
                                                <xsl:call-template name="saiPackage">
                                                    <xsl:with-param name="nodeType" select="$javaReferenceType"/>
                                                </xsl:call-template>
                                            </xsl:variable>
                                            <xsl:choose>
                                                <xsl:when test="(string-length($saiPackagePath) > 0)">
                                                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 10a */</xsl:text></xsl:if>
                                                    <xsl:value-of select="$saiPackagePath"/>
                                                    <xsl:text>.</xsl:text>
                                                    <xsl:value-of select="$javaReferenceType"/>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 10b, saiPackage not found */</xsl:text></xsl:if>
                                                    <xsl:value-of select="$javaReferenceType"/>
                                                </xsl:otherwise>
                                            </xsl:choose>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                    <xsl:text> </xsl:text>
                                    <xsl:value-of select="$normalizedMemberObjectName"/>
                                    <!-- problem prevention: avoid null by including default when needed for this type -->
                                    <xsl:choose>
                                        <xsl:when test="contains($javaType,'ArrayList')">
                                                <xsl:text disable-output-escaping="yes"><![CDATA[ = new ArrayList<>()]]></xsl:text>
                                        </xsl:when>
                                        <xsl:when test="(@type = 'SFString')">
                                                <xsl:text> = new String()</xsl:text>
                                        </xsl:when>
                                    </xsl:choose>
                                    <xsl:text>;</xsl:text>
                                    <xsl:text> //  X3D field type: </xsl:text>
                                    <xsl:value-of select="@type"/>

                                    <xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
                                        <xsl:text> acceptable node types: </xsl:text>
                                        <xsl:value-of select="@acceptableNodeTypes"/>
                                        <xsl:if test="not(@name = 'IS') and not(@name = 'field') and not(@name = 'fieldValue')">
                                            <xsl:text> or ProtoInstance</xsl:text>
                                        </xsl:if>
                                        <!-- TODO is it possible to restrict these further when setting children? -->
									</xsl:if>
                                    <xsl:if test="starts-with($name,'field') and ($normalizedMemberObjectName = 'value')">
                                        <xsl:text> or MFString</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>

                                    <!-- debug: xslt boolean tests. saxon returns string.  sheesh.
									<xsl:text>// bleah test: @type</xsl:text>
                                    <xsl:value-of select="@type"/>
									<xsl:text>, $isX3dStatement=</xsl:text>
                                    <xsl:value-of select="$isX3dStatement"/>
									<xsl:text>, boolean($isX3dStatement = 'true')=</xsl:text>
                                    <xsl:value-of select="boolean($isX3dStatement = 'true')"/>
									<xsl:text>, not($isX3dStatement = 'true')=</xsl:text>
                                    <xsl:value-of select="not($isX3dStatement = 'true')"/>
									<xsl:text>, not(boolean($isX3dStatement = 'true'))=</xsl:text>
                                    <xsl:value-of select="not(boolean($isX3dStatement = 'true'))"/>
									<xsl:text>, ($isX3dStatement = 'true')=</xsl:text>
                                    <xsl:value-of select="($isX3dStatement = 'true')"/>
									<xsl:text>, not($isX3dStatement = 'true')=</xsl:text>
                                    <xsl:value-of select="not($isX3dStatement = 'true')"/>
									<xsl:text>&#10;</xsl:text>
                                     -->
									<xsl:if test="(@type = 'SFNode') and not($isX3dStatement = 'true')">
										<!-- add corresponding member variable for SFNode ProtoInstance substitution -->
                                        <xsl:text>	private ProtoInstance</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> </xsl:text>
                                        <xsl:value-of select="$normalizedMemberObjectName"/>
                                        <xsl:text>ProtoInstance; // allowed alternative for </xsl:text>
                                        <xsl:value-of select="$normalizedMemberObjectName"/>
                                        <xsl:text> field</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
									</xsl:if>
								</xsl:if>
							</xsl:for-each>

							<xsl:if test="($name = 'ProtoInstance')">
								<xsl:text>
					      ProtoDeclare</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> referenceProtoDeclare;
					ExternProtoDeclare</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> referenceExternProtoDeclare;
								</xsl:text>
							</xsl:if>
							<xsl:if test="($name = 'field') or ($name = 'fieldValue')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
    /** Default value for this field type is an empty array. */
    private static final boolean[] DEFAULT_VALUE_BOOLEAN = new boolean[0]; // initialize as empty array

    /** boolean array, typed value holder */
    private boolean[] valueArrayBoolean;

    /** Default value for this field type is an empty array. */
    private static final int[] DEFAULT_VALUE_INTEGER = new int[0]; // initialize as empty array

    /** int array, typed value holder */
    private int[] valueArrayInteger;

    /** Default value for this field type is an empty array. */
    private static final float[] DEFAULT_VALUE_FLOAT = new float[0]; // initialize as empty array

    /** float array, typed value holder */
    private float[] valueArrayFloat;

    /** Default value for this field type is an empty array. */
    private static final double[] DEFAULT_VALUE_DOUBLE = new double[0]; // initialize as empty array

    /** double array, typed value holder */
    private double[] valueArrayDouble;

]]></xsl:text>
							</xsl:if>

							<!-- Source code: add special constant definitions -->
							<xsl:choose>
								<xsl:when test="($name = 'X3D')">
									<!-- Excerpt from X3D-Edit SchemaData.jsail -->
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/** XML declaration appears on first line of an XML document.
	 * <br> <i>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_HEADER = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";

	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.1//EN" "https://www.web3d.org/specifications/x3d-4.1.dtd"&gt;</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_4_1 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 4.1//EN\" \"https://www.web3d.org/specifications/x3d-4.1.dtd\">";

	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.0//EN" "https://www.web3d.org/specifications/x3d-4.0.dtd"&gt;</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_4_0 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 4.0//EN\" \"https://www.web3d.org/specifications/x3d-4.0.dtd\">";

	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "https://www.web3d.org/specifications/x3d-3.3.dtd"&gt;</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_3_3 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.3//EN\" \"https://www.web3d.org/specifications/x3d-3.3.dtd\">";

	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.2//EN" "https://www.web3d.org/specifications/x3d-3.2.dtd"&gt;</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_3_2 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.2//EN\" \"https://www.web3d.org/specifications/x3d-3.2.dtd\">";

	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.1//EN" "https://www.web3d.org/specifications/x3d-3.1.dtd"&gt;</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_3_1 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.1//EN\" \"https://www.web3d.org/specifications/x3d-3.1.dtd\">";

	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "https://www.web3d.org/specifications/x3d-3.0.dtd"&gt;</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_3_0 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.0//EN\" \"https://www.web3d.org/specifications/x3d-3.0.dtd\">";

	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.0.xsd'</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_3_0_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.0.xsd'";
	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.1.xsd'</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_3_1_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.1.xsd'";
	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.2.xsd'</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_3_2_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.2.xsd'";
	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.3.xsd'</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_3_3_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.3.xsd'";
	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-4.0.xsd'</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_4_0_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-4.0.xsd'";
	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-4.1.xsd'</i>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_4_1_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-4.1.xsd'";
]]></xsl:text>

									<xsl:text disable-output-escaping="yes"><![CDATA[
	// Acronym and glossary choices
]]></xsl:text>
                                                                    <xsl:for-each select="//SimpleType[(@name='acronymChoices') or (@name='glossaryChoices')]/enumeration">
                                                                        <xsl:variable name="camelCaseEnumerationName">
                                                                            <xsl:value-of select="translate(substring(@value,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
                                                                            <xsl:value-of select="substring(@value,2)"/>
                                                                        </xsl:variable>
									<xsl:variable name="capitalizedEnumerationName">
                                                                            <xsl:value-of select="translate(@value,'abcdefghijklmnopqrstuvwxyz-','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
                                                                        </xsl:variable>
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * <b>]]></xsl:text><xsl:value-of select="@value"/><xsl:text disable-output-escaping="yes"><![CDATA[</b>: ]]></xsl:text><xsl:value-of select="translate(@appinfo,'#','')"/><xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/glossary.html#]]></xsl:text>
                                                                        <xsl:value-of select="$camelCaseEnumerationName"/>
                                                                        <xsl:text>" target="_blank"&gt;X3D 4.0 Architecture - Definitions, acronyms, and abbreviated terms: </xsl:text>
                                                                        <xsl:value-of select="@value"/>
                                                                        <xsl:text disable-output-escaping="yes"><![CDATA[</a> */
	public static final String GLOSSARY_]]></xsl:text>
                                                                        <xsl:value-of select="$capitalizedEnumerationName"/>
                                                                        <xsl:text> = "</xsl:text>
                                                                        <xsl:value-of select="translate(@appinfo,'#','')"/>
                                                                        <xsl:text>";</xsl:text>
                                                                        <xsl:text>&#10;</xsl:text>
                                                                    </xsl:for-each>
								</xsl:when>
								<xsl:when test="not($isInterface = 'true') and ($name = 'unit')">
									<!-- unit factors from X3D-Edit X3dSchemaData.jsail -->
									<xsl:text disable-output-escaping="yes"><![CDATA[
	// Scale factors https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Scale

	/** unit statement conversionFactor for converting scene values of angles to Radians from Degrees */
	public static final double CONVERSIONFACTOR_ANGLES_toRadiansFromDegrees = 0.0174532925167;
	/** unit statement conversionFactor for converting scene values of angles to Radians from FullCircle */
	public static final double CONVERSIONFACTOR_ANGLES_toRadiansFromFullCircle = 6.283185307179;
	/** unit statement conversionFactor for converting scene values of angles to Radians from Grads */
	public static final double CONVERSIONFACTOR_ANGLES_toRadiansFromGrads = 0.01570796326795;

	/** unit statement conversionFactor for converting scene values of length to Meters from Pica */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromPica = 0.0042175176;
	/** unit statement conversionFactor for converting scene values of length to Meters from Inches */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromInches = 0.0254;
	/** unit statement conversionFactor for converting scene values of length to Meters from Feet */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromFeet = 0.3048;
	/** unit statement conversionFactor for converting scene values of length to Meters from Yards */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromYards = 0.9144;
	/** unit statement conversionFactor for converting scene values of length to Meters from Fathoms */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromFathoms = 1.8288;
	/** unit statement conversionFactor for converting scene values of length to Meters from Furlongs */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromFurlongs = 201.1684;
	/** unit statement conversionFactor for converting scene values of length to Meters from Miles */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromMiles = 1609.344;
	/** unit statement conversionFactor for converting scene values of length to Meters from Nautical Miles */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromNauticalMiles = 1852.0;
	/** unit statement conversionFactor for converting scene values of length to Meters from Microns */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromMicrons = 0.000001;
	/** unit statement conversionFactor for converting scene values of length to Meters from Millimeters */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromMillimeters = 0.001;
	/** unit statement conversionFactor for converting scene values of length to Meters from Centimeters */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromCentimeters = 0.01;
	/** unit statement conversionFactor for converting scene values of length to Meters from Kilometers */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromKilometers = 1000.0;

	/** unit statement conversionFactor for converting scene values of force to Newtons from Dynes */
	public static final double CONVERSIONFACTOR_FORCE_toNewtonsFromDynes = 0.00001;
	/** unit statement conversionFactor for converting scene values of force to Newtons from Kilogram-force */
	public static final double CONVERSIONFACTOR_FORCE_toNewtonsFromKilogramForce = 9.8068;
	/** unit statement conversionFactor for converting scene values of force to Newtons from Pounds-force */
	public static final double CONVERSIONFACTOR_FORCE_toNewtonsFromPoundsForce = 4.4482;
	/** unit statement conversionFactor for converting scene values of force to Newtons from Poundal */
	public static final double CONVERSIONFACTOR_FORCE_toNewtonsFromPoundal = 0.13826;

	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Grains Avoirdupois (gr) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromGrains = 0.00006479891;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Drams Avoirdupois (dr) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromDrams = 0.001771845195312;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Ounces Avoirdupois (oz) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromOunces = 0.028349523125;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Troy Ounces (toz) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromTroyOunces = 0.0311034768;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Pounds Avoirdupois (lb) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromPounds = 0.45359237;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Stone, i.e. 14 Pounds Avoirdupois (lb) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromStone = 6.35029318;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Tons (U.S. short) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromTons = 907.18474;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Micrograms */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFrom = 0.000000001;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Milligrams */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromMilligrams = 0.000001;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Centigrams */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromCentigrams = 0.00001;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Carats */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromCarats = 0.0002;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Grams (g) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromGrams = 0.001;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Dekagrams */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromDekagrams = 0.01;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Metric Tonnes (t) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromMetricTonnes = 1000.0;

]]></xsl:text>
								</xsl:when>
<!-- field added to X3DUOM
	private ArrayList<field> fieldList = new ArrayList<>(); // instantiation
-->
<!--
								<xsl:when test="not($isInterface = 'true') and (($name = 'Script') or ($name = 'ShaderProgram'))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	private String sourceCode;
]]></xsl:text>
								</xsl:when>
-->
								<xsl:when test="not($isInterface = 'true') and (($name = 'ComposedShader') or ($name = 'PackagedShader'))">
<!-- field added to X3DUOM
									<xsl:text disable-output-escaping="yes"><![CDATA[
	private ArrayList<field> fieldList = new ArrayList<>(); // instantiation
]]></xsl:text>
-->
								</xsl:when>
                                                                <!-- handled by X3DUOM
								<xsl:when test="not($isInterface = 'true') and ($name = 'ShaderPart')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	private String sourceCode;
]]></xsl:text>
								</xsl:when>
                                                                -->
								<xsl:when test="not($isInterface = 'true') and (($name = 'ProtoBody'))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/** The first node of a prototype declaration determines its node type, and a reference is stored here.
		The node itself also remains in the children list, in order with other CommentBlocks and additional ProtoBody contained nodes. */
	private X3DConcreteNode primaryNode;
]]></xsl:text>
								</xsl:when>
								<!--  ProtoInterface fieldList and ProtoInstance fieldValueList declarations handled separately -->
							</xsl:choose>
<!-- IS added to X3DUOM
							<xsl:if test="not($isInterface = 'true') and (not($isX3dStatement = 'true') or ($name = 'ProtoInstance'))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/** IS/connect statements can be added if this node is within a ProtoBody and connections are defined between prototype fields and built-in node fields */
	private IS</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> IS;
]]></xsl:text>
							</xsl:if>
-->
							<!-- Source code: String enumeration constants -->
							<xsl:for-each select="InterfaceDefinition/field">
								<xsl:for-each select="enumeration[(@value!='...') and (string-length(normalize-space(@value)) > 0)]">

									<xsl:variable name="fieldName" select="translate(../@name,'-','_')"/>
									<xsl:if test="position()=1">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	// ==== String constants for enumeration values ensure correct syntax and avoid run-time errors ====</xsl:text>
										<xsl:text>&#10;</xsl:text>

										<xsl:if test="(ends-with(../@baseType,  'Values') or ends-with(../@baseType,  'Choices') or
                                                                                               ends-with(../@simpleType,'Values') or ends-with(../@simpleType,'Choices'))">
                                                                                        <xsl:text>&#10;</xsl:text>
                                                                                        <xsl:text>	/** Reduce excessive warning information for this attribute. */ </xsl:text>
                                                                                        <xsl:text>&#10;</xsl:text>
                                                                                        <xsl:text>	static boolean </xsl:text>
                                                                                        <xsl:value-of select="../@name"/>
                                                                                        <xsl:text>WarningAlreadyProvided = false;</xsl:text>
                                                                                        <xsl:text>&#10;</xsl:text>
                                                                                </xsl:if>

										<xsl:if test="(ends-with(../@baseType,'Values') or ends-with(../@baseType,'Choices'))">
											<xsl:variable name="currentBaseType" select="../@baseType"/>
											<xsl:variable name="parentField" select=".."/>
											<!-- https://stackoverflow.com/questions/41505539/find-preceding-sibling-of-the-parent-element-in-xslt -->
											<xsl:if test="not(../preceding-sibling::*[(@baseType = $currentBaseType)])">
												<xsl:text>&#10;</xsl:text>
												<xsl:text>	/** List of specification-defined enumeration values, with additional author-defined enumeration values</xsl:text>
												<!-- TODO clarify HAnim names for consistency between X3DUOM/tooltips -->
												<xsl:if test="not(@additionalEnumerationValuesAllowed = 'true')">
													<xsl:text> not</xsl:text>
												</xsl:if>
												<xsl:text> allowed.</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text disable-output-escaping="yes"><![CDATA[<br ><br >]]></xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>	* Allowed values: </xsl:text>
												<xsl:for-each select="../enumeration">
													<xsl:if test="position() gt 1">
														<xsl:text>, </xsl:text>
													</xsl:if>
													<xsl:text>&quot;</xsl:text>
													<xsl:call-template name="escape-quote-characters"> <!-- tail recursion -->
														<xsl:with-param name="inputValue" select="@value"/>
													</xsl:call-template>
													<xsl:text>&quot;</xsl:text>
												</xsl:for-each>
												<xsl:text>.</xsl:text>

												<xsl:if test="//SimpleType[@name = $currentBaseType][string-length(@appinfo) > 0]">
													<xsl:text>&#10;</xsl:text>
													<xsl:text disable-output-escaping="yes"><![CDATA[<br ><br >]]></xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>	 * </xsl:text>
													<xsl:value-of select="normalize-space(//SimpleType[@name = $currentBaseType]/@appinfo)"/>
												</xsl:if>
												<xsl:if test="//SimpleType[@name = $currentBaseType][string-length(@documentation) > 0]">
													<xsl:text>&#10;</xsl:text>
													<xsl:text>	 * @see </xsl:text>
													<xsl:call-template name="wrap-hyperlinks">
														<xsl:with-param name="string">
															<!-- xsl:text> debug: escape-javadoc-characters0 </xsl:text -->
															<xsl:call-template name="escape-javadoc-characters">
																<xsl:with-param name="inputValue">
																	<xsl:value-of select="normalize-space(//SimpleType[@name = $currentBaseType]/@documentation)" disable-output-escaping="yes"/>
																</xsl:with-param>
															</xsl:call-template>
														</xsl:with-param>
													</xsl:call-template>
												</xsl:if>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>	*/</xsl:text>
												<xsl:text disable-output-escaping="yes"><![CDATA[
	public static final ArrayList<String> ]]></xsl:text><xsl:value-of select="../@baseType"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ = new ArrayList<>(Arrays.<String>asList(]]></xsl:text>
												<xsl:for-each select="../enumeration">
													<xsl:if test="position() gt 1">
														<xsl:text>, </xsl:text>
													</xsl:if>
													<xsl:text>&quot;</xsl:text>
													<xsl:call-template name="escape-quotes-recurse"> <!-- tail recursion -->
														<xsl:with-param name="inputValue" select="@value"/>
													</xsl:call-template>
													<xsl:text>&quot;</xsl:text>
												</xsl:for-each>
												<xsl:text>));</xsl:text>
												<xsl:text>&#10;</xsl:text>
											</xsl:if>
										</xsl:if>
									</xsl:if>

									<xsl:text>&#10;</xsl:text>
									<xsl:text>	/** </xsl:text>
									<!-- debug @appinfo and documentation/@source
									<xsl:message>
										<xsl:text> enumeration </xsl:text>
										<xsl:value-of select="@name"/>
										<xsl:for-each select="@*">
											<xsl:text> @</xsl:text>
											<xsl:value-of select="local-name()"/>
											<xsl:text>="</xsl:text>
											<xsl:value-of select="."/>
											<xsl:text>"</xsl:text>
										</xsl:for-each>
									</xsl:message> -->
									<xsl:if test="(string-length(@appinfo) > 0)">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;Tooltip:&lt;/i&gt; </xsl:text>
										<xsl:value-of select="normalize-space(@appinfo)"/>
										<xsl:if test="not(ends-with(normalize-space(@appinfo),'.'))">
											<xsl:text>.</xsl:text>
										</xsl:if>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
									</xsl:if>
									<xsl:value-of select="../@type"/>
									<xsl:text> field named </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:value-of select="$fieldName"/>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:if test="(string-length(../@simpleType) > 0)">
										<xsl:text> with X3DUOM simpleType </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="../@simpleType"/>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									</xsl:if>
									<xsl:if test="(string-length(../@simpleType) > 0) and (string-length(../@baseType) > 0)">
                                                                            <xsl:text> and</xsl:text>
									</xsl:if>
									<xsl:if test="(string-length(../@baseType) > 0)">
										<xsl:text> with X3DUOM baseType </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="../@baseType"/>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									</xsl:if>
									<xsl:choose>
										<xsl:when test="(../@type = 'SFString')">
											<xsl:text> can equal this value </xsl:text>
										</xsl:when>
										<xsl:when test="(../@type = 'MFString') and (../@additionalEnumerationValuesAllowed='true')">
											<xsl:text> is an array that can include this quoted enumeration value (and also may include alternate values) </xsl:text>
										</xsl:when>
										<xsl:when test="(../@type = 'MFString')">
											<xsl:text> is an array that can only include one set of the quoted enumeration values </xsl:text>
										</xsl:when>
                                                                                <xsl:otherwise><xsl:text> </xsl:text></xsl:otherwise>
									</xsl:choose>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:variable name="fieldName" select="translate(../@name,'-','_')"/>
									<xsl:variable name="x3dType">
										<xsl:choose>
											<!-- TODO needed? EscapeQuotedSFString -->
											<xsl:when test="(../@type='MFString') and (contains(@value,'&quot; &quot;'))">
												<xsl:text>EscapeQuotedSFString</xsl:text><!-- intentional override for multi-value enumerations, e.g.  ALIGN_LEFT_BOTTOM -->
											</xsl:when>
											<!-- individual enumeration values within MFString array are each SFString -->
											<xsl:when test="(../@type='MFString')">
												<xsl:text>UnquotedSFString</xsl:text><!-- intentional override for singleton enumeration-->
											</xsl:when>
											<xsl:otherwise>
												<xsl:text>SFString</xsl:text>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:call-template name="javaValue">
										<xsl:with-param name="javadoc"><xsl:text>true</xsl:text></xsl:with-param>
										<xsl:with-param name="x3dType">
											<xsl:value-of select="$x3dType"/>
										</xsl:with-param>
										<xsl:with-param name="schemaValue">
											<xsl:value-of select="@value"/>
										</xsl:with-param>
									</xsl:call-template>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> (Java syntax) or </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:if test="(../@type='MFString')">
										<xsl:text>'</xsl:text>
									</xsl:if>
									<xsl:value-of select="@value"/>
									<xsl:if test="(../@type='MFString')">
										<xsl:text>'</xsl:text>
									</xsl:if>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> (XML syntax).</xsl:text>
                                                                        <xsl:if test="(string-length(@alias) > 0)">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @see #</xsl:text>
                                                                                <xsl:value-of select="upper-case(../@name)"/>
										<xsl:text>_</xsl:text>
										<xsl:value-of select="upper-case(@value)"/><!-- NAME -->
										<xsl:text>_ALIAS </xsl:text>
									</xsl:if>
									<xsl:if test="(string-length(../@simpleType) > 0) and (ends-with(../@simpleType,'Choices') or ends-with(../@simpleType,'Values'))">
										<xsl:text>&#10;</xsl:text>
                                                                                <xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="https://web3d.org/specifications/X3dSchemaDocumentation4.0/x3d-4.0_]]></xsl:text>
										<xsl:value-of select="../@simpleType"/>
										<xsl:text>.html</xsl:text>
                                                                                <xsl:text disable-output-escaping="yes"><![CDATA[">XML Schema: ]]></xsl:text>
										<xsl:value-of select="../@simpleType"/>
                                                                                <xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
									</xsl:if>
									<xsl:if test="(string-length(../@baseType) > 0) and (ends-with(../@baseType,'Choices') or ends-with(../@baseType,'Values'))">
                                                                                <xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="https://web3d.org/specifications/X3dSchemaDocumentation4.0/x3d-4.0_]]></xsl:text>
										<xsl:value-of select="../@baseType"/>
										<xsl:text>.html</xsl:text>
                                                                                <xsl:text disable-output-escaping="yes"><![CDATA[>>XML Schema: ]]></xsl:text>
										<xsl:value-of select="../@baseType"/>
                                                                                <xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:if test="(string-length(normalize-space(@documentation)) > 0)">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @see </xsl:text>
												<xsl:call-template name="wrap-hyperlinks">
													<xsl:with-param name="string">
														<!-- xsl:text> debug: escape-javadoc-characters0 </xsl:text -->
														<xsl:call-template name="escape-javadoc-characters">
															<xsl:with-param name="inputValue">
																<xsl:value-of select="normalize-space(@documentation)" disable-output-escaping="yes"/>
															</xsl:with-param>
														</xsl:call-template>
													</xsl:with-param>
												</xsl:call-template>
									</xsl:if>
									<xsl:text> */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public static final </xsl:text>
									<!-- TODO not all String enumeration constants are final arrays, some are addable elements -->
									<xsl:value-of disable-output-escaping="yes">
										<!-- can include collections, must be escaped -->
										<xsl:call-template name="javaType">
											<xsl:with-param name="x3dType" select="$x3dType"/>
										</xsl:call-template>
									</xsl:value-of>
									<xsl:text> </xsl:text>
									<xsl:value-of select="upper-case($fieldName)"/>
									<xsl:text>_</xsl:text>
									<xsl:variable name="currentAlias" select="@alias"/>
                                                                        <!-- debug
                                                                        <xsl:message>
                                                                            <xsl:text>../@name=</xsl:text>
                                                                            <xsl:value-of select="../@name"/>
                                                                            <xsl:text>, ../@baseType=</xsl:text>
                                                                            <xsl:value-of select="../@baseType"/>
                                                                            <xsl:text>, @alias=</xsl:text>
                                                                            <xsl:value-of select="@alias"/>
                                                                        </xsl:message> -->
                                                                        <xsl:choose>
                                                                            <xsl:when test="(../@baseType = 'SFInt32') and (string-length($currentAlias) > 0)">
                                                                                <xsl:value-of select="upper-case($currentAlias)"/>
                                                                            </xsl:when>
                                                                            <xsl:otherwise>
                                                                                <!-- enumeration name: omit " character, others become _ underscore -->
                                                                                <xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
                                                                            </xsl:otherwise>
                                                                        </xsl:choose>
									<xsl:text> = </xsl:text>
									<xsl:call-template name="javaValue">
										<xsl:with-param name="x3dType">
											<xsl:value-of select="$x3dType"/>
										</xsl:with-param>
										<xsl:with-param name="schemaValue">
											<xsl:value-of select="@value"/>
										</xsl:with-param>
									</xsl:call-template>
									<xsl:text>;</xsl:text>
									<xsl:text>&#10;</xsl:text>

									<!-- additional enumeration attributes (e.g. HAnim index LOA alias parent) originating in XML schema annotation/appinfo -->
									<xsl:if test="(string-length(@index) > 0)">
										<xsl:text>	/** SFString </xsl:text>
										<xsl:value-of select="../@baseType"/>
										<xsl:text> enumeration value </xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="@value"/><!-- name -->
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text> has unique index </xsl:text>
										<xsl:value-of select="@index"/>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @see #NAME_</xsl:text>
										<xsl:value-of select="upper-case(@value)"/><!-- NAME -->
										<xsl:text> */</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	public static final int </xsl:text><!-- type found in XML schema -->
										<xsl:text>NAME_</xsl:text>
										<xsl:value-of select="upper-case(@value)"/><!-- NAME -->
										<xsl:text>_INDEX = </xsl:text>
										<xsl:value-of select="@index"/>
										<xsl:text>;</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:if test="(string-length(@loa) > 0)">
										<xsl:text>	/** SFString </xsl:text>
										<xsl:value-of select="../@baseType"/>
										<xsl:text> enumeration value </xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="@value"/><!-- name -->
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text> has unique Level Of Articulation loa=</xsl:text>
										<xsl:value-of select="@loa"/>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @see #NAME_</xsl:text>
										<xsl:value-of select="upper-case(@value)"/><!-- NAME -->
										<xsl:text> */</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	public static final int </xsl:text><!-- type found in XML schema -->
										<xsl:text>NAME_</xsl:text>
										<xsl:value-of select="upper-case(@value)"/><!-- NAME -->
										<xsl:text>_LOA = </xsl:text>
										<xsl:value-of select="@loa"/>
										<xsl:text>;</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:if test="(string-length(@parent) > 0)">
										<xsl:variable name="parentJavadocObject">
											<xsl:choose>
												<xsl:when test="(../@simpleType = 'hanimJointNameValues')">
													<!-- joint parents are joints -->
													<xsl:text>HAnimJoint</xsl:text>
												</xsl:when>
												<xsl:when test="(../@simpleType = 'hanimSegmentNameValues')">
													<!-- segment parents are joints -->
													<xsl:text>HAnimJoint</xsl:text>
												</xsl:when>
												<xsl:when test="(../@simpleType = 'hanimFeaturePointNameValues')">
													<!-- site parents are segments -->
													<xsl:text>HAnimSegment</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="../@simpleType"/>
													<xsl:message>
														<xsl:text>*** javadoc generation error, unrecognized enumeration constant baseType=</xsl:text>
														<xsl:value-of select="../@baseType"/>
													</xsl:message>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:text>	/** SFString </xsl:text>
										<xsl:value-of select="../@baseType"/>
										<xsl:text> enumeration value </xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="@value"/><!-- name -->
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text> has unique parent </xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="@parent"/>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text> in </xsl:text>
										<xsl:value-of select="$parentJavadocObject"/>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @see #NAME_</xsl:text>
										<xsl:value-of select="upper-case(@value)"/><!-- NAME -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @see </xsl:text>
										<xsl:value-of select="$parentJavadocObject"/>
										<xsl:text>#</xsl:text>
										<xsl:text>NAME_</xsl:text>
										<xsl:value-of select="upper-case(@parent)"/><!-- NAME -->
										<xsl:text> */</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	public static final String </xsl:text><!-- type found in XML schema -->
										<xsl:text>NAME_</xsl:text>
										<xsl:value-of select="upper-case(@value)"/><!-- NAME -->
										<xsl:text>_PARENT = </xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:value-of select="@parent"/>
										<xsl:text>"</xsl:text>
										<xsl:text>;</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:if test="(string-length(@alias) > 0)">
										<xsl:text>	/** SFString </xsl:text>
										<xsl:value-of select="../@baseType"/>
										<xsl:text> enumeration value </xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="@value"/><!-- name -->
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:text> has alias </xsl:text>
										<xsl:if test="contains(@alias,',')">
											<xsl:text> (TODO tokenize array)</xsl:text>
										</xsl:if>
										<xsl:text>"</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="@alias"/>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>"</xsl:text>
                                                                                <xsl:choose>
                                                                                    <xsl:when test="contains(@alias,',')">
                                                                                        <!-- (TODO tokenize array) -->
                                                                                    </xsl:when>
                                                                                    <xsl:when test="(../@baseType = 'SFInt32')">
                                                                                        <!-- special case such as hatchStyleValues -->
                                                                                        <xsl:text>&#10;</xsl:text>
                                                                                        <xsl:text>	 * @see #</xsl:text>
                                                                                        <xsl:value-of select="upper-case($fieldName)"/>
                                                                                        <xsl:text>_</xsl:text>
                                                                                        <xsl:value-of select="upper-case(@alias)"/>
                                                                                    </xsl:when>
                                                                                    <xsl:otherwise>
                                                                                        <xsl:text>&#10;</xsl:text>
                                                                                        <xsl:text>	 * @see #</xsl:text>
                                                                                        <xsl:value-of select="upper-case($fieldName)"/>
                                                                                        <xsl:text>_</xsl:text>
                                                                                        <xsl:value-of select="upper-case(@value)"/><!-- NAME -->
                                                                                    </xsl:otherwise>
                                                                                </xsl:choose>
										<xsl:text> */</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	public static final String </xsl:text><!-- type found in XML schema -->
										<xsl:value-of select="upper-case($fieldName)"/>
										<xsl:text>_</xsl:text>
										<xsl:value-of select="upper-case(@value)"/><!-- NAME -->
										<xsl:text>_ALIAS = </xsl:text>
										<xsl:text>"</xsl:text>
										<xsl:value-of select="@alias"/>
										<xsl:text>"</xsl:text>
										<xsl:text>;</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
								</xsl:for-each><!-- enumeration -->

								<!-- utility methods for special enumerations -->

								<xsl:if test="enumeration[(string-length(@index) > 0) or (string-length(@alias) > 0) or (string-length(@loa) > 0) or (string-length(@parent) > 0)]">
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	// special enumeration utility methods</xsl:text>
									<xsl:text>&#10;</xsl:text>
                                                                        <xsl:if test="starts-with($name, 'HAnim') and (@name = 'name')">
                                                                                <xsl:text>
        String  namingMessage = new String();
        boolean namingMessageAlreadyProvided = false;
</xsl:text>
                                                                        </xsl:if>
								</xsl:if>
								<xsl:for-each select="enumeration[(string-length(@index) > 0)]">
									<xsl:variable name="enumerationName" select="@value"/>
                                                                        <xsl:variable name="typeName">
                                                                            <xsl:choose>
                                                                                <xsl:when test="(string-length(../@name) > 0)">
                                                                                     <xsl:value-of select="../@name"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(string-length(../@simpleType) > 0)">
                                                                                     <xsl:value-of select="substring-before(../@simpleType,'Values')"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(../@baseType = 'SFInt32')">
                                                                                     <xsl:value-of select="@alias"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(string-length(../@baseType) > 0)">
                                                                                     <xsl:value-of select="substring-before(../@baseType,'Values')"/>
                                                                                </xsl:when>
                                                                                <xsl:otherwise>
                                                                                    <xsl:message>
                                                                                        <xsl:text>[warning] typeName not found, $enumerationName=</xsl:text>
                                                                                         <xsl:value-of select="$enumerationName"/>
                                                                                        <xsl:text> @alias=</xsl:text>
                                                                                         <xsl:value-of select="@alias"/>
                                                                                    </xsl:message>
                                                                                </xsl:otherwise>
                                                                            </xsl:choose>
                                                                        </xsl:variable>
									<xsl:variable name="suffixName">
										<xsl:value-of select="upper-case(substring($typeName,1,1))"/>
										<xsl:value-of select="substring($typeName,2)"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="position()=1">
											<xsl:text>
	/** Get index for this </xsl:text><xsl:value-of select="$typeName"/><xsl:text>
	 * @param </xsl:text><xsl:value-of select="$typeName"/><xsl:text> of interest
	 * @return index value, otherwise -1 if not found
	 */
	public static int get</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>Index(String </xsl:text><xsl:value-of select="$typeName"/><xsl:text>)
	{
		if      </xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>		else if </xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text><xsl:value-of select="$typeName"/><xsl:text>.equalsIgnoreCase(NAME_</xsl:text>
									<xsl:value-of select="upper-case($enumerationName)"/>
									<xsl:text>)) return NAME_</xsl:text>
									<xsl:value-of select="upper-case($enumerationName)"/>
									<xsl:text>_INDEX;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="position()=last()">
										<xsl:text>		else return -1; // not found
	}
	/** Whether an index exists for this </xsl:text><xsl:value-of select="$typeName"/><xsl:text>
	 * @param </xsl:text><xsl:value-of select="$typeName"/><xsl:text> of interest
	 * @return true if found
	 */
	public static boolean has</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>Index(String </xsl:text><xsl:value-of select="$typeName"/><xsl:text>)
	{
		return (get</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>Index(</xsl:text><xsl:value-of select="$typeName"/><xsl:text>) > -1);
	}
</xsl:text>
									</xsl:if>
								</xsl:for-each> <!-- enumeration with index -->

								<xsl:for-each select="enumeration[(string-length(@loa) > 0)]">
									<xsl:variable name="enumerationName" select="@value"/>
                                                                        <xsl:variable name="typeName">
                                                                            <xsl:choose>
                                                                                <xsl:when test="(string-length(../@name) > 0)">
                                                                                     <xsl:value-of select="../@name"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(string-length(../@simpleType) > 0)">
                                                                                     <xsl:value-of select="substring-before(../@simpleType,'Values')"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(../@baseType = 'SFInt32')">
                                                                                     <xsl:value-of select="@alias"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(string-length(../@baseType) > 0)">
                                                                                     <xsl:value-of select="substring-before(../@baseType,'Values')"/>
                                                                                </xsl:when>
                                                                                <xsl:otherwise>
                                                                                    <xsl:message>
                                                                                        <xsl:text>[warning] typeName not found, $enumerationName=</xsl:text>
                                                                                         <xsl:value-of select="$enumerationName"/>
                                                                                        <xsl:text> @alias=</xsl:text>
                                                                                         <xsl:value-of select="@alias"/>
                                                                                    </xsl:message>
                                                                                </xsl:otherwise>
                                                                            </xsl:choose>
                                                                        </xsl:variable>
									<xsl:variable name="suffixName">
										<xsl:value-of select="upper-case(substring($typeName,1,1))"/>
										<xsl:value-of select="substring($typeName,2)"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="position()=1">
											<xsl:text>
	/** Get Level of Articulation (loa) for this </xsl:text><xsl:value-of select="$typeName"/><xsl:text>
	 * @param </xsl:text><xsl:value-of select="$typeName"/><xsl:text> of interest
	 * @return loa value, otherwise -1 if not found
	 */
	public static int get</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>Loa(String </xsl:text><xsl:value-of select="$typeName"/><xsl:text>)
	{
		if      </xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>		else if </xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text><xsl:value-of select="$typeName"/><xsl:text>.equalsIgnoreCase(NAME_</xsl:text>
									<xsl:value-of select="upper-case($enumerationName)"/>
									<xsl:text>)) return NAME_</xsl:text>
									<xsl:value-of select="upper-case($enumerationName)"/>
									<xsl:text>_LOA;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="position()=last()">
										<xsl:text>		else return -1; // not found
	}
	/** Whether an loa exists for this </xsl:text><xsl:value-of select="$typeName"/><xsl:text>
	 * @param </xsl:text><xsl:value-of select="$typeName"/><xsl:text> of interest
	 * @return true if found
	 */
	public static boolean has</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>Loa(String </xsl:text><xsl:value-of select="$typeName"/><xsl:text>)
	{
		return (get</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>Loa(</xsl:text><xsl:value-of select="$typeName"/><xsl:text>) > -1);
	}
</xsl:text>
									</xsl:if>
								</xsl:for-each> <!-- enumeration with loa -->
<xsl:if test="not(@baseType = 'SFInt32')">
    <!-- TODO need to use alias, numeric enumerations are still a problem -->
								<xsl:for-each select="enumeration[(string-length(@alias) > 0)]">
									<xsl:variable name="enumerationName" select="@value"/>
                                                                        <xsl:variable name="typeName">
                                                                            <xsl:choose>
                                                                                <xsl:when test="(string-length(../@name) > 0)">
                                                                                     <xsl:value-of select="../@name"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(string-length(../@simpleType) > 0)">
                                                                                     <xsl:value-of select="substring-before(../@simpleType,'Values')"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(../@baseType = 'SFInt32')">
                                                                                     <xsl:value-of select="@alias"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(string-length(../@baseType) > 0)">
                                                                                     <xsl:value-of select="substring-before(../@baseType,'Values')"/>
                                                                                </xsl:when>
                                                                                <xsl:otherwise>
                                                                                    <xsl:message>
                                                                                        <xsl:text>[warning] typeName not found, $enumerationName=</xsl:text>
                                                                                         <xsl:value-of select="$enumerationName"/>
                                                                                        <xsl:text> @alias=</xsl:text>
                                                                                         <xsl:value-of select="@alias"/>
                                                                                    </xsl:message>
                                                                                </xsl:otherwise>
                                                                            </xsl:choose>
                                                                        </xsl:variable>
									<xsl:variable name="suffixName">
										<xsl:value-of select="upper-case(substring($typeName,1,1))"/>
										<xsl:value-of select="substring($typeName,2)"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="position()=1">
											<xsl:text>
	/** Get alias for this </xsl:text><xsl:value-of select="$typeName"/><xsl:text>
	 * @param </xsl:text><xsl:value-of select="$typeName"/><xsl:text>Value of interest
	 * @return alias value, otherwise empty string if not found
	 */
	public static String get</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>Alias(String </xsl:text><xsl:value-of select="$typeName"/><xsl:text>Value)
	{
		if      </xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>		else if </xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text><xsl:value-of select="$typeName"/><xsl:text>Value.equalsIgnoreCase(</xsl:text>
                                                                        <xsl:value-of select="upper-case(../@name)"/>
									<xsl:text>_</xsl:text>
									<xsl:value-of select="upper-case($enumerationName)"/>
									<xsl:text>)) return </xsl:text>
                                                                        <xsl:value-of select="upper-case(../@name)"/>
									<xsl:text>_</xsl:text>
									<xsl:value-of select="upper-case($enumerationName)"/>
									<xsl:text>_ALIAS;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="position()=last()">
										<xsl:text>		else return ""; // not found
	}
	/** Whether a alias exists for this </xsl:text><xsl:value-of select="$typeName"/><xsl:text>
	 * @param </xsl:text><xsl:value-of select="$typeName"/><xsl:text> of interest
	 * @return true if found
	 */
	public static boolean has</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>Alias(String </xsl:text><xsl:value-of select="$typeName"/><xsl:text>)
	{
		return !get</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>Alias(</xsl:text><xsl:value-of select="$typeName"/><xsl:text>).isEmpty();
	}
</xsl:text>
									</xsl:if>
								</xsl:for-each> <!-- enumeration with alias -->
</xsl:if>

								<xsl:for-each select="enumeration[(string-length(@parent) > 0)]">
									<xsl:variable name="enumerationName" select="@value"/>
                                                                        <xsl:variable name="typeName">
                                                                            <xsl:choose>
                                                                                <xsl:when test="(string-length(../@name) > 0)">
                                                                                     <xsl:value-of select="../@name"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(string-length(../@simpleType) > 0)">
                                                                                     <xsl:value-of select="substring-before(../@simpleType,'Values')"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(../@baseType = 'SFInt32')">
                                                                                     <xsl:value-of select="@alias"/>
                                                                                </xsl:when>
                                                                                <xsl:when test="(string-length(../@baseType) > 0)">
                                                                                     <xsl:value-of select="substring-before(../@baseType,'Values')"/>
                                                                                </xsl:when>
                                                                                <xsl:otherwise>
                                                                                    <xsl:message>
                                                                                        <xsl:text>[warning] typeName not found, $enumerationName=</xsl:text>
                                                                                         <xsl:value-of select="$enumerationName"/>
                                                                                        <xsl:text> @alias=</xsl:text>
                                                                                         <xsl:value-of select="@alias"/>
                                                                                    </xsl:message>
                                                                                </xsl:otherwise>
                                                                            </xsl:choose>
                                                                        </xsl:variable>
									<xsl:variable name="suffixName">
										<xsl:value-of select="upper-case(substring($typeName,1,1))"/>
										<xsl:value-of select="substring($typeName,2)"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="position()=1">
											<xsl:text>
	/** Get parent for this </xsl:text><xsl:value-of select="$typeName"/><xsl:text>
	 * @param </xsl:text><xsl:value-of select="$typeName"/><xsl:text> of interest
	 * @return parent value, otherwise empty string if not found
	 */
	public static String getParent</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>(String </xsl:text><xsl:value-of select="$typeName"/><xsl:text>)
	{
		if      </xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>		else if </xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text><xsl:value-of select="$typeName"/><xsl:text>.equalsIgnoreCase(</xsl:text>
                                                                        <xsl:value-of select="upper-case(../@name)"/>
									<xsl:text>_</xsl:text>
									<xsl:value-of select="upper-case($enumerationName)"/>
									<xsl:text>)) return </xsl:text>
                                                                        <xsl:value-of select="upper-case(../@name)"/>
									<xsl:text>_</xsl:text>
									<xsl:value-of select="upper-case($enumerationName)"/>
									<xsl:text>_PARENT;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="position()=last()">
										<xsl:text>		else return ""; // not found
	}
	/** Whether a parent exists for this </xsl:text><xsl:value-of select="$typeName"/><xsl:text>
	 * @param </xsl:text><xsl:value-of select="$typeName"/><xsl:text> of interest
	 * @return true if found
	 */
	public static boolean hasParentMatchingName(String </xsl:text><xsl:value-of select="$typeName"/><xsl:text>)
	{
		return !getParent</xsl:text><xsl:value-of select="$suffixName"/><xsl:text>(</xsl:text><xsl:value-of select="$typeName"/><xsl:text>).isEmpty();
	}
</xsl:text>
									</xsl:if>
								</xsl:for-each> <!-- enumeration with parent -->
							</xsl:for-each>     <!-- InterfaceDefinition/field -->

							<xsl:if test="not($isInterface = 'true') and not($isUtilityClass = 'true')">
								<xsl:choose>
									<xsl:when test="($name = 'X3DConcreteElement')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>NAME</i> provides name of this element; overridden by implementing class. */
	protected static final String NAME = ""; // must be overridden
]]></xsl:text>
									</xsl:when>
									<xsl:when test="starts-with($name, 'X3DConcrete')">
										<!-- do not re-declare NAME, let class definition provide override -->
									</xsl:when>
									<xsl:when test="($name = 'ConfigurationProperties')">
										<!-- do not re-declare NAME, let class definition provide override -->
									</xsl:when>
									<xsl:otherwise>
                                                                            <xsl:text>&#10;</xsl:text>
                                                                            <xsl:text>	// String constants for default field values match X3D Schema definitions</xsl:text>
                                                                            <xsl:text>&#10;</xsl:text>
                                                                            <xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>NAME</i> provides name of this element: <i>]]></xsl:text>
										<xsl:value-of select="@name"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[</i>. */
	@SuppressWarnings("FieldNameHidesFieldInSuperclass")
	public static final String NAME = "]]></xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text><![CDATA[";

	/** Provides name of this element: <i>]]></xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text><![CDATA[</i>
	 * @return name of this element
	 */
	@Override
	public final String getElementName()
	{
		return NAME;
	}
]]></xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>COMPONENT</i> defines X3D component for the <i>]]></xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text><![CDATA[</i> element: <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[</i> */
	public static final String COMPONENT = "]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
			<xsl:text><![CDATA[";

	/** Defines X3D component for the <i>]]></xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text><![CDATA[</i> element: <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
			<xsl:text><![CDATA[</i>
	 * @return X3D component for this element
	 */
	/* @Override */
	public final String getComponent()
	{
		return COMPONENT;
	}
]]></xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Integer constant <i>LEVEL</i> provides default X3D <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
			<xsl:text><![CDATA[</i> component level for this element: <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[</i> */
	public static final int LEVEL = ]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:text><![CDATA[;

	/** Provides default X3D component level for this element: <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:text><![CDATA[</i>
	 * @return default X3D component level for this element
	 */
	/* @Override */
	public final int getComponentLevel()
	{
		return LEVEL;
	}
]]></xsl:text>
									</xsl:otherwise>
								</xsl:choose>
								</xsl:if>

                            <xsl:text>
            // DEFAULT_VALUE declarations
</xsl:text>

							<!-- Source code: _DEFAULT_VALUE declarations -->
                            <xsl:for-each select="InterfaceDefinition/field[((@type='SFString') or (@type='MFString') or (string-length(normalize-space(@default)) > 0)) and
                                                  (@type = 'xs:string') or starts-with(@type,'xs:NMTOKEN') or (@type = 'xs:token') or starts-with(@type,'xs:ID') or
                                                  not(@type='MFNode') and
                                                  not(@name = 'DEF') and not(@name = 'USE') and not(@name = 'id') and not(@name = 'class') and not((@name = 'style') and not(ends-with($name, 'FontStyle')))]
                                                  [(@accessType='initializeOnly') or (@accessType='inputOutput')]">
    <!-- not(@type='SFNode') and -->
                                <xsl:variable name="fieldName" select="translate(@name,'-','_')"/>
                                <!-- avoid erroneously duplicated fields in X3DUOM -->
                                <xsl:choose>
                                    <!-- filter unwanted duplicates from X3DUOM -->
                                    <xsl:when test="(count(preceding-sibling::*[@type = 'SFNode'][translate(@name,'-','_') = $fieldName]) > 0)">
                                        <xsl:message>
                                            <xsl:text>[warning] duplicate field definition found, </xsl:text>
                                            <xsl:value-of select="$name"/><!-- element -->
                                            <xsl:text> </xsl:text>
                                            <xsl:value-of select="@name"/>
                                            <xsl:text>, count=</xsl:text>
                                            <xsl:value-of select="count(preceding-sibling::*[@type = 'SFNode'][translate(@name,'-','_') = $fieldName])"/>
                                        </xsl:message>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:variable name="isX3dStatement">
                                            <xsl:call-template name="isX3dStatement">
                                                <xsl:with-param name="name" select="@name"/>
                                            </xsl:call-template>
                                        </xsl:variable>

                                        <xsl:variable name="defaultValue">
                                            <xsl:value-of select="@default"/>
                                        </xsl:variable>

                                        <xsl:text>&#10;</xsl:text>
                                        <xsl:text>	/** </xsl:text>
                                        <xsl:if test="($name = 'field') and ((@name = 'type') or (@name = 'accessType'))">
                                            <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
                                            <xsl:text>Initial value is required to be set for validity:</xsl:text>
                                            <xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
                                            <xsl:text> </xsl:text>
                                        </xsl:if>
                                        <xsl:value-of select="@type"/>
                                        <xsl:text> field named </xsl:text>
                                        <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
                                        <xsl:value-of select="$fieldName"/>
                                        <xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
                                        <xsl:text> has default </xsl:text>
                                        <xsl:choose>
                                            <xsl:when test="(string-length($defaultValue) > 0)">
                                                <xsl:if test="(@type = 'MFString')">
                                                    <xsl:text>quoted </xsl:text>
                                                </xsl:if>
                                                <xsl:text>value </xsl:text>
                                                <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
                                                <xsl:call-template name="javaValue">
                                                    <xsl:with-param name="javadoc"><xsl:text>true</xsl:text></xsl:with-param>
                                                    <xsl:with-param name="x3dType">
                                                        <xsl:value-of select="@type"/>
                                                    </xsl:with-param>
                                                    <xsl:with-param name="schemaValue">
                                                        <xsl:value-of select="$defaultValue"/>
                                                    </xsl:with-param>
                                                </xsl:call-template>
                                                <xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
                                                <xsl:text> (Java syntax) or </xsl:text>
                                                <xsl:if test="(@type = 'MFString')">
                                                    <xsl:text>quoted value </xsl:text>
                                                </xsl:if>
                                                <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
                                                <xsl:value-of select="$defaultValue"/>
                                                <xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
                                                <xsl:text> (XML syntax)</xsl:text>
                                            </xsl:when>
                                            <xsl:when test="starts-with(@type, 'MF')">
                                                <xsl:text>value equal to an empty list</xsl:text>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:text>value equal to an empty string</xsl:text>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text>. </xsl:text>
                                        <xsl:text>*/</xsl:text><!-- end javadoc -->
                                        <xsl:text>&#10;</xsl:text>
                                        <xsl:text>	public static final </xsl:text>
                                        <xsl:variable name="javaType">
                                            <!-- can include collections, must be escaped -->
                                            <xsl:call-template name="javaType">
                                                <xsl:with-param name="x3dType" select="@type"/>
                                                <xsl:with-param name="isInterface" select="$isInterface"/>
                                            </xsl:call-template>
                                        </xsl:variable>
                                        <xsl:variable name="saiPackagePath">
                                            <xsl:call-template name="saiPackage">
                                                <xsl:with-param name="nodeType" select="$javaType"/>
                                            </xsl:call-template>
                                        </xsl:variable>
                                        <xsl:choose>
                                            <xsl:when test="(string-length($saiPackagePath) > 0)">
                                                <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 11a */</xsl:text></xsl:if>
                                                <xsl:value-of select="$saiPackagePath"/>
                                                <xsl:text>.</xsl:text>
                                                <xsl:value-of select="$javaType" disable-output-escaping="yes"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 11b, saiPackage not found */</xsl:text></xsl:if>
                                                <xsl:value-of select="$javaType" disable-output-escaping="yes"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text> </xsl:text>
                                        <xsl:value-of select="upper-case($fieldName)"/>
                                        <xsl:text>_DEFAULT_VALUE</xsl:text>
                                        <xsl:text> = </xsl:text>
                                        <xsl:call-template name="javaValue">
                                            <xsl:with-param name="x3dType">
                                                <xsl:value-of select="@type"/>
                                            </xsl:with-param>
                                            <xsl:with-param name="schemaValue">
                                                <xsl:value-of select="$defaultValue"/>
                                            </xsl:with-param>
                                        </xsl:call-template>
                                        <xsl:text>;</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:for-each>

							<xsl:variable name="isX3dStatement">
								<xsl:call-template name="isX3dStatement">
									<xsl:with-param name="name" select="@name"/>
								</xsl:call-template>
							</xsl:variable>

							<xsl:if test="InterfaceDefinition/field[((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove'))]">
								<!-- Source code: getFieldType -->
								<xsl:text disable-output-escaping="yes">
	/** Indicate type corresponding to given fieldName.
	 * @param fieldName name of field in this X3D </xsl:text>
								<xsl:choose>
								   <xsl:when test="($isX3dStatement = 'true')">
									   <xsl:text>statement</xsl:text>
								   </xsl:when>
								   <xsl:otherwise>
									   <xsl:text>node</xsl:text>
								   </xsl:otherwise>
								</xsl:choose>
								<xsl:text disable-output-escaping="yes">
	 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_TYPE
	 * @return X3D type (SFvec3f etc.), otherwise ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE if not recognized
	 */
	/* @Override */
	public String getFieldType(String fieldName)
	{
		String result;

		switch (fieldName)
		{</xsl:text>
								<xsl:for-each select="InterfaceDefinition/field"> <!-- [((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove'))] -->
									<xsl:if test="position()=1">
										<xsl:text>
			// String constants for exact field type values matching X3D Schema definitions,
			// thus avoiding spelling errors and allowing type-matching checks

			case "containerField":
				result = "SFString";
				break;</xsl:text>
									</xsl:if>
									<xsl:variable name="fieldName">
										<xsl:choose>
											<xsl:when test="starts-with(@name,'set_')">
												<xsl:value-of select="translate(substring-after(@name,'set_'),'-','_')"/>
											</xsl:when>
											<xsl:when test="ends-with(@name,'_changed')">
												<xsl:value-of select="translate(substring-before(@name,'_changed'),'-','_')"/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="translate(@name,'-','_')"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:variable name="fieldType">
                                                                            <xsl:choose>
                                                                                <xsl:when test="(@type = 'xs:NMTOKEN')">
                                                                                    <xsl:text>SFString</xsl:text>
                                                                                </xsl:when>
                                                                                <xsl:otherwise>
                                                                                    <xsl:value-of select="@type"/>
                                                                                </xsl:otherwise>
                                                                            </xsl:choose>

									</xsl:variable>
									<xsl:variable name="hasPrecedingFieldDefinition">
										<!-- example: ParticleSystem has 'geometry' field annotation overriding Shape node -->
										<xsl:value-of select="(count(preceding-sibling::*[(@name = $fieldName) or (@name = concat('set_',$fieldName)) or (@name = concat($fieldName,'_changed'))]) > 0)"/>
									</xsl:variable>
									<xsl:if test="not($hasPrecedingFieldDefinition = 'true')">
										<xsl:text>
			case "</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>":
				result = "</xsl:text><xsl:value-of select="$fieldType"/><xsl:text>";
				break;</xsl:text>
									</xsl:if>
								</xsl:for-each>
									<xsl:text disable-output-escaping="yes">
			default:
			{
				// if fieldName has a prefix "set_" prepended (or a suffix "_changed" appended) then try again by stripping it and recursing once
				if      (fieldName.trim().startsWith("set_"))
						 result = getFieldType(fieldName.trim().substring(4)); // after "set_"
				else if (fieldName.trim().endsWith("_changed"))
						 result = getFieldType(fieldName.trim().substring(0, fieldName.length() - 8)); // before "_changed"
				else     result = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE; // unique return value avoids mistaken matches
			}
		}
</xsl:text>
								<!-- now check special-case fields -->
								<xsl:choose>
									<xsl:when test="($name = 'ProtoDeclare')  or ($name = 'ExternProtoDeclare') or ($name = 'Script') or
													($name = 'ShaderProgram') or ($name = 'ComposedShader')     or ($name = 'PackagedShader')">
										<xsl:text>		// now check author-defined fields
		field</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> fieldDeclaration = this.findFieldByName(fieldName);
		if (fieldDeclaration != null)
			result = fieldDeclaration.getType(); // found it!
</xsl:text>
									</xsl:when>
									<xsl:when test="($name = 'ProtoInstance')">
										<xsl:text>		// now check author-defined fields
		field</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> fieldDeclaration = null;
		if      (      hasProtoDeclare())
			fieldDeclaration =       referenceProtoDeclare.findFieldByName(fieldName);
		else if (hasExternProtoDeclare())
			fieldDeclaration = referenceExternProtoDeclare.findFieldByName(fieldName);
		if (fieldDeclaration != null)
			result = fieldDeclaration.getType(); // found it!
</xsl:text>
									</xsl:when>
								</xsl:choose>
								<xsl:text>		return result;
	}
</xsl:text>
								<!-- Source code: getAccessType -->
								<xsl:text disable-output-escaping="yes">
	/** Indicate accessType corresponding to given fieldName.
	 * @param fieldName name of field in this X3D </xsl:text>
								<xsl:choose>
								   <xsl:when test="($isX3dStatement = 'true')">
									   <xsl:text>statement</xsl:text>
								   </xsl:when>
								   <xsl:otherwise>
									   <xsl:text>node</xsl:text>
								   </xsl:otherwise>
								</xsl:choose>
								<xsl:text disable-output-escaping="yes">
	 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_ACCESSTYPE
	 * @return X3D accessType (inputOnly etc.), otherwise ConfigurationProperties.ERROR_UNKNOWN_FIELD_ACCESSTYPE if not recognized
	 */
	/* @Override */
	public String getAccessType(String fieldName)
	{
		String result; // set by following checks
		switch (fieldName)
		{</xsl:text>
								<xsl:for-each select="InterfaceDefinition/field"><!-- [((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove'))] -->
									<xsl:if test="position()=1">
										<xsl:text>
			// String constants for field accessType values matching X3D Schema definitions,
			// thus avoiding spelling errors and allowing accessType-matching checks</xsl:text>
									</xsl:if>
									<xsl:variable name="fieldName" select="translate(@name,'-','_')"/>
									<xsl:variable name="hasPrecedingFieldDefinition">
										<!-- only example: ParticleSystem has 'geometry' field annotation overriding Shape node -->
										<!-- otherwise ignore preceding field definitions since each field variation (set_ or _changed or plain name) has different accessType -->
										<xsl:value-of select="($name = 'ParticleSystem') and ($fieldName = 'geometry') and (count(preceding-sibling::*[@name = $fieldName]) > 0)"/>
									</xsl:variable>
									<xsl:if test="not($hasPrecedingFieldDefinition = 'true') and
                                                  not(contains($name, 'FontStyle') and ($fieldName = 'style'))"> <!-- overloaded with CSS style -->
										<xsl:text>
			case "</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>":
				result = "</xsl:text><xsl:value-of select="@accessType"/><xsl:text>";
				break;</xsl:text>
									</xsl:if>
								</xsl:for-each>
								<xsl:text disable-output-escaping="yes">
			default:
			{
				// if user has added a prefix "set_" or suffix "_changed" then try again by stripping it and recursing once
				if      (fieldName.trim().startsWith("set_"))
						 result = getAccessType(fieldName.trim().substring(4)); // after "set_"
				else if (fieldName.trim().endsWith("_changed"))
						 result = getAccessType(fieldName.trim().substring(0, fieldName.length() - 8)); // before "_changed"
				else     result = ConfigurationProperties.ERROR_UNKNOWN_FIELD_ACCESSTYPE; // unique return value avoids mistaken matches
			}
		}
</xsl:text>
								<!-- now check special-case fields -->
								<xsl:choose>
									<xsl:when test="($name = 'ProtoDeclare')  or ($name = 'ExternProtoDeclare') or ($name = 'Script') or
													($name = 'ShaderProgram') or ($name = 'ComposedShader')     or ($name = 'PackagedShader')">
										<xsl:text>		// now check author-defined fields
		field</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> fieldDeclaration = this.findFieldByName(fieldName);
		if (fieldDeclaration != null)
			result = fieldDeclaration.getAccessType(); // found it!
</xsl:text>
									</xsl:when>
									<xsl:when test="($name = 'ProtoInstance')">
										<xsl:text>		// now check author-defined fields
		field</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> fieldDeclaration = null;
		if      (       hasProtoDeclare())
			fieldDeclaration =       referenceProtoDeclare.findFieldByName(fieldName);
		else if (hasExternProtoDeclare())
			fieldDeclaration = referenceExternProtoDeclare.findFieldByName(fieldName);
		if (fieldDeclaration != null)
			result = fieldDeclaration.getAccessType(); // found it!
</xsl:text>
									</xsl:when>
								</xsl:choose>

									<xsl:text>		return result;
	}
</xsl:text>
							</xsl:if> <!-- end getType(fieldName), getAccessType(fieldName) -->
							<!-- handled by X3DUOM
                                                        <xsl:if test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ShaderPart')">
								<xsl:text>
	/** Contained plain-text source code */
	private String SOURCECODE_DEFAULT_VALUE = "";
								</xsl:text>
							</xsl:if>
                                                        -->
							<!-- containerField defaults and methods -->
							<xsl:variable name="containerFieldDefaultType" select="InterfaceDefinition/containerField/@type"/>
                                                        <xsl:variable name="containerFieldAllowedValues">
                                                            <!-- TODO once recorded in X3D XML Schema and X3D Object Model, iterate over values and add to array -->
                                                            <xsl:choose>
                                                                    <xsl:when test="(string-length($containerFieldDefaultType) > 0) and //simpleType[@name=$containerFieldDefaultType]">
                                                                        <xsl:message>
                                                                            <xsl:text>[warning] found containerFieldDefaultType=</xsl:text>
                                                                            <xsl:value-of select="$containerFieldDefaultType"/>
                                                                        </xsl:message>
                                                                        <xsl:for-each select="enumeration">
                                                                            <xsl:text>, "</xsl:text>
                                                                            <xsl:value-of select="@value"/>
                                                                            <xsl:text>"</xsl:text>
                                                                            <xsl:if test="(string-length(@appinfo) > 0)">
                                                                               <xsl:text> // </xsl:text>
                                                                               <xsl:value-of select="@appinfo"/>
                                                                               <xsl:text>&#10;</xsl:text>
                                                                            </xsl:if>
                                                                        </xsl:for-each>
                                                                    </xsl:when>
                                                                    <!-- manually customized code follows, might still have some omissions, see various containerFieldChoices* in X3DUOM -->
                                                                    <xsl:when test="starts-with($name,'Coordinate') or starts-with($name,'CoordinateDouble')">
                                                                            <xsl:text>, "skinCoord", "skinBindingCoords" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="($name = 'Normal')">
                                                                            <xsl:text>, "skinNormal", "skinBindingNormal" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="($name = 'Shape')">
                                                                            <xsl:text>, "proxy" /*Collision parent*/, "shape", "rootNode" /*GeoLOD parent*/, "skin" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="($name = 'LOD') or ($name = 'Transform')">
                                                                            <xsl:text>, "proxy" /*Collision parent*/, "shape"/*CADFace or CollidableShape parent*/, "skin" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="($name = 'Group')">
                                                                            <!-- debatable whether support is appropriate for a few other X3DGroupingNode nodes -->
                                                                            <xsl:text>, "proxy" /*Collision parent*/, "skin" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="($name = 'IndexedFaceSet') or ($name = 'IndexedLineSet')     or ($name = 'IndexedFanSet') or
                                                                                    ($name = 'IndexedQuadSet') or ($name = 'IndexedTriangleSet') or ($name = 'IndexedTriangleStripSet')">
                                                                            <!-- debatable whether support is appropriate for a few other X3DGroupingNode nodes -->
                                                                            <xsl:text>, "skin" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="($name = 'StaticGroup') or ($name = 'Collision')   or
                                                                                    ($name = 'Anchor')      or ($name = 'Billboard')   or ($name = 'CADAssembly') or
                                                                                    ($name = 'CADLayer')    or ($name = 'CADPart')     or ($name = 'Switch')">
                                                                            <!-- debatable whether support is appropriate for a few other X3DGroupingNode nodes -->
                                                                            <xsl:text>, "proxy" /*Collision parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="($name = 'ImageTexture') or ($name = 'PixelTexture')">
                                                                            <xsl:text>, "back",        "bottom",        "front",        "left",        "right",        "top"</xsl:text>
                                                                            <xsl:text>, "backTexture", "bottomTexture", "frontTexture", "leftTexture", "rightTexture", "topTexture"</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="starts-with($name,'Metadata') and starts-with(//X3dUnifiedObjectModel/@version, '4')">
                                                                            <!-- X3D version 4 default -->
                                                                            <xsl:text>, "metadata" /*any node parent, X3D3 default**/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="starts-with($name,'Metadata')">
                                                                            <!-- X3D version 3 default -->
                                                                            <xsl:text>, "value" /*MetadataSet parent, X3D4 default*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="($name = 'MovieTexture')">
                                                                            <xsl:text>, "source" /*Sound parent*/</xsl:text>
                                                                            <!-- X3D3 synonyms for X3D4 field regularization -->
                                                                            <xsl:text>, "back",        "bottom",        "front",        "left",        "right",        "top"</xsl:text>
                                                                            <xsl:text>, "backTexture", "bottomTexture", "frontTexture", "leftTexture", "rightTexture", "topTexture"</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="starts-with($name,'DISEntityTypeMapping')">
                                                                            <xsl:text>, "mapping"</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="starts-with($name,'HAnimDisplacer')">
                                                                            <xsl:text>, "displacers" /*HAnimJoint or HAnimSegment parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="starts-with($name,'HAnimJoint')">
                                                                            <xsl:text>, "joints" /*HAnimHumanoid parent*/, "skeleton" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="starts-with($name,'HAnimSegment')">
                                                                            <xsl:text>, "segments" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="starts-with($name,'HAnimSite')">
                                                                            <xsl:text>, "sites" /*HAnimHumanoid parent*/, "skeleton" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="starts-with($name,'HAnimMotion')">
                                                                            <xsl:text>, "motions" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                                    <xsl:when test="starts-with($name,'HAnimMotion')">
                                                                            <xsl:text>, "motions" /*HAnimHumanoid parent*/</xsl:text>
                                                                    </xsl:when>
                                                            </xsl:choose>
                                                            <!-- X3DUrlObject nodes can also be a child of LoadSensor -->
                                                            <xsl:if test="($name = 'Anchor')              or ($name = 'AudioClip')      or ($name = 'DISEntityTypeMapping') or ($name = 'GeoMetadata') or
                                                                          ($name = 'ImageCubeMapTexture') or ($name = 'ImageTexture3D') or ($name = 'ImageTexture')         or ($name = 'Inline') or
                                                                          ($name = 'MovieTexture')        or ($name = 'PackagedShader') or ($name = 'Script')               or ($name = 'ShaderPart') or
                                                                          ($name = 'ShaderProgram')">
                                                                    <xsl:text>, "children"</xsl:text><!-- formerly watchList in X3D3 -->
                                                            </xsl:if>
                                                            <xsl:text> };</xsl:text>
                                                            <xsl:if test="(string-length(InterfaceDefinition/containerField/@type) > 0)">
                                                                    <xsl:text> // type </xsl:text>
                                                                    <xsl:if test="starts-with(InterfaceDefinition/containerField/@type,'containerField')">
                                                                        <xsl:text>X3DUOM </xsl:text>
                                                                    </xsl:if>
                                                                    <xsl:value-of select="InterfaceDefinition/containerField/@type"/>
                                                            </xsl:if>
                                                        </xsl:variable>
							<xsl:if test="(string-length(InterfaceDefinition/containerField/@default) > 0)">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
         * containerField describes typical field relationship of a node to its parent.
	 * Usage is not ordinarily needed when using this API, this default value is provided for informational purposes only.
         * <br />
         * containerField_DEFAULT_VALUE = "]]></xsl:text>
								<xsl:value-of select="InterfaceDefinition/containerField/@default"/>
								<xsl:text disable-output-escaping="yes"><![CDATA[";
         * <br />
         * containerField_ALLOWED_VALUES = {"]]></xsl:text>
								<xsl:value-of select="InterfaceDefinition/containerField/@default"/>
                                                                <xsl:text>"</xsl:text>
                                                                <!-- replace Java contained-comment characters within javadoc -->
                                                                <xsl:value-of select='replace($containerFieldAllowedValues, "/", "")'/>

								<xsl:if test="(string-length(InterfaceDefinition/containerField/@type) > 0)">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerFieldChoices" target="_blank">X3D Scene Authoring Hints: validation choices for containerField</a>
	 * @see <a href="https://www.web3d.org/specifications/X3DUOM.html" target="_blank">X3D Unified Object Model (X3DUOM)</a>]]></xsl:text>
								</xsl:if>
								<xsl:text>
	 */

	public static final String containerField_DEFAULT_VALUE = "</xsl:text>
								<xsl:value-of select="InterfaceDefinition/containerField/@default"/>
								<xsl:text>";</xsl:text>
								<xsl:if test="(string-length(InterfaceDefinition/containerField/@type) > 0)">
									<xsl:text> // type </xsl:text>
									<xsl:value-of select="InterfaceDefinition/containerField/@type"/>
								</xsl:if>
								<xsl:text>
	/**
         * containerField describes typical field relationship of a node to its parent.
	 * Programmer usage is not ordinarily needed when using this API, since this default value is provided for informational purposes only.</xsl:text>
								<xsl:if test="(string-length(InterfaceDefinition/containerField/@type) > 0)">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see #containerField_DEFAULT_VALUE
         * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerFieldChoices" target="_blank">X3D Scene Authoring Hints: validation choices for containerField</a>
	 * @see <a href="https://www.web3d.org/specifications/X3DUOM.html" target="_blank">X3D Unified Object Model (X3DUOM)</a>]]></xsl:text>
								</xsl:if>
								<xsl:text>
         * @return default containerField value
	 */
        @Override
        public final String getContainerFieldDefault()
        {
            return containerField_DEFAULT_VALUE;
        }
</xsl:text>
							</xsl:if>
							<xsl:if test="not($isX3dStatement = 'true')">
								<!-- Source code: _TOFIELD, FROM_FIELD definitions -->
								<xsl:for-each select="InterfaceDefinition/field[not((@name = 'DEF') or (@name = 'USE') or (@name = 'id') or (@name = 'class') or ((@name = 'style') and not(ends-with($name, 'FontStyle'))))]">
									<xsl:if test="position()=1">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	// String constants for field names usable in ROUTE statements</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:variable name="isX3dStatement">
										<xsl:call-template name="isX3dStatement">
											<xsl:with-param name="name" select="@name"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="name" select="@name"/>
									<xsl:variable name="fieldName" select="translate(@name,'-','_')"/>

									<xsl:variable name="hasPrecedingFieldDefinition">
										<!-- example: ParticleSystem has 'geometry' field annotation overriding Shape node -->
										<xsl:value-of select="(count(preceding-sibling::*[(@name = $fieldName) or (@name = concat('set_',$fieldName)) or (@name = concat($fieldName,'_changed'))]) > 0)"/>
									</xsl:variable>

									<!-- output event names -->
									<xsl:if test="(@accessType = 'outputOnly') or (@accessType='inputOutput') and not($hasPrecedingFieldDefinition = 'true')
												  and not($name = 'field') and not($name = 'fieldValue')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	/** fromField ROUTE name for </xsl:text>
										<xsl:value-of select="@type"/>
										<xsl:text> field named </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="$fieldName"/>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>. </xsl:text>
										<xsl:text>*/</xsl:text><!-- end javadoc -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	public static final String fromField_</xsl:text>
										<xsl:value-of select="upper-case($fieldName)"/>
										<xsl:text> = "</xsl:text>
										<xsl:value-of select="$fieldName"/>
										<xsl:text>";</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>

									<!-- input event names -->
									<xsl:if test="(@accessType = 'inputOnly') or (@accessType='inputOutput') and not($hasPrecedingFieldDefinition = 'true') and not($isX3dStatement = 'true')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	/** toField ROUTE name for </xsl:text>
										<xsl:value-of select="@type"/>
										<xsl:text> field named </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="$fieldName"/>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>. </xsl:text>
										<xsl:text>*/</xsl:text><!-- end javadoc -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	public static final String toField_</xsl:text>
										<xsl:value-of select="upper-case($fieldName)"/>
										<xsl:text> = "</xsl:text>
										<xsl:value-of select="$fieldName"/>
										<xsl:text>";</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
								</xsl:for-each>
							</xsl:if>

							<!-- Source code: constructor method -->
							<xsl:if test="not(starts-with($name, 'X3DConcrete'))"><!-- which have no initialize() method -->
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	/** Constructor for </xsl:text>
								<xsl:value-of select="$thisClassName"/>
								<xsl:if test="(@type='MFNode')">
									<xsl:text>[]</xsl:text>
								</xsl:if>
								<xsl:text> to initialize member variables with default values. */</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	public </xsl:text>
								<xsl:value-of select="$name"/>
								<xsl:if test="not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not(starts-with($name,'X3DConcrete'))">
									<xsl:value-of select="$jsaiClassSuffix"/>
								</xsl:if>
								<xsl:if test="(@type='MFNode')">
									<xsl:text>[]</xsl:text>
								</xsl:if>
								<xsl:text>()</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	{</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>		super(); // constructor invocation and corresponding initialize()</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>		initialize();</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	}</xsl:text>
								<xsl:text>&#10;</xsl:text>

								<!-- initialize() method -->
								<xsl:if test="not(contains($implementationBlock,' void initialize')) and
										      not($isUtilityClass = 'true')">
									<!-- Source code: initialize method -->
									<xsl:text>
	/** Initialize all member variables to default values. */
	@Override
	public final void initialize()
	{
		super.initialize();
</xsl:text>

									<xsl:if test="(local-name() = 'ConcreteNode') and InterfaceDefinition/field[@name = 'name']">
										<xsl:text>
        super.includesNameField();</xsl:text>
                                    </xsl:if>
									<xsl:if test="not($isX3dStatement = 'true')">
										<!-- as needed, containerField updates by checking parent node and SFNode field -->
										<!-- Reference list found at X3D Scene Authoring Hints: containerField -->
										<!-- https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField -->
										<xsl:text>
        setContainerFieldOverride(""); // ensuring default value used
	containerField_ALLOWED_VALUES = new String[] { "</xsl:text>
										<xsl:value-of select="InterfaceDefinition/containerField/@default"/>
										<xsl:text>"</xsl:text>
                                                                                <xsl:value-of select="$containerFieldAllowedValues" disable-output-escaping="yes"/>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<!-- initialize each field with default values -->
									<xsl:for-each select="InterfaceDefinition/field[
													not(starts-with(@name,'set_')) and not(ends-with(@name,'_changed')) and
													not(@name = 'DEF') and not(@name = 'USE') and not(@name = 'id') and not(@name = 'class') and not((@name = 'style') and not(ends-with($thisClassName, 'FontStyle'))) and
												 ((@accessType='inputOutput') or (@accessType='initializeOnly') or (string-length(@accessType)=0))]">
										<xsl:variable name="isX3dStatement">
											<xsl:call-template name="isX3dStatement">
												<xsl:with-param name="name" select="@name"/>
											</xsl:call-template>
										</xsl:variable>

										<!-- TODO avoid duplication, refactor as call-template; alternatively override X3D Object Model -->
										<xsl:variable name="defaultValue">
											<!-- Provide default values where useRequired in XML Schema, e.g. X3D version -->
											<xsl:choose>
												<xsl:when test="(@type='SFNode') or (@default='NULL')">
													<xsl:text>null</xsl:text>
												</xsl:when>
												<xsl:when test="(@type='MFNode')">
													<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;()</xsl:text><!-- ArrayList<> -->
												</xsl:when>
												<xsl:when test="(string-length(@default) > 0)">
													<xsl:value-of select="@default"/>
												</xsl:when>
											</xsl:choose>
										</xsl:variable>

										<xsl:text>&#10;</xsl:text>
										<xsl:text>		</xsl:text>
										<xsl:choose>
                                            <xsl:when test="(@name = 'id')">
                                                <xsl:text>HtmlID</xsl:text>
                                            </xsl:when>
											<xsl:when test="(@name = 'class')">
												<!-- getClass() is reserved by Java Object() class -->
												<xsl:text>cssClass</xsl:text>
											</xsl:when>
											<xsl:when test="(@name = 'style') and not(ends-with($thisClassName, 'FontStyle'))">
											<!-- similarly named for clarity, consistency -->
												<xsl:text>cssStyle</xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="translate(@name,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											</xsl:otherwise>
										</xsl:choose>
										<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
											<xsl:text>List</xsl:text><!-- append to member name -->
										</xsl:if>
										<xsl:text> = </xsl:text>
										<xsl:choose>
											<xsl:when test="(@type='SFNode') or (@type='MFNode')">
												<xsl:value-of select="$defaultValue" disable-output-escaping="yes"/>
												<xsl:text>;</xsl:text>
												<xsl:if test="($defaultValue = 'null')">
                                                    <xsl:if test="(@type='SFNode') and not($isX3dStatement = 'true')">
                                                        <xsl:text>             </xsl:text>
													</xsl:if>
													<xsl:text> // clear out any prior node</xsl:text>
													<xsl:if test="(@type='MFNode')">
														<xsl:text>s</xsl:text>
													</xsl:if>
												</xsl:if>
                                                <xsl:if test="(@type='SFNode') and not($isX3dStatement = 'true')">
                                                    <xsl:text>&#10;</xsl:text>
                                                    <xsl:text>		</xsl:text>
                                                    <xsl:value-of select="translate(@name,'-','_')"/> <!-- translate name here to avoid xpath problems -->
                                                    <xsl:text>ProtoInstance</xsl:text>
                                                    <xsl:text> = </xsl:text>
                                                    <xsl:text>null</xsl:text>
                                                    <xsl:text>;</xsl:text>
                                                    <xsl:text> // clear out any prior node</xsl:text>
												</xsl:if>
											</xsl:when>
											<xsl:when test="(@type='MFString')">
												<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;(</xsl:text><!-- ArrayList<> -->
												<xsl:value-of select="upper-case(translate(@name,'-','_'))"/> <!-- translate name here to avoid xpath problems -->
												<xsl:text>_DEFAULT_VALUE</xsl:text>
												<xsl:text>);</xsl:text>
											</xsl:when>
											<!-- TODO check if $defaultValue test is correct, order of these patterns is sensitive -->
											<xsl:when test="(@type='SFString') or (@type = 'xs:string') or starts-with(@type,'xs:NMTOKEN') or (@type = 'xs:token') or starts-with(@type,'xs:ID') or
                                                            (string-length(normalize-space($defaultValue)) > 0)">
												<xsl:value-of select="upper-case(translate(@name,'-','_'))"/> <!-- translate name here to avoid xpath problems -->
												<xsl:text>_DEFAULT_VALUE;</xsl:text>
											</xsl:when>
											<xsl:when test="(@type='MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type='MFFloat') or (@type='MFDouble') or (@type='MFTime')">
												<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;();</xsl:text><!-- ArrayList<> -->
											</xsl:when>
											<xsl:when test="starts-with(@type,'MF')">
												<xsl:text> new </xsl:text>
												<xsl:value-of disable-output-escaping="yes">
													<!-- can include collections, must be escaped -->
													<xsl:call-template name="javaType">
														<xsl:with-param name="x3dType" select="@type"/>
														<xsl:with-param name="isInterface" select="$isInterface"/>
													</xsl:call-template>
												</xsl:value-of>
												<xsl:text> { };</xsl:text>
											</xsl:when>
											<xsl:when test="(string-length($defaultValue) = 0)">
												<!-- all fields should have a default value; report error if found -->
												<xsl:variable name="errorMessage">
													<xsl:text>[Error in X3DUOM, XML Schema] No default value found for </xsl:text>
													<xsl:value-of select="$name"/>
													<xsl:text> field </xsl:text>
													<xsl:value-of select="@name"/>
												</xsl:variable>
												<xsl:text>UNDEFINED; // </xsl:text>
												<xsl:value-of select="$errorMessage"/>
												<xsl:message>
													<xsl:text>[error]  </xsl:text>
													<xsl:value-of select="$errorMessage"/>
												</xsl:message>
											</xsl:when>
										</xsl:choose>
									</xsl:for-each>
									<xsl:text>&#10;</xsl:text>

									<xsl:if test="not($hasChildrenField = 'true') and not(starts-with($name, 'X3DConcrete'))">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		commentsList = new ArrayList<>(); // instantiate, initialize
]]></xsl:text>
									</xsl:if>
									<xsl:choose>
										<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
			fieldList = new ArrayList<>(); // instantiate, initialize

	]]></xsl:text>
        <!-- handled by X3DUOM
			sourceCode = SOURCECODE_DEFAULT_VALUE; // reset
        -->
										</xsl:when>
										<xsl:when test="(($name = 'ComposedShader') or ($name = 'PackagedShader'))">
											<xsl:text disable-output-escaping="yes"><![CDATA[
			fieldList = new ArrayList<>(); // instantiate, initialize
	]]></xsl:text>
										</xsl:when>
        <!-- handled by X3DUOM
										<xsl:when test="($name = 'ShaderPart')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
			sourceCode = SOURCECODE_DEFAULT_VALUE; // reset
	]]></xsl:text>
										</xsl:when>
                                                                                -->
										<xsl:when test="($name = 'ProtoInterface')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
			fieldList = new ArrayList<>(); // instantiate, initialize
	]]></xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'ProtoInstance')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
		fieldValueList = new ArrayList<>(); // instantiate, initialize
]]></xsl:text>
										</xsl:when>
									</xsl:choose>

									<xsl:if test="($name = 'field') or ($name = 'fieldValue')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		valueArrayBoolean = java.util.Arrays.copyOf(DEFAULT_VALUE_BOOLEAN, DEFAULT_VALUE_BOOLEAN.length); // must be separate copy
		valueArrayInteger = java.util.Arrays.copyOf(DEFAULT_VALUE_INTEGER, DEFAULT_VALUE_INTEGER.length); // must be separate copy
		valueArrayFloat   = java.util.Arrays.copyOf(DEFAULT_VALUE_FLOAT,   DEFAULT_VALUE_FLOAT.length  ); // must be separate copy
		valueArrayDouble  = java.util.Arrays.copyOf(DEFAULT_VALUE_DOUBLE,  DEFAULT_VALUE_DOUBLE.length ); // must be separate copy
]]></xsl:text>
									</xsl:if>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
							</xsl:if>


							<!-- Add class-specific methods and member definitions -->
							<xsl:variable name="protectedPreamble">
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	// Protected member value declarations are encapsulated and private, for internal library use only</xsl:text>
								<xsl:text>&#10;</xsl:text>
							</xsl:variable>
							<xsl:choose>
								<xsl:when test="($name = 'X3D')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * File extension for X3D XML Encoding, with dot prepended: <i>.x3d</i>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html" target="_blank">X3D XML Encoding</a>
	 */
	public static final String FILE_EXTENSION_X3D = ".x3d";

	/**
	 * File extension for X3D ClassicVRML Encoding, with dot prepended: <i>.x3dv</i>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/X3D_ClassicVRML.html" target="_blank">X3D ClassicVRML Encoding</a>
	 */
	public static final String FILE_EXTENSION_CLASSICVRML = ".x3dv";
	/**
	 * File extension for X3D Compressed Binary Encoding, with dot prepended: <i>.x3db</i>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/X3D_Binary.html" target="_blank">X3D Compressed Binary Encoding Encoding</a>
	 */
	public static final String FILE_EXTENSION_X3DB = ".x3db";

	/**
	 * File extension for VRML97 Encoding, with dot prepended: <i>.wrl</i>
	 * @see <a href="https://www.web3d.org/documents/specifications/14772/V2.0/index.html" target="_blank">VRML97 Encoding</a>
	 */
	public static final String FILE_EXTENSION_VRML97 = ".wrl";

	/**
	 * File extension for Extensible Markup Language, with dot prepended: <i>.xml</i>
	 * @see <a href="https://www.w3.org/TR/REC-xml" target="_blank">W3C Recommendation, Extensible Markup Language (XML)</a>
	 */
	public static final String FILE_EXTENSION_XML = ".xml";

	/**
	 * File extension for Scalable Vector Graphics (SVG), with dot prepended: <i>.svg</i>
	 * @see <a href="https://www.w3.org/Graphics/SVG" target="_blank">SVG Working Group</a>
	 */
	public static final String FILE_EXTENSION_SVG = ".svg";

	/**
	 * File extension for HTML Encoding, with dot prepended: <i>.html</i>
	 * @see <a href="https://www.w3.org/TR/html/syntax.html#syntax" target="_blank">HTML5: HTML syntax</a>
	 */
	public static final String FILE_EXTENSION_HTML = ".html";

	/**
	 * File extension for markdown encoding, with dot prepended: <i>.md</i>
	 * @see <a href="https://docs.gitlab.com/ee/user/markdown.html" target="_blank">GitLab Flavored Markdown (GFM)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Markdown" target="_blank">Wikipedia: Markdown</a>
	 */
	public static final String FILE_EXTENSION_MARKDOWN = ".md";

	/**
	 * File extension for MIDI encoding, with dot prepended: <i>.midi</i>
	 * @see <a href="https://www.midi.org" target="_blank">MIDI Association</a>
	 * @see <a href="https://en.wikipedia.org/wiki/MIDI" target="_blank">Wikipedia: MIDI</a>
	 */
	public static final String FILE_EXTENSION_MIDI = ".midi";

	/**
	 * File extension for PLY file format (Polygon File Format, or Stanford Triangle Format) with dot prepended: <i>.ply</i>.
	 * @see <a href="https://en.wikipedia.org/wiki/PLY_(file_format)" target="_blank">Wikipedia: PLY (file format)</a>
	 */
	public static final String FILE_EXTENSION_PLY = ".ply";

	/**
	 * File extension for STL (stereolithography) file format with dot prepended: <i>.stl</i>
	 * @see <a href="https://en.wikipedia.org/wiki/STL_(file_format)" target="_blank">Wikipedia: STL (file format)</a>
	 */
	public static final String FILE_EXTENSION_STL = ".stl";

	/**
	 * File extension for XHTML Encoding, with dot prepended: <i>.xhtml</i>
	 * @see <a href="https://www.w3.org/TR/html/xhtml.html#xhtml" target="_blank">HTML5: XHTML syntax</a>
	 */
	public static final String FILE_EXTENSION_XHTML = ".xhtml";

	/**
	 * File extension for text files, with dot prepended: <i>.txt</i>
	 */
	public static final String FILE_EXTENSION_TEXT = ".txt";

	/**
	 * File extension for Graphics Interchange Format (GIF) image format, with dot prepended: <i>.gif</i>
	 * @see <a href="https://en.wikipedia.org/wiki/GIF" target="_blank">Wikipedia: GIF</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Images" target="_blank">X3D Scene Authoring Hints: Images</a>
	 */
	public static final String FILE_EXTENSION_GIF = ".gif";

	/**
	 * File extension for Joint Photographic Experts Group (JPEG) image format, with dot prepended: <i>.jpg</i>
	 * @see <a href="https://en.wikipedia.org/wiki/JPEG" target="_blank">Wikipedia: JPEG</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Images" target="_blank">X3D Scene Authoring Hints: Images</a>
	 */
	public static final String FILE_EXTENSION_JPG = ".jpg";

	/**
	 * File extension for Joint Photographic Experts Group (JPEG) image format, with dot prepended: <i>.jpeg</i>
	 * @see <a href="https://en.wikipedia.org/wiki/JPEG" target="_blank">Wikipedia: JPEG</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Images" target="_blank">X3D Scene Authoring Hints: Images</a>
	 */
	public static final String FILE_EXTENSION_JPEG = ".jpeg";

	/**
	 * File extension for Portable Network Graphics (PNG) image format, with dot prepended: <i>.png</i>
	 * @see <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics" target="_blank">Wikipedia: Portable Network Graphics</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Images" target="_blank">X3D Scene Authoring Hints: Images</a>
	 */
	public static final String FILE_EXTENSION_PNG = ".png";

	/**
	 * File extension for Java source code, with dot prepended: <i>.java</i>
	 * @see <a href="https://www.oracle.com/technetwork/java/javase/overview" target="_blank">Java Platform, Standard Edition (Java SE)</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Java" target="_blank">X3D Scene Authoring Hints: Java</a>
	 */
	public static final String FILE_EXTENSION_JAVA = ".java";

	/**
	 * File extension for JavaScript source code, with dot prepended: <i>.js</i>
	 * @see <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a>
	 * @see <a href="https://en.wikipedia.org/wiki/ECMAScript" target="_blank">ECMAScript ECMA-262</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#JavaScript" target="_blank">X3D Scene Authoring Hints: JavaScript</a>
	 */
	public static final String FILE_EXTENSION_JAVASCRIPT = ".js";

	/**
	 * File extension for JavaScript Object Notation (JSON) source data, with dot prepended: <i>.json</i>
	 * @see <a href="https://en.wikipedia.org/wiki/JSON" target="_blank">JavaScript Object Notation (JSON)</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#JSON" target="_blank">X3D Scene Authoring Hints: JSON</a>
	 */
	public static final String FILE_EXTENSION_JSON = ".json";

	/**
	 * File extension for Python programming-language source code, with dot prepended: <i>.py</i>
	 * @see <a href="https://www.python.org" target="_blank">Python.org</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Python_(programming_language)" target="_blank">Python (programming language)</a>
	 * @see <a href="https://pypi.org/project/x3d" target="_blank">Python X3D Package x3d.py</a>
	 */
	public static final String FILE_EXTENSION_PYTHON = ".py";

	/**
	 * File extension for Efficient XML Interchange (EXI) compressed XML file, with dot prepended: <i>.exi</i>
	 * @see <a href="https://en.wikipedia.org/wiki/Efficient_XML_Interchange" target="_blank">Wikipedia: Efficient XML Interchange (EXI) file format</a>
	 * @see <a href="https://www.w3.org/TR/2014/REC-exi-20140211" target="_blank">Efficient XML Interchange (EXI) Format 1.0 (Second Edition) W3C Recommendation</a>
	 * @see <a href="https://www.w3.org/XML/EXI" target="_blank">EXI Working Group (public page)</a>
	 * @see <a href="https://www.w3.org/XML/Group/EXI" target="_blank">EXI Working Group (member page)</a>
	 */
	public static final String FILE_EXTENSION_EXI = ".exi";

	/**
	 * File extension for GZIP compressed file, with dot prepended: <i>.gz</i>
	 * @see <a href="https://en.wikipedia.org/wiki/Gzip" target="_blank">Wikipedia: gzip file format</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/package-summary.html" target="_blank">Java Package java.util.zip for ZIP and GZIP file formats</a>
	 * @see <a href="https://www.oracle.com/technetwork/articles/java/compress-1565076.html" target="_blank">Compressing and Decompressing Data Using Java APIs by Qusay H. Mahmoud</a>
	 */
	public static final String FILE_EXTENSION_GZIP = ".gz";

	/**
	 * File extension for ZIP compressed file, with dot prepended: <i>.zip</i>
	 * @see <a href="https://en.wikipedia.org/wiki/Zip_(file_format)" target="_blank">Wikipedia: zip file format</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/package-summary.html" target="_blank">Java Package java.util.zip for ZIP and GZIP file formats</a>
	 * @see <a href="https://www.oracle.com/technetwork/articles/java/compress-1565076.html" target="_blank">Compressing and Decompressing Data Using Java APIs by Qusay H. Mahmoud</a>
	 */
	public static final String FILE_EXTENSION_ZIP = ".zip";

	/**
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles" target="_blank">Buffered I/O Methods for Text Files</a>
     */
	private BufferedWriter bufferedWriter;

	/**
	 * Setup EXIFactory as required, TODO EXIFICIENT documentation
	 */
//    EXIFactory exiFactory = DefaultEXIFactory.newInstance();

	/** @see TODO EXIFICIENT docs */
	Grammars exificientGrammarX3D; // TODO public

	/**
	 * Provide XML string serialization of this model subgraph, utilizing X3D XML encoding and conforming to X3D Canonical Form.
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#FILE_EXTENSION_X3D
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#FILE_EXTENSION_XML
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toStringXML()
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileXML(String)
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileX3D(String)
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html" target="_blank">X3D XML Encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="_blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm" target="_blank">X3D Canonicalization (C14N) Tool</a>
	 * @return X3D string
	 */
	public String toStringXML()
	{
		return toStringX3D();
	}
	/**
	 * Provide XML string serialization of this model subgraph, utilizing X3D XML encoding and conforming to X3D Canonical Form.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#FILE_EXTENSION_X3D
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#FILE_EXTENSION_XML
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toStringXML()
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileXML(String)
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileX3D(String)
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html" target="_blank">X3D XML Encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm" target="_blank">X3D Canonicalization (C14N) Tool</a>
	 * @return X3D string
	 */
	public String toStringXML(int indentLevel)
	{
		return toStringX3D(indentLevel);
	}

	/**
	 * Serialize scene graph using <i>toStringX3D()</i> to create a new XML-encoding X3D file with extension <i>x3d</i> or <i>xml</i>.
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toStringXML()
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileXML(String)
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileX3D(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles" target="_blank">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .x3d
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileXML(String fileName)
	{
		return toFileX3D(fileName);
	}
/**
 * Check whether fileName is satisfactory NMTOKEN, ignoring prior path (if any).
 * @see SFString#isNMTOKEN(String)
 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
 * @param fileName name of file to check
 * @return whether fileName is satisfactory NMTOKEN
 */
public static boolean isFileNameNMTOKEN(String fileName)
{
    String strippedFileName = fileName;
    if (strippedFileName.contains("/"))
        strippedFileName = strippedFileName.substring(strippedFileName.lastIndexOf("/")  + 1);
    if (strippedFileName.contains("\\"))
        strippedFileName = strippedFileName.substring(strippedFileName.lastIndexOf("\\") + 1);

    return SFString.isNMTOKEN(strippedFileName);
}
/**
 * Check whether fileName ending in .x3d meets X3D naming conventions, ignoring prior path (if any).
 * Not observing these conventions can cause errors when converting to a Java file name.
 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#FILE_EXTENSION_X3D
 * @see SFString#isNMTOKEN(String)
 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
 * @param fileName name of file to check
 * @return whether fileName ending in .x3d is satisfactory NMTOKEN
 */
public static boolean fileNameMeetsX3dNamingConventions(String fileName)
{
    String strippedFileName = fileName;
    if (strippedFileName.contains("/"))
        strippedFileName = strippedFileName.substring(strippedFileName.lastIndexOf("/")   + 1);
    if (strippedFileName.contains("\\"))
        strippedFileName = strippedFileName.substring(strippedFileName.lastIndexOf("\\")  + 1);
    if (strippedFileName.contains(".")) // strip file extension
       strippedFileName = strippedFileName.substring(0, strippedFileName.lastIndexOf("."));

    if (!fileName.endsWith(FILE_EXTENSION_X3D)       || // avoid warning on file-format conversions in unit tests
         fileName.toUpperCase().contains(".EXI")     ||
         fileName.toUpperCase().contains(".OPENEXI") ||
         fileName.toUpperCase().contains(".NASHORN") ||
         fileName.toUpperCase().contains(".JS")      ||
         fileName.toUpperCase().contains(".JAVA")    ||
         fileName.toUpperCase().contains(".JSON")    ||
         fileName.toUpperCase().contains(".PY")      ||
         fileName.toUpperCase().contains(".TEMP")    ||
         fileName.toUpperCase().contains("ROUNDTRIP"))
         return true;
    else return SFString.meetsX3dInteroperabilityNamingConventions(strippedFileName);
}
	/**
	 * Serialize scene graph using <i>toStringX3D()</i> to create a new XML-encoding X3D file with extension <i>x3d</i> or <i>xml</i>.
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toStringX3D()
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toStringXML()
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileXML(String)
	 * @see SFString#isNMTOKEN(String)
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles" target="_blank">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .x3d
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileX3D(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileX3D(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_X3D + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_X3D) && !fileName.endsWith(FILE_EXTENSION_XML))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_X3D + "\" or " +
                            "\"" + FILE_EXTENSION_XML + "\"");
		}
        if (!fileNameMeetsX3dNamingConventions(fileName))
            System.out.println ("[warning] " + fileName + " does not meet suggested X3D naming conventions, continuing...");
        else if (!isFileNameNMTOKEN(fileName)) // less strict
            System.out.println ("[warning] " + fileName + " is not a valid NMTOKEN, continuing...");

		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}

		// https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

		try
		{
			validate(); // strict checks before serializing scene and saving file
		}
		catch (Exception e)
		{
			System.out.println (e); // output exception but allow serialization to continue, file may be editable
			e.printStackTrace();
			if (ConfigurationProperties.isValidationExceptionAllowed())
				 System.out.println ("Output serialization allowed to continue, file may be editable...");
			else throw (e);
		}
		File priorFile = new File(fileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Note: toFileX3D() is overwriting prior file " + fileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("[warning] toFileX3D() is not allowed to overwrite prior file: " + fileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

		String outputSceneText = toStringX3D();
		try
		{
			Path directoryPath = outputFilePath.getParent();
			if ((directoryPath != null))
				 Files.createDirectories(directoryPath); // if needed
			bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
			bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
			bufferedWriter.close(); // ensure file writing is complete
			return outputFilePath.toFile(); // success
		}
		catch (IOException exception)
		{
			exception.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException for fileName " + fileName + ", unable to save file: " + exception);
		}
	}
	/**
	 * Serialize scene graph using <i>toStringClassicVRML()</i> to create a new X3D file with extension <i>x3dv</i>.
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toStringClassicVRML()
	 * @see SFString#isNMTOKEN(String)
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles" target="_blank">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .x3dv
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileClassicVRML(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileClassicVRML(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_CLASSICVRML + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_CLASSICVRML))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with extension \"" + FILE_EXTENSION_CLASSICVRML + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
            System.out.println ("[warning] " + fileName + " does not meet suggested X3D naming conventions, continuing...");
        else if (!isFileNameNMTOKEN(fileName)) // less strict
            System.out.println ("[warning] " + fileName + " is not a valid NMTOKEN, continuing...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			if (errorNotice.isEmpty()) errorNotice += "\n";
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}

		// https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

		try
		{
			validate(); // strict checks before serializing scene and saving file
		}
		catch (Exception e)
		{
			System.out.println (e); // output exception but allow serialization to continue, file may be editable
			e.printStackTrace();
			if (ConfigurationProperties.isValidationExceptionAllowed())
				 System.out.println ("Output serialization allowed to continue, file may be editable...");
			else throw (e);
		}
		File priorFile = new File(fileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Note: toFileClassicVRML() is overwriting prior file " + fileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("[warning] toFileClassicVRML() is not allowed to overwrite prior file: " + fileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

		String outputSceneText = toStringClassicVRML();
		try
		{
			Path directoryPath = outputFilePath.getParent();
			if ((directoryPath != null))
				 Files.createDirectories(directoryPath); // if needed
			bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
			bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
			bufferedWriter.close(); // ensure file writing is complete
			return outputFilePath.toFile(); // success
		}
		catch (IOException exception)
		{
			exception.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException for fileName " + fileName + ", unable to save file: " + exception);
		}
	}
	/**
	 * Serialize scene graph using <i>toStringVRML97()</i> to create a new X3D file with extension <i>wrl</i>.
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toStringVRML97()
	 * @see SFString#isNMTOKEN(String)
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles" target="_blank">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .wrl
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileVRML97(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileVRML97(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_VRML97 + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_VRML97))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with extension \"" + FILE_EXTENSION_VRML97 + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
            System.out.println ("[warning] " + fileName + " does not meet suggested X3D naming conventions, continuing...");
        else if (!isFileNameNMTOKEN(fileName)) // less strict
            System.out.println ("[warning] " + fileName + " is not a valid NMTOKEN, continuing...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			if (errorNotice.isEmpty()) errorNotice += "\n";
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}

		// https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

		try
		{
			validate(); // strict checks before serializing scene and saving file
		}
		catch (Exception e)
		{
			System.out.println (e); // output exception but allow serialization to continue, file may be editable
			e.printStackTrace();
			if (ConfigurationProperties.isValidationExceptionAllowed())
				 System.out.println ("Output serialization allowed to continue, file may be editable...");
			else throw (e);
		}
		File priorFile = new File(fileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Note: toFileVRML97() is overwriting prior file " + fileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("[warning] toFileVRML97() is not allowed to overwrite prior file: " + fileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

		String outputSceneText = toStringVRML97();
		try
		{
			Path directoryPath = outputFilePath.getParent();
			if ((directoryPath != null))
				 Files.createDirectories(directoryPath); // if needed
			bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
			bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
			bufferedWriter.close(); // ensure file writing is complete
			return outputFilePath.toFile(); // success
		}
		catch (IOException exception)
		{
			exception.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException for fileName " + fileName + ", unable to save file: " + exception);
		}
	}
	/**
	 * Utility method for toFileStylesheetConversion() with no stylesheet parameters.
	 * @param stylesheetName name of stylesheet to apply
	 * @param fileName name of file to create and save, can include local directory path, must end with allowed file extension (e.g. ".html")
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileStylesheetConversion(String stylesheetName, String fileName)
	{
            return toFileStylesheetConversion(stylesheetName, fileName, "", "", "", "");
	}
	/**
	 * Utility method for toFileStylesheetConversion() with a single stylesheet name=value parameter pair.
	 * @param stylesheetName name of stylesheet to apply
	 * @param fileName name of file to create and save, can include local directory path, must end with allowed file extension (e.g. ".html")
	 * @param parameterName1  first stylesheet parameter name
	 * @param parameterValue1 first stylesheet parameter value
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileStylesheetConversion(String stylesheetName, String fileName, String parameterName1, String parameterValue1)
	{
            return toFileStylesheetConversion(stylesheetName, fileName, parameterName1, parameterValue1, "", "");
	}

	/**
	 * Serialize current X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ scene graph using <i>toFileX3D()</i> and then create a new file with corresponding filename extension (e.g. <i>.html</i>) using an embedded stylesheet.
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toStringX3D()
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileX3D(String)
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileJava(String)
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileJSON(String)
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFilePython(String)
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileX3DOM(String)
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileX_ITE(String,String)
	 * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#toFileCobweb(String,String)
	 * @see SFString#isNMTOKEN(String)
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @see ConfigurationProperties#X3DJSAIL_JAR_RELEASE_VERSIONS
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding" target="_blank">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE" target="_blank">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html" target="_blank">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip" target="_blank">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles" target="_blank">Buffered I/O Methods for Text Files</a>
	 * @param stylesheetName name of stylesheet to apply
	 * @param fileName name of file to create and save, can include local directory path, must end with allowed file extension (e.g. ".html")
	 * @param parameterName1  first stylesheet parameter name
	 * @param parameterValue1 first stylesheet parameter value
	 * @param parameterName2  second stylesheet parameter name
	 * @param parameterValue2 second stylesheet parameter value
	 * @return File containing result (if operation succeeds), null otherwise
	 */
    // https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html
    // https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html
    // https://stackoverflow.com/questions/1858021/suppress-deprecated-import-warning-in-java
    @SuppressWarnings("deprecation")
	public File toFileStylesheetConversion(String stylesheetName, String fileName, String parameterName1, String parameterValue1, String parameterName2, String parameterValue2)
	{
		String errorNotice               = new String();
                String expectedFileNameExtension = new String();
		if ((stylesheetName == null || stylesheetName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileStylesheetConversion(stylesheetName, fileName) stylesheetName not provided;" +
				" (see ConfigurationProperties for allowed choices)");
		}
                expectedFileNameExtension = ConfigurationProperties.getExpectedOutputFileExtension(stylesheetName);

		if ((fileName == null || fileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileStylesheetConversion(stylesheetName, fileName) fileName not provided;" +
				" (see ConfigurationProperties for allowed choices)");
		}
		if (!((fileName.endsWith(expectedFileNameExtension)) || // some variations allowed
                     (fileName.endsWith(FILE_EXTENSION_XHTML)      && expectedFileNameExtension.equals(FILE_EXTENSION_HTML)) ||
                     (fileName.endsWith(FILE_EXTENSION_JAVASCRIPT) && expectedFileNameExtension.equals(FILE_EXTENSION_JSON))))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with expected extension \"" + expectedFileNameExtension + "\"");
		}
                // no need to check fileName for suggested X3D naming conventions
                if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("[warning] " + fileName + " is not a valid NMTOKEN, continuing...");

		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
		}

		String intermediateX3DFileName = fileName.substring(0, fileName.length() - 5) + "PrettyPrint.intermediate.x3d";
		Path   intermediateX3DFilePath = Paths.get(intermediateX3DFileName);
		if (ConfigurationProperties.isDebugModeActive())
			errorNotice += "[diagnostic] intermediateX3DFilePath=" + intermediateX3DFilePath.toAbsolutePath() + "\n";

		// https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

		try
		{
			validate(); // strict checks before serializing scene and saving file
		}
		catch (Exception e)
		{
			System.out.println (e); // output exception but allow serialization to continue, file may be editable
			e.printStackTrace();
			if (ConfigurationProperties.isValidationExceptionAllowed())
				 System.out.println ("Output serialization allowed to continue, file may be editable...");
			else throw (e);
		}
		File priorFile = new File(fileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Note: toFileStylesheetConversion(" + stylesheetName + ") is overwriting prior file " + fileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("[warning] toFileStylesheetConversion() is not allowed to overwrite prior file: " + fileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

		String outputSceneText = toStringX3D();
		try
		{
			bufferedWriter = Files.newBufferedWriter(intermediateX3DFilePath, charset);
			bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
			bufferedWriter.close(); // ensure file writing is complete
		}
		catch (IOException exception)
		{
			throw new org.web3d.x3d.sai.X3DException("IOException when creating intermediateX3DFilePath " + intermediateX3DFilePath +
				", unable to save file: " + exception);
		}

		try // https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html
		{
            // background references
			// https://stackoverflow.com/questions/20389255/reading-a-resource-file-from-within-jar/20389418#20389418
			// https://stackoverflow.com/questions/403256/how-do-i-read-a-resource-file-from-a-java-jar-file
			// https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getResourceAsStream(String)
			// https://stackoverflow.com/questions/11501418/is-it-possible-to-create-a-file-object-from-inputstream
			// targets: X3DJSAIL.4.0.full.jar and X3DJSAIL.4.0.classes.jar

			final String systemClassPath = ConfigurationProperties.getClassPath();

			String currentX3dJsailJarName = "(unlocated)";
			boolean foundX3dJsailJar = false;
			if    ( systemClassPath.contains("X3DJSAIL"))
			{
					 currentX3dJsailJarName = systemClassPath.substring(systemClassPath.indexOf("X3DJSAIL"));
				if ((systemClassPath.indexOf("X3DJSAIL") > 0) &&
					(currentX3dJsailJarName.indexOf(java.io.File.pathSeparatorChar) > 0))
					 currentX3dJsailJarName = currentX3dJsailJarName.substring(0,currentX3dJsailJarName.indexOf(java.io.File.pathSeparatorChar));
				// X3DJSAIL.*.jar now extracted as currentX3dJsailJarName
				for (String nextX3dJsailJar : ConfigurationProperties.X3DJSAIL_JAR_RELEASE_VERSIONS)
				{
					if (currentX3dJsailJarName.equals(nextX3dJsailJar))
					{
						 foundX3dJsailJar = true;
						 break;
					}
				}
			}
			if (!foundX3dJsailJar)
			{
				errorNotice = ConfigurationProperties.ERROR_CONFIGURATION_X3DJSAIL + " X3DJSAIL .jar archive " + currentX3dJsailJarName
								+ " not found in\n  CLASSPATH=" + systemClassPath+ "\n";
                                errorNotice += "  invoked from toFileStylesheetConversion(" + stylesheetName + ", " + fileName
                                         + ", " + parameterName1 + ", " + parameterValue1 + ", " + parameterName2 + ", " + parameterValue2 + ")\n";
                                validationResult.append(errorNotice);
				throw new InvalidFieldValueException(errorNotice);
			}

                        // must end in !/ https://stackoverflow.com/questions/38488492/documentbuilder-gives-java-net-malformedurlexception-no-in-spec
			String        jarPath = "jar:file:" + currentX3dJsailJarName + "!/";
			String stylesheetPath = "stylesheets/" + stylesheetName;

			if (ConfigurationProperties.isDebugModeActive())
			{
				errorNotice += "[diagnostic] ConfigurationProperties.isDebugModeActive()=" + ConfigurationProperties.isDebugModeActive() + "\n";
				errorNotice += "[diagnostic] System java.class.path=" + systemClassPath   + "\n";
				errorNotice += "[diagnostic] jarPath=" + jarPath + ", ";
				errorNotice +=  "stylesheetPath=" + stylesheetPath + "\n";
			}
                        // .class or getClass().getResourceAsStream looks within each classpath .jar for stylesheetPath
			InputStream stylesheetInputStream = getClass().getResourceAsStream("/" + stylesheetPath);
 			if (stylesheetInputStream == null)
			{
				errorNotice += "Stylesheet not found in " + jarPath + ": " + stylesheetPath + ", ";
			}
                        // if class loader jar invocation not working then here is a bad hack for build testing: use local path instead
			File stylesheetFile = new File("lib/stylesheets/", ConfigurationProperties.STYLESHEET_HTML_DOCUMENTATION);
                        if ((stylesheetInputStream == null) && !stylesheetFile.exists())
				errorNotice += "Stylesheet not found: " + stylesheetFile.getAbsolutePath() + ", ";

			// TODO check for subdirectory writeable
			File outputFile = outputFilePath.toFile();
			if (outputFile == null)
			{
					errorNotice += "outputFile not created: " + outputFilePath.getFileName() + ", ";
			}
//			else if (!outputFile.canWrite())
//					errorNotice += "outputFile not writable: " + outputFile.getAbsolutePath() + ", ";

			if (ConfigurationProperties.getXsltEngine().equals(ConfigurationProperties.XSLT_ENGINE_SAXON))
			{
				// reference: Saxon-HE 9.7 documentation and samples
				// S9APIExamples.jsail: private static class TransformA implements S9APIExamples.Test

				Processor           processor = new Processor(false);
				XsltCompiler     xsltCompiler = processor.newXsltCompiler();
				XsltExecutable xsltExecutable;
                                if (stylesheetInputStream != null)
                                    xsltExecutable = xsltCompiler.compile (new StreamSource(stylesheetInputStream));
                                else
                                    xsltExecutable = xsltCompiler.compile (new StreamSource(stylesheetFile)); // this fallback might easily fail

				XdmNode source = processor.newDocumentBuilder().build(new StreamSource(intermediateX3DFilePath.toFile()));
				Serializer out = processor.newSerializer(outputFile);
				out.setOutputProperty(Serializer.Property.METHOD, "html");
				out.setOutputProperty(Serializer.Property.INDENT, "yes");
				XsltTransformer xsltTransformer = xsltExecutable.load();
				xsltTransformer.setInitialContextNode(source);
				xsltTransformer.setDestination(out);
				if (parameterName1.length() > 0)
					xsltTransformer.setParameter(new QName(parameterName1), new XdmAtomicValue(parameterValue1));
				if (parameterName2.length() > 0)
					xsltTransformer.setParameter(new QName(parameterName2), new XdmAtomicValue(parameterValue2));
                                if (stylesheetInputStream != null)
                                    xsltTransformer.setParameter(new QName("produceSVGfigures"), new XdmAtomicValue("false"));
                                xsltTransformer.transform();
			}
			else if (ConfigurationProperties.getXsltEngine().equals(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA))
			{
                                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    //                          factory.setNamespaceAware(true);
    //                          factory.setValidating    (true);

				DocumentBuilder builder = factory.newDocumentBuilder();
				Document x3dDocument = builder.parse(intermediateX3DFilePath.toFile());
				TransformerFactory tFactory = TransformerFactory.newInstance();
                                StreamSource styleStreamSource;
                                if (stylesheetInputStream != null)
                                    styleStreamSource = new StreamSource(stylesheetInputStream);
                                                else
                                    styleStreamSource = new StreamSource(stylesheetFile);
                                                Transformer transformer = tFactory.newTransformer(styleStreamSource);
                                                if (parameterName1.length() > 0)
                                                        transformer.setParameter(parameterName1, parameterValue1);
                                                if (parameterName2.length() > 0)
                                                        transformer.setParameter(parameterName2, parameterValue2);
                                if (stylesheetInputStream != null)
                                        transformer.setParameter("produceSVGfigures", "false");

                                DOMSource       domSource = new DOMSource(x3dDocument);
                                StreamResult streamResult = new StreamResult(outputFile);
                                transformer.transform(domSource, streamResult);
			}
			else // no joy
			{
				errorNotice = "Invalid ConfigurationProperties.getXsltEngine() value='" + ConfigurationProperties.getXsltEngine() +
									 "', legal values are ConfigurationProperties.XSLT_ENGINE_SAXON or ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA";
//				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			if (ConfigurationProperties.isDeleteIntermediateFiles()) // clean up when done
				intermediateX3DFilePath.toFile().deleteOnExit();
		}
		catch (IOException | ParserConfigurationException | TransformerException | SAXException exception)
		{
			throw new org.web3d.x3d.sai.X3DException(errorNotice + exception.toString() + " exception when transforming and creating fileName " + outputFilePath +
				", unable to save result: " + exception);
		}
		catch (SaxonApiException saxonApiException)
		{
//			Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, saxonApiException);

			throw new org.web3d.x3d.sai.X3DException(errorNotice + "SaxonApiException when transforming and creating fileName " + outputFilePath +
				", unable to save result: " + saxonApiException);
		}
		return outputFilePath.toFile(); // success
	}

	/**
	 * Serialize scene graph using <i>toFileX3D()</i> and then create a new pretty-print HTML file with extension <i>.html</i>, suitable for documentation purposes.
     * Also create SVG output file (with same base name) for Extrusion crossSection, if found.
	 * @see ConfigurationProperties#STYLESHEET_HTML_DOCUMENTATION
	 * @see ConfigurationProperties#STYLESHEET_ExtrusionCrossSectionSVG
	 * @see X3D#toStringX3D()
	 * @see X3D#toFileX3D(String)
	 * @see X3D#toFileJava(String)
	 * @see X3D#toFileJSON(String)
	 * @see X3D#toFilePython(String)
	 * @see X3D#toFileX3DOM(String)
	 * @see X3D#toFileX_ITE(String,String)
	 * @see X3D#toFileCobweb(String,String)
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding" target="_blank">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE" target="_blank">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html" target="_blank">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip" target="_blank">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles" target="_blank">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileHtmlDocumentation(String fileName)
	{
            String   svgFileName = fileName;
            if (     svgFileName.endsWith(".html"))
                     svgFileName = svgFileName.replace(".html", ".svg");
            else if (svgFileName.endsWith(".xhtml"))
                     svgFileName = svgFileName.replace(".xhtml", ".svg");
            else     svgFileName+= ".svg";

//          if (true) // TODO consider adding method to check for presence of element (e.g. Extrusion)
//                    // though likely better to let stylesheet handle that
                   toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_ExtrusionCrossSectionSVG, svgFileName);

            return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_HTML_DOCUMENTATION,           fileName);
	}

	// TODO refactor XSLT conversion methods to re-use common code

    /** Return a file found within X3DJSAIL jar
      * @param internalPath is relative path to file from top of jar
      * @param fileName is fileName of interest to retrieve
      * @return resulting temporary File object that is deleted when program invocation ends
      */
    public static File getTempFileFromX3dJsailJar(String internalPath, String fileName)
    {
        // background references
        // https://stackoverflow.com/questions/20389255/reading-a-resource-file-from-within-jar/20389418#20389418
        // https://stackoverflow.com/questions/403256/how-do-i-read-a-resource-file-from-a-java-jar-file
        // https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getResourceAsStream(String)
        // https://stackoverflow.com/questions/11501418/is-it-possible-to-create-a-file-object-from-inputstream
        // targets: X3DJSAIL.4.0.full.jar and X3DJSAIL.4.0.classes.jar

        final String systemClassPath = ConfigurationProperties.getClassPath();

        String currentX3dJsailJarName = new String();
        String errorNotice        = new String();
        boolean foundX3dJsailJar = false;
        if    ( systemClassPath.contains("X3DJSAIL"))
        {
                 currentX3dJsailJarName = systemClassPath.substring(systemClassPath.indexOf("X3DJSAIL"));
            if ((systemClassPath.indexOf("X3DJSAIL") > 0) &&
                (currentX3dJsailJarName.indexOf(java.io.File.pathSeparatorChar) > 0))
                 currentX3dJsailJarName = currentX3dJsailJarName.substring(0,currentX3dJsailJarName.indexOf(java.io.File.pathSeparatorChar));
            // X3DJSAIL.*.jar now extracted as currentX3dJsailJarName
            for (String nextX3dJsailJar : ConfigurationProperties.X3DJSAIL_JAR_RELEASE_VERSIONS)
            {
                if (currentX3dJsailJarName.equals(nextX3dJsailJar))
                {
                     foundX3dJsailJar = true;
                     break;
                }
            }
        }
        if (!foundX3dJsailJar)
        {
            errorNotice = ConfigurationProperties.ERROR_CONFIGURATION_X3DJSAIL + " X3DJSAIL jar archive \"" + currentX3dJsailJarName
                            + "\" not found in CLASSPATH=" + systemClassPath + "\n";
            errorNotice += "  invoked from getTempFileFromX3dJsailJar(" + internalPath + ", " + fileName + ")\n";
           	System.out.println(errorNotice);
// TODO     throw new InvalidFieldValueException(errorNotice);
        }

        // TODO jar flexibility, once working
        // must end in !/ https://stackoverflow.com/questions/38488492/documentbuilder-gives-java-net-malformedurlexception-no-in-spec
        String  jarPath = "jar:file:" + currentX3dJsailJarName + "!/";
        String filePath = internalPath;
        if (!filePath.startsWith("/"))
             filePath = "/" + filePath;
        if (!filePath.endsWith("/"))
             filePath += "/";
        filePath += fileName;
        String fileNameRoot  = fileName;
        String fileExtension = new String();
        if (fileName.contains("."))
        {
            fileNameRoot  = fileName.substring(0,fileName.lastIndexOf("."));
            fileExtension = fileName.substring(  fileName.lastIndexOf("."));
        }
        if (ConfigurationProperties.isDebugModeActive())
        {
        	errorNotice += "[diagnostic] System java.class.path=" + systemClassPath   + "\n";
        	errorNotice += "[diagnostic] jarPath=" + jarPath + ", ";
        	errorNotice +=             "filePath=" + filePath + "\n";
        }
        // .class or getClass().getResourceAsStream looks within each classpath .jar for stylesheetPath
        InputStream fileInputStream = X3D.class.getResourceAsStream(filePath);
        if (fileInputStream == null)
        {
        	errorNotice += "File not found in " + jarPath + ": " + filePath + ", ";
        }
        // if class loader jar invocation not working then here is a bad hack for build testing: use local path instead
//        File stylesheetFile = new File("lib/stylesheets/", ConfigurationProperties.STYLESHEET_HTML_DOCUMENTATION);
//        if ((fileInputStream == null) && !stylesheetFile.exists())
//        	errorNotice += "Stylesheet not found: " + stylesheetFile.getAbsolutePath() + ", ";

        File outputFile;
        try
        {
            outputFile = File.createTempFile(fileNameRoot, fileExtension);
            if (outputFile == null)
            {
            	errorNotice += "*** [getTempFileFromX3dJsailJar() internal error] outputFile not created: " + fileName + ", ";
            }
//          else if (!outputFile.canWrite())
//            	     errorNotice += "outputFile not writable: " + outputFile.getAbsolutePath() + ", ";
            outputFile.deleteOnExit();
            java.nio.file.Files.copy (fileInputStream, outputFile.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
        }
        catch (IOException ex)
        {
            ex.printStackTrace();
            outputFile = null;
        }
        System.out.flush();
        if      (!errorNotice.isEmpty() && errorNotice.trim().startsWith("[diagnostic]"))
                 System.out.println ("       "        + errorNotice.trim() + "\n");
        else if (!errorNotice.isEmpty())
                 System.out.println ("[error] " + errorNotice.trim());

        System.out.flush();
        return outputFile;
    }

	/** Private method to read a file as a String
	 * @see https://stackoverflow.com/questions/326390/how-do-i-create-a-java-string-from-the-contents-of-a-file
	 * @return file contents
	 */
	private String readFile(String file) throws IOException
	{
		BufferedReader reader = new BufferedReader(new FileReader (file));
		String         line;
		StringBuilder  stringBuilder = new StringBuilder();
		String         ls = System.getProperty("line.separator");

		try {
			while((line = reader.readLine()) != null)
			{
				stringBuilder.append(line);
				stringBuilder.append(ls);
			}
			return stringBuilder.toString();
		}
		finally
		{
			reader.close();
		}
	}

	/**
	 * Serialize scene graph using X3dToJson.xslt stylesheet to create a new JSON-encoding string.
	 * @see X3D#toFileJSON(String)
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
	 * @see <a href="https://www.web3d.org/wiki/index.php/X3D_JSON_Encoding" target="_blank">X3D JSON Encoding</a>
	 * @see <a href="https://www.web3d.org/x3d/stylesheets/X3dToJson.html" target="_blank">X3D to JSON Stylesheet Converter</a>
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringJSON()
	{
		String temporaryFileName = "temporaryJsonOutputFile.json";

		try
		{
			File     fileJSON = toFileJSON(temporaryFileName);

			if  ((fileJSON != null) && fileJSON.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileJSON.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException when converting toStringJSON(): " + ioe);
		}
		return "";
	}

	/**
	 * Serialize scene graph using X3dToPython.xslt stylesheet to create a new Python-language string.
	 * @see X3D#toFilePython(String)
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
	 * @see <a href="https://www.python.org" target="_blank">Python.org</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Python_(programming_language)" target="_blank">Python (programming language)</a>
	 * @see <a href="https://pypi.org/project/x3d" target="_blank">Python X3D Package x3d.py</a>
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringPython()
	{
		String temporaryFileName = "temporaryPythonOutputFile.py";

		try
		{
			File     filePython = toFilePython(temporaryFileName);

			if  ((filePython != null) && filePython.exists())
			{
				String fileContents = readFile(temporaryFileName);
				filePython.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException when converting toStringPython(): " + ioe);
		}
		return "";
	}

	/**
	 * Serialize scene graph using toFileJava() to create new Java source as a string.
	 * @see X3D#toFileJava(String)
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringJava()
	{
		String temporaryFileName = "temporaryJavaOutputFile.java";

		try
		{
			File     fileJava = toFileJava(temporaryFileName);

			if  ((fileJava != null) && fileJava.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileJava.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (Exception e)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Serialize scene graph using NodeSerializer.js to create a JavaScript string.
	 * @see X3D#toFileJavaScript(String)
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringJavaScript()
	{
		String temporaryFileName = "temporaryJavaScriptOutputFile.js";

		try
		{
			File     fileJavaScript = toFileJavaScript(temporaryFileName);

			if  ((fileJavaScript != null) && fileJavaScript.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileJavaScript.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (Exception e)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Serialize scene graph using NodeSerializer.js to create a JavaScript file.
	 * @author John Carlson
	 * @see X3D#toStringJavaScript()
	 * @see SFString#isNMTOKEN(String)
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @param fileName name of file to create and save, can include local directory path, must end with .js
	 * @return File containing result (if operation succeeds), empty otherwise
	 */
    public File toFileJavaScript(String fileName)
    {
		return toFileJavaScript(fileName, false); // no license
    }
	/**
	 * Serialize scene graph using NodeSerializer.js to create a JavaScript file, with boolean indicating whether to include open-source license.
	 * @author John Carlson
	 * @see X3D#toStringJavaScript()
	 * @see SFString#isNMTOKEN(String)
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @param fileName name of file to create and save, can include local directory path, must end with .js
	 * @param includeWeb3dLicense whether to include license
	 * @return File containing result (if operation succeeds), empty otherwise
	 */
    public File toFileJavaScript(String fileName, boolean includeWeb3dLicense)
    {
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileJavaScript(fileName, includeWeb3dLicense) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_X3D + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_JAVASCRIPT))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_JAVASCRIPT + "\"");
		}
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		String className = fileName.substring(0,fileName.indexOf(".js"));
		if (className.contains("/"))
			className = className.substring(fileName.lastIndexOf("/")  + 1); // strip path
		if (className.contains("\\/"))
			className = className.substring(fileName.lastIndexOf("\\") + 1); // strip path

		// XSLT stylesheet parameter names and values
		String parameterName1  = "className";
		String parameterValue1 =  className;
		String parameterName2  = "";
		String parameterValue2 = "";
		if (includeWeb3dLicense)
		{
				parameterName2  = "includeLicenseoriginals";
				parameterValue2 = Boolean.toString(includeWeb3dLicense);
		}
		return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_JAVASCRIPT, fileName,
					parameterName1, parameterValue1, parameterName2, parameterValue2);
	}

	/**
	 * Serialize scene graph using STYLESHEET_HTML_DOCUMENTATION to create a new X3DOM html page as a string.
	 * @see X3D#toFileHtmlDocumentation(String)
	 * @see X3D#FILE_EXTENSION_HTML
	 * @see X3D#FILE_EXTENSION_XHTML
	 * @see ConfigurationProperties#STYLESHEET_HTML_DOCUMENTATION
	 * @see <a href="https://www.x3dom.org" target="_blank">X3DOM open-source X3D player</a>
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringHtmlDocumentation()
	{
		String temporaryFileName = "temporaryPrettyPrintOutputFile.html";

		try
		{
			File     fileHTML = toFileHtmlDocumentation(temporaryFileName);

			if  ((fileHTML != null) && fileHTML.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileHTML.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException when converting toHtmlDocumentation(): " + ioe);
		}
		return "";
	}

	/**
	 * Produce model meta information as `name`=`value` pairs, providing markdown output as a string.
	 * @see X3D#toFileModelMetaMarkdown(String)
	 * @see X3D#FILE_EXTENSION_MARKDOWN
	 * @see ConfigurationProperties#STYLESHEET_MODEL_META_TO_MARKDOWN
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringModelMetaMarkdown()
	{
		String temporaryFileName = "temporaryModelMetaMarkdownOutputFile.x3d";

		try
		{
			File     fileMarkdown = toFileModelMetaMarkdown(temporaryFileName);

			if  ((fileMarkdown != null) && fileMarkdown.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileMarkdown.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException when converting toStringModelMetaMarkdown(): " + ioe);
		}
		return "";
	}

	/**
	 * Produce alternate cleaned-up X3D scene using STYLESHEET_X3DTIDY, providing output as a string.
	 * @see X3D#toFileX3dTidy(String)
	 * @see X3D#FILE_EXTENSION_X3D
	 * @see ConfigurationProperties#STYLESHEET_X3DTIDY
	 * @see <a href="https://www.web3d.org/x3d/stylesheets/X3dTidy.html" target="_blank">X3D Tidy for Scene Cleanup, Corrections and Modifications</a>
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringX3dTidy()
	{
		String temporaryFileName = "temporaryPrettyPrintOutputFile.x3d";

		try
		{
			File     fileHTML = toFileX3dTidy(temporaryFileName);

			if  ((fileHTML != null) && fileHTML.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileHTML.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException when converting toStringX3dTidy(): " + ioe);
		}
		return "";
	}

	/**
	 * Serialize scene graph using STYLESHEET_X3DOM to create a new X3DOM html page as a string.
	 * @see X3D#toFileX3DOM(String)
	 * @see X3D#FILE_EXTENSION_HTML
	 * @see X3D#FILE_EXTENSION_XHTML
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see <a href="https://www.x3dom.org" target="_blank">X3DOM open-source X3D player</a>
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringX3DOM()
	{
		String temporaryFileName = "temporaryX3domOutputFile.html";

		try
		{
			File     fileX3DOM = toFileX3DOM(temporaryFileName);

			if  ((fileX3DOM != null) && fileX3DOM.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileX3DOM.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException when converting toStringX3DOM(): " + ioe);
		}
		return "";
	}

	/**
	 * Serialize scene graph using STYLESHEET_X3DOM (with appropriate parameters) to create a new X_ITE html page as a string.
	 * @see X3D#toFileX_ITE(String,String)
	 * @see <a href="https://create3000.de/x_ite" target="_blank">X_ITE open-source X3D player</a>
	 * @see X3D#FILE_EXTENSION_HTML
	 * @see X3D#FILE_EXTENSION_XHTML
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see ConfigurationProperties#STYLESHEET_X_ITE
	 * @param sourceSceneName X3D file to load and view
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringX_ITE(String sourceSceneName)
	{
		String temporaryFileName = "temporaryX3domOutputFile.html";

		try
		{
			File     fileX_ITE = toFileX_ITE(sourceSceneName, temporaryFileName);

			if  ((fileX_ITE != null) && fileX_ITE.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileX_ITE.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
			throw new org.web3d.x3d.sai.X3DException("IOException when converting toStringX_ITE(): " + ioe);
		}
		return "";
	}

	/**
	 * Serialize scene graph using X3dToJson.xslt stylesheet to create a new JSON-encoding X3D file with extension <i>json</i>.
	 * @see X3D#toStringJSON()
	 * @see X3D#toStringX3D()
	 * @see X3D#toFileX3D(String)
	 * @see X3D#toFileJava(String)
	 * @see X3D#toFileHtmlDocumentation(String)
	 * @see X3D#toFileX_ITE(String,String)
	 * @see X3D#toFileCobweb(String,String)
	 * @see X3D#toFileX3DOM(String)
	 * @see X3D#FILE_EXTENSION_JSON
	 * @see X3D#FILE_EXTENSION_JAVASCRIPT
	 * @see ConfigurationProperties#STYLESHEET_JSON
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJson.xslt" target="_blank">X3dToJson.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.json" target="_blank">examples/HelloWorldProgramOutput.json</a>
	 * @see <a href="https://www.web3d.org/wiki/index.php/X3D_JSON_Encoding" target="_blank">X3D JSON Encoding</a>
	 * @see <a href="https://www.web3d.org/x3d/stylesheets/X3dToJson.html" target="_blank">X3D to JSON Stylesheet Converter</a>
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding" target="_blank">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE" target="_blank">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html" target="_blank">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip" target="_blank">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles" target="_blank">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileJSON(String fileName)
	{
            return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_JSON, fileName,
                        "normalizeCommentWhitespace", Boolean.toString(ConfigurationProperties.isNormalizeCommentWhitespace()));
	}
	/**
	 * Serialize scene graph using X3dToPython.xslt stylesheet to create a new Python-language X3D file with extension <i>py</i>.
	 * @see X3D#toStringPython()
	 * @see X3D#toStringJSON()
	 * @see X3D#toStringX3D()
	 * @see X3D#toFileX3D(String)
	 * @see X3D#toFilePython(String)
	 * @see X3D#toFileHtmlDocumentation(String)
	 * @see X3D#toFileX_ITE(String,String)
	 * @see X3D#toFileCobweb(String,String)
	 * @see X3D#toFileX3DOM(String)
	 * @see X3D#FILE_EXTENSION_PYTHON
	 * @see ConfigurationProperties#STYLESHEET_PYTHON
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
	 * @see <a href="../../../../../../lib/stylesheets/X3dToPython.xslt" target="_blank">X3dToPython.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.py" target="_blank">examples/HelloWorldProgramOutput.py</a>
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding" target="_blank">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE" target="_blank">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html" target="_blank">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip" target="_blank">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles" target="_blank">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFilePython(String fileName)
	{
            return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_PYTHON, fileName,
                        "normalizeCommentWhitespace", Boolean.toString(ConfigurationProperties.isNormalizeCommentWhitespace()));
	}
	/**
	 * Serialize scene graph using X3dToJava.xslt stylesheet to create a new Java source file with extension <i>java</i>, no default license included.
	 * @see X3D#toFileJava(String,boolean)
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJava.xslt" target="_blank">X3dToJava.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.java" target="_blank">examples/HelloWorldProgramOutput.java</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileJava(String fileName)
	{
		return toFileJava(fileName, false); // no license
	}
	/**
	 * Serialize scene graph using X3dToJava.xslt stylesheet to create a new Java source file with extension <i>java</i>.
	 * @see X3D#toStringX3D()
	 * @see X3D#toFileX3D(String)
	 * @see X3D#toFileJSON(String)
	 * @see X3D#toFilePython(String)
	 * @see X3D#toFileHtmlDocumentation(String)
	 * @see X3D#toFileX_ITE(String,String)
	 * @see X3D#toFileCobweb(String,String)
	 * @see X3D#toFileX3DOM(String)
	 * @see X3D#FILE_EXTENSION_JSON
	 * @see X3D#FILE_EXTENSION_JAVASCRIPT
	 * @see ConfigurationProperties#STYLESHEET_JSON
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJava.xslt" target="_blank">X3dToJava.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.java" target="_blank">examples/HelloWorldProgramOutput.java</a>
	 * @see <a href="https://www.web3d.org/wiki/index.php/X3D_JSON_Encoding">X3D JSON Encoding</a>
	 * @see <a href="https://www.web3d.org/x3d/stylesheets/X3dToJson.html">X3D to JSON Stylesheet Converter</a>
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @param includeWeb3dLicense whether to insert default open-source Web3D license at top of source file
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileJava(String fileName, boolean includeWeb3dLicense)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileJava(fileName, includeWeb3dLicense) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_X3D + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_JAVA))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_JAVA + "\"");
		}
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		String className = fileName.substring(0,fileName.indexOf(".java"));
		if (className.contains("/"))
			className = className.substring(fileName.lastIndexOf("/")  + 1); // strip path
		if (className.contains("\\/"))
			className = className.substring(fileName.lastIndexOf("\\") + 1); // strip path

		// XSLT stylesheet parameter names and values
		String parameterName1  = "className";
		String parameterValue1 =  className;
		String parameterName2  = "";
		String parameterValue2 = "";
		if (includeWeb3dLicense)
		{
				parameterName2  = "includeLicenseoriginals";
				parameterValue2 = Boolean.toString(includeWeb3dLicense);
		}
		return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_JAVA, fileName,
					parameterName1, parameterValue1, parameterName2, parameterValue2);
	}

        /* whether to include subdirectory paths when creating markdown with  */
        private boolean includeSubdirectoryPaths = true;

        /** Set whether to include subdirectory paths when creating markdown (default is true)
         * @param value whether to omit subdirectory paths when creating markdown (default is true)
         * @see X3D#toFileModelMetaMarkdown(String)
         * @see X3D#toStringModelMetaMarkdown()
         * @see X3D#FILE_EXTENSION_MARKDOWN
         * @see ConfigurationProperties#STYLESHEET_MODEL_META_TO_MARKDOWN
         */
        public void setIncludeSubdirectoryPaths (boolean value)
        {
            includeSubdirectoryPaths = value;
        }

	/**
	 * Create model meta information as `name`=`value` pairs, providing markdown output as an output file having extension <i>.md</i>.
	 * @see X3D#toStringModelMetaMarkdown()
	 * @see X3D#toStringX3D()
	 * @see X3D#toFileX3D(String)
	 * @see X3D#toFileJava(String)
	 * @see X3D#toFileJSON(String)
	 * @see X3D#toFilePython(String)
	 * @see X3D#toFileHtmlDocumentation(String)
	 * @see X3D#toFileX_ITE(String,String)
	 * @see X3D#toFileCobweb(String,String)
	 * @see SFString#isNMTOKEN(String)
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @see ConfigurationProperties#STYLESHEET_MODEL_META_TO_MARKDOWN
	 * @see <a href="https://www.web3d.org/x3d/stylesheets/X3dTidy.html">X3D Tidy for Scene Cleanup, Corrections and Modifications</a>
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileModelMetaMarkdown(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileX3dTidy(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_MARKDOWN + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_MARKDOWN))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_MARKDOWN + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("[warning] " + fileName + " does not meet suggested X3D naming conventions, continuing...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("[warning] " + fileName + " is not a valid NMTOKEN, continuing...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
        	return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_MODEL_META_TO_MARKDOWN, fileName, "includeSubdirectoryPaths", Boolean.toString(includeSubdirectoryPaths)); // one stylesheet parameter
	}

	/**
	 * Create alternate cleaned-up X3D scene using STYLESHEET_X3DTIDY within an output file having extension <i>.x3d</i>.
	 * @see X3D#toStringX3dTidy()
	 * @see X3D#toStringX3D()
	 * @see X3D#toFileX3D(String)
	 * @see X3D#toFileJava(String)
	 * @see X3D#toFileJSON(String)
	 * @see X3D#toFilePython(String)
	 * @see X3D#toFileHtmlDocumentation(String)
	 * @see X3D#toFileX_ITE(String,String)
	 * @see X3D#toFileCobweb(String,String)
	 * @see SFString#isNMTOKEN(String)
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @see ConfigurationProperties#STYLESHEET_X3DTIDY
	 * @see <a href="https://www.web3d.org/x3d/stylesheets/X3dTidy.html">X3D Tidy for Scene Cleanup, Corrections and Modifications</a>
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileX3dTidy(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileX3dTidy(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_X3D + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_X3D))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_X3D + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("[warning] " + fileName + " does not meet suggested X3D naming conventions, continuing...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("[warning] " + fileName + " is not a valid NMTOKEN, continuing...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
        return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_X3DTIDY, fileName); // no stylesheet parameters
	}

	/**
	 * Create displayable scene page rendered with X3DOM, using STYLESHEET_X3DOM by serializing XML syntax within an XHTML file having extension <i>.xhtml</i>.
	 * @see <a href="https://www.x3dom.org" target="_blank">X3DOM open-source X3D player</a>
	 * @see X3D#toStringX3D()
	 * @see X3D#toFileX3D(String)
	 * @see X3D#toFileJava(String)
	 * @see X3D#toFileJSON(String)
	 * @see X3D#toFilePython(String)
	 * @see X3D#toFileHtmlDocumentation(String)
	 * @see X3D#toFileX_ITE(String,String)
	 * @see X3D#toFileCobweb(String,String)
	 * @see SFString#isNMTOKEN(String)
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileX3DOM(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileX3DOM(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_HTML + "\" or \"" + FILE_EXTENSION_XHTML + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_HTML) && !fileName.endsWith(FILE_EXTENSION_XHTML))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_HTML + "\" or \"" + FILE_EXTENSION_XHTML + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("[warning] " + fileName + " does not meet suggested X3D naming conventions, continuing...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("[warning] " + fileName + " is not a valid NMTOKEN, continuing...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
        return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_X3DOM, fileName, "player", "X3DOM");
	}

	/**
	 * Create displayable scene page rendered with X_ITE (formerly Cobweb) using STYLESHEET_X3DOM and special settings, by serializing XML syntax within an XHTML file having extension <i>.xhtml</i>.
	 * @see <a href="https://create3000.de/x_ite" target="_blank">X_ITE open-source X3D player</a>
	 * @see X3D#toStringX3D()
	 * @see X3D#toFileX3D(String)
	 * @see X3D#toFileJava(String)
	 * @see X3D#toFileJSON(String)
	 * @see X3D#toFilePython(String)
	 * @see X3D#toFileHtmlDocumentation(String)
	 * @see X3D#toFileX3DOM(String)
	 * @see X3D#toFileX_ITE(String,String)
	 * @see X3D#toFileCobweb(String,String)
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param sourceSceneName X3D file to load and view
	 * @param resultFileName name of file to create and save, can include local directory path, must end with .html (preferred) or .xhtml
	 * @return File containing result (if operation succeeds), null otherwise
	 */
        // https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html
        // https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html
        // https://stackoverflow.com/questions/1858021/suppress-deprecated-import-warning-in-java
    @SuppressWarnings("deprecation")
	public File toFileX_ITE(String sourceSceneName, String resultFileName)
	{
		return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_COBWEB, resultFileName,
			"player", "Cobweb", "urlScene", sourceSceneName);
	}

	/**
	 * Create displayable scene page rendered with X_ITE (formerly Cobweb) using STYLESHEET_X3DOM and special settings, by serializing XML syntax within an XHTML file having extension <i>.xhtml</i>.
	 * @see <a href="https://create3000.de/x_ite" target="_blank">X_ITE open-source X3D player</a>
	 * @see X3D#toStringX3D()
	 * @see X3D#toFileX3D(String)
	 * @see X3D#toFileJava(String)
	 * @see X3D#toFileJSON(String)
	 * @see X3D#toFilePython(String)
	 * @see X3D#toFileHtmlDocumentation(String)
	 * @see X3D#toFileX3DOM(String)
	 * @see X3D#toFileX_ITE(String,String)
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param sourceSceneName X3D file to load and view
	 * @param resultFileName name of file to create and save, can include local directory path, must end with .html (preferred) or .xhtml
	 * @return File containing result (if operation succeeds), null otherwise
	 */
        @Deprecated
	public File toFileCobweb(String sourceSceneName, String resultFileName)
	{
		return toFileX_ITE (sourceSceneName, resultFileName);
	}

	/**
	 * Load new model from a zip file, using unzip to extract the model plus any associated files into the same path location.
	 * @see X3D#fromFileZIP(String,String,String)
	 * @param zipFileName name of zip file to load, can include local directory path, must end with .zip
	 * @param outputFileName name of output file to save, can include local directory path, must end with .x3d or .xml
	 * @return boolean if operation succeeds in creating this X3DObject, false otherwise
	 */
    public boolean fromFileZIP(String zipFileName, String outputFileName)
	{
		return fromFileZIP(zipFileName, outputFileName, ""); // use whatever filename is found internally
	}

	/**
	 * Load new model from a zip file, using unzip to extract the model plus any associated files into the same path location.
	 * <br ><br >
	 * <i>Warning:</i> If no <code>modelFileName</code> is provided, then the first <code>.x3d</code> model encountered in the zip file is returned (if any).
	 * <br ><br >
	 * <i>Warning:</i> this method overwrites any previously existing file versions when decompressing.
	 * @see <a href="https://en.wikipedia.org/wiki/Zip_(file_format)">Wikipedia: ZIP file format</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/package-summary.html">Java Package java.util.zip for ZIP and GZIP file formats</a>
	 * @see X3D#FILE_EXTENSION_EXI
	 * @see X3D#FILE_EXTENSION_GZIP
	 * @see X3D#FILE_EXTENSION_ZIP
	 * @see X3D#fromFileEXI(String)
	 * @see X3D#fromFileGZIP(String)
	 * @see X3D#toFileZIP(String,String)
	 * @see X3D#fromFileZIP(String,String)
	 * @param zipFileName name of zip file to load, can include local directory path, must end with .zip
	 * @param outputFileName name of output file to save, can include local directory path, must end with .x3d or .xml
	 * @param modelFileName name of model file to load, can include local directory path, must end with .x3d
	 * @return boolean if operation succeeds in creating this X3DObject, false otherwise
	 */
    public boolean fromFileZIP(String zipFileName, String outputFileName, String modelFileName)
	{
		if (modelFileName == null)
			modelFileName = new String(); // avoid NPE
		String errorNotice = new String();
		if ((zipFileName == null || zipFileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("fromFileZIP(zipFileName, modelFileName) zipFileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_ZIP + "\"");
		}
		if (!zipFileName.endsWith(FILE_EXTENSION_ZIP))
		{
			errorNotice += ("fromFileZIP zipFileName " + zipFileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_ZIP + "\"" + "\n");
			System.out.println (errorNotice);
			return false;
		}
		if (!zipFileName.endsWith(FILE_EXTENSION_ZIP))
		{
			errorNotice += ("fromFileZIP zipFileName " + zipFileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_ZIP + "\"" + "\n");
			System.out.println (errorNotice);
			return false;
		}
		Path inputFilePath = Paths.get(zipFileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] fromFileZIP zipFileName path=" + inputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		// Elliotte Rusty Harold, "Java I/O" Chapter 10 Compressing Streams, O'Reilly and Associates, 2nd edition, May 2006.
		// Example 10-11, adapted

		File zipFile = new File(zipFileName);
		if (!zipFile.exists() || (zipFile == null))
		{
			errorNotice += "zipFileName " + zipFileName + "not found\n";
			System.out.println (errorNotice);
			return false;
		}
		try
		{
			FileInputStream fileInputStream = new FileInputStream(zipFile);
			ZipInputStream  zipInputStream = new  ZipInputStream(fileInputStream);
			ZipEntry        zipEntry       = null;
			while ((zipEntry = zipInputStream.getNextEntry()) != null)
			{
				if (ConfigurationProperties.isDebugModeActive())
				{
					System.out.println ("Unzipping " + zipEntry.getName() + " size=" + zipEntry.getSize() + " bytes");
				}

				if (outputFileName.isEmpty())
				{
					outputFileName = zipEntry.getName(); // first found .x3d file in .zip
					System.out.println ("[warning] fromFileZIP() outputFileName was empty, unzipping found initial X3D file to save: " + outputFileName);
				}
				if (modelFileName.isEmpty() && (zipEntry.getName().endsWith(FILE_EXTENSION_X3D) ||
                                                zipEntry.getName().endsWith(FILE_EXTENSION_XML)))
				{
					modelFileName = zipEntry.getName(); // first found .x3d file in .zip
					System.out.println ("[warning] fromFileZIP() modelFileName was empty, unzipping found initial X3D file to load: " + modelFileName);
				}
				File priorFile = new File(outputFileName);
				if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
				{
					System.out.println ("Note: fromFileZIP() is overwriting prior file " + outputFileName);
				}
				else if  (priorFile.exists())
				{
					System.out.println ("[warning] fromFileZIP() is not allowed to overwrite prior file: " + outputFileName);
					System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
					return false;
				}
				// TODO add optional output directory path
				FileOutputStream fileOutputStream = new FileOutputStream (outputFileName);
				for (int c = zipInputStream.read(); c != -1; c = zipInputStream.read())
				{
					fileOutputStream.write(c);
				}
				zipInputStream.closeEntry();
				fileOutputStream.close();
				System.out.println ("Unzipped " + outputFileName + " size=" + zipEntry.getSize() + " bytes");
			}
			zipInputStream.close();

			if (modelFileName.isEmpty())
			{
				System.out.println ("fromZIP output modelFileName not found in zipFileName " + zipFileName + ", no X3D model to load");
				return false;
			}

			X3DLoaderDOM x3dLoader = new X3DLoaderDOM();
			boolean x3dLoaderSuccess = x3dLoader.loadModelFromFileX3D(modelFileName);
			if (x3dLoaderSuccess)
				replace((X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[) x3dLoader.getX3dObjectTree());
		}
		catch (IOException e)
		{
			errorNotice += "zipFileName " + zipFileName + "not readable\n";
			System.out.println (errorNotice);
			return false;
		}
		return hasHead() || hasScene(); // success test
	}

	/**
	 * Load new model from a gz gzip file, using ungzip to extract the model into the same path location.
	 * <br ><br >
	 * <i>Warning:</i> this method overwrites any previously existing file versions when decompressing.
	 * @see <a href="https://en.wikipedia.org/wiki/Gzip">Wikipedia: GZIP file format</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/package-summary.html">Java Package java.util.zip for ZIP and GZIP file formats</a>
	 * @see X3D#FILE_EXTENSION_EXI
	 * @see X3D#FILE_EXTENSION_GZIP
	 * @see X3D#FILE_EXTENSION_ZIP
	 * @see X3D#fromFileEXI(String)
	 * @see X3D#fromFileZIP(String,String)
	 * @see X3D#toFileGZIP(String)
	 * @param gzipFileName name of file to load, can include local directory path, must end with .exi
	 * @return boolean if operation succeeds in creating this X3DObject, false otherwise
	 */
    public boolean fromFileGZIP(String gzipFileName)
	{
		String errorNotice = new String();
		if ((gzipFileName == null || gzipFileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("fromFileGZIP(gzipFileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_GZIP + "\"");
		}
		if (!gzipFileName.endsWith(FILE_EXTENSION_GZIP))
		{
			errorNotice += ("gzipFileName " + gzipFileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_GZIP + "\"" + "\n");
		}
		Path inputFilePath = Paths.get(gzipFileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] gzipFileName path=" + inputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		// Elliotte Rusty Harold, "Java I/O" Chapter 10 Compressing Streams, O'Reilly and Associates, 2nd edition, May 2006.
		// Example 10-11, adapted

		File gzipFile = new File(gzipFileName);
		if (!gzipFile.exists() || (gzipFile == null))
		{
			errorNotice += "gzipFileName " + gzipFileName + "not found\n";
			System.out.println (errorNotice);
			return false;
		}
		String modelFileName = gzipFileName;
		if (modelFileName.contains(FILE_EXTENSION_GZIP))
			modelFileName = modelFileName.substring(0, modelFileName.lastIndexOf(FILE_EXTENSION_GZIP));
		if (!modelFileName.endsWith (FILE_EXTENSION_X3D))
			 modelFileName += FILE_EXTENSION_X3D;
		if ( modelFileName.isEmpty())
			 return false;
		System.out.println ("  fromFileGZIP() output modelFileName " + modelFileName);
		File priorFile = new File(modelFileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Note: fromFileGZIP() is overwriting prior file " + modelFileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("[warning] fromFileGZIP() is not allowed to overwrite prior file: " + modelFileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return false;
		}
		try
		{
			FileInputStream fileInputStream = new FileInputStream(gzipFile);
			GZIPInputStream gzipInputStream = new GZIPInputStream(fileInputStream);

			if (ConfigurationProperties.isDebugModeActive())
			{
				System.out.println ("gunzipping " + gzipFile);
			}
			// TODO add optional output directory path
			FileOutputStream fileOutputStream = new FileOutputStream (modelFileName);
			for (int c = gzipInputStream.read(); c != -1; c = gzipInputStream.read())
			{
				fileOutputStream.write(c);
			}
			gzipInputStream.close();
			fileOutputStream.close();
			File decompressedFile = new File(modelFileName);
			System.out.println ("gunzipped " + decompressedFile.getPath() + " size=" + decompressedFile.length() + " bytes");

			X3DLoaderDOM x3dLoader = new X3DLoaderDOM();
			boolean x3dLoaderSuccess = x3dLoader.loadModelFromFileX3D(modelFileName);
			if (x3dLoaderSuccess)
				replace((X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[) x3dLoader.getX3dObjectTree());
		}
		catch (IOException e)
		{
			errorNotice += "gzipFileName " + gzipFileName + "not readable\n";
			System.out.println (errorNotice);
			return false;
		}

		return hasHead() || hasScene(); // success test
	}

    /**
     * Load new model from an EXI file, using unzip to extract the model plus
     * any associated files into the same path location.
     * <br ><br >
     * <i>Warning:</i> this method overwrites any previously existing file
     * versions when decompressing.
     *
     * @see
     * <a href="https://openexi.sourceforge.net/tutorial/index.html">OpenEXI
     * Nagasena Tutorial</a>
     * @see <a href="https://exificient.github.io/java">EXIFICIENT Java
     * Implementations</a>
     * @see
     * <a href="https://en.wikipedia.org/wiki/Efficient_XML_Interchange">Wikipedia:
     * Efficient XML Interchange (EXI) file format</a>
     * @see ConfigurationProperties#getExiEngine()
     * @see ConfigurationProperties#setExiEngine(String)
     * @see X3D#FILE_EXTENSION_EXI
     * @see X3D#FILE_EXTENSION_GZIP
     * @see X3D#FILE_EXTENSION_ZIP
     * @see X3D#toFileEXI(String)
     * @see X3D#fromFileZIP(String,String)
     * @see X3D#fromFileGZIP(String)
     * @param exiFileName name of file to load, can include local directory
     * path, must end with .exi
     * @return boolean if operation succeeds in creating this X3DObject, false
     * otherwise
     */
    public boolean fromFileEXI(String exiFileName) {
        String errorNotice = new String();
        if ((exiFileName == null || exiFileName.isEmpty())) {
            throw new org.web3d.x3d.sai.X3DException("fromFileEXI(exiFileName) fileName not provided;"
                    + " be sure to end with extension \"" + FILE_EXTENSION_EXI + "\"");
        }
        if (!exiFileName.endsWith(FILE_EXTENSION_EXI)) {
            errorNotice += ("exiFileName " + exiFileName + " does not end with extension "
                    + "\"" + FILE_EXTENSION_EXI + "\"" + "\n");
        }
        File priorFile = new File(exiFileName);
        if (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles()) {
            System.out.println("Note: fromFileEXI() is overwriting prior file " + exiFileName);
        } else if (priorFile.exists()) {
            System.out.println("[warning] fromFileEXI() is not allowed to overwrite prior file: " + exiFileName);
            System.out.println("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
            return false;
        }

        Path inputFilePath = Paths.get(exiFileName);
        if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
        {
            errorNotice += "[diagnostic] exiFileName path=" + inputFilePath.toAbsolutePath() + "\n";
            System.out.println(errorNotice);
        }

        String xmlFileName = "examples/temp.exiInputTransformed.x3d"; // XML output again
        switch (ConfigurationProperties.getExiEngine()) {
            case ConfigurationProperties.EXI_ENGINE_EXIFICIENT:
                try {

                   /*
                    * Setup EXIFactory as required
                    */
                    EXIFactory exiFactory = DefaultEXIFactory.newInstance();
                    // e.g., add additional settings beyond the default values
                    // TODO separate string constants for schema addresses
                    // TODO use local copy of schema rather than online; is identifier needed for consistency?
                    // TODO can the grammar be precompiled and cached in X3DJSAIL library?
                    // TODO is a grammar needed for file reading?
                    if (exificientGrammarX3D == null) // only needed once, avoid recomputation
                    {
                        exificientGrammarX3D = GrammarFactory.newInstance().createGrammars("https://www.web3d.org/specifications/x3d-4.0.xsd"); // use XML schema
                    }
                    exiFactory.setGrammars(exificientGrammarX3D);
                    exiFactory.setCodingMode(CodingMode.COMPRESSION); // use deflate compression for larger XML files

                   /*
                    *  decode EXI to XML
                    */
                    Result result = new StreamResult(xmlFileName);
                    InputSource exiFileInputSource = new InputSource(exiFileName);
                    SAXSource exiSource = new EXISource(exiFactory);
                    exiSource.setInputSource(exiFileInputSource);
                    TransformerFactory tf = TransformerFactory.newInstance();
                    Transformer transformer = tf.newTransformer();
                    transformer.transform(exiSource, result);

                    // TODO someday: efficiently parse as X3D, rather than using string-based methods
                } catch (EXIException | TransformerException ex) {
                    Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                    return false;
                }
                break;

            // Nagasena
            case ConfigurationProperties.EXI_ENGINE_OPENEXI:

                InputStream fileInputStream = null;
                InputStream schemaInputStream = null;
                Writer out = null;
                StringWriter stringWriter = new StringWriter();

                // The Grammar Cache stores schema and EXI options information.
                // The settings must match when encoding and subsequently decoding
                // a data set.
                GrammarCache grammarCache;

                // All EXI options can expressed in a single short integer.
                // DEFAULT_OPTIONS=2;
                short options = GrammarOptions.DEFAULT_OPTIONS;

                try {

                    // Standard SAX methods parse content and lexical values.
                    SAXTransformerFactory saxTransformerFactory = (SAXTransformerFactory) SAXTransformerFactory.newInstance();
                    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
                    saxParserFactory.setNamespaceAware(true);
                    TransformerHandler transformerHandler = saxTransformerFactory.newTransformerHandler();

                    // EXIReader infers and reconstructs the XML file structure.
                    EXIReader reader = new EXIReader();

                    // Ensure smallest file size
                    reader.setAlignmentType(AlignmentType.compress);

                    // If using strict interpretation of the schema, set
                    // STRICT_OPTIONS and continue.
                    // NOTE: Strict does not work with X3D schema
//                    options = GrammarOptions.STRICT_OPTIONS;

                    File inputFile = new File(exiFileName);
                    fileInputStream = new FileInputStream(inputFile);
                    out = new OutputStreamWriter(new FileOutputStream(xmlFileName), "UTF-8");

                    // Set the schema and EXI Options in the Grammar Cache.
                    FileInputStream fis = null;

                    // Create a schema and set it to null. If useSchema == "None" it remains null.
                    EXISchema schema = null;

                    // Faster if the schema is already in EXIG format
                    if (!new File("examples/x3d-4.0.xsd.exig").exists()) {
                        SerializeEXISchema s = new SerializeEXISchema();
                        try {
                            schemaInputStream = getClass().getResourceAsStream("/specifications/x3d-4.0.xsd");
                            s.serializeEXISchema("/specifications/x3d-4.0.xsd", schemaInputStream, "examples/x3d-4.0.xsd.exig");
                        } catch (EXISchemaFactoryException | IOException ex) {
                            Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                            throw new IllegalArgumentException(ex);
                        } finally {
                            try {
                                if (schemaInputStream != null) {
                                    schemaInputStream.close();
                                }
                            } catch (IOException ex) {
                                Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }
                    }

                    try {
                        fis = new FileInputStream("examples/x3d-4.0.xsd.exig");
                        schema = new EXISchemaReader().parse(fis);
                    } finally {
                        if (fis != null) {
                            fis.close();
                        }
                    }
                    grammarCache = new GrammarCache(schema, options);

                    // Use the Grammar Cache to set the schema and grammar options
                    // for EXIReader.
                    reader.setGrammarCache(grammarCache);

                    // Prepare to send the results from the transformer to a
                    // StringWriter object.
                    transformerHandler.setResult(new StreamResult(stringWriter));

                    // Read the file into a byte array.
                    byte fileContent[] = new byte[(int) inputFile.length()];
                    fileInputStream.read(fileContent);

                    // Assign the transformer handler to interpret XML content.
                    reader.setContentHandler(transformerHandler);

                    // Parse the file information.
                    reader.parse(new InputSource(new ByteArrayInputStream(fileContent)));

                    // Get the resulting string, write it to the output file, and
                    // flush the buffer contents.
                    final String reconstitutedString;
                    reconstitutedString = stringWriter.getBuffer().toString();
                    out.write(reconstitutedString);
                    out.flush();
                } catch (TransformerConfigurationException | EXIOptionsException | IOException | SAXException ex) {
                    Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                    return false;
                }

                // Verify that the input and output files are closed.
                finally {
                    try {
                        if (fileInputStream != null) {
                            fileInputStream.close();
                        }
                        if (out != null) {
                            out.close();
                        }
                    } catch (IOException ex) {
                        Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
                break;

            default:
                errorNotice = ConfigurationProperties.ERROR_CONFIGURATION_X3DJSAIL + " illegal value \"" + ConfigurationProperties.getExiEngine()
                        + "\" found for ConfigurationProperties.getExiEngine()\n"
                        + "   allowed values are ConfigurationProperties.EXI_ENGINE_EXIFICIENT and ConfigurationProperties.EXI_ENGINE_OPENEXI";
                if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
                {
                    errorNotice += "[diagnostic] exiFileName path=" + inputFilePath.toAbsolutePath() + "\n";
                }
                System.err.println(errorNotice);
                throw new InvalidFieldValueException(errorNotice);
        }

        File decompressedFile = new File(xmlFileName);
/*
        // JDOM to pretty-fy
        org.jdom.Document doc;
        Format form = Format.getPrettyFormat();
        XMLOutputter xout = new XMLOutputter(form);
        try {
            doc = new SAXBuilder().build(decompressedFile);
            xout.output(doc, new FileWriter(decompressedFile));
        } catch (IOException | JDOMException ex) {
            Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
        }
*/
        System.out.println("EXI decompressed " + decompressedFile.getPath() + " size=" + decompressedFile.length() + " bytes");

        X3DLoaderDOM x3dLoader = new X3DLoaderDOM();
        boolean x3dLoaderSuccess = x3dLoader.loadModelFromFileX3D(xmlFileName);
        if (x3dLoaderSuccess) {
            replace((X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[) x3dLoader.getX3dObjectTree());
        }
        return hasHead() || hasScene(); // success test
    }

	/** Determine if this X3D model is empty and no content is present.
	 * @return true if no head and no Scene found, otherwise false
	 */
	public boolean isEmpty()
	{
		return !(hasHead() || hasScene());
	}

	/** Load X3D model from file to initialize or replace contents of this X3D object.
	 * Supports .x3d or .xml file encodings.
	 * @param fileName name of model file that replaces current X3DObject
	 * @return true if replacement successful, false otherwise
	 */
	public boolean loadModelFromFileX3D (String fileName)
	{
        return loadModelFromFileX3D ("", fileName);
	}

	/** Load X3D model from file to initialize or replace contents of this X3D object.
	 * Supports .x3d or .xml file encodings.
	 * @param path directory path to file of interest
	 * @param fileName name of model file that replaces current X3DObject
	 * @return true if replacement successful, false otherwise
	 */
	public boolean loadModelFromFileX3D (String path, String fileName)
	{
            File x3dFile;
            if ((path == null) || path.isEmpty() || path.equals("."))
                 x3dFile = new File(      fileName);
            else x3dFile = new File(path, fileName);

            if (!x3dFile.exists())
            {
                    throw new org.web3d.x3d.sai.X3DException("path, fileName " + path + ", " + fileName + " does not exist and cannot be loaded, check path and filename.");
            }
            return loadModelFromFileX3D (x3dFile);
	}

	/** Load X3D model from file to initialize or replace contents of this X3D object.
	 * Supports .x3d or .xml file encodings.
	 * @param x3dFile model file that replaces current X3DObject
	 * @return true if replacement successful, false otherwise
	 */
	public boolean loadModelFromFileX3D (File x3dFile)
	{
            X3DLoaderDOM x3dLoader = new X3DLoaderDOM();
            boolean x3dLoaderSuccess = x3dLoader.loadModelFromFileX3D(x3dFile);
            if (x3dLoaderSuccess)
                return replace((X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[) x3dLoader.getX3dObjectTree());
            else return false;
	}

	/** Replaces current X3D object with new X3D object.
	 * @param newX3DObject replaces current X3DObject
	 * @return true if replacement successful, false otherwise
	 */
	public boolean replace (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newX3DObject)
	{
            if (newX3DObject == null)
                return false;
            setHead (newX3DObject.getHead());
            setScene(newX3DObject.getScene());
            return true;
	}

    /**
     * Save current model as an EXI file.
     *
     * @see <a href="https://openexi.sourceforge.net/tutorial/index.html">OpenEXI Nagasena Tutorial</a>
     * @see ConfigurationProperties#getExiEngine()
     * @see ConfigurationProperties#setExiEngine(String)
     * @see X3D#FILE_EXTENSION_EXI
     * @see X3D#FILE_EXTENSION_GZIP
     * @see X3D#FILE_EXTENSION_ZIP
     * @see X3D#fromFileEXI(String)
     * @see X3D#toFileGZIP(String)
     * @see X3D#toFileZIP(String,String)
     * @see X3D#toFileX3D(String)
     * @param resultFileName name of file to create and save, can include local
     * directory path, must end with .exi
     * @return File containing result (if operation succeeds), null otherwise
     */
    public File toFileEXI(String resultFileName) {
        String errorNotice = new String();
        if ((resultFileName == null || resultFileName.isEmpty())) {
            throw new org.web3d.x3d.sai.X3DException("toFileJava(resultFileName) fileName not provided;"
                    + " be sure to end with extension \"" + FILE_EXTENSION_EXI + "\"");
        }
        if (!resultFileName.endsWith(FILE_EXTENSION_EXI)) {
            throw new org.web3d.x3d.sai.X3DException("resultFileName " + resultFileName + " does not end with extension "
                    + "\"" + FILE_EXTENSION_EXI + "\"");
        }
        Path outputFilePath = Paths.get(resultFileName);
        if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
        {
            errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
            System.out.println(errorNotice);
        }
        File newXmlFile = toFileX3D(resultFileName + ".temp.x3d");
        newXmlFile.deleteOnExit();
        String exiFileName = resultFileName;
        if (!exiFileName.endsWith(FILE_EXTENSION_EXI)) {
            exiFileName += FILE_EXTENSION_EXI;
            System.out.println(resultFileName + " changed to " + exiFileName);
        }
        File newExiFile = new File(exiFileName);

        // TODO convert this to an .exi file
        switch (ConfigurationProperties.getExiEngine()) {
            case ConfigurationProperties.EXI_ENGINE_EXIFICIENT:
                try {

                   /*
                    * Setup EXIFactory as required
                    */
                    EXIFactory exiFactory = DefaultEXIFactory.newInstance();
                    // e.g., add additional settings beyond the default values
                    // TODO separate string constants for schema addresses
                    // TODO use local copy of schema rather than online; is identifier needed for consistency?
                    // TODO can the grammar be precompiled and cached in X3DJSAIL library?
                    if (exificientGrammarX3D == null) // only needed once, avoid recomputation
                    {
                        exificientGrammarX3D = GrammarFactory.newInstance().createGrammars("https://www.web3d.org/specifications/x3d-4.0.xsd"); // use XML schema
                    }
                    exiFactory.setGrammars(exificientGrammarX3D);
                    exiFactory.setCodingMode(CodingMode.COMPRESSION); // use deflate compression for larger XML files

                    /*
                     * Encode XML to EXI
                     */
                     try (OutputStream osEXI = new FileOutputStream(exiFileName)) {
                        EXIResult exiResult = new EXIResult(exiFactory);
                        exiResult.setOutputStream(osEXI);
                        SAXParserFactory spf = SAXParserFactory.newInstance();
                        spf.setNamespaceAware(true);
                        SAXParser saxParser = spf.newSAXParser();
                        saxParser.parse(newXmlFile, (DefaultHandler) exiResult.getHandler()); // parse XML input
                        // all done, close stream and file
                    }
                } catch (SAXException | IOException | EXIException | ParserConfigurationException ex) {
                    Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                    // not rethrown
                }
                break;

            // Nagasena
            case ConfigurationProperties.EXI_ENGINE_OPENEXI:

                // reference EncodeEXI.java from Nagasena tutorial #4

                InputStream fileInputStream = null;
                InputStream schemaInputStream = null;
                OutputStream out = null;
                GrammarCache grammarCache;

                // All EXI options can be stored in a single short integer. DEFAULT_OPTIONS=2.
                short options;
                try {

                    // Encoding always requires the same steps.
                    // 1. Instantiate a Transmogrifier
                    Transmogrifier transmogrifier = new Transmogrifier();

                    // Bit-packed alignment is the default when transforming XML to
                    // EXI. For some smaller file sizes, greater compaction can be
                    // achieved using the default bit-packed setting.
                    transmogrifier.setAlignmentType(AlignmentType.compress);

                    // If you are confident that your XML file is 100% compliant with
                    // the schema, you can use strict interpretation to encode the
                    // file. This is faster to process, and results in the smallest
                    // possible file size.
//                options = GrammarOptions.STRICT_OPTIONS;
                    // Strict not going to work: org.openexi.sax.TransmogrifierException:
                    // Attribute "noNamespaceSchemaLocation" of namespace
                    // "https://www.w3.org/2001/XMLSchema-instance" with value
                    // "https://www.web3d.org/specifications/x3d-3.3.xsd" is not expected.

                    // Therefore, set default
                    options = GrammarOptions.DEFAULT_OPTIONS;

                    // 2. Initialize the input and output streams.
                    fileInputStream = new FileInputStream(newXmlFile); // source
                    out = new FileOutputStream(newExiFile); // destination

                    // 2.5. Turn x3d-4.0.xsd into an EXIG for faster parsing

                    // Faster if the schema is already in EXIG format
                    if (!new File("examples/x3d-4.0.xsd.exig").exists()) {
                        SerializeEXISchema s = new SerializeEXISchema();
                        try {
                            schemaInputStream = getClass().getResourceAsStream("/specifications/x3d-4.0.xsd");
                            s.serializeEXISchema("/specifications/x3d-4.0.xsd", schemaInputStream, "examples/x3d-4.0.xsd.exig");
                        } catch (EXISchemaFactoryException | IOException ex) {
                            Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                            throw new IllegalArgumentException(ex);
                        } finally {
                            try {
                                if (schemaInputStream != null) {
                                    schemaInputStream.close();
                                }
                            } catch (IOException ex) {
                                Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }
                    }

                    // 3. Set the schema and EXI options in the Grammar Cache.
                    InputStream fis = null;
                    EXISchema schema = null;

                    try {
                        fis = new FileInputStream("examples/x3d-4.0.xsd.exig");
                        schema = new EXISchemaReader().parse(fis);
                    } finally {
                        if (fis != null) {
                            fis.close();
                        }
                    }

                    grammarCache = new GrammarCache(schema, options);

                    // 4. Set the configuration options in the Transmogrifier.
                    transmogrifier.setGrammarCache(grammarCache);

                    // 5. Set the output stream.
                    transmogrifier.setOutputStream(out);

                    // 6. Encode the input stream.
                    transmogrifier.encode(new InputSource(fileInputStream));
                } catch (EXIOptionsException | TransmogrifierException | IOException ex) {
                    Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                } finally {

                    // 7.  Verify that the streams are closed.
                    try {
                        if (fileInputStream != null) {
                            fileInputStream.close();
                        }
                        if (out != null) {
                            out.close();
                        }
                    } catch (IOException ex) {
                        Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }

                // non schema based compression
//
//            InputStream   fileInputStream = null;
//            OutputStream out = null;
//            GrammarCache grammarCache;
//
//            try {
//
//                // Encoding always requires the same steps.
//
//                // 1. Instantiate a Transmogrifier
//                Transmogrifier transmogrifier = new Transmogrifier();
//
//                // 2. Initialize the input and output streams.
//                fileInputStream  = new FileInputStream (newXmlFile);
//                out = new FileOutputStream(newExiFile);
//
//                // 3. Create a Grammar Cache. This example uses default options and no schema.
//                grammarCache = new GrammarCache(null, GrammarOptions.DEFAULT_OPTIONS); // (EXISchema)null
//
//                // 4. Set the configuration options in the Transmogrifier.
//                transmogrifier.setGrammarCache(grammarCache);
//
//                // 5. Set the output stream.
//                transmogrifier.setOutputStream(out);
//
//                // 6. Encode the input stream.
//                transmogrifier.encode(new InputSource(fileInputStream));
//            }
//            catch (EXIOptionsException | TransmogrifierException | IOException ex)
//            {
//                Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
//            }
//            finally
//            {
//                // 7.  Verify that the streams are closed.
//                try {
//                    if (in != null) {
//                        in.close();
//                    }
//                    if (out != null) {
//                        out.close();
//                    }
//                }
//                catch (IOException ex)
//                {
//                    Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, ex);
//                }
//             }
                break;
            default:
                errorNotice = ConfigurationProperties.ERROR_CONFIGURATION_X3DJSAIL + " illegal value \"" + ConfigurationProperties.getExiEngine()
                        + "\" found for ConfigurationProperties.getExiEngine()\n"
                        + "   allowed values are ConfigurationProperties.EXI_ENGINE_EXIFICIENT and ConfigurationProperties.EXI_ENGINE_OPENEXI";
                if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
                {
                    errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
                }
                System.err.println(errorNotice);
                throw new InvalidFieldValueException(errorNotice);
        }
        return newExiFile;
    }

	/**
	 * Save current model as a GZIP file.
	 * @see <a href="https://openexi.sourceforge.net/tutorial/index.html">OpenEXI Nagasena Tutorial</a>
	 * @see X3D#FILE_EXTENSION_EXI
	 * @see X3D#FILE_EXTENSION_GZIP
	 * @see X3D#FILE_EXTENSION_ZIP
	 * @see X3D#toFileEXI(String)
	 * @see X3D#toFileZIP(String,String)
	 * @see X3D#toFileX3D(String)
	 * @param resultFileName name of file to create and save, can include local directory path, must end with .gz (TODO or .tgz)
	 * @return File containing result (if operation succeeds), null otherwise
	 */
    public File toFileGZIP(String resultFileName)
	{
		File resultFile = new File (resultFileName);
		try
		{
			FileOutputStream fos  = new FileOutputStream(resultFile);
			GZIPOutputStream gzos = new GZIPOutputStream (fos);
			gzos.write(toStringX3D().getBytes());
			gzos.close();
		}
		catch (IOException ioe)
		{
			System.out.println (ioe.getMessage());
			ioe.printStackTrace();
		}
		return resultFile;
	}

	/**
	 * Save current model as a ZIP file.
	 * @see <a href="https://openexi.sourceforge.net/tutorial/index.html">OpenEXI Nagasena Tutorial</a>
	 * @see X3D#FILE_EXTENSION_EXI
	 * @see X3D#FILE_EXTENSION_GZIP
	 * @see X3D#FILE_EXTENSION_ZIP
	 * @see X3D#toFileEXI(String)
	 * @see X3D#toFileGZIP(String)
	 * @see X3D#toFileX3D(String)
	 * @param zipFileName name of zip archive file to create and save, can include local directory path, must end with .zip
	 * @param modelName name of X3D file to create and save within the .zip archive
	 * @return File containing result (if operation succeeds), null otherwise
	 */
    public File toFileZIP(String zipFileName, String modelName)
	{
		File resultFile = new File (zipFileName);
		try
		{
			FileOutputStream fos = new FileOutputStream(resultFile);
			ZipOutputStream  zos = new ZipOutputStream (fos);
			zos.setMethod(ZipOutputStream.DEFLATED); // matches java default
			zos.setLevel(Deflater.BEST_COMPRESSION);
			zos.setComment("Created by " + ConfigurationProperties.NAME_X3DJSAIL + " " + ConfigurationProperties.URL_X3DJSAIL);
			ZipEntry         ze  = new ZipEntry(modelName);
			zos.putNextEntry(ze);
			zos.write(toStringX3D().getBytes());
			zos.close();
		}
		catch (IOException ioe)
		{
			System.out.println (ioe.getMessage());
			ioe.printStackTrace();
		}
		return resultFile;
	}

  /** Provide thorough X3DJSAIL validation results for this X3D model.
   * @return "success" or validation results plus exception information (if any)
   */
  public String validationReport()
  {
	String       metaResult = new String();
	String validationResult = new String();
	String  exceptionResult = new String();
        boolean priorConsoleOutputVerbose = ConfigurationProperties.isConsoleOutputVerbose();
        ConfigurationProperties.setConsoleOutputVerbose(false);
	try
	{
		// do not initialize() prior to validation since that clears the X3D entire model!

		if (getHead() != null)
		{
			// first list informational meta elements of interest
			for (meta meta : getHead().getMetaList())
			{
				if (meta.getName().equals(meta.NAME_ERROR)   ||
                                    meta.getName().equals(meta.NAME_WARNING) ||
                                    meta.getName().equals(meta.NAME_HINT)    ||
                                    meta.getName().equals(meta.NAME_INFO)    ||
                                    meta.getName().equals(meta.NAME_TODO))
				{
                                    metaResult += meta.toStringX3D();
				}
			}
		}
		validationResult += validate(); // walk entire tree to validate correctness
	}
	catch (Exception e)
	{
		exceptionResult = e.getMessage(); // report exception failures, if any
	    if (exceptionResult.isBlank())
	    {
                exceptionResult = "Exception caught but no description found! \n";
                // https://stackoverflow.com/questions/1149703/how-can-i-convert-a-stack-trace-to-a-string
                StringWriter sw = new StringWriter();
                e.printStackTrace(new PrintWriter(sw));
                String exceptionAsString = sw.toString();
                exceptionResult+= exceptionAsString;
                e.printStackTrace();
	    }
	}
        // validation checking complete
        ConfigurationProperties.setConsoleOutputVerbose(priorConsoleOutputVerbose);

	if  (metaResult.isEmpty() && exceptionResult.isEmpty() && validationResult.isEmpty())
	     return "success";
	else
	{
		if (!metaResult.isEmpty())
                     metaResult = "\n" + metaResult; // easier to read
		String returnMessage = metaResult;
	//	if  (!exceptionResult.isEmpty() || !validationResult.isEmpty())
        //           returnMessage += "\n[exception] ";
		if  (!exceptionResult.isEmpty())
                     returnMessage += "[exception] " + exceptionResult;
		if  (!validationResult.isEmpty())
		     returnMessage = "\n" + returnMessage; // skip line before meta tags, etc.
		returnMessage += "\n" + validationResult;
		return returnMessage;
	}
  }

	/** Utility method for standalone programs that get created with stylesheet X3dToJava.xslt,
	 * also sets loaded X3D model fileInputStream global CommandLine to this X3D object.
	 * Invocation switches are listed in CommandLine.USAGE help.
	 * @see org.web3d.x3d.jsail.CommandLine
	 * @see org.web3d.x3d.jsail.CommandLine#USAGE
	 * @see org.web3d.x3d.jsail.CommandLine#USAGE_LONG
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJava.xslt" target="_blank">X3dToJava.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.java" target="_blank">examples/HelloWorldProgramOutput.java</a>
	 * @param args command-line arguments
	 */
	public void handleArguments(String[] args)
	{
		String fileName = new String();
		File   newFile;

		CommandLine.setLoadedX3dModel(this); // initialize using this object

		CommandLine.run(args);
	}
]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'X3DConcreteElement')">
									<xsl:value-of select="$protectedPreamble"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[
	private X3DConcreteElement parent = null; // X3D node or statement

	/**
	 * Provide object reference to parent X3D node or statement, if any.
	 * This reference is named "parentObject" rather than "parent" to avoid potential name collision with any X3D field named "parent".
	 * @return object reference to parent X3D node or statement, otherwise null if none
	 */
	public X3DConcreteElement getParent()
	{
		return parent;
	}
	/**
	 * Whether parent object exists.
	 * This reference is named "parentObject" rather than "parent" to avoid potential name collision with any X3D field named "parent".
	 * @return true if found
	 */
	public boolean hasParent()
	{
		return (parent != null);
	}

	/**
	 * Package-internal method to set parent object reference.
	 * @param newParentObject object reference to parent node or X3D statement that contains this node
	 */
	public void setParent(X3DConcreteElement newParentObject)
	{
		parent = newParentObject;
	}

	/**
	 * Package-protected internal method to clear local reference to parent object, if any.
	 */
	public void clearParent()
	{
		setParent(null);
	}

	/**
	 * Find object reference to ancestor Scene element, assumes this object is an attached child.
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see #hasAncestorX3D()
	 * @see X3DConcreteElement#findAncestorX3D()
	 * @return ancestor Scene child reference if attached, otherwise null
	 */
	public Scene]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ findAncestorScene()
	{
		if ((this instanceof org.web3d.x3d.sai.Core.X3DNode) && ((org.web3d.x3d.sai.Core.X3DNode)this) instanceof org.web3d.x3d.jsail.Core.Scene)
			return (Scene)((org.web3d.x3d.sai.Core.X3DNode)this);
		X3DConcreteElement element = this.getParent();
		while (element != null)
		{
			if (element instanceof org.web3d.x3d.jsail.Core.Scene)
				 return (Scene)element;
			else element = element.getParent(); // walk up the tree to top, then back down to Scene
		}
		return null; // not found
	}
	/**
	 * Determine whether ancestor Scene element is found, meaning this object is an attached child.
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see #hasAncestorX3D()
	 * @see X3DConcreteElement#findAncestorX3D()
	 * @return whether ancestor Scene node is found
	 */
	public boolean hasAncestorScene()
	{
		return (findAncestorScene() != null);
	}

	/**
	 * Find object reference to ancestor element (i.e. node or statement), if this object is an attached child.
	 * @param ancestorElementName elementName of ancestor of interest (e.g. first Transform)
	 * @return ancestor node reference if attached and found, otherwise null
	 */
	public X3DConcreteElement findAncestorElementByName(String ancestorElementName)
	{
		if (this.getElementName().equals(ancestorElementName))
			return this;
		X3DConcreteElement element = this.getParent();
		while (element != null)
		{
			if (element.getElementName().equals(ancestorElementName))
				 return element;
			else element = element.getParent(); // walk up the tree to top
		}
		return null; // not found
	}
	/**
	 * Determine whether ancestor element (i.e. node or statement) is found, meaning this object is an attached child.
	 * @param ancestorElementName elementName of ancestor of interest (e.g. first Transform)
	 * @see #findAncestorProtoBody()
	 * @return whether ancestor element is found
	 */
	public boolean hasAncestorElementByName(String ancestorElementName)
	{
		return (findAncestorElementByName(ancestorElementName) != null);
	}

	/**
	 * Find object reference to ancestor ProtoBody, if this node or statement is a child.
	 * @see #hasAncestorProtoBody()
	 * @return ancestor ProtoBody reference if attached and found, otherwise null
	 */
	public ProtoBody findAncestorProtoBody()
	{
		return (ProtoBody) findAncestorElementByName(ProtoBody.NAME);
	}
	/**
	 * Determine whether ancestor ProtoBody element is found, meaning this object is an attached child.
	 * @see #findAncestorProtoBody()
	 * @return whether ancestor ProtoBody element is found
	 */
	public boolean hasAncestorProtoBody()
	{
		return (findAncestorProtoBody() != null);
	}

	/**
	 * Find object reference to ancestor X3D element, if this node or statement is part of an X3D object.
	 * @see #hasAncestorX3D()
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @return ancestor X3D reference if attached, otherwise null
	 */
	public X3D findAncestorX3D()
	{
		if (((org.web3d.x3d.sai.Core.X3DNode)this) instanceof org.web3d.x3d.jsail.Core.X3D)
			return (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[)((org.web3d.x3d.sai.Core.X3DNode)this);
		X3DConcreteElement element = this.getParent();
		while (element != null)
		{
			if (element instanceof org.web3d.x3d.jsail.Core.X3D)
				 return (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[)element;
			else element = element.getParent(); // walk up the tree to top
		}
		return null; // not found
	}
	/**
	 * Determine whether ancestor X3D element is found, meaning this object is an attached child.
	 * @see X3DConcreteElement#findAncestorX3D()
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @return whether ancestor X3D element is found
	 */
	public boolean hasAncestorX3D()
	{
		return (findAncestorX3D() != null);
	}

	/** Provides name of this element.
	 * @return name of this element
	 */
	abstract public String getElementName(); // must be overridden (static methods cannot be abstract)

	/** Defines X3D component for this element.
	 * @return X3D component for this element
	 */
	abstract public String getComponent(); // must be overridden (static methods cannot be abstract)

	/** Provides default X3D component level for this element
	 * @return default X3D component level for this element
	 */
	abstract public int getComponentLevel(); // must be overridden (static methods cannot be abstract)

	/** Indicate type corresponding to given fieldName.
	 * @param fieldName name of field in this X3D statement
	 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_TYPE
	 * @return X3D type (SFvec3f etc.), otherwise ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE if not recognized
	 */
	abstract public String getFieldType(String fieldName); // must be overridden

	/** Indicate accessType corresponding to given fieldName.
	 * @param fieldName name of field in this X3D statement
	 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_TYPE
	 * @return X3D accessType (inputOnly etc.), otherwise ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE if not recognized
	 */
	abstract public String getAccessType(String fieldName); // must be overridden

	/**
	 * Recursive method to provide object reference to node or statement by name attribute, if found as part of this element or in a contained element.
	 * Elements with name fields include meta, Metadata* nodes, field/fieldValue, ProtoDeclare/ExternProtoDeclare/ProtoInstance, CAD and HAnim nodes.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorScene() to check entire scene graph, or findAncestorX3D() to check entire model document.
	 * <br ><br >
	 * @see #findNodeByDEF(String)
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3D()
	 * @see meta
	 * @see org.web3d.x3d.jsail.Core.MetadataString
	 * <i>Warning:</i> more than one element may be found that has the same name, this method does not handle that case.
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @param elementName identifies the element of interest (meta MetadataString ProtoDeclare CADassembly ProtoInstance HAnimHumanoid etc.)
	 * @return object reference to found element, null otherwise
	 */
	abstract public X3DConcreteElement findElementByNameValue(String nameValue, String elementName); // required interface

	/**
	 * Recursive method to provide object reference to node or statement by name attribute, if found as part of this element or in a contained element.
	 * Elements with name fields include meta, Metadata* nodes, field/fieldValue, ProtoDeclare/ExternProtoDeclare/ProtoInstance, CAD and HAnim nodes.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorScene() to check entire scene graph, or findAncestorX3D() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same name, this method does not handle that case.
	 * @see #findNodeByDEF(String)
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3D()
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @return object reference to found element, null otherwise
	 */
	abstract public X3DConcreteElement findElementByNameValue(String nameValue); // required interface

	/**
	 * Recursive method to provide object reference to node by DEF, if found as this node or in a contained node.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorScene() to check entire scene graph, or findAncestorX3D() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same DEF, this method does not handle that case.
	 * @see #findElementByNameValue(String)
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3D()
	 * @param DEFvalue is value of the name field being searched for in this element and child elements(if any)
	 * @return object reference to found node, null otherwise
	 */
	abstract public X3DConcreteNode findNodeByDEF(String DEFvalue); // required interface

	/** Provide fully qualified package for a given element object, including className.  Helpful for reflection.
	 * @param className X3D statement or node of interest
	 * @return fully qualified package for className
	 */
	static public String getPackageName(String className)
	{
		if (className.contains("Object"))
		    className = className.substring(0,className.indexOf("Object"));
		switch (className)
		{]]></xsl:text>
									<!-- node sequence catenation! 8) -->
									<xsl:for-each select="//ConcreteNodes/ConcreteNode, //Statements/Statement">
										<xsl:text>
			case "</xsl:text>
										<xsl:value-of select="@name"/>
										<xsl:text>":
				return "org.web3d.x3d.jsail.</xsl:text>
										<xsl:value-of select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
										<xsl:text>.</xsl:text>
										<xsl:value-of select="@name"/>
										<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>";</xsl:text>
									</xsl:for-each>
									<xsl:text>
			default:
				return "UnknownClassName_" + className;
		}
	}
</xsl:text>
								</xsl:when>
								<!--
								<xsl:when test="($name = 'X3DConcreteNode') or
												(($isInterface = 'true') and (($name = 'ProtoBody') or ($name = 'Scene')))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide object reference to node by DEF name, found either as this node or in a contained node (if any).
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorScene() to check entire scene graph, or findAncestorX3D() to check entire model document.
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3D()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findElementByNameValue(String,String)
	 * @param DEFlabel DEF name of node to find
	 * @return object reference to node
	 */
	abstract public X3DConcreteNode getNodeByDEF(String DEFlabel); // required interface
]]></xsl:text>
								</xsl:when>
								-->
							</xsl:choose>
						</xsl:when>
					</xsl:choose>
					<!-- ===================================================== -->
					<!-- Source code: accessor methods -->
                                        <!-- include sourceCode; and not(@name = 'sourceCode') -->
					<xsl:for-each select="InterfaceDefinition/field[not(starts-with(@name,'set'))]"> <!-- TODO check filtering is consistently effective -->

						<xsl:if test="position()=1">
							<xsl:text>&#10;</xsl:text>
							<xsl:text>	// ==== Accessor methods: strongly typed get/set methods for compile-time strictness</xsl:text>
							<xsl:text>&#10;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:if>
						<xsl:variable name="isX3dStatement">
							<xsl:call-template name="isX3dStatement">
								<xsl:with-param name="name" select="@name"/>
							</xsl:call-template>
						</xsl:variable>
						<!-- TODO why are duplicate field definitions in X3D Object Model? likely due to duplicate entries in appinfo and content model, e.g. LOD, ParticleSystems-->
						<xsl:variable name="fieldName" select="@name"/>

						<!-- avoid duplicates, avoid statement accessors for interfaces -->
						<xsl:if test="not(preceding-sibling::*[@name = $fieldName]) and
                                      not(($isInterface = 'true') and ($isX3dStatement = 'true'))">
							<xsl:variable name="javaType">
								<xsl:call-template name="javaType">
									<xsl:with-param name="x3dType" select="@type"/>
									<xsl:with-param name="isInterface" select="$isInterface"/>
								</xsl:call-template>
							</xsl:variable>
                            <xsl:variable name="listType">
                                <xsl:choose>
                                    <xsl:when test="true() and (@type = 'MFNode') and not((@name = 'X3D') or (@name = 'head') or (@name = 'meta') or (@name = 'unit') or (@name = 'component') or (@name = 'Scene'))">
                                        <!-- TODO allow both allowed node types and ProtoInstance in same list, carefully control node type in set methods. impacts multiple methods. -->
                                        <xsl:text disable-output-escaping="yes"><![CDATA[ArrayList<org.web3d.x3d.sai.Core.X3DNode>]]></xsl:text>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="$javaType" disable-output-escaping="yes"/><!-- append to type name -->
                                        <xsl:if test="($isX3dStatement = 'true') and starts-with(@type,'X3D') and (ends-with(@type,'Node') or ends-with(@type,'Object'))">
                                            <xsl:value-of select="$jsaiInterfaceSuffix"/>
                                        </xsl:if>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:variable>
							<xsl:variable name="javaReferenceType"><!-- base type of ArrayList -->
                                <xsl:choose>
                                    <xsl:when test="(@type = 'MFNode') and not($isX3dStatement = 'true') and not(@name = 'field') and not(@name = 'fieldValue')"><!-- (contains($javaType,'Object') or (@acceptableNodeTypes = 'X3DMetadataObject')) and not(contains($javaType,'X3DMetadataObject')) and -->
                                        <xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
                                    </xsl:when>
                                    <xsl:when test="contains($javaType,'&lt;')">
                                        <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="$javaType"/>
                                    </xsl:otherwise>
                                </xsl:choose>
							</xsl:variable>
							<xsl:variable name="javaPrimitiveType">
								<xsl:call-template name="javaType">
									<xsl:with-param name="x3dType" select="@type"/>
									<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="javaBaseType">
								<xsl:choose>
									<xsl:when test="contains($javaPrimitiveType,'[')">
										<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$javaPrimitiveType"/><!-- array of array type -->
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="tupleSize">
								<xsl:call-template name="tupleSize">
									<xsl:with-param name="x3dType" select="@type"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="javaReferenceType"><!-- base type of ArrayList -->
                                <xsl:choose>
                                    <xsl:when test="(@type = 'MFNode') and not($isX3dStatement = 'true') and not(@name = 'field') and not(@name = 'fieldValue')"><!-- (contains($javaType,'Object') or (@acceptableNodeTypes = 'X3DMetadataObject')) and not(contains($javaType,'X3DMetadataObject')) and -->
                                        <xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
                                    </xsl:when>
                                    <xsl:when test="contains($javaType,'&lt;')">
                                        <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="$javaType"/>
                                    </xsl:otherwise>
                                </xsl:choose>
							</xsl:variable>
							<xsl:variable name="isArrayType">
								<!-- TODO remove restrictions when ArrayList types added -->
								<xsl:value-of select="starts-with(@type,'MF') and not(contains(@type,'Color') or contains(@type,'Vec') or contains(@type,'Rotation') or contains(@type,'Matrix')) and contains($javaType,'[]')"/>
							</xsl:variable>
							<xsl:variable name="isArrayListType">
								<xsl:value-of select="contains($javaType,'&lt;')"/>
							</xsl:variable>
							<xsl:variable name="tooltipText">
								<xsl:value-of select="$x3d.tooltips.document//element[@name = $name]/attribute[@name = $fieldName]/@tooltip" disable-output-escaping="yes"/>
							</xsl:variable>
							<xsl:variable name="fieldTooltip">
								<xsl:if test="(string-length(normalize-space($tooltipText)) > 0)"><!-- doc-available($x3d.tooltips.path) -->
									<xsl:value-of select="replace(replace($tooltipText,'&#8734;','infinity'),'&#960;','pi')" disable-output-escaping="yes"/>
									<!-- consistent javadoc punctuation -->
									<xsl:if test="not(ends-with(normalize-space($tooltipText),'.')) and not(contains($tooltipText,'http')) and not(contains($tooltipText,'mailto')) and not(contains($tooltipText,'ftp'))">
										<xsl:text>.</xsl:text>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:variable name="x3dType" select="@name"/>

							<!-- javadoc from BuildSpecificationLanguageBindingJava.xslt-->
							<xsl:variable name="type">
                                <xsl:choose>
                                    <xsl:when test="(@type = 'xs:string') or (@type = 'xs:token') or starts-with(@type, 'xs:NMTOKEN') or starts-with(@type, 'xs:ID')">
                                        <xsl:text>String</xsl:text>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="@type"/>
                                    </xsl:otherwise>
                                </xsl:choose>
							</xsl:variable>
							<xsl:variable name="isEnumerationType" select="(count(enumeration) > 0)"/>
                            <xsl:variable name="isEnumerationTypeRequired" select="boolean(@additionalEnumerationValuesAllowed='false')"/>
							<xsl:variable name="tupleNess">
								<xsl:choose>
									<xsl:when test="contains($type,'FVec2')">
										<xsl:text>2-tuple </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'FVec3') or ends-with($type,'FColor') or (@baseType='bboxSizeType')">
										<xsl:text>3-tuple </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'FVec4') or ends-with($type,'FRotation') or contains($type,'FColorRGBA')">
										<xsl:text>4-tuple </xsl:text>
									</xsl:when>
									<xsl:when test="starts-with($type,'MF')">
										<!-- <xsl:text>1-tuple </xsl:text> -->
									</xsl:when>
								</xsl:choose>
							</xsl:variable>

<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
	<xsl:text>*** @name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text>, $type=</xsl:text>
	<xsl:value-of select="$type"/>
	<xsl:text>, $tupleNess=</xsl:text>
	<xsl:value-of select="$tupleNess"/>
	<xsl:text>, $name=</xsl:text>
	<xsl:value-of select="$name"/>
</xsl:message>
</xsl:if>

							<xsl:variable name="enumerationValues">
								<xsl:for-each select="enumeration">
									<xsl:text>"</xsl:text>
									<xsl:value-of select="@value"/>
									<xsl:text>"</xsl:text>
									<xsl:if test="not(position() = last())">
										<xsl:text> | </xsl:text>
									</xsl:if>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="CamelCaseName"><!-- upper camel case -->
								<xsl:choose>
									<xsl:when test="starts-with(@name,'set_')">
										<xsl:value-of select="translate(substring(substring-after(@name,'set_'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
										<xsl:value-of select="substring(substring-after(@name,'set_'),2)"/>
									</xsl:when>
									<xsl:when test="starts-with(@name,'set')">
										<xsl:value-of select="translate(substring(substring-after(@name,'set'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
										<xsl:value-of select="substring(substring-after(@name,'set'),2)"/>
									</xsl:when>
									<xsl:when test="contains(@name,'_changed')">
										<xsl:value-of select="translate(substring(substring-before(@name,'_changed'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
										<xsl:value-of select="substring(substring-before(@name,'_changed'),2)"/>
									</xsl:when>
									<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
										<!-- unmodified -->
										<xsl:value-of select="@name"/>
									</xsl:when>
                                    <xsl:when test="(@name = 'id')">
                                        <xsl:text>HtmlID</xsl:text>
                                    </xsl:when>
									<xsl:when test="(@name = 'class')">
										<!-- getClass() is reserved by Java Object() class -->
										<xsl:text>CssClass</xsl:text>
									</xsl:when>
									<xsl:when test="(@name = 'style') and not(ends-with($thisClassName, 'FontStyle'))">
										<!-- similarly named for clarity, consistency -->
										<xsl:text>CssStyle</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="translate(substring(@name,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
										<xsl:value-of select="substring(@name,2)"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="memberObjectName"><!-- lower camel case, usually -->
								<xsl:choose>
									<xsl:when test="($isX3dStatement = 'true')">
										<xsl:value-of select="@name"/>
									</xsl:when>
									<xsl:when test="(@name = 'AS')"><!-- special case: IMPORT, EXPORT -->
										<xsl:value-of select="@name"/>
									</xsl:when>
									<xsl:when test="(@name = 'set_boolean')"> <!-- special case: BooleanFilter, BooleanToggle, IntegerTrigger -->
										<xsl:text>booleanField</xsl:text>
									</xsl:when>
									<xsl:when test="(@name = 'set_boolean')"> <!-- special case: BooleanFilter, BooleanToggle, IntegerTrigger -->
										<xsl:text>booleanField</xsl:text>
									</xsl:when>
									<xsl:when test="starts-with(@name,'set_')">
										<xsl:value-of select="translate(substring(substring-after(@name,'set_'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
										<xsl:value-of select="substring(substring-after(@name,'set_'),2)"/>
									</xsl:when>
									<xsl:when test="starts-with(@name,'set')">
										<xsl:value-of select="translate(substring(substring-after(@name,'set'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
										<xsl:value-of select="substring(substring-after(@name,'set'),2)"/>
									</xsl:when>
									<xsl:when test="contains(@name,'_changed')">
										<xsl:value-of select="translate(substring(substring-before(@name,'_changed'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
										<xsl:value-of select="substring(substring-before(@name,'_changed'),2)"/>
									</xsl:when>
									<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
										<!-- unmodified -->
										<xsl:value-of select="@name"/>
									</xsl:when>
                                    <xsl:when test="(@name = 'id')">
                                        <!-- similarly named for clarity, consistency -->
										<xsl:text>HtmlID</xsl:text>
                                    </xsl:when>
									<xsl:when test="(@name = 'class')">
										<!-- getClass() is reserved by Java Object() class -->
										<xsl:text>cssClass</xsl:text>
									</xsl:when>
									<xsl:when test="(@name = 'style') and not(ends-with($thisClassName, 'FontStyle'))">
										<!-- similarly named for clarity, consistency -->
										<xsl:text>cssClass</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="translate(substring($CamelCaseName,1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
										<xsl:value-of select="substring($CamelCaseName,2)"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="normalizedMemberObjectName">
								<!-- translate name into legal Java form here to avoid xpath problems -->
								<xsl:value-of select="translate($memberObjectName,'-','_')"/>
								<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
									<xsl:text>List</xsl:text><!-- append to member name -->
								</xsl:if>
							</xsl:variable>

							<!-- TODO create Javadoc matching spec, including reference to (string-length(@acceptableNodeTypes) > 1) -->

							<!-- Source code: provide accessor methods according to accessType ========================= -->

							<!-- get method -->
							<xsl:if test="((@accessType='outputOnly') or (@accessType='initializeOnly') or (@accessType='inputOutput') or (string-length(@accessType) = 0))
										  and ((@name = 'address') or (not(starts-with(@name,'add'))
										  and not(starts-with(@name,'remove'))
										  and not(($isInterface = 'true') and ((@name = 'DEF') or (@name = 'USE') or (@name = 'id') or (@name = 'class') or ((@name = 'style') and not(ends-with($thisClassName, 'FontStyle')))))))">
								<!-- javadoc from BuildSpecificationLanguageBindingJava.xslt-->
								<xsl:text>	/**</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 * Provide </xsl:text>
<xsl:if test="($debug = 'true')">
	<xsl:text>($javaType=</xsl:text>
	<xsl:value-of select="$javaType"/>
	<xsl:text>, isArrayType=</xsl:text>
	<xsl:value-of select="$isArrayType"/>
	<xsl:text>, isArrayListType=</xsl:text>
	<xsl:value-of select="$isArrayListType"/>
	<xsl:text>, javaPrimitiveType=</xsl:text>
	<xsl:value-of select="$javaPrimitiveType"/>
	<xsl:text>, javaReferenceType=</xsl:text>
	<xsl:value-of select="$javaReferenceType"/>
	<xsl:text>, isX3dStatement=</xsl:text>
	<xsl:value-of select="$isX3dStatement"/>
	<xsl:text>, isClassX3dStatement=</xsl:text>
	<xsl:value-of select="$isClassX3dStatement"/>
	<xsl:text>) </xsl:text>
</xsl:if>
								<xsl:choose>
									<xsl:when test="contains($javaType,'[]')"><!-- array -->
										<xsl:text>array of </xsl:text>
										<xsl:value-of select="$tupleNess"/>
										<xsl:value-of select="substring-before($javaType,'[]')"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:text> results </xsl:text>
									</xsl:when>
									<xsl:when test="($isArrayListType = 'true')"><!-- boxed type such as ArrayList<String> -->
										<xsl:text>array of </xsl:text>
										<xsl:value-of select="$tupleNess"/>
										<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:text> results </xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$tupleNess"/>
										<xsl:choose>
											<xsl:when test="($name = 'ProtoBody') and (@name = 'children')">
												<xsl:text disable-output-escaping="yes"><![CDATA[ArrayList<org.web3d.x3d.sai.Core.X3DNode>]]></xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="$javaType" disable-output-escaping="yes"/><!-- append to type name -->
												<xsl:if test="($isX3dStatement = 'true') and starts-with(@type,'X3D') and (ends-with(@type,'Node') or ends-with(@type,'Object'))">
													<xsl:value-of select="$jsaiInterfaceSuffix"/>
												</xsl:if>
											</xsl:otherwise>
										</xsl:choose>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:choose>
											<xsl:when test="(ends-with(@type,'FNode'))">
												<xsl:text> instance </xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:text> value </xsl:text>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:otherwise>
								</xsl:choose>
								<!-- value restrictions, if any -->
								<xsl:choose>
									<xsl:when test="contains($type,'RGBA')">
										<xsl:text>using RGBA values [0..1] </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'Color')">
										<xsl:text>using RGB values [0..1] </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'otation') or contains(@name,'otation') or contains(@name,'angle') or contains(@name,'Angle')">
										<xsl:text>unit axis, angle (in radians) </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'Time')">
										<xsl:text>in seconds </xsl:text>
									</xsl:when>
									<xsl:when test="($type='SFNode')">
										<xsl:text>(using a properly typed node) </xsl:text>
									</xsl:when>
									<xsl:when test="($type='MFNode')">
										<xsl:text>(using an array consisting of properly typed nodes or ProtoInstances) </xsl:text>
									</xsl:when>
								</xsl:choose>
								<xsl:call-template name="list-restrictions"/>

								<xsl:text>from </xsl:text>
								<xsl:value-of select="@accessType"/>
								<xsl:text> </xsl:text>
								<xsl:value-of select="@type"/>
								<xsl:text> field </xsl:text>
								<xsl:if test="not(ends-with(@type,'FNode'))">
									<xsl:text>named </xsl:text>
								</xsl:if>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:text>.</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:if test="($type='SFNode') and not($isInterface = 'true') and not($isX3dStatement = 'true')">
									<xsl:text>	 * @see #get</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>ProtoInstance()</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(string-length($fieldTooltip) > 0)">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;Tooltip:&lt;/i&gt; </xsl:text>
									<xsl:call-template name="bulletize-hints-warnings">
										<xsl:with-param name="tooltipText">
											<xsl:call-template name="wrap-hyperlinks">
												<xsl:with-param name="string">
													<!-- xsl:text> debug: escape-javadoc-characters1 </xsl:text -->
													<xsl:call-template name="escape-javadoc-characters">
														<xsl:with-param name="inputValue">
															<xsl:value-of select="normalize-space(substring-after($fieldTooltip,']'))" disable-output-escaping="yes"/>
														</xsl:with-param>
													</xsl:call-template>
												</xsl:with-param>
											</xsl:call-template>
										</xsl:with-param>
									</xsl:call-template>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="((@type='SFString') or (@type='MFString')) and (enumeration) and not($isInterface = 'true')">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Available enumeration values for string comparison: </xsl:text>
									<xsl:for-each select="enumeration">
										<xsl:if test="position() > 1">
											<xsl:text>, </xsl:text>
										</xsl:if>
										<xsl:text>{@link </xsl:text>
										<xsl:text>#</xsl:text>
										<xsl:value-of select="upper-case(../@name)"/>
										<xsl:text>_</xsl:text>
										<!-- enumeration name: omit " character, others become _ underscore -->
										<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
										<xsl:text> </xsl:text>
										<!-- enumeration name: omit " character, others become _ underscore -->
										<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
										<xsl:text>}</xsl:text>
									</xsl:for-each>
									<xsl:text>.</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(@type = 'MFNode') and (string-length(@acceptableNodeTypes) > 1)">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[<i>Warning:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
									<xsl:value-of select="@acceptableNodeTypes"/>
									<xsl:text>.</xsl:text>
									<xsl:text>&#10;</xsl:text>

									<xsl:variable name="X3dUnifiedObjectModelTree" select="/"/>
									<xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
										<xsl:variable name="acceptableNodeType" select="string(.)"/>
										<xsl:text>	 * @see </xsl:text>
										<xsl:variable name="packageName">
											<xsl:choose>
												<xsl:when test="starts-with($acceptableNodeType,'X3D') and contains($acceptableNodeType,'Node')">
													<xsl:text>org.web3d.x3d.sai.</xsl:text>
													<xsl:value-of select="translate($X3dUnifiedObjectModelTree//AbstractNodeType  [@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
												</xsl:when>
												<xsl:when test="starts-with($acceptableNodeType,'X3D') and contains($acceptableNodeType,'Object')">
													<xsl:text>org.web3d.x3d.sai.</xsl:text>
													<xsl:value-of select="translate($X3dUnifiedObjectModelTree//AbstractObjectType[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>org.web3d.x3d.jsail.</xsl:text>
													<xsl:value-of select="translate($X3dUnifiedObjectModelTree//Statements/Statement      [@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:value-of select="translate($X3dUnifiedObjectModelTree//ConcreteNodes/ConcreteNode[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
													<xsl:value-of select="$jsaiClassSuffix"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<!-- debug trace
										<xsl:message>
											<xsl:text>acceptableNodeType=</xsl:text>
											<xsl:value-of select="$acceptableNodeType"/>
											<xsl:text>, packageName=</xsl:text>
											<xsl:value-of select="$packageName"/>
										</xsl:message> -->
										<!-- find, insert package name -->
										<xsl:value-of select="$packageName"/>
										<xsl:text>&#10;</xsl:text>
									</xsl:for-each>
								</xsl:if>
								<xsl:if test="(@name = 'metadata')">
                                                                        <xsl:text>&#10;</xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:text>	 * @return value of </xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:if test="(@name != 'field')">
									<xsl:text> field</xsl:text>
								</xsl:if>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 */</xsl:text><!-- end javadoc -->
								<xsl:text>&#10;</xsl:text>
<!-- TODO debug comment in source
-->
<xsl:if test="true()"><!-- ($debug = 'true') -->
<xsl:text>	// ($isInterface=</xsl:text>
<xsl:value-of select="$isInterface"/>
<xsl:text>, $isException=</xsl:text>
<xsl:value-of select="$isException"/>
<xsl:text>, $isServiceInterface=</xsl:text>
<xsl:value-of select="$isServiceInterface"/>
<xsl:text>, $isX3dStatement=</xsl:text>
<xsl:value-of select="$isX3dStatement"/>
<xsl:text>, $isClassX3dStatement=</xsl:text>
<xsl:value-of select="$isClassX3dStatement"/>
<xsl:text>, preceding-sibling::Inheritance=</xsl:text>
<xsl:value-of select="preceding-sibling::Inheritance"/>
<xsl:text>, $baseType=</xsl:text>
<xsl:value-of select="$baseType"/>
<xsl:text>, $additionalInheritanceBaseType=</xsl:text>
<xsl:value-of select="$additionalInheritanceBaseType"/>
<xsl:text>, $thisClassName=</xsl:text>
<xsl:value-of select="$thisClassName"/>
<xsl:text>, $CamelCaseName=</xsl:text>
<xsl:value-of select="$CamelCaseName"/>
<xsl:text>, $memberObjectName=</xsl:text>
<xsl:value-of select="$memberObjectName"/>
<xsl:text>, $memberObjectName=</xsl:text>
<xsl:value-of select="$normalizedMemberObjectName"/>
<xsl:text>)</xsl:text>
<xsl:text>&#10;</xsl:text>
</xsl:if>
								<!-- source code: get method -->
								<xsl:if test="(not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')) or
												 (($isInterface = 'true') and //AbstractNodeType  [@name = $baseType                     ]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($isInterface = 'true') and //AbstractNodeType  [@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($isInterface = 'true') and //AbstractObjectType[@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($thisClassName = 'ProtoInstance') and
												  (($CamelCaseName = 'Metadata') or ($CamelCaseName = 'Name') or ($CamelCaseName = 'DEF') or ($CamelCaseName = 'USE') or ($CamelCaseName = 'CssClass')) or
												 (not($thisClassName = 'X3DNode') and ($CamelCaseName = 'Metadata')))">
									<!--<xsl:text>	/* @Override */</xsl:text>--><!-- // here1? -->
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:text>	public </xsl:text>
								<xsl:choose>
									<!--
									<xsl:when test="($name = 'ProtoBody') and (@name = 'children')">
										<xsl:text disable-output-escaping="yes"><![CDATA[ArrayList<org.web3d.x3d.sai.Core.X3DNode>]]></xsl:text>
									</xsl:when>
									-->
									<xsl:when test="(@type = 'MFNode') and (($isClassX3dStatement = 'true') or ($isX3dStatement = 'true') or (@name = 'addChildren') or (@name = 'removeChildren'))">
										<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
									</xsl:when>
									<xsl:otherwise>
                                        <xsl:variable name="saiPackagePath">
                                            <xsl:call-template name="saiPackage">
                                                <xsl:with-param name="nodeType" select="$javaPrimitiveType"/>
                                            </xsl:call-template>
                                        </xsl:variable>
                                        <xsl:choose>
                                            <xsl:when test="(string-length($saiPackagePath) > 0)">
                                                <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 5a */</xsl:text></xsl:if>
                                                <xsl:value-of select="$saiPackagePath"/>
                                                <xsl:text>.</xsl:text>
                                                <xsl:value-of select="$javaPrimitiveType"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 5b, saiPackage for </xsl:text>
                                                <xsl:value-of select="$javaPrimitiveType"/>
                                                <xsl:text> not found */</xsl:text></xsl:if>
                                                <xsl:value-of select="$javaPrimitiveType"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
									</xsl:otherwise>
								</xsl:choose>
								<xsl:text> get</xsl:text>
								<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
								<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
									<xsl:text>List</xsl:text><!-- append to member name -->
								</xsl:if>
								<xsl:text>()</xsl:text>
								<xsl:choose>
									<xsl:when test="($isInterface = 'true')">
										<xsl:text>;</xsl:text>
										<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
											<xsl:text> // acceptable node types #1: </xsl:text>
											<xsl:value-of select="@acceptableNodeTypes"/>
										</xsl:if>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	{</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:choose>
											<xsl:when test="(($name = 'field') or ($name = 'fieldValue')) and (@name = 'value') and not($isX3dStatement = 'true')">
												<xsl:text disable-output-escaping="yes"><![CDATA[		String valueType = getType();
		// alternatives for return typed value
		if ((valueArrayBoolean != null) && (valueArrayBoolean.length > 0))
		{
			if      (valueType.equals(field.TYPE_SFBOOL)) return SFBool.toString(valueArrayBoolean[0]);
			else if (valueType.equals(field.TYPE_MFBOOL)) return MFBool.toString(valueArrayBoolean);
                        // ProtoInstance fieldValue does not directly contain type but a value has been found nonetheless
                        else if (valueArrayBoolean.length == 1)               return SFBool.toString(valueArrayBoolean[0]);
                        else                                                  return MFBool.toString(valueArrayBoolean);
		}
		else if ((valueArrayInteger != null) && (valueArrayInteger.length > 0))
		{
			if      (valueType.equals(field.TYPE_SFINT32)) return SFInt32.toString(valueArrayInteger[0]);
			else if (valueType.equals(field.TYPE_MFINT32)) return MFInt32.toString(valueArrayInteger);
			else if (valueType.equals(field.TYPE_SFIMAGE)) return SFImage.toString(valueArrayInteger);
			else if (valueType.equals(field.TYPE_MFIMAGE)) return MFImage.toString(valueArrayInteger);
                        // ProtoInstance fieldValue does not directly contain type but a value has been found nonetheless
                        else if (valueArrayInteger.length == 1)               return SFInt32.toString(valueArrayInteger[0]);
                        else                                                  return MFInt32.toString(valueArrayInteger);
		}
		else if ((valueArrayFloat != null) && (valueArrayFloat.length > 0))
		{
			if      (valueType.equals(field.TYPE_SFFLOAT))     return SFFloat.toString(valueArrayFloat[0]);
			else if (valueType.equals(field.TYPE_MFFLOAT))     return MFFloat.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_SFCOLOR))     return SFColor.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_MFCOLOR))     return MFColor.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_SFCOLORRGBA)) return SFColorRGBA.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_MFCOLORRGBA)) return MFColorRGBA.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_SFROTATION))  return SFRotation.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_MFROTATION))  return MFRotation.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_SFVEC2F))     return SFVec2f.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_SFVEC3F))     return SFVec3f.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_SFVEC4F))     return SFVec4f.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_MFVEC2F))     return MFVec2f.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_MFVEC3F))     return MFVec3f.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_MFVEC4F))     return MFVec4f.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_MFMATRIX3F))  return MFMatrix3f.toString(valueArrayFloat);
			else if (valueType.equals(field.TYPE_MFMATRIX4F))  return MFMatrix4f.toString(valueArrayFloat);
                        // ProtoInstance fieldValue does not directly contain type but a value has been found nonetheless
                        else if (valueArrayFloat.length == 1)              return SFFloat.toString(valueArrayFloat[0]);
                        else                                               return MFFloat.toString(valueArrayFloat);
		}
		else if ((valueArrayDouble != null) && (valueArrayDouble.length > 0))
		{
			if      (valueType.equals(field.TYPE_SFDOUBLE))    return SFDouble.toString(valueArrayDouble[0]);
			else if (valueType.equals(field.TYPE_MFDOUBLE))    return MFDouble.toString(valueArrayDouble);
			else if (valueType.equals(field.TYPE_SFTIME))      return SFTime.toString(valueArrayDouble[0]);
			else if (valueType.equals(field.TYPE_MFTIME))      return MFTime.toString(valueArrayDouble);
			else if (valueType.equals(field.TYPE_SFVEC2D))     return SFVec2d.toString(valueArrayDouble);
			else if (valueType.equals(field.TYPE_SFVEC3D))     return SFVec3d.toString(valueArrayDouble);
			else if (valueType.equals(field.TYPE_SFVEC4D))     return SFVec4d.toString(valueArrayDouble);
			else if (valueType.equals(field.TYPE_MFVEC2D))     return MFVec2d.toString(valueArrayDouble);
			else if (valueType.equals(field.TYPE_MFVEC3D))     return MFVec3d.toString(valueArrayDouble);
			else if (valueType.equals(field.TYPE_MFVEC4D))     return MFVec4d.toString(valueArrayDouble);
			else if (valueType.equals(field.TYPE_MFMATRIX3D))  return MFMatrix3d.toString(valueArrayDouble);
			else if (valueType.equals(field.TYPE_MFMATRIX4D))  return MFMatrix4d.toString(valueArrayDouble);
                        // ProtoInstance fieldValue does not directly contain type but a value has been found nonetheless
                        else if (valueArrayDouble.length == 1)                    return SFDouble.toString(valueArrayDouble[0]);
                        else                                                      return MFDouble.toString(valueArrayDouble);
		}
		else if (value != null)
		{
			if      (valueType.equals(field.TYPE_SFSTRING) ||
					 valueType.equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE)) // matches XML default; might not be connected yet
				return new SFString(value).toString();
			else if (valueType.equals(field.TYPE_MFSTRING))
				return new MFString(value).toString();
		}
		// TODO error handling
		if (value == null)
		{
			return "";
		}
		else return value]]></xsl:text>
											</xsl:when>
                                            <!-- special case -->
                                            <xsl:when test="((@name = 'style') and ends-with($thisClassName, 'FontStyle'))">
												<xsl:text>		return style</xsl:text>
											</xsl:when>
											<!-- check if SFNode subtype cast necessary -->
											<xsl:when test="(@type = 'SFNode') and not($javaPrimitiveType = $javaType) and not($isX3dStatement = 'true')">
												<xsl:text>		return (</xsl:text>
												<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
												<xsl:text>)</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
											</xsl:when>
											<xsl:when test="(@type = 'MFNode') and (($isX3dStatement = 'true') or ($isClassX3dStatement = 'true'))">
												<xsl:text>		return </xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
											</xsl:when>
											<xsl:when test="not($isX3dStatement = 'true') and
															((($isArrayListType = 'true') and contains($javaType,'ArrayList')) or
															 ((@type = 'MFNode') and not(starts-with($javaPrimitiveType, $javaReferenceType)) and not($isClassX3dStatement = 'true')))">
												<xsl:text>		final </xsl:text>
												<xsl:choose>
													<xsl:when test="($isX3dStatement = 'true')">
														<xsl:value-of select="@name"/>
														<xsl:value-of select="$jsaiClassSuffix"/>
														<xsl:if test="(@type='MFNode')">
															<xsl:text>[]</xsl:text>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
													</xsl:otherwise>
												</xsl:choose>
												<xsl:text> valuesArray = new </xsl:text>
												<xsl:choose>
													<xsl:when test="($isX3dStatement = 'true')">
														<xsl:value-of select="$normalizedMemberObjectName"/>
													</xsl:when>
													<xsl:otherwise>
														<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
													</xsl:otherwise>
												</xsl:choose>
												<xsl:text>[</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>.size()];</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		int i = 0;</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		for (</xsl:text>
												<xsl:value-of select="$javaReferenceType"/>
												<xsl:text> arrayElement : </xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>) {</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			valuesArray[i++] = </xsl:text>
												<!-- cast -->
                                                <xsl:if test="(@type = 'MFNode') and not($javaPrimitiveType = $javaType) and not(starts-with($javaPrimitiveType, $javaReferenceType)) and not($isX3dStatement = 'true')">
													<xsl:text>(</xsl:text>
													<xsl:value-of select="substring-before($javaPrimitiveType,'[')" disable-output-escaping="yes"/>
													<xsl:text>)</xsl:text>
												</xsl:if>
												<xsl:text>arrayElement;</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		}</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		return valuesArray</xsl:text>
												<!--
												final boolean[] primitives = new boolean[booleanList.size()];
												for (Boolean object : booleanList) {
													primitives[i++] = object;
												}
												return primitives;
												-->
												<!-- https://docs.oracle.com/javase/8/docs/api/java/util/List.html#toArray -->
												<!-- https://stackoverflow.com/questions/5615664/coverting-a-boolean-object-array-to-boolean-primitive-array -->
											</xsl:when>
											<xsl:when test="(@name = 'DEF') or (@name = 'USE') or (@name = 'id') or (@name = 'class') or ((@name = 'style') and not(ends-with($thisClassName, 'FontStyle')))">
                                                <xsl:text>		// override abstract method in X3DConcreteNode</xsl:text>
                                                <xsl:text>&#10;</xsl:text>
                                                <xsl:text>		return super.get</xsl:text>
                                                <xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
                                                <xsl:text>()</xsl:text>
                                            </xsl:when>
											<xsl:otherwise>
												<xsl:text>		return </xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
											</xsl:otherwise>
										</xsl:choose>
										<xsl:text>;</xsl:text>
										<xsl:text>&#10;</xsl:text>

										<xsl:text>	}</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:otherwise>
								</xsl:choose>

								<xsl:if test="((@type='MFNode') or (@type='MFString') or (@type='MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type='MFFloat') or (@type='MFDouble') or (@type='MFTime'))
											   and (not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true') or
                                                                                                (($name = 'ExternProtoDeclare') and (@name = 'url')))">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Utility method to get ArrayList </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #get</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>()}.</xsl:text>
									<xsl:if test="($name = 'field') or ($name = 'fieldValue')">
                                                                                <xsl:text>&#10;</xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[	 * <i>Hint:</i> for best performance, set type before setting value.]]></xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<!-- TODO
									<xsl:text> * @see java.util.ArrayList</xsl:text>
									<xsl:text>&#10;</xsl:text>
									-->
									<xsl:text>	 * @return value of </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:if test="(@name != 'field')">
										<xsl:text> field</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
                                    <xsl:choose>
                                        <xsl:when test="contains($javaType,'ArrayList')">
                                            <xsl:text disable-output-escaping="yes"><![CDATA[ArrayList<]]></xsl:text>
                                            <xsl:value-of select="$javaReferenceType"/>
                                            <xsl:text disable-output-escaping="yes"><![CDATA[>]]></xsl:text>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="$javaReferenceType"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
									<xsl:text> get</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>List()</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		return </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="((@type='MFString') or (@type='MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type='MFFloat') or (@type='MFDouble') or (@type='MFTime'))
											   and not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
									<!-- not (@type='MFNode') -->
                                    <xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Utility method to get String </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #get</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>()}.</xsl:text>
									<xsl:if test="($name = 'field') or ($name = 'fieldValue')">
                                                                            <xsl:text>&#10;</xsl:text>
                                                                            <xsl:text disable-output-escaping="yes"><![CDATA[	 * <i>Hint:</i> for best performance, set type before setting value.]]></xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<!-- TODO
									<xsl:text> * @see java.util.ArrayList</xsl:text>
									<xsl:text>&#10;</xsl:text>
									-->
									<xsl:text>	 * @return value of </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:if test="(@name != 'field')">
										<xsl:text> field</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public String get</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>String()
    {
        StringBuilder result = new StringBuilder();
		for (</xsl:text>
		<xsl:value-of select="$javaReferenceType"/>
        <xsl:text> arrayElement : </xsl:text>
        <xsl:value-of select="$normalizedMemberObjectName"/>
        <xsl:text>) {</xsl:text>
        <xsl:choose>
			<xsl:when test="(@type = 'MFString')">
				<xsl:text>
			result.append("\"");
			result.append(arrayElement);
			result.append("\"");</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>
			result.append(arrayElement.toString());</xsl:text>
			</xsl:otherwise>
        </xsl:choose>
									<xsl:text>
			result.append(" ");
		}
		return result.toString().trim();
	}
</xsl:text>
								</xsl:if>
								<!-- end of get accessors -->
							</xsl:if>

							<!-- javadoc: set/add method accessor(s) -->
							<xsl:if test="((@accessType='inputOnly') or (@accessType='initializeOnly') or (@accessType='inputOutput') or (string-length(@accessType) = 0))
										  and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')))
                                          and not(($isInterface = 'true') and ((@name = 'DEF') or (@name = 'USE') or (@name = 'id') or (@name = 'class') or ((@name = 'style') and not(ends-with($thisClassName, 'FontStyle')))))">

								<xsl:variable name="newValueInstanceAcceptableNodeTypesTest">
									<xsl:if test="contains(@acceptableNodeTypes, '|')">
										<!-- debug trace
										<xsl:message>
											<xsl:value-of select="$name"/>
											<xsl:text> field=</xsl:text>
											<xsl:value-of select="@name"/>
											<xsl:text> @type=</xsl:text>
											<xsl:value-of select="@type"/>
											<xsl:text> @acceptableNodeTypes=</xsl:text>
											<xsl:value-of select="@acceptableNodeTypes"/>
										</xsl:message> -->
										<xsl:text disable-output-escaping="yes">
		// newValueInstanceAcceptableNodeTypesTest checks are needed for methods that override/subset X3DNode interfaces #1
		boolean isNodeTypeAllowed =</xsl:text>
										<xsl:if test="(@type = 'MFNode') and ((@name='children') or contains(@acceptableNodeTypes, 'children'))">
											<!-- these statements do not qualify as SFNode fields -->
											<xsl:text disable-output-escaping="yes">
				(newValue instanceof org.web3d.x3d.jsail.Core.CommentsBlock) ||
				(newValue instanceof org.web3d.x3d.jsail.Core.ROUTE) ||
				(newValue instanceof org.web3d.x3d.jsail.Networking.IMPORT) ||
				(newValue instanceof org.web3d.x3d.jsail.Networking.EXPORT) ||
				(newValue instanceof org.web3d.x3d.jsail.Core.ProtoDeclare) ||
				(newValue instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclare) ||</xsl:text>
										</xsl:if>

										<!-- must save access to object model tree before going inside an xsl:for-each that loops over strings -->
										<xsl:variable name="X3dUnifiedObjectModelTree" select="/"/>
										<xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
											<xsl:variable name="acceptableNodeType" select="string(.)"/>
											<xsl:choose>
												<xsl:when test="($acceptableNodeType = 'LayerSet')">
													<xsl:text>
				(newValue instanceof org.web3d.x3d.jsail.Layering.LayerSet)</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>
				(((X3DConcreteNode)</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>) instanceof </xsl:text>
                                                    <!--
                                                    -->
													<xsl:variable name="packageName">
														<xsl:choose>
															<xsl:when test="starts-with($acceptableNodeType,'X3D') and contains($acceptableNodeType,'Node')">
																<xsl:text>org.web3d.x3d.sai.</xsl:text>
																<xsl:value-of select="translate($X3dUnifiedObjectModelTree//AbstractNodeType  [@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
																<xsl:text>.</xsl:text>
																<xsl:value-of select="$acceptableNodeType"/>
															</xsl:when>
															<xsl:when test="starts-with($acceptableNodeType,'X3D') and contains($acceptableNodeType,'Object')">
																<xsl:text>org.web3d.x3d.sai.</xsl:text>
																<xsl:value-of select="translate($X3dUnifiedObjectModelTree//AbstractObjectType[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
																<xsl:text>.</xsl:text>
																<xsl:value-of select="$acceptableNodeType"/>
															</xsl:when>
															<xsl:otherwise>
																<xsl:text>org.web3d.x3d.jsail.</xsl:text>
																<xsl:value-of select="translate($X3dUnifiedObjectModelTree//ConcreteNodes/ConcreteNode[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
																<xsl:text>.</xsl:text>
																<xsl:value-of select="$acceptableNodeType"/>
																<xsl:value-of select="$jsaiClassSuffix"/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:value-of select="$packageName"/>
													<!-- debug trace
													<xsl:message>
														<xsl:text>acceptableNodeType=</xsl:text>
														<xsl:value-of select="$acceptableNodeType"/>
														<xsl:text>, packageName=</xsl:text>
														<xsl:value-of select="$packageName"/>
													</xsl:message> -->
													<xsl:text>)</xsl:text>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:if test="not(position() = last())">
												<xsl:text> || </xsl:text>
											</xsl:if>
										</xsl:for-each>
										<xsl:text>;
		if  (!isNodeTypeAllowed)
		{
			throw new org.web3d.x3d.sai.InvalidFieldValueException("X3DNode newValue is not instanceof " +
				"acceptableNodeTypes </xsl:text>
			<xsl:value-of select="@acceptableNodeTypes"/>
			<xsl:text>; newValue=" + newValue);
		}
</xsl:text>
									</xsl:if>
								</xsl:variable>
								<xsl:variable name="newValueArrayAcceptableNodeTypesTest">
									<xsl:if test="contains(@acceptableNodeTypes, '|')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		// newValueArrayAcceptableNodeTypesTest checks are needed for methods that override/subset X3DNode interfaces #2
		for (int i = 0; i < ]]></xsl:text>
										<xsl:value-of select="$newValue"/>
										<xsl:text>.length; i++)
		{
			boolean isNodeTypeAllowed = </xsl:text>
										<xsl:if test="((@name='children') or contains(@acceptableNodeTypes, 'children'))">
											<xsl:text>
				(newValue[i] instanceof org.web3d.x3d.jsail.Core.CommentsBlock) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Core.ROUTE) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Networking.IMPORT) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Networking.EXPORT) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Core.ProtoDeclare) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclare) ||</xsl:text>
										</xsl:if>
										<!-- must save access to object model tree before going inside an xsl:for-each that loops over strings -->
										<xsl:variable name="X3dUnifiedObjectModelTree" select="/"/>
										<xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
											<xsl:variable name="acceptableNodeType" select="string(.)"/>
											<xsl:choose>
												<xsl:when test="($acceptableNodeType = 'LayerSet')">
													<xsl:text>
				(newValue[i] instanceof org.web3d.x3d.jsail.Layering.LayerSet)</xsl:text>
												</xsl:when>
												<xsl:when test="not(starts-with($acceptableNodeType, 'X3D'))">
													<xsl:text>
				(((X3DConcreteNode)</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i]) instanceof </xsl:text>
													<xsl:text>org.web3d.x3d.jsail.</xsl:text>
													<xsl:value-of select="translate($X3dUnifiedObjectModelTree//ConcreteNodes/ConcreteNode[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
													<xsl:value-of select="$jsaiClassSuffix"/>
													<xsl:text>)</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>
				(((X3DConcreteNode)</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i]) instanceof </xsl:text>
                                                    <xsl:variable name="saiPackagePath">
                                                        <xsl:call-template name="saiPackage">
                                                            <xsl:with-param name="nodeType" select="$acceptableNodeType"/>
                                                        </xsl:call-template>
                                                    </xsl:variable>
                                                    <xsl:choose>
                                                        <xsl:when test="(string-length($saiPackagePath) > 0)">
                                                            <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 17a */</xsl:text></xsl:if> -->
                                                            <xsl:value-of select="$saiPackagePath"/>
                                                            <xsl:text>.</xsl:text>
                                                            <xsl:value-of select="$acceptableNodeType"/>
                                                        </xsl:when>
                                                        <xsl:otherwise>
                                                            <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 17b, saiPackage not found */</xsl:text></xsl:if> -->
                                                            <xsl:value-of select="$acceptableNodeType"/>
                                                        </xsl:otherwise>
                                                    </xsl:choose>
													<xsl:text>)</xsl:text>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:if test="(last() > position())">
												<xsl:text> || </xsl:text>
											</xsl:if>
										</xsl:for-each>
										<xsl:text>;
			if  (!isNodeTypeAllowed)
			{
				throw new org.web3d.x3d.sai.InvalidFieldValueException("X3DNode[] newValue["+i+"] is not instanceof " +
					"acceptableNodeTypes </xsl:text>
				<xsl:value-of select="@acceptableNodeTypes"/>
				<xsl:text>; newValue["+i+"]=" + newValue[i]);
			}
		}
</xsl:text>
									</xsl:if>
								</xsl:variable>

								<!-- javadoc from BuildSpecificationLanguageBindingJava.xslt-->
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	/**</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 * Accessor method to assign </xsl:text>
	<xsl:if test="($debug = 'true') or (@name = 'GeoOrigin')">
            <xsl:text>($javaType=</xsl:text>
            <xsl:value-of select="$javaType" disable-output-escaping="yes"/>
            <xsl:text>, isArrayType=</xsl:text>
            <xsl:value-of select="$isArrayType"/>
            <xsl:text>, isArrayListType=</xsl:text>
            <xsl:value-of select="$isArrayListType"/>
            <xsl:text>, javaPrimitiveType=</xsl:text>
            <xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
            <xsl:text>, javaReferenceType=</xsl:text>
            <xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
            <xsl:text>, isX3dStatement=</xsl:text>
            <xsl:value-of select="$isX3dStatement"/>
            <xsl:text>, isClassX3dStatement=</xsl:text>
            <xsl:value-of select="$isClassX3dStatement"/>
            <xsl:text>) </xsl:text>
	</xsl:if>
								<xsl:value-of select="$tupleNess"/>
								<xsl:choose>
									<xsl:when test="contains($javaType,'[]')">
										<xsl:value-of select="substring-before($javaType,'[]')"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:text> array </xsl:text>
									</xsl:when>
									<xsl:when test="($isArrayListType = 'true')"><!-- boxed type such as ArrayList<String> -->
										<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:text> array </xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:choose>
											<xsl:when test="(ends-with(@type,'FNode'))">
												<xsl:text> instance </xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:text> value </xsl:text>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:otherwise>
								</xsl:choose>
								<!-- value restrictions, if any -->
								<xsl:choose>
									<xsl:when test="$isEnumerationType">
										<xsl:text>(</xsl:text>
										<xsl:value-of select="$enumerationValues"/>
										<xsl:text>) </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'RGBA')">
										<xsl:text>using RGBA values [0..1] </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'Color')">
										<xsl:text>using RGB values [0..1] </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'otation') or contains(@name,'otation') or contains(@name,'angle') or contains(@name,'Angle')">
										<xsl:text>unit axis, angle (in radians) </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'Time')">
										<xsl:text>in seconds </xsl:text>
									</xsl:when>
									<xsl:when test="($type='SFNode')">
										<xsl:text>(using a properly typed node) </xsl:text>
									</xsl:when>
									<xsl:when test="($type='MFNode')">
										<xsl:text>(using an array consisting of properly typed nodes or ProtoInstances) </xsl:text>
									</xsl:when>
								</xsl:choose>
                                <!-- duplicative
                                <xsl:if test="(string-length(@baseType) > 0)">
                                    <xsl:text>(</xsl:text>
                                    <xsl:value-of select="@name"/>
                                    <xsl:text> baseType#1 </xsl:text>
                                    <xsl:value-of select="@baseType"/>
                                    <xsl:text>) </xsl:text>
                                </xsl:if>
								<xsl:call-template name="list-restrictions"/>
                                -->
								<xsl:text>to </xsl:text>
								<xsl:value-of select="@accessType"/>
								<xsl:text> </xsl:text>
								<xsl:value-of select="@type"/>
								<xsl:text> field </xsl:text>
								<xsl:if test="not(ends-with(@type,'FNode'))">
									<xsl:text>named </xsl:text>
								</xsl:if>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:if test="((@type='SFString') or (@type='MFString')) and (enumeration) and not($isInterface = 'true')">
									<xsl:choose>
										<xsl:when test="not(@additionalEnumerationValuesAllowed='true')">
											<xsl:text>.</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	 * </xsl:text>
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text>&#10;</xsl:text>
											<xsl:text disable-output-escaping="yes"><![CDATA[	 * <i>Warning:</i> authors can only choose from a strict list of enumeration values ]]></xsl:text>
										</xsl:when>
										<xsl:when test="   (@additionalEnumerationValuesAllowed='true')">
											<xsl:text>.</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	 * </xsl:text>
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text>&#10;</xsl:text>
											<xsl:text disable-output-escaping="yes"><![CDATA[	 * <i>Hint:</i> authors have option to choose from an extendible list of predefined enumeration values ]]></xsl:text>
										</xsl:when>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:for-each select="enumeration">
										<xsl:if test="position() > 1">
											<xsl:text>, </xsl:text>
										</xsl:if>
										<xsl:text>{@link </xsl:text>
										<xsl:text>#</xsl:text>
										<xsl:value-of select="upper-case(../@name)"/>
										<xsl:text>_</xsl:text>
										<!-- enumeration name: omit " character, others become _ underscore -->
										<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
										<xsl:text> </xsl:text>
										<!-- enumeration name: omit " character, others become _ underscore -->
										<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
										<xsl:text>}</xsl:text>
									</xsl:for-each>
									<xsl:text>)</xsl:text>
								</xsl:if>
								<xsl:text>.</xsl:text>
								<xsl:text>&#10;</xsl:text>
                                <!--
								<xsl:if test="(string-length($newValueInstanceAcceptableNodeTypesTest) > 0)">
									<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest"/>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
                            -->

								<xsl:if test="($type='SFNode') and not($isInterface = 'true') and not($isX3dStatement = 'true')">
                                    <!-- ProtoInstance can only replace nodes, not statements -->
									<xsl:text>	 * @see #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(ProtoInstance)</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(string-length($fieldTooltip) > 0)">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;Tooltip:&lt;/i&gt; </xsl:text>
									<!-- TODO recurse to insert line breaks for each Hint: -->
									<!-- TODO regular expression to insert links for url text -->
									<!-- don't escape apostrophes, that makes javadoc unhappy -->
									<!-- xsl:text> debug: escape-javadoc-characters2 </xsl:text -->
									<xsl:call-template name="bulletize-hints-warnings">
										<xsl:with-param name="tooltipText">
											<xsl:call-template name="wrap-hyperlinks">
												<xsl:with-param name="string">
													<!-- xsl:text> debug: escape-javadoc-characters3 </xsl:text -->
													<xsl:call-template name="escape-javadoc-characters">
														<xsl:with-param name="inputValue">
															<xsl:value-of select="normalize-space(substring-after($fieldTooltip,']'))" disable-output-escaping="yes"/>
														</xsl:with-param>
													</xsl:call-template>
												</xsl:with-param>
											</xsl:call-template>
										</xsl:with-param>
									</xsl:call-template>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:choose>
									<xsl:when test="(@name = 'DEF')">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text> Note that setting the DEF value clears the USE value.</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
									<xsl:when test="(@name = 'USE')">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> each <code>USE</code> node is still an independent object, with the <code>USE</code> value matching the <code>DEF</code> value in the preceding object. ]]></xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Warning:</i> invoking the <code>setUSE()</code> method on this node resets all other fields to their default values (except for containerField) and also releases all child nodes.]]></xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Warning:</i> no other operations can be performed to modify a USE node other than setting an alternate containerField value.]]></xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
								</xsl:choose>
								<xsl:if test="(@type = 'MFNode') and (string-length(@acceptableNodeTypes) > 1)">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
									<xsl:value-of select="@acceptableNodeTypes"/>
									<xsl:text>.</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(@name = 'name') and (($name = 'component') or ($name = 'meta') or ($name = 'unit') or ($name = 'field') or ($name = 'fieldValue') or starts-with($name, 'CAD') or starts-with($name, 'HAnim') or starts-with($name, 'Metadata') or contains($name, 'Proto'))">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes"><![CDATA[@see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="($name = 'meta')">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[@see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#metaStatements" target="_blank">X3D Scene Authoring Hints: meta Statements</a>]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(@name = 'metadata') or starts-with($name, 'Metadata')">
									<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:text>	 * @param </xsl:text>
								<xsl:value-of select="$newValue"/>
								<xsl:text> is new value for the </xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:text> field.</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 * @return {@link </xsl:text>
								<xsl:value-of select="$thisClassName"/>
								<xsl:text>} - namely </xsl:text>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:text>this</xsl:text>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
								<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
								<!-- https://parlab.eecs.berkeley.edu/wiki/_media/patterns
								     https://parlab.eecs.berkeley.edu/wiki/_media/patterns/pipeline-v1.pdf -->
								<!-- https://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html -->

								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 */</xsl:text><!-- end javadoc -->
                                                                <xsl:text>&#10;</xsl:text>
								<xsl:variable name="isSingleValueType">
									<xsl:value-of select="starts-with(@type,'SF') and not(contains(@type, 'Vec')) and not(contains(@type, 'Rotation')) and not(contains(@type, 'Color')) and not(contains(@type, 'Matrix'))"/>
								</xsl:variable>
								<xsl:variable name="newValueNullExceptionCheck">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
									<xsl:text>("</xsl:text>
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is null and cannot be set"); // newValueNullExceptionCheck</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullClearsFieldReturnThis">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			</xsl:text>
                                    <xsl:text>clear</xsl:text>
                                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                                    <xsl:text>(); // reset newValueNullClearsFieldReturnThis</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			return</xsl:text>
									<xsl:if test="not(@name = 'children') or ($name = 'ProtoBody')">
										<xsl:text> this</xsl:text>
									</xsl:if>
									<xsl:text>;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullClearsFieldReturnVoid">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			</xsl:text>
                                    <xsl:text>clear</xsl:text>
                                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                                    <xsl:text>(); // reset newValueNullClearsFieldReturnVoid</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			return;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullReturnSelf">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null) return; // newValueNullReturnSelf</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullReturnThis">
									<!-- ignores addition of null node to array -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null) return this; // newValueNullReturnThis</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullSetDEFAULT_VALUE">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null)</xsl:text>
                                    <xsl:choose>
                                        <xsl:when test="(@type = 'SFNode')">
                                            <xsl:text>			// reset value field to null</xsl:text>
                                            <xsl:text>&#10;</xsl:text>
                                        </xsl:when>
                                        <xsl:when test="(@type = 'MFNode')">
                                            <xsl:text>			// reset value field to empty array</xsl:text>
                                            <xsl:text>&#10;</xsl:text>
                                        </xsl:when>
                                    </xsl:choose>
									<xsl:choose>
										<xsl:when test="($isSingleValueType = 'true')">
											<xsl:text>			return set</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											<xsl:text>(</xsl:text>
											<xsl:value-of select="upper-case(translate(@name,'-','_'))"/> <!-- translate name here to avoid xpath problems -->
											<xsl:text>_DEFAULT_VALUE); // newValueNullSetDEFAULT_VALUE</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>		{</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>			clear</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											<xsl:text>(); // newValueNullSetDEFAULT_VALUE</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>			return this;</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>		}</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:variable name="newProtoInstanceNodeNullReturnThis">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (newProtoInstanceNode == null) return this</xsl:text>
									<xsl:text>; // newProtoInstanceNodeNullReturnThis</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueInstanceAcceptableNodeTypesJavadoc">
									<xsl:if test="contains(@acceptableNodeTypes, '|')">
										<xsl:text disable-output-escaping="yes">
		 * Allowed node types include </xsl:text>
										<xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
											<xsl:variable name="acceptableNodeType" select="string(.)"/>
											<xsl:value-of select="$acceptableNodeType"/>
											<xsl:if test="(position() != last())">
												<xsl:text>, </xsl:text>
											</xsl:if>
										</xsl:for-each>
										<xsl:if test="(@type = 'MFNode') and ((@name='children') or contains(@acceptableNodeTypes, 'children'))">
											<!-- these statements do not qualify as SFNode fields -->
											<xsl:text> as well as X3D statements CommentsBlock, ROUTEObject, IMPORTObject, EXPORTObject, ProtoDeclare and ExternProtoDeclare.</xsl:text>
										</xsl:if>
										<xsl:text>.</xsl:text>
										<xsl:if test="contains(@acceptableNodeTypes, 'LayerSet')">
											<!-- TODO -->
										</xsl:if>
									</xsl:if>
								</xsl:variable>
								<xsl:variable name="newValueArrayListAcceptableNodeTypesTest">
									<xsl:if test="contains(@acceptableNodeTypes, '|')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		// newValueArrayListAcceptableNodeTypesTest checks are needed for methods that override/subset X3DNode interfaces #3
		for (org.web3d.x3d.sai.Core.X3DNode element : ]]></xsl:text>
										<xsl:value-of select="$newValue"/>
										<xsl:text>)
		{
			boolean isNodeTypeAllowed = </xsl:text>
										<xsl:if test="((@name='children') or contains(@acceptableNodeTypes, 'children'))">
											<xsl:text>
				(element instanceof org.web3d.x3d.jsail.Core.CommentsBlock) ||
				(element instanceof org.web3d.x3d.jsail.Core.ROUTE) ||
				(element instanceof org.web3d.x3d.jsail.Networking.IMPORT) ||
				(element instanceof org.web3d.x3d.jsail.Networking.EXPORT) ||
				(element instanceof org.web3d.x3d.jsail.Core.ProtoDeclare) ||
				(element instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclare) ||</xsl:text>
										</xsl:if>
										<!-- must save access to object model tree before going inside an xsl:for-each that loops over strings -->
										<xsl:variable name="X3dUnifiedObjectModelTree" select="/"/>
										<xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
											<xsl:variable name="acceptableNodeType" select="string(.)"/>
											<xsl:choose>
												<xsl:when test="($acceptableNodeType = 'LayerSet')">
													<xsl:text>
				(element instanceof org.web3d.x3d.jsail.Layering.LayerSet)</xsl:text>
												</xsl:when>
												<xsl:when test="not(starts-with($acceptableNodeType, 'X3D'))">
													<xsl:text>
				(element instanceof org.web3d.x3d.jsail.</xsl:text>
													<xsl:value-of select="translate($X3dUnifiedObjectModelTree//ConcreteNodes/ConcreteNode[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
													<xsl:value-of select="$jsaiClassSuffix"/>
													<xsl:text>)</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>
				(element instanceof </xsl:text>
                                                    <xsl:variable name="saiPackagePath">
                                                        <xsl:call-template name="saiPackage">
                                                            <xsl:with-param name="nodeType" select="$acceptableNodeType"/>
                                                        </xsl:call-template>
                                                    </xsl:variable>
                                                    <xsl:choose>
                                                        <xsl:when test="(string-length($saiPackagePath) > 0)">
                                                            <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 18a */</xsl:text></xsl:if> -->
                                                            <xsl:value-of select="$saiPackagePath"/>
                                                            <xsl:text>.</xsl:text>
                                                            <xsl:value-of select="$acceptableNodeType"/>
                                                        </xsl:when>
                                                        <xsl:otherwise>
                                                            <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 18b, saiPackage not found */</xsl:text></xsl:if> -->
                                                            <xsl:value-of select="$acceptableNodeType"/>
                                                        </xsl:otherwise>
                                                    </xsl:choose>
													<xsl:text>)</xsl:text>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:if test="(last() > position())">
												<xsl:text> || </xsl:text>
											</xsl:if>
										</xsl:for-each>
										<xsl:text>;
			if  (!isNodeTypeAllowed)
			{
				throw new org.web3d.x3d.sai.InvalidFieldValueException("X3DNode[] element is not instanceof " +
					"acceptableNodeTypes </xsl:text>
				<xsl:value-of select="@acceptableNodeTypes"/>
				<xsl:text>; element=" + element);
			}
		}
</xsl:text>
									</xsl:if>
								</xsl:variable>
								<xsl:variable name="isEnumerationType" select="(count(enumeration) > 0)"/>
                                <xsl:variable name="isEnumerationTypeRequired" select="boolean(@additionalEnumerationValuesAllowed='false')"/>

								<!-- source code: set method -->
								<xsl:if test="(not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')) or
												 (($isInterface = 'true') and //AbstractNodeType  [@name = $baseType                     ]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($isInterface = 'true') and //AbstractNodeType  [@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($isInterface = 'true') and //AbstractObjectType[@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($thisClassName = 'ProtoInstance') and
												  (($CamelCaseName = 'Metadata') or ($CamelCaseName = 'Name') or ($CamelCaseName = 'DEF') or ($CamelCaseName = 'USE') or ($CamelCaseName = 'CssClass')) or
												 (not($thisClassName = 'X3DNode') and ($CamelCaseName = 'Metadata')))">
									<!--<xsl:text>	/* @Override */</xsl:text>-->
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:text>	public </xsl:text>
								<!-- might avoid final in case someone is subclassing someday, but logic is tricky and so conservative here -->
								<xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'id') or (@name = 'class') or ((@name = 'style') and not(ends-with($thisClassName, 'FontStyle'))) or (@name = 'name') or (@name = 'content')) and not($isInterface = 'true')">
									<xsl:text>final </xsl:text>
								</xsl:if>
								<xsl:value-of select="$thisClassName"/>
								<xsl:text> </xsl:text>
								<xsl:choose>
									<xsl:when test="(@name = 'addChildren') or (@name = 'removeChildren')">
										<!-- no change in corresponding method name -->
										<xsl:value-of select="@name"/>
										<!-- TODO update javadoc descriptions accordingly -->
										<!-- TODO SFNode utility methods corresponding to MFNode methods -->
									</xsl:when>
									<xsl:otherwise>
										<xsl:text>set</xsl:text>
										<xsl:choose>
											<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
												<!-- unmodified -->
												<xsl:value-of select="@name"/>
											</xsl:when>
                                            <xsl:when test="(@name = 'id')">
                                                <!-- similarly named for clarity, consistency -->
                                                <xsl:text>HtmlID</xsl:text>
                                            </xsl:when>
											<xsl:when test="(@name = 'class')">
												<!-- getClass() is reserved by Java Object() class -->
												<xsl:text>CssClass</xsl:text>
											</xsl:when>
											<xsl:when test="(@name = 'style') and not(ends-with($thisClassName, 'FontStyle'))">
                                                <!-- similarly named for clarity, consistency -->
												<xsl:text>CssStyle</xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											</xsl:otherwise>
										</xsl:choose>
										<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
											<xsl:text>List</xsl:text><!-- append to member name -->
										</xsl:if>
									</xsl:otherwise>
								</xsl:choose>
								<xsl:text>(</xsl:text>
								<xsl:variable name="saiPackagePath">
                                    <xsl:call-template name="saiPackage">
                                        <xsl:with-param name="nodeType" select="$javaType"/>
                                    </xsl:call-template>
                                </xsl:variable>
				<xsl:variable name="saiPackagePathPrimitive">
                                    <xsl:call-template name="saiPackage">
                                        <xsl:with-param name="nodeType" select="$javaPrimitiveType"/>
                                    </xsl:call-template>
                                </xsl:variable>
                                <xsl:choose>
                                    <xsl:when test="(string-length($saiPackagePath) > 0)">
                                        <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 6a */</xsl:text></xsl:if>
                                        <xsl:value-of select="$saiPackagePath"/>
                                        <xsl:text>.</xsl:text>
                                        <xsl:value-of select="$javaType" disable-output-escaping="yes"/>
                                    </xsl:when>
                                    <xsl:when test="(string-length($saiPackagePathPrimitive) > 0)">
                                        <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 6b */</xsl:text></xsl:if>
                                        <xsl:value-of select="$saiPackagePathPrimitive"/>
                                        <xsl:text>.</xsl:text>
                                        <xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
                                    </xsl:when>
                                    <xsl:when test="(@type = 'MFNode') and (($isClassX3dStatement = 'true') or ($isX3dStatement = 'true') or (@name = 'addChildren') or (@name = 'removeChildren'))">
                                        <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 6c, saiPackage not found */</xsl:text></xsl:if>
                                        <xsl:value-of select="$javaType" disable-output-escaping="yes"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 6d, $javaPrimitiveType */</xsl:text></xsl:if>
                                        <xsl:value-of select="$javaPrimitiveType"/>
                                    </xsl:otherwise>
								</xsl:choose>
								<xsl:text> </xsl:text>
								<xsl:value-of select="$newValue"/>
								<xsl:text>)</xsl:text>
								<xsl:choose>
									<xsl:when test="($isInterface = 'true')">
										<xsl:text>;</xsl:text>
										<!-- note that node type cannot be constrained further here because this method implements/overrides an SAI interface -->
										<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
											<xsl:text> // acceptable node types #2: </xsl:text>
											<xsl:value-of select="@acceptableNodeTypes"/>
										</xsl:if>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	{</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>		// set-newValue-validity-checks #0.a</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:call-template name="set-newValue-validity-checks">
											<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
											<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
											<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
											<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
											<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
                                            <xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
											<xsl:with-param name="comparisonType"   ><xsl:text>simple</xsl:text></xsl:with-param>
									        <xsl:with-param name="debug"            ><xsl:text>true</xsl:text></xsl:with-param>
										</xsl:call-template>

                                        <!-- debug
                                        <xsl:text disable-output-escaping="yes"><![CDATA[
		// $isEnumerationTypeRequired=]]></xsl:text>
						<xsl:value-of select="$isEnumerationTypeRequired"/>
						<xsl:text disable-output-escaping="yes"><![CDATA[
]]></xsl:text> -->
                                        <xsl:if test="$isEnumerationTypeRequired">
                                            <!-- TODO -->
                                        </xsl:if>

										<xsl:if test="($name = 'field') and (@name = 'type')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
		if (newValue.isEmpty() ) // no value provided to set type
		{
			String warningMessage = "[warning] field type newValue=\"" + newValue + "\" has no value, ignored.";
			if (ConfigurationProperties.isConsoleOutputVerbose())
			    System.out.println(warningMessage);
			return this;
		}
		boolean isStringType  = newValue.equals(field.TYPE_SFSTRING) || newValue.equals(field.TYPE_MFSTRING);
		boolean isBooleanType = newValue.equals(field.TYPE_SFBOOL)   || newValue.equals(field.TYPE_MFBOOL);
		boolean isIntegerType = newValue.equals(field.TYPE_SFINT32)  || newValue.equals(field.TYPE_MFINT32) ||
								newValue.equals(field.TYPE_SFIMAGE)  || newValue.equals(field.TYPE_MFIMAGE);
		boolean isFloatType   = newValue.equals(field.TYPE_SFCOLOR)    || newValue.equals(field.TYPE_MFCOLOR) ||
								newValue.equals(field.TYPE_SFCOLORRGBA)|| newValue.equals(field.TYPE_MFCOLORRGBA) ||
								newValue.equals(field.TYPE_SFFLOAT)    || newValue.equals(field.TYPE_MFFLOAT) ||
								newValue.equals(field.TYPE_SFROTATION) || newValue.equals(field.TYPE_MFROTATION) ||
								newValue.equals(field.TYPE_SFVEC2F)    || newValue.equals(field.TYPE_MFVEC2F) ||
								newValue.equals(field.TYPE_SFVEC3F)    || newValue.equals(field.TYPE_MFVEC3F) ||
								newValue.equals(field.TYPE_SFVEC4F)    || newValue.equals(field.TYPE_MFVEC4F) ||
								newValue.equals(field.TYPE_SFMATRIX3F) || newValue.equals(field.TYPE_MFMATRIX3F) ||
								newValue.equals(field.TYPE_SFMATRIX4F) || newValue.equals(field.TYPE_MFMATRIX4F);
		boolean isDoubleType  = newValue.equals(field.TYPE_SFDOUBLE)   || newValue.equals(field.TYPE_MFDOUBLE) ||
								newValue.equals(field.TYPE_SFTIME)     || newValue.equals(field.TYPE_MFTIME) ||
								newValue.equals(field.TYPE_SFVEC2D)    || newValue.equals(field.TYPE_MFVEC2D) ||
								newValue.equals(field.TYPE_SFVEC3D)    || newValue.equals(field.TYPE_MFVEC3D) ||
								newValue.equals(field.TYPE_SFVEC4D)    || newValue.equals(field.TYPE_MFVEC4D) ||
								newValue.equals(field.TYPE_SFMATRIX3D) || newValue.equals(field.TYPE_MFMATRIX3D) ||
								newValue.equals(field.TYPE_SFMATRIX4D);

		boolean hasStringValuePresent  = (value.length() > 0);
		boolean hasBooleanValuePresent = (valueArrayBoolean.length > 0);
		boolean hasIntegerValuePresent = (valueArrayInteger.length > 0);
		boolean hasFloatValuePresent   = (valueArrayFloat.length   > 0);
		boolean hasDoubleValuePresent  = (valueArrayDouble.length  > 0);

		boolean hasMismatchedValuePresent = // (hasStringValuePresent  && !isStringType)  ||
											(hasBooleanValuePresent && !isBooleanType) ||
											(hasIntegerValuePresent && !isIntegerType) ||
											(hasFloatValuePresent   && !isIntegerType && !isFloatType)   ||
											(hasDoubleValuePresent  && !isIntegerType && !isFloatType && !isDoubleType);
		if (hasMismatchedValuePresent)
		{
			// Report if prior data is getting cleared from a differently typed value holder
			String warningMessage = "[warning] field name=\"" + getName() + "\" type=\"" + newValue + "\" has prior value with mismatched type already set, ";
//			if (!isStringType && hasStringValuePresent)
//          {
//              maxLength = max (value.length(),40);
//              if (ConfigurationProperties.isConsoleOutputVerbose())
//		    System.out.println(warningMessage + "String value=\"" + value.substring(0,maxLength) + "\"");
//          }
            int maxLength;
            if (!isBooleanType && hasBooleanValuePresent)
            {
                maxLength = Integer.min(new MFBool(valueArrayBoolean).toString().length(),40);
                if (ConfigurationProperties.isConsoleOutputVerbose())
  		    System.out.println(warningMessage + "valueArrayBoolean=[" + new MFBool(valueArrayBoolean).toString().substring(0,maxLength)  + "]");
            }
			if (!isIntegerType && hasIntegerValuePresent)
            {
                maxLength = Integer.min(new MFInt32(valueArrayInteger).toString().length(),40);
                if (ConfigurationProperties.isConsoleOutputVerbose())
  		    System.out.println(warningMessage + "valueArrayInteger=[" + new MFInt32(valueArrayInteger).toString().substring(0,maxLength) + "]");
            }
            if (!isFloatType && hasFloatValuePresent)
            {
            maxLength = Integer.min(new MFFloat(valueArrayFloat).toString().length(),40);
            if (ConfigurationProperties.isConsoleOutputVerbose())
  		System.out.println(warningMessage + "valueArrayFloat=["   + new MFFloat(valueArrayFloat).toString().substring(0,maxLength)   + "]");
            }
            if (!isDoubleType && hasDoubleValuePresent)
            {
                maxLength = Integer.min(new MFDouble(valueArrayDouble).toString().length(),40);
                if (ConfigurationProperties.isConsoleOutputVerbose())
  		    System.out.println(warningMessage + "valueArrayDouble=["  + new MFDouble(valueArrayDouble).toString().substring(0,maxLength) + "]");
            }
		}
		// When assigning type: if appropriate, shift prior string value to corresponding typed array
		if (newValue.equals(field.TYPE_SFNODE)   || newValue.equals(field.TYPE_MFNODE))
		{
			// clear all arrays
			value             = new   String(); // reset
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if (isStringType)
		{
			// leave String value array alone, clear other arrays
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if (isBooleanType)
		{
			// don't overwrite prior array if present, otherwise recover string value
			if (!hasBooleanValuePresent && hasStringValuePresent)
				valueArrayBoolean = new MFBool().setValueByString(value).getPrimitiveValue();
			value             = new   String(); // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if (isIntegerType)
		{
			// don't overwrite prior array if present, otherwise recover string value
			if (!hasIntegerValuePresent && hasStringValuePresent)
				valueArrayInteger = new MFInt32().setValueByString(value).getPrimitiveValue();
			value             = new   String(); // reset
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if (isFloatType)
		{
			// don't overwrite prior array if present, otherwise recover string value
			if (!hasFloatValuePresent && hasStringValuePresent)
				valueArrayFloat = new MFFloat().setValueByString(value).getPrimitiveValue();
			value             = new   String(); // reset
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if (isDoubleType)
		{
			// don't overwrite prior array if present, otherwise recover string value
			if (!hasDoubleValuePresent && hasStringValuePresent)
				valueArrayDouble = new MFDouble().setValueByString(value).getPrimitiveValue();
			value             = new   String(); // reset
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
		}
]]></xsl:text>
										</xsl:if>
										<xsl:if test="(($name = 'field') or ($name = 'fieldValue')) and (@name = 'value')">
													<xsl:text disable-output-escaping="yes"><![CDATA[		// check for legal type
		String valueType = getType();
		if (valueType.equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE))
			valueType = field.TYPE_SFSTRING; // same as default found in file encodings
			// TODO must recheck during run-time validation to ensure fully constructed OK

		if ((valueType.equals(field.TYPE_SFNODE) || valueType.equals(field.TYPE_MFNODE)) &&
			(newValue.length() > 0))
		{
			throw new org.web3d.x3d.sai.InvalidProtoException("field name='" + getName() + "' with type='" + valueType +
					"' cannot have any simple-type value (newValue='" + newValue + "').  Use setChildren() method instead.");
		}
		else if (valueType.equals(field.TYPE_SFSTRING) || valueType.equals(field.TYPE_MFSTRING))
		{
			value = newValue;
		}]]></xsl:text>
						<xsl:for-each select="//FieldTypes/FieldType">
							<xsl:variable name="fieldName" select="@type"/>
							<xsl:variable name="upperCaseFieldName" select="upper-case($fieldName)"/>
							<xsl:variable name="baseVariable">
								<xsl:choose>
									<xsl:when test="contains(@type,'String')">
										<xsl:text>value</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Bool')">
										<xsl:text>valueArrayBoolean</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Int32') or contains(@type,'Image')">
										<xsl:text>valueArrayInteger</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Float') or contains(@type,'Color') or contains(@type,'Rotation') or
													ends-with(@type,'f') or (@type = 'bboxSizeType')">
										<xsl:text>valueArrayFloat</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Double') or contains(@type,'Time') or ends-with(@type,'d')">
										<xsl:text>valueArrayDouble</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'FNode')">
										<!-- handled by getChildren method -->
									</xsl:when>
									<xsl:otherwise>
										<xsl:message>
											<xsl:text>*** unhandled baseVariable: </xsl:text>
											<xsl:value-of select="@type"/>
										</xsl:message>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<!-- typed get methods -->
							<xsl:choose>
								<xsl:when test="contains(@type,'FNode')">
									<!-- handled by getChildren() -->
								</xsl:when>
								<xsl:when test="contains(@type,'FString')">
									<!-- already handled prior to this loop -->
								</xsl:when>
								<xsl:when test="starts-with(@type,'SF')">
							<xsl:text>
		else if (valueType.equals(field.TYPE_</xsl:text><xsl:value-of select="$upperCaseFieldName"/><xsl:text>))
		{
			</xsl:text>
			<xsl:value-of select="$baseVariable"/>
			<!--
			<xsl:if test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
				<xsl:text>[0]</xsl:text>
			</xsl:if>
			-->
			<xsl:text> = new M</xsl:text>
			<xsl:value-of select="substring($fieldName,2)"/>
			<xsl:value-of select="$jsaiClassSuffix"/>
			<xsl:text>().setValueByString(newValue).getPrimitiveValue();
		}
	</xsl:text>
								</xsl:when>
							</xsl:choose>
						</xsl:for-each>
										</xsl:if>
										<xsl:choose>
											<xsl:when test="(@name = 'DEF')">
												<xsl:text>		setConcreteUSE(""); // ensure that no previous USE value remains</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		setConcreteDEF(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>); // private superclass methods</xsl:text>
											</xsl:when>
											<xsl:when test="(@name = 'USE')">
												<xsl:text>		setConcreteDEF(""); // ensure that no previous DEF value remains</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		setConcreteUSE(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>); // private superclass method</xsl:text>
											</xsl:when>
											<xsl:when test="(@name = 'id')">
												<xsl:text>		setConcreteHtmlID(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>); // private superclass method</xsl:text>
											</xsl:when>
											<xsl:when test="(@name = 'class')">
												<xsl:text>		setConcreteCssClass(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>); // private superclass method</xsl:text>
											</xsl:when>
											<xsl:when test="(@name = 'style') and not(ends-with($thisClassName, 'FontStyle'))">
												<xsl:text>		setConcreteCssStyle(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>); // private superclass method</xsl:text>
											</xsl:when>
											<!-- https://stackoverflow.com/questions/10530353/convert-string-array-to-arraylist -->
											<xsl:when test="(@type = 'SFNode') and not($javaPrimitiveType = $javaType) and not($isX3dStatement = 'true')">
												<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
												<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
												<!-- SFNode subtype checks necessary -->
												<xsl:text>	if (</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text> instanceof </xsl:text>
												<xsl:value-of select="$javaType"/>
												<xsl:text>)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>	{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>       </xsl:text>
												<xsl:value-of select="@name"/>
												<xsl:text> = </xsl:text>
												<xsl:text>(</xsl:text>
												<xsl:value-of select="$javaType"/>
												<xsl:text>)</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>;</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>       ((X3DConcreteElement) </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>).setParent(this); // parentTest10</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>	}</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>	else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
												<xsl:text>("</xsl:text>
												<xsl:value-of select="$javaPrimitiveType"/>
												<xsl:text> </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>=(</xsl:text>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
												<xsl:text>) is not instanceof </xsl:text>
												<xsl:value-of select="$javaType"/>
												<xsl:text>; </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>=" + </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>);</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'MFNode') and (($isX3dStatement = 'true') or ($isClassX3dStatement = 'true'))">
												<xsl:if test="($name = 'ProtoBody')">
													<xsl:text>		if (primaryNode != null)
		{
			primaryNode.setParent(null); // housekeeping, clear prior object
		    primaryNode = null;
		}
</xsl:text>
												</xsl:if>
												<xsl:text>		</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text> = </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>;</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		for (</xsl:text>
												<xsl:value-of select="$javaReferenceType"/>
												<xsl:text> arrayElement : </xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		{</xsl:text>
												<xsl:if test="($name = 'ProtoBody')">
													<xsl:text disable-output-escaping="yes"><![CDATA[
			if ((primaryNode == null) && (arrayElement instanceof org.web3d.x3d.jsail.X3DConcreteNode))
			{
				primaryNode = (X3DConcreteNode) arrayElement; // remember node type
				primaryNode.setParent(this);
			}
]]></xsl:text>
												</xsl:if>
												<!-- special set method validation, assignment checks -->
												<xsl:choose>
													<xsl:when test="($name = 'ExternProtoDeclare') and (@name = 'field')">
		<!-- check to ensure that no value is present within field having parent ExternProtoDeclare -->
		<xsl:text disable-output-escaping="yes"><![CDATA[			// No value is allowed within field having parent ExternProtoDeclare
			if ((!arrayElement.getValue().isEmpty() || !arrayElement.getChildren().isEmpty()) && arrayElement.hasChildrenElements())
			{
				String foundValue;
				if (!arrayElement.getValue().isEmpty())
					 foundValue = arrayElement.getValue();
				else foundValue = arrayElement.getChildren().toString();

				throw new org.web3d.x3d.sai.InvalidProtoException("ExternProtoDeclare name='" + name +
					"' with field name='" + arrayElement.getName() +
					"' cannot have any initial value (found \"" + foundValue +
					"\"). Instead use ProtoInstance fieldValue to override the original default ProtoDeclare field value.");
			}
]]></xsl:text>
													</xsl:when>
												</xsl:choose>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			((X3DConcreteElement) arrayElement).setParent(this); // parentTest11</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		}</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'MFNode') and not(starts-with($javaType, $javaReferenceType)) and not($isX3dStatement = 'true')">
												<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
												<xsl:value-of select="$newValueArrayAcceptableNodeTypesTest" disable-output-escaping="yes"/>
												<xsl:text>		</xsl:text>
                                                <xsl:text>clear</xsl:text>
                                                <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                                                <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                                                <xsl:text>(); // reset</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<!-- MFNode subtype checks necessary -->
												<xsl:text>		for (int i = 0; i </xsl:text>
												<xsl:text disable-output-escaping="yes">&lt; </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>.length; i++)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			if  ((</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>[i] instanceof </xsl:text>
												<xsl:value-of select="$javaReferenceType"/>
												<xsl:text>) || (</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>[i] instanceof ProtoInstance))</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>				</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>.add(</xsl:text>
												<!-- cast -->
												<xsl:if test="not($isX3dStatement = 'true') and not($javaReferenceType = 'X3DNode')">
													<xsl:text>(</xsl:text>
													<xsl:value-of select="$javaReferenceType"/>
													<xsl:text>)</xsl:text>
												</xsl:if>
												<xsl:value-of select="$newValue"/>
												<xsl:text>[i]);</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:if test="($name = 'ProtoBody') and not($isInterface = 'true')">
													<xsl:text disable-output-escaping="yes"><![CDATA[
			if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof org.web3d.x3d.jsail.X3DConcreteNode))
			{
				primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>; // remember node type
				primaryNode.setParent(this);
			}
</xsl:text>
												</xsl:if>
												<xsl:text>				((X3DConcreteElement) </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>[i]).setParent(this); // parentTest12</xsl:text>
												<xsl:text>&#10;</xsl:text>
													<xsl:choose>
														<!-- MFNode child -->
														<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
															<xsl:text>				((X3DConcreteNode)    </xsl:text>
															<xsl:value-of select="$newValue"/>
															<xsl:text>[i]).setContainerFieldOverride("value");</xsl:text>
															<xsl:text>&#10;</xsl:text>
														</xsl:when>
													</xsl:choose>
												<xsl:text>			}</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
												<xsl:text>("</xsl:text>
												<xsl:value-of select="$javaPrimitiveType"/>
												<xsl:text> </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>["+i+"] is not instanceof </xsl:text>
												<xsl:value-of select="$javaReferenceType"/>
												<xsl:text> or ProtoInstance array </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>=" + </xsl:text>
												<xsl:text>Arrays.toString(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>)</xsl:text>
												<xsl:text>);</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		}</xsl:text>
											</xsl:when>
											<xsl:when test="($isArrayListType = 'true') and not($javaReferenceType = 'X3DNode') and not($isX3dStatement = 'true')">
												<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
												<!-- https://stackoverflow.com/questions/39873596/convert-array-of-strings-to-boolean-list-in-java -->
												<xsl:text>		</xsl:text>
                                                <xsl:text>clear</xsl:text>
                                                <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                                                <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                                                <xsl:text>(); // reset</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		for (int i = 0; i </xsl:text>
												<xsl:text disable-output-escaping="yes">&lt; </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>.length; i++)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:choose>
													<xsl:when test="(@type = 'MFNode') and not(starts-with($javaPrimitiveType, $javaReferenceType))">
														<xsl:value-of select="$newValueArrayAcceptableNodeTypesTest" disable-output-escaping="yes"/>
														<!-- SFNode subtype checks necessary -->
														<xsl:text>			if (</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>[i] instanceof </xsl:text>
														<xsl:value-of select="$javaReferenceType"/>
														<xsl:value-of select="$jsaiClassSuffix"/>
														<xsl:text>)</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>			{</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:if test="($name = 'ProtoBody') and not($isInterface = 'true')">
															<xsl:text disable-output-escaping="yes"><![CDATA[
				if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof org.web3d.x3d.jsail.X3DConcreteNode))
				{
					primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>[i]; // remember node type
					primaryNode.setParent(this);
				}
</xsl:text>
														</xsl:if>
														<xsl:text>				</xsl:text>
														<xsl:value-of select="@name"/>
														<xsl:text>.add(</xsl:text>
														<xsl:text>(</xsl:text>
														<xsl:value-of select="$javaReferenceType"/>
														<xsl:value-of select="$jsaiClassSuffix"/>
														<xsl:text>)</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>[i]);</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>       ((X3DConcreteElement) </xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>[i]).setParent(this); // apparently unused?</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>			}</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>			else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
														<xsl:text>("</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>["+i+"] is not instanceof </xsl:text>
														<xsl:value-of select="$javaReferenceType"/>
														<xsl:value-of select="$jsaiClassSuffix"/>
														<xsl:text>; </xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>=" + </xsl:text>
														<xsl:choose>
															<xsl:when test="starts-with(@type,'MF')">
																<xsl:text>Arrays.toString(</xsl:text>
																<xsl:value-of select="$newValue"/>
																<xsl:text>)</xsl:text>
															</xsl:when>
															<xsl:otherwise>
																<xsl:value-of select="$x3dType"/>
																<xsl:value-of select="$jsaiClassSuffix"/>
																<xsl:text>.toString(</xsl:text>
																<xsl:value-of select="$newValue"/>
																<xsl:text>)</xsl:text>
															</xsl:otherwise>
														</xsl:choose>
														<xsl:text>);</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>		}</xsl:text>
														<xsl:text>&#10;</xsl:text>
													</xsl:when>
													<xsl:otherwise>
														<xsl:text>			</xsl:text>
														<xsl:value-of select="@name"/>
														<xsl:text>.add(</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>[i]);</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>		}</xsl:text>
														<xsl:text>&#10;</xsl:text>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:when>
											<xsl:otherwise>
												<xsl:text>		</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text> = </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>;</xsl:text>
												<!-- set SFNode -->
												<xsl:if test="(@type = 'SFNode')">
													<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
													<xsl:text>
		if (</xsl:text><xsl:value-of select="$newValue"/><xsl:text> != null)
		{
			((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>).setParent(this); // parentTest15.1</xsl:text>
													<xsl:text>&#10;</xsl:text>
									<!-- as needed, containerField updates by checking parent node and SFNode field -->
									<!-- Reference list found at X3D Scene Authoring Hints: containerField -->
									<!-- https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField -->
									<xsl:choose>
										<xsl:when test="(($name = 'CADFace') or ($name = 'CollidableShape')) and (@name = 'shape')">
											<xsl:text>			</xsl:text>
											<xsl:text>((X3DConcreteNode)</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("shape");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'Collision') and (@name = 'proxy')">
											<xsl:text>			</xsl:text>
											<xsl:text>((X3DConcreteNode)</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("proxy");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'ComposedCubeMapTexture') and
														((@name = 'backTexture') or (@name = 'bottomTexture') or (@name = 'frontTexture') or
														 (@name = 'leftTexture') or (@name = 'rightTexture')  or (@name = 'topTexture'))">
											<!-- ImageTexture check -->
											<xsl:text>			((X3DConcreteNode)</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("</xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="not(starts-with($name,'Metadata')) and (@name = 'metadata')">
											<xsl:text>			// change X3D4 MetadataSet default 'value' back to 'metadata' if parent is not another Metadata* node */</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>			if (</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text> instanceof org.web3d.x3d.jsail.Core.MetadataSet)</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>{</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>				((X3DConcreteNode) </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("metadata");</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>}</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'Sound') and (@name = 'source')">
											<xsl:text>			if (</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text> instanceof org.web3d.x3d.jsail.Texturing.MovieTexture)</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>				((X3DConcreteNode)    </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("source");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'TextureBackground') and
														((@name = 'backTexture') or (@name = 'bottomTexture') or (@name = 'frontTexture') or
														 (@name = 'leftTexture') or (@name = 'rightTexture')  or (@name = 'topTexture'))">
											<!-- ImageTexture check -->
											<xsl:text>			((X3DConcreteNode)</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("</xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
									</xsl:choose>
<xsl:text>		}</xsl:text>
													<xsl:if test="not($isX3dStatement = 'true') and not(@name = 'IS')">
														<xsl:text>
		if (</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance != null)
		{
			</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance.setParent(null); // housekeeping, clear prior object
			</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance = null;
		}</xsl:text>
													</xsl:if>
												</xsl:if>
											</xsl:otherwise>
										</xsl:choose>

										<xsl:text>&#10;</xsl:text>
										<xsl:text>		return this;</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	}</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:otherwise>
								</xsl:choose>
								<xsl:text>&#10;</xsl:text>

								<xsl:if test="(($name = 'field') or ($name = 'fieldValue')) and (@name = 'value')">

                                    <xsl:for-each select="//FieldTypes/FieldType[not(contains(@type,'FNode'))]">
                                        <xsl:variable name="fieldTypeName" select="@type"/>
                                        <xsl:variable name="upperCaseFieldName" select="upper-case($fieldName)"/>
                                        <xsl:variable name="baseVariable">
                                            <xsl:choose>
                                                <xsl:when test="contains(@type,'String')">
                                                    <xsl:text>value</xsl:text>
                                                </xsl:when>
                                                <xsl:when test="contains(@type,'Bool')">
                                                    <xsl:text>valueArrayBoolean</xsl:text>
                                                </xsl:when>
                                                <xsl:when test="contains(@type,'Int32') or contains(@type,'Image')">
                                                    <xsl:text>valueArrayInteger</xsl:text>
                                                </xsl:when>
                                                <xsl:when test="contains(@type,'Float') or contains(@type,'Color') or contains(@type,'Rotation') or
                                                                ends-with(@type,'f')    or (@type = 'bboxSizeType')">
                                                    <xsl:text>valueArrayFloat</xsl:text>
                                                </xsl:when>
                                                <xsl:when test="contains(@type,'Double') or contains(@type,'Time') or ends-with(@type,'d')">
                                                    <xsl:text>valueArrayDouble</xsl:text>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                    <xsl:message>
                                                        <xsl:text>*** unhandled baseVariable: </xsl:text>
                                                        <xsl:value-of select="@type"/>
                                                    </xsl:message>
                                                </xsl:otherwise>
                                            </xsl:choose>
                                        </xsl:variable>
							<xsl:variable name="javaPrimitiveType">
								<xsl:call-template name="javaType">
									<xsl:with-param name="x3dType" select="@type"/>
									<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="javaBaseType">
								<xsl:choose>
									<xsl:when test="contains($javaPrimitiveType,'[')">
										<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$javaPrimitiveType"/><!-- array of array type -->
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
                                    <xsl:text>
	/**
	 * Append </xsl:text><xsl:value-of select="$fieldTypeName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> to </xsl:text>
                                    <xsl:value-of select="$name"/>
                                    <xsl:text disable-output-escaping="yes"><![CDATA[ for <i>value</i> attribute.
	 * <br><br>
	 * <i>Tooltip:</i> fieldValue contains initial value for this field, which overrides default initialization value defined in original ProtoDeclare field.
	 * @param newValue is new value to append to the value field.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendValue(]]></xsl:text><xsl:value-of select="$fieldTypeName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
        // set-newValue-validity-checks #TODO
]]></xsl:text>
                                        <!-- typed append methods -->
                                        <xsl:variable name="nameMFType" select="concat('M',substring(@type,2))"/>
                                        <xsl:variable name="nameSFType" select="concat('S',substring(@type,2))"/>
                                        <xsl:choose>
                                            <xsl:when test="(@type = 'SFString')">
                                                <xsl:text disable-output-escaping="yes"><![CDATA[
        if ( getType().equals(field.TYPE_SFSTRING) ||
            (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
        {
            if (newValue != null)
                   value += newValue.getPrimitiveValue();]]></xsl:text>
                                            </xsl:when>
                                            <xsl:when test="(@type = 'MFString')">
                                                <xsl:text disable-output-escaping="yes"><![CDATA[
        if ( getType().equals(field.TYPE_SFSTRING) || getType().equals(field.TYPE_MFSTRING) ||
            (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
        {
                if (newValue != null)
                   value += newValue.getPrimitiveValue();]]></xsl:text>
                                            </xsl:when>
                                            <xsl:when test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
                                        <xsl:text disable-output-escaping="yes"><![CDATA[
        if ( getType().equals(field.TYPE_]]></xsl:text><xsl:value-of select="upper-case($nameSFType)"/><xsl:text disable-output-escaping="yes"><![CDATA[) ||
            (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
        {
            // https://stackoverflow.com/questions/2843366/how-to-add-new-elements-to-an-array
            // arrays cannot be dynamically resized, must create new array of proper length
            ]]></xsl:text><xsl:value-of select="$javaBaseType"/><xsl:text>[] newArray = new </xsl:text><xsl:value-of select="$javaBaseType"/>
            <xsl:text>[</xsl:text><xsl:value-of select="$baseVariable"/><xsl:text>.length + 1];
            System.arraycopy(</xsl:text><xsl:value-of select="$baseVariable"/><xsl:text>, 0, newArray, 0, </xsl:text><xsl:value-of select="$baseVariable"/><xsl:text>.length);
            newArray[</xsl:text><xsl:value-of select="$baseVariable"/><xsl:text>.length] = newValue.getPrimitiveValue();
            </xsl:text>
            <xsl:value-of select="$baseVariable"/><xsl:text> = newArray;</xsl:text>
                                            </xsl:when>
                                            <xsl:when test="starts-with(@type,'MF') or contains(@type,'FColor') or contains(@type,'FRotation') or contains(@type,'FVec') or contains(@type,'FMatrix') or contains(@type,'FImage')">
                                        <xsl:text disable-output-escaping="yes"><![CDATA[
        if ( getType().equals(field.TYPE_]]></xsl:text><xsl:value-of select="upper-case(@type)"/><xsl:text disable-output-escaping="yes"><![CDATA[) ||
             getType().equals(field.TYPE_]]></xsl:text><xsl:value-of select="upper-case($nameSFType)"/><xsl:text disable-output-escaping="yes"><![CDATA[) ||
            (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
        {
            // https://stackoverflow.com/questions/2843366/how-to-add-new-elements-to-an-array
            // arrays cannot be dynamically resized, must create new array of proper length
            ]]></xsl:text><xsl:value-of select="$javaBaseType"/><xsl:text>[] newArray = new </xsl:text><xsl:value-of select="$javaBaseType"/>
            <xsl:text>[</xsl:text><xsl:value-of select="$baseVariable"/><xsl:text>.length + newValue.getPrimitiveValue().length];
            System.arraycopy(</xsl:text><xsl:value-of select="$baseVariable"/><xsl:text>, 0, newArray, 0, </xsl:text><xsl:value-of select="$baseVariable"/><xsl:text>.length);
            System.arraycopy(newValue.getPrimitiveValue(), 0, newArray, 0, newValue.getPrimitiveValue().length);
            </xsl:text>
            <xsl:value-of select="$baseVariable"/><xsl:text> = newArray;</xsl:text>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:message>
                                                    <xsl:text>** unhandled type=</xsl:text>
                                                    <xsl:value-of select="@type"/>
                                                </xsl:message>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:text>
        }
        else
        {
            String errorNotice = "*** Illegal type: cannot appendValue(</xsl:text><xsl:value-of select="$fieldTypeName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> " + newValue + ") when </xsl:text>
                                                    <xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
            validationResult.append(errorNotice).append("\n");
            throw new InvalidFieldValueException(errorNotice); // report error
        }
        return this;
    }
</xsl:text>
                                    </xsl:for-each>
                                    <xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Append boolean to ]]></xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ for <i>value</i> attribute.
	 * <br><br>
	 * <i>Tooltip:</i> fieldValue contains initial value for this field, which overrides default initialization value defined in original ProtoDeclare field.
	 * @param newValue is new value to append to the value field.
	 * @return {@link fieldValue} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendValue(boolean newValue)
	{
            if ( getType().equals(field.TYPE_MFBOOL) ||
                (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                boolean[] newArray = new boolean[valueArrayBoolean.length + 1];
                System.arraycopy(valueArrayBoolean, 0, newArray, 0, valueArrayBoolean.length);
                newArray[valueArrayBoolean.length] = newValue;
                valueArrayBoolean = newArray;
            }
            else
            {
                String errorNotice = "*** Illegal type: cannot appendValue(boolean " + newValue + ") when fieldValue type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
            return this;
        }
	/**
	 * Append integer to ]]></xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ for <i>value</i> attribute.
	 * <br><br>
	 * <i>Tooltip:</i> fieldValue contains initial value for this field, which overrides default initialization value defined in original ProtoDeclare field.
	 * @param newValue is new value to append to the value field.
	 * @return {@link fieldValue} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendValue(int newValue)
	{
        if ( getType().equals(field.TYPE_MFINT32) ||
            (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
        {
            int[] newArray = new int[valueArrayInteger.length + 1];
            System.arraycopy(valueArrayInteger, 0, newArray, 0, valueArrayInteger.length);
            newArray[valueArrayInteger.length] = newValue;
            valueArrayInteger = newArray;
        }
        else
        {
            String errorNotice = "*** Illegal type: cannot appendValue(int " + newValue + ") when fieldValue type='" + getType() + "'";
            validationResult.append(errorNotice).append("\n");
            throw new InvalidFieldValueException(errorNotice); // report error
        }
        return this;
    }
	/**
	 * Append float to ]]></xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ for <i>value</i> attribute.
	 * <br><br>
	 * <i>Tooltip:</i> fieldValue contains initial value for this field, which overrides default initialization value defined in original ProtoDeclare field.
	 * @param newValue is new value to append to the value field.
	 * @return {@link fieldValue} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendValue(float newValue)
	{
        if ( getType().equals(field.TYPE_MFFLOAT) ||
            (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
        {
            float[] newArray = new float[valueArrayFloat.length + 1];
            System.arraycopy(valueArrayFloat, 0, newArray, 0, valueArrayFloat.length);
            newArray[valueArrayFloat.length] = newValue;
            valueArrayFloat = newArray;
        }
        else
        {
            String errorNotice = "*** Illegal type: cannot appendValue(float " + newValue + ") when fieldValue type='" + getType() + "'";
            validationResult.append(errorNotice).append("\n");
            throw new InvalidFieldValueException(errorNotice); // report error
        }
        return this;
    }
	/**
	 * Append double to ]]></xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ for <i>value</i> attribute.
	 * <br><br>
	 * <i>Tooltip:</i> fieldValue contains initial value for this field, which overrides default initialization value defined in original ProtoDeclare field.
	 * @param newValue is new value to append to the value field.
	 * @return {@link fieldValue} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendValue(double newValue)
	{
        if ( getType().equals(field.TYPE_MFDOUBLE) || getType().equals(field.TYPE_MFTIME) ||
            (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
        {
            double[] newArray = new double[valueArrayDouble.length + 1];
            System.arraycopy(valueArrayDouble, 0, newArray, 0, valueArrayDouble.length);
            newArray[valueArrayDouble.length] = newValue;
            valueArrayDouble = newArray;
        }
        else
        {
            String errorNotice = "*** Illegal type: cannot appendValue(double " + newValue + ") when fieldValue type='" + getType() + "'";
            validationResult.append(errorNotice).append("\n");
            throw new InvalidFieldValueException(errorNotice); // report error
        }
        return this;
    }
	/**
	 * Append String (converted if necessary) to ]]></xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ for <i>value</i> attribute.
	 * For type SFString, the single string gets longer.
	 * For type MFString, another string is added to the list.
	 * For other MF types, another value converted from the string is added to the list.
	 * <br><br>
	 * <i>Tooltip:</i> fieldValue contains initial value for this field, which overrides default initialization value defined in original ProtoDeclare field.
	 * @param newValue is new value to append to the value field.
	 * @return {@link fieldValue} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendValue(String newValue)
	{
        // set-newValue-validity-checks #TODO
        if ( getType().equals(field.TYPE_SFSTRING) ||
            (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
        {
            value += newValue; // append string
        }
        else if (getType().equals(field.TYPE_MFSTRING))
        {
            if (!newValue.startsWith(" "))
                value += " ";
            if (!newValue.trim().startsWith("\""))
                value += "\""; // wrap quote
            value += newValue; // append string
            if (!newValue.trim().endsWith("\""))
                value += "\""; // wrap quote
        }
        else if (getType().equals(field.TYPE_MFBOOL))
        {
            boolean[] newArray = new boolean[valueArrayBoolean.length + 1];
            System.arraycopy(valueArrayBoolean, 0, newArray, 0, valueArrayBoolean.length);
            newArray[valueArrayBoolean.length] = new SFBool().setValueByString(newValue).getValue(); // type conversion
            valueArrayBoolean = newArray;
        }
        else if (getType().equals(field.TYPE_MFINT32))
        {
            int[] newArray = new int[valueArrayInteger.length + 1];
            System.arraycopy(valueArrayInteger, 0, newArray, 0, valueArrayInteger.length);
            newArray[valueArrayInteger.length] = new SFInt32().setValueByString(newValue).getValue(); // type conversion
            valueArrayInteger = newArray;
        }
        else if (getType().equals(field.TYPE_MFFLOAT))
        {
            float[] newArray = new float[valueArrayFloat.length + 1];
            System.arraycopy(valueArrayFloat, 0, newArray, 0, valueArrayFloat.length);
            newArray[valueArrayFloat.length] = new SFFloat().setValueByString(newValue).getValue(); // type conversion
            valueArrayFloat = newArray;
        }
        else if (getType().equals(field.TYPE_MFDOUBLE) || getType().equals(field.TYPE_MFTIME))
        {
            double[] newArray = new double[valueArrayDouble.length + 1];
            System.arraycopy(valueArrayDouble, 0, newArray, 0, valueArrayDouble.length);
            newArray[valueArrayDouble.length] = new SFDouble().setValueByString(newValue).getValue(); // type conversion
            valueArrayDouble = newArray;
        }
        else
        {
            String errorNotice = "*** Illegal type: cannot appendValue(String " + newValue + ") when ]]></xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ type='" + getType() + "'";
            validationResult.append(errorNotice).append("\n");
            throw new InvalidFieldValueException(errorNotice); // report error
        }
        return this;
    }
	/**
	 * Assign typed object MFString value to ]]></xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[, similar to {@link #setValue(String)}.
	 * @param newValue is new value for the value field.
	 * @return {@link field} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValue(MFString newValue)
	{
            if ( getType().equals(field.TYPE_MFSTRING) ||
                (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                if (newValue != null)
                    value += newValue.getPrimitiveValue();
                return this;
            }
            else
            {
                String errorNotice = "*** Illegal type: cannot appendValue(MFString " + newValue + ") when fieldValue type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
	}
	/**
	 * Assign typed object String[] array value to ]]></xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[, similar to {@link #setValue(String)}.
	 * @param newValue is new value for the value field.
	 * @return {@link field} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValue(String[] newValue)
	{
            if ( getType().equals(field.TYPE_MFSTRING) ||
                (getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                if (newValue != null)
                {
                    for (int i = 0; i < newValue.length; i++)
                    {
                        String currentString = newValue[i];
                        if (!currentString.startsWith("\""))
                        {
                             value += "\"" + newValue[i];
                        }
                        else
                        {
                            value += newValue[i];
                        }
                        if (!currentString.endsWith("\""))
                        {
                            value += "\"";
                        }
                        if (i < newValue.length - 1)
                                value += " ";
                    }
                    return this;
                }
                else
                {
                    value = null; // empty array vice singleton empty string
                    return this;
                }
            }
            else
            {
                String errorNotice = "*** Illegal type: cannot appendValue(MFString " + newValue + ") when fieldValue type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
	}
]]></xsl:text>
                                </xsl:if>

								<!-- additional field utility methods for concrete classes -->

								<!-- set method using typed field object -->
								<xsl:if test="not(@type='SFNode') and not(@type='MFNode') and not(@type='xs:NMTOKEN') and
											  not($isInterface = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign typed object </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value to </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text><!-- // #0.e -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>

									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$type" disable-output-escaping="yes"/>
									<xsl:value-of select="$jsaiClassSuffix"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>

									<xsl:if test="($isArrayListType = 'true') and not($javaReferenceType = 'X3DNode') and not($isX3dStatement = 'true')">
										<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									</xsl:if>
									<xsl:text>			// set-newValue-validity-checks #1 gets handled by set-primitive method</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<!-- stub
									<xsl:text>			// set-newValue-validity-checks #1</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>complex</xsl:text></xsl:with-param>
                                        <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									-->
									<xsl:text>			</xsl:text>
									<xsl:text>set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>.getPrimitiveValue());</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(@type = 'SFVec2f') or (@type = 'SFVec3f') or (@type = 'SFVec4f') or
												  (@type = 'SFColor') or (@type = 'SFColorRGBA') or (@type = 'SFRotation')">
										<xsl:text>
	/**
	 * Assign values to </xsl:text>
										<xsl:value-of select="@type"/>
										<xsl:text> </xsl:text>
										<xsl:value-of select="$normalizedMemberObjectName"/>
										<xsl:text> field, similar to {@link #set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float[])}.
</xsl:text>
										<xsl:choose>
											<xsl:when test="(@type = 'SFVec2f')">
												<xsl:text>
	 * @param x first component
	 * @param y second component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec3f')">
												<xsl:text>
	 * @param x first component
	 * @param y second component
	 * @param z third component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec4f')">
												<xsl:text>
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param w fourth component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFColor')">
												<xsl:text>
	 * @param red first component
	 * @param green second component
	 * @param blue third component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFColorRGBA')">
												<xsl:text>
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @param alpha fourth component for opaqueness (1 - transparency)
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFRotation')">
												<xsl:text>
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
</xsl:text>
											</xsl:when>
										</xsl:choose>
												<xsl:text>
	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:choose>
											<xsl:when test="(@type = 'SFVec2f')">
												<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float x, float y)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {x, y});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec3f')">
												<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float x, float y, float z)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {x, y, z});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec4f')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float x, float y, float z, float w)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {x, y, z, w});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFColor')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float red, float green, float blue)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {red, green, blue});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFColorRGBA')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float red, float green, float blue, float alpha)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {red, green, blue, alpha});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFRotation')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float x, float y, float z, float angleRadians)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {x, y, z, angleRadians});
		return this;
	}
</xsl:text>
											</xsl:when>
										</xsl:choose>
									</xsl:if>
									<xsl:if test="(@type = 'SFVec2d') or (@type = 'SFVec3d') or (@type = 'SFVec4d')">
										<xsl:text>
	/**
	 * Assign values to </xsl:text>
										<xsl:value-of select="@type"/>
										<xsl:text> </xsl:text>
										<xsl:value-of select="$normalizedMemberObjectName"/>
										<xsl:text> field, similar to {@link #set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(double[])}.
	 * @param x first component
	 * @param y second component
</xsl:text>
										<xsl:choose>
											<xsl:when test="(@type = 'SFVec3d')">
												<xsl:text>
	 * @param z third component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec4d')">
												<xsl:text>
	 * @param z third component
	 * @param w fourth component
</xsl:text>
											</xsl:when>
										</xsl:choose>
												<xsl:text>
	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:choose>
											<xsl:when test="(@type = 'SFVec2d')">
												<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(double x, double y)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new double[] {x, y});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec3d')">
												<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(double x, double y, double z)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new double[] {x, y, z});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec4d')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(double x, double y, double z, double w)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new double[] {x, y, z, w});
		return this;
	}
</xsl:text>
											</xsl:when>
										</xsl:choose>
									</xsl:if>
								</xsl:if>
								<xsl:if test="(@type = 'MFString')
											   and not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign single SFString object </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value to </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="$isEnumerationType">
										<xsl:text>	 * @see MFString#cleanupEnumerationValues(String)</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:text>S</xsl:text>
									<xsl:value-of select="substring($type,2)" disable-output-escaping="yes"/>
									<xsl:value-of select="$jsaiClassSuffix"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="($isArrayListType = 'true') and not($javaReferenceType = 'X3DNode') and not($isX3dStatement = 'true')">
										<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									</xsl:if>
									<!-- assumption: SF/MF object assignment is OK due to object integrity.
                                                                             therefore check if MFString value was actually sent as SFString
									-->
                                                                        <xsl:text disable-output-escaping="yes">
                // cast SFString value to MFString value if needed
                if ((newValue.getValue().length() - newValue.getValue().replace("\"", "").length()) > 2) // more than two quotation marks
                    return set</xsl:text>
                <xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
                <xsl:text>(new MFString(newValue));</xsl:text>
                <xsl:text>&#10;</xsl:text>
									<xsl:text>		// set-newValue-validity-checks #2</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:text>false</xsl:text></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>complex</xsl:text></xsl:with-param>
									    <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									<xsl:text>		</xsl:text>
									<xsl:text>set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:choose>
										<xsl:when test="$isEnumerationType">
											<xsl:text>MFString.cleanupEnumerationValues(</xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>.toString())); // handle potential enumeration values</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$newValue"/>
											<xsl:text>.getValue());</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text></xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>

									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign singleton String </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value to </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="$isEnumerationType">
										<xsl:text>	 * @see MFString#cleanupEnumerationValues(String)</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="($isArrayListType = 'true') and not($javaReferenceType = 'X3DNode') and not($isX3dStatement = 'true')">
										<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									</xsl:if>
									<!-- assumption: SF/MF object assignment is OK due to object integrity.
                                                                             therefore check if MFString value was actually sent as SFString
									-->
                                                                        <xsl:text disable-output-escaping="yes">
                // cast String value to MFString if needed
                if ((newValue.length() - newValue.replace("\"", "").length()) > 2) // more than two quotation marks
                    return set</xsl:text>
                <xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
                <xsl:text>(new MFString(newValue));</xsl:text>
                <xsl:text>&#10;</xsl:text>
									<xsl:text>		// set-newValue-validity-checks #3</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:text>false</xsl:text></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>simple</xsl:text></xsl:with-param>
									    <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									<xsl:choose>
										<xsl:when test="$isEnumerationType">
											<xsl:text>		</xsl:text>
											<xsl:text>set</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											<xsl:text>(</xsl:text>
											<xsl:text>MFString.cleanupEnumerationValues(</xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>)</xsl:text>
											<xsl:text>); // handle potential enumeration values</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>		</xsl:text>
											<xsl:text>clear</xsl:text>
                                            <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                                            <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                                            <xsl:text>(); // reset</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>		</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>.add(</xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>);</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<xsl:if test="((@type='MFNode') or (@type='MFString') or (@type='MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type='MFFloat') or (@type='MFDouble') or (@type='MFTime'))
											   and not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign ArrayList </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									<xsl:text>		// set-newValue-validity-checks #4</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>complex</xsl:text></xsl:with-param>
									    <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									<xsl:value-of select="$newValueArrayListAcceptableNodeTypesTest" disable-output-escaping="yes"/>
									<xsl:text>        if (newValue.isEmpty())</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>            clear</xsl:text>
                                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                                    <xsl:text>(); // reset</xsl:text>
									<xsl:text>&#10;</xsl:text>
                                    <xsl:text>        else</xsl:text>
									<xsl:text>&#10;</xsl:text>
                                    <xsl:text>        {</xsl:text>
									<xsl:text>&#10;</xsl:text>
                                    <xsl:text>            </xsl:text>
                                    <xsl:value-of select="$javaBaseType"/>
									<xsl:text>[] newArray = new </xsl:text>
                                    <xsl:value-of select="$javaBaseType"/>
									<xsl:text>[newValue.size()];</xsl:text>
									<xsl:text>&#10;</xsl:text>
                                    <xsl:text disable-output-escaping="yes"><![CDATA[            for (int i = 0; i < newValue.size(); i++)]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
                                    <xsl:text>                newArray[i] = </xsl:text>
                                    <xsl:if test="($name = 'MetadataSet') or ($name = 'LoadSensor')">
                                        <xsl:text>(org.web3d.x3d.sai.Core.X3DNode)</xsl:text><!-- cast -->
                                    </xsl:if>
                                    <xsl:text>newValue.get(i);</xsl:text>
									<xsl:text>&#10;</xsl:text>
                                    <xsl:text>            set</xsl:text>
                                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                                    <xsl:text>(newArray);</xsl:text>
									<xsl:text>&#10;</xsl:text>
                                    <xsl:text>        }</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(@type='MFNode')"><!-- setParentObject -->
										<xsl:text>		</xsl:text>
										<xsl:text>for (</xsl:text>
                                        <xsl:choose>
                                            <xsl:when test="contains($javaType,'&lt;')">
                                                <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:value-of select="$javaReferenceType"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
										<xsl:text> element : </xsl:text>
										<xsl:value-of select="$newValue"/>
										<xsl:text>)</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>		{</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>			</xsl:text>
                                        <xsl:value-of select="@name"/>
                                        <xsl:text>.add(</xsl:text>
                                        <!-- cast -->
                                        <xsl:if test="not(contains($javaType, 'X3DNode'))">
                                            <xsl:text>(org.web3d.x3d.sai.Core.X3DNode) </xsl:text>
                                        </xsl:if>
                                        <xsl:text>element);</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>			((X3DConcreteElement) element).setParent(this); // parentTest13</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:choose>
											<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
												<xsl:text>			((X3DConcreteNode)    element).setContainerFieldOverride("value");</xsl:text>
												<xsl:text>&#10;</xsl:text>
											</xsl:when>
										</xsl:choose>
										<xsl:text>		}</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>		return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<xsl:if test="(@type = 'MFNode') and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove'))) and not($isInterface = 'true')
											   and not($isInterface = 'true') and not($isX3dStatement = 'true')">
									<!-- source code: addSingleThing -->
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Add single </xsl:text>
									<xsl:if test="not(starts-with(@name,'child'))">
										<xsl:text>child </xsl:text>
									</xsl:if>
									<xsl:text>node to existing array of </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> nodes (if any).</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text> and ProtoInstance.</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value to be appended the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:if test="not(@name = 'children') or ($isX3dStatement = 'true')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text>} - namely </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:text>this</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
										<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									</xsl:if>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>

									<xsl:text>	public </xsl:text>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="not(@name = 'children') or ($isX3dStatement = 'true')">
											<xsl:value-of select="ancestor::*[@name]/@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>void</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:choose>
										<xsl:when test="not(starts-with(@name,'add'))">
											<xsl:text> add</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text> </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:when test="(string-length(@acceptableNodeTypes) > 1) and
														 not(starts-with(@acceptableNodeTypes,'X3D')) and not(contains(@acceptableNodeTypes,'|'))">
											<xsl:value-of select="@acceptableNodeTypes"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- special method, TODO might need another if more than one acceptableNodeTypes -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$javaReferenceType"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:choose>
										<xsl:when test="(@name = 'children')">
											<xsl:value-of select="$newValueNullReturnSelf"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$newValueNullReturnThis"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>.add(</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>);</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		((X3DConcreteElement) </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>).setParent(this); // parentTest2</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:choose>
										<!-- MFNode child -->
										<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
											<xsl:text>		((X3DConcreteNode)    </xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>).setContainerFieldOverride("value");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
									</xsl:choose>
									<xsl:if test="($name = 'ProtoBody')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof org.web3d.x3d.jsail.X3DConcreteNode))
		{
			primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>; // remember node type
			primaryNode.setParent(this);
		}
</xsl:text>
									</xsl:if>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="not(@name = 'children') or ($isX3dStatement = 'true')">
											<xsl:text>		return this;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<!-- requirement to match SAI interfaces prevents adding further support -->
									</xsl:choose>
									<xsl:text>	}</xsl:text>
                                    <xsl:text>
	/**
	 * Add single ProtoInstance (with appropriate node type and containerField value) to MFNode array for </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[ field.
	 * <br><br>
	 * <i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ShaderPart and ProtoInstance.
	 * @param newValue is new value to be appended the parts field.
	 * @return {@link ]]></xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> add</xsl:text>
                                        <xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(ProtoInstance newValue)
	{
		if (newValue == null) return this; // newValueNullReturnThis
		</xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[.add(newValue);
		((X3DConcreteElement) newValue).setParent(this); // parentTest16
		return this;
	}
]]></xsl:text>

								<!-- duplicate -->
								<xsl:if test="false() and not($isX3dStatement = 'true') and (not($isInterface = 'true') and not(@name = 'children'))">
									<!-- source code: appendSingleThing -->
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Append single </xsl:text>
									<xsl:if test="not(starts-with(@name,'child'))">
										<xsl:text>child </xsl:text>
									</xsl:if>
									<xsl:value-of select="@name"/>
									<xsl:text> node to array of existing nodes (if any).</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text>.</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value to be appended the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:if test="($isX3dStatement = 'true') or (not($isInterface = 'true') and not(@name = 'children'))">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text>} - namely </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:text>this</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
										<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									</xsl:if>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>

									<xsl:text>	public </xsl:text>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true') or (not($isInterface = 'true') and not(@name = 'children'))">
											<xsl:value-of select="ancestor::*[@name]/@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>void</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:choose>
										<xsl:when test="not(starts-with(@name,'add'))">
											<xsl:text> add</xsl:text><!-- [previously append] -->
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text> </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true') or (not($isInterface = 'true') and not(@name = 'children'))">
											<xsl:value-of select="@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$javaReferenceType"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:choose>
										<xsl:when test="(not($isInterface = 'true') and not(@name = 'children'))">
											<xsl:value-of select="$newValueNullReturnThis"/><!-- pipeline -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$newValueNullReturnSelf"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>.add(</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>);</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		((X3DConcreteElement) </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>).setParent(this); // parentTest4 unneeded?</xsl:text>
									<xsl:text>&#10;</xsl:text>
													<xsl:choose>
														<!-- MFNode child -->
														<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
															<xsl:text>		((X3DConcreteNode)    </xsl:text>
															<xsl:value-of select="$newValue"/>
															<xsl:text>).setContainerFieldOverride("value");</xsl:text>
															<xsl:text>&#10;</xsl:text>
														</xsl:when>
													</xsl:choose>
									<xsl:if test="($name = 'ProtoBody')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof org.web3d.x3d.jsail.X3DConcreteNode))
		{
			primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>; // remember node type
			primaryNode.setParent(this);
		}
</xsl:text>
									</xsl:if>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true') or (not($isInterface = 'true') and not(@name = 'children'))">
											<xsl:text>		return this;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<!-- requirement to match SAI interfaces prevents adding further support -->
									</xsl:choose>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								</xsl:if>

								<xsl:if test="((@type = 'MFNode') and (@name = 'children'))
											   and not($isX3dStatement = 'true') and not($isInterface = 'true')">
<!-- * <br ><br >
	 * <i>Warning:</i> acceptable child node types and statements are limited to X3DChildNode.-->
										<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to add single child element to contained list of existing children nodes (if any).
	 * @param newValue is new node value to be appended the children field.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	*/
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addChild(</xsl:text>
	<xsl:choose>
		<xsl:when test="($name = 'field') or ($name = 'fieldValue')">
			<!-- SceneGraphFragmentContentModel -->
			<xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
		</xsl:when>
		<xsl:when test="($name = 'ViewpointGroup')">
			<xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
		</xsl:when>
		<xsl:when test="(string-length(@acceptableNodeTypes) > 0) and not(contains(@acceptableNodeTypes, '|'))">
            <xsl:variable name="saiPackagePath">
                <xsl:call-template name="saiPackage">
                    <xsl:with-param name="nodeType" select="@acceptableNodeTypes"/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:choose>
                <xsl:when test="(string-length($saiPackagePath) > 0)">
                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 20a */</xsl:text></xsl:if>
                    <xsl:value-of select="$saiPackagePath"/>
                    <xsl:text>.</xsl:text>
                    <xsl:value-of select="@acceptableNodeTypes"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 20b, saiPackage not found */</xsl:text></xsl:if>
                    <xsl:value-of select="@acceptableNodeTypes"/>
                </xsl:otherwise>
            </xsl:choose>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>org.web3d.x3d.sai.Core.X3DChildNode</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
]]></xsl:text>
									<xsl:value-of select="$newValueNullReturnThis"/>
									<!-- $newValueArrayAcceptableNodeTypesTest apparently unnecessary/inappropriate since only single typed value being applied -->
									<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
                                    <xsl:if test="($name = 'ProtoBody')">
                                        <xsl:text disable-output-escaping="yes"><![CDATA[
        if ((primaryNode == null) && (newValue instanceof org.web3d.x3d.jsail.X3DConcreteNode))
        {
            primaryNode = (X3DConcreteNode) newValue; // remember node type
            primaryNode.setParent(this);
        }
]]></xsl:text>
                                    </xsl:if>
                                    <xsl:text>
		children.add((org.web3d.x3d.sai.Core.X3DNode)newValue);
		((X3DConcreteElement) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>).setParent(this); // parentTest3
//      if  (</xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof ProtoInstance)
//           ((ProtoInstance) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>).setContainerField("children");
</xsl:text>
                                    <xsl:if test="($name = 'LoadSensor')">
                                    <xsl:text>
        if  (</xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof ProtoInstance)
             ((ProtoInstance)   </xsl:text><xsl:value-of select="$newValue"/><xsl:text>).setContainerField        ("children");
        else ((X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>).setContainerFieldOverride("children");</xsl:text>
                                    </xsl:if>
                                    <xsl:text>
		return this;
	}
</xsl:text>
								</xsl:if>

                                <!-- special addChild methods for Contour2D -->
								<xsl:if test="(($name = 'Contour2D') and (@name = 'children'))
											   and not($isX3dStatement = 'true') and not($isInterface = 'true')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Add single children node to array of existing children nodes (if any) for Contour2D.
	 * @param newValue is new node value to be appended the children field.
	 * @return {@link Contour2D} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public Contour2D addChild(NurbsCurve2D newValue)
	{
		if (newValue == null) // newValueNullReturnSelf
		{
			return this; // nothing else to do
		}
		children.add(newValue);
		((X3DConcreteElement) newValue).setParent(this); // parentTest2
		return this;
	}
	/**
	 * Add single children node to array of existing children nodes (if any) for Contour2D.
	 * @param newValue is new node value to be appended the children field.
	 * @return {@link Contour2D} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public Contour2D addChild(ContourPolyline2D newValue)
	{
		if (newValue == null) // newValueNullReturnSelf
		{
			return this; // nothing else to do
		}
		children.add(newValue);
		((X3DConcreteElement) newValue).setParent(this); // parentTest2
		return this;
	}
]]></xsl:text>
								</xsl:if>
								<xsl:if test="(@type = 'MFNode') and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')) and not(starts-with(@name,'field')))">
									<!-- source code: addSomething -->
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Add array of </xsl:text>
									<xsl:if test="not(starts-with(@name,'child'))">
										<xsl:text>child </xsl:text>
									</xsl:if>
									<xsl:value-of select="@name"/>
									<xsl:text> nodes to array of existing nodes (if any).</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text>.</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value array to be appended the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:if test="($isX3dStatement = 'true')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text>} - namely </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:text>this</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
										<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
	<!-- debug -->
	<xsl:if test="($debug = 'true')">
	<xsl:text>	// ($isInterface=</xsl:text>
	<xsl:value-of select="$isInterface"/>
	<xsl:text>, preceding-sibling::Inheritance=</xsl:text>
	<xsl:value-of select="preceding-sibling::Inheritance"/>
	<xsl:text>, $isX3dStatement=</xsl:text>
	<xsl:value-of select="$isX3dStatement"/>
	<xsl:text>)</xsl:text>
	<xsl:text>&#10;</xsl:text>
	</xsl:if>
									<xsl:if test="( not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')) or
												    (($isInterface = 'true') and //AbstractNodeType  [@name = $baseType                     ]/InterfaceDefinition/field[@name = $fieldName]) or
												    (($isInterface = 'true') and //AbstractNodeType  [@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												    (($isInterface = 'true') and //AbstractObjectType[@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												    (($thisClassName = 'ProtoInstance') and
												      (($CamelCaseName = 'Metadata') or ($CamelCaseName = 'Name') or ($CamelCaseName = 'DEF') or ($CamelCaseName = 'USE') or ($CamelCaseName = 'CssClass')))">
										<!--<xsl:text>	/* @Override */ // or here2?</xsl:text>
										<xsl:text>&#10;</xsl:text>-->
									</xsl:if>
									<xsl:text>	public </xsl:text>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="ancestor::*[@name]/@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>void</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:choose>
										<xsl:when test="not(starts-with(@name,'add'))">
											<xsl:text>add</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$normalizedMemberObjectName"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:choose>
                                        <xsl:when test="not($isInterface = 'true') and (string-length(@acceptableNodeTypes) > 1) and not(contains(@acceptableNodeTypes,'|'))">
											<!--
                                            <xsl:value-of select="@acceptableNodeTypes"/>
                                            <xsl:if test="not(contains(@acceptableNodeTypes,$jsaiClassSuffix)) and not(starts-with(@acceptableNodeTypes,'X3D'))">
                                                <xsl:value-of select="$jsaiClassSuffix"/>  append to type name
                                            </xsl:if> -->
                                            <xsl:value-of select="$javaReferenceType"/>
                                            <xsl:if test="not($isX3dStatement = 'true')">
                                                <xsl:text>[]</xsl:text>
                                            </xsl:if>
                                            <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 33 TODO add node typing */ </xsl:text></xsl:if>
										</xsl:when>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="$javaPrimitiveType"/>
                                            <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 34 TODO add node typing */ </xsl:text></xsl:if>
										</xsl:when>
										<xsl:otherwise>
                                            <xsl:variable name="saiPackagePath">
                                                <xsl:call-template name="saiPackage">
                                                    <xsl:with-param name="nodeType" select="$javaPrimitiveType"/>
                                                </xsl:call-template>
                                            </xsl:variable>
                                            <xsl:choose>
                                                <xsl:when test="(string-length($saiPackagePath) > 0)">
                                                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 8a */</xsl:text></xsl:if>
                                                    <xsl:value-of select="$saiPackagePath"/>
                                                    <xsl:text>.</xsl:text>
                                                    <xsl:value-of select="$javaPrimitiveType"/>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 8b, saiPackage not found */</xsl:text></xsl:if>
                                                    <xsl:value-of select="$javaPrimitiveType"/>
                                                </xsl:otherwise>
                                            </xsl:choose>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:choose>
										<xsl:when test="($isInterface = 'true')">
											<xsl:text>;</xsl:text>
											<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
												<xsl:text> // acceptable node types #3: </xsl:text>
												<xsl:value-of select="@acceptableNodeTypes"/>
											</xsl:if>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	{</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true')">
													<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="$newValueNullReturnSelf"/>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:value-of select="$newValueArrayAcceptableNodeTypesTest" disable-output-escaping="yes"/>
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true') and (@type = 'MFNode')">
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		</xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>.add(</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>).setParent(this); // parentTest5</xsl:text>
												</xsl:when>
												<xsl:when test="(@type = 'MFNode')">
													<!-- do not reset array when adding to it -->
													<!-- MFNode subtype checks necessary -->
													<xsl:text>		for (int i = 0; i </xsl:text>
													<xsl:text disable-output-escaping="yes">&lt; </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>.length; i++)</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		{</xsl:text>
													<xsl:if test="($name = 'ProtoBody') and not($isInterface = 'true')">
														<xsl:text disable-output-escaping="yes"><![CDATA[
			if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text>[i] instanceof org.web3d.x3d.jsail.X3DConcreteNode))
			{
				primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>[i]; // remember node type
				primaryNode.setParent(this);
			}
</xsl:text>
													</xsl:if>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			if  ((</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i] instanceof </xsl:text>
													<xsl:value-of select="$javaReferenceType"/>
													<xsl:text>) || (</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i] instanceof ProtoInstance))</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			{</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>				</xsl:text>
													<xsl:value-of select="@name"/>
													<xsl:text>.add(</xsl:text>
													<!-- cast
													<xsl:if test="not($isX3dStatement = 'true') and not($javaReferenceType = 'X3DNode')">
														<xsl:text>(</xsl:text>
														<xsl:value-of select="$javaReferenceType"/>
														<xsl:text>)</xsl:text>
													</xsl:if> -->
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i]);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>				((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i]).setParent(this); // parentTest6</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:choose>
														<!-- MFNode child -->
														<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
															<xsl:text>				((X3DConcreteNode)    </xsl:text>
															<xsl:value-of select="$newValue"/>
															<xsl:text>[i]).setContainerFieldOverride("value");</xsl:text>
															<xsl:text>&#10;</xsl:text>
														</xsl:when>
													</xsl:choose>
                                                    <xsl:text>				if (</xsl:text>
                                                    <xsl:value-of select="$newValue"/>
                                                    <xsl:text>[i] instanceof ProtoInstance)
					((ProtoInstance) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>[i]).setContainerField("</xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			}</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
													<xsl:text>("</xsl:text>
													<xsl:value-of select="$javaPrimitiveType"/>
													<xsl:text> </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>["+i+"] is not instanceof </xsl:text>
													<xsl:value-of select="$javaReferenceType"/>
													<xsl:text> or ProtoInstance, array </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>=" + </xsl:text>
													<xsl:text>Arrays.toString(</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>)</xsl:text>
													<xsl:text>);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		}</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>		</xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>.add(</xsl:text>
													<!--
													<xsl:if test="(@type = 'MFNode')">
														<xsl:text>(org.web3d.x3d.sai.Core.X3DNode)</xsl:text>
													</xsl:if>
													-->
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:if test="(@type = 'MFNode') and (string-length(@acceptableNodeTypes) > 0)">
														<xsl:text> // acceptable node types #4:</xsl:text>
														<xsl:value-of select="@acceptableNodeTypes"/>
													</xsl:if>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:text>&#10;</xsl:text>
											<!-- allow method pipelining, if appropropriate -->
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true')">
													<xsl:text>		return this;</xsl:text>
													<xsl:text>&#10;</xsl:text>
												</xsl:when>
												<!-- requirement to match SAI interfaces prevents adding further support -->
											</xsl:choose>
											<xsl:text>	}</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>

                                <!-- special CssStyle methods for FontStyle, ScreenFontStyle -->
								<xsl:if test="((@name = 'style') and ends-with($name, 'FontStyle'))
											   and not($isX3dStatement = 'true') and not($isInterface = 'true')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
    // special CssStyle methods for FontStyle, ScreenFontStyle

////	/**
////	 * Provide String value from inputOutput SFString field named <i>style</i>.
////	 * @return value of style field
////	 */
////    @Override
////	public String getCssStyle()
////	{
////		// override abstract method in X3DConcreteNode
////		return super.getCssStyle();
////	}
////
////	/**	/**
////	 * Accessor method to assign String value to inputOutput SFString field named <i>id</i>.
////	 * @param newValue is new value for the id field.
////	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
////	 */
////	public final ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setHtmlID(String newValue)
////	{
////		// set-newValue-validity-checks #0.b
////		if (newValue == null)
////		    newValue = new String(); // Principle of Least Astonishment (POLA) #5
////		    // https://en.wikipedia.org/wiki/Principle_of_least_astonishment
////		setConcreteHtmlID(newValue); // private superclass method
////		return this;
////	}
////
////	/**
////	 * Assign typed object value to SFString cssClass field, similar to {@link #setCssStyle(String)}.
////	 * This attribute is only functional if the X3D model is loaded within an HTML page.
////	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
////	 * @param newValue is new value for the style field.
////	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
////	 */
////	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setHtmlID(SFString newValue)
////	{
////			// set-newValue-validity-checks #1 gets handled by set-primitive method
////			setHtmlID(newValue.getPrimitiveValue());
////			return this;
////	}

	/**
	 * Accessor method to assign String value to inputOutput SFString field named <i>style</i>.
	 * @param newValue is new value for the style field.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public final ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setCssStyle(String newValue)
	{
		// set-newValue-validity-checks #0.c
		if (newValue == null)
		    newValue = new String(); // Principle of Least Astonishment (POLA) #5
		    // https://en.wikipedia.org/wiki/Principle_of_least_astonishment
		setConcreteCssStyle(newValue); // private superclass method
		return this;
	}

	/**
	 * Assign typed object value to SFString cssClass field, similar to {@link #setCssStyle(String)}.
	 * This attribute is only functional if the X3D model is loaded within an HTML page.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
	 * @param newValue is new value for the style field.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setCssStyle(SFString newValue)
	{
			// set-newValue-validity-checks #1 gets handled by set-primitive method
			setCssStyle(newValue.getPrimitiveValue());
			return this;
	}
]]></xsl:text>
								</xsl:if>

								<xsl:if test="(@type = 'MFNode') and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')))">
									<!-- source code: addMFNodeSomething(SFNodeValue) method -->
	<!-- debug -->
	<xsl:if test="($debug = 'true')">
	<xsl:text>	// ($isInterface=</xsl:text>
	<xsl:value-of select="$isInterface"/>
	<xsl:text>, preceding-sibling::Inheritance=</xsl:text>
	<xsl:value-of select="preceding-sibling::Inheritance"/>
	<xsl:text>, $isX3dStatement=</xsl:text>
	<xsl:value-of select="$isX3dStatement"/>
	<xsl:text>)</xsl:text>
	<xsl:text>&#10;</xsl:text>
	</xsl:if>
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Set single </xsl:text>
									<xsl:if test="not(starts-with(@name,'child'))">
										<xsl:text>child </xsl:text>
									</xsl:if>
									<xsl:value-of select="@name"/>
									<xsl:text> node, replacing prior array of existing nodes (if any).</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="($name = 'MetadataSet')">
										<xsl:text disable-output-escaping="yes"><![CDATA[	 * <i>Warning:</i> this method can only accept Metadata* nodes.]]></xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:choose>
										<xsl:when test="not($isInterface = 'true') and (string-length(@acceptableNodeTypes) > 1) and not(ends-with(@acceptableNodeTypes,'Object'))">
											<xsl:text>	 * </xsl:text>
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	 * </xsl:text>
											<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are restricted to ]]></xsl:text>
											<xsl:value-of select="@acceptableNodeTypes"/>
											<xsl:text>.</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="not($isX3dStatement = 'true') and not($isInterface = 'true')">
											<xsl:text>	 * Unable to return this object and pipeline methods since abstract SAI specifies void return type.</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="https://stackoverflow.com/questions/14694852/can-overridden-methods-differ-in-return-type" target="_blank">stackoverflow: Can overridden methods differ in return type?</a>]]></xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
									</xsl:choose>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new node for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field</xsl:text>
									<xsl:if test="not($isInterface = 'true') and (string-length(@acceptableNodeTypes) > 1) and not(ends-with(@acceptableNodeTypes,'Object'))">
										<xsl:text> (restricted to </xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text>)</xsl:text>
									</xsl:if>
									<xsl:if test="($isX3dStatement = 'true') or ($name = 'ProtoBody')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text>} - namely </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:text>this</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
										<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
										<xsl:text>	/* @Override */</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>	public </xsl:text>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true') or ($thisClassName = 'ProtoBody')">
											<xsl:value-of select="ancestor::*[@name]/@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<!-- TODO fix/figure out
										<xsl:when test="not($isInterface = 'true') and not(@name = 'children') and (string-length(@acceptableNodeTypes) > 1) and not(ends-with(@acceptableNodeTypes,'Object'))">
											<xsl:value-of select="$name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											< ! - - singleton, no [] - - >
										</xsl:when> -->
										<xsl:otherwise>
											<xsl:text>void</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:choose>
										<xsl:when test="not(starts-with(@name,'add'))">
											<xsl:text>set</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$normalizedMemberObjectName"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:choose>
                                        <xsl:when test="not($isInterface = 'true') and (string-length(@acceptableNodeTypes) > 1) and not(contains(@acceptableNodeTypes,'|'))">
											<!--
                                            <xsl:value-of select="@acceptableNodeTypes"/>
                                            <xsl:if test="not(contains(@acceptableNodeTypes,$jsaiClassSuffix)) and not(starts-with(@acceptableNodeTypes,'X3D'))">
                                                <xsl:value-of select="$jsaiClassSuffix"/>  append to type name
                                            </xsl:if>
                                            -->
                                            <xsl:value-of select="$javaReferenceType"/>
                                            <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 31 TODO add node typing */ </xsl:text></xsl:if>
										</xsl:when>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="$javaPrimitiveType"/>
                                            <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 32 TODO add node typing */ </xsl:text></xsl:if>
										</xsl:when>
										<xsl:otherwise>
                                            <xsl:variable name="saiPackagePath">
                                                <xsl:call-template name="saiPackage">
                                                    <xsl:with-param name="nodeType" select="$javaPrimitiveType"/>
                                                </xsl:call-template>
                                            </xsl:variable>
                                            <xsl:choose>
                                                <xsl:when test="(string-length($saiPackagePath) > 0)">
                                                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 9a */</xsl:text></xsl:if>
                                                    <xsl:value-of select="$saiPackagePath"/>
                                                    <xsl:text>.</xsl:text>
                                                    <xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 9b, saiPackage not found */</xsl:text></xsl:if>
                                                    <xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
                                                </xsl:otherwise>
                                            </xsl:choose>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:choose>
										<xsl:when test="($isInterface = 'true')">
											<xsl:text>;</xsl:text>
											<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
												<xsl:text> // acceptable node types #5: </xsl:text>
												<xsl:value-of select="@acceptableNodeTypes"/>
											</xsl:if>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	{</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:if test="($name = 'ProtoBody')">
												<xsl:text disable-output-escaping="yes"><![CDATA[		if ((newValue == null) && (primaryNode != null))]]></xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			primaryNode.setParent(null); // housekeeping, clear prior object</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			primaryNode = null; // clear from ProtoBody</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		}</xsl:text>
												<xsl:text>&#10;</xsl:text>
											</xsl:if>
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true') or ($name = 'ProtoBody')">
													<xsl:value-of select="$newValueNullClearsFieldReturnThis"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="$newValueNullClearsFieldReturnVoid"/>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
											<xsl:choose>
												<xsl:when test="($name = 'ExternProtoDeclare') and (@name = 'field')">
		<!-- check to ensure that no value is present within field having parent ExternProtoDeclare -->
		<xsl:text disable-output-escaping="yes"><![CDATA[		// No value is allowed within field having parent ExternProtoDeclare
		if ((!newValue.getValue().isEmpty() || !newValue.getChildren().isEmpty()) && newValue.hasChildrenElements())
		{
			String foundValue;
			if (!newValue.getValue().isEmpty())
				 foundValue = newValue.getValue();
			else foundValue = newValue.getChildren().toString();

			throw new org.web3d.x3d.sai.InvalidProtoException("ExternProtoDeclare name='" + name +
					"' with field name='" + newValue.getName() +
					"' cannot have any initial value (found \"" + foundValue +
					"\"). Instead use ProtoInstance fieldValue to override the original default ProtoDeclare field value.");
		}
]]></xsl:text>
												</xsl:when>
											</xsl:choose>
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true') and (@type = 'MFNode')">
													<xsl:text>		</xsl:text>
													<xsl:text>for (</xsl:text>
													<xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
													<xsl:text> element : </xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>)</xsl:text>
													<xsl:text> // </xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			((X3DConcreteElement) element).clearParent(); // remove references to facilitate Java memory management</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		</xsl:text>
													<xsl:text>clear</xsl:text>
                                                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                                                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
													<xsl:text>(); // reset</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		</xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>.add(</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>).setParent(this); // parentTest7</xsl:text>
													<xsl:text>&#10;</xsl:text>
												</xsl:when>
												<xsl:when test="(@type = 'MFNode')">
													<xsl:text>		if  (</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text> instanceof </xsl:text>
													<xsl:choose>
														<xsl:when test="($name = 'ProtoBody')">
															<xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="$javaReferenceType"/>
														</xsl:otherwise>
													</xsl:choose>
													<xsl:text>)</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		{</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			</xsl:text>
													<xsl:text>for (org.web3d.x3d.sai.Core.X3DNode</xsl:text>
													<!-- <xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/> -->
													<xsl:text> element : </xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>)</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>				((X3DConcreteElement) element).clearParent(); // remove references to facilitate Java memory management</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			</xsl:text>
													<xsl:text>clear</xsl:text>
                                                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                                                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
													<xsl:text>(); // reset</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>).setParent(this); // parentTest8</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:choose>
														<!-- MFNode child -->
														<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
															<xsl:text>			((X3DConcreteNode)    </xsl:text>
															<xsl:value-of select="$newValue"/>
															<xsl:text>).setContainerFieldOverride("value");</xsl:text>
															<xsl:text>&#10;</xsl:text>
														</xsl:when>
														<xsl:when test="($name = 'MetadataSet') and (@name = 'metadata')">
															<xsl:text>			((X3DConcreteNode)    </xsl:text>
															<xsl:value-of select="$newValue"/>
															<xsl:text>).setContainerFieldOverride("metadata");</xsl:text>
															<xsl:text>&#10;</xsl:text>
														</xsl:when>
													</xsl:choose>
													<xsl:text>			</xsl:text>
													<xsl:if test="($name = 'ProtoBody')">
														<xsl:text>if ((</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text disable-output-escaping="yes"><![CDATA[ instanceof org.web3d.x3d.jsail.X3DConcreteNode) && (primaryNode == null))]]></xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>				 primaryNode = (X3DConcreteNode) </xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>; // remember node type</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>			</xsl:text><!-- continue and include primaryNode in children list -->
													</xsl:if>
													<xsl:value-of select="@name"/>
													<xsl:text>.add(</xsl:text>
                                                    <!-- cast
													<xsl:choose>
														<xsl:when test="not($javaReferenceType = 'X3DNode')">
															<xsl:text>(</xsl:text>
															<xsl:value-of select="$javaReferenceType"/>
															<xsl:text>)</xsl:text>
														</xsl:when>
													</xsl:choose> -->
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		}</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
													<xsl:text>("</xsl:text>
													<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
													<xsl:text> </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text> is not instanceof </xsl:text>
													<xsl:value-of select="$javaReferenceType"/>
													<xsl:text>; </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>=" + </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
												</xsl:when>
												<xsl:otherwise><!-- apparently unused -->
													<xsl:text>		</xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>.add(</xsl:text>
													<!--
													<xsl:if test="(@type = 'MFNode')">
														<xsl:text>(org.web3d.x3d.sai.Core.X3DNode)</xsl:text>
													</xsl:if>
													-->
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:if test="(@type = 'MFNode') and (string-length(@acceptableNodeTypes) > 0)">
														<xsl:text> // acceptable node types #6:</xsl:text>
														<xsl:value-of select="@acceptableNodeTypes"/>
													</xsl:if>
													<xsl:text>		((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>).setParent(this); // parentTest9</xsl:text>
													<xsl:text>&#10;</xsl:text>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:text>&#10;</xsl:text>
											<!-- allow method pipelining, if appropropriate -->
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true') or ($name = 'ProtoBody')">
													<xsl:text>		return this;</xsl:text>
													<xsl:text>&#10;</xsl:text>
												</xsl:when>
												<!-- requirement to match SAI interfaces prevents adding further support, must return void -->
											</xsl:choose>
											<xsl:text>}</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
<!-- duplicate method definition -->
                                    <xsl:if test="false() and not(starts-with(@name,'child')) and not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
                                        <!-- source code: addMFNodeSomething(SFNode) method -->
										<xsl:text>
	/**
	 * Utility method to set single SFNode as </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> </xsl:text>
									<xsl:value-of select="@name"/>
                                    <xsl:text>.
	 * @param newValue </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> node to set
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> set</xsl:text>
			<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
            <xsl:text>(</xsl:text>
            <xsl:choose>
                <xsl:when test="($name = 'MetadataSet')">
                    <xsl:text>X3DMetadataObject</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>X3DConcreteNode</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text> newValue)
	{
		set</xsl:text>
        <xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
        <xsl:text>((org.web3d.x3d.sai.Core.X3DNode) </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:text>);
		((X3DConcreteElement) newValue).setParent(this);
		return this;
	}
</xsl:text>
                                    </xsl:if>
								</xsl:if>

								<xsl:if test="((@type='SFNode') or starts-with($javaType,'X3D')) and not($isInterface = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Utility method to clear </xsl:text>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[ field.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).]]></xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> clear</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>()</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		((X3DConcreteElement) </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>).clearParent(); // remove references to facilitate Java memory management</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> = null; // reset SFNode field</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		</xsl:text>
									<xsl:text>return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<xsl:if test="((@type='MFNode') or (@type='MFString') or (@type='MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type='MFFloat') or (@type='MFDouble') or (@type='MFTime')) and not($isInterface = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Utility method to clear </xsl:text>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[ field.  This method does not initialize with]]></xsl:text>
                                                                        <xsl:value-of select="upper-case($fieldName)"/>
                                                                        <xsl:text disable-output-escaping="yes"><![CDATA[_DEFAULT_VALUE.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> clear</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>()</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(@type='MFNode')">
										<xsl:text>		</xsl:text>
										<xsl:text>for (</xsl:text>
										<xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
										<xsl:text> element : </xsl:text>
										<xsl:value-of select="$normalizedMemberObjectName"/>
										<xsl:text>)</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>			((X3DConcreteElement) element).clearParent(); // remove references to facilitate Java memory management</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>.clear(); // reset MF field</xsl:text>
									<xsl:text>&#10;</xsl:text>
	<xsl:if test="($name = 'ProtoBody')">
		<xsl:text>&#10;</xsl:text>
		<xsl:text>		if (primaryNode != null)</xsl:text>
		<xsl:text>&#10;</xsl:text>
		<xsl:text>		{</xsl:text>
		<xsl:text>&#10;</xsl:text>
		<xsl:text>			primaryNode.setParent(null); // housekeeping, clear prior object</xsl:text>
		<xsl:text>&#10;</xsl:text>
		<xsl:text>			primaryNode = null; // clear from ProtoBody</xsl:text>
		<xsl:text>&#10;</xsl:text>
		<xsl:text>		}</xsl:text>
		<xsl:text>&#10;</xsl:text>
	</xsl:if>
									<xsl:text>		</xsl:text>
									<xsl:text>return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<xsl:if test="((@type='MFFloat') or (@type='MFDouble') or (@type='MFTime'))
											   and not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign floating-point array </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(int[] </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									<xsl:text>		// set-newValue-validity-checks #5</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>complex</xsl:text></xsl:with-param>
									    <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									<xsl:value-of select="$newValueArrayAcceptableNodeTypesTest" disable-output-escaping="yes"/>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="substring-before($javaPrimitiveType,'[]')" disable-output-escaping="yes"/>
									<xsl:text>[] holdArray = new </xsl:text>
									<xsl:value-of select="substring-before($javaPrimitiveType,'[]')" disable-output-escaping="yes"/>
									<xsl:text>[newValue.length];</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		for (int i = 0; i </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt; </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>.length; i++)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			</xsl:text>
									<xsl:text>holdArray[i] = (</xsl:text>
									<xsl:value-of select="substring-before($javaPrimitiveType,'[]')" disable-output-escaping="yes"/>
									<xsl:text>)</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>[i];</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		}</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		</xsl:text>
									<xsl:text>set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(holdArray);</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<!-- not(@name = 'metadata') -->
								<xsl:if test="true() and ((@type = 'SFNode') and not($isX3dStatement = 'true') and not($isInterface = 'true'))">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign ProtoInstance (using a properly typed node) to </xsl:text>
									<xsl:value-of select="@accessType"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="@type"/>
									<xsl:text> field </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text>.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @see #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text>
									<xsl:text>&#10;</xsl:text>

									<xsl:if test="not($isInterface = 'true') and (@name = 'metadata')">
										<xsl:text>	/* @Override */</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<!-- also have setFieldName(ProtoInstance newValue) for SFNode fields -->
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(ProtoInstance </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:choose>
										<xsl:when test="($isInterface = 'true')">
											<xsl:text>;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	{</xsl:text>
											<xsl:text>
		if (</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance</xsl:text><xsl:text> != null)
		{
			((X3DConcreteElement) </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>ProtoInstance</xsl:text>
											<xsl:text>).setParent(null); // parentTest15.5</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	    }</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>		</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>ProtoInstance = </xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>;
		if (</xsl:text><xsl:value-of select="$newValue"/><xsl:text> != null)
		{
			((X3DConcreteElement) </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>ProtoInstance</xsl:text>
											<xsl:text>).setParent(this); // parentTest15.6
            </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>ProtoInstance.setContainerField("</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>");
	    }
		if (</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text> != null)
		{
			((X3DConcreteElement) </xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>).setParent(null); // housekeeping, clear prior object
			</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text> = null;
		}
</xsl:text>
											<xsl:text>	    return this;</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	}</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		/** Private utility method to access SFNode ProtoInstance field **/</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		private ProtoInstance get</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>ProtoInstance</xsl:text>
									<xsl:text>()</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			return </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text>ProtoInstance;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<!-- [duplicative, avoid] SFNode thoroughness: setFieldName(ProtoInstance newValue) -->
								<xsl:if test="false() and ((@type='SFNode') and not($isX3dStatement = 'true') and not($isInterface = 'true'))">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[	 * Assign ProtoInstance to <i>]]></xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[</i> field.]]></xsl:text>
									<xsl:if test="(string-length(@acceptableNodeTypes) > 0)">
										<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> ProtoInstance must match acceptable node type]]></xsl:text>
										<xsl:if test="contains(@acceptableNodeTypes,'|')">
											<xsl:text>s</xsl:text>
										</xsl:if>
										<xsl:text> </xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text>.</xsl:text>
									</xsl:if>
									<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @param newProtoInstanceNode is the new ProtoInstance node for the ]]></xsl:text><xsl:value-of select="@name"/><xsl:text disable-output-escaping="yes"><![CDATA[ field
	 * @see #set]]></xsl:text><xsl:value-of select="translate($CamelCaseName,'-','_')"/>
		<xsl:text>(</xsl:text>
		<xsl:choose>
			<xsl:when test="(@type = 'MFNode') and (($isClassX3dStatement = 'true') or ($isX3dStatement = 'true') or (@name = 'addChildren') or (@name = 'removeChildren'))">
				<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$javaPrimitiveType"/>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>)</xsl:text>
		<xsl:if test="contains($CamelCaseName, 'Metadata')">
			<xsl:text>&#10;</xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
		</xsl:if>
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
]]></xsl:text>
									<xsl:text>	public </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(ProtoInstance newProtoInstanceNode)
	{
		if (</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text> != null)
		{
			((X3DConcreteElement) </xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>).setParent(null); // housekeeping, clear prior object
			</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text> = null;
		}
		</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance = newProtoInstanceNode;
		if (newProtoInstanceNode != null)
		{
			newProtoInstanceNode.setParent(this);
</xsl:text>
                        <xsl:choose>
                                <xsl:when test="(($name = 'CADFace') or ($name = 'CollidableShape')) and (@name = 'shape')">
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("shape");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <xsl:when test="($name = 'Collision') and (@name = 'proxy')">
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("proxy");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <xsl:when test="(($name = 'ComposedCubeMapTexture') and
                                                    ((@name = 'backTexture') or (@name = 'bottomTexture') or (@name = 'frontTexture') or
                                                     (@name = 'leftTexture') or (@name = 'rightTexture')  or (@name = 'topTexture'))) or
                                                (($name = 'Appearance') and (@name = 'material'))">
                                        <!-- ImageTexture check -->
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("</xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <!-- MFNode child -->
                                <xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("value");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <xsl:when test="($name = 'Sound') and (@name = 'source')">
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("source");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <xsl:when test="($name = 'TextureBackground') and
												((@name = 'backTexture') or (@name = 'bottomTexture') or (@name = 'frontTexture') or
												 (@name = 'leftTexture') or (@name = 'rightTexture')  or (@name = 'topTexture'))">
                                        <!-- ImageTexture check -->
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("</xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                        </xsl:choose>
			<xsl:text>		}
		return this;
	}
	/**
	 * Provide properly typed ProtoInstance for </xsl:text><xsl:value-of select="@accessType"/>
		<xsl:text disable-output-escaping="yes"><![CDATA[ SFNode field <i>]]></xsl:text>
		<xsl:value-of select="$normalizedMemberObjectName"/>
		<xsl:text disable-output-escaping="yes"><![CDATA[</i>, if available.
	 * @see #get]]></xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>()</xsl:text>
	<xsl:if test="contains($CamelCaseName, 'Metadata')">
		<xsl:text>&#10;</xsl:text>
		<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
	</xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return ProtoInstance value of geometry field
	 */
	public ProtoInstance get]]></xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>ProtoInstance()
	{
		return </xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance;
	}
</xsl:text>
								</xsl:if>

								<xsl:if test="(($type='SFNode') or ($type='MFNode')) and not($isInterface = 'true')">
									<xsl:text>
	/**
	 * Indicate whether an object is available for </xsl:text><xsl:value-of select="@accessType"/>
		<xsl:text> </xsl:text><xsl:value-of select="$type"/><xsl:text disable-output-escaping="yes"><![CDATA[ field <i>]]></xsl:text>
		<xsl:value-of select="$normalizedMemberObjectName"/>
		<xsl:text disable-output-escaping="yes"><![CDATA[</i>.
	 * @return whether a ]]></xsl:text>
	 <xsl:choose>
		 <xsl:when test="($isX3dStatement = 'true')">
			 <xsl:text>concrete statement </xsl:text>
		 </xsl:when>
		 <xsl:otherwise>
			 <xsl:text>properly typed node or ProtoInstance </xsl:text>
		 </xsl:otherwise>
	 </xsl:choose>
	 <xsl:if test="($type='MFNode')">
		 <xsl:text>array </xsl:text>
	 </xsl:if>
	 <xsl:text>or CommentsBlock is available.
	 * @see #get</xsl:text><xsl:value-of select="$CamelCaseName"/>
	 <xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
		 <xsl:text>List</xsl:text>
	 </xsl:if>
	 <xsl:text>()</xsl:text>
	 <xsl:if test="($type='SFNode') and not($isX3dStatement = 'true')">
		 <xsl:text>
	 * @see #get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>ProtoInstance()</xsl:text>
	 </xsl:if>
	<xsl:if test="contains($CamelCaseName, 'Metadata')">
		<xsl:text>&#10;</xsl:text>
		<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
	</xsl:if>
	 <xsl:text>
	 */
	public boolean has</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>()
	{
		return </xsl:text>
		<xsl:choose>
			<xsl:when test="($type='MFNode') and not($isX3dStatement = 'true')">
				<xsl:text>(!</xsl:text>
				<xsl:value-of select="$normalizedMemberObjectName"/>
				<xsl:text>.isEmpty())</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>(</xsl:text>
				<xsl:value-of select="$normalizedMemberObjectName"/>
				<xsl:choose>
					<xsl:when test="($isX3dStatement = 'true') and (@type='MFNode')">
						<xsl:text>.isEmpty() == false)</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text> != null)</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="($type='SFNode') and not($isX3dStatement = 'true')">
			<xsl:text> || (</xsl:text>
			<xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance != null)</xsl:text>
		</xsl:if>
		<xsl:text>;
	}
</xsl:text>
								</xsl:if>
								<!-- add simple type if tupleSize = 1 -->
								<xsl:if test="starts-with($type,'MF') and ($tupleSize = 1) and not($type = 'MFNode') and not($isX3dStatement = 'true') and not($isInterface = 'true')">
									<xsl:text>
	/**
	 * Add singleton </xsl:text><xsl:value-of select="$javaBaseType"/><xsl:text> value to </xsl:text><xsl:value-of select="$type"/><xsl:text> </xsl:text><xsl:value-of select="@name"/><xsl:text> field.
	 * @param newValue is new value to add to the </xsl:text><xsl:value-of select="@name"/><xsl:text> field.</xsl:text>
									<xsl:if test="($type = 'MFString')">
										<xsl:text>
	 * @see MFString#cleanupEnumerationValues(String)</xsl:text>
									</xsl:if>
									<xsl:text>
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> add</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text><xsl:value-of select="$javaBaseType"/><xsl:text> newValue)
	{
		</xsl:text>
									<xsl:choose>
										<xsl:when test="($type = 'MFString')">
											<xsl:text disable-output-escaping="yes"><![CDATA[if (newValue == null)
		{
			return this; // nothing else to do
		}
        newValue = MFString.cleanupEnumerationValue(newValue); // handle potential enumeration value
		if (!newValue.isEmpty() && !]]></xsl:text>
											<xsl:value-of select="@name"/>
											<xsl:text>.contains(newValue))
            </xsl:text>
											<xsl:value-of select="@name"/>
											<xsl:text>.add(newValue); // only add if not already present
</xsl:text>
										</xsl:when>
                                        <xsl:otherwise>
											<xsl:value-of select="@name"/>
											<xsl:text>.add(newValue); // add simple type if tupleSize = 1</xsl:text>
                                        </xsl:otherwise>
									</xsl:choose>
									<xsl:text>
		return this;
	}</xsl:text>
								</xsl:if>
								<!-- add singleton field object -->
								<xsl:if test="starts-with($type,'MF') and not($type = 'MFNode') and not($isX3dStatement = 'true') and not($isInterface = 'true')">
									<xsl:text>
	/**
	 * Add singleton S</xsl:text><xsl:value-of select="substring($type,2)"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> value to </xsl:text><xsl:value-of select="$type"/><xsl:text> </xsl:text><xsl:value-of select="@name"/><xsl:text> field.
	 * @param newValue is new value to add to the </xsl:text><xsl:value-of select="@name"/><xsl:text> field.</xsl:text>
									<xsl:if test="($type = 'MFString')">
										<xsl:text>
	 * @see MFString#cleanupEnumerationValues(String)</xsl:text>
									</xsl:if>
									<xsl:text>
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> add</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<!-- SF type -->
									<xsl:text>(S</xsl:text>
									<xsl:value-of select="substring($type,2)"/>
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text> newValue)
	{
		if (newValue == null)
		{
			return this; // nothing else to do
		}
		</xsl:text>
									<xsl:choose>
										<xsl:when test="($type = 'MFString')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
        newValue.setValue(MFString.cleanupEnumerationValue(newValue.getValue())); // handle potential enumeration value
		if (!newValue.getValue().isEmpty() && !]]></xsl:text>
											<xsl:value-of select="@name"/>
											<xsl:text>.contains(newValue.getValue()))
            </xsl:text>
											<xsl:value-of select="@name"/>
											<xsl:text>.add(newValue.getValue()); // only add if not already present
</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:choose>
												<xsl:when test="($tupleSize = 1)">
													<xsl:value-of select="@name"/>
													<xsl:text>.add(newValue.getPrimitiveValue());</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<!-- https://stackoverflow.com/questions/80476/how-can-i-concatenate-two-arrays-in-java -->
													<xsl:value-of select="$javaPrimitiveType"/>
													<xsl:text> result =  Arrays.copyOf(</xsl:text>
													<xsl:value-of select="@name"/><xsl:text>, </xsl:text>
													<xsl:value-of select="@name"/><xsl:text>.length + </xsl:text>
													<xsl:value-of select="$tupleSize"/><xsl:text>);
		System.arraycopy(newValue.getPrimitiveValue(), 0, result, </xsl:text>
													<xsl:value-of select="@name"/><xsl:text>.length, </xsl:text>
													<xsl:value-of select="$tupleSize"/><xsl:text>);
		</xsl:text><xsl:value-of select="@name"/><xsl:text> =  result;</xsl:text>
  												</xsl:otherwise>
											</xsl:choose>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>
		return this;
	}

</xsl:text>
								</xsl:if>

								<!-- add singleton field object HAnimDispacer for HAnimJoint, HAnimSegment -->
<!--
								<xsl:if test="(@name = 'displacers') and (($name = 'HAnimJoint') or ($name = 'HAnimSegment')) and not($isInterface = 'true')">
									<xsl:text>
	/**
	 * Set HAnimDisplacerObject as single child in displacers field.
	 * @param newValue HAnimDisplacer node to set
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> setDisplacers(HAnimDisplacer newValue)
	{
        </xsl:text><xsl:value-of select="$newValueNullReturnThis"/><xsl:text>
		displacers.add(newValue);
		((X3DConcreteElement) newValue).setParent(this);
		return this;
	}
</xsl:text>
<xsl:text>
	/**
	 * Set ProtoInstance with node type HAnimDisplacer as single child in displacers field.
	 * @param newValue ProtoInstance node of type HAnimDisplacer to set
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> setDisplacers(ProtoInstance newValue)
	{
        </xsl:text><xsl:value-of select="$newValueNullReturnThis"/><xsl:text>
		displacers.set(newValue);
		((X3DConcreteElement) newValue).setParent(this);
		return this;
	}
	/**
	 * Add ProtoInstance with node type HAnimDisplacer to MFNode array for displacers field.
	 * @param newValue ProtoInstance node of type HAnimDisplacer to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addDisplacers(ProtoInstance newValue)
	{
        </xsl:text><xsl:value-of select="$newValueNullReturnThis"/><xsl:text>
		displacers.add(newValue);
		((X3DConcreteElement) newValue).setParent(this);
		return this;
	}
</xsl:text>
								</xsl:if>
-->
								<!-- end of per-field set/add accessors and field utility methods for concrete classes -->
							</xsl:if>

								<xsl:choose>
									<xsl:when test="((@name = 'children') and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
													not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CADPart'))
													or (@name = 'GeoLOD')"> <!-- GeoLOD has outputOnly children field -->
										<xsl:text>
	/**
	 * Add comment as CommentsBlock to children field
	 * @param newComment initial value
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	/* @Override */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (String newComment)
	{
		if (newComment == null) return this;
		children.add(new CommentsBlock (newComment));
		return this;
	}
	/**
	 * Add comments as String[] array to children field
	 * @param newComments array of comments
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	/* @Override */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (String[] newComments)
	{
		if (newComments == null) return this;
		children.add(new CommentsBlock (newComments));
		return this;
	}
	/**
	 * Add CommentsBlock to children field
	 * @param newCommentsBlock block of comments to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	/* @Override */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (CommentsBlock newCommentsBlock)
	{
		if (newCommentsBlock == null) return this;
		children.add(newCommentsBlock);
		return this;
	}
										</xsl:text>
									</xsl:when>
								</xsl:choose>

                            <xsl:if test="not($isInterface = 'true') and (starts-with(@accessType,'in'))">
                              <xsl:choose>
                                <xsl:when test="($type = 'SFFloat')">
                                    <xsl:text>
	/**
	 * Utility method: double-precision set-parameter accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float)}.
	 * @param newValue is new value for field
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double newValue)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>((float) newValue);
	}
</xsl:text>
                                </xsl:when>
                                <xsl:when test="($type = 'SFVec2f')">
                                    <xsl:text>
	/**
	 * Utility method: double-precision set-parameters accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param x first component
	 * @param y second component
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double x, double y)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(x, y));
	}
	/**
	 * Utility method: double-precision set-array accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param newArray is new value for field
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double[] newArray)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(newArray));
	}
</xsl:text>
                                </xsl:when>
                                <xsl:when test="($type = 'SFVec3f')">
                                    <xsl:text>
	/**
	 * Utility method: double-precision set-parameters accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double x, double y, double z)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(x, y, z));
	}
	/**
	 * Utility method: double-precision set-array accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param newArray is new value for field
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double[] newArray)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(newArray));
	}
</xsl:text>
                                </xsl:when>
                                <xsl:when test="($type = 'SFVec4f')">
                                    <xsl:text>
	/**
	 * Utility method: double-precision set-parameters accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param t fourth component
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double x, double y, double z, double t)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(x, y, z, t));
	}
	/**
	 * Utility method: double-precision set-array accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param newArray is new value for field
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double[] newArray)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(newArray));
	}
</xsl:text>
                                </xsl:when>
                                <xsl:when test="($type = 'SFRotation')">
                                    <xsl:text>
	/**
	 * Utility method: double-precision set-parameters accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param angleRadians fourth component
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double x, double y, double z, double angleRadians)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(x, y, z, angleRadians));
	}
	/**
	 * Utility method: double-precision set-array accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param newArray is new value for field
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double[] newArray)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(newArray));
	}
</xsl:text>
                                </xsl:when>
                                <xsl:when test="($type = 'SFColor')">
                                    <xsl:text>
	/**
	 * Utility method: double-precision set-parameters accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double red, double green, double blue)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>((float) red, (float) green, (float) blue);
	}
	/**
	 * Utility method: double-precision set-parameters accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param newArray is new value for field
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double[] newArray)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(newArray));
	}
</xsl:text>
                                </xsl:when>
                                <xsl:when test="($type = 'SFColorRGBA')">
                                    <xsl:text>
	/**
	 * Utility method: double-precision set-parameters accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @param alpha fourth component [0..1]
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double red, double green, double blue, double alpha)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>((float) red, (float) green, (float) blue, (float) alpha);
	}
	/**
	 * Utility method: double-precision set-parameters accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param newArray is new value for field
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double[] newArray)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(newArray));
	}
</xsl:text>
                                </xsl:when>
                                <!-- TODO: create array constructors for SF/MFMatrix* types.  Snippet for following test: or contains($type, 'FMatrix') -->
                                <xsl:when test="($type = 'MFFloat') or (starts-with($type, 'MFVec') and ends-with($type, 'f')) or starts-with($type, 'MFColor')">
                                    <xsl:text>
	/**
	 * Utility method: double-precision set-array accessor for X3D floating-point type, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(float[])}.
	 * @param newArray is new value for field
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(double[] newArray)
	{
		return set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(new </xsl:text>
									<xsl:value-of select="$type"/> <!-- translate name here to avoid xpath problems -->
									<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(newArray));
	}
</xsl:text>
                                </xsl:when>
                              </xsl:choose>
                            </xsl:if>

							<!-- debug
							<xsl:message>
								<xsl:text>*** @CamelCaseName=</xsl:text>
								<xsl:value-of select="$CamelCaseName"/>
								<xsl:text>, accessType=</xsl:text>
								<xsl:value-of select="@accessType"/>
							</xsl:message> -->
						</xsl:if>

					</xsl:for-each>
					<!-- finished with InterfaceDefinition/field loop -->
                                        <!-- end Source code: accessor methods -->

								<!-- HAnim utility methods -->
								<xsl:if test="(($name = 'HAnimJoint') or ($name = 'HAnimSegment') or ($name = 'HAnimSite') or ($name = 'HAnimDisplacer') or ($name = 'HAnimMotion')) and not($isInterface = 'true')">
									<xsl:text>
	/** Return reference to ancestor HAnimHumanoid
	 * @return HAnimHumanoid if found, otherwise null
	 */
	public HAnimHumanoid getAncestorHAnimHumanoid()
	{
		X3DConcreteElement parentElement = ((X3DConcreteElement)this).getParent();;
		while (parentElement != null)
		{
			if (parentElement instanceof HAnimHumanoid)
				return (HAnimHumanoid) parentElement;
			parentElement = ((X3DConcreteElement)this).getParent();
		}
		return null;
	}
	/** Return whether ancestor HAnimHumanoid is available
	 * @return true if ancestor HAnimHumanoid found
	 */
	public boolean hasAncestorHAnimHumanoid()
	{
		return (getAncestorHAnimHumanoid() != null);
	}
</xsl:text>
								</xsl:if>

								<xsl:choose>
									<xsl:when test="($name = 'HAnimMotion') and not($isInterface = 'true')">
										<xsl:text>
	/** Return version of ancestor HAnimHumanoid (if found) or this HAnimMotion node
	 * @return ancestor version if found, otherwise 2.0
	 * @see HAnimHumanoid#VERSION_2_0
	 */
	public String getHAnimVersion()
	{
		if  (hasAncestorHAnimHumanoid())
			 return getAncestorHAnimHumanoid().getVersion();
		else return HAnimHumanoid.VERSION_2_0;
	}
</xsl:text>
									</xsl:when>
									<xsl:when test="($name = 'HAnimHumanoid') and not($isInterface = 'true')">
										<xsl:text>
	/** Return version of this HAnimHumanoid
	 * @return HAnim version
	 */
	public String getHAnimVersion()
	{
		return getVersion();
	}
</xsl:text>
									</xsl:when>
									<xsl:when test="(starts-with($name, 'HAnim')) and not($isInterface = 'true')">
										<xsl:text>
	/** Return version of ancestor HAnimHumanoid
	 * @return version if found, otherwise "-1"
	 */
	public String getHAnimVersion()
	{
		if (hasAncestorHAnimHumanoid())
			return getAncestorHAnimHumanoid().getVersion();
		else return "-1";
	}
</xsl:text>
									</xsl:when>
								</xsl:choose>

					<xsl:if test="($hasImplementationBlock)">
						<xsl:if test="starts-with(normalize-space($implementationBlock),'{')">
							<xsl:message>
								<xsl:text>*** Code-generation warning: $implementationBlock starts with {</xsl:text>
							</xsl:message>
						</xsl:if>
						<xsl:value-of select="$implementationBlock" disable-output-escaping="yes"/> <!-- typically has additional javadoc included -->
					</xsl:if>

					<!-- Additional one-per-class utility methods -->
					<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
								  not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not(starts-with($thisClassName, 'X3DConcrete')) and
								  not($isUtilityClass = 'true')">

						<xsl:text>&#10;</xsl:text>
						<xsl:text>	// Additional utility methods for this class ==============================
</xsl:text>
						<xsl:variable name="hasChild">
							<xsl:value-of select="(count(*) + count(comment()) > 0)"/>
						</xsl:variable>
						<xsl:variable name="hasAttributes">
							<xsl:value-of select="(count(*) + count(comment()) > 0)"/>
						</xsl:variable>
						<xsl:variable name="isX3dStatement">
							<xsl:call-template name="isX3dStatement">
								<xsl:with-param name="name" select="@name"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:if test="(not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')) or ($name = 'ProtoInstance')">

                                                    <!-- IS added to X3DUOM
	<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign field named <i>IS</i> for establishing IS/connect field connections between ProtoInterface fields and internal ProtoBody nodes.
	 * The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
	 * @param newValue is new value for the description field.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS">X3D Tooltips: IS</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect">X3D Tooltips: connect</a>
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	/* @Override */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setIS(IS newValue)
	{
		if (IS != null)
			IS.setParent(null); // housekeeping, clear prior object
		IS = newValue;
		IS.setParent(this);
		return this;
	}
	/**
	 * Provide field named <i>IS</i> for establishing IS/connect field connections between ProtoInterface fields and internal ProtoBody nodes.
	 * The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS">X3D Tooltips: IS</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect">X3D Tooltips: connect</a>
	 * @return current IS, if any.
	 */
	/* @Override */
	public IS getIS()
	{
		return IS;
	}
-->
	<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a USE reference to another DEF node of same node type, similar to {@link #setUSE(String)}.
	 * <br ><br >
	 * <i>Warning:</i> note that the <code>setUSE()</code> method on this node resets all other fields to their default values (except for containerField) and also releases all child nodes.
	 * <br><br>
	 * <i>Warning:</i> no other operations can be performed to modify a USE node other than setting an alternate containerField value.
	 * @param DEFnode must have a DEF value defined
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setUSE(]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ DEFnode)
	{
		if (DEFnode.getDEF().isEmpty())
		{
			String errorNotice = "*** setUSE(DEFnode) invoked on ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[" +
				" that has no DEF name defined, thus a copy cannot be referenced as a USE node";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
		setUSE(DEFnode.getDEF());
		return this;
	}]]></xsl:text>
						</xsl:if>

						<!-- utility constructor for nodes -->
						<xsl:if test="not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
								<xsl:text>
	/**
	 * Utility constructor that assigns DEF label after initializing member variables with default values.
	 * @param DEFlabel unique DEF name for this X3D node
	 */
	public </xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String DEFlabel)
	{
		initialize();
		setDEF(DEFlabel); // apply checks
	}
]]></xsl:text>
						</xsl:if>
						<!-- Additional utility constructors -->
						<xsl:choose>
							<!-- Constructors for nodes with name attributes and string values -->
							<xsl:when test="($name = 'component')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor that assigns name and level attributes.
	 * @param newName  name for this component
	 * @param newLevel level value for this component element
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#component">X3D Tooltips: component</a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String newName, int newLevel)
	{
		initialize();
		setName   (newName);
		setLevel(newLevel);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'unit')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor that assigns name-category-conversionFactor triplet attributes.
	 * @param newName  name for this unit statement
	 * @param newCategory category value for this unit statement
	 * @param newConversionFactor conversion factor for this unit statement
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#unit">X3D Tooltips: meta</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Scale" target="_blank">X3D Scene Authoring Hints: Scale Factors and Unit Conversions </a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String newName, String newCategory, float newConversionFactor)
	{
		initialize();
		setName            (newName);
		setCategory        (newCategory);
		setConversionFactor(newConversionFactor);
	}
	/**
	 * Utility constructor that assigns name-category-conversionFactor triplet attributes.
	 * @param newName  name for this unit statement
	 * @param newCategory category value for this unit statement
	 * @param newConversionFactor conversion factor for this unit statement
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#unit">X3D Tooltips: meta</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Scale" target="_blank">X3D Scene Authoring Hints: Scale Factors and Unit Conversions </a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String newName, String newCategory, double newConversionFactor)
	{
		initialize();
		setName            (newName);
		setCategory        (newCategory);
		setConversionFactor(newConversionFactor);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'meta')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor that assigns name-value pair for name and content attributes.
	 * @param newName  name for this meta element
	 * @param newContent content value for this meta element
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#meta">X3D Tooltips: meta statement</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#metaStatements" target="_blank">X3D Scene Authoring Hints: meta Statements</a>
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String newName, String newContent)
	{
		initialize();
		setName   (newName);
		setContent(newContent);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'MetadataString')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor that assigns name-value pair, after initializing member variables with default values.
	 * @param DEFlabel unique DEF name for this X3D node
	 * @param newName  name for this meta element
	 * @param newValue content value for this meta element
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataString">X3D Tooltips: MetadataString</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String DEFlabel, String newName, String newValue)
	{
		initialize();
		setDEF  (DEFlabel);
		setName (newName);
		setValue(newValue);
	}
	/**
	 * Utility constructor that assigns DEF plus name-value pair, after initializing member variables with default values.
	 * @param newName  name for this meta element
	 * @param newValue content value for this meta element
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataString">X3D Tooltips: MetadataString</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String newName, String newValue)
	{
		initialize();
		setName (newName);
		setValue(newValue);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="(starts-with($name, 'Metadata') or starts-with($name, 'CAD') or starts-with($name, 'HAnim')) and not($name = 'HAnimMotion')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor that assigns both DEF label and name, after initializing member variables with default values.
	 * @param DEFlabel unique DEF name for this X3D node
	 * @param newName  name for this meta element
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[">X3D Tooltips: ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
			<xsl:if test="starts-with($name, 'Metadata')">
	<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
			</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String DEFlabel, String newName)
	{
		initialize();
		setDEF  (DEFlabel);
		setName (newName);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare') or ($name = 'ProtoInstance')">
								<xsl:text>
	/**
	 * Utility constructor that assigns </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> name after initializing member variables with default values.
	 * @param prototypeName initial name for this </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> statement
	 */
	public </xsl:text>
			<xsl:value-of select="$thisClassName"/><xsl:text><![CDATA[ (String prototypeName)
	{
		initialize();
		setName(prototypeName); // apply checks
	}
]]></xsl:text>
			<xsl:if test="($name = 'ProtoInstance')">
				<xsl:text>
	/**
	 * Utility constructor that assigns </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> prototypeName and DEF after initializing member variables with default values.
	 * @param prototypeName initial name for this </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text><![CDATA[ statement
	 * @param DEFlabel unique DEF name for this X3D node
	 */
	public ProtoInstance]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ (String prototypeName, String DEFlabel)
	{
		initialize();
		setName(prototypeName); // apply checks
		setDEF (DEFlabel);      // apply checks
	}
	/**
	 * Utility method that creates a USE copy of ProtoInstance containerField value, if DEF and name provided
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInstance.containerField">X3D Tooltips: ProtoInstance.containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField">X3D Scene Authoring Hints: containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerFieldChoices">X3D Scene Authoring Hints: validation choices for containerField</a>
	 * @return containerField value
	 */
	public ProtoInstance createProtoInstanceUSE()
	{
            ProtoInstance newUSEprotoInstance = new ProtoInstance();
            newUSEprotoInstance.setName(getName())
                               .setUSE (getDEF())
                               .setContainerField(getContainerField());
            if (getName().isBlank() || getDEF().isBlank())
                System.err.println("*** Warning, ProtoInstance.createProtoInstanceUSE() has name='" + getName() +
                                   "' and USE value matching original DEF='" + getDEF() + "' but both are required");
            return newUSEprotoInstance;
	}
	/**
	 * Utility method that provides ProtoInstance containerField value
	 * <i>Hint:</i> ProtoInstance containerField is important for determining parent-child node relationships.
	 * @see #containerField_DEFAULT_VALUE
         * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 * @see org.web3d.x3d.jsail.X3DConcreteNode#setContainerFieldOverride(String)
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInstance.containerField">X3D Tooltips: ProtoInstance.containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField">X3D Scene Authoring Hints: containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerFieldChoices">X3D Scene Authoring Hints: validation choices for containerField</a>
	 * @return containerField value
	 */
	public String getContainerField()
	{
		return getContainerFieldOverride();
	}
	/**
	 * Utility method that assigns ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text><![CDATA[ containerField value
	 * <i>Hint:</i> ProtoInstance containerField is important for determining parent-child node relationships.
	 * @param containerFieldName overriding value
	 * @see org.web3d.x3d.jsail.X3DConcreteNode#setContainerFieldOverride(String)
	 * @return {@link ProtoInstance} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInstance.containerField">X3D Tooltips: ProtoInstance.containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField">X3D Scene Authoring Hints: containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerFieldChoices">X3D Scene Authoring Hints: validation choices for containerField</a>
	 */
	public ProtoInstance setContainerField(String containerFieldName)
	{
		setContainerFieldOverride(containerFieldName);
		return this;
	}
	/**
	 * Utility method to find original ProtoInstance name if this ProtoInstance is a USE node (which does not include name).
	 * @return {@link ProtoInstance} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public String getOriginalName()
	{
		if (!getName().isEmpty())
		    return getName();

		String          originalName = getName();
		X3DConcreteNode originalProtoInstanceNode = null;
		if (originalName.isEmpty())
		{
            if (findAncestorScene() != null)
                 originalProtoInstanceNode = findAncestorScene().findNodeByDEF(getUSE());

			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
            {
                if (originalProtoInstanceNode == null)
                {
                    String errorNotice = ConfigurationProperties.ERROR_NODE_NOT_FOUND +
                            ": unable to locate reference ProtoInstance DEF='" + getUSE() + "' for ProtoInstance USE='" + getUSE() + "'";
                    validationResult.append(errorNotice);
                    throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
                }
                else if (!(originalProtoInstanceNode instanceof ProtoInstance))
                {
                    String errorNotice = ConfigurationProperties.ERROR_NODE_NOT_FOUND +
                            ": unable to locate correct node reference, ProtoInstance USE='" + getUSE() + "' mistakenly matches " + originalProtoInstanceNode.getClass() + " DEF='" + getUSE() + "'";
                    validationResult.append(errorNotice);
                    throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
                }
                originalName = ((ProtoInstance)originalProtoInstanceNode).getName();
			}
		}
		return originalName;
	}
	/**
	 * Determine whether a corresponding ProtoDeclare with same name is connected in this scene graph.
	 * @see #hasExternProtoDeclare
	 * @see #getProtoDeclare
	 * @see #getExternProtoDeclare
	 * @return {@link ProtoInstance} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public boolean hasProtoDeclare()
	{
		// check for corresponding declaration
		if  (findAncestorScene() == null)
			 return false;
		// ProtoInstance USE nodes don't include name, so utility method getOriginalName() helps here
		X3DConcreteElement matchingDeclaration = null;
        if (!getOriginalName().isEmpty())
             matchingDeclaration = findAncestorScene().findElementByNameValue(getOriginalName(), ProtoDeclare.NAME);
		if ((matchingDeclaration != null) && (matchingDeclaration instanceof org.web3d.x3d.jsail.Core.ProtoDeclare))
		{
			 referenceProtoDeclare = (ProtoDeclare) matchingDeclaration;
			 return true;
		}
		else return false;
	}
	/**
	 * Determine whether a corresponding ExternProtoDeclare with same name is connected in this scene graph.
	 * @see #hasProtoDeclare
	 * @see #getProtoDeclare
	 * @see #getExternProtoDeclare
	 * @return {@link ProtoInstance} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public boolean hasExternProtoDeclare()
	{
		// check for corresponding declaration
		if  (findAncestorScene() == null)
			 return false;
		// ProtoInstance USE nodes don't include name, so utility method getOriginalName() helps here
		X3DConcreteElement matchingDeclaration = null;
        if  (!getOriginalName().isEmpty())
             matchingDeclaration = findAncestorScene().findElementByNameValue(getOriginalName(), ExternProtoDeclare.NAME);
		if ((matchingDeclaration != null) && (matchingDeclaration instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclare))
		{
			 referenceExternProtoDeclare = (ExternProtoDeclare) matchingDeclaration;
			 return true;
		}
		else return false;
	}
	/**
	 * Provide corresponding ProtoDeclare with same name if connected in this scene graph.
	 * @see #hasProtoDeclare
	 * @see #hasExternProtoDeclare
	 * @see #getExternProtoDeclare
	 * @return {@link ProtoInstance} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ProtoDeclare getProtoDeclare()
	{
		if  (hasProtoDeclare())
			 return referenceProtoDeclare;
		else return null;
	}
	/**
	 * Provide corresponding ExternProtoDeclare with same name if connected in this scene graph.
	 * @see #hasProtoDeclare
	 * @see #hasExternProtoDeclare
	 * @see #getProtoDeclare
	 * @return {@link ProtoInstance} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ExternProtoDeclare getExternProtoDeclare()
	{
		if  (hasExternProtoDeclare())
			 return referenceExternProtoDeclare;
		else return null;
	}
]]></xsl:text>
			</xsl:if>

				<!-- getNodeType() -->
				<xsl:text>
	/**
	 * </xsl:text>
	 <xsl:if test="($name = 'ExternProtoDeclare')">
		 <xsl:text disable-output-escaping="yes"><![CDATA[(<i>Warning:</i> not yet supported in ExternProtoDeclare implementation, TODO) ]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[This method helps determine node type of ProtoInstance by inspecting first node within corresponding ProtoDeclare ProtoBody]]></xsl:text>
	 <xsl:if test="($name = 'ProtoDeclare')">
		 <xsl:text disable-output-escaping="yes"><![CDATA[, where local copy is maintained in ProtoBody <i>primaryNode</i>]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#PROTOdefinitionsemantics">X3D Abstract Specification: 4.4.4.3 PROTO definition semantics</a>]]></xsl:text>
	 <xsl:choose>
		 <xsl:when test="($name = 'ProtoDeclare')">
			 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see ProtoBody#getNodeType()
	 * @see ExternProtoDeclare#getNodeType()
	 * @see ProtoInstance#getNodeType()
	 * @see Scene]]></xsl:text>
		 </xsl:when>
		 <xsl:when test="($name = 'ExternProtoDeclare')">
			 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see ProtoDeclare#getNodeType()
	 * @see ProtoBody#getNodeType()
	 * @see ProtoInstance#getNodeType()
	 * @see Scene]]></xsl:text>
		 </xsl:when>
		 <xsl:when test="($name = 'ProtoInstance')">
			 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see ProtoDeclare#getNodeType()
	 * @see ProtoBody#getNodeType()
	 * @see ExternProtoDeclare#getNodeType()
	 * @see Scene]]></xsl:text>
		 </xsl:when>
	 </xsl:choose>
	 <xsl:text disable-output-escaping="yes"><![CDATA[

	 * @return name of X3D node corresponding to node type for this ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> statement
	 */
	public String getNodeType()
	{</xsl:text>
		<xsl:choose>
			<xsl:when test="($name = 'ProtoDeclare')">
				<xsl:text>
		if (ProtoBody != null)
			 return ProtoBody.getNodeType();
		else
		{
			String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE + ": " +
						         "ProtoDeclare name='" + getName() + "' has no ProtoBody and thus has no node type yet.";
			validationResult.append(errorNotice).append("\n");
			return errorNotice; // node type not found
		}
                </xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'ExternProtoDeclare')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		String errorNotice = new String();
		if (findAncestorScene() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_UNKNOWN_EXTERNPROTODECLARE_NODE_TYPE + ": " +
						   "ExternProtoDeclare name='" + getName() + "' must first be connected to Scene scene graph in order to get checked.";
				validationResult.append(errorNotice).append("\n");
			}
			return errorNotice; // node type not found
		}
		// TODO consider metadata node or contained-comment convention for noting node type
		// TODO remote loading of external ProtoDeclare file, then lookup of node type
		errorNotice = ConfigurationProperties.ERROR_UNKNOWN_EXTERNPROTODECLARE_NODE_TYPE + ": " +
                        "ExternProtoDeclare name='" + getName() + "' type cannot be remotely accessed at run time.\n" +
                        "TODO X3DJSAIL needs to add further capability that retrieves the ExternProtoDeclare file.";
		validationResult.append(errorNotice).append("\n");
		return errorNotice; // node type not found]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'ProtoInstance')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// check for corresponding declaration
		String errorNotice = new String();
		if (findAncestorScene() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE + ": " +
							   "ProtoInstance name='" + getOriginalName() + "' must first be connected to Scene scene graph in order to get checked.";
				validationResult.append(errorNotice).append("\n");
				return ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH + "_PrototypeNotFound"; // node type not found
			}
			else return errorNotice;
		}
		// ProtoInstance USE nodes don't include name, so utility method getOriginalName() helps here
		X3DConcreteElement matchingDeclaration = null;
		if ((findAncestorScene() != null) && !getOriginalName().isEmpty())
        {
            // first try ProtoDeclare
			matchingDeclaration = findAncestorScene().findElementByNameValue(getOriginalName(), ProtoDeclare.NAME);
            if ((matchingDeclaration != null) && (matchingDeclaration instanceof org.web3d.x3d.jsail.Core.ProtoDeclare))
            {
                if (getContainerFieldOverride().isEmpty()) // fall back to use ProtoDeclare default value since actual value not provided in source model
                {
					String computedContainerField = ((ProtoDeclare) matchingDeclaration).getContainerFieldDefault();
                    setContainerFieldOverride(computedContainerField);

                    if (!computedContainerField.equals(ProtoInstance.containerField_DEFAULT_VALUE))
					{
						String warningNotice = ConfigurationProperties.WARNING_MESSAGE + ": " +
							"ProtoInstance name='" + getOriginalName() + "' DEF='" + getDEF() + "' USE='" + getUSE() +
							"' is missing containerField relationship to parent node, assuming " +
							"containerField='" + getContainerFieldOverride() + "' from initial node in corresponding ProtoDeclare. " +
							"Need to fix ProtoInstance definition in model source.";
						validationResult.append(warningNotice).append("\n");
						System.out.println(warningNotice);
					}
                }
                return ((ProtoDeclare) matchingDeclaration).getNodeType();
            }
            // next try ExternProtoDeclare
            matchingDeclaration = findAncestorScene().findElementByNameValue(getOriginalName(), ExternProtoDeclare.NAME);
            if ((matchingDeclaration != null) && (matchingDeclaration instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclare))
            {
                // no way to determine default containerField
                return ((ExternProtoDeclare) matchingDeclaration).getNodeType();
            }
        }
        if  (ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
             return "";
        else
        {
            errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE + ": ";
            if  (hasUSE())
                 errorNotice += "ProtoInstance USE='" + getUSE();
            else errorNotice += "ProtoInstance name='" + getName();
            errorNotice += "' has no corresponding ProtoDeclare or ExternProtoDeclare to provide type.";
            validationResult.append(errorNotice).append("\n");
            return errorNotice; // node type not found
        }

]]></xsl:text>
			</xsl:when>
		</xsl:choose>
<xsl:text>
	}
</xsl:text>
								<xsl:if test="($name = 'ProtoDeclare')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method that provides default containerField value for initial node in ProtoDeclare.
	 * <i>Hint:</i> ProtoInstance containerField is important for determining parent-child node relationships.
         * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 * @see org.web3d.x3d.jsail.X3DConcreteNode#setContainerFieldOverride(String)
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInstance.containerField">X3D Tooltips: ProtoInstance.containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField">X3D Scene Authoring Hints: containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerFieldChoices">X3D Scene Authoring Hints: validation choices for containerField</a>
	 * @return default containerField value
	 */
	public String getContainerFieldDefault()
	{
            if (ProtoBody != null)
                return ProtoBody.getContainerFieldDefault();
            else return "";
        }
	/**
	 * Find contained field statement by name, if present in contained ProtoInterface.
	 * @param fieldName is name attribute for field of interest
	 * @return field reference of interest, null otherwise
	 */
	public field findFieldByName (String fieldName)
	{
		if  (hasProtoInterface())
			 return getProtoInterface().findFieldByName(fieldName);
		else return null;
	}
	/**
	 * Determine if field statement is present in contained ProtoInterface.
	 * @param fieldName is name attribute for field of interest
	 * @return whether field is found
	 */
	public boolean hasField (String fieldName)
	{
		return (findFieldByName(fieldName) != null);
	}
]]></xsl:text>
								</xsl:if>
							</xsl:when>
							<xsl:when test="($name = 'ProtoBody')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * First node within ProtoDeclare ProtoBody determines node type of corresponding ProtoInstance, local reference maintained in member variable named <i>primaryNode</i>.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#PROTOdefinitionsemantics">X3D Abstract Specification: 4.4.4.3 PROTO definition semantics</a>
	 * @see ProtoDeclare#getNodeType()
	 * @see ExternProtoDeclare#getNodeType()
	 * @see ProtoInstance#getNodeType()
	 * @see Scene
	 * @return name of X3D node corresponding to node type for this ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ statement
	 */
	public String getNodeType()
	{
		if (primaryNode != null)
		     return primaryNode.getElementName();
		else
		{
			String prototypeName = "ParentProtoDeclareNameNotKnown";
			if (getParent() !=  null)
				prototypeName = ((ProtoDeclare)getParent()).getName();
			String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE + ": " +
						   "ProtoDeclare name='" + prototypeName + "' ProtoBody has no initial node and thus has no node type yet.";
			validationResult.append(errorNotice).append("\n");
			return errorNotice; // node type not found
		}
	}
	/**
	 * Utility method that provides default containerField value for initial node in ProtoDeclare.
	 * <i>Hint:</i> ProtoInstance containerField is important for determining parent-child node relationships.
         * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 * @see org.web3d.x3d.jsail.X3DConcreteNode#setContainerFieldOverride(String)
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInstance.containerField">X3D Tooltips: ProtoInstance.containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField">X3D Scene Authoring Hints: containerField</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerFieldChoices">X3D Scene Authoring Hints: validation choices for containerField</a>
	 * @return default containerField value
	 */
	public String getContainerFieldDefault()
	{
        if  (primaryNode != null)
             return primaryNode.getContainerFieldDefault();
        else return "";
    }
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'field')">
								<xsl:text>
	// no other constructors because field must have name, type, accessType (required)
	/**
	 * Utility constructor that assigns name, type, accessType (required)
	 * @param fieldName name for this field (required, and locally unique among peer fields)
	 * @param fieldType appropriate type value for this field (required)
	 * @param fieldAccessType appropriate accessType value for this field (required)
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text> (String fieldName, String fieldType, String fieldAccessType)
	{
		initialize();
		      setName(fieldName);		// apply checks
		      setType(fieldType);		// apply checks
		setAccessType(fieldAccessType);	// apply checks
	}
	/**
	 * Utility constructor that assigns name, type, accessType (required) and default value (if appropriate)
	 * @param fieldName name for this field (required, and locally unique among peer fields)
	 * @param fieldType appropriate type value for this field (required)
	 * @param fieldAccessType appropriate accessType value for this field (required)
	 * @param defaultValue string version of default value for this field (if appropriate)
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text> (String fieldName, String fieldType, String fieldAccessType, String defaultValue)
	{
		initialize();
		      setName(fieldName);	// apply checks
		      setType(fieldType);	// apply checks
		setAccessType(fieldAccessType);	// apply checks
		     setValue(defaultValue);	// apply checks
	}
</xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'fieldValue')">
								<xsl:text>
	/**
	 * Utility constructor that also assigns fieldValueName
	 * @param fieldValueName unique DEF name for this X3D node
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text> (String fieldValueName)
	{
		initialize();
		setName(fieldValueName);
	}
	/**
	 * Utility constructor that also assigns fieldValueName, defaultValue
	 * @param fieldValueName unique name for this field
	 * @param defaultValue string version of defaultValue for this field
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String fieldValueName, String defaultValue)
	{
		initialize();
		setName (fieldValueName);
	    setValue(defaultValue);
	}
        // special utilities for fieldValue IS

        private IS IS; // SFNode acceptable node types: IS

	/**
	 * Provide IS instance (using a properly typed node) from inputOutput SFNode field <i>IS</i>.
	 * @return value of IS field
	 */
	public IS getIS()
	{
		return IS;
	}

	/**
	 * Accessor method to assign IS instance (using a properly typed node) to inputOutput SFNode field <i>IS</i>.
	 * @param newValue is new value for the IS field.
	 * @return {@link fieldValue} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public fieldValue setIS(IS newValue)
	{
            // set-newValue-validity-checks #0.d
            IS = newValue;
            if (newValue != null)
            {
                    ((X3DConcreteElement) IS).setParent(this); // parentTest15.2
            }
            return this;
	}

	/**
	 * Utility method to clear SFNode value of IS field.
	 * @return {@link fieldValue} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).	 */
	public fieldValue clearIS()
	{
		((X3DConcreteElement) IS).clearParent(); // remove references to facilitate Java memory management
		IS = null; // reset SFNode field
		return this;
	}

	/**
	 * Indicate whether an object is available for inputOutput SFNode field <i>IS</i>.
	 * @return whether an IS statement is available.
	 * @see #getIS()
	 */
	public boolean hasIS()
	{
		return (IS != null);
	}

	/** Utility method to indicate accessType corresponding to given fieldValue name.
	 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_ACCESSTYPE
	 * @return X3D accessType (inputOnly etc.), otherwise ConfigurationProperties.ERROR_UNKNOWN_FIELD_ACCESSTYPE if not recognized
	 */
	/* @Override */
	public String getAccessType()
	{
            return getAccessType(getName());
	}
]]></xsl:text>
							</xsl:when>

<!-- error prone, not included:

							<xsl:when test="($name = 'connect')">
								<xsl:text>
	/**
	 * Utility constructor that assigns both nodeField and protoField (be sure to get order correct).
	 * @param protoField field name in the containing Prototype interface
	 * @param nodeField field name in the parent node that is getting connected
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text> (String protoFieldName, String nodeFieldName)
	{
		initialize();
		setProtoField(protoFieldName);
		setNodeField( nodeFieldName);
	}
</xsl:text>
							</xsl:when>
-->
						</xsl:choose> <!-- utility constructors -->

						<!-- Additional utility methods -->
                        <xsl:choose>
                            <xsl:when test="($name = 'head')">
                                <xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Add a child <i>component</i> statement.
     * @param componentName name for component statement
     * @param level for component statement
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#component">X3D Tooltips: component</a>
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ addComponent (String componentName, int level)
	{
        return addComponent(new component(componentName, level));
	}
	/**
	 * Add a child <i>unit</i> statement.
	 * @param newName name for this unit statement
	 * @param newCategory category value for this unit statement
	 * @param newConversionFactor conversion factor for this unit statement
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#unit">X3D Tooltips: unit statement</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Scale" target="_blank">X3D Scene Authoring Hints: Scale Factors and Unit Conversions </a>
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ addUnit (String newName, String newCategory, float newConversionFactor)
	{
        return addUnit(new unit(newName, newCategory, newConversionFactor));
	}
	/**
	 * Add a child <i>unit</i> statement.
	 * @param newName name for this unit statement
	 * @param newCategory category value for this unit statement
	 * @param newConversionFactor conversion factor for this unit statement
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#unit">X3D Tooltips: unit statement</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Scale" target="_blank">X3D Scene Authoring Hints: Scale Factors and Unit Conversions </a>
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ addUnit (String newName, String newCategory, double newConversionFactor)
	{
        return addUnit(new unit(newName, newCategory, newConversionFactor));
	}
	/**
	 * Add a child <i>meta</i> statement.
     * @param newName name for meta statement
     * @param newDescription description for meta statement
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#meta">X3D Tooltips: meta statement</a>
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addMeta (String newName, String newDescription)
	{
        return addMeta(new meta(newName, newDescription));
	}
</xsl:text>
                            </xsl:when>
                            <xsl:when test="($name = 'field') or ($name = 'fieldValue')">
                                <xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Indicate whether a node or statement is found in inputOutput MFNode field <i>children</i>.
	 * @return whether a node or statement is found; ignores CommentsBlock.
	 * @see #getChildren()
	 */
	public boolean hasChildrenElements()
	{
		if (children.isEmpty())
			return false; // nothing found
		for (org.web3d.x3d.sai.Core.X3DNode node : children)
		{
			if (!(node instanceof CommentsBlock))
				return true;
		}
		return false; // nothing but CommentsBlock found
	}
]]></xsl:text>
                            </xsl:when>
                        </xsl:choose>

						<!-- commentsBlock -->
						<xsl:if test="(not($hasChildrenField = 'true') and not(starts-with($name, 'X3DConcrete')) and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
									   not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock'))">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Add comment as String to contained commentsList.
	 * @param newComment initial value
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#Organization">X3D Architecture, clause 7.2.5.1 Organization</a>
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	/* @Override */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (String newComment)
	{</xsl:text>
        <!-- it is OK to append a comment to a USE node
							<xsl:if test="not($isX3dStatement = 'true')">
								<xsl:text>
		if (hasUSE())
		{
			String errorNotice = "*** addComments(\"" + newComment + "\")" + "\n" +
					"cannot be applied to a USE node (USE='" + getUSE() + "') which only contains a reference to a DEF node";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
								</xsl:text>
							</xsl:if>
        -->
								<xsl:text>
		commentsList.add(newComment);
		return this;
	}
	/**
	 * Add comments as String[] array to contained commentsList.
	 * @param newComments array of comments
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	/* @Override */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (String[] newComments)
	{</xsl:text>
                <!-- it is OK to append a comment to a USE node
							<xsl:if test="not($isX3dStatement = 'true')">
								<xsl:text>
		if (hasUSE())
		{
			String errorNotice = "*** addComments(" + Arrays.toString(newComments) + ")" + "\n" +
					"cannot be applied to a USE node (USE='" + getUSE() + "') which only contains a reference to a DEF node";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
								</xsl:text>
							</xsl:if>
                -->
								<xsl:text>
		commentsList.addAll(Arrays.asList(newComments));
		return this;
	}
	/**
	 * Add CommentsBlock to contained commentsList.
	 * @param newCommentsBlock block of comments to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	/* @Override */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (CommentsBlock newCommentsBlock)
	{</xsl:text>
        <!-- it is OK to append a comment to a USE node
							<xsl:if test="not($isX3dStatement = 'true')">
								<xsl:text>
		if (hasUSE())
		{
			String errorNotice = "*** addComments(CommentsBlock) " +
					"cannot be applied to a USE node (USE='" + getUSE() + "') which only contains a reference to a DEF node";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
								</xsl:text>
							</xsl:if>
        -->
								<xsl:text>
		commentsList.addAll(newCommentsBlock.toStringList());
		return this;
	}</xsl:text>
						</xsl:if>

						<!-- toStringX3D, toStringXML -->
						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">

          <!-- handle field synonyms -->
                            <xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to adjust field synonyms
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#fieldNameChanges">X3D Scene Authoring Hints: X3D4 Field name changes for improved consistency</a>
     */
    private void handleFieldSynonyms()
    {]]></xsl:text>
    <xsl:choose>
        <xsl:when test="InterfaceDefinition/field[string-length(@synonym) > 0]">
            <xsl:text>
        String correctedContainerField;</xsl:text>
            <xsl:for-each select="InterfaceDefinition/field[string-length(@synonym) > 0][@type = 'SFNode']">
                <!-- great bugfix by John Carlson, this block needs to be repeated for each SFNode field -->
                <xsl:text disable-output-escaping="yes"><![CDATA[
        if (hasAncestorX3D() && findAncestorX3D().getVersion().startsWith("3"))
             correctedContainerField = "]]></xsl:text><xsl:value-of select="@synonym"/><xsl:text>";
        else correctedContainerField = "</xsl:text>   <xsl:value-of select="@name"/><xsl:text>";
</xsl:text>
                <xsl:variable name="CamelCaseName"><!-- upper camel case -->
                    <xsl:value-of select="translate(substring(@name,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
                    <xsl:value-of select="substring(@name,2)"/>
                </xsl:variable>
                <xsl:text>
        if      (get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>() != null)
                 ((X3DConcreteNode) get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>()).setContainerFieldOverride(correctedContainerField);
        else if (get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>ProtoInstance() != null)
                 ((X3DConcreteNode) get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>ProtoInstance()).setContainerFieldOverride(correctedContainerField);
</xsl:text>
            </xsl:for-each>
            <xsl:for-each select="InterfaceDefinition/field[string-length(@synonym) > 0][@type = 'MFNode']">
                <xsl:if test="(position() = 1)">
                    <xsl:text disable-output-escaping="yes"><![CDATA[
        if (hasAncestorX3D() && findAncestorX3D().getVersion().startsWith("3"))
             correctedContainerField = "]]></xsl:text><xsl:value-of select="@synonym"/><xsl:text>";
        else correctedContainerField = "</xsl:text>   <xsl:value-of select="@name"/><xsl:text>";
</xsl:text>
                </xsl:if>
                <xsl:text>
        for (org.web3d.x3d.sai.Core.X3DNode element : </xsl:text><xsl:value-of select="@name"/><xsl:text>)
        {</xsl:text>
                <xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
                    <xsl:variable name="saiPackage">
                        <xsl:call-template name="saiPackage">
                            <xsl:with-param name="nodeType" select="."/>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:text>
            if (element instanceof</xsl:text><xsl:value-of select="$saiPackage"/>.<xsl:value-of select="."/><xsl:text>)
                ((X3DConcreteNode) element).setContainerFieldOverride(correctedContainerField);</xsl:text>
                </xsl:for-each>
                <xsl:text>
        }
 </xsl:text>
            </xsl:for-each>
        </xsl:when>
        <xsl:otherwise>
            <xsl:text>
            // no synonyms to handle
</xsl:text>
        </xsl:otherwise>
    </xsl:choose>
            <xsl:text>	}</xsl:text>

							<xsl:text disable-output-escaping="yes"><![CDATA[

	/**
	 * Recursive method to provide X3D string serialization of this model subgraph, utilizing XML encoding and conforming to X3D Canonical Form.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3D#FILE_EXTENSION_X3D
	 * @see X3D#FILE_EXTENSION_XML
	 * @see X3D#toStringXML()
	 * @see X3D#toFileXML(String)
	 * @see X3D#toFileX3D(String)
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
	 * @return X3D string
	 */
	@Override
	public String toStringX3D(int indentLevel)
	{]]></xsl:text>
	<xsl:if test="not($name = 'CommentsBlock')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
		boolean hasAttributes = true; // TODO check for non-default attribute values
		boolean      hasChild = ]]></xsl:text>
		<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) or ($name = 'ProtoInstance')">
			<xsl:text>(IS != null) || </xsl:text>
		</xsl:if>
		<xsl:variable name="fieldsList" select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and
														((@accessType='initializeOnly') or (@accessType='inputOutput'))]"/>
		<xsl:for-each select="$fieldsList">
			<!-- do not sort child elements/statements, retain document order -->
			<xsl:variable name="isX3dStatement">
				<xsl:call-template name="isX3dStatement">
					<xsl:with-param name="name" select="@name"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram')">
					<xsl:text>(!fieldList.isEmpty()) || (!sourceCode.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ComposedShader') or ($name = 'PackagedShader')">
					<xsl:text>(!fieldList.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ShaderPart')">
					<xsl:text>(!sourceCode.isEmpty()) || </xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="(@type = 'SFNode')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="@name"/>
					<xsl:text> != null)</xsl:text>
					<xsl:if test="not($isX3dStatement = 'true')">
						<xsl:text> || (</xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text>ProtoInstance != null)</xsl:text>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise><!-- (@type='MFNode') -->
					<xsl:text>(!</xsl:text>
					<xsl:value-of select="@name"/>
					<xsl:if test="($isX3dStatement = 'true')">
						<xsl:text>List</xsl:text><!-- append to member name -->
					</xsl:if>
					<xsl:text>.isEmpty())</xsl:text>
				</xsl:otherwise>
			</xsl:choose>

			<xsl:if test="(last() > position()) or not($hasChildrenField = 'true')">
				<xsl:text> || </xsl:text>
                                <xsl:text>&#10;</xsl:text>
				<xsl:text>		                        </xsl:text>
			</xsl:if>
		</xsl:for-each>
		<xsl:choose>
			<xsl:when test="not($hasChildrenField = 'true')">
				<xsl:text disable-output-escaping="yes">!commentsList.isEmpty()</xsl:text>
			</xsl:when>
			<xsl:when test="1 > count($fieldsList)">
				<xsl:text>false</xsl:text><!-- TODO account for CommentsBlock -->
			</xsl:when>
		</xsl:choose>
		<xsl:text>;</xsl:text><!-- hasChild definition complete -->
	</xsl:if>
	<xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
		if (hasUSE())
			hasChild = false; // USE nodes only include attributes for USE and non-default containerField]]></xsl:text><!-- append to member name -->
	</xsl:if>
        <!-- handle field synonyms -->
	<xsl:text>
		handleFieldSynonyms(); // adjust containerField values for X3D3 differences, if any</xsl:text>

	<xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder indent = new StringBuilder();
		int  indentIncrement = ConfigurationProperties.getIndentIncrement();
		char indentCharacter = ConfigurationProperties.getIndentCharacter();
		for (int i = 0; i < indentLevel; i++)
			indent.append(indentCharacter); // level of indentation for this level

		StringBuilder stringX3D = new StringBuilder();
]]></xsl:text>

		<!-- special constants needed for serialization toStringX3D -->
		<xsl:choose>
			<xsl:when test="($name = 'X3D')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringX3D.append(XML_HEADER).append("\n");
		switch (version)
		{
			case "3.0":
				stringX3D.append(XML_DOCTYPE_X3D_3_0).append("\n");
				break;
			case "3.1":
				stringX3D.append(XML_DOCTYPE_X3D_3_1).append("\n");
				break;
			case "3.2":
				stringX3D.append(XML_DOCTYPE_X3D_3_2).append("\n");
				break;
			case "3.3":
				stringX3D.append(XML_DOCTYPE_X3D_3_3).append("\n");
				break;
			case "4.0":
				stringX3D.append(XML_DOCTYPE_X3D_4_0).append("\n");
				break;
			case "4.1":
				stringX3D.append(XML_DOCTYPE_X3D_4_1).append("\n");
				break;
			default:
				stringX3D.append("<!-- unknown DOCTYPE for X3D version ").append(version).append(" -->").append("\n");
		}
		stringX3D.append("<!-- This model file was produced using X3DJSAIL https://www.web3d.org/specifications/java/X3DJSAIL.html -->").append("\n");]]></xsl:text>
			</xsl:when>
		</xsl:choose>

		<xsl:choose>
			<xsl:when test="($name = 'CommentsBlock')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		for (String comment : commentsList)
		{
                    if (ConfigurationProperties.isNormalizeCommentWhitespace())
                    {
                        // https://stackoverflow.com/questions/3958955/how-to-remove-duplicate-white-spaces-in-string-using-java
                        comment = comment.replaceAll("\\s+", " ");
                    }
                    stringX3D.append(indent).append("<!-- ").append(CommentsBlock.cleanXmlCommentDelimiters(comment).trim()).append(" -->").append("\n");
		}]]></xsl:text>
			</xsl:when>
			<xsl:otherwise>

		<xsl:text disable-output-escaping="yes"><![CDATA[
		stringX3D.append(indent).append("<]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA["); // start opening tag
		if (hasAttributes)
		{]]></xsl:text>
			<!-- DEF, USE, name attributes first for readability and to match X3D Canonical Form -->
			<xsl:if test="InterfaceDefinition/field[@name = 'DEF']">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			if (!getDEF().equals(DEF_DEFAULT_VALUE) && !hasUSE())
			{
				stringX3D.append(" DEF='").append(SFString.toString(getDEF())).append("'");
			}
			]]></xsl:text>
			</xsl:if>
			<xsl:if test="InterfaceDefinition/field[@name = 'USE']">
				<xsl:text>
			if (!getUSE().equals(USE_DEFAULT_VALUE))
			{
				stringX3D.append(" USE='").append(SFString.toString(getUSE())).append("'");
			}
			</xsl:text>
			</xsl:if>
			<!-- output prior to other fields; name comes first, except for meta statement -->
			<xsl:if test="InterfaceDefinition/field[@name = 'name'] and not(@name='meta')">
			<!-- name is now required
                                <xsl:if test="($name = 'ProtoInstance')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
			// note special case for ProtoInstance, do not include name field if USE is present]]></xsl:text>
				</xsl:if> -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
			if (!getName().equals(NAME_DEFAULT_VALUE)]]></xsl:text>
			<!-- name is now required
			<xsl:if test="not($isX3dStatement = 'true') or ($name = 'ProtoInstance')">
				<xsl:text disable-output-escaping="yes"><![CDATA[ && !hasUSE()]]></xsl:text>
			</xsl:if> -->
			<xsl:text>)
			{
				stringX3D.append(" name='").append(SFString.toString(getName())).append("'");
			}
			</xsl:text>
			</xsl:if>
                        <xsl:choose>
                            <xsl:when test="starts-with(local-name(),'Metadata')">
                                    <xsl:text disable-output-escaping="yes"><![CDATA[
            if      (getParent() instanceof Scene)
            {
                    // must be default value since it is one of children of Scene
                    // stringX3D.append(" containerField='").append(this.getContainerFieldDefault()).append("'");
            }
            else if (!getContainerFieldOverride().isBlank() && !getContainerFieldOverride().equals(this.getContainerFieldDefault()))
            {
                   stringX3D.append(" containerField='").append(getContainerFieldOverride()).append("'");
            }
]]></xsl:text>
                            </xsl:when>
                            <!-- this if statement might be more selective, but this approach is safest to avoid unintended omission and evolution -->
                            <xsl:when test="not($isX3dStatement = 'true') or ($name = 'ProtoInstance')">
                                    <xsl:text disable-output-escaping="yes"><![CDATA[
            // containerField is critical for ProtoInstance relationship to parent node
            if (!getContainerFieldOverride().isBlank() && !getContainerFieldOverride().equals(this.getContainerFieldDefault())) // output if not default ProtoInstance containerField
            {
                    stringX3D.append(" containerField='").append(getContainerFieldOverride()).append("'");
            }
]]></xsl:text>
                                <xsl:if test="starts-with($name,'Metadata')">
                                    <xsl:text disable-output-escaping="yes"><![CDATA[            // always output Metadata* node containerField for X3D3 since defaults changed in X3D4
            else if (!getContainerFieldOverride().isBlank() && hasAncestorX3D() && findAncestorX3D().getVersion().startsWith("3"))
            {
                    stringX3D.append(" containerField='").append(getContainerFieldOverride()).append("'");
            }
            // only output Metadata* node non-default containerField='metadata' in X3D4
            else if (!getContainerFieldOverride().isBlank() && hasAncestorX3D() && findAncestorX3D().getVersion().startsWith("4") && getContainerFieldOverride().equals("metadata"))
            {
                    stringX3D.append(" containerField='").append(getContainerFieldOverride()).append("'");
            }
]]></xsl:text>
                                </xsl:if>
                            </xsl:when>
                        </xsl:choose>
			<!-- test attributes (i.e. non-node fields) -->
			<xsl:for-each select="InterfaceDefinition/field[not(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and not(@name = 'DEF') and not(@name = 'USE') and not(@name = 'sourceCode') and
                                                            (not(@name = 'name') or ((@name = 'name') and ancestor::Statement[@name='meta'])) and
                                                            ((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
				<!-- alphabetic order of attributes is essential for X3D canonical form (C14N) -->
				<xsl:sort select="@name" order="ascending"/>

                <xsl:if test="(position() = 1)">
                    <xsl:text disable-output-escaping="yes"><![CDATA[
            // test attributes
]]></xsl:text>
                </xsl:if>
				<xsl:variable name="fieldName" select="translate(@name,'-','_')"/><!-- handle http-equiv etc. -->
				<xsl:variable name="isSingleValueType">
					<xsl:value-of select="starts-with(@type,'SF') and not(contains(@type, 'Vec')) and not(contains(@type, 'Rotation')) and not(contains(@type, 'Color')) and not(contains(@type, 'Matrix'))"/>
				</xsl:variable>
				<xsl:variable name="CamelCaseName"><!-- upper camel case -->
					<xsl:choose>
						<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
							<!-- unmodified -->
							<xsl:value-of select="@name"/>
						</xsl:when>
                        <xsl:when test="(@name = 'id')">
                            <!-- similarly named for clarity, consistency -->
							<xsl:text>HtmlID</xsl:text>
                        </xsl:when>
						<xsl:when test="(@name = 'class')">
							<!-- getClass() is reserved by Java() class -->
							<xsl:text>CssClass</xsl:text>
						</xsl:when>
						<xsl:when test="(@name = 'style') and not(contains($name, 'FontStyle'))">
							<!-- similarly named for clarity, consistency -->
							<xsl:text>CssStyle</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="translate(substring($fieldName,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
							<xsl:value-of select="substring($fieldName,2)"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="javaType">
					<xsl:call-template name="javaType">
						<xsl:with-param name="x3dType" select="@type"/>
						<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
					</xsl:call-template>
				</xsl:variable>
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
<xsl:text>// ($fieldName=</xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:text>, $hasChild=</xsl:text>
<xsl:value-of select="$hasChild"/>
<xsl:text>, $hasAttributes=</xsl:text>
<xsl:value-of select="$hasAttributes"/>
<xsl:text>, CamelCaseName=</xsl:text>
<xsl:value-of select="$CamelCaseName"/>
<xsl:text>, javaType=</xsl:text>
<xsl:value-of select="$javaType"/>
<xsl:text>, isSingleValueType=</xsl:text>
<xsl:value-of select="$isSingleValueType"/>
<xsl:text>)</xsl:text>
</xsl:message>
</xsl:if>

				<xsl:text><![CDATA[
			if ((]]></xsl:text>
			<xsl:choose>
				<!-- required attributes -->
				<xsl:when test="(($name = 'X3D') and (($fieldName = 'profile') or ($fieldName = 'version'))) or
								(($name = 'HAnimHumanoid') and ($fieldName = 'version')) or
								(($name = 'component') and ($fieldName = 'level')) or
								(($name = 'unit')      and ($fieldName = 'conversionFactor'))">
					<xsl:text><![CDATA[true) /* required attribute */ ]]></xsl:text>
				</xsl:when>
				<xsl:when test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
					<xsl:text><![CDATA[(get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[() != ]]></xsl:text>
					<xsl:value-of select="upper-case($fieldName)"/>
					<xsl:text><![CDATA[_DEFAULT_VALUE) || !ConfigurationProperties.getStripDefaultAttributes()) /* simple type */]]></xsl:text>
				</xsl:when>
				<xsl:when test="contains($javaType, 'ArrayList')">
                                            <xsl:text><![CDATA[((get]]></xsl:text>
                                            <xsl:value-of select="$CamelCaseName"/>
                                            <xsl:text disable-output-escaping="yes"><![CDATA[().length > 0) && !get]]></xsl:text>
                                            <xsl:value-of select="$CamelCaseName"/>
                                            <xsl:text disable-output-escaping="yes"><![CDATA[List().equals(]]></xsl:text>
                                            <xsl:value-of select="upper-case($fieldName)"/>
                                            <xsl:text disable-output-escaping="yes"><![CDATA[_DEFAULT_VALUE)) || !ConfigurationProperties.getStripDefaultAttributes()) /* ArrayList .x3d compare */]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'LayerSet') and ($fieldName = 'order')">
					<xsl:text><![CDATA[!(get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[().equals(]]></xsl:text>
					<xsl:value-of select="upper-case($fieldName)"/>
					<xsl:text><![CDATA[_DEFAULT_VALUE) || !ConfigurationProperties.getStripDefaultAttributes())]]></xsl:text>
				</xsl:when>
				<xsl:when test="($isSingleValueType = 'true')">
					<xsl:text><![CDATA[!get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text><![CDATA[().equals(]]></xsl:text>
					<xsl:value-of select="upper-case($fieldName)"/>
					<xsl:text><![CDATA[_DEFAULT_VALUE) || !ConfigurationProperties.getStripDefaultAttributes()) /* isSingleValueType */]]></xsl:text>
				</xsl:when>
				<xsl:when test="(string-length(@default) > 0)">
					<xsl:text><![CDATA[!Arrays.equals(get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text><![CDATA[(), ]]></xsl:text>
					<xsl:value-of select="upper-case($fieldName)"/>
					<xsl:text><![CDATA[_DEFAULT_VALUE) || !ConfigurationProperties.getStripDefaultAttributes()) /* (string-length(@default) > 0) */]]></xsl:text>
				</xsl:when>
				<xsl:otherwise>
                                    <xsl:text><![CDATA[((get]]></xsl:text>
                                    <xsl:value-of select="$CamelCaseName"/>
                                    <xsl:text disable-output-escaping="yes"><![CDATA[().length > 0) && !get]]></xsl:text>
                                    <xsl:value-of select="$CamelCaseName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[().equals(]]></xsl:text>
                                    <xsl:value-of select="upper-case($fieldName)"/>
                                    <xsl:text disable-output-escaping="yes"><![CDATA[_DEFAULT_VALUE)) || !ConfigurationProperties.getStripDefaultAttributes()) /* otherwise */]]></xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="not($isX3dStatement = 'true')">
				<xsl:text disable-output-escaping="yes"><![CDATA[ && !hasUSE()]]></xsl:text>
			</xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[)
			{
				stringX3D.append(" ]]></xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>='").append(</xsl:text>
				<xsl:choose>
					<xsl:when test="(@type = 'SFString') or (@type = 'MFString')">
						<xsl:text>new </xsl:text>
						<xsl:value-of select="@type"/>
						<xsl:value-of select="$jsaiClassSuffix"/>
						<xsl:text>(get</xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text>())</xsl:text>
						<xsl:text>.toStringX3D()</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="@type"/>
						<xsl:value-of select="$jsaiClassSuffix"/>
						<xsl:text>.toString</xsl:text>
						<xsl:text>(get</xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text>())</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:text>).append("'");
			}</xsl:text>
			</xsl:for-each>
			<xsl:choose>
				<xsl:when test="($name = 'X3D')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
				switch (version)
				{
					case "3.0":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_0_ATTRIBUTES);
						break;
					case "3.1":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_1_ATTRIBUTES);
						break;
					case "3.2":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_2_ATTRIBUTES);
						break;
					case "3.3":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_3_ATTRIBUTES);
						break;
					case "4.0":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_4_0_ATTRIBUTES);
						break;
					case "4.1":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_4_1_ATTRIBUTES);
						break;
					default:
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_3_ATTRIBUTES); // TODO error condition
						break;
				}
]]></xsl:text>
				</xsl:when>
			</xsl:choose>

			<xsl:text disable-output-escaping="yes"><![CDATA[
		}]]></xsl:text>

                <xsl:text disable-output-escaping="yes"><![CDATA[
		if ((hasChild]]></xsl:text>
                        <xsl:choose>
                            <xsl:when test="($name = 'Script')">
                                    <xsl:text><![CDATA[ || !sourceCode.isEmpty())]]></xsl:text>
                            </xsl:when>
                            <xsl:otherwise>
                                    <xsl:text>)</xsl:text>
                            </xsl:otherwise>
                        </xsl:choose>
			<xsl:if test="not($isX3dStatement = 'true')">
				<xsl:text disable-output-escaping="yes"><![CDATA[ && !hasUSE()]]></xsl:text>
			</xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[) // has contained node(s), comment(s), IS/connect and/or source code
		{
			stringX3D.append(">").append("\n"); // finish opening tag
]]></xsl:text>
            <!-- note ProtoInstance IS handled later due to serialization sequencing -->
            <!-- IS now handled by X3DUOM
            <xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock') and not($name = 'Script')">
                <xsl:text>
                if (getIS() != null)
                    stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement));</xsl:text>
            </xsl:if>
            -->

                        <xsl:if test="(not($hasChildrenField = 'true') and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
                                                   not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not($name = 'CADPart'))">
                                <xsl:text><![CDATA[
                        if (!commentsList.isEmpty())
                        {
                                CommentsBlock commentsBlock = new CommentsBlock(commentsList);
                                stringX3D.append(commentsBlock.toStringX3D(indentLevel + indentIncrement));
                        }]]></xsl:text>
                        </xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[
			// recursively iterate over child element]]></xsl:text>
			<xsl:if test="InterfaceDefinition/field[(@type = 'MFNode')] or
				   (count(InterfaceDefinition/field[contains(@type,'FNode')]) > 1)">
				<xsl:text>s</xsl:text>
			</xsl:if>

			<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and
									((@accessType='initializeOnly') or (@accessType='inputOutput')) and
                                                                        not(@name = 'meta')]">
				<!-- order is essential for elements, note that xsl:sort results in reverse order -->
				<!-- sort by statement/field @name, all other child nodes last -->
				<xsl:sort select="@name[not((. = 'Scene') or (. = 'head') or (. = 'meta') or (. = 'unit') or (. = 'component') or
                                                            (. = 'ProtoBody') or (. = 'ProtoInterface') or (. = 'IS') or (. = 'field') or (. = 'fieldValue') or
                                                            (. = 'metadata'))]"/>
				<!-- sort head before Scene in X3D -->
				<xsl:sort select="(@name = 'Scene')"/>
				<xsl:sort select="(@name = 'head')"/>
				<!-- special order within head elements: component, unit, meta -->
				<xsl:sort select="(@name = 'meta')"/>
				<xsl:sort select="(@name = 'unit')"/>
				<xsl:sort select="(@name = 'component')"/>
				<!-- sort ProtoInterface before ProtoBody in ProtoDeclare -->
				<xsl:sort select="(@name = 'ProtoBody')"/>
				<xsl:sort select="(@name = 'ProtoInterface')"/>
				<!-- necessary order for model validation: field/IS/metadata before all other nodes/statements -->
				<!-- sort order field, fieldValue, IS, metadata in ProtoInstance, Script, others -->
                                <!-- note reverse order since each sort is applied after the preceding sort -->
				<xsl:sort select="(@name = 'metadata')"/>
				<xsl:sort select="(@name = 'IS')"/>
				<xsl:sort select="(@name = 'field')"/>
                                <!-- adjust child ordering: Collision proxy field may have DEF geometry that gets USEd in children -->
                                <xsl:sort select="(@name = 'children')"/>
                                <xsl:sort select="(@name = 'proxy')"/>
                                <xsl:sort select="(@name = 'metadata')"/>

				<xsl:variable name="isX3dStatement">
                                    <xsl:call-template name="isX3dStatement">
                                        <xsl:with-param name="name" select="@name"/>
                                    </xsl:call-template>
				</xsl:variable>
				<xsl:variable name="javaType">
                                    <xsl:call-template name="javaType">
                                        <xsl:with-param name="x3dType" select="@type"/>
                                        <xsl:with-param name="isInterface" select="$isInterface"/>
                                    </xsl:call-template>
				</xsl:variable>
				<xsl:variable name="javaReferenceType"><!-- base type of ArrayList -->
                    <xsl:choose>
                        <xsl:when test="(@type = 'MFNode') and not($isX3dStatement = 'true') and not(@name = 'field') and not(@name = 'fieldValue')"><!-- (contains($javaType,'Object') or (@acceptableNodeTypes = 'X3DMetadataObject')) and not(contains($javaType,'X3DMetadataObject')) and -->
                            <xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
                        </xsl:when>
                        <xsl:when test="contains($javaType,'&lt;')">
                            <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$javaType"/>
                        </xsl:otherwise>
                    </xsl:choose>
                                </xsl:variable>

				<xsl:choose>
					<xsl:when test="(@type = 'SFNode')">
						<!-- cast abstract element to concrete type -->
						<xsl:text><![CDATA[
			if      (]]></xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
			{
				stringX3D.append(((X3DConcreteElement)</xsl:text><xsl:value-of select="@name"/>
						<xsl:text>).toStringX3D(indentLevel + indentIncrement));
			}</xsl:text>
						<xsl:if test="not($isX3dStatement = 'true')">
						<xsl:text><![CDATA[
			else if (]]></xsl:text><xsl:value-of select="@name"/><xsl:text><![CDATA[ProtoInstance != null)
			{
				stringX3D.append(((X3DConcreteElement)]]></xsl:text><xsl:value-of select="@name"/>
						<xsl:text><![CDATA[ProtoInstance).toStringX3D(indentLevel + indentIncrement));
			}]]></xsl:text>
						</xsl:if>
					</xsl:when>
					<xsl:otherwise> <!-- MFNode -->
                                            <xsl:if test="not(($name='HAnimHumanoid') and (@name='skeleton'))"><!-- avoid duplication of special case -->
						<xsl:text><![CDATA[
			for (]]></xsl:text><xsl:value-of select="$javaReferenceType"/><xsl:text><![CDATA[ element : ]]></xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<!-- cast abstract element to concrete type -->
						<xsl:text>)
			{
				stringX3D.append(((X3DConcreteElement)element).toStringX3D(indentLevel + indentIncrement));
			}</xsl:text>
                                            </xsl:if>
					</xsl:otherwise>
				</xsl:choose>

                                <xsl:if test="($name='HAnimHumanoid') and (@name='metadata')"><!-- immediately follow metadata, IS -->
                                    <xsl:text>
			// special case for HAnimHumanoid: output skeleton field prior to any of corresponding USE MFNode arrays
			for (org.web3d.x3d.sai.Core.X3DNode element : skeleton)
                        {
                                stringX3D.append(((X3DConcreteElement)element).toStringX3D(indentLevel + indentIncrement));
			}</xsl:text>
                                </xsl:if>
			</xsl:for-each>

			<xsl:if test="($name = 'head')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			// note required order of component, unit, meta (though relaxation of this requirement has been proposed)
			for (meta element : metaList)
				 stringX3D.append(element.toStringX3D(indentLevel + indentIncrement));
]]></xsl:text>
			</xsl:if>
            <!-- IS now handled by X3DUOM
			<xsl:if test="($name = 'ProtoInstance')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			if (getIS() != null)
				stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement)); // IS follows fieldValue definitions]]></xsl:text>
			</xsl:if>
            -->

			<xsl:choose>
				<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram')">
<!-- field, IS now handled by X3DUOM
			for (field element : fieldList)
				 stringX3D.append(element.toStringX3D(indentLevel + indentIncrement));

			if (getIS() != null)
				stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement)); // IS follows field definitions
-->
					<xsl:text disable-output-escaping="yes"><![CDATA[

			if (sourceCode.trim().length() > 0)
				stringX3D.append("<![CDATA[\n").append(sourceCode)
				         .append("\n]]></xsl:text><xsl:text>]]</xsl:text><xsl:text disable-output-escaping="yes"><![CDATA[>\n");
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ComposedShader') or ($name = 'PackagedShader')">
<!-- field, IS now handled by X3DUOM
					<xsl:text disable-output-escaping="yes"><![CDATA[

			for (field element : fieldList)
				 stringX3D.append(element.toStringX3D(indentLevel + indentIncrement));

			if (getIS() != null)
				stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement)); // IS follows field definitions
]]></xsl:text>
-->
				</xsl:when>
				<xsl:when test="($name = 'ShaderPart')">
<!-- field, IS now handled by X3DUOM

			if (getIS() != null)
				stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement)); // IS follows field definitions
-->
					<xsl:text disable-output-escaping="yes"><![CDATA[

			if (sourceCode.trim().length() > 0)
				stringX3D.append("<![CDATA[\n").append(sourceCode)
				         .append("\n]]></xsl:text><xsl:text>]]</xsl:text><xsl:text disable-output-escaping="yes"><![CDATA[>\n");
]]></xsl:text>
				</xsl:when>
			</xsl:choose>

			<xsl:text disable-output-escaping="yes"><![CDATA[
			stringX3D.append(indent).append("</]]></xsl:text>
			<xsl:value-of select="$name"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[>").append("\n"); // finish closing tag
		}
		else
		{
			stringX3D.append("/>").append("\n"); // otherwise finish singleton tag
		}]]></xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text disable-output-escaping="yes"><![CDATA[
		return stringX3D.toString();
	}
]]></xsl:text>
						</xsl:if>

						<!-- toStringClassicVRML -->
						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">
<!-- debug ($debug = 'true')-->
<xsl:if test="true()">
<xsl:text>// ($name=</xsl:text>
<xsl:value-of select="$name"/>
<xsl:text>, isX3dStatement=</xsl:text>
<xsl:value-of select="$isX3dStatement"/>
<xsl:text>, isClassX3dStatement=</xsl:text>
<xsl:value-of select="$isClassX3dStatement"/>
<xsl:text>, $hasChild=</xsl:text>
<xsl:value-of select="$hasChild"/>
<xsl:text>, $hasAttributes=</xsl:text>
<xsl:value-of select="$hasAttributes"/>
</xsl:if>

						<!-- toStringClassicVRML() encoding -->
						<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide ClassicVRML string serialization.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3D#FILE_EXTENSION_CLASSICVRML
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/X3D_ClassicVRML.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/grammar.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding, Annex A: Grammar</a>
	 * @return ClassicVRML string
	 */
	@Override
	public String toStringClassicVRML(int indentLevel)
	{
		StringBuilder stringClassicVRML = new StringBuilder();]]></xsl:text>
	<xsl:if test="not($name = 'CommentsBlock')">
		<xsl:text><![CDATA[
		boolean hasAttributes = ]]></xsl:text>
		<xsl:value-of select="$hasAttributes"/>
		<xsl:text><![CDATA[; // TODO further refinement
		boolean      hasChild = ]]></xsl:text>
		<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) or ($name = 'ProtoInstance')">
			<xsl:text>(IS != null) || </xsl:text>
		</xsl:if>

		<xsl:variable name="fieldsList" select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and
														((@accessType='initializeOnly') or (@accessType='inputOutput'))]"/>
		<xsl:for-each select="$fieldsList">
			<xsl:variable name="isX3dStatement">
				<xsl:call-template name="isX3dStatement">
					<xsl:with-param name="name" select="@name"/>
				</xsl:call-template>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="($name = 'Script')  or ($name = 'ShaderProgram')">
					<xsl:text>(!fieldList.isEmpty()) || (!sourceCode.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ComposedShader') or ($name = 'PackagedShader')">
					<xsl:text>(!fieldList.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ShaderPart')">
					<xsl:text>(!sourceCode.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ProtoInstance')">
					<xsl:text>(!fieldValueList.isEmpty()) || </xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="(@type = 'SFNode')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="@name"/>
					<xsl:text> != null)</xsl:text>
					<xsl:if test="not($isX3dStatement = 'true')">
						<xsl:text> || (</xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text>ProtoInstance != null)</xsl:text>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise><!-- (@type='MFNode') -->
					<xsl:text>(!</xsl:text>
					<xsl:value-of select="@name"/>
					<xsl:if test="($isX3dStatement = 'true')">
						<xsl:text>List</xsl:text><!-- append to member name -->
					</xsl:if>
					<xsl:text>.isEmpty())</xsl:text>
				</xsl:otherwise>
			</xsl:choose>

			<xsl:if test="(last() > position()) or not($hasChildrenField = 'true')">
				<xsl:text> || </xsl:text>
                                <xsl:text>&#10;</xsl:text>
				<xsl:text>		                        </xsl:text>
			</xsl:if>
		</xsl:for-each>
		<xsl:choose>
			<xsl:when test="not($hasChildrenField = 'true')">
				<xsl:text disable-output-escaping="yes">!commentsList.isEmpty()</xsl:text>
			</xsl:when>
			<xsl:when test="1 > count($fieldsList)">
				<xsl:text>false</xsl:text><!-- TODO account for CommentsBlock -->
			</xsl:when>
		</xsl:choose>
		<xsl:text>;</xsl:text><!-- hasChild definition complete -->
	</xsl:if>
	<xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
		if (hasUSE())
		{
			hasAttributes = false;
			hasChild      = false; // USE nodes include no other fields
		}]]></xsl:text><!-- append to member name -->
	</xsl:if>
        <!-- handle field synonyms, TODO do not perform if serializing VRML97 -->
	<xsl:text>
                if (!serializingVRML97output)
                    handleFieldSynonyms(); // adjust containerField values for X3D3 differences, if any</xsl:text>
	<xsl:if test="not((@name = 'X3D') or (@name = 'head') or (@name = 'meta') or (@name = 'unit') or (@name = 'component') or (@name = 'Scene'))">
		<!-- toDO in progress, ignore: avoid defining indentCharacter for nodes with no indentation, helps to ensure that consistent logic follows -->
	</xsl:if>
    <xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder  indent = new StringBuilder();
		char  indentCharacter = ConfigurationProperties.getIndentCharacter();
		int   indentIncrement = ConfigurationProperties.getIndentIncrement();
		for (int i = 0; i < indentLevel; i++)
			indent.append(indentCharacter); // level of indentation for this level
]]></xsl:text>

		<!-- preliminary special handling of statement names themselves, then proceed with additional content -->
		<xsl:choose>
			<xsl:when test="($name = 'X3D')">
				<!-- header needed for serialization toStringClassicVRML -->
				<xsl:text>
		stringClassicVRML.append("#X3D V") // V for version
                                 .append(version).append(" utf8").append("\n");
		stringClassicVRML.append("PROFILE").append(" ").append(profile).append("\n");
		stringClassicVRML.append("# This model file was produced using X3DJSAIL https://www.web3d.org/specifications/java/X3DJSAIL.html\n");</xsl:text>
			</xsl:when>
			<xsl:when test="(@name = 'head') or (@name = 'Scene')">
				<!-- special output provided separately by X3D, only mention name as a comment here -->
				<xsl:text>
		stringClassicVRML.append("# [</xsl:text><xsl:value-of select="@name"/><xsl:text>]").append("\n");</xsl:text>
			</xsl:when>
		</xsl:choose>
		<!-- keep these xsl:choose statements separate -->
		<xsl:choose>
			<xsl:when test="($name = 'CommentsBlock')">
				<!-- might have embedded XML comments, that is OK here -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
		for (String comment : commentsList)
		{
                    if (ConfigurationProperties.isNormalizeCommentWhitespace())
                    {
                        // https://stackoverflow.com/questions/3958955/how-to-remove-duplicate-white-spaces-in-string-using-java
                        comment = comment.replaceAll("\\s+", " ");
                    }
                    // ensure that comments with embedded line breaks have # character at start of new line
                    stringClassicVRML.append("# ").append(comment.replaceAll("\n", "\n#\t")).append("\n").append(indent);
		}]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'component')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/concepts.html#ComponentStatementSyntax
		stringClassicVRML.append("COMPONENT ").append(name).append(":").append(getLevel()).append("\n");
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'meta')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/concepts.html#METAStatementSyntax
		stringClassicVRML.append("META \"").append(name).append("\" \"").append(SFString.toStringClassicVRML(content)).append("\"").append("\n");
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'unit')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/concepts.html#UNITStatementSyntax
		stringClassicVRML.append("UNIT ").append(category).append(" ").append(name).append(" ").append(conversionFactor).append("\n");
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'ROUTE')">
				<!-- formatting note: "TO" preceded by tab character to alight consecutive ROUTE outputs, for some cases -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("ROUTE ").append(fromNode).append(".").append(fromField)
			.append(" TO ").append(toNode).append(".").append(toField).append("\n").append(indent);
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'IMPORT')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("IMPORT ");
		stringClassicVRML.append(getInlineDEF());
		if (getInlineDEF().equals(INLINEDEF_DEFAULT_VALUE))
		{
			stringClassicVRML.append("TODO_MISSING_INLINEDEF");
		}
		stringClassicVRML.append(".");
		stringClassicVRML.append(getImportedDEF());
		if (getImportedDEF().equals(IMPORTEDDEF_DEFAULT_VALUE))
		{
			stringClassicVRML.append("TODO_MISSING_IMPORTEDDEF");
		}
		if (!getAS().equals(AS_DEFAULT_VALUE))
		{
			stringClassicVRML.append(" AS ").append(SFString.toString(getAS())).append(" ");
		}
		stringClassicVRML.append("\n").append(indent);
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'EXPORT')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("EXPORT ").append(getLocalDEF());
		if (getLocalDEF().equals(LOCALDEF_DEFAULT_VALUE))
		{
			stringClassicVRML.append("TODO_MISSING_LOCALDEF");
		}
		if (!getAS().equals(AS_DEFAULT_VALUE))
		{
			stringClassicVRML.append(" AS ").append(SFString.toString(getAS())).append(" ");
		}
		stringClassicVRML.append("\n").append(indent);
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@name = 'ProtoDeclare')">
				<!-- special handling -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("PROTO ").append(name).append(" [").append("\n").append(indent);

		if (!getAppinfo().equals(APPINFO_DEFAULT_VALUE) || (!getAppinfo().isEmpty() && !ConfigurationProperties.getStripDefaultAttributes()))
		{
			stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append(" # [appinfo] ").append("\"").append(SFString.toStringClassicVRML(getAppinfo())).append("\"");
		}
		if (!getDocumentation().equals(DOCUMENTATION_DEFAULT_VALUE) || (!getDocumentation().isEmpty() && !ConfigurationProperties.getStripDefaultAttributes()))
		{
			stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append("# [documentation] ").append("\"").append(SFString.toStringClassicVRML(getDocumentation())).append("\"").append("\n").append(indent).append(indentCharacter);
		}

		// recursively iterate over child elements
		if (ProtoInterface != null)
		{
			stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append(ProtoInterface.toStringClassicVRML(indentLevel + indentIncrement));
			for (field nextField : ProtoInterface.getFieldList())
			{
				stringClassicVRML.append(nextField.toStringClassicVRML(indentLevel + indentIncrement));
			}
		}
		if (!commentsList.isEmpty())
		{
			CommentsBlock commentsBlock = new CommentsBlock(commentsList);
			stringClassicVRML.append(commentsBlock.toStringClassicVRML(indentLevel));
		}
		stringClassicVRML.append(" ] {").append("\n").append(indent);

		if (ProtoBody != null)
		{
			stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append(ProtoBody.toStringClassicVRML(indentLevel + indentIncrement));
			stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter);
			for (org.web3d.x3d.sai.Core.X3DNode element : ProtoBody.getChildren())
			{
				stringClassicVRML.append(((X3DConcreteElement) element).toStringClassicVRML(indentLevel + indentIncrement));
			}
		}
		stringClassicVRML.append("}").append("\n").append(indent);
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@name = 'ExternProtoDeclare')">
				<!-- special handling -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("EXTERNPROTO ").append(name).append(" [").append("\n").append(indent);

		if (!getAppinfo().equals(APPINFO_DEFAULT_VALUE) || (!getAppinfo().isEmpty() && !ConfigurationProperties.getStripDefaultAttributes()))
		{
			stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append(" # [appinfo] ").append("\"").append(SFString.toStringClassicVRML(getAppinfo()).replaceAll("\"","\\\"")).append("\"");
		}
		if (!getDocumentation().equals(DOCUMENTATION_DEFAULT_VALUE) || (!getDocumentation().isEmpty() && !ConfigurationProperties.getStripDefaultAttributes()))
		{
			stringClassicVRML.append("\n").append(indent).append(indentCharacter);
			stringClassicVRML.append("# [documentation] ").append("\"").append(SFString.toStringClassicVRML(getDocumentation())).append("\"").append("\n").append(indent).append(indentCharacter);
		}

		// recursively iterate over child elements
		for (field element : fieldList)
		{
			stringClassicVRML.append(((X3DConcreteElement)element).toStringClassicVRML(indentLevel));
		}
                stringClassicVRML.append("\n");
		if (!commentsList.isEmpty())
		{
			CommentsBlock commentsBlock = new CommentsBlock(commentsList);
			stringClassicVRML.append(commentsBlock.toStringClassicVRML(indentLevel));
		}
		stringClassicVRML.append("]").append("\n").append(indent);

		if (getUrl().length > 0)
		{
		//	stringClassicVRML.append("\n").append(indent).append(indentCharacter);
		//	stringClassicVRML.append("url "); // explicit 'url' is not included in ClassicVRML syntax for EXTERNPROTO
                //	https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/concepts.html#EXTERNPROTOURLSemantics
                        MFString urlMFString = new MFString(getUrl());
			stringClassicVRML.append(" [ ").append(urlMFString.toStringClassicVRML()).append(" ]"); // may add line breaks for readability
                        stringClassicVRML.append(" # ExternProtoDeclare url complete").append("\n").append("\n");
                        for (int i = 0; i < (indentLevel + indentIncrement); i++)
                            stringClassicVRML.append(indentCharacter); // level of indentation for this level
		}]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@name = 'ProtoInterface') or (@name = 'ProtoBody')">
				<!-- special output provided separately by ProtoDeclare, only mention name as a comment here -->
				<xsl:text>
		stringClassicVRML.append("# </xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
			</xsl:when>
			<xsl:otherwise>
			<!-- DEF, USE, name attributes first for readability and to match X3D Canonical Form -->
			<xsl:if test="InterfaceDefinition/field[@name = 'DEF']">
				<xsl:text>
		if (!getDEF().equals(DEF_DEFAULT_VALUE))
		{
			stringClassicVRML.append("DEF ").append(SFString.toString(getDEF())).append(" ");
		}</xsl:text>
			</xsl:if>
			<xsl:if test="InterfaceDefinition/field[@name = 'USE']">
				<xsl:text>
		if (!getUSE().equals(USE_DEFAULT_VALUE))
		{
			 stringClassicVRML.append("USE ").append(SFString.toString(getUSE())).append("\n");
		}
		else // only have further output if not a USE node
		{</xsl:text>
				<!-- all done with this USE node -->
			</xsl:if>
			<xsl:choose>
				<xsl:when test="($name = 'ProtoInstance')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
			if (getName().isEmpty())
				 stringClassicVRML.append("NoNameFoundError");
			else stringClassicVRML.append(getName());
			stringClassicVRML.append(" { "); // define ProtoInstance node name, fieldValue content follows
]]></xsl:text>
				</xsl:when>
				<xsl:when test="not($isX3dStatement = 'true')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
			stringClassicVRML.append("]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[").append(" { "); // define node name, node content follows
]]></xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:if test="not($isX3dStatement = 'true') and not($name = 'Script')">
				<xsl:text>
			if (hasAttributes || hasChild)
			{</xsl:text>
				<xsl:text>
				stringClassicVRML.append("\n")</xsl:text>
			<xsl:text>.append(indent).append(indentCharacter); // fields for this node follow</xsl:text>
			<xsl:text>
			}</xsl:text>
			</xsl:if>

			<xsl:if test="($name = 'fieldValue')">
				<xsl:text>
		// fieldValue type is figured out using ProtoDeclare/ExternProtoDeclare field getType()</xsl:text>
			</xsl:if>
			<xsl:choose>
				<!-- special handling -->
				<xsl:when test="($name = 'connect')">
                                    <!-- no output here, IS/connect handled following field definiton in ClassicVRML encoding -->
                                </xsl:when>
				<!-- special handling -->
				<xsl:when test="($name = 'field') or ($name = 'fieldValue')">
					<xsl:text>
		// </xsl:text>
		<xsl:value-of select="$name"/>
					<xsl:text> definition
		stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter)</xsl:text>
					<xsl:if test="($name = 'field')">
						<xsl:text disable-output-escaping="yes">.append(accessType).append(" ").append(type).append(" ")</xsl:text>
					</xsl:if>
					<!-- getType() defined for both field and fieldValue -->
					<xsl:text disable-output-escaping="yes"><![CDATA[.append(name);
                String  parentName   = "fieldParentNotKnown"; // default value, just in case the follow-on determination is unsuccessful
                boolean hasISconnect = false;
                IS      parentIS     = null;

                if ((getParent() !=  null) && (getParent() instanceof X3DConcreteNode))
                {
                        parentName   = ((X3DConcreteNode)getParent()).getElementName();
                        parentIS     = ((X3DConcreteNode)getParent()).getIS();
                        hasISconnect = false;
                        if (parentIS != null)
                          for (connect element : parentIS.getConnectList())
                          {
                            if (element.getNodeField().equals(name))
                            {
                                hasISconnect = true;
                                break;
                            }
                          }
                }
                else if ((getParent() !=  null) && (getParent() instanceof X3DConcreteStatement))
                          parentName = ((X3DConcreteStatement)getParent()).getElementName();

                // first case: field IS/connect
                if (hasISconnect)
                {
                    if (parentIS != null)
                      for (connect element : parentIS.getConnectList())
                      {
                        if (element.getNodeField().equals(name))
                        {
                            stringClassicVRML.append(indentCharacter).append("IS").append(indentCharacter).append(element.getProtoField()); // found matching connect
                        }
                      }
                }
                // additional case: default value, if any is provided
		else if (((getValue().length() > 0) || getType().startsWith("MF") || getType().equals(field.TYPE_SFSTRING)) &&
                        !parentName.equals(ExternProtoDeclare.NAME) && !hasISconnect]]></xsl:text>
                                    <xsl:if test="($name = 'field')">
                                        <xsl:text disable-output-escaping="yes"><![CDATA[ &&
                         (getAccessType().equals(ACCESSTYPE_INITIALIZEONLY) || getAccessType().equals(ACCESSTYPE_INPUTOUTPUT))]]></xsl:text>
                                    </xsl:if>
                                    <xsl:text disable-output-escaping="yes"><![CDATA[)
		{
                    // no value for EXTERNPROTODECLARE fields since default values are found in the original prototype
                    stringClassicVRML.append(" ");
                    if (getType().equals(field.TYPE_SFBOOL) &&
                             (getValue().equalsIgnoreCase("true") || getValue().equalsIgnoreCase("false")))
                    {
                        stringClassicVRML.append(getValue().toUpperCase()).append("\n"); // .append(" ### trace field initialization value #1")
                        for (int i = 0; i < (indentLevel + indentIncrement); i++)
                            stringClassicVRML.append(indentCharacter); // level of indentation for this level
                    }
                    else if (getType().equals(field.TYPE_MFBOOL))
                    {
                        String capitalizedValue = getValueMFBool().toStringClassicVRML();
                        stringClassicVRML.append("[ ").append(capitalizedValue).append(" ]").append("\n"); // .append(" ### trace field initialization value #2")
                        for (int i = 0; i < (indentLevel + indentIncrement); i++)
                            stringClassicVRML.append(indentCharacter); // level of indentation for this level
                    }
                    else if (getType().equals(field.TYPE_SFSTRING))
                    {
                         stringClassicVRML.append("\"").append(SFString.toStringClassicVRML(getValue())).append("\""); // might be empty string
                    }
//                  else if (getType().equals(field.TYPE_MFSTRING))
//                  // problematic, TODO requires parsing to separate individual strings in array and then individual escaping
//                  {
//                       stringClassicVRML.append("[ ").append(MFString.toStringClassicVRML(getValue())).append(" ]"); // might be empty array
//                  }
                    else if (getType().startsWith("MF") && !getType().equals(field.TYPE_MFNODE))
                    {
                        stringClassicVRML.append("[ ").append(getValue()).append(" ]"); // .append(" ### trace field initialization value #3")
                    }
                    else if (getValue().length() > 0)
                    {
                        stringClassicVRML.append(getValue().replaceAll("\"","\\\"")); // .append(" ### trace field initialization value #4")
                    }
		}
                else if (parentName.equals(ExternProtoDeclare.NAME))
                {
                    // no initialization value provided within ExternProtoDeclare
                }
                else if (getValue().length() > 0)
                {
                    stringClassicVRML.append(getValue()); // .append(" ### trace field initialization value #5")
                }
                if (getType().equals(field.TYPE_SFNODE) && !hasChildrenElements() &&
                    !parentName.equals(ExternProtoDeclare.NAME) && !hasISconnect &&
                    (getAccessType().equals(field.ACCESSTYPE_INITIALIZEONLY) ||
                     getAccessType().equals(field.ACCESSTYPE_INPUTOUTPUT)))
                {
                    stringClassicVRML.append(" ").append("NULL # no initialization node provided").append("\n");
                    for (int i = 0; i < (indentLevel + indentIncrement); i++)
                        stringClassicVRML.append(indentCharacter); // level of indentation for this level
                }
                // see below
//                 else if ((getType().equals(field.TYPE_SFNODE)) && hasChildrenElements())
//                 {
//                     for (int i = 0; i < getChildren().size(); i++) // expecting one element plus optional comments
//                     {
//                         stringClassicVRML.append(" ").append(((X3DConcreteElement)getChildren().get(i)).toStringClassicVRML(indentLevel));
//                     }
//                 }
                else if (getType().equals(field.TYPE_MFNODE) && !parentName.endsWith(ExternProtoDeclare.NAME) &&
                         !hasISconnect &&
                         (getAccessType().equals(field.ACCESSTYPE_INITIALIZEONLY) ||
                          getAccessType().equals(field.ACCESSTYPE_INPUTOUTPUT))) // && hasChildrenElements()
                {
                    // TODO check containerField matches?
                    // recursively iterate over child elements
                    stringClassicVRML.append(" [ ");
                    for (X3DNode element : getChildren())
                    {
                            stringClassicVRML.append(" ").append(((X3DConcreteElement)element).toStringClassicVRML(indentLevel));
                    }
                    stringClassicVRML.append(" ]").append("\n"); // .append(" ### trace field initialization value #6")
                    for (int i = 0; i < (indentLevel + indentIncrement); i++)
                        stringClassicVRML.append(indentCharacter); // level of indentation for this level
                }
                // TODO possible additional case: default value for this type, if none is provided by field in Script/ProtoInterface
                //      perhaps best to let that ambiguous case fail, so that author initialization intent is explicitly declared
]]></xsl:text>
					<xsl:if test="($name = 'field')">
						<!-- append field [appinfo], add field [documentation] -->
						<xsl:text disable-output-escaping="yes"><![CDATA[
		if (!getAppinfo().equals(APPINFO_DEFAULT_VALUE) || (!getAppinfo().isEmpty() && !ConfigurationProperties.getStripDefaultAttributes()))
		{
                    stringClassicVRML.append(" # [appinfo] ").append("\"").append(SFString.toStringClassicVRML(getAppinfo()).replaceAll("\"","\\\"")).append("\"").append("\n").append(indent);
		}
		if (!getDocumentation().equals(DOCUMENTATION_DEFAULT_VALUE) || (!getDocumentation().isEmpty() && !ConfigurationProperties.getStripDefaultAttributes()))
		{
                    stringClassicVRML.append("# [documentation] ").append("\"").append(SFString.toStringClassicVRML(getDocumentation())).append("\"").append("\n").append(indent);
		}]]></xsl:text>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
			<xsl:text>
			if (hasAttributes)
			{</xsl:text>
			<xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
				boolean hasISconnect = (getIS() != null) && !getIS().getConnectList().isEmpty();]]></xsl:text>
			</xsl:if>

			<xsl:for-each select="InterfaceDefinition/field[not(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and not(@name = 'DEF') and not(@name = 'USE') and not(@name = 'sourceCode') and
                                                            ((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
				<!-- alphabetic order of attributes is essential for X3D canonical form (C14N) -->
				<xsl:sort select="@name" order="ascending"/>

                                <xsl:variable name="fieldName" select="translate(@name,'-','_')"/><!-- handle http-equiv etc. -->
				<xsl:variable name="isSingleValueType">
					<xsl:value-of select="starts-with(@type,'SF') and not(contains(@type, 'Vec')) and not(contains(@type, 'Rotation')) and not(contains(@type, 'Color')) and not(contains(@type, 'Matrix'))"/>
				</xsl:variable>
				<xsl:variable name="CamelCaseName"><!-- upper camel case -->
					<xsl:choose>
						<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
							<!-- unmodified -->
							<xsl:value-of select="@name"/>
						</xsl:when>
                        <xsl:when test="(@name = 'id')">
                            <!-- similarly named for clarity, consistency -->
							<xsl:text>HtmlID</xsl:text>
                        </xsl:when>
						<xsl:when test="(@name = 'class')">
							<!-- getClass() is reserved by Java() class -->
							<xsl:text>CssClass</xsl:text>
						</xsl:when>
						<xsl:when test="(@name = 'style') and not(contains($name, 'FontStyle'))">
							<!-- similarly named for clarity, consistency -->
							<xsl:text>CssStyle</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="translate(substring($fieldName,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
							<xsl:value-of select="substring($fieldName,2)"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="javaType">
					<xsl:call-template name="javaType">
						<xsl:with-param name="x3dType" select="@type"/>
						<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
					</xsl:call-template>
				</xsl:variable>
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
<xsl:text>// ($fieldName=</xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:text>, CamelCaseName=</xsl:text>
<xsl:value-of select="$CamelCaseName"/>
<xsl:text>, javaType=</xsl:text>
<xsl:value-of select="$javaType"/>
<xsl:text>, isSingleValueType=</xsl:text>
<xsl:value-of select="$isSingleValueType"/>
<xsl:text>)</xsl:text>
</xsl:message>
</xsl:if>
				<xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock') and not($name = 'ProtoInstance')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
				if (hasISconnect)
				{
					for (connect element : getIS().getConnectList())
					{
						if (element.getNodeField().equals("]]></xsl:text><xsl:value-of select="@name"/><xsl:text><![CDATA["))
						{
							stringClassicVRML.append(indentCharacter).append("]]></xsl:text>
							<xsl:value-of select="@name"/>
							<xsl:text>").append(" IS ").append(element.getProtoField()).append("\n").append(indent).append(indentCharacter); // found matching connect
						}
					}
				}
				else </xsl:text>
				</xsl:if>
				<xsl:text>
				if (</xsl:text>
				<xsl:choose>
					<!-- avoided attributes -->
					<xsl:when test="($name = 'X3D')">
						<xsl:text><![CDATA[false) // attribute handled separately]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'ProtoInstance') and ($fieldName = 'name')">
						<xsl:text><![CDATA[false) // attribute handled separately]]></xsl:text>
					</xsl:when>
					<!-- required attributes -->
					<xsl:when test="(($name = 'X3D') and (($fieldName = 'profile') or ($fieldName = 'version'))) or
									(($name = 'HAnimHumanoid') and ($fieldName = 'version')) or
									(($name = 'component')     and ($fieldName = 'level')) or
									(($name = 'unit')          and ($fieldName = 'conversionFactor'))">
						<xsl:text><![CDATA[true) /* required attribute */ ]]></xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
						<xsl:text><![CDATA[(get]]></xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text disable-output-escaping="yes"><![CDATA[() != ]]></xsl:text>
						<xsl:value-of select="upper-case($fieldName)"/>
						<xsl:text><![CDATA[_DEFAULT_VALUE) || !ConfigurationProperties.getStripDefaultAttributes())]]></xsl:text>
					</xsl:when>
					<xsl:when test="contains($javaType, 'ArrayList')">
                                            <xsl:text><![CDATA[((get]]></xsl:text>
                                            <xsl:value-of select="$CamelCaseName"/>
                                            <xsl:text disable-output-escaping="yes"><![CDATA[().length > 0) && !get]]></xsl:text>
                                            <xsl:value-of select="$CamelCaseName"/>
                                            <xsl:text disable-output-escaping="yes"><![CDATA[List().equals(]]></xsl:text>
                                            <xsl:value-of select="upper-case($fieldName)"/>
                                            <xsl:text disable-output-escaping="yes"><![CDATA[_DEFAULT_VALUE)) || !ConfigurationProperties.getStripDefaultAttributes()) /* ArrayList .x3dv compare */]]></xsl:text>
					</xsl:when>
					<xsl:when test="($isSingleValueType = 'true')">
						<xsl:text><![CDATA[!get]]></xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text><![CDATA[().equals(]]></xsl:text>
						<xsl:value-of select="upper-case($fieldName)"/>
						<xsl:text><![CDATA[_DEFAULT_VALUE) || !ConfigurationProperties.getStripDefaultAttributes())]]></xsl:text>
					</xsl:when>
					<xsl:when test="(string-length(@default) > 0)">
						<xsl:text><![CDATA[!Arrays.equals(get]]></xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text><![CDATA[(), ]]></xsl:text>
						<xsl:value-of select="upper-case($fieldName)"/>
						<xsl:text><![CDATA[_DEFAULT_VALUE) || !ConfigurationProperties.getStripDefaultAttributes())]]></xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text><![CDATA[(get]]></xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text>().length</xsl:text>
                                                <xsl:if test="($javaType = 'String')">
                                                    <xsl:text>()</xsl:text>
                                                </xsl:if>
						<xsl:text disable-output-escaping="yes"><![CDATA[ > 0) || !ConfigurationProperties.getStripDefaultAttributes())]]></xsl:text>
					</xsl:otherwise>
				</xsl:choose>

				<!-- output simple-field value -->
				<xsl:text><![CDATA[
				{
					stringClassicVRML]]></xsl:text>
				<xsl:text><![CDATA[.append("]]></xsl:text>
				<!-- unsupported attributes, style and class -->
				<xsl:if test="(@name = 'id') or (@name = 'class')">
					<xsl:text> # </xsl:text>
				</xsl:if>
				<xsl:if test="(@name = 'style') and not(ends-with($thisClassName, 'FontStyle'))">
					<xsl:text> # </xsl:text>
				</xsl:if>
				<xsl:value-of select="$fieldName"/>
				<xsl:text> ")</xsl:text>
				<xsl:choose>
					<xsl:when test="(@type = 'SFString')">
						<xsl:text>.append("\"")</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with(@type, 'MF')">
						<xsl:text>.append("[ ")</xsl:text>
					</xsl:when>
				</xsl:choose>
				<xsl:text>.append(</xsl:text>
                                <xsl:choose>
                                    <xsl:when test="(@type = 'xs:NMTOKEN')">
                                        <xsl:text>SFString</xsl:text>
                                    </xsl:when>
                                    <xsl:when test="(@type = 'xs:NMTOKENS')">
                                        <xsl:text>MFString</xsl:text>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="@type"/>
                                    </xsl:otherwise>
                                </xsl:choose>
				<xsl:value-of select="$jsaiClassSuffix"/>
				<xsl:text>.toString</xsl:text>
                                <xsl:choose>
                                    <xsl:when test="ends-with(@type,'FBool')">
                                        <xsl:text>ClassicVRML</xsl:text>
                                    </xsl:when>
                                </xsl:choose>
				<xsl:text>(get</xsl:text>
				<xsl:value-of select="$CamelCaseName"/>
				<xsl:text>()))</xsl:text>
				<xsl:choose>
					<xsl:when test="(@type = 'SFString')">
						<xsl:text>.append("\"")</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with(@type, 'MF')">
						<xsl:text>.append(" ]")</xsl:text>
					</xsl:when>
				</xsl:choose>
				<xsl:text>.append("\n")</xsl:text>
				<xsl:if test="not($isX3dStatement = 'true')">
					<xsl:text><![CDATA[.append(indent).append(indentCharacter)]]></xsl:text>
				</xsl:if>
				<xsl:text>;
				}</xsl:text>
			</xsl:for-each>

						<xsl:text disable-output-escaping="yes"><![CDATA[
			}]]></xsl:text>
						<xsl:if test="InterfaceDefinition/field[@name = 'USE']">
							<xsl:text>
		}</xsl:text>
						</xsl:if> <!-- end hasAttributes -->
					</xsl:otherwise>
				</xsl:choose>

				<xsl:text disable-output-escaping="yes"><![CDATA[
		if (hasChild) // has contained node(s) (including USE), comment(s), IS/connect and/or source code
		{]]></xsl:text>
                                <xsl:if test="($name = 'field') or ($name = 'fieldValue')"> <!-- -->
                                    <xsl:text disable-output-escaping="yes"><![CDATA[
                        if ((getType().equals(field.TYPE_SFNODE) && hasChildren()) ||
                            (hasChildren() && !hasChildrenElements())) // second case: comments only, no children nodes or statements
			{
                            for (org.web3d.x3d.sai.Core.X3DNode element : children) // children might include comment statements
                            {
                                stringClassicVRML.append(indentCharacter).append(((X3DConcreteElement) element).toStringClassicVRML(indentLevel + indentIncrement + indentIncrement)).append("\n");
                            }
                            stringClassicVRML.append(" ### trace field initialization value #7").append("\n"); //
//                          for (int i = 0; i < (indentLevel + indentIncrement); i++)
//                              stringClassicVRML.append(indentCharacter); // level of indentation for this level
                        }]]></xsl:text>
                            </xsl:if>
                            <xsl:if test="($name = 'field')">
                                <xsl:text>
                        else </xsl:text>
                                <xsl:text>&#10;</xsl:text>
                            </xsl:if>
                            <xsl:if test="not($name = 'fieldValue')">
                                <xsl:text>
                        // recursively iterate over child element</xsl:text>
                                <xsl:if test="InterfaceDefinition/field[(@type = 'MFNode')] or
                                           (count(InterfaceDefinition/field[contains(@type,'FNode')]) > 1)">
                                        <xsl:text>s</xsl:text>
                                </xsl:if>
                                <xsl:text>&#10;</xsl:text><!-- indent -->

			<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and
									((@accessType='initializeOnly') or (@accessType='inputOutput')) and
                                                                        not(@name = 'meta')]">
				<!-- order is essential for elements, note that xsl:sort results in reverse order -->
				<!-- sort by statement/field @name, all other child nodes last -->
				<xsl:sort select="@name[not((. = 'Scene') or (. = 'head') or (. = 'meta') or (. = 'unit') or (. = 'component') or
                                                            (. = 'ProtoBody') or (. = 'ProtoInterface') or (. = 'IS') or (. = 'field') or (. = 'fieldValue') or
                                                            (. = 'children') or (. = 'proxy') or (. = 'metadata'))]"/>
				<!-- sort head before Scene in X3D -->
				<xsl:sort select="(@name = 'Scene')"/>
				<xsl:sort select="(@name = 'head')"/>
				<!-- special order within head elements: component, unit, meta -->
				<xsl:sort select="(@name = 'meta')"/>
				<xsl:sort select="(@name = 'unit')"/>
				<xsl:sort select="(@name = 'component')"/>
				<!-- sort ProtoInterface before ProtoBody in ProtoDeclare -->
				<xsl:sort select="(@name = 'ProtoBody')"/>
				<xsl:sort select="(@name = 'ProtoInterface')"/>
				<!-- necessary order for model validation: field/IS/metadata before all other nodes/statements -->
				<!-- sort order field, fieldValue, IS, metadata in ProtoInstance, Script, others -->
                                <!-- note reverse order since each sort is applied after the preceding sort -->
				<xsl:sort select="(@name = 'IS')"/>
				<xsl:sort select="(@name = 'field')"/>
				<xsl:sort select="(@name = 'fieldValue')"/>
                                <!-- adjust child ordering: Collision proxy field may have DEF geometry that gets USEd in children -->
                                <xsl:sort select="(@name = 'children')"/>
                                <xsl:sort select="(@name = 'proxy')"/>
                                <xsl:sort select="(@name = 'metadata')"/>

				<xsl:variable name="javaType">
                                    <xsl:call-template name="javaType">
                                        <xsl:with-param name="x3dType" select="@type"/>
                                        <xsl:with-param name="isInterface" select="$isInterface"/>
                                    </xsl:call-template>
				</xsl:variable>
				<xsl:variable name="javaReferenceType"><!-- base type of ArrayList -->
                    <xsl:choose>
                        <xsl:when test="(@type = 'MFNode') and not($isX3dStatement = 'true') and not(@name = 'field') and not(@name = 'fieldValue')"><!-- (contains($javaType,'Object') or (@acceptableNodeTypes = 'X3DMetadataObject')) and not(contains($javaType,'X3DMetadataObject')) and -->
                            <xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
                        </xsl:when>
                        <xsl:when test="contains($javaType,'&lt;')">
                            <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$javaType"/>
                        </xsl:otherwise>
                    </xsl:choose>
                                </xsl:variable>
				<xsl:variable name="isFieldX3dStatement">
					<xsl:call-template name="isX3dStatement">
						<xsl:with-param name="name" select="@name"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="isX3dStatement">
					<xsl:call-template name="isX3dStatement">
						<xsl:with-param name="name" select="@name"/>
					</xsl:call-template>
				</xsl:variable>

				<xsl:choose>
					<xsl:when test="(@type = 'X3D') or (@type = 'head')">
						<!-- already handled -->
					</xsl:when>
					<xsl:when test="(@type = 'SFNode')">
						<xsl:text><![CDATA[
			if (]]></xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text><![CDATA[ != null)
			{]]></xsl:text>
						<xsl:if test="not($isX3dStatement = 'true')">
							<!-- TODO containerField name alternatives -->
							<xsl:text><![CDATA[
				stringClassicVRML.append(indentCharacter).append("]]></xsl:text>
							<xsl:value-of select="@name"/>
							<xsl:text>").append(" "); // containerField for SFNode</xsl:text><!-- watch out for CommentsBlock or ROUTE -->
						</xsl:if>
						<!-- cast abstract element to concrete type -->
						<xsl:text>
				stringClassicVRML.append(((X3DConcreteElement) </xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:choose>
							<xsl:when test="not($isX3dStatement = 'true')">
								<xsl:text>).toStringClassicVRML(indentLevel + indentIncrement));
				stringClassicVRML.append(indent); // end SFNode</xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text>).toStringClassicVRML(indentLevel)); // end X3D statement</xsl:text>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:text>
			}</xsl:text>
						<xsl:if test="not($isX3dStatement = 'true') and not(@name = 'IS')"><!-- output ProtoInstance -->
							<xsl:text>
			else if (</xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text><![CDATA[ProtoInstance != null)
			{
				stringClassicVRML.append(indentCharacter).append("]]></xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text>").append(" "); // containerField for SFNode</xsl:text><!-- watch out for CommentsBlock or ROUTE -->
						<!-- cast abstract element to concrete type, output ProtoInstance alternative (if present) -->
						<xsl:text>
				stringClassicVRML.append(((X3DConcreteElement) </xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text>ProtoInstance).toStringClassicVRML(indentLevel + indentIncrement));
				stringClassicVRML.append(indent); // end SFNode ProtoInstance
			}</xsl:text>
						</xsl:if>

                                                <xsl:if test="($name='HAnimHumanoid') and (@name='metadata')"><!-- immediately follow metadata, IS -->
                                    <xsl:text>
			// special case for HAnimHumanoid: output skeleton field prior to any of corresponding USE MFNode arrays
			if (!skeleton.isEmpty())
			{
                            stringClassicVRML.append(indentCharacter).append(indentCharacter).append("skeleton").append(" [").append("\n")
                                             .append(indent).append(indentCharacter).append(indentCharacter); // containerField for MFNode array
                            for (org.web3d.x3d.sai.Core.X3DNode element : skeleton)
                            {
				stringClassicVRML.append(((X3DConcreteElement)element).toStringClassicVRML(indentLevel + indentIncrement + indentIncrement));
                            }
                            stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter).append("]").append("\n")
				.append(indent); // end MFNode array
			}</xsl:text>
                                </xsl:if>
					</xsl:when>
					<xsl:otherwise> <!-- MFNode -->
                                            <xsl:if test="not(($name='HAnimHumanoid') and (@name='skeleton'))"><!-- avoid duplication of special case -->
                                                <xsl:choose>
							<xsl:when test="not($isX3dStatement = 'true') and not(@name = 'ROUTE') and not(@name = 'fieldValue')">
								<xsl:text>
			if (!</xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
									<xsl:text>List</xsl:text><!-- append to member name -->
								</xsl:if>
								 <xsl:text disable-output-escaping="yes"><![CDATA[.isEmpty())
			{]]></xsl:text>
                                                                <xsl:if test="not($name = 'Scene')">
                                                                    <!-- note no field name precedes root nodes at top level of Scene -->
                                                                    <xsl:text disable-output-escaping="yes"><![CDATA[
				stringClassicVRML.append(indentCharacter).append(indentCharacter).append("]]></xsl:text>
                                                                    <!-- TODO containerField name alternatives -->
                                                                    <xsl:value-of select="@name"/>
                                                                    <xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
									<xsl:text>List</xsl:text><!-- append to member name -->
                                                                    </xsl:if>
                                                                    <xsl:text>").append(" [").append("\n")
					.append(indent).append(indentCharacter).append(indentCharacter); // containerField for MFNode array</xsl:text>
                                                                </xsl:if>
							</xsl:when>
							<xsl:otherwise>
                                                            <!-- empty -->
							</xsl:otherwise>
						</xsl:choose>
						<xsl:text>
                            for (</xsl:text>
						<xsl:value-of select="$javaReferenceType"/>
						<xsl:text> element : </xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<xsl:text>)
                            {</xsl:text>
						<!-- cast abstract element to concrete type -->
						<xsl:text>
				stringClassicVRML.append(((X3DConcreteElement</xsl:text>
						<xsl:choose>
							<xsl:when test="not($isX3dStatement = 'true') or (@name = 'ROUTE') or (@name = 'IMPORT') or (@name = 'EXPORT')">
								<xsl:text><![CDATA[)element).toStringClassicVRML(indentLevel + indentIncrement + indentIncrement))]]></xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text><![CDATA[)element).toStringClassicVRML(indentLevel))]]></xsl:text>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:text>;</xsl:text>

						<xsl:if test="not((@name = 'X3D') or (@name = 'head'))">
							<xsl:text>
                            }</xsl:text>
						</xsl:if>
                                                <xsl:choose>
                                                    <xsl:when test="($name = 'Scene')">
                                                        <!-- note no field name precedes root nodes at top level of Scene, so no closing ] square bracket at end -->
							<xsl:text>
			}</xsl:text>
                                                    </xsl:when>
                                                    <xsl:when test="not($isX3dStatement = 'true') or (@name = 'ROUTE') or (@name = 'IMPORT') or (@name = 'EXPORT')">
							<xsl:text>
                            stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter).append("]").append("\n")
				.append(indent); // end MFNode array
			}</xsl:text>
                                                    </xsl:when>
                                                </xsl:choose>
                                            </xsl:if>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
			<xsl:text>stringClassicVRML.append("\n").append(indent).append("\n"); // .append(" ### trace field initialization value #8")
</xsl:text>
                    </xsl:if>
			<!-- TODO confirm: IS handled per field
			<xsl:if test="($name = 'ProtoInstance')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			if (getIS() != null)
				stringClassicVRML.append(getIS().toStringClassicVRML(indentLevel + indentIncrement)); // IS follows fieldValue definitions]]></xsl:text>
			</xsl:if>
			-->

			<xsl:if test="($name = 'head')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			// note required order of component, unit, meta (though relaxation of this requirement has been proposed)
			for (meta element : metaList)
			{
				 stringClassicVRML.append(element.toStringClassicVRML(indentLevel));
			}
]]></xsl:text>
			</xsl:if>

			<!-- special handling -->
			<xsl:choose>
				<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram')">
<!--

                    for (field element : fieldList)
                    {
                        stringClassicVRML.append(element.toStringClassicVRML(indentLevel + indentIncrement));
                    }
-->
					<xsl:text disable-output-escaping="yes"><![CDATA[
			if (sourceCode.trim().length() > 0)
			{
				String trimmedSource = SFString.toStringClassicVRML(sourceCode.trim()); // escape " characters
                                // note ecmascript source code overloading of url field in ClassicVRML/VRML97 syntax
				stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter)
					.append("url [ \"").append(trimmedSource).append("\n").append("\" ]").append("\n");
			}
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ComposedShader') or ($name = 'PackagedShader')">
<!--
					<xsl:text disable-output-escaping="yes"><![CDATA[

			for (field element : fieldList)
			{
				stringClassicVRML.append(element.toStringClassicVRML(indentLevel + indentIncrement));
			}
]]></xsl:text>
-->
				</xsl:when>
				<xsl:when test="($name = 'ShaderPart')">
					<xsl:text disable-output-escaping="yes"><![CDATA[

			if (sourceCode.trim().length() > 0)
			{
				String trimmedSource = sourceCode; // workaround, TODO fix BS Contact bug with leading whitespace
				stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter)
					.append("url [ \"").append(sourceCode).append("\n").append("\" ]").append("\n");
			}
]]></xsl:text>
				</xsl:when>
			</xsl:choose>

			<xsl:if test="(not($hasChildrenField = 'true') and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
						   not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not($name = 'CADPart'))">
				<xsl:text><![CDATA[
			if (!commentsList.isEmpty())
			{
				CommentsBlock commentsBlock = new CommentsBlock(commentsList);]]></xsl:text>
				<xsl:choose>
					<xsl:when test="not($isX3dStatement = 'true')">
						<xsl:text>
				stringClassicVRML.append(commentsBlock.toStringClassicVRML(indentLevel));
				stringClassicVRML.append(indent); // end SFNode
			}</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>
				stringClassicVRML.append(commentsBlock.toStringClassicVRML(indentLevel));
			}</xsl:text>

					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>

			<xsl:text disable-output-escaping="yes"><![CDATA[
		}]]></xsl:text>
			<xsl:if test="not($isX3dStatement = 'true')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		if (getUSE().isEmpty() && (hasAttributes || hasChild))
		{
			stringClassicVRML.append("}").append("\n"); // finish node content
		}]]></xsl:text>
			</xsl:if>
			</xsl:otherwise>
		</xsl:choose>

		<xsl:if test="($name = 'ProtoInstance')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
                if (getUSE().isEmpty())
                    stringClassicVRML.append(indent).append("}").append("\n"); // finish closing tag]]></xsl:text>
		</xsl:if>

		<xsl:text disable-output-escaping="yes"><![CDATA[
		return stringClassicVRML.toString();
	}
]]></xsl:text>
						</xsl:if>

						<!-- toStringVRML97() -->
						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">
							<xsl:text disable-output-escaping="yes"><![CDATA[

    private boolean serializingVRML97output = false; // whether to avoid handling field name synonyms

	/**
	 * Recursive method to provide VRML97 string serialization.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3D#FILE_EXTENSION_VRML97
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/14772/V2.0/index.html">Virtual Reality Modeling Language (VRML) 97 specification</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/14772-1/V2.1/index.html">VRML 97 v2.1 Amendment</a>
	 * @return VRML97 string
	 */
	@Override
	public String toStringVRML97(int indentLevel)
	{
            serializingVRML97output = true;
            String result = toStringClassicVRML(indentLevel);
            serializingVRML97output = false;

            return result]]></xsl:text>
	<xsl:choose>
		<xsl:when test="($name = 'X3D')">
			<!-- TODO fix this hack more thoroughly, possibly via ConfigurationProperties or else by optional parameter in method signature -->
			<xsl:text>
		.replace("#X3D V4.0 utf8","#VRML V2.0 utf8")
		.replace("#X3D V3.3 utf8","#VRML V2.0 utf8")
		.replace("#X3D V3.2 utf8","#VRML V2.0 utf8")
		.replace("#X3D V3.1 utf8","#VRML V2.0 utf8")
		.replace("#X3D V3.0 utf8","#VRML V2.0 utf8")
		.replaceAll("PROFILE ","#PROFILE ")
		.replaceAll("COMPONENT ","#COMPONENT ")
		.replaceAll("META ","#META ")
		.replaceAll("UNIT ","#UNIT "); // hide unavailable X3D features</xsl:text>
		</xsl:when>
		<xsl:when test="($name = 'component')">
			<xsl:text>.replaceAll("COMPONENT ","#COMPONENT "); // hide unavailable X3D feature</xsl:text>
		</xsl:when>
		<xsl:when test="($name = 'meta')">
			<xsl:text>.replaceAll("META ","#META "); // hide unavailable X3D feature</xsl:text>
		</xsl:when>
		<xsl:when test="($name = 'component')">
			<xsl:text>.replaceAll("UNIT ","#UNIT "); // hide unavailable X3D feature</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>;</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text disable-output-escaping="yes"><![CDATA[
	}
]]></xsl:text>
						</xsl:if>

						<!-- Scene includes nodes with DEF -->
						<!-- getNodeByDEF()
						<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock') and not(starts-with($thisClassName, 'X3DConcrete'))) or
									  ($name = 'ProtoBody') or ($name = 'ProtoInstance') or ($name = 'Scene')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide object reference to node by DEF name, if found as this node or in a contained node.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorScene() to check entire scene graph, or findAncestorX3D() to check entire model document.
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3D()
	 * @see #findElementByNameValue(String,String)
	 * @param DEFlabel DEF name of node to find
	 * @return object reference to node
	 */]]></xsl:text>
							<xsl:if test="not($name = 'Scene') and not($name = 'ProtoBody')">
								<xsl:text>
	/* @Override */</xsl:text>
							</xsl:if>
								<xsl:text>
	public X3DConcreteNode getNodeByDEF(String DEFlabel)
	{
		X3DConcreteNode referenceNode;
</xsl:text>
							<xsl:if test="not($name = 'Scene') and not($name = 'ProtoBody')">
								<xsl:text>
		if (getDEF().equals(DEFlabel))
			return this;
</xsl:text>
							</xsl:if>

							<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and
															((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
								<xsl:variable name="isFieldX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaType">
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="@type"/>
										<xsl:with-param name="isInterface" select="$isInterface"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaReferenceType">
                                    <xsl:choose>
                                        <xsl:when test="contains($javaType,'Object') and not($isX3dStatement = 'true') and not(@name = 'field') and not(@name = 'fieldValue')">
                                            <xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:variable>
								<xsl:choose>
									<xsl:when test="($isFieldX3dStatement = 'true')">
										< ! - - ignore, statements do not include DEF - - >
									</xsl:when>
									<xsl:when test="(@type = 'SFNode')">
										<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
		{
			referenceNode = ((X3DConcreteNode) </xsl:text><xsl:value-of select="@name"/><xsl:text>).getNodeByDEF(DEFlabel); // SFNode
			if (referenceNode != null)
				return referenceNode;
		}</xsl:text>
									</xsl:when>
									<xsl:when test="(@type = 'MFNode')">
										<xsl:text>
		for (</xsl:text>
		<xsl:value-of select="$javaReferenceType"/>
		<xsl:text> element : </xsl:text><xsl:value-of select="@name"/><xsl:text>) // MFNode
		{
			if (element instanceof org.web3d.x3d.jsail.X3DConcreteNode)
			{
				if (((X3DConcreteNode) element).getDEF().equals(DEFlabel))
					return (X3DConcreteNode) element; // found, this node

				// not yet found, continue with depth-first search of current child element
				referenceNode = ((X3DConcreteNode) element).getNodeByDEF(DEFlabel);
				if (referenceNode != null)
					return referenceNode; // found in child
			}
		}</xsl:text>
									</xsl:when>
								</xsl:choose>
							</xsl:for-each>
							<xsl:if test="($name = 'ProtoInstance')">
								<xsl:text>
		// ProtoInstance node can contain other DEF'ed nodes in any contained fieldValue
		for (fieldValue fieldInitialization : getFieldValueList()) // MFNode
		{
			// not yet found, continue with depth-first search of current fieldValueList
			for (org.web3d.x3d.sai.Core.X3DNode child : fieldInitialization.getChildren())
			{
				if (child instanceof X3DConcreteNode)
				{
					referenceNode = ((X3DConcreteNode) child).getNodeByDEF(DEFlabel);
					if (referenceNode != null)
						return referenceNode; // found in child
				}
			}
		}</xsl:text>
							</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[
		return null; // not found, in this node or in children nodes
	}
]]></xsl:text>
						</xsl:if>
						 -->

						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">
							<!-- ======================== -->
							<!-- findElementByNameValue() -->
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide object reference to node or statement by name attribute, if found as part of this element or in a contained element.
	 * Elements with name fields include meta, Metadata* nodes, field/fieldValue, ProtoDeclare/ExternProtoDeclare/ProtoInstance, CAD and HAnim nodes.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorScene() to check entire scene graph, or findAncestorX3D() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same name, this method does not handle that case.
	 * @see #findNodeByDEF(String)
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3D()
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @return object reference to found element, null otherwise
	 */
	/* @Override */
	public X3DConcreteElement findElementByNameValue(String nameValue)
	{
		return findElementByNameValue(nameValue, ""); // empty string is wildcard, any element match is allowed
	}

	/**
	 * Recursive method to provide object reference to node or statement by name attribute, if found as part of this element or in a contained element.
	 * Elements with name fields include meta, Metadata* nodes, field/fieldValue, ProtoDeclare/ExternProtoDeclare/ProtoInstance, CAD and HAnim nodes.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorScene() to check entire scene graph, or findAncestorX3D() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same name, this method does not handle that case.
	 * @see #findNodeByDEF(String)
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3D()
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @param elementName identifies the element of interest (meta MetadataString ProtoDeclare CADassembly ProtoInstance HAnimHumanoid etc.)
	 * @return object reference to found element, null otherwise
	 */
	/* @Override */
	public X3DConcreteElement findElementByNameValue(String nameValue, String elementName)
	{
		if ((nameValue == null) || nameValue.isEmpty())
		{
			String errorNotice = "*** findElementByNameValue(\"\", " + elementName + ") cannot use empty string to find a name attribute";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}]]></xsl:text>
							<xsl:choose>
								<xsl:when test="($thisClassName = 'CommentsBlock')">
									<!-- no children to test -->
								</xsl:when>
								<xsl:when test="InterfaceDefinition/field[@name = 'name']">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (elementName == null)
			elementName = "";
		if (getName().equals(nameValue) &&
			(elementName.isEmpty() || elementName.equals(getElementName())))
			return this;]]></xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<xsl:text disable-output-escaping="yes"><![CDATA[
		// no name field available for this element]]></xsl:text>
								</xsl:otherwise>
							</xsl:choose>

							<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and
															((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
								<xsl:if test="position() = 1">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		X3DConcreteElement referenceElement;]]></xsl:text>
								</xsl:if>
								<xsl:variable name="isFieldX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaType">
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="@type"/>
										<xsl:with-param name="isInterface" select="$isInterface"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaReferenceType"><!-- base type of ArrayList -->
                                    <xsl:choose>
                                        <xsl:when test="(@type = 'MFNode') and not($isX3dStatement = 'true') and not(@name = 'field') and not(@name = 'fieldValue')"><!-- (contains($javaType,'Object') or (@acceptableNodeTypes = 'X3DMetadataObject')) and not(contains($javaType,'X3DMetadataObject')) and -->
                                            <xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
                                        </xsl:when>
                                        <xsl:when test="contains($javaType,'&lt;')">
                                            <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="$javaType"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:variable>
								<xsl:choose>
									<xsl:when test="(@name = 'field') or (@name = 'fieldValue')">
										<xsl:text>
		for (</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:value-of select="$jsaiClassSuffix"/><xsl:text> element : </xsl:text><xsl:value-of select="@name"/><xsl:text disable-output-escaping="yes"><![CDATA[List)
		{
			if (element instanceof X3DConcreteElement)
			{
				referenceElement = ((X3DConcreteElement) element).findElementByNameValue(nameValue, elementName);
				if ((referenceElement != null))
					return referenceElement;
			}
		}]]></xsl:text>
									</xsl:when>
									<xsl:when test="(@type = 'SFNode') or (@name = 'ProtoDeclare') or (@name = 'ExternProtoDeclare') or (@name = 'ProtoInstance')">
										<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
		{
			referenceElement = ((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>).findElementByNameValue(nameValue, elementName);
			if (referenceElement != null)
				return referenceElement;
		}</xsl:text>
										<!-- now corresponding ProtoInstance for each SFNode field -->
										<xsl:if test="(@type = 'SFNode') and not($isX3dStatement = 'true') and not(@name = 'IS')">
											<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance != null)
		{
			referenceElement = ((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance).findElementByNameValue(nameValue, elementName);
			if (referenceElement != null)
				return referenceElement;
		}</xsl:text>
										</xsl:if>
									</xsl:when>
									<xsl:when test="(@type = 'MFNode') and
													(not($isFieldX3dStatement = 'true') or starts-with(@name,'field'))">
										<xsl:text>
		for (</xsl:text>
		<xsl:value-of select="$javaReferenceType"/>
		<xsl:text> element : </xsl:text><xsl:value-of select="@name"/><xsl:text>) // MFNode
		{
			if (element instanceof X3DConcreteElement)
			{
				referenceElement = ((X3DConcreteElement) element).findElementByNameValue(nameValue, elementName);
				if (referenceElement != null)
					return referenceElement;
			}
		}</xsl:text>
									</xsl:when>
								</xsl:choose>
							</xsl:for-each>
	<xsl:text disable-output-escaping="yes"><![CDATA[
		return null; // not found
	}
	/**
	 * Recursive method to determine whether node or statement with given name attribute is found, meaning both objects are attached to same scene graph.
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @param elementName identifies the element of interest (meta MetadataString ProtoDeclare CADassembly ProtoInstance HAnimHumanoid etc.)
	 * @see #findElementByNameValue(String, String)
	 * @return whether node is found
	 */
	public boolean hasElementByNameValue(String nameValue, String elementName)
	{
		return (findElementByNameValue(nameValue, elementName) != null);
	}
]]></xsl:text>
							<!-- ================================== -->
							<!-- findNodeByDEF() and hasNodeByDef() -->
<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide object reference to node by DEF, if found as this node or in a contained node.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorScene() to check entire scene graph, or findAncestorX3D() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same DEF, this method does not handle that case.
	 * @see #findElementByNameValue(String)
	 * @see X3DConcreteElement#hasAncestorScene()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3D()
	 * @param DEFvalue is value of the name field being searched for in this element and child elements(if any)
	 * @return object reference to found node, null otherwise
	 */
	/* @Override */
	public X3DConcreteNode findNodeByDEF(String DEFvalue)
	{
		if ((DEFvalue == null) || DEFvalue.isEmpty())
		{
			String errorNotice = "*** findNodeByDEF(\"\") cannot use empty string to find a name";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}]]></xsl:text>
							<xsl:choose>
								<xsl:when test="InterfaceDefinition/field[@name = 'DEF']">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (getDEF().equals(DEFvalue))
			return this;]]></xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<!-- no children to test -->
								</xsl:otherwise>
							</xsl:choose>

							<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and
															((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
								<xsl:if test="position() = 1">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		X3DConcreteNode referenceNode;]]></xsl:text>
								</xsl:if>
								<xsl:variable name="isFieldX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaType">
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="@type"/>
										<xsl:with-param name="isInterface" select="$isInterface"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaReferenceType"><!-- base type of ArrayList -->
                                    <xsl:choose>
                                        <xsl:when test="(@type = 'MFNode') and not($isX3dStatement = 'true') and not(@name = 'field') and not(@name = 'fieldValue')"><!-- (contains($javaType,'Object') or (@acceptableNodeTypes = 'X3DMetadataObject')) and not(contains($javaType,'X3DMetadataObject')) and -->
                                            <xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
                                        </xsl:when>
                                        <xsl:when test="contains($javaType,'&lt;')">
                                            <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="$javaType"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:variable>
								<xsl:choose>
									<xsl:when test="(@type = 'SFNode')">
										<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
		{
			referenceNode = ((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>).findNodeByDEF(DEFvalue);
			if (referenceNode != null)
				return referenceNode;
		}</xsl:text>
										<!-- also check SFNode protoInstance member objects -->
										<xsl:if test="not(@name = 'head') and not(@name = 'Scene') and not(@name = 'ProtoInterface') and not(@name = 'ProtoBody') and not(@name = 'IS')">
											<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance != null)
		{
			referenceNode = ((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance).findNodeByDEF(DEFvalue);
			if (referenceNode != null)
				return referenceNode;
		}</xsl:text>
										</xsl:if>
									</xsl:when>
									<xsl:when test="(@type = 'MFNode') and
													not(($isFieldX3dStatement = 'true') or starts-with(@name,'field'))">
										<xsl:text>
		for (</xsl:text>
		<xsl:value-of select="$javaReferenceType"/>
		<xsl:text> element : </xsl:text><xsl:value-of select="@name"/><xsl:text>) // MFNode
		{
			if (element instanceof org.web3d.x3d.jsail.X3DConcreteNode)
			{
				referenceNode = ((X3DConcreteElement) element).findNodeByDEF(DEFvalue);
				if (referenceNode != null)
					return referenceNode;
			}
		}</xsl:text>
									</xsl:when>
								</xsl:choose>
							</xsl:for-each>
	<xsl:text disable-output-escaping="yes"><![CDATA[
		return null; // not found
	}
	/**
	 * Recursive method to determine whether node with DEFvalue is found, meaning both objects are attached to same scene graph.
	 * @param DEFvalue is value of the name field being searched for in this element and child elements(if any)
	 * @see #findNodeByDEF(String)
	 * @return whether node is found
	 */
	public boolean hasNodeByDEF(String DEFvalue)
	{
		return (findNodeByDEF(DEFvalue) != null);
	}
]]></xsl:text>
							<!-- ======================== -->
						</xsl:if>

						<!-- validate() -->
						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">
							<xsl:text>

	/**
	 * Recursive method to validate this element plus all contained nodes and statements,
	 * using both datatype-specification value checks and regular expression (regex) checking of corresponding string values.
         * TODO document specific validation methods.
	 * @return validation results (if any)
	 */
	@Override
	public String validate()
	{
		validationResult = new StringBuilder(); // prepare for updated results
</xsl:text>
                <xsl:if test="(@name = 'ProtoInstance')">
                    <xsl:text>
                getNodeType(); // initialize ProtoInstance containerField, if missing and available in corresponding ProtoDeclare
</xsl:text>
                </xsl:if>
                                <!-- special one-time warnings -->
				<xsl:choose>
                                    <xsl:when test="($name = 'X3D')">
					<xsl:text>
                if (!hasHead()) // special warning
                {
                    validationResult.append(ConfigurationProperties.ERROR_NODE_NOT_FOUND + ": X3D has no head element, and thus has no meta elements and is undescribed" + "\n");
                }
                if (!hasScene()) // special warning
                {
                    validationResult.append(ConfigurationProperties.ERROR_NODE_NOT_FOUND + ": X3D has no Scene element and thus has no model defined" + "\n");
                }</xsl:text>
                                    </xsl:when>
                                    <xsl:when test="($name = 'head')">
					<xsl:text>
                if (!hasMeta()) // special warning
                {
                    validationResult.append(ConfigurationProperties.ERROR_NODE_NOT_FOUND + ": X3D head has no meta elements and thus is undescribed" + "\n");
                }</xsl:text>
                                    </xsl:when>
                                    <xsl:when test="($name = 'Scene')">
					<xsl:text>
                if (!hasChildren()) // special warning
                {
                    validationResult.append(ConfigurationProperties.ERROR_NODE_NOT_FOUND + ": X3D Scene element is empty and thus has no model defined" + "\n");
                }</xsl:text>
                                    </xsl:when>
                                </xsl:choose>
							<xsl:for-each select="InterfaceDefinition/field[not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and
															((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
								<xsl:sort select="contains(@type,'Node')"/> <!-- attributes first can simplify debugging -->
								<xsl:variable name="isFieldX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaType">
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="@type"/>
										<xsl:with-param name="isInterface" select="$isInterface"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaReferenceType"><!-- base type of ArrayList -->
                                    <xsl:choose>
                                        <xsl:when test="(@type = 'MFNode') and not($isX3dStatement = 'true') and not(@name = 'field') and not(@name = 'fieldValue')"><!-- (contains($javaType,'Object') or (@acceptableNodeTypes = 'X3DMetadataObject')) and not(contains($javaType,'X3DMetadataObject')) and -->
                                            <xsl:text>org.web3d.x3d.sai.Core.X3DNode</xsl:text>
                                        </xsl:when>
                                        <xsl:when test="contains($javaType,'&lt;')">
                                            <xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="$javaType"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:variable>
								<xsl:variable name="fieldName" select="translate(@name,'-','_')"/><!-- handle http-equiv etc. -->
								<xsl:variable name="CamelCaseName"><!-- upper camel case -->
									<xsl:choose>
										<xsl:when test="starts-with(@name,'set_')">
											<xsl:value-of select="translate(substring(substring-after(@name,'set_'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
											<xsl:value-of select="substring(substring-after(@name,'set_'),2)"/>
										</xsl:when>
										<xsl:when test="starts-with(@name,'set')">
											<xsl:value-of select="translate(substring(substring-after(@name,'set'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
											<xsl:value-of select="substring(substring-after(@name,'set'),2)"/>
										</xsl:when>
										<xsl:when test="contains(@name,'_changed')">
											<xsl:value-of select="translate(substring(substring-before(@name,'_changed'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
											<xsl:value-of select="substring(substring-before(@name,'_changed'),2)"/>
										</xsl:when>
										<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
											<!-- unmodified -->
											<xsl:value-of select="@name"/>
										</xsl:when>
										<xsl:when test="(@name = 'id')">
											<!-- similarly named for clarity, consistency -->
											<xsl:text>HtmlID</xsl:text>
										</xsl:when>
										<xsl:when test="(@name = 'class')">
											<!-- getClass() is reserved by Java Object() class -->
											<xsl:text>CssClass</xsl:text>
										</xsl:when>
                                        <xsl:when test="(@name = 'style') and not(ends-with($thisClassName, 'FontStyle'))">
                                            <!-- similarly named for clarity, consistency -->
                                            <xsl:text>CssStyle</xsl:text>
                                        </xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="translate(substring(@name,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
											<xsl:value-of select="substring($fieldName,2)"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:variable name="isRequired"><!-- either by X3D Schema/OM4X3D or X3D semantics -->
                                                                        <!-- Metadata* node name is not required, omit: or starts-with(@name,'Metadata') -->
									<xsl:value-of select="(@use = 'required') or
														  ((@name = 'name') and not(ancestor::ConcreteNode[(@name = 'ProtoInstance')]) and
														   (ancestor::ConcreteNode[starts-with(@name,'HAnim') or
																				   starts-with(@name,'field') or contains(@name,'ProtoDeclare')])) or
														  (ancestor::ConcreteNode[(@name = 'component') or (@name = 'connect') or (@name = '') or (@name = 'ROUTE') or (@name = 'unit')]) or
														  ((@name = 'localDEF')                               and (ancestor::ConcreteNode[(@name = 'EXPORT')])) or
														  (((@name = 'inlineDEF') or (@name = 'importedDEF')) and (ancestor::ConcreteNode[(@name = 'IMPORT')])) or
														  (((@name = 'type')    or (@name = 'accessType'))    and (ancestor::ConcreteNode[starts-with(@name,'field')])) or
														  (((@name = 'profile') or (@name = 'version'))       and (ancestor::ConcreteNode[(@name = 'X3D')])) or
														  ((@name = 'version') and (ancestor::ConcreteNode[(@name = 'HAnimHumanoid')])) or
														  ((@name = 'content') and (ancestor::ConcreteNode[(@name = 'meta')]))"/>
								</xsl:variable>
								<xsl:text>&#10;		</xsl:text><!-- indent -->

								<xsl:if test="($isRequired = 'true')">
									<!--
									<xsl:message>
										<xsl:text>[node=</xsl:text>
										<xsl:value-of select="ancestor::ConcreteNode/@name"/>
										<xsl:text>, attribute=</xsl:text>
										<xsl:value-of select="@name"/>
										<xsl:text>, $isRequired=</xsl:text>
										<xsl:value-of select="$isRequired"/>
										<xsl:text>]</xsl:text>
									</xsl:message>
									-->
									<xsl:choose>
										<xsl:when test="(@type = 'SFNode') or (@type = 'MFNode')">
											<xsl:text>// TODO check for required field</xsl:text>
										</xsl:when>
										<xsl:when test="(@type = 'SFString')">
											<xsl:text>if (get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>().isEmpty()</xsl:text>
											<xsl:if test="not($isX3dStatement = 'true')">
												<xsl:text disable-output-escaping="yes"><![CDATA[ && !hasUSE()]]></xsl:text>
											</xsl:if>
											<xsl:text>) // required attribute
		{
			String errorNotice = ConfigurationProperties.ERROR_VALUE_NOT_FOUND +
					     ", " + NAME + " </xsl:text>
                                                                        <xsl:value-of select="$fieldName"/>
                                                                        <xsl:text> field is required but no value found.";</xsl:text>
                                                                        <xsl:if test="($name = 'ProtoInstance') and ($fieldName = 'name')">
                                                                            <xsl:text>
                        if (hasDEF())
                        {
                            errorNotice += " DEF='" + getDEF() + "'"; // assist user node identification for troubleshooting
                        }
                        if (hasUSE())
                        {
                            errorNotice += " USE='" + getUSE() + "'"; // assist user node identification for troubleshooting
                        }
</xsl:text>
                                                                        </xsl:if>
											<xsl:if test="($fieldName = 'content')"><!-- meta tag -->
												<xsl:text>
            errorNotice += " (meta name='" + getName() + "')";
</xsl:text>
											</xsl:if>
                                            <xsl:text>
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		// TODO duplicated name checks in setValue() method</xsl:text>
											<xsl:if test="(@name = 'meta')">
												<xsl:text>
		if (getName().equalsIgnoreCase("error") || getName().equalsIgnoreCase("warning") || getName().equalsIgnoreCase("hint") || getName().equalsIgnoreCase("info"))
		{
			String warningNotice = ConfigurationProperties.WARNING_MESSAGE + ": " +
                                   NAME + " name=\"" + getName() + "\" content=\"" + getContent() + "\"";
			validationResult.append(warningNotice).append("\n");
			throw new InvalidFieldValueException(warningNotice); // report meta warning
		}</xsl:text>
											</xsl:if>
										</xsl:when>
									</xsl:choose>
									<xsl:text>&#10;		</xsl:text><!-- indent -->
								</xsl:if>
								<xsl:choose>
									<xsl:when test="(@type = 'SFNode')">
										<xsl:text>if (</xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
		{
			set</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>(get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>());
			((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>).validate(); // exercise field checks, SFNode
			validationResult.append(((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>).getValidationResult());
		}</xsl:text>
				<xsl:if test="not($isX3dStatement = 'true') and not(@name = 'IS')">
					<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance != null)
		{
			set</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>(get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>ProtoInstance());
			((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance).validate(); // exercise field checks, SFNode
			validationResult.append(((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance).getValidationResult());
		}
		if ((</xsl:text>   <xsl:value-of select="@name"/><xsl:text disable-output-escaping="yes"><![CDATA[ != null) && (]]></xsl:text>
						   <xsl:value-of select="@name"/><xsl:text>ProtoInstance != null))
		{
			String errorNotice = "*** Internal X3DJSAIL error: incorrect handling of contained SFNode field, both </xsl:text><xsl:value-of select="@name"/><xsl:text> and </xsl:text>
				<xsl:value-of select="@name"/><xsl:text>ProtoInstance are set simultaneously";
			validationResult.append(errorNotice);
			throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
		}</xsl:text>
				</xsl:if>
									</xsl:when>
									<xsl:when test="(@type = 'MFNode')">
										<xsl:text>for (</xsl:text>
		<xsl:value-of select="$javaReferenceType"/>
		<xsl:text> element : </xsl:text><xsl:value-of select="@name"/>
						<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<xsl:text>) // MFNode
		{
			try {
                            ((X3DConcreteElement) element).validate(); // exercise field checks, MFNode element
                            validationResult.append(((X3DConcreteElement) element).getValidationResult());
                        }
                        catch (Exception e)
                        {
                            String exceptionMessage = "[exception] during validation: " + e.getMessage();
                            validationResult.append(exceptionMessage);
                        //  System.err.println(exceptionMessage);
                            e.printStackTrace();
                        }
		}
		set</xsl:text><xsl:value-of select="$CamelCaseName"/>
						<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<xsl:text>(get</xsl:text><xsl:value-of select="$CamelCaseName"/>
						<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<xsl:text>()); // also test getter/setter validation</xsl:text>
                        <xsl:if test="(@type = 'SFNode') or (@type = 'MFNode')">
                            <xsl:text>, which also includes checks for acceptableNodeTypes (if applicable)</xsl:text>
                        </xsl:if>
                        <xsl:text>&#10;</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:if test="(@name = 'DEF')">
											<xsl:text>if (!hasUSE()) // be careful! setting DEF via setDEF() method will reset USE value
			</xsl:text>
										</xsl:if>
										<xsl:if test="(@name = 'USE')">
											<xsl:text>if (hasUSE()) // be careful! setting USE via setUSE() method resets all attributes to default values and wipes out all children
			</xsl:text>
										</xsl:if>
										<xsl:if test="(@name = 'value') and (($name = 'field') or ($name = 'fieldValue'))">
											<xsl:text>if (!hasChildren()) // be careful! only check simple types if no children nodes found
			</xsl:text>
										</xsl:if>
										<xsl:text>set</xsl:text><xsl:value-of select="translate($CamelCaseName,'-','_')"/>
<xsl:text>(get</xsl:text><xsl:value-of select="translate($CamelCaseName,'-','_')"/>
										<xsl:text>()); // exercise field checks, simple types
        </xsl:text>
<xsl:if test="false()"><!-- no need to test string regex when values are already loaded -->
    <xsl:if test="starts-with(@type, 'MF') and not(@type = 'MFString') and not(@type = 'MFNode')">
        <xsl:text>try { </xsl:text>
    </xsl:if>
    <xsl:text>if (!(new </xsl:text>
		<xsl:value-of select="@type"/>
		<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
		<xsl:text>(get</xsl:text>
		<xsl:value-of select="translate($CamelCaseName,'-','_')"/>
        <xsl:text>())).matches</xsl:text>
        <!-- TODO generalize this custom regex invocation -->
        <xsl:choose>
            <xsl:when test="($CamelCaseName = 'BboxSize')">
                <xsl:text>BboxSizeType</xsl:text>
            </xsl:when>
        </xsl:choose>
        <xsl:text>()) // regex checking of string version of typed value
        {
            validationResult.append((new </xsl:text>
		<xsl:value-of select="@type"/>
		<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
		<xsl:text>(get</xsl:text>
		<xsl:value-of select="translate($CamelCaseName,'-','_')"/>
        <xsl:text>())).validate().trim());
            validationResult.append(" for </xsl:text>
		<xsl:value-of select="$name"/>
		<xsl:text> </xsl:text>
		<xsl:value-of select="$fieldName"/>
<xsl:text>\n");
        }</xsl:text>
    <xsl:if test="starts-with(@type, 'MF') and not(@type = 'MFString') and not(@type = 'MFNode')">
        <xsl:text> }
        catch (java.lang.StackOverflowError soe) // regex processing required too much memory for String version of this attribute
        {
            String validationMessage = "java.lang.StackOverflow warning: regular expression (regex) unable to evaluate large corresponding String value for </xsl:text>
		<xsl:value-of select="$name"/>
		<xsl:text> </xsl:text>
		<xsl:value-of select="$fieldName"/>
        <xsl:if test="starts-with($fieldName,'MF')">
            <xsl:text> array</xsl:text>
        </xsl:if>
        <!-- TODO compute full length for all types
        <xsl:text> (length " + </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>.toString().length() + " values)</xsl:text> -->
		<xsl:text>";
            validationResult.append(validationMessage).append("\n");
            System.out.println ("[exception] " + validationMessage);
        }</xsl:text>
    </xsl:if>
    <xsl:text>&#10;</xsl:text>
</xsl:if><!-- no need to test string regex when values are already loaded -->
									</xsl:otherwise>
								</xsl:choose>
                                <!-- ProtoInstance name checks -->
                                <xsl:if test="($name = 'ProtoInstance') and (@name = 'name')">
                                        <xsl:text disable-output-escaping="yes"><![CDATA[
        if (getName().isEmpty() && !hasUSE())
        {
            String errorNotice = "*** ProtoInstance missing name field, which is always required.";
            if (hasDEF())
            {
                errorNotice += " DEF='" + getDEF() + "'"; // assist user node identification for troubleshooting
            }
            if (hasUSE())
            {
                errorNotice += " USE='" + getUSE() + "'"; // assist user node identification for troubleshooting
            }
            validationResult.append(errorNotice);
            throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
        }
	else if (getName().isEmpty() && hasUSE())
        {
            String errorNotice = "*** ProtoInstance USE='"+ getUSE() + "' node must always include name field, which is missing.";
            validationResult.append(errorNotice);
            throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
        }
        String originalName = getOriginalName(); // call once here, for efficiency and also to allow separate changes

        // check for presence of corresponding ProtoDeclare/ExternProtoDeclare having same name, report if missing
        if (ConfigurationProperties.isDebugModeActive() && hasProtoDeclare())
        {
                if  (hasUSE())
                     validationResult.append("ProtoInstance ").append(originalName).append(" USE='").append(getUSE()).append("' has corresponding ProtoDeclare").append("\n");
                else validationResult.append("ProtoInstance ").append(getName())   .append(" DEF='").append(getDEF()).append("' has corresponding ProtoDeclare").append("\n");
        }
        else if (ConfigurationProperties.isDebugModeActive() && hasExternProtoDeclare())
        {
                if  (hasUSE())
                     validationResult.append("ProtoInstance ").append(originalName).append(" USE='").append(getUSE()).append("' has corresponding ExternProtoDeclare (but node type is unconfirmed)").append("\n");
                else validationResult.append("ProtoInstance ").append(getName())   .append(" DEF='").append(getDEF()).append("' has corresponding ExternProtoDeclare (but node type is unconfirmed)").append("\n");
        }
        else if (hasProtoDeclare() && hasExternProtoDeclare())
        {
                String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE +
                                "ProtoInstance " + getName() + " has both corresponding ProtoDeclare and ExternProtoDeclare";
                validationResult.append(errorNotice);
                throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
        }
        if (getNodeType().startsWith(ConfigurationProperties.ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE))
        {
            String errorNotice = getNodeType();
            validationResult.append(errorNotice);
            throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
        }
        if (getNodeType().startsWith(ConfigurationProperties.ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE))
        {
            String errorNotice = getNodeType();
            validationResult.append(errorNotice);
            throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
        }
            // TODO check for legal containerField among allowed getContainerFieldAllowedValues() for given nodeType
]]></xsl:text>
                                                                </xsl:if>
								<!-- USE child checks -->
								<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) or ($name = 'ProtoInstance')">
									<xsl:choose>
										<xsl:when test="(@type = 'SFNode')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
            if (hasUSE() && has]]></xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>()) // test USE restrictions
            {
                String errorNotice = "*** </xsl:text><xsl:value-of select="$name"/><xsl:text> USE='" + getUSE() + "' is not allowed to have contained </xsl:text>
				<xsl:value-of select="@type"/><xsl:text> </xsl:text><xsl:value-of select="@name"/><xsl:text>";
                validationResult.append(errorNotice);
                throw new InvalidFieldValueException(errorNotice); // report error
            }
		</xsl:text>
									<xsl:if test="not($hasChildrenField = 'true') and not(starts-with($name, 'X3DConcrete'))">
                <!-- it is OK to append a comment to a USE node
										<xsl:text disable-output-escaping="yes"><![CDATA[
		if (hasUSE() && !commentsList.isEmpty())// test USE restrictions
		{
			String errorNotice = "*** ]]></xsl:text><xsl:value-of select="$name"/><xsl:text> USE='" + getUSE() + "' is not allowed to have contained comments";
			validationResult.append(errorNotice);
			throw new InvalidFieldValueException(errorNotice); // report error
		}
</xsl:text>
		-->
									</xsl:if>
                								</xsl:when>
										<xsl:when test="(@type = 'MFNode')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		if (hasUSE() && has]]></xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>()) // test USE restrictions
		{
                    String errorNotice = "*** </xsl:text><xsl:value-of select="$name"/><xsl:text> USE='" + getUSE() + "' is not allowed to have contained </xsl:text>
				<xsl:value-of select="@type"/><xsl:text> </xsl:text><xsl:value-of select="@name"/><xsl:text>";
                    validationResult.append(errorNotice);
                    throw new InvalidFieldValueException(errorNotice); // report error
		}
		</xsl:text>
										</xsl:when>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>

							<!-- Special validation tests -->
							<xsl:choose>
								<xsl:when test="(@name = 'head')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
        // check for redundant component tag
        int index = 0;
		for (component componentStatement : componentList)
		{
            for (int j = 0; j < index; j++)
            {
                if (componentStatement.getName().equalsIgnoreCase(componentList.get(j).getName()))
                {
                    validationResult.append("Redundant statements found, same category:\n  ").append(componentStatement.toStringX3D()).append(" and\n  ")
                        .append(componentList.get(j).toStringX3D());
                }
            }
            index++; // proceed to next, only checking in reverse
        }
        // check for redundant unit tag
        index = 0;
		for (unit unitStatement : unitList)
		{
            for (int j = 0; j < index; j++)
            {
                if (unitStatement.getCategory().equalsIgnoreCase(unitList.get(j).getCategory()))
                {
                    validationResult.append("Redundant statements found: ").append(unitStatement.toStringX3D()).append(" and ")
                        .append(unitList.get(j).toStringX3D());
                }
            }
            index++; // proceed to next, only checking in reverse
        }
        // check for duplicate meta tag
        index = -1; // list indices are zero-based
		for (meta metaStatement : metaList)
		{
            for (int j = 0; j < index; j++)
            {
                if (metaStatement.getName()   .equalsIgnoreCase(metaList.get(j).getName()) &&
                    metaStatement.getContent().equalsIgnoreCase(metaList.get(j).getContent()))
                {
                    validationResult.append(ConfigurationProperties.WARNING_MESSAGE)
                        .append(": duplicate statement found: <meta name='").append(metaStatement.getName())
                        .append("' content='").append(metaStatement.getContent()).append("'/>\n");
                }
                // singleton meta tags
                else if ( metaStatement.getName().equalsIgnoreCase(metaList.get(j).getName()) &&
                         (metaStatement.getName().equalsIgnoreCase(meta.NAME_DESCRIPTION) ||
                          metaStatement.getName().equalsIgnoreCase(meta.NAME_CREATED)     ||
                          metaStatement.getName().equalsIgnoreCase(meta.NAME_MODIFIED)    ||
                          metaStatement.getName().equalsIgnoreCase(meta.NAME_IDENTIFIER)    ||
                          metaStatement.getName().equalsIgnoreCase(meta.NAME_TITLE)    ||
                          metaStatement.getName().equalsIgnoreCase(meta.NAME_SUBJECT)))
                {
                    validationResult.append("Duplicate found: <meta name='").append(metaStatement.getName()).append("'/>\n");
                }
            }
            index++; // proceed to next, only checking in reverse
		}
]]></xsl:text>
                                </xsl:when>
								<xsl:when test="(@name = 'meta')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
        String warningMessage = new String();
        if (getName().contains("\""))
			warningMessage += "WARNING:avoid quotes in name, <meta name='" + getName() + "' content='" + getContent() + "'/>";
        if (getContent().startsWith("\"") && getContent().endsWith("\""))
			warningMessage += "WARNING:avoid quoting content value, <meta name='" + getName() + "' content='" + getContent() + "'/>";

        // additional meta validation
        if (!getName().isBlank() && !getContent().isBlank())
        {
            String contentPrefix = getContent();
            if (getContent().contains("."))
                contentPrefix = getContent().substring(0,getContent().lastIndexOf("."));
            if ((getName().equalsIgnoreCase(meta.NAME_TITLE) || getName().equalsIgnoreCase("filename") || getName().equalsIgnoreCase("name")) &&
                (SFString.isX3dNodeName(getContent()) || SFString.isX3dNodeName(contentPrefix)))
                            warningMessage += "WARNING:avoid duplicating a built-in X3D node name as model title, <meta name='" + getName() + "' content='" + getContent() + "'/>";
            if ((getName().equalsIgnoreCase(meta.NAME_TITLE) || getName().equalsIgnoreCase("filename") || getName().equalsIgnoreCase("name")) &&
                (SFString.isX3dStatementName(getContent()) || SFString.isX3dStatementName(contentPrefix)))
                            warningMessage += "WARNING:avoid duplicating a built-in X3D statement name as model title, <meta name='" + getName() + "' content='" + getContent() + "'/>";
        }

		// TODO consider if ConfigurationProperties for verbose output is appropriate
		if      (getName().equals(NAME_ERROR) ||
                         getName().equals(NAME_HINT) ||
                         getName().equals(NAME_INFO) ||
                         getName().equals(NAME_INFORMATION) ||
                         getName().equals(NAME_WARNING))
		{
                      // these diagnostics are handled in X3D.java metaResult, TODO consider verbose switch
                      // warningMessage += "Model diagnostic: <meta name='" + getName() + "' content='" + getContent() + "'/>";
                      // System.out.println(warningMessage);
		}
                else if (!warningMessage.isBlank())
		{
                         System.out.println();
                         System.out.print  (warningMessage);
		}

]]></xsl:text>
                                </xsl:when>
								<xsl:when test="(@name = 'ROUTE')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		// NMTOKEN checks for allowed characters and no whitespace are provided when
		// setting name of fromNode, fromField, toNode, toField

		// Now check ROUTE node-type validity; note that each ROUTE must already be connected to scene graph

		String errorNotice = new String();
		String ROUTE_description = "<ROUTE fromNode='" + fromNode + "' fromField='" + fromField +
										  "' toNode='" +   toNode +   "' toField='" +   toField + "'/>";

		X3DConcreteNode fromNodeObject = null;
		X3DConcreteNode   toNodeObject = null;

		if ((findAncestorScene() == null) && (findAncestorProtoBody() == null))
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH +
							   ", ROUTE is not currently connected to scene graph and thus fromNode/toNode fields cannot be checked, must first be connected to scene graph in order to get checked. ";
				validationResult.append(ROUTE_description).append("\n").append(errorNotice).append("\n");
			}
		}
		if (getFromField().isEmpty())
		{
			errorNotice = "ROUTE has no DEF value for source node since fromNode value is empty. ";
			validationResult.append(errorNotice).append("\n");
		}
		else if (findAncestorProtoBody() != null) // look only within ProtoBody, if appropriate
		{
			fromNodeObject = findAncestorProtoBody().findNodeByDEF(getFromNode());
			if (fromNodeObject == null)
			{
				errorNotice = "ROUTE fromNode='" + getFromNode() + "' was not found within connected ProtoBody. ";
				validationResult.append(errorNotice).append("\n");
			}
		}
		else if (findAncestorScene() != null) // otherwise look within Scene
		{
			fromNodeObject = findAncestorScene().findNodeByDEF(getFromNode());
			if (fromNodeObject == null)
			{
				errorNotice = "ROUTE fromNode='" + getFromNode() + "' was not found in connected scene graph. ";
				validationResult.append(errorNotice).append("\n");
			}
		}
		if (getToField().isEmpty())
		{
			errorNotice = "ROUTE has no DEF value for target node since toNode value is empty. ";
			validationResult.append(errorNotice).append("\n");
		}
		else if (findAncestorProtoBody() != null) // look only within ProtoBody, if appropriate
		{
			toNodeObject = findAncestorProtoBody().findNodeByDEF(getToNode());
			if (toNodeObject == null)
			{
				errorNotice = "ROUTE toNode='" + getToNode() + "' was not found within connected ProtoBody. ";
				validationResult.append(errorNotice).append("\n");
			}
		}
		else if (findAncestorScene() != null) // otherwise look within Scene
		{
			toNodeObject = findAncestorScene().findNodeByDEF(getToNode());
			if (toNodeObject == null)
			{
				errorNotice = "ROUTE toNode='" + getToNode() + "' was not found in connected scene graph. ";
				validationResult.append(errorNotice).append("\n");
			}
		}
		if (fromNode.equals(toNode) && fromField.equals(toField)) // self-ROUTE check
		{
			errorNotice = "ROUTE source and destination are identical. ";
			validationResult.append(errorNotice).append("\n");
		}
		if (!errorNotice.isEmpty() || (fromNodeObject == null) || (toNodeObject == null))
		{
			validationResult.append(ROUTE_description).append("\n");
		}
		else // further checking
		{
			String  fromNodeType, toNodeType, fromFieldType, toFieldType, fromFieldAccessType, toFieldAccessType = new String();

			 fromNodeType = fromNodeObject.getClass().getSimpleName().split("Object")[0]; // substring-before Object
			   toNodeType =   toNodeObject.getClass().getSimpleName().split("Object")[0]; // substring-before Object

			      fromFieldType = fromNodeObject.getFieldType (fromField);
			        toFieldType =   toNodeObject.getFieldType (  toField);
			fromFieldAccessType = fromNodeObject.getAccessType(fromField);
			  toFieldAccessType =   toNodeObject.getAccessType(  toField);

			ROUTE_description = "ROUTE details: FROM " +
				fromNode + "." + fromField + " [" + fromNodeType + "," + fromFieldType + "," + fromFieldAccessType + "] TO " +
				  toNode + "." +   toField + " [" +   toNodeType + "," +   toFieldType + "," +   toFieldAccessType + "]";

			if (!fromFieldType.equals(toFieldType))
			{
				errorNotice = "ROUTE has source-destination type mismatch, " +
							   "fromField='" + fromField + "' source and toField='" + toField + "' destination have different types. ";
			}
			if (!fromFieldAccessType.equals(field.ACCESSTYPE_INPUTOUTPUT) &&
				!fromFieldAccessType.equals(field.ACCESSTYPE_OUTPUTONLY))
			{
				errorNotice = "ROUTE fromField (source) event can only have accessType='inputOutput' or accessType='outputOnly'. ";
			}
			if (  !toFieldAccessType.equals(field.ACCESSTYPE_INPUTOUTPUT) &&
				  !toFieldAccessType.equals(field.ACCESSTYPE_INPUTONLY))
			{
				errorNotice = "ROUTE toField (destination) event can only have accessType='inputOutput' or accessType='inputOnly'. ";
			}
			if (!errorNotice.isEmpty())
			{
				validationResult.append(errorNotice).append("\n").append(ROUTE_description).append("\n");
				throw new InvalidFieldValueException(ROUTE_description + "\n" + errorNotice);
			}
		}]]></xsl:text>
								</xsl:when>
								<xsl:when test="(@name = 'IndexedFaceSet') or (@name = 'IndexedLineSet')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (hasCoord() && coordIndex.isEmpty())
		{
			if (getCoordCount() > 0)
			{
				String errorNotice = NAME + " containing Coordinate node with " + getCoordCount() + " values must also include coordIndex field";
				validationResult.append(errorNotice);
				throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
			}
		}
		if (((color != null) || (colorProtoInstance != null)) && colorIndex.isEmpty() && coordIndex.isEmpty())
		{
			if (getColorCount() > 0)
			{
				String errorNotice = NAME + " containing Color node with " + getColorCount() + " values must also include colorIndex or coordIndex field";
				validationResult.append(errorNotice);
				throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
			}
		}]]></xsl:text>
		<xsl:if test="(@name = 'IndexedFaceSet')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((hasNormal()) && normalIndex.isEmpty() && coordIndex.isEmpty())
		{
			if (getNormalCount() > 0)
			{
				String errorNotice = NAME + " containing Normal node with " + getNormalCount() + " values must also include normalIndex or coordIndex field";
				validationResult.append(errorNotice);
				throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
			}
		}
		if (((texCoord != null) || (texCoordProtoInstance != null)) && texCoordIndex.isEmpty() && coordIndex.isEmpty())
		{
			if (getTexCoordCount() > 0)
			{
				String errorNotice = NAME + " containing TextureCoordinate node with " + getTexCoordCount() + " values must also include texCoordIndex or coordIndex field";
				validationResult.append(errorNotice);
				throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
			}
		}]]></xsl:text>
		</xsl:if>
								</xsl:when>
								<xsl:when test="(@name = 'IMPORT')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		// check IMPORT not overloading DEF name

		String errorNotice = new String();
		String IMPORT_description = "<IMPORT inlineDEF='" + inlineDEF + "' importedDEF='" + importedDEF + "' AS='" + AS + "'/>";

		if (findAncestorScene() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH +
							   ": IMPORT is not currently connected to Scene scene graph and thus cannot get checked.";
				validationResult.append(IMPORT_description).append("\n").append(errorNotice).append("\n");
			}
		}
		else
		{
			X3DConcreteNode          inlineDEFObject = findAncestorScene().findNodeByDEF(  inlineDEF);
			X3DConcreteNode importedDEF_InlineObject = findAncestorScene().findNodeByDEF(importedDEF);
			X3DConcreteNode          AS_InlineObject = findAncestorScene().findNodeByDEF(         AS);

			if (inlineDEF.isEmpty())
			{
				errorNotice += "IMPORT error: no inlineDEF value defined. ";
			}
			else if (inlineDEFObject == null)
			{
				errorNotice += "IMPORT error: corresponding <Inline DEF='" + inlineDEF + "'/> not found. ";
			}
			if      (!AS.isEmpty() && (AS_InlineObject != null))
			{
				errorNotice += "IMPORT collision in parent scene: another " + AS_InlineObject.getElementName() +
							   " node found with DEF value matching IMPORT AS value. ";
			}
			else if ( AS.isEmpty() && !importedDEF.isEmpty() && (importedDEF_InlineObject != null))
			{
				errorNotice += "IMPORT collision: another " + importedDEF_InlineObject.getElementName() +
							   " node found with DEF value matching IMPORT importedDEF value. ";
			}
			if (!errorNotice.isEmpty())
			{
				validationResult.append(IMPORT_description).append("\n").append(errorNotice).append("\n");
				throw new InvalidFieldValueException(IMPORT_description + "\n" + errorNotice);
			}
		}
]]></xsl:text>
								</xsl:when>
								<xsl:when test="(@name = 'EXPORT')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		// check EXPORT using valid DEF name

		String errorNotice = new String();
		String EXPORT_description = "<EXPORT localDEF='" + localDEF + "' AS='" + AS + "'/>";

		if (findAncestorScene() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH +
							   ": EXPORT is not currently connected to Scene scene graph and thus cannot get checked.";
				validationResult.append(EXPORT_description).append("\n").append(errorNotice).append("\n");
			}
		}
		else
		{
			X3DConcreteNode   localDEFObject = findAncestorScene().findNodeByDEF(localDEF);

			if (localDEF.isEmpty())
			{
				errorNotice = "EXPORT has no localDEF defined. ";
			}
			else if (localDEFObject == null)
			{
				errorNotice = "Local node with DEF=localDEF not found. ";
			}
			if (!errorNotice.isEmpty())
			{
				validationResult.append(EXPORT_description).append("\n").append(errorNotice).append("\n");
				throw new InvalidFieldValueException(EXPORT_description + "\n" + errorNotice);
			}
		}
]]></xsl:text>
								</xsl:when>
								<!-- ProtoDeclare, ExternProtoDeclare check for corresponding ProtoInstance -->
								<xsl:when test="($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (findAncestorScene().findElementByNameValue (getName(), ProtoInstance.NAME) == null)
		{
			String warningNotice = ConfigurationProperties.WARNING_PROTOINSTANCE_NOT_FOUND +
									", " + NAME + " " + getName() + " has no corresponding " +
									ProtoInstance.NAME + " attached to the scene graph. ";
			validationResult.append(warningNotice).append("\n");
		}
		// TODO pass through allowed containerField values array?
]]></xsl:text>
								</xsl:when>
								<xsl:when test="(@name = 'ProtoBody')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (children.isEmpty())
		{
			String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE +
						   ": ProtoBody does not have any child nodes and so ProtoDeclare has no node type. ";
			String ProtoDeclare_description = "Parent ProtoDeclare name: " + getName(); // may report error condition if no parent
			validationResult.append(ProtoDeclare_description).append("\n").append(errorNotice).append("\n");
		}
]]></xsl:text>
								</xsl:when>
								<xsl:when test="(@name = 'connect')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (nodeField.equals("DEF") || nodeField.equals("USE") || nodeField.startsWith("css") || nodeField.startsWith("containerField"))
		{
			String errorNotice = ConfigurationProperties.ERROR_ILLEGAL_VALUE +
						   ": connect statement cannot modify DEF, USE, cssClass or containerField value of an internal node. ";
			String connect_description = "connect protoField='" + protoField + "' nodeField='" + nodeField + "'. ";
			validationResult.append(connect_description).append("\n").append(errorNotice).append("\n");
		}
]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ComposedShader') or ($name = 'PackagedShader')">
<!--
		for (field field : fieldList) // check each field
		{
			field.validate(); // exercise field checks to ensure connected and valid
			validationResult.append(field.getValidationResult());
		}
-->
									<xsl:text disable-output-escaping="yes"><![CDATA[
]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'HAnimDisplacer')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
         // test for correct parent
         X3DConcreteElement parent = getParent();
         if (hasParent())
         {
            if (!parent.getElementName().equals(HAnimJoint.NAME) && !parent.getElementName().equals(HAnimSegment.NAME) &&
                !parent.getElementName().equals(ProtoBody.NAME) && !parent.getElementName().equals(field.NAME) && !parent.getElementName().equals(fieldValue.NAME))
            {
                String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +
                    ": illegal parent for ]]></xsl:text>
                         <xsl:value-of select="$name"/>
                         <xsl:text> DEF='" + getDEF() + "'</xsl:text>
                         <xsl:text disable-output-escaping="yes"><![CDATA[, found " + parent.getElementName() + " instead of HAnimJoint or HAnimSegment" ;
                validationResult.append(errorNotice).append("\n");
                throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
            }
        }
]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'HAnimJoint')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
         // test for correct parent
         X3DConcreteElement parent = getParent();
         if (hasParent())
         {
            if (!parent.getElementName().equals(HAnimHumanoid.NAME) && !parent.getElementName().equals(HAnimJoint.NAME) &&
                !parent.getElementName().equals(ProtoBody.NAME) && !parent.getElementName().equals(field.NAME) && !parent.getElementName().equals(fieldValue.NAME))
            {
                String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +
                    ": illegal parent for ]]></xsl:text>
                         <xsl:value-of select="$name"/>
                         <xsl:text> DEF='" + getDEF() + "'</xsl:text>
                         <xsl:text disable-output-escaping="yes"><![CDATA[, found " + parent.getElementName() + " instead of HAnimJoint or HAnimHumanoid" ;
                validationResult.append(errorNotice).append("\n");
                throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
            }
        }
]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'HAnimSite')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
         // test for correct parent
         X3DConcreteElement parent = getParent();
         if (hasParent())
         {
            if (!parent.getElementName().equals(HAnimHumanoid.NAME) && !parent.getElementName().equals(HAnimSegment.NAME) &&
                !parent.getElementName().equals(Transform.NAME)     && !parent.getElementName().equals(LOD.NAME)          &&
                !parent.getElementName().equals(Switch.NAME)        && !parent.getElementName().equals(Collision.NAME)    &&
                !parent.getElementName().equals(Group.NAME)         && !parent.getElementName().equals(StaticGroup.NAME)  &&
                !parent.getElementName().equals(ProtoBody.NAME) && !parent.getElementName().equals(field.NAME) && !parent.getElementName().equals(fieldValue.NAME))
            {
                String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +
                    ": illegal parent for ]]></xsl:text>
                         <xsl:value-of select="$name"/>
                         <xsl:text> DEF='" + getDEF() + "'</xsl:text>
                         <xsl:text disable-output-escaping="yes"><![CDATA[, found " + parent.getElementName() + " instead of HAnimSegment children, or HAnimHumanoid field (sites, skeleton, viewpoints)" ;
                validationResult.append(errorNotice).append("\n");
                throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
            }
        }
]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'HAnimSegment')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
         // test for correct parent
         X3DConcreteElement parent = getParent();
         if (hasParent())
         {
            if (!parent.getElementName().equals(HAnimHumanoid.NAME) && !parent.getElementName().equals(HAnimJoint.NAME) &&
                !parent.getElementName().equals(ProtoBody.NAME) && !parent.getElementName().equals(field.NAME) && !parent.getElementName().equals(fieldValue.NAME))
            {
                String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +
                    ": illegal parent for ]]></xsl:text>
                         <xsl:value-of select="$name"/>
                         <xsl:text> DEF='" + getDEF() + "'</xsl:text>
                         <xsl:text disable-output-escaping="yes"><![CDATA[, found " + parent.getElementName() + " instead of HAnimJoint or HAnimHumanoid" ;
                validationResult.append(errorNotice).append("\n");
                throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
            }
        }
]]></xsl:text>
         <!-- leftover fragment
         <xsl:value-of select="$name"/>
         <xsl:value-of select="$jsaiClassSuffix"/>
         <xsl:text>.NAME))</xsl:text> -->
         <xsl:text>
             /* if (false) // TODO
             {
                 // now test for correct parent-child LOA4 relationship pair
                 if (!hasParentMatchingName(((HAnimJoint)parent).getName()))
                 {
                     String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +
                         ": illegal parent for </xsl:text>
                         <xsl:value-of select="$name"/>
                         <xsl:text> DEF='" + getDEF() + "'</xsl:text>
                         <xsl:text disable-output-escaping="yes"><![CDATA[, found " + ((</xsl:text>
                         <xsl:value-of select="$name"/>
                         <xsl:text disable-output-escaping="yes"><![CDATA[)parent).getName() + " instead of TODO (please report this error)" ;
                     validationResult.append(errorNotice).append("\n");
                     throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
                 }
             }
             else if (!parent.getElementName().equals(field.NAME)     && !parent.getElementName().equals(fieldValue.NAME) &&
                      !parent.getElementName().equals(ProtoBody.NAME) && !hasUSE())
             {
                 String naming = new String();
                 if (!getName().isEmpty())
                     naming = " name='" + getName() + "'";
                 String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +
                     ": " + NAME + " DEF='" + getDEF() + "'" + naming +
                     " illegal parent found: " + parent.getElementName() +" name='" + ((X3DConcreteNode)parent).getDEF() + "'";
                 if      (parent instanceof org.web3d.x3d.jsail.HAnim.HAnimHumanoid)
                          errorNotice += " name='" + ((HAnimHumanoid)parent).getName() + "'";
                 else if (parent instanceof org.web3d.x3d.jsail.HAnim.HAnimJoint)
                          errorNotice += " name='" + ((HAnimJoint)parent).getName() + "'";
                 else if (parent instanceof org.web3d.x3d.jsail.HAnim.HAnimSegment)
                          errorNotice += " name='" + ((HAnimSegment)parent).getName() + "'";
                 else if (parent instanceof org.web3d.x3d.jsail.HAnim.HAnimSite)
                          errorNotice += " name='" + ((HAnimSite)parent).getName() + "'";
                 validationResult.append(errorNotice).append("\n");
                 throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
             }
         }
// TODO: if LOA less than 4, need to modify this test to properly compare whether immediate parent is a legal ancestor.
// [warning] this is not a 100% test until the LOA 0..3 alias-matching algorithms are also added.
         */

]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'PixelTexture')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (image.size() != (getWidth() * getHeight()) + NUMBER_PARAMETERS) // validity check
		{
			String errorNotice = "*** Illegal length of PixelTexture image integer array (" + image.size() +
				") while ((width=" + getWidth() + " * height=" + getHeight() + " expects number of pixels=" + (getWidth() * getHeight());
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'PixelTexture3D')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (image.size() != (getWidth() * getHeight() * getDepth())) // validity check
		{
			String errorNotice = "*** Illegal length of PixelTexture3D integer array (" + image.size() +
				") while ((width=" + getWidth() + " * height=" + getHeight() + " * depth=" + getDepth() + " expects number of pixels=" + (getWidth() * getHeight() * getDepth());
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
]]></xsl:text>
								</xsl:when>

								<!-- TODO review ProtoInstance checks
									<xsl:when test="($name = 'ProtoInstance')">
										<xsl:text>		// now check corresponding prototype declaration fields
		if (findAncestorScene() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				String errorNotice = "*** ProtoDeclare name='" + getName() + "' must first be connected to Scene scene graph in order to get checked.";
				validationResult.append(errorNotice).append("\n");
			}
			return "PrototypeNotFoundWhenNotConnectedToSceneGraph"; // not found
		}
		X3DConcreteElement declarationElement = findAncestorScene().findElementByNameValue(getName(), ProtoDeclare.NAME);
		if (declarationElement instanceof org.web3d.x3d.jsail.Core.ProtoDeclare)
		{
			field field = ((ProtoDeclare) declarationElement).getProtoInterface().findFieldByName(fieldName);
			if  (field != null)
				 result = field.getType();
			else result = "FieldDeclarationNotFound";
		}
		declarationElement = findAncestorScene().findElementByNameValue(getName(), ExternProtoDeclare.NAME);
		if (declarationElement instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclare)
		{
			field field = ((ExternProtoDeclare) declarationElement).findFieldByName(fieldName);
			if  (field != null)
				 result = field.getType();
			else result = "FieldDeclarationNotFound";
		}
</xsl:text>
									</xsl:when>
									-->
								<!-- ProtoBody might contain only comments
								<xsl:when test="(@name = 'ProtoBody')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((primaryNode == null) && !getChildren().isEmpty()) // must have primaryNode if any children are present
		{
			String errorNotice = "*** ProtoBody primaryNode is null, but getChildren() has" + getChildren().size() + " entries";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
		}
]]></xsl:text>
								</xsl:when> -->
							</xsl:choose>

							<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) or ($name = 'ProtoInstance')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
		if (getIS() != null)
		{
			if (getIS().getConnectList().isEmpty())
			{
				String errorNotice = "*** IS statement present, but contains no connect statements";
				validationResult.append(errorNotice).append("\n");
				throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
			}
			// TODO also check that this node has ancestor ProtoBody, and that a field with same name also exists, so that IS is legal
		}]]></xsl:text>
							</xsl:if>
							<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) and not($name = 'ProtoInstance')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
		if (!getContainerFieldOverride().isBlank() &&
			!Arrays.asList(containerField_ALLOWED_VALUES).contains(getContainerFieldOverride()))
		{
			String errorNotice = ConfigurationProperties.ERROR_ILLEGAL_VALUE +
				": illegal value encountered, containerField='" + getContainerFieldOverride() +
				"' but allowed values are containerField_ALLOWED_VALUES='" +
				new MFString(containerField_ALLOWED_VALUES).toStringX3D() + "'.";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
		}]]></xsl:text>
							</xsl:if>
							<!-- profileNameChoices checking, add validation test if appropriate -->
							<xsl:variable name="profileNameChoicesAppinfo" select="false()"/>
							<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
							<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
							<xsl:choose>
								<xsl:when test="($isX3dStatement = 'true') or ($name = 'CommentsBlock')">
									<!-- no validation test needed, all X3D statements allowed in all X3D profiles -->
								</xsl:when>
								<xsl:otherwise>
									<xsl:text disable-output-escaping="yes"><![CDATA[

		// profile validation test, if connected to full scene
		if (findAncestorX3D() != null)
		{
			String     modelProfile = findAncestorX3D().getProfile();
]]></xsl:text>
<!--
			headObject modelHead    = findAncestorX3D().getHead();

			// check whether model has a satisfactory component statement for this node
			ArrayList<component> sceneComponentsList = new ArrayList<>();
            if (modelHead != null)
				sceneComponentsList = modelHead.getComponentList();
			boolean hasSatisfactoryComponent = false;
			for (component nextComponent : sceneComponentsList)
			{
				if ( nextComponent.getName().equals("CADGeometry") &&
					(nextComponent.getLevel() >= 2))
					hasSatisfactoryComponent = true;
			}
-->
									<xsl:text disable-output-escaping="yes"><![CDATA[
			// check whether model has a satisfactory profile for this node
			boolean hasSatisfactorySupport = findAncestorX3D().supportsX3dProfile   (modelProfile) ||
                                             findAncestorX3D().supportsX3dComponent (COMPONENT, LEVEL);

			if (!hasSatisfactorySupport)]]></xsl:text>
<!--
			if (!hasSatisfactoryComponent &&]]></xsl:text>
			<xsl:for-each select="(//SimpleTypeEnumerations/SimpleType[@name='profileNameChoices']/enumeration/allowedElement[.=$name])">
				<xsl:text>
				!modelProfile.equals("</xsl:text><xsl:value-of select="../@value"/><xsl:text disable-output-escaping="yes"><![CDATA[") &&]]></xsl:text>
			</xsl:for-each>
				<xsl:text disable-output-escaping="yes"><![CDATA[
				!modelProfile.equals("Full"))
-->
									<xsl:text disable-output-escaping="yes"><![CDATA[
			{
				String errorNotice = ConfigurationProperties.ERROR_ILLEGAL_VALUE +
					" insufficient X3D profile='" + modelProfile +
					"' for current X3D model containing ']]></xsl:text><xsl:value-of select="$name"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[' node, ensure sufficient support by adding head statement <component name=']]></xsl:text><xsl:value-of select="$componentName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[' level=']]></xsl:text>
					<xsl:value-of select="$componentLevel"/>
					<xsl:text disable-output-escaping="yes"><![CDATA['/>\n" +
					"or Java source-code assignment: " +
					" findAncestorX3D().getHead().addComponent(\"]]></xsl:text><xsl:value-of select="$componentName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[\").setLevel(]]></xsl:text>
					<xsl:value-of select="$componentLevel"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[);";
				validationResult.append(errorNotice).append("\n");
				throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice); // report error
			}
		}]]></xsl:text>
								</xsl:otherwise>
							</xsl:choose>

							<xsl:text>
		return validationResult.toString();
	}
</xsl:text>
						</xsl:if>

						<!-- addComments() for single String -->
						<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
									  not(//field[@name = 'children']) and not($name = 'X3DLoaderDOM') and not($name = 'BlenderLauncher') and not($name = 'MeshLabLauncher') and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock')">
							<xsl:text>
		/**
		 * Utility method to add a comment to this </xsl:text>
							<xsl:value-of select="$name"/>
							<xsl:text>.
		 * @param newComment is new comment string to add to list of comments.
		 * @see CommentsBlock
	</xsl:text>
							<xsl:text>	 * @return {@link </xsl:text>
							<xsl:value-of select="$thisClassName"/>
							<xsl:text>} - namely </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
							<xsl:text>this</xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
							<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
		 */
		public </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addChild (String newComment) // found?
		{</xsl:text>
							<xsl:choose>
								<xsl:when test="//field[@name = 'children']">
									<xsl:text>
			addChild(new CommentsBlock(newComment));
			return this;</xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<xsl:text>
			commentsList.add(newComment);
			return this;</xsl:text>
								</xsl:otherwise>
							</xsl:choose>
							<xsl:text>
		}
	</xsl:text>
						</xsl:if>

						<xsl:choose><!-- utility methods for node-unique and statement-unique functionality -->

							<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ComposedShader') or ($name = 'PackagedShader') or ($name = 'ShaderPart')">
								<!-- field utilities -->
							<xsl:if test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ComposedShader') or ($name = 'PackagedShader')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Add field to fieldList for this ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text>
	 * @param newField is field to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ addField (field newField)
	{
		String errorNotice = "*** Illegal addField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ DEF='" + getDEF() + "', ";
        if (newField == null)
        {
            errorNotice += "provided null field";
            validationResult.append(errorNotice).append("\n");
            throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
        }
		for (field priorField : fieldList) // check for field with duplicate name
		{
			if (priorField.getName().equals(newField.getName()))
			{
				errorNotice += "provided duplicate newField name='" + newField.getName() + "', each field can only be defined once";
				validationResult.append(errorNotice).append("\n");
				throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
			}
		}
		String fieldValidationResult = newField.validate();
		if (!fieldValidationResult.trim().isEmpty())
		{
			errorNotice += "newField.validation() failure: " + fieldValidationResult;
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
		}
		fieldList.add(newField);
		newField.setParent(this);
		return this;
	}
	/**
	 * Remove a field from contained fieldList
	 * @param fieldToRemove matching field of interest
	 * @see #removeField(String)
	 * @return whether field was removed
	 */
	public boolean removeField (field fieldToRemove)
	{
		String errorNotice = "*** Illegal removeField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ DEF='" + getDEF() + "', ";
        if (fieldToRemove == null)
        {
            errorNotice += "provided null field";
            validationResult.append(errorNotice).append("\n");
            throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
        }
		int  fieldIndex = fieldList.indexOf(fieldToRemove);
		if  (fieldIndex >= 0)
		{
			 field removedField = fieldList.remove(fieldIndex);
			 return (removedField != null);
		}
		else return false;
	}
	/**
	 * Remove a field by name from contained fieldList
	 * @param fieldName matching field of interest
	 * @see #removeField(field)
	 * @return whether field was removed
	 */
	public boolean removeField (String fieldName)
	{
		String errorNotice = "*** Illegal removeField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ DEF='" + getDEF() + "', ";
        if ((fieldName == null) || fieldName.isEmpty())
        {
            errorNotice += "provided null or empty fieldName string";
            validationResult.append(errorNotice).append("\n");
            throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
        }
		field fieldToRemove = findFieldByName (fieldName);
		if (fieldToRemove != null)
			return removeField (fieldToRemove);
		else return false;
	}
	/**
	 * Clear all fields
	 */
	public void clearFields()
	{
		fieldList.clear();
	}
	/**
	 * Find contained field statement by name, if present.
	 * @param fieldName is name attribute for field of interest
	 * @return field reference of interest, null otherwise
	 */
	public field findFieldByName (String fieldName)
	{
		for (field element : fieldList)
		{
			 if (element.getName().equalsIgnoreCase(fieldName))
				 return element;
		}
		return null;
	}
	/**
	 * Determine if field statement is present.
	 * @param fieldName is name attribute for field of interest
	 * @return whether field is found
	 */
	public boolean hasField (String fieldName)
	{
		return (findFieldByName(fieldName) != null);
	}
]]></xsl:text>
<!-- field added to X3DUOM
	/**
	 * Determine whether field(s) are available
	 * @return whether field(s) are found
	 */
	public boolean hasField()
	{
		return !fieldList.isEmpty();
	}
	/**
	 * Provide list of fields.
	 * @return value of field list
	 */
	public ArrayList<field> getFieldList()
	{
		return fieldList;
	}
-->
							</xsl:if>
							<!-- ComposedShader, PackagedShader have no contained source code -->
                                                        <xsl:if test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ShaderPart')">
							<!-- now handled by X3DUOM
								<xsl:text disable-output-escaping="yes"><![CDATA[

	/**
	 * Set new source code (for example, JavaScript).
	 * <i>WARNING</i>: be sure to prepend <i>ecmascript:</i> prior to any actual source code.
	 * @param newSourceCode is source code to set
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setSourceCode (String[] newSourceCode)
	{
		return setSourceCode (Arrays.toString(newSourceCode));
	}

	/**
	 * Set new source code (for example, JavaScript).
	 * <i>WARNING</i>: be sure to prepend <i>ecmascript:</i> prior to any actual source code.
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#CDATA" target="_blank">X3D Scene Authoring Hints: CDATA Character Data</a>
	 * @param newSourceCode is source code to set
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setSourceCode (String newSourceCode)
	{
		String errorNotice = new String();
		if (newSourceCode == null)
		{
			errorNotice = "Illegal setSourceCode() invocation, String newSourceCode is null. ";
			validationResult.append(errorNotice).append("\n");
		}
		else if (newSourceCode.trim().isEmpty())
		{
			errorNotice = "Illegal setSourceCode() invocation, String newSourceCode is empty. ";
			validationResult.append(errorNotice).append("\n");
		}
		else if (newSourceCode.trim().startsWith("<![CDATA[") || newSourceCode.endsWith("]" + "]>"))
		{
			errorNotice = "Illegal setSourceCode() invocation, String newSourceCode is wrapped in <![CDATA[ ...(source)... ]]> block which can be omitted";
			validationResult.append(errorNotice).append("\n");
		}
		if (!newSourceCode.trim().startsWith("<![CDATA[") && !newSourceCode.trim().startsWith("ecmascript:"))
		{
			errorNotice = "Illegal setSourceCode() invocation, String newSourceCode must start with \"ecmascript:\"";
			validationResult.append(errorNotice).append("\n");
		}
		if (!errorNotice.isEmpty())
			throw new InvalidFieldValueException(errorNotice);

		sourceCode = newSourceCode;
		return this;
	}
]]></xsl:text>
-->
                                                            <xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Set new source code (for example, JavaScript), utility method using StringBuilder.
	 * <i>WARNING</i>: be sure to prepend <i>ecmascript:</i> prior to any actual source code.
	 * @param newSourceCode is source to set
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setSourceCode (StringBuilder newSourceCode)
	{
		if (newSourceCode == null)
		{
			String errorNotice = "*** Illegal setSourceCode() invocation, StringBuilder newSourceCode is null";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		else if (!newSourceCode.toString().trim().startsWith("ecmascript:") && (newSourceCode.toString().trim().length() > 0))
		{
			String errorNotice = "*** Illegal setSourceCode() invocation, StringBuilder newSourceCode must start with \"ecmascript:\"";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		setSourceCode(newSourceCode.toString()); // apply further diagnostics
		return this;
	}

	/**
	 * Append source code (for example, JavaScript)
	 * @param newSourceCode is source to append
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendSourceCode (String newSourceCode)
	{
		sourceCode += newSourceCode;
		return this;
	}

	/**
	 * Append source code (for example, JavaScript)
	 * @param newSourceCode is source to append
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendSourceCode (StringBuilder newSourceCode)
	{
		if (newSourceCode == null)
		{
			String errorNotice = "*** Illegal appendSourceCode() invocation, StringBuilder newSourceCode is null";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		else sourceCode += newSourceCode.toString();
		return this;
	}

	/**
	 * Clear all contained CDATA source code.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ clearSourceCode()
	{
		sourceCode = SOURCECODE_DEFAULT_VALUE;
		return this;
	}
]]></xsl:text>
								</xsl:if>
                                                        <!-- addField, findFieldByName methods are repeated for ProtoInterface and ExternProtoDeclare -->
							</xsl:when>
							<xsl:when test="($name = 'ProtoInterface') or ($name = 'ProtoBody') or ($name = 'ExternProtoDeclare')">
								<xsl:if test="($name = 'ProtoInterface') or ($name = 'ExternProtoDeclare')">
									<!-- addField, findFieldByName methods repeat a Script method -->
									<xsl:text>
	/**
	 * Add field to fieldList for this </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text>
	 * @param newField is field to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ addField (field newField)
	{
		String errorNotice = "*** Illegal addField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> </xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[ name='" + getName() + "', ";
        if (newField == null)
        {
            errorNotice += "provided null field";
            validationResult.append(errorNotice).append("\n");
            throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
        }
		for (field priorField : fieldList) // check for field with duplicate name
		{
			if (priorField.getName().equals(newField.getName()))
			{
				errorNotice += "trying to add field with duplicate name='" + newField.getName() + "'";
				validationResult.append(errorNotice).append("\n");
				throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
			}
		}
		String fieldValidationResult = newField.validate();
		if (!fieldValidationResult.trim().isEmpty())
		{
			errorNotice += "newField.validation() failure: " + fieldValidationResult;
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
		}
		fieldList.add(newField);
		newField.setParent(this);
		return this;
	}

	/**
	 * Find contained field statement by name, if present.
	 * @param fieldName is name attribute for field of interest
	 * @return field reference of interest, null otherwise
	 */
	public field findFieldByName (String fieldName)
	{
		for (field element : fieldList)
		{
			 if (element.getName().equalsIgnoreCase(fieldName))
				 return element;
		}
		return null;
	}
	/**
	 * Remove a field from contained fieldList
	 * @param fieldToRemove matching field of interest
	 * @see #removeField(String)
	 * @return whether field was removed
	 */
	public boolean removeField (field fieldToRemove)
	{
		String errorNotice = "*** Illegal removeField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/>
                <xsl:choose>
                    <xsl:when test="($name = 'ProtoInterface')">
                        <xsl:text> parent ProtoDeclare name='" + getName() + "', ";</xsl:text>
                    </xsl:when>
                    <xsl:when test="($name = 'ExternProtoDeclare')">
                        <xsl:text> name='" + getName() + "', ";</xsl:text>
                    </xsl:when>
                </xsl:choose>
				<xsl:text disable-output-escaping="yes"><![CDATA[
        if (fieldToRemove == null)
        {
            errorNotice += "provided null field";
            validationResult.append(errorNotice).append("\n");
            throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
        }
		int  fieldIndex = fieldList.indexOf(fieldToRemove);
		if  (fieldIndex >= 0)
		{
			 field removedField = fieldList.remove(fieldIndex);
			 return (removedField != null);
		}
		else return false;
	}
	/**
	 * Remove a field by name from contained fieldList
	 * @param fieldName matching field of interest
	 * @see #removeField(field)
	 * @return whether field was removed
	 */
	public boolean removeField (String fieldName)
	{
		String errorNotice = "*** Illegal removeField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/>
                <xsl:choose>
                    <xsl:when test="($name = 'ProtoInterface')">
                        <xsl:text> parent ProtoDeclare name='" + getName() + "', ";</xsl:text>
                    </xsl:when>
                    <xsl:when test="($name = 'ExternProtoDeclare')">
                        <xsl:text> name='" + getName() + "', ";</xsl:text>
                    </xsl:when>
                </xsl:choose>
				<xsl:text disable-output-escaping="yes"><![CDATA[
        if ((fieldName == null) || fieldName.isEmpty())
        {
            errorNotice += "provided null or empty fieldName string";
            validationResult.append(errorNotice).append("\n");
            throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
        }
		field fieldToRemove = findFieldByName (fieldName);
		if (fieldToRemove != null)
			return removeField (fieldToRemove);
		else return false;
	}
	/**
	 * Clear all fields
	 */
	public void clearFields()
	{
		fieldList.clear();
	}
	/**
	 * Determine if field statement is present.
	 * @param fieldName is name attribute for field of interest
	 * @return whether field is found
	 */
	public boolean hasField (String fieldName)
	{
		return (findFieldByName(fieldName) != null);
	}
]]></xsl:text>
								</xsl:if>
								<xsl:if test="($name = 'ProtoInterface') or ($name = 'ProtoBody')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to inspect parent ProtoDeclare and provide String value from inputOutput SFString field named <i>name</i>.
	 * @return value of name field in parent ProtoDeclare
	 * @see ProtoDeclare#getName
	 */
	public String getName()
	{
		if  (getParent() != null)
			 return ((ProtoDeclare)getParent()).getName();
		else return ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH +
				": " + getElementName() + "Object has no parent ProtoDeclare, thus getName() cannot be checked.";
	}
]]></xsl:text>
								</xsl:if>
							</xsl:when>
							<xsl:when test="($name = 'ProtoInstance')">
								<xsl:text>
	/**
	 * Add fieldValue
	 * @param newFieldValue is fieldValue to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ addFieldValue (fieldValue newFieldValue)
	{
		String errorNotice = "*** Illegal addFieldValue() invocation for ProtoInstance name='" + getName() +
					"' fieldValue name='" + newFieldValue.getName() + "', ";
        if (newFieldValue == null)
        {
            errorNotice += "provided null fieldValue";
            validationResult.append(errorNotice).append("\n");
            throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
        }
		for (fieldValue priorFieldValue : fieldValueList) // check for field with duplicate name
		{
			if (priorFieldValue.getName().equals(newFieldValue.getName()))
			{
				errorNotice += "trying to add fieldValue with duplicate name='" + newFieldValue.getName() + "'";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
		}
		String fieldValueValidationResult = newFieldValue.validate();
		if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed() &&
			!fieldValueValidationResult.trim().isEmpty())
		{
			errorNotice += "newFieldValue.validation() failure:\n   " + fieldValueValidationResult;
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
		}
		fieldValueList.add(newFieldValue);
		newFieldValue.setParent(this);
		return this;
	}

	/**
	 * Find contained fieldValue statement by name, if present.
	 * @param fieldValueName is name attribute for fieldValue of interest
	 * @return fieldValue reference of interest, null otherwise
	 */
	public fieldValue findFieldValueByName (String fieldValueName)
	{
		for (fieldValue element : fieldValueList)
		{
			 if (element.getName().equalsIgnoreCase(fieldValueName))
				 return element;
		}
		return null;
	}
	/**
	 * Remove a fieldValue from contained fieldValueList
	 * @param fieldValueToRemove matching fieldValue of interest
	 * @see #removeFieldValue(String)
	 * @return whether fieldValue was removed
	 */
	public boolean removeFieldValue (fieldValue fieldValueToRemove)
	{
		String errorNotice = "*** Illegal removeFieldValue() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ DEF='" + getDEF() + "', ";
        if (fieldValueToRemove == null)
        {
            errorNotice += "provided null fieldValue";
            validationResult.append(errorNotice).append("\n");
            throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
        }
		int  fieldValueIndex = fieldValueList.indexOf(fieldValueToRemove);
		if  (fieldValueIndex >= 0)
		{
			 fieldValue removedfieldValue = fieldValueList.remove(fieldValueIndex);
			 return (removedfieldValue != null);
		}
		else return false;
	}
	/**
	 * Remove a fieldValue by name from contained fieldValueList
	 * @param fieldValueName matching fieldValue of interest
	 * @see #removeFieldValue(fieldValue)
	 * @return whether fieldValue was removed
	 */
	public boolean removeFieldValue (String fieldValueName)
	{
		String errorNotice = "*** Illegal removeFieldValue() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ DEF='" + getDEF() + "', ";
        if ((fieldValueName == null) || fieldValueName.isEmpty())
        {
            errorNotice += "provided null or empty fieldValueName string";
            validationResult.append(errorNotice).append("\n");
            throw new org.web3d.x3d.sai.InvalidFieldException(errorNotice);
        }
		fieldValue fieldValueToRemove = findFieldValueByName (fieldValueName);
		if (fieldValueToRemove != null)
			return removeFieldValue (fieldValueToRemove);
		else return false;
	}
	/**
	 * Clear all fieldValues
	 */
	public void clearFieldValues()
	{
		fieldValueList.clear();
	}
	/**
	 * Determine if fieldValue statement is present.
	 * @param fieldValueName is name attribute for fieldValue of interest
	 * @return whether fieldValue is found
	 */
	public boolean hasFieldValue (String fieldValueName)
	{
		return (findFieldValueByName(fieldValueName) != null);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'Scene')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to add single X3DMetadataNode to contained list of existing Scene root nodes (if any).
         * <i>WARNING</i>: Scene is a statement that is implicit in several encodings and has no <i>metadata</i> field, so top-level metadata nodes are typically kept together within other top-level root nodes as Scene children.
	 * @param newValue is new node value to be appended the children field.
	 * @return {@link Scene} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	*/
	public Scene]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ addMetadata(X3DMetadataObject newValue)
	{
		if (newValue == null)
		{
			return this; // nothing else to do
		}
                // note Scene has no metadata field, add to children instead
		children.add((org.web3d.x3d.sai.Core.X3DNode)newValue);
		((X3DConcreteElement) newValue).setParent(this);
		return this;
	}
	/**
	 * Utility method to add single LayerSet to contained list of existing Scene root nodes (if any).
	 * @param newValue is new node value to be appended the children field.
	 * @return {@link Scene} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	*/
	public Scene]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ addLayerSet(LayerSet newValue)
	{
		if (newValue == null)
		{
			return this; // nothing else to do
		}
		children.add((org.web3d.x3d.sai.Core.X3DNode)newValue);
		((X3DConcreteElement) newValue).setParent(this);
		return this;
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'head')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Find contained meta statement by name, if present.
	 * @param metaName is NMTOKEN name attribute for meta statement of interest
	 * @return meta reference of interest, null otherwise
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#meta">X3D Tooltips: meta statement</a>
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 */
	public meta findMetaByName (String metaName)
	{
		for (meta element : metaList)
		{
			 if (element.getName().equalsIgnoreCase(metaName))
				 return element;
		}
		return null;
	}
	/**
	 * Determine whether relevant meta statement is present.
	 * @param metaName is name attribute for meta statement of interest
	 * @return whether meta is found.
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#meta">X3D Tooltips: meta statement</a>
	 */
	public boolean hasMeta (String metaName)
	{
		return (findMetaByName(metaName) != null);
	}

	/**
	 * Find contained component statement by name, if present.
	 * @param componentName name for component statement
	 * @return component reference of interest, null otherwise
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#component">X3D Tooltips: component</a>
	 */
	public component findComponentByName (String componentName)
	{
		for (component element : componentList)
		{
			 if (element.getName().equalsIgnoreCase(componentName))
				 return element;
		}
		return null;
	}
	/**
	 * Determine whether relevant component statement is present.
	 * @param componentName name for component statement
	 * @return whether component is found.
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#component">X3D Tooltips: component</a>
	 */
	public boolean hasComponent (String componentName)
	{
		return (findComponentByName(componentName) != null);
	}

	/**
	 * Find contained unit statement by name, if present.
	 * @param unitName is name attribute for unit statement of interest
	 * @return unit object reference of interest, null otherwise
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#unit">X3D Tooltips: unit</a>
	 */
	public unit findUnitByName (String unitName)
	{
		for (unit element : unitList)
		{
			 if (element.getName().equalsIgnoreCase(unitName))
				 return element;
		}
		return null;
	}
	/**
	 * Determine whether relevant unit statement is present.
	 * @param unitName is name attribute for unit statement of interest
	 * @return whether unit is found.
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#unit">X3D Tooltips: unit</a>
	 */
	public boolean hasUnit (String unitName)
	{
		return (findUnitByName(unitName) != null);
	}
]]></xsl:text>
							</xsl:when>
                            <xsl:when test="($name = 'Extrusion')">
                                    <xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Whether crossSection array is open or closed (closed means that endpoints are coincident).
* @return whether crossSection is closed, i.e. first and last points identical
* @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#Extrusion">X3D Tooltips: Extrusion</a>
*/
public boolean isCrossSectionClosed()
{
    boolean isClosed;
    if (crossSection == null) return false; // safety check
    int crossSectionTupleLength = crossSection.length / MFVec2f.TUPLE_SIZE;
    isClosed = (crossSectionTupleLength > 1) &&
    (crossSection[0] == crossSection[(crossSectionTupleLength-1)*2 + 0]) &&
    (crossSection[1] == crossSection[(crossSectionTupleLength-1)*2 + 1]);
    return isClosed;
}

/**
* Whether spine array is open or closed (closed means that endpoints are coincident).
* @return whether spine is closed, i.e. first and last points identical
*/
public boolean isSpineClosed()
{
    boolean isClosed;
    if (spine == null) return false; // safety check
    int spineTupleLength = spine.length / MFVec3f.TUPLE_SIZE;
    isClosed = (spineTupleLength > 1) &&
    (spine[0] == spine[(spineTupleLength-1)*3 + 0]) &&
    (spine[1] == spine[(spineTupleLength-1)*3 + 1]) &&
    (spine[2] == spine[(spineTupleLength-1)*3 + 2]);
    return isClosed;
}

/**
* Create SVG output file (with same base name) for Extrusion crossSection, if found.
* @see X3D#FILE_EXTENSION_SVG
* @see ConfigurationProperties#STYLESHEET_ExtrusionCrossSectionSVG
* @see X3D#toFileStylesheetConversion(String,String)
* @param fileName name of file to create and save, can include local directory path, must end with .svg
* @return File containing result (if operation succeeds), null otherwise
*/
public File toFileSvgCrossSection(String fileName)
{
    if (!(fileName.endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_SVG)))
    {
        throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with expected extension \"" + X3D.FILE_EXTENSION_SVG + "\"");
    }
    return findAncestorX3D().toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_ExtrusionCrossSectionSVG, fileName);
}
/**
 * Utility ccessor method to assign 4-tuple double array unit axis, angle (in radians) to initializeOnly MFRotation field named <i>orientation</i>.
 * <br><br>
 * <i>Tooltip:</i> The orientation array is a list of axis-angle 4-tuple values applied at each spine-aligned cross-section plane.
 * <ul>
 *  <li> <i>Hint:</i> if the orientation array contains a single 4-tuple value, it is applied at all spine-aligned crossSection planes. </li>
 *  <li> <i>Hint:</i>  number of values must all match for 3-tuple spine points, 2-tuple scale values, and 4-tuple orientation values. </li>
 * </ul>
 * @param newValue is new value for the orientation field.
 * @return {@link Extrusion} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
 */
    public Extrusion setOrientation(double[] newValue)
    {
        float[] floatArray = new float[newValue.length];
        for (int i = 0;i < newValue.length; i++)
        {
            floatArray[i] = (float) newValue[i];
        }
        setOrientation(floatArray);
        return this;
    }
]]></xsl:text>
							</xsl:when>
                            <xsl:when test="contains($name, 'PixelTexture')">
                                <xsl:choose>
                                    <xsl:when test="($name = 'PixelTexture')">
                                        <xsl:text disable-output-escaping="yes"><![CDATA[
    /** index of width parameter in image array */
    static final int WIDTH_INDEX  = 0;
    /** index of height parameter in image array */
    static final int HEIGHT_INDEX = 1;
    /** index of numberComponents parameter in image array */
    static final int NUMBER_COMPONENTS_INDEX = 2;
    /** number of initialization parameters in image array preceding pixel values */
    static final int NUMBER_PARAMETERS = 3;

    /**
     * Compute expected length of integer array based on width and height values.
	 * Note that each integer pixel value must represent the full set of components for this SFImage.
	 * @see #getWidth
	 * @see #getHeight
	 * @return number of pixel values expected in image integer array
	 */
	public int getExpectedLength()
	{
		return (getWidth() * getHeight());
	}
]]></xsl:text>
                                    </xsl:when>
                                    <xsl:when test="($name = 'PixelTexture3D')">
                                        <xsl:text disable-output-escaping="yes"><![CDATA[
    /** index of numberComponents parameter in image array */
    static final int NUMBER_COMPONENTS_INDEX = 0;
    /** index of width parameter in image array */
    static final int WIDTH_INDEX  = 1;
    /** index of height parameter in image array */
    static final int HEIGHT_INDEX = 2;
    /** index of depth parameter in image array */
    static final int DEPTH_INDEX  = 3;
    /** number of initialization parameters in image array preceding pixel values */
    static final int NUMBER_PARAMETERS = 4;

	/**
	 * Utility method to determine depth of texture from second element in <i>value</i> array.
	 * @return depth parameter of value field
	 */
	public int getDepth()
	{
        int depth = 0;
        if (image.size() >= NUMBER_PARAMETERS)
        {
            depth = image.get(DEPTH_INDEX);
            if ((depth < 0) || (depth > image.size()))
            {
                String errorNotice = "*** erroneous image depth=" + depth + " for ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[";
                validationResult.append(errorNotice).append("\n");
                throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
            }
        }
		return depth;
	}
    /**
     * Compute expected length of integer array (including height, width and depth values).
	 * Note that each integer pixel value must represent the full set of components for this SFImage.
	 * @see #getWidth
	 * @see #getHeight
	 * @see #getDepth
	 * @see #getNumberComponents
	 * @return number of pixel values expected in image integer array
	 */
	public int getExpectedLength()
	{
		return (getWidth() * getHeight() * getDepth());
	}
]]></xsl:text>
                                    </xsl:when>
                                </xsl:choose>
                                <xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to determine width of texture from initial element in <i>value</i> array.
	 * @return width parameter of value field
	 */
	public int getWidth()
	{
        int width = 0;
        if (image.size() >= NUMBER_PARAMETERS)
        {
            width = image.get(WIDTH_INDEX);
            if ((width < 0) || (width > image.size()))
            {
                String errorNotice = "*** erroneous image width=" + width + " for ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[";
                validationResult.append(errorNotice).append("\n");
                throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
            }
        }
		return width;
	}
	/**
	 * Utility method to determine height of texture from second element in <i>value</i> array.
	 * @return height parameter of value field
	 */
	public int getHeight()
	{
        int height = 0;
        if (image.size() >= NUMBER_PARAMETERS)
        {
            height = image.get(HEIGHT_INDEX);
            if ((height < 0) || (height > image.size()))
            {
                String errorNotice = "*** erroneous image height=" + height + " for ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[";
                validationResult.append(errorNotice).append("\n");
                throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
            }
        }
		return height;
	}
	/**
	 * Utility method to determine number of components of texture (1..4 components) from third element in <i>value</i> array.
	 * @return number of components for each element in value field
	 */
	public int getNumberComponents()
	{
        int numberComponents = 0;
        if (image.size() >= NUMBER_PARAMETERS)
        {
            numberComponents = image.get(NUMBER_COMPONENTS_INDEX);
            if ((numberComponents < 0) || (numberComponents > 4))
            {
                String errorNotice = "*** erroneous image numberComponents=" + numberComponents + " for ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[";
                validationResult.append(errorNotice).append("\n");
                throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
            }
        }
		return numberComponents;
	}
	/**
	 * Utility method to provide pixels (following parameters) in <i>value</i> array.
	 * @return pixels in image field
	 */
	public int[] getPixels()
	{
        int[] valuesArray = new int[0];
        if (image.size() >= NUMBER_PARAMETERS)
        {
            valuesArray = new int[image.size() - NUMBER_PARAMETERS];
            for (int i = NUMBER_PARAMETERS; i < image.size(); i++) {
                valuesArray[i - NUMBER_PARAMETERS] = image.get(i);
            }
        }
        return valuesArray;
	}
	// TODO public ArrayList<Integer> getPixelsList()

	/**
	 * Utility method to get String value of SFImage image field only, without size parameters.
	 * @return string value of pixels (only, no size parameters)
	 */
	public String getPixelsString()
    {
        StringBuilder result = new StringBuilder();
        String hexFormat = SFImage.getPixelHexFormat(getNumberComponents());

		int[] destinationPixels = getPixels();
		for (int i = 0; i < destinationPixels.length; i++)
        {
			result.append(String.format(hexFormat, destinationPixels[i]));
			result.append(" ");
		}
		return result.toString().trim();
	}
]]></xsl:text>
                            </xsl:when>
						</xsl:choose><!-- node-unique and statement-unique methods -->

					</xsl:if>

					<xsl:if test="($name = 'fieldValue') and not($isInterface = 'true')">
						<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Discover base type of this fieldValue declaration from corresponding ProtoDeclare/ExternProtoDeclare field declaration.
	 * Note that returned value might be empty string if never set in original field object.
	 * If found, provides String value ["SFBool" | "MFBool" | "SFColor" | "MFColor" | "SFColorRGBA" | "MFColorRGBA" | "SFDouble" | "MFDouble" | "SFFloat" | "MFFloat" | "SFImage" | "MFImage" | "SFInt32" | "SFNode" | "MFNode" | "MFInt32" | "SFRotation" | "MFRotation" | "SFString" | "MFString" | "SFTime" | "MFTime" | "SFVec2d" | "MFVec2d" | "SFVec2f" | "MFVec2f" | "SFVec3d" | "MFVec3d" | "SFVec3f" | "MFVec3f" | "SFVec4d" | "MFVec4d" | "SFVec4f" | "MFVec4f" | "SFMatrix3d" | "MFMatrix3d" | "SFMatrix3f" | "MFMatrix3f" | "SFMatrix4d" | "MFMatrix4d" | "SFMatrix4f" | "MFMatrix4f"] from inputOutput SFString field named <i>type</i>.
	 * <br><br>
	 * @see org.web3d.x3d.jsail.Core.field
	 * @return type value from corresponding field declaration, otherwise "fieldValueTypeNotFound"
	 */
	public String getType()
	{
		String prototypeName;
		String fieldValueType = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE; // default until found
		String errorNotice;

		if (getParent() == null)
		{
			errorNotice = ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH +
							": fieldValue name='" + getName() + "' is not currently connected to a ProtoInstance and thus getType() cannot be checked.";
			validationResult.append(errorNotice).append("\n");

			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				 throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
                 // ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE
			}
			else // missing type might allowably occur during object creation
			{
				return fieldValueType; // default is unknown type
            }
		}
		else prototypeName = ((ProtoInstance) getParent()).getName();

		field fieldDefinition = new field();
		Scene ancestorScene = findAncestorScene();
		if (ancestorScene == null)
		{
			errorNotice = "ProtoInstance name='" + prototypeName + "' with fieldValue  name='" + getName() + "' problem: " +
						   ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH;
			validationResult.append(errorNotice).append("\n");

			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				 throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
			}
			else // missing type might allowably occur during object creation
			{
				return fieldValueType; // default is unknown type
			}
		}
		X3DConcreteElement correspondingPrototype = ancestorScene.findElementByNameValue(prototypeName);
		if (correspondingPrototype == null)
		{
			errorNotice = "ProtoInstance name='" + prototypeName + "' does not have a corresponding " +
						  "ProtoDeclare or ExternProtoDeclare name='" + name + "' definition";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
		}
		correspondingPrototype = findAncestorScene().findElementByNameValue(prototypeName, ProtoDeclare.NAME);
		if (correspondingPrototype instanceof org.web3d.x3d.jsail.Core.ProtoDeclare)
		{
			fieldDefinition = ((ProtoDeclare) correspondingPrototype).getProtoInterface().findFieldByName(name);
			if (fieldDefinition != null)
				fieldValueType = fieldDefinition.getType(); // found in scene graph
			else
			{
				errorNotice = "fieldValue name='" + name + "' does not have a corresponding ProtoDeclare field name='" +
							   name + "' definition";
				validationResult.append(errorNotice).append("\n");
				throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
			}
			return fieldValueType; // might be empty string if never set in original field
		}
		// else
		correspondingPrototype = findAncestorScene().findElementByNameValue(prototypeName, ExternProtoDeclare.NAME);
		if (correspondingPrototype instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclare)
		{
			fieldDefinition = ((ExternProtoDeclare) correspondingPrototype).findFieldByName(name);
			if (fieldDefinition != null)
				fieldValueType = fieldDefinition.getType(); // found in scene graph
			else
			{
				errorNotice = "fieldValue name='" + name + "' does not have a corresponding ProtoDeclare field name='" +
							   name + "' definition";
				validationResult.append(errorNotice).append("\n");
				throw new org.web3d.x3d.sai.InvalidProtoException(errorNotice); // report error
			}
		}
		return fieldValueType; // might be empty string if never set in original field
	}
]]></xsl:text>
					</xsl:if>

					<xsl:if test="(($name = 'field') or ($name = 'fieldValue')) and not($isInterface = 'true')">

						<xsl:for-each select="//FieldTypes/FieldType">
							<xsl:variable name="fieldName" select="@type"/>
							<xsl:variable name="upperCaseFieldName" select="upper-case($fieldName)"/>
							<xsl:variable name="baseVariable">
								<xsl:choose>
									<xsl:when test="contains(@type,'String')">
										<xsl:text>value</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Bool')">
										<xsl:text>valueArrayBoolean</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Int32') or contains(@type,'Image')">
										<xsl:text>valueArrayInteger</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Float') or contains(@type,'Color') or contains(@type,'Rotation') or
													ends-with(@type,'f') or (@type = 'bboxSizeType')">
										<xsl:text>valueArrayFloat</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Double') or contains(@type,'Time') or ends-with(@type,'d')">
										<xsl:text>valueArrayDouble</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'FNode')">
										<!-- handled by getChildren method -->
									</xsl:when>
									<xsl:otherwise>
										<xsl:message>
											<xsl:text>*** unhandled baseVariable: </xsl:text>
											<xsl:value-of select="@type"/>
										</xsl:message>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="isSingletonType"><!-- tupleness -->
								<xsl:value-of select="(@type = 'MFBool')   or (@type = 'MFInt32') or (@type = 'MFDouble') or (@type = 'MFFloat') or
													  (@type = 'MFString') or (@type = 'MFTime')  or (@type = 'MFNode') or
													   starts-with(@type,'SF')"/>
							</xsl:variable>
							<xsl:variable name="javaPrimitiveType">
								<xsl:call-template name="javaType">
									<xsl:with-param name="x3dType" select="@type"/>
									<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="javaBaseType">
								<xsl:choose>
									<xsl:when test="contains($javaPrimitiveType,'[')">
										<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$javaPrimitiveType"/><!-- array of array type -->
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="tupleSize">
								<xsl:call-template name="tupleSize">
									<xsl:with-param name="x3dType" select="@type"/>
								</xsl:call-template>
							</xsl:variable>
<!-- debug
<xsl:if test="($debug = 'true')">
</xsl:if>
<xsl:message>
<xsl:text>// field ($fieldName=</xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:text>, $isSingletonType=</xsl:text>
<xsl:value-of select="$isSingletonType"/>
<xsl:text>, $javaPrimitiveType=</xsl:text>
<xsl:value-of select="$javaPrimitiveType"/>
<xsl:text>, $javaPrimitiveType=</xsl:text>
<xsl:value-of select="$javaBaseType"/>
<xsl:text>, $tupleSize=</xsl:text>
<xsl:value-of select="$tupleSize"/>
<xsl:text>)</xsl:text>
</xsl:message> -->
							<!-- typed get methods -->
							<xsl:choose>
								<xsl:when test="contains(@type,'FNode')">
									<!-- handled by getChildren() -->
								</xsl:when>
								<xsl:when test="starts-with(@type,'SF')">
									<xsl:text>
	/**
	 * If type matches, then get typed value of a </xsl:text><xsl:value-of select="$fieldName"/><xsl:text> </xsl:text><xsl:value-of select="$name"/><xsl:text> declaration.  For general accessor use:
         * @see getValue()
	 * @return typed value object (if values are available), otherwise returns default object
	 */
	public </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/>
		<xsl:text> getValue</xsl:text><xsl:value-of select="@type"/>
		<xsl:text>()
	{
		if (getType().equals(field.TYPE_</xsl:text><xsl:value-of select="$upperCaseFieldName"/><xsl:text>))
		{
			if (</xsl:text>
			<xsl:choose>
				<xsl:when test="(@type = 'SFString') or (@type = 'MFString')">
					<xsl:value-of select="$baseVariable"/>
					<xsl:text>.isEmpty())</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$baseVariable"/>
					<xsl:text>.length == 0)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>
			{
				return new </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/>
		<xsl:text>();
			}
			else</xsl:text>
			<xsl:choose>
				<xsl:when test="(@type = 'SFString') or (@type = 'MFString')">
					<!-- no further test needed -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:text> if (</xsl:text>
					<xsl:value-of select="$baseVariable"/>
					<xsl:text>.length == </xsl:text>
					<xsl:value-of select="$tupleSize"/>
					<xsl:text>)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>
			{
				return new </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>(</xsl:text><xsl:value-of select="$baseVariable"/>
					<xsl:if test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
						<xsl:text>[0]</xsl:text>
					</xsl:if>
					<xsl:text>);
			}</xsl:text>
			<xsl:if test="not(@type = 'SFString') and not(@type = 'MFString')">
				<xsl:text>
			else // hopefully this case cannot occur, possible internal library error
			{
				String errorNotice = "*** Invalid invocation of field.getValue</xsl:text>
					<xsl:if test="not(@type = 'SFString') and not(@type = 'MFString')">
						<xsl:value-of select="@type"/>
					</xsl:if>
					<xsl:text>() singleton method when field value='" +
									 </xsl:text><xsl:value-of select="$baseVariable"/><xsl:text> + "' has length=" + </xsl:text><xsl:value-of select="$baseVariable"/><xsl:text>.length;
				throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
			}</xsl:text>
			</xsl:if>
				<xsl:text>
		}
		else
		{
			String errorNotice = "*** Invalid invocation of field.getValue</xsl:text>
					<xsl:if test="not(@type = 'SFString') and not(@type = 'MFString')">
						<xsl:value-of select="@type"/>
					</xsl:if>
					<xsl:text>() when declared field type='" + getType() + "'";
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
	}
</xsl:text>
								</xsl:when>
								<xsl:when test="starts-with(@type,'MF')">
		<xsl:text>
	/**
	 * If type matches, then get typed value of a </xsl:text><xsl:value-of select="$fieldName"/><xsl:text> </xsl:text><xsl:value-of select="$name"/><xsl:text> declaration.  For general accessor use:
         * @see getValue()
	 * @return typed value object, if values are available
	 */
	public </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/>
		<xsl:text> getValue</xsl:text><xsl:value-of select="@type"/><xsl:text>()
	{
		if (getType().equals(field.TYPE_</xsl:text><xsl:value-of select="$upperCaseFieldName"/><xsl:text>))
		{
			return new </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(</xsl:text><xsl:value-of select="$baseVariable"/><xsl:text>);
		}
		else
		{
			String errorNotice = "*** Invalid invocation of field.getValue</xsl:text>
					<xsl:if test="not(@type = 'SFString') and not(@type = 'MFString')">
						<xsl:value-of select="@type"/>
					</xsl:if>
					<xsl:text>() when declared field type='" + getType() + "'";
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
	}
</xsl:text>
								</xsl:when>
							</xsl:choose>
							<!-- typed set methods -->
							<xsl:choose>
								<xsl:when test="contains(@type,'FNode')">
									<!-- handled by getChildren() -->
								</xsl:when>
								<xsl:when test="not(contains(@type,'FString'))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Set typed value of a ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text> </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.  For general accessor use:
         * @see getValue()
	 * <i>WARNING</i>: must first <i>setType()</i> in ancestor <i>field</i> declaration to ensure validity of the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text>
	 <xsl:value-of select="$name"/>
	 <xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> setValue(</xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> newValue)
	{
		clearValues();
		</xsl:text>
		<!-- no need to test array tupleSize since this is already an object -->
		<xsl:choose>
			<xsl:when test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
				<xsl:value-of select="$baseVariable"/>
				<xsl:text> = new </xsl:text><xsl:value-of select="$javaBaseType"/><xsl:text>[1]; // fix array size
		</xsl:text>
				<xsl:value-of select="$baseVariable"/>
				<xsl:text>[0] = newValue.getPrimitiveValue();</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<!-- no need to resize -->
				<xsl:value-of select="$baseVariable"/>
				<xsl:text> = newValue.getPrimitiveValue();</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>
		return this;
	}
</xsl:text>
								</xsl:when>
							</xsl:choose>
						</xsl:for-each>
						<!-- specialty set methods for field, fieldValue -->
						<xsl:text>
	/**
	 * Clear all values in a </xsl:text><xsl:value-of select="$name"/><xsl:text> declaration.  For general accessor use:
         * @see getValue()
	 * @return {@link </xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> clearValues()
	{
		value = VALUE_DEFAULT_VALUE;
		valueArrayBoolean = java.util.Arrays.copyOf(DEFAULT_VALUE_BOOLEAN, DEFAULT_VALUE_BOOLEAN.length); // must be separate copy
		valueArrayInteger = java.util.Arrays.copyOf(DEFAULT_VALUE_INTEGER, DEFAULT_VALUE_INTEGER.length); // must be separate copy
		valueArrayFloat   = java.util.Arrays.copyOf(DEFAULT_VALUE_FLOAT,   DEFAULT_VALUE_FLOAT.length  ); // must be separate copy
		valueArrayDouble  = java.util.Arrays.copyOf(DEFAULT_VALUE_DOUBLE,  DEFAULT_VALUE_DOUBLE.length ); // must be separate copy
		clearChildren(); // clear all contained children including nodes, statements and comments (if any)
		return this;
	}
	/**
	 * Set typed value of a boolean </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.  For general accessor use:
         * @see getValue()
	 * <i>WARNING</i>: must first <i>setType()</i> in ancestor <i>field</i> declaration to ensure validity of the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(boolean newValue)
	{
            if (!getType().isEmpty() &&
                !getType().equals(field.TYPE_SFBOOL) && !getType().equals(field.TYPE_MFBOOL) &&
                !(getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                String errorNotice = "*** Illegal type: cannot setValue(boolean " + newValue + ") when ]]></xsl:text>
                                     <xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
            clearValues();
            valueArrayBoolean = new boolean[1]; // fix array size
            valueArrayBoolean[0] = newValue;
            return this;
	}
	/**
	 * Set typed value of a boolean[] </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.  For general accessor use:
         * @see getValue()
	 * <i>WARNING</i>: must first <i>setType()</i> in ancestor <i>field</i> declaration to ensure validity of the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(boolean[] newValue)
	{
            if (!getType().isEmpty() &&
                !getType().equals(field.TYPE_SFBOOL) && !getType().equals(field.TYPE_MFBOOL) &&
                !(getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                String errorNotice = "*** Illegal type: cannot setValue(boolean[] " + newValue + ") array when ]]></xsl:text>
                                     <xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
            clearValues();
            if (newValue == null)
            {
                return this; // nothing else to do
            }
            valueArrayBoolean = newValue;
            return this;
	}
	/**
	 * Set typed value of a integer </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.  For general accessor use:
         * @see getValue()
	 * <i>WARNING</i>: must first <i>setType()</i> in ancestor <i>field</i> declaration to ensure validity of the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(int newValue)
	{
            // type promotions first
            if (getType().equals(field.TYPE_SFDOUBLE)  || getType().equals(field.TYPE_MFDOUBLE) ||
                getType().equals(field.TYPE_SFTIME)    || getType().equals(field.TYPE_MFTIME))
            {
                clearValues();
                valueArrayDouble = new double[1]; // fix array size
                valueArrayDouble[0] = (double) newValue;
                return this;
            }
            else if (!getType().isEmpty() &&
                      getType().equals(field.TYPE_SFFLOAT)   || getType().equals(field.TYPE_MFFLOAT))
            {
                clearValues();
                valueArrayFloat = new float[1]; // fix array size
                valueArrayFloat[0] = (float) newValue;
                return this;
            }
            else if (!getType().equals(field.TYPE_SFINT32) && !getType().equals(field.TYPE_MFINT32) &&
                     !(getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                String errorNotice = "*** Illegal type: cannot setValue(int " + newValue + ") when ]]></xsl:text>
                                     <xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
            else // integer type
            {
		clearValues();
		valueArrayInteger = new int[1]; // fix array size
		valueArrayInteger[0] = newValue;
		return this;
            }
	}
	/**
	 * Set typed value of a integer array </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.  For general accessor use:
         * @see getValue()
	 * <i>WARNING</i>: must first <i>setType()</i> in ancestor <i>field</i> declaration to ensure validity of the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(int[] newValue)
	{
            if (!getType().isEmpty() &&
                !getType().equals(field.TYPE_SFINT32) && !getType().equals(field.TYPE_MFINT32) &&
                !getType().equals(field.TYPE_SFIMAGE) && !getType().equals(field.TYPE_MFIMAGE) &&
                !(getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                String errorNotice = "*** Illegal type: cannot setValue(int[] " + newValue + ") array when ]]></xsl:text>
                                     <xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
            clearValues();
            if (newValue == null)
            {
                return this; // nothing else to do
            }
            valueArrayInteger = newValue;
            return this;
	}
	/**
	 * Set typed value of a float </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.  For general accessor use:
         * @see getValue()
	 * <i>WARNING</i>: must first <i>setType()</i> in ancestor <i>field</i> declaration to ensure validity of the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float newValue)
	{
            // type promotions first
            if (getType().equals(field.TYPE_SFDOUBLE)  || getType().equals(field.TYPE_MFDOUBLE) ||
                getType().equals(field.TYPE_SFTIME)    || getType().equals(field.TYPE_MFTIME))
            {
                clearValues();
                valueArrayDouble = new double[1]; // fix array size
                valueArrayDouble[0] = (double) newValue;
                return this;
            }
            if (!getType().isEmpty() &&
                 getType().equals(field.TYPE_SFFLOAT)    && !getType().equals(field.TYPE_MFFLOAT) &&
                 !(getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                String errorNotice = "*** Illegal type: cannot setValue(float " + newValue + ") when ]]></xsl:text>
                                     <xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
            clearValues();
            valueArrayFloat = new float[1]; // fix array size
            valueArrayFloat[0] = newValue;
            return this;
	}
	/**
	 * Set typed value of a float[] array </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.  For general accessor use:
         * @see getValue()
	 * <i>WARNING</i>: must first <i>setType()</i> in ancestor <i>field</i> declaration to ensure validity of the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float[] newValue)
	{
            // type promotions first
            if (getType().equals(field.TYPE_SFDOUBLE)  || getType().equals(field.TYPE_MFDOUBLE) ||
                getType().equals(field.TYPE_SFTIME)    || getType().equals(field.TYPE_MFTIME))
            {
                clearValues();
                valueArrayDouble = new double[newValue.length];
                for (int i = 0; i < newValue.length; i++)
                {
                    valueArrayDouble[i] = (double) newValue[i];
                }
                return this;
            }
            if (!getType().isEmpty() &&
                !getType().equals(field.TYPE_SFCOLOR)    && !getType().equals(field.TYPE_MFCOLOR)     &&
                !getType().equals(field.TYPE_SFCOLORRGBA)&& !getType().equals(field.TYPE_MFCOLORRGBA) &&
                !getType().equals(field.TYPE_SFFLOAT)    && !getType().equals(field.TYPE_MFFLOAT)     &&
                !getType().equals(field.TYPE_SFROTATION) && !getType().equals(field.TYPE_MFROTATION)  &&
                !getType().equals(field.TYPE_SFVEC2F)    && !getType().equals(field.TYPE_MFVEC2F)     &&
                !getType().equals(field.TYPE_SFVEC3F)    && !getType().equals(field.TYPE_MFVEC3F)     &&
                !getType().equals(field.TYPE_SFVEC4F)    && !getType().equals(field.TYPE_MFVEC4F)     &&
                !getType().equals(field.TYPE_SFMATRIX3F) && !getType().equals(field.TYPE_MFMATRIX3F)  &&
                !getType().equals(field.TYPE_SFMATRIX4F) && !getType().equals(field.TYPE_MFMATRIX4F)  &&
                !(getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                String errorNotice = "*** Illegal type: cannot setValue(float[] " + newValue + ") array when ]]></xsl:text>
                                                        <xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
            if (!getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) &&
                (newValue.length % X3DConcreteField.getTupleSize(getType())) != 0) // tupleSize modulus check
            {
                String errorNotice = "*** illegal number of values (" + newValue.length + ")" +
                                     " in initialization string, must be multiple of " + X3DConcreteField.getTupleSize(getType());
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice);
            }
            clearValues();
            if (newValue == null)
            {
                return this; // nothing else to do
            }
            valueArrayFloat = newValue;
            return this;
	}
	/**
	 * Set typed value of a double ]]></xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.  For general accessor use:
         * @see getValue()
	 * <i>WARNING</i>: must first <i>setType()</i> in ancestor <i>field</i> declaration to ensure validity of the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double newValue)
	{
            // type demotions first
            if (getType().equals(field.TYPE_SFFLOAT)    || getType().equals(field.TYPE_MFFLOAT))
            {
                clearValues();
                valueArrayFloat = new float[1]; // fix array size
                valueArrayFloat[0] = (float) newValue;
                String errorNotice = "*** (Warning) Type demotion: loss of precision may occur when setValue(double " + newValue + ") applied to ]]></xsl:text>
                                     <xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                return this;
            }</xsl:text>
	<xsl:text disable-output-escaping="yes"><![CDATA[
            if (!getType().isEmpty() &&
                !getType().equals(field.TYPE_SFDOUBLE)   && !getType().equals(field.TYPE_MFDOUBLE) &&
                !getType().equals(field.TYPE_SFTIME)     && !getType().equals(field.TYPE_MFTIME)   &&
                !(getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                String errorNotice = "*** Illegal type: cannot setValue(double " + newValue + ") when ]]></xsl:text>
                                     <xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
            clearValues();
            valueArrayDouble = new double[1]; // fix array size
            valueArrayDouble[0] = newValue;
            return this;
	}
	/**
	 * Set typed value of a double[] array </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.  For general accessor use:
         * @see getValue()
	 * <i>WARNING</i>: must first <i>setType()</i> in ancestor <i>field</i> declaration to ensure validity of the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double[] newValue)
	{
            // type demotions first
            if (getType().equals(field.TYPE_SFFLOAT)    || getType().equals(field.TYPE_MFFLOAT))
            {
                clearValues();
                valueArrayFloat = new float[newValue.length];
                for (int i = 0; i < newValue.length; i++)
                {
                    valueArrayFloat[i] = (float) newValue[i];
                }
                String errorNotice = "*** (Warning) Type demotion: loss of precision may occur when setValue(double[] " + newValue + ") array applied to ]]></xsl:text>
                                     <xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                return this;
            }</xsl:text>
	<xsl:text disable-output-escaping="yes"><![CDATA[
            if (!getType().isEmpty() &&
                !getType().equals(field.TYPE_SFDOUBLE)   && !getType().equals(field.TYPE_MFDOUBLE)   &&
                !getType().equals(field.TYPE_SFTIME)     && !getType().equals(field.TYPE_MFTIME)     &&
                !getType().equals(field.TYPE_SFFLOAT)    && !getType().equals(field.TYPE_MFFLOAT)    &&
                !getType().equals(field.TYPE_SFINT32)    && !getType().equals(field.TYPE_MFINT32)    &&
                !getType().equals(field.TYPE_SFVEC2D)    && !getType().equals(field.TYPE_MFVEC2D)    &&
                !getType().equals(field.TYPE_SFVEC3D)    && !getType().equals(field.TYPE_MFVEC3D)    &&
                !getType().equals(field.TYPE_SFVEC4D)    && !getType().equals(field.TYPE_MFVEC4D)    &&
                !getType().equals(field.TYPE_SFMATRIX3D) && !getType().equals(field.TYPE_MFMATRIX3D) &&
                !getType().equals(field.TYPE_SFMATRIX4D) && !getType().equals(field.TYPE_MFMATRIX4D) &&
                !(getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) && ConfigurationProperties.isCreationConnectionValidationExceptionAllowed()))
            {
                String errorNotice = "*** Illegal type: cannot setValue(double[] " + newValue + ") array when ]]></xsl:text>
                                     <xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ type='" + getType() + "'";
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice); // report error
            }
            if (!getType().equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) &&
                (newValue.length % X3DConcreteField.getTupleSize(getType())) != 0) // tupleSize modulus check
            {
                String errorNotice = "*** illegal number of values (" + newValue.length + ")" +
                                     " in initialization string, must be multiple of " + X3DConcreteField.getTupleSize(getType());
                validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice);
            }
            clearValues();
            if (newValue == null)
            {
                return this; // nothing else to do
            }
            valueArrayDouble = newValue;
            return this;
	}
]]></xsl:text>

					</xsl:if> <!-- end of field, fieldValue typed getValue methods -->
                                                                <!-- ($name='IndexedFaceSet') or ($name='IndexedLineSet') -->
								<xsl:if test="(($baseType = 'X3DComposedGeometryNode') or ($name = 'IndexedLineSet')) and not($isInterface = 'true')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to get number of coordinate 3-tuple values in contained Coordinate/CoordinateDouble or ProtoInstance node
	 * @see Coordinate
	 * @see CoordinateDouble
	 * @see ProtoInstance
	 * @return number of coordinate 3-tuple values
	 */
	public int getCoordCount()
	{
		if (getCoord() != null)
		{
			if      (getCoord() instanceof Coordinate)
				 return (((Coordinate      )getCoord()).getPoint().length / SFVec3f.TUPLE_SIZE);
			else if (getCoord() instanceof CoordinateDouble)
				 return (((CoordinateDouble)getCoord()).getPoint().length / SFVec3d.TUPLE_SIZE);
		}
		else if ((getCoordProtoInstance() != null) && getCoordProtoInstance().hasFieldValue())
		{
			for (fieldValue nextFieldValue : getCoordProtoInstance().getFieldValueList())
			{
				if      (nextFieldValue.getName().equals("point"))
					     return nextFieldValue.getValueMFVec3f().size();
				else if (nextFieldValue.getName().equals("point"))
					     return nextFieldValue.getValueMFVec3d().size();
			}
		}
		return 0; // otherwise
	}
	/**
	 * Utility method to get number of 3-tuple Color RGB values (or 4-tuple ColorRGBA values) in contained Color/ColorRGBA or ProtoInstance node
	 * @see Color
	 * @see ColorRGBA
	 * @see ProtoInstance
	 * @return number of color values
	 */
	public int getColorCount()
	{
		if (getColor() != null)
		{
			if      (getColor() instanceof Color)
			         return (((Color    )getColor()).getColor().length / SFColor.TUPLE_SIZE);
			else if (getColor() instanceof ColorRGBA)
				     return (((ColorRGBA)getColor()).getColor().length / SFColorRGBA.TUPLE_SIZE);
		}
		else if ((getColorProtoInstance() != null) && getColorProtoInstance().hasFieldValue())
		{
			for (fieldValue nextFieldValue : getColorProtoInstance().getFieldValueList())
			{
				if      (nextFieldValue.getName().equals("color"))
					     return nextFieldValue.getValueMFColor().size();
				else if (nextFieldValue.getName().equals("color"))
					     return nextFieldValue.getValueMFColorRGBA().size();
			}
		}
		return 0;
	}
]]></xsl:text>
								</xsl:if>
                                                                <!-- not included: ($name='IndexedLineSet') -->
								<xsl:if test="($baseType = 'X3DComposedGeometryNode') and not($isInterface = 'true')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to get number of 3-tuple normal vectors in contained Normal or ProtoInstance node
	 * @see Normal
	 * @see ProtoInstance
	 * @return number of color values
	 */
	public int getNormalCount()
	{
		if (getNormal() != null)
		{
			return (((Normal)getNormal()).getVector().length / MFVec3f.TUPLE_SIZE);
		}
		else if ((getNormalProtoInstance() != null) && getColorProtoInstance().hasFieldValue())
		{
			for (fieldValue nextFieldValue : getColorProtoInstance().getFieldValueList())
			{
				if      (nextFieldValue.getName().equals("normal"))
					     return nextFieldValue.getValueMFVec3f().size();
			}
		}
		return 0;
	}
	/**
	 * Utility method to get number of 2-tuple texture coordinate values in contained TextureCoordinate or ProtoInstance node
	 * @see TextureCoordinate
	 * @see MultiTextureCoordinate
	 * @see ProtoInstance
	 * @return number of color values
	 */
	public int getTexCoordCount()
	{
            if ((texCoord != null) && (texCoord instanceof org.web3d.x3d.jsail.Texturing.TextureCoordinate))
            {
                return (((org.web3d.x3d.jsail.Texturing.TextureCoordinate)texCoord).getPoint().length / SFVec2f.TUPLE_SIZE);
            }
            else if ((texCoord != null) && (texCoord instanceof org.web3d.x3d.jsail.Texturing.MultiTextureCoordinate))
            {
                if (((org.web3d.x3d.jsail.Texturing.MultiTextureCoordinate)texCoord).getTexCoordList().isEmpty())
                     return 0;
                else return (((org.web3d.x3d.jsail.Texturing.TextureCoordinate)((org.web3d.x3d.jsail.Texturing.MultiTextureCoordinate)texCoord).getTexCoordList().get(1)).getPoint().length / SFVec2f.TUPLE_SIZE);
            }
            else if ((getTexCoordProtoInstance() != null) && getTexCoordProtoInstance().hasFieldValue())
            {
                for (fieldValue nextFieldValue : getTexCoordProtoInstance().getFieldValueList())
                {
                    if (nextFieldValue.getName().equals("texcoord"))
                        return nextFieldValue.getValueMFVec2f().size();
                }
            }
            return 0;
	}
]]></xsl:text>
								</xsl:if>

					<!-- TODO consider pass-through methods for ProtoDeclare that hand off to contained (or provided) ProtoInterface -->
					<!-- end Additional per-class utility methods -->
				</xsl:when>
				<xsl:when test="not($hasInterfaceBlock) and not($hasImplementationBlock)"><!-- and no fields present for this interface -->
					<!-- note definition error -->
					<xsl:message>
						<xsl:text>*** No fields, neither interfaceBlock or implementationBlock found</xsl:text>
					</xsl:message>
					<xsl:text>
	// No field interfaces defined in X3D Object Model
</xsl:text>
				</xsl:when>
			</xsl:choose>

			<!-- additional utility methods -->
			<xsl:if test="not($isInterface = 'true') and not($isUtilityClass = 'true') and
							(($name = 'CommentsBlock') or ($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or
							 ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @return null, this method is deprecated and has no effect */
@Deprecated
/* @Override */
public org.web3d.x3d.sai.Core.X3DMetadataObject getMetadata()
{
    return null;
}

/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @param newValue ignored
 * @return unmodified object, this method is deprecated and has no effect */
@Deprecated]]></xsl:text>
    <xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
        <xsl:text>
/* @Override */</xsl:text>
    </xsl:if>
    <xsl:text>
public </xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:if test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
		<xsl:value-of select="$jsaiClassSuffix"/>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[	setMetadata(org.web3d.x3d.sai.Core.X3DMetadataObject newValue)
{
    return this; // no action
}
]]></xsl:text>
<!--
<xsl:text disable-output-escaping="yes"><![CDATA[
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @return empty string, this method is deprecated and has no effect */
@Deprecated
public String getDEF()
{
return "";
}
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @return empty string, this method is deprecated and has no effect */
@Deprecated
public String getUSE()
{
return "";
}
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @return empty string, this method is deprecated and has no effect */
@Deprecated
public String getCssClass()
{
return "";
}
]]></xsl:text>
-->
<xsl:text disable-output-escaping="yes"><![CDATA[
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @param newValue ignored
 * @return unmodified object, this method is deprecated and has no effect */
@Deprecated]]></xsl:text>
    <xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
        <xsl:text>
/* @Override */</xsl:text>
    </xsl:if>
    <xsl:text>
public </xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:if test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
		<xsl:value-of select="$jsaiClassSuffix"/>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setDEF(String newValue)
{
    return this; // no action
}
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @param newValue ignored
 * @return unmodified object, this method is deprecated and has no effect */
@Deprecated]]></xsl:text>
    <xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
        <xsl:text>
/* @Override */</xsl:text>
    </xsl:if>
    <xsl:text>
public </xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:if test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
		<xsl:value-of select="$jsaiClassSuffix"/>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setUSE(String newValue)
{
    return this; // no action
}]]></xsl:text>
    <xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
        <xsl:text>
/* @Override */</xsl:text>
    </xsl:if>
    <!--
    <xsl:text disable-output-escaping="yes"><![CDATA[
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @param newValue ignored
 * @return unmodified object, this method is deprecated and has no effect */
@Deprecated
public ]]></xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:if test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
		<xsl:value-of select="$jsaiClassSuffix"/>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setCssClass(String newValue)
{
    return this; // no action
}
]]></xsl:text>
-->
			</xsl:if>
			<xsl:if test="($name = 'CommentsBlock')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, it is only provided since a stub method is necessary to implement X3DChildNode interface.
 * @param fieldName ignored
 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_TYPE
 * @return ConfigurationProperties#ERROR_UNKNOWN_FIELD_TYPE, this method is deprecated and has no effect */
@Deprecated
@Override
public String getFieldType(String fieldName)
{
    return ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE; // unique return value avoids mistaken matches;
}
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, it is only provided since a stub method is necessary to implement X3DChildNode interface.
 * @param fieldName ignored
 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_ACCESSTYPE
 * @return ConfigurationProperties#ERROR_UNKNOWN_FIELD_ACCESSTYPE, this method is deprecated and has no effect */
@Deprecated
@Override
public String getAccessType(String fieldName)
{
    return ConfigurationProperties.ERROR_UNKNOWN_FIELD_ACCESSTYPE; // unique return value avoids mistaken matches;
}
]]></xsl:text>
			</xsl:if>

            <xsl:if test="($name = 'X3D')">
				<xsl:text disable-output-escaping="yes"><![CDATA[    /**
     * Confirm whether given version is supported by current X3D object.
     * @param otherVersion other X3D version to check
     * @return whether current X3D version is greater than or equal to otherVersion
     * @throws InvalidFieldValueException if provided with illegal value
     */
    public boolean supportsX3dVersion (String otherVersion) throws InvalidFieldValueException
    {
		if ((otherVersion == null || otherVersion.isEmpty()))
        {
            otherVersion = VERSION_DEFAULT_VALUE;
            System.out.println ("[warning] X3D.supportsX3dVersion{\"\") called with empty otherVersion value, substituting VERSION_DEFAULT_VALUE=" + VERSION_DEFAULT_VALUE);
        }

        if (!(
            otherVersion.equals(VERSION_3_0) ||
            otherVersion.equals(VERSION_3_1) ||
            otherVersion.equals(VERSION_3_2) ||
            otherVersion.equals(VERSION_3_3) ||
            otherVersion.equals(VERSION_4_0)))
        {
            String errorNotice = ConfigurationProperties.ERROR_ILLEGAL_VALUE + " illegal X3D version " + otherVersion;
            throw new InvalidFieldValueException(errorNotice);
        }
        return (getVersion().compareTo(otherVersion) >= 0); // Java string comparison
    }

    /**
     * Confirm whether given profile is supported by current X3D model
     * @param otherProfile different X3D profile for comparison
     * @return whether current X3D model supports otherProfile
     * @throws InvalidFieldValueException if provided with illegal value
     */
    public boolean supportsX3dProfile (String otherProfile) throws InvalidFieldValueException
    {
		if ((otherProfile == null || otherProfile.isEmpty()))
        {
            otherProfile = PROFILE_DEFAULT_VALUE;
            System.out.println ("[warning] X3D.supportsX3dProfile{\"\") called with empty otherProfile value, substituting PROFILE_DEFAULT_VALUE=" + PROFILE_DEFAULT_VALUE);
        }
        boolean legalProfile = profile.equals(PROFILE_CORE) ||
                               profile.equals(PROFILE_CADINTERCHANGE) ||
                               profile.equals(PROFILE_FULL) ||
                               profile.equals(PROFILE_IMMERSIVE) ||
                               profile.equals(PROFILE_INTERACTIVE) ||
                               profile.equals(PROFILE_INTERCHANGE) ||
                               profile.equals(PROFILE_MEDICALINTERCHANGE) ||
                               profile.equals(PROFILE_MPEG4INTERACTIVE);
        if (!legalProfile)
        {
            String errorNotice = ConfigurationProperties.ERROR_ILLEGAL_VALUE + " illegal X3D profile " + otherProfile;
            throw new InvalidFieldValueException(errorNotice);
        }
        boolean hasComponentCAD =    (head != null) && (head.hasComponent(component.NAME_CADGEOMETRY));
        boolean hasComponentVolume = (head != null) && (head.hasComponent(component.NAME_VOLUMERENDERING));

        boolean hasSupportedProfile =
            (     profile.equals(PROFILE_FULL)) ||  // FULL supports all profiles
			(otherProfile.equals(profile))      ||  // matched profiles
			(otherProfile.equals(PROFILE_CORE)) ||  // minimal CORE always supported

			(otherProfile.equals(PROFILE_INTERCHANGE) &&
                (!profile.equals(PROFILE_CORE))) || // any other profile is a superset

			(otherProfile.equals(PROFILE_INTERACTIVE) &&
                 (profile.equals(PROFILE_IMMERSIVE))) ||

			(otherProfile.equals(PROFILE_IMMERSIVE) &&
                 (profile.equals(PROFILE_IMMERSIVE))) ||

			(otherProfile.equals(PROFILE_CADINTERCHANGE) &&
                 (profile.equals(PROFILE_IMMERSIVE) && hasComponentCAD)) ||

			(otherProfile.equals(PROFILE_MEDICALINTERCHANGE) &&
                 (profile.equals(PROFILE_IMMERSIVE) && hasComponentVolume));

        return hasSupportedProfile;
    }

    /**
     * Confirm whether given component is supported by current X3D model,
     * [warning] no support for level tests yet.  TODO.
     * @param otherComponent other component to check
     * @param minimumLevel minimum level of component support needed
     * @return comparison result
     * @throws InvalidFieldValueException if provided with illegal value(s)
     */
    public boolean supportsX3dComponent (String otherComponent, int minimumLevel) throws InvalidFieldValueException
    {
		if ((otherComponent == null || otherComponent.isEmpty()))
        {
            System.out.println ("[warning] X3D.supportsX3dComponent(\"\"," + minimumLevel + ") called with empty otherComponent value, nothing to do, returning false");
            return false;
        }
		if ((minimumLevel < 1) || (minimumLevel > 5))
        {
            System.out.println ("[warning] X3D.supportsX3dComponent(\"" + otherComponent + "\") called with minimumLevel value outside allowed range [1..5], returning false");
            return false;
        }
        // check legal component values, throws InvalidFieldValueException if incorrect
        component componentTest = new component().setName(otherComponent).setLevel(minimumLevel);

        boolean hasComponentCADGEOMETRY          = (head != null) && (head.hasComponent(component.NAME_CADGEOMETRY));
        boolean hasComponentCORE                 = (head != null) && (head.hasComponent(component.NAME_CORE));
        boolean hasComponentCUBEMAPTEXTURING     = (head != null) && (head.hasComponent(component.NAME_CUBEMAPTEXTURING));
        boolean hasComponentDIS                  = (head != null) && (head.hasComponent(component.NAME_DIS));
        boolean hasComponentENVIRONMENTALEFFECTS = (head != null) && (head.hasComponent(component.NAME_ENVIRONMENTALEFFECTS));
        boolean hasComponentENVIRONMENTALSENSOR  = (head != null) && (head.hasComponent(component.NAME_ENVIRONMENTALSENSOR));
        boolean hasComponentEVENTUTILITIES       = (head != null) && (head.hasComponent(component.NAME_EVENTUTILITIES));
        boolean hasComponentFOLLOWERS            = (head != null) && (head.hasComponent(component.NAME_FOLLOWERS));
        boolean hasComponentGEOMETRY2D           = (head != null) && (head.hasComponent(component.NAME_GEOMETRY2D));
        boolean hasComponentGEOMETRY3D           = (head != null) && (head.hasComponent(component.NAME_GEOMETRY3D));
        boolean hasComponentGEOSPATIAL           = (head != null) && (head.hasComponent(component.NAME_GEOSPATIAL));
        boolean hasComponentGROUPING             = (head != null) && (head.hasComponent(component.NAME_GROUPING));
        boolean hasComponentH_ANIM               = (head != null) && (head.hasComponent(component.NAME_H_ANIM) || head.hasComponent(component.NAME_HANIM)); // v1 H-Anim and v2 HAnim
        boolean hasComponentINTERPOLATION        = (head != null) && (head.hasComponent(component.NAME_INTERPOLATION));
        boolean hasComponentKEYDEVICESENSOR      = (head != null) && (head.hasComponent(component.NAME_KEYDEVICESENSOR));
        boolean hasComponentLAYERING             = (head != null) && (head.hasComponent(component.NAME_LAYERING));
        boolean hasComponentLAYOUT               = (head != null) && (head.hasComponent(component.NAME_LAYOUT));
        boolean hasComponentLIGHTING             = (head != null) && (head.hasComponent(component.NAME_LIGHTING));
        boolean hasComponentNAVIGATION           = (head != null) && (head.hasComponent(component.NAME_NAVIGATION));
        boolean hasComponentNETWORKING           = (head != null) && (head.hasComponent(component.NAME_NETWORKING));
        boolean hasComponentNURBS                = (head != null) && (head.hasComponent(component.NAME_NURBS));
        boolean hasComponentPARTICLESYSTEMS      = (head != null) && (head.hasComponent(component.NAME_PARTICLESYSTEMS));
        boolean hasComponentPICKING              = (head != null) && (head.hasComponent(component.NAME_PICKING));
        boolean hasComponentPOINTINGDEVICESENSOR = (head != null) && (head.hasComponent(component.NAME_POINTINGDEVICESENSOR));
        boolean hasComponentRENDERING            = (head != null) && (head.hasComponent(component.NAME_RENDERING));
        boolean hasComponentRIGIDBODYPHYSICS     = (head != null) && (head.hasComponent(component.NAME_RIGIDBODYPHYSICS));
        boolean hasComponentSCRIPTING            = (head != null) && (head.hasComponent(component.NAME_SCRIPTING));
        boolean hasComponentSHADERS              = (head != null) && (head.hasComponent(component.NAME_SHADERS));
        boolean hasComponentSHAPE                = (head != null) && (head.hasComponent(component.NAME_SHAPE));
        boolean hasComponentSOUND                = (head != null) && (head.hasComponent(component.NAME_SOUND));
        boolean hasComponentTEXT                 = (head != null) && (head.hasComponent(component.NAME_TEXT));
        boolean hasComponentTEXTURING            = (head != null) && (head.hasComponent(component.NAME_TEXTURING));
        boolean hasComponentTEXTURING3D          = (head != null) && (head.hasComponent(component.NAME_TEXTURING3D));
        boolean hasComponentTIME                 = (head != null) && (head.hasComponent(component.NAME_TIME));
        boolean hasComponentVOLUMERENDERING      = (head != null) && (head.hasComponent(component.NAME_VOLUMERENDERING));

        int hasLevelCADGEOMETRY          = 0;
        int hasLevelCORE                 = 0;
        int hasLevelCUBEMAPTEXTURING     = 0;
        int hasLevelDIS                  = 0;
        int hasLevelENVIRONMENTALEFFECTS = 0;
        int hasLevelENVIRONMENTALSENSOR  = 0;
        int hasLevelEVENTUTILITIES       = 0;
        int hasLevelFOLLOWERS            = 0;
        int hasLevelGEOMETRY2D           = 0;
        int hasLevelGEOMETRY3D           = 0;
        int hasLevelGEOSPATIAL           = 0;
        int hasLevelGROUPING             = 0;
        int hasLevelHANIM                = 0;
        int hasLevelINTERPOLATION        = 0;
        int hasLevelKEYDEVICESENSOR      = 0;
        int hasLevelLAYERING             = 0;
        int hasLevelLAYOUT               = 0;
        int hasLevelLIGHTING             = 0;
        int hasLevelNAVIGATION           = 0;
        int hasLevelNETWORKING           = 0;
        int hasLevelNURBS                = 0;
        int hasLevelPARTICLESYSTEMS      = 0;
        int hasLevelPICKING              = 0;
        int hasLevelPOINTINGDEVICESENSOR = 0;
        int hasLevelRENDERING            = 0;
        int hasLevelRIGIDBODYPHYSICS     = 0;
        int hasLevelSCRIPTING            = 0;
        int hasLevelSHADERS              = 0;
        int hasLevelSHAPE                = 0;
        int hasLevelSOUND                = 0;
        int hasLevelTEXT                 = 0;
        int hasLevelTEXTURING            = 0;
        int hasLevelTEXTURING3D          = 0;
        int hasLevelTIME                 = 0;
        int hasLevelVOLUMERENDERING      = 0;

        if (head != null)
        {
            if (head.hasComponent(component.NAME_CADGEOMETRY))
                hasLevelCADGEOMETRY          = head.findComponentByName(component.NAME_CADGEOMETRY).getLevel();
            if (head.hasComponent(component.NAME_CORE))
                hasLevelCORE                 = head.findComponentByName(component.NAME_CORE).getLevel();
            if (head.hasComponent(component.NAME_CUBEMAPTEXTURING))
                hasLevelCUBEMAPTEXTURING     = head.findComponentByName(component.NAME_CUBEMAPTEXTURING).getLevel();
            if (head.hasComponent(component.NAME_DIS))
                hasLevelDIS                  = head.findComponentByName(component.NAME_DIS).getLevel();
            if (head.hasComponent(component.NAME_ENVIRONMENTALEFFECTS))
                hasLevelENVIRONMENTALEFFECTS = head.findComponentByName(component.NAME_ENVIRONMENTALEFFECTS).getLevel();
            if (head.hasComponent(component.NAME_ENVIRONMENTALSENSOR))
                hasLevelENVIRONMENTALSENSOR  = head.findComponentByName(component.NAME_ENVIRONMENTALSENSOR).getLevel();
            if (head.hasComponent(component.NAME_EVENTUTILITIES))
                hasLevelEVENTUTILITIES       = head.findComponentByName(component.NAME_EVENTUTILITIES).getLevel();
            if (head.hasComponent(component.NAME_FOLLOWERS))
                hasLevelFOLLOWERS            = head.findComponentByName(component.NAME_FOLLOWERS).getLevel();
            if (head.hasComponent(component.NAME_GEOMETRY2D))
                hasLevelGEOMETRY2D           = head.findComponentByName(component.NAME_GEOMETRY2D).getLevel();
            if (head.hasComponent(component.NAME_GEOMETRY3D))
                hasLevelGEOMETRY3D           = head.findComponentByName(component.NAME_GEOMETRY3D).getLevel();
            if (head.hasComponent(component.NAME_GEOSPATIAL))
                hasLevelGEOSPATIAL           = head.findComponentByName(component.NAME_GEOSPATIAL).getLevel();
            if (head.hasComponent(component.NAME_GROUPING))
                hasLevelGROUPING             = head.findComponentByName(component.NAME_GROUPING).getLevel();
            if (head.hasComponent(component.NAME_H_ANIM)) // v1 H-Anim
                hasLevelHANIM               = head.findComponentByName(component.NAME_H_ANIM).getLevel();
            if (head.hasComponent(component.NAME_HANIM))  // v2 HAnim
                hasLevelHANIM               = head.findComponentByName(component.NAME_HANIM).getLevel();
            if (head.hasComponent(component.NAME_INTERPOLATION))
                hasLevelINTERPOLATION        = head.findComponentByName(component.NAME_INTERPOLATION).getLevel();
            if (head.hasComponent(component.NAME_KEYDEVICESENSOR))
                hasLevelKEYDEVICESENSOR      = head.findComponentByName(component.NAME_KEYDEVICESENSOR).getLevel();
            if (head.hasComponent(component.NAME_LAYERING))
                hasLevelLAYERING             = head.findComponentByName(component.NAME_LAYERING).getLevel();
            if (head.hasComponent(component.NAME_LAYOUT))
                hasLevelLAYOUT               = head.findComponentByName(component.NAME_LAYOUT).getLevel();
            if (head.hasComponent(component.NAME_LIGHTING))
                hasLevelLIGHTING             = head.findComponentByName(component.NAME_LIGHTING).getLevel();
            if (head.hasComponent(component.NAME_NAVIGATION))
                hasLevelNAVIGATION           = head.findComponentByName(component.NAME_NAVIGATION).getLevel();
            if (head.hasComponent(component.NAME_NETWORKING))
                hasLevelNETWORKING           = head.findComponentByName(component.NAME_NETWORKING).getLevel();
            if (head.hasComponent(component.NAME_NURBS))
                hasLevelNURBS                = head.findComponentByName(component.NAME_NURBS).getLevel();
            if (head.hasComponent(component.NAME_PARTICLESYSTEMS))
                hasLevelPARTICLESYSTEMS      = head.findComponentByName(component.NAME_PARTICLESYSTEMS).getLevel();
            if (head.hasComponent(component.NAME_PICKING))
                hasLevelPICKING              = head.findComponentByName(component.NAME_PICKING).getLevel();
            if (head.hasComponent(component.NAME_POINTINGDEVICESENSOR))
                hasLevelPOINTINGDEVICESENSOR = head.findComponentByName(component.NAME_POINTINGDEVICESENSOR).getLevel();
            if (head.hasComponent(component.NAME_RENDERING))
                hasLevelRENDERING            = head.findComponentByName(component.NAME_RENDERING).getLevel();
            if (head.hasComponent(component.NAME_RIGIDBODYPHYSICS))
                hasLevelRIGIDBODYPHYSICS     = head.findComponentByName(component.NAME_RIGIDBODYPHYSICS).getLevel();
            if (head.hasComponent(component.NAME_SCRIPTING))
                hasLevelSCRIPTING            = head.findComponentByName(component.NAME_SCRIPTING).getLevel();
            if (head.hasComponent(component.NAME_SHADERS))
                hasLevelSHADERS              = head.findComponentByName(component.NAME_SHADERS).getLevel();
            if (head.hasComponent(component.NAME_SHAPE))
                hasLevelSHAPE                = head.findComponentByName(component.NAME_SHAPE).getLevel();
            if (head.hasComponent(component.NAME_SOUND))
                hasLevelSOUND                = head.findComponentByName(component.NAME_SOUND).getLevel();
            if (head.hasComponent(component.NAME_TEXT))
                hasLevelTEXT                 = head.findComponentByName(component.NAME_TEXT).getLevel();
            if (head.hasComponent(component.NAME_TEXTURING))
                hasLevelTEXTURING            = head.findComponentByName(component.NAME_TEXTURING).getLevel();
            if (head.hasComponent(component.NAME_TEXTURING3D))
                hasLevelTEXTURING3D          = head.findComponentByName(component.NAME_TEXTURING3D).getLevel();
            if (head.hasComponent(component.NAME_TIME))
                hasLevelTIME                 = head.findComponentByName(component.NAME_TIME).getLevel();
            if (head.hasComponent(component.NAME_VOLUMERENDERING))
                hasLevelVOLUMERENDERING      = head.findComponentByName(component.NAME_VOLUMERENDERING).getLevel();
        }

        if       (profile.equals(PROFILE_CORE))
        {
            hasComponentCORE                 = true;
                hasLevelCORE                 = Integer.max(hasLevelCORE, 1);
        }
        else if  (profile.equals(PROFILE_INTERCHANGE))
        {
            hasComponentCORE                 = true;
                hasLevelCORE                 = Integer.max(hasLevelCORE, 1);
            hasComponentTIME                 = true;
                hasLevelTIME                 = Integer.max(hasLevelTIME, 1);
            hasComponentNETWORKING           = true;
                hasLevelNETWORKING           = Integer.max(hasLevelNETWORKING, 1);
            hasComponentGROUPING             = true;
                hasLevelGROUPING             = Integer.max(hasLevelGROUPING, 1);
            hasComponentRENDERING            = true;
                hasLevelRENDERING            = Integer.max(hasLevelRENDERING, 3);
            hasComponentSHAPE                = true;
                hasLevelSHAPE                = Integer.max(hasLevelSHAPE, 1);
            hasComponentGEOMETRY3D           = true;
                hasLevelGEOMETRY3D           = Integer.max(hasLevelGEOMETRY3D, 2);
            hasComponentLIGHTING             = true;
                hasLevelLIGHTING             = Integer.max(hasLevelLIGHTING, 1);
            hasComponentTEXTURING            = true;
                hasLevelTEXTURING            = Integer.max(hasLevelTEXTURING, 2);
            hasComponentINTERPOLATION        = true;
                hasLevelINTERPOLATION        = Integer.max(hasLevelINTERPOLATION, 2);
            hasComponentNAVIGATION           = true;
                hasLevelNAVIGATION           = Integer.max(hasLevelNAVIGATION, 1);
            hasComponentENVIRONMENTALEFFECTS = true;
                hasLevelENVIRONMENTALEFFECTS = Integer.max(hasLevelENVIRONMENTALEFFECTS, 1);
        }
        else if (profile.equals(PROFILE_INTERACTIVE))
        {
            hasComponentCORE                 = true;
                hasLevelCORE                 = Integer.max(hasLevelCORE, 1);
            hasComponentTIME                 = true;
                hasLevelTIME                 = Integer.max(hasLevelTIME, 1);
            hasComponentNETWORKING           = true;
                hasLevelNETWORKING           = Integer.max(hasLevelNETWORKING, 2);
            hasComponentGROUPING             = true;
                hasLevelGROUPING             = Integer.max(hasLevelGROUPING, 2);
            hasComponentRENDERING            = true;
                hasLevelRENDERING            = Integer.max(hasLevelRENDERING, 3);
            hasComponentSHAPE                = true;
                hasLevelSHAPE                = Integer.max(hasLevelSHAPE, 1);
            hasComponentGEOMETRY3D           = true;
                hasLevelGEOMETRY3D           = Integer.max(hasLevelGEOMETRY3D, 3);
            hasComponentLIGHTING             = true;
                hasLevelLIGHTING             = Integer.max(hasLevelLIGHTING, 2);
            hasComponentTEXTURING            = true;
                hasLevelTEXTURING            = Integer.max(hasLevelTEXTURING, 2);
            hasComponentINTERPOLATION        = true;
                hasLevelINTERPOLATION        = Integer.max(hasLevelINTERPOLATION, 2);
            hasComponentPOINTINGDEVICESENSOR = true;
                hasLevelPOINTINGDEVICESENSOR = Integer.max(hasLevelPOINTINGDEVICESENSOR, 2);
            hasComponentKEYDEVICESENSOR      = true;
                hasLevelKEYDEVICESENSOR      = Integer.max(hasLevelKEYDEVICESENSOR, 1);
            hasComponentENVIRONMENTALSENSOR  = true;
                hasLevelENVIRONMENTALSENSOR  = Integer.max(hasLevelENVIRONMENTALSENSOR, 1);
            hasComponentNAVIGATION           = true;
                hasLevelNAVIGATION           = Integer.max(hasLevelNAVIGATION, 1);
            hasComponentENVIRONMENTALEFFECTS = true;
                hasLevelENVIRONMENTALEFFECTS = Integer.max(hasLevelENVIRONMENTALEFFECTS, 1);
            hasComponentEVENTUTILITIES       = true;
                hasLevelEVENTUTILITIES       = Integer.max(hasLevelEVENTUTILITIES, 1);
        }
        else if (profile.equals(PROFILE_IMMERSIVE))
        {
            hasComponentCORE                 = true;
                hasLevelCORE                 = Integer.max(hasLevelCORE, 2);
            hasComponentTIME                 = true;
                hasLevelTIME                 = Integer.max(hasLevelTIME, 1);
            hasComponentNETWORKING           = true;
                hasLevelNETWORKING           = Integer.max(hasLevelNETWORKING, 3);
            hasComponentGROUPING             = true;
                hasLevelGROUPING             = Integer.max(hasLevelGROUPING, 2);
            hasComponentRENDERING            = true;
                hasLevelRENDERING            = Integer.max(hasLevelRENDERING, 3);
            hasComponentSHAPE                = true;
                hasLevelSHAPE                = Integer.max(hasLevelSHAPE, 2);
            hasComponentGEOMETRY3D           = true;
                hasLevelGEOMETRY3D           = Integer.max(hasLevelGEOMETRY3D, 4);
            hasComponentGEOMETRY2D           = true;
                hasLevelGEOMETRY2D           = Integer.max(hasLevelGEOMETRY2D, 1);
            hasComponentTEXT                 = true;
                hasLevelTEXT                 = Integer.max(hasLevelTEXT, 1);
            hasComponentSOUND                = true;
                hasLevelSOUND                = Integer.max(hasLevelSOUND, 1);
            hasComponentLIGHTING             = true;
                hasLevelLIGHTING             = Integer.max(hasLevelLIGHTING, 2);
            hasComponentTEXTURING            = true;
                hasLevelTEXTURING            = Integer.max(hasLevelTEXTURING, 3);
            hasComponentINTERPOLATION        = true;
                hasLevelINTERPOLATION        = Integer.max(hasLevelINTERPOLATION, 2);
            hasComponentPOINTINGDEVICESENSOR = true;
                hasLevelPOINTINGDEVICESENSOR = Integer.max(hasLevelPOINTINGDEVICESENSOR, 1);
            hasComponentKEYDEVICESENSOR      = true;
                hasLevelKEYDEVICESENSOR      = Integer.max(hasLevelKEYDEVICESENSOR, 2);
            hasComponentENVIRONMENTALSENSOR  = true;
                hasLevelENVIRONMENTALSENSOR  = Integer.max(hasLevelENVIRONMENTALSENSOR, 2);
            hasComponentNAVIGATION           = true;
                hasLevelNAVIGATION           = Integer.max(hasLevelNAVIGATION, 2);
            hasComponentENVIRONMENTALEFFECTS = true;
                hasLevelENVIRONMENTALEFFECTS = Integer.max(hasLevelENVIRONMENTALEFFECTS, 2);
            hasComponentSCRIPTING            = true;
                hasLevelSCRIPTING            = Integer.max(hasLevelSCRIPTING, 1);
            hasComponentEVENTUTILITIES       = true;
                hasLevelEVENTUTILITIES       = Integer.max(hasLevelEVENTUTILITIES, 1);
        }
        else if (profile.equals(PROFILE_CADINTERCHANGE))
        {
            hasComponentCORE                 = true;
                hasLevelCORE                 = Integer.max(hasLevelCORE, 1);
            hasComponentNETWORKING           = true;
                hasLevelNETWORKING           = Integer.max(hasLevelNETWORKING, 2);
            hasComponentGROUPING             = true;
                hasLevelGROUPING             = Integer.max(hasLevelGROUPING, 1);
            hasComponentRENDERING            = true;
                hasLevelRENDERING            = Integer.max(hasLevelRENDERING, 4);
            hasComponentSHAPE                = true;
                hasLevelSHAPE                = Integer.max(hasLevelSHAPE, 2);
            hasComponentLIGHTING             = true;
                hasLevelLIGHTING             = Integer.max(hasLevelLIGHTING, 1);
            hasComponentTEXTURING            = true;
                hasLevelTEXTURING            = Integer.max(hasLevelTEXTURING, 2);
            hasComponentNAVIGATION           = true;
                hasLevelNAVIGATION           = Integer.max(hasLevelNAVIGATION, 2);
            hasComponentSHADERS              = true;
                hasLevelSHADERS              = Integer.max(hasLevelSHADERS, 1);
            hasComponentCADGEOMETRY          = true;
                hasLevelCADGEOMETRY          = Integer.max(hasLevelCADGEOMETRY, 1);
        }
        else if (profile.equals(PROFILE_MEDICALINTERCHANGE))
        {
            hasComponentCORE                 = true;
                hasLevelCORE                 = Integer.max(hasLevelCORE, 1);
            hasComponentTIME                 = true;
                hasLevelTIME                 = Integer.max(hasLevelTIME, 1);
            hasComponentNETWORKING           = true;
                hasLevelNETWORKING           = Integer.max(hasLevelNETWORKING, 2);
            hasComponentGROUPING             = true;
                hasLevelGROUPING             = Integer.max(hasLevelGROUPING, 3);
            hasComponentRENDERING            = true;
                hasLevelRENDERING            = Integer.max(hasLevelRENDERING, 5);
            hasComponentSHAPE                = true;
                hasLevelSHAPE                = Integer.max(hasLevelSHAPE, 3);
            hasComponentGEOMETRY3D           = true;
                hasLevelGEOMETRY3D           = Integer.max(hasLevelGEOMETRY3D, 2);
            hasComponentGEOMETRY2D           = true;
                hasLevelGEOMETRY2D           = Integer.max(hasLevelGEOMETRY2D, 2);
            hasComponentTEXT                 = true;
                hasLevelTEXT                 = Integer.max(hasLevelTEXT, 1);
            hasComponentLIGHTING             = true;
                hasLevelLIGHTING             = Integer.max(hasLevelLIGHTING, 2);
            hasComponentTEXTURING            = true;
                hasLevelTEXTURING            = Integer.max(hasLevelTEXTURING, 2);
            hasComponentNAVIGATION           = true;
                hasLevelNAVIGATION           = Integer.max(hasLevelNAVIGATION, 3);
            hasComponentENVIRONMENTALEFFECTS = true;
                hasLevelENVIRONMENTALEFFECTS = Integer.max(hasLevelENVIRONMENTALEFFECTS, 1);
            hasComponentEVENTUTILITIES       = true;
                hasLevelEVENTUTILITIES       = Integer.max(hasLevelEVENTUTILITIES, 1);
            hasComponentTEXTURING3D          = true;
                hasLevelTEXTURING3D          = Integer.max(hasLevelTEXTURING3D, 2);
            hasComponentVOLUMERENDERING      = true;
                hasLevelVOLUMERENDERING      = Integer.max(hasLevelVOLUMERENDERING, 4);
        }
        else if (profile.equals(PROFILE_MPEG4INTERACTIVE))
        {
            hasComponentCORE                 = true;
                hasLevelCORE                 = Integer.max(hasLevelCORE, 1);
            hasComponentTIME                 = true;
                hasLevelTIME                 = Integer.max(hasLevelTIME, 1);
            hasComponentNETWORKING           = true;
                hasLevelNETWORKING           = Integer.max(hasLevelNETWORKING, 2);
            hasComponentGROUPING             = true;
                hasLevelGROUPING             = Integer.max(hasLevelGROUPING, 2);
            hasComponentRENDERING            = true;
                hasLevelRENDERING            = Integer.max(hasLevelRENDERING, 1);
            hasComponentSHAPE                = true;
                hasLevelSHAPE                = Integer.max(hasLevelSHAPE, 1);
            hasComponentGEOMETRY3D           = true;
                hasLevelGEOMETRY3D           = Integer.max(hasLevelGEOMETRY3D, 2);
            hasComponentLIGHTING             = true;
                hasLevelLIGHTING             = Integer.max(hasLevelLIGHTING, 1);
            hasComponentTEXTURING            = true;
                hasLevelTEXTURING            = Integer.max(hasLevelTEXTURING, 2);
            hasComponentINTERPOLATION        = true;
                hasLevelINTERPOLATION        = Integer.max(hasLevelINTERPOLATION, 1);
            hasComponentPOINTINGDEVICESENSOR = true;
                hasLevelPOINTINGDEVICESENSOR = Integer.max(hasLevelPOINTINGDEVICESENSOR, 1);
            hasComponentENVIRONMENTALSENSOR  = true;
                hasLevelENVIRONMENTALSENSOR  = Integer.max(hasLevelENVIRONMENTALSENSOR, 1);
            hasComponentNAVIGATION           = true;
                hasLevelNAVIGATION           = Integer.max(hasLevelNAVIGATION, 1);
            hasComponentENVIRONMENTALEFFECTS = true;
                hasLevelENVIRONMENTALEFFECTS = Integer.max(hasLevelENVIRONMENTALEFFECTS, 1);
        }

        boolean hasSupport =
            (profile.equals(PROFILE_FULL)) ||  // FULL supports all profiles

			(otherComponent.equals(component.NAME_CORE)                 && hasComponentCORE &&
                (minimumLevel <= hasLevelCORE)) ||  // minimal CORE always supported
			(otherComponent.equals(component.NAME_CADGEOMETRY)          && hasComponentCADGEOMETRY &&
                (minimumLevel <= hasLevelCADGEOMETRY)) ||
			(otherComponent.equals(component.NAME_CUBEMAPTEXTURING)     && hasComponentCUBEMAPTEXTURING &&
                (minimumLevel <= hasLevelCUBEMAPTEXTURING)) ||
			(otherComponent.equals(component.NAME_DIS)                  && hasComponentDIS &&
                (minimumLevel <= hasLevelDIS)) ||
			(otherComponent.equals(component.NAME_ENVIRONMENTALEFFECTS) && hasComponentENVIRONMENTALEFFECTS &&
                (minimumLevel <= hasLevelENVIRONMENTALEFFECTS)) ||
			(otherComponent.equals(component.NAME_ENVIRONMENTALSENSOR)  && hasComponentENVIRONMENTALSENSOR &&
                (minimumLevel <= hasLevelENVIRONMENTALSENSOR)) ||
			(otherComponent.equals(component.NAME_EVENTUTILITIES)       && hasComponentEVENTUTILITIES &&
                (minimumLevel <= hasLevelEVENTUTILITIES)) ||
			(otherComponent.equals(component.NAME_FOLLOWERS)            && hasComponentFOLLOWERS &&
                (minimumLevel <= hasLevelFOLLOWERS)) ||
			(otherComponent.equals(component.NAME_GEOMETRY2D)           && hasComponentGEOMETRY2D &&
                (minimumLevel <= hasLevelGEOMETRY2D)) ||
			(otherComponent.equals(component.NAME_GEOMETRY3D)           && hasComponentGEOMETRY3D &&
                (minimumLevel <= hasLevelGEOMETRY3D)) ||
			(otherComponent.equals(component.NAME_GEOSPATIAL)           && hasComponentGEOSPATIAL &&
                (minimumLevel <= hasLevelGEOSPATIAL)) ||
			(otherComponent.equals(component.NAME_GROUPING)             && hasComponentGROUPING &&
                (minimumLevel <= hasLevelGROUPING)) ||
			((otherComponent.equals(component.NAME_H_ANIM) || otherComponent.equals(component.NAME_HANIM))
                                                                        && hasComponentH_ANIM &&
                (minimumLevel <= hasLevelHANIM)) ||
			(otherComponent.equals(component.NAME_INTERPOLATION)        && hasComponentINTERPOLATION &&
                (minimumLevel <= hasLevelINTERPOLATION)) ||
			(otherComponent.equals(component.NAME_KEYDEVICESENSOR)      && hasComponentKEYDEVICESENSOR &&
                (minimumLevel <= hasLevelKEYDEVICESENSOR)) ||
			(otherComponent.equals(component.NAME_LAYERING)             && hasComponentLAYERING &&
                (minimumLevel <= hasLevelLAYERING)) ||
			(otherComponent.equals(component.NAME_LAYOUT)               && hasComponentLAYOUT &&
                (minimumLevel <= hasLevelLAYOUT)) ||
			(otherComponent.equals(component.NAME_INTERPOLATION)        && hasComponentINTERPOLATION &&
                (minimumLevel <= hasLevelINTERPOLATION)) ||
			(otherComponent.equals(component.NAME_LIGHTING)             && hasComponentLIGHTING &&
                (minimumLevel <= hasLevelLIGHTING)) ||
			(otherComponent.equals(component.NAME_NAVIGATION)           && hasComponentNAVIGATION &&
                (minimumLevel <= hasLevelNAVIGATION)) ||
			(otherComponent.equals(component.NAME_NETWORKING)           && hasComponentNETWORKING &&
                (minimumLevel <= hasLevelNETWORKING)) ||
			(otherComponent.equals(component.NAME_NURBS)                && hasComponentNURBS &&
                (minimumLevel <= hasLevelNURBS)) ||
			(otherComponent.equals(component.NAME_PARTICLESYSTEMS)      && hasComponentPARTICLESYSTEMS &&
                (minimumLevel <= hasLevelPARTICLESYSTEMS)) ||
			(otherComponent.equals(component.NAME_PICKING)              && hasComponentPICKING &&
                (minimumLevel <= hasLevelPICKING)) ||
			(otherComponent.equals(component.NAME_POINTINGDEVICESENSOR) && hasComponentPOINTINGDEVICESENSOR &&
                (minimumLevel <= hasLevelPOINTINGDEVICESENSOR)) ||
			(otherComponent.equals(component.NAME_RENDERING)            && hasComponentRENDERING &&
                (minimumLevel <= hasLevelRENDERING)) ||
			(otherComponent.equals(component.NAME_RIGIDBODYPHYSICS)     && hasComponentRIGIDBODYPHYSICS &&
                (minimumLevel <= hasLevelRIGIDBODYPHYSICS)) ||
			(otherComponent.equals(component.NAME_SCRIPTING)            && hasComponentSCRIPTING &&
                (minimumLevel <= hasLevelSCRIPTING)) ||
			(otherComponent.equals(component.NAME_SHADERS)              && hasComponentSHADERS &&
                (minimumLevel <= hasLevelSHADERS)) ||
			(otherComponent.equals(component.NAME_SHAPE)                && hasComponentSHAPE &&
                (minimumLevel <= hasLevelSHAPE)) ||
			(otherComponent.equals(component.NAME_SOUND)                && hasComponentSOUND &&
                (minimumLevel <= hasLevelSOUND)) ||
			(otherComponent.equals(component.NAME_TEXT)                 && hasComponentTEXT &&
                (minimumLevel <= hasLevelTEXT)) ||
			(otherComponent.equals(component.NAME_TEXTURING)            && hasComponentTEXTURING &&
                (minimumLevel <= hasLevelTEXTURING)) ||
			(otherComponent.equals(component.NAME_TEXTURING3D)          && hasComponentTEXTURING3D &&
                (minimumLevel <= hasLevelTEXTURING3D)) ||
			(otherComponent.equals(component.NAME_TIME)                 && hasComponentTIME &&
                (minimumLevel <= hasLevelTIME)) ||
			(otherComponent.equals(component.NAME_VOLUMERENDERING)      && hasComponentVOLUMERENDERING &&
                (minimumLevel <= hasLevelVOLUMERENDERING));

        return hasSupport;
    }
]]></xsl:text>
            </xsl:if>

			<!-- finished source file definition -->
			<xsl:if test="($wrapClassBrackets)">
				<xsl:text>}</xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>

			<!-- debug
<xsl:message>
	<xsl:text>*** wrapClassBrackets close: $wrapClassBrackets=</xsl:text>
	<xsl:value-of select="$wrapClassBrackets"/>
</xsl:message>
-->

		</xsl:result-document> <!-- save file -->
    </xsl:if>
	</xsl:template><!-- sourceFile -->

    <!-- ===================================================== -->
    <!-- ===================================================== -->
    <!-- ===================================================== -->

    <!-- create fixed (unchanging) files -->

	<xsl:template name="FieldDefinitions">

		<xsl:variable name="subPackage">
			<xsl:choose>
				<xsl:when test="($modifySpecificationInterfaces = 'true')">
					<xsl:text>fields</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<!-- otherwise Java SAI specification has no subPackage for the interfaces, they go in the root package - very unusual. -->
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<!-- TODO specification: fix prose regarding X3DField, seems incorrect. -->
		<!-- TODO specification: change constant values to final, add toString method. -->
		<!-- TODO specification: add data types following MFString (officially approved version dates back to v3.0). -->
		<!-- Note that X3DFieldTypes an interface but it is not implemented by anything else. -->

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DFieldTypes</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Set of constants corresponding to each X3D field type and accessType.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>5.3 Field types</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>fieldsDef.html#FieldTypes</xsl:text></xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Enumeration constant <i>INPUT_ONLY</i> has value <i>1</i>. */
	public final int INPUT_ONLY = 1;
	/** Enumeration constant <i>INITIALIZE_ONLY</i> has value <i>2</i>. */
	public final int INITIALIZE_ONLY = 2;
	/** Enumeration constant <i>INPUT_OUTPUT</i> has value <i>3</i>. */
	public final int INPUT_OUTPUT = 3;
	/** Enumeration constant <i>OUTPUT_ONLY</i> has value <i>4</i>. */
	public final int OUTPUT_ONLY = 4;

	/** Enumeration constant <i>SFBOOL</i> has value <i>1</i>. */
	public final int SFBOOL = 1;
	/** Enumeration constant <i>MFBOOL</i> has value <i>2</i>. */
	public final int MFBOOL = 2;
	/** Enumeration constant <i>SFINT32</i> has value <i>3</i>. */
	public final int SFINT32 = 3;
	/** Enumeration constant <i>MFINT32</i> has value <i>4</i>. */
	public final int MFINT32 = 4;
	/** Enumeration constant <i>SFFLOAT</i> has value <i>5</i>. */
	public final int SFFLOAT = 5;
	/** Enumeration constant <i>MFFLOAT</i> has value <i>6</i>. */
	public final int MFFLOAT = 6;
	/** Enumeration constant <i>SFDOUBLE</i> has value <i>7</i>. */
	public final int SFDOUBLE = 7;
	/** Enumeration constant <i>MFDOUBLE</i> has value <i>8</i>. */
	public final int MFDOUBLE = 8;
	/** Enumeration constant <i>SFTIME</i> has value <i>9</i>. */
	public final int SFTIME = 9;
	/** Enumeration constant <i>MFTIME</i> has value <i>10</i>. */
	public final int MFTIME = 10;
	/** Enumeration constant <i>SFNODE</i> has value <i>11</i>. */
	public final int SFNODE = 11;
	/** Enumeration constant <i>MFNODE</i> has value <i>12</i>. */
	public final int MFNODE = 12;
	/** Enumeration constant <i>SFVEC2F</i> has value <i>13</i>. */
	public final int SFVEC2F = 13;
	/** Enumeration constant <i>MFVEC2F</i> has value <i>14</i>. */
	public final int MFVEC2F = 14;
	/** Enumeration constant <i>SFVEC3F</i> has value <i>15</i>. */
	public final int SFVEC3F = 15;
	/** Enumeration constant <i>MFVEC3F</i> has value <i>16</i>. */
	public final int MFVEC3F = 16;
	/** Enumeration constant <i>SFVEC3D</i> has value <i>17</i>. */
	public final int SFVEC3D = 17;
	/** Enumeration constant <i>MFVEC3D</i> has value <i>18</i>. */
	public final int MFVEC3D = 18;
	/** Enumeration constant <i>SFROTATION</i> has value <i>19</i>. */
	public final int SFROTATION = 19;
	/** Enumeration constant <i>MFROTATION</i> has value <i>20</i>. */
	public final int MFROTATION = 20;
	/** Enumeration constant <i>SFCOLOR</i> has value <i>21</i>. */
	public final int SFCOLOR = 21;
	/** Enumeration constant <i>MFCOLOR</i> has value <i>22</i>. */
	public final int MFCOLOR = 22;
	/** Enumeration constant <i>SFCOLORRGBA</i> has value <i>23</i>. */
	public final int SFCOLORRGBA = 23;
	/** Enumeration constant <i>MFCOLORRGBA</i> has value <i>24</i>. */
	public final int MFCOLORRGBA = 24;
	/** Enumeration constant <i>SFIMAGE</i> has value <i>25</i>. */
	public final int SFIMAGE = 25;
	/** Enumeration constant <i>MFIMAGE</i> has value <i>26</i>. */
	public final int MFIMAGE = 26;
	/** Enumeration constant <i>SFSTRING</i> has value <i>27</i>. */
	public final int SFSTRING = 27;
	/** Enumeration constant <i>MFSTRING</i> has value <i>28</i>. */
	public final int MFSTRING = 28;

	// added in v3.3
	/** Enumeration constant <i>SFVEC2D</i> has value <i>29</i>. */
	public final int SFVEC2D = 29;
	/** Enumeration constant <i>MFVEC2D</i> has value <i>30</i>. */
	public final int MFVEC2D = 30;
	/** Enumeration constant <i>SFVEC4F</i> has value <i>31</i>. */
	public final int SFVEC4F = 31;
	/** Enumeration constant <i>MFVEC4F</i> has value <i>32</i>. */
	public final int MFVEC4F = 32;
	/** Enumeration constant <i>SFVEC4D</i> has value <i>33</i>. */
	public final int SFVEC4D = 33;
	/** Enumeration constant <i>MFVEC4D</i> has value <i>34</i>. */
	public final int MFVEC4D = 34;
	/** Enumeration constant <i>SFMATRIX3F</i> has value <i>35</i>. */
	public final int SFMATRIX3F = 35;
	/** Enumeration constant <i>MFMATRIX3F</i> has value <i>36</i>. */
	public final int MFMATRIX3F = 36;
	/** Enumeration constant <i>SFMATRIX3D</i> has value <i>37</i>. */
	public final int SFMATRIX3D = 37;
	/** Enumeration constant <i>MFMATRIX3D</i> has value <i>38</i>. */
	public final int MFMATRIX3D = 38;
	/** Enumeration constant <i>SFMATRIX4F</i> has value <i>39</i>. */
	public final int SFMATRIX4F = 39;
	/** Enumeration constant <i>MFMATRIX4F</i> has value <i>40</i>. */
	public final int MFMATRIX4F = 40;
	/** Enumeration constant <i>SFMATRIX4D</i> has value <i>41</i>. */
	public final int SFMATRIX4D = 41;
	/** Enumeration constant <i>MFMATRIX4D</i> has value <i>42</i>. */
	public final int MFMATRIX4D = 42;
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- ===================================================== -->

		<!-- TODO specification Table 5.1 Topics index, _B_ should be _BROWSER_: 5.4.3 SAI_B_ConnectionError 5.4.4 SAI_B_Initialized 5.4.5 SAI_B_Shutdown 5.4.6 SAI_B_URLError -->
		<!-- ToDO B.4.2 X3DFieldEvent is incorrectly listed as class, but is actually interface -->
		<!-- TODO specification B.5.3 X3DFieldEvent is a duplicate and should be removed. -->
		<!-- TODO specification interface missing void as return type. -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DFieldEvent</xsl:text></xsl:with-param>
			<!-- Note that X3DFieldEvent is listed in specification as a class, but it gets generated alongside other SAI interfaces (not .jsail concretes) -->
			<xsl:with-param name="isAbstract"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>java.util.EventObject</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>The event type is implemented as the class X3DFieldEvent. This class contains methods for obtaining the source of the event, the time (in X3D time) and any user defined data that occurred with the event.</xsl:text></xsl:with-param>
			<!-- saiJavaSpecificationSection also has reference at 5.4.7 SAIFieldEvent -->
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.2 X3DFieldEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#EventTypesSAIFieldEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.4.2 SAIFieldEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text> @author Justin Couch
</xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[javadocBlock
	// unused
	/**
	 * Get the timestamp that this event occurred at.
	 * @return The time of this event, in X3D time coordinates.
	 */
	public double getTime();

	/**
	 * Construct a new X3DFieldEvent instance.
	 *
	 * @param sourceField The source field that generated this event
	 * @param newTimeStamp The timestamp of the event, in X3D time
	 * @param neweventDataObject Any user associated data with this event
	 */
	public X3DFieldEvent(Object sourceField, double newTimeStamp, Object neweventDataObject);

	/**
	 * Get data with this event.
	 * @return eventDataObject
	 */
	public Object getData();
]]></xsl:text>
			</xsl:with-param>
            <xsl:with-param name="implementationBlock">
                <xsl:text><![CDATA[
		/** The time stamp, in X3D time, that this event occurred at */
		protected double timeStamp;

		/** Passed field data for this event */
		protected Object eventDataObject;

		/**
		 * Construct a new X3DFieldEvent instance.
		 *
		 * @param sourceField The source field that generated this event
		 * @param newTimeStamp The timestamp of the event, in X3D time
		 * @param neweventDataObject Any user associated data with this event
		 */
		public X3DFieldEvent(Object sourceField, double newTimeStamp, Object neweventDataObject)
		{
			super(sourceField);

			timeStamp = newTimeStamp;
			eventDataObject = neweventDataObject;
		}

		/**
		 * Get the timestamp that this event occurred at.
		 * @return The time of this event, in X3D time coordinates.
		 */
		public double getTime()
		{
			return timeStamp;
		}

		/**
		 * Get data with this event.
		 * @return eventDataObject
		 */
		public Object getData()
		{
			return eventDataObject;
		}
	]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- ===================================================== -->

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>java.util.EventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Listener for events passing values from one X3D field to another.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.3 X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>6.3.20 registerBrowserInterest</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>servRef.html#RegisterBrowserInterest</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[
    /** Callback event handler
      * @param event callback event of interest
      */
	public void readableFieldChanged(X3DFieldEvent event);
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- ===================================================== -->

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Representation of a node's field definition.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.4 X3DFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#X3DFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>6.3.10 SAIFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>types.html#SAIFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
<p>
The field definition holds the static field information such as the field
access type, the data type and the name of the field.
</p>
<p>
The implementation of the toString() method of this class shall return the
full IDL declaration of the field as per the specification, not the UTF8 or
XML format. Implementation of <code>.equals()</code> shall return true if
the two field definitions share the same access type, data type and name. It
shall not include the underlying field's values at that point in time.
</p>

@author Justin Couch
</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
    /**
     * Get the name of this field. This will be something like "children"
     * or "translation". If the field is an exposed field then the name
     * give will be the base name without any <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>set_<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text> or <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>_changed<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
     * added to the name, regardless of how the initial field was fetched.
     *
     * @return The name of this field
     */
	public String getName();

    /**
     * Get the access type of the field. This will be one of field,
     * exposedField, eventIn or eventOut constants described in the
     * X3DFieldTypes interface.
     *
     * @return The access type of this node
     * @see org.web3d.x3d.sai.X3DFieldTypes
     */
	public int getAccessType();

    /**
     * Get the field type. This string represents the field type such as
     * MFNode, SFInt32. The definition of the returned int value is
     * described in the X3DFieldType interface.
     *
     * @return A constant describing the field type
     * @see org.web3d.x3d.sai.X3DFieldTypes
     */
	public int getFieldType();

    /**
     * Get the field type. This string represents the field type such as
     * MFNode, SFInt32, etc. A string is used to allow full extensibility.
     *
     * @return A string describing the field type
     */
	public String getFieldTypeString();
</xsl:with-param>
		</xsl:call-template>

		<!-- ===================================================== -->
	<!-- TODO cleanup, avoiding duplicate file generation, move javadoc -->
    <xsl:if test="false()">
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DField</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Base representation of a single-field (SF) X3D field type.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.5 X3DField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#X3DField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.13 SAIField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIField</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>4.4.2.2 Field semantics</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>concepts.html#FieldSemantics</xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock">
    /**
     * Get the definition of this field.
     *
     * @return The field definition to use
     */
    X3DFieldDefinition getDefinition();

    /**
     * Check to see if this field is readable. This may return two different
     * sets of values depending on the use. If this field is the field of a
     * script that has been passed to a script implementation, it will return
     * true if the field is an eventIn, exposedField or field and false for an
     * eventOut. If it is a field of any other circumstance (ie an external
     * application querying a node or a script querying another node it has a
     * reference to) it shall return true for eventOuts, exposedFields and
     * false for eventIn or field.
     * @return whether field is readable
     */
    boolean isReadable();

    /**
     * Check to see if this field is writable. This may return two different
     * sets of values depending on the use. If this field is the field of a
     * script that has been passed to a script implementation, it will return
     * true if the field is an eventOut, exposedField or field and false for an
     * eventIn. If it is a field of any other circumstance (ie an external
     * application querying a node or a script querying another node it has a
     * reference to) it shall return true for eventIns, exposedFields and
     * false for eventOut or field.
     *
     * @return true if the values of this field are readable
     */
    boolean isWritable();

    /**
     * <p>
     * Add a listener for changes in this field. This works for listening to
     * changes in a readable field. A future extension to the specification,
     * or a browser-specific extension, may allow for listeners to be added
     * to writable nodes as well.
     * </p>
     * <p>
     * A listener instance cannot have multiple simultaneous registrations.
     * If the listener instance is currently registered, this request shall
     * be silently ignored.
     * </p>
     *
     * @param listener The listener to add
     */
    void addX3DEventListener(X3DFieldEventListener listener);

    /**
     * Remove a listener for changes in the readable field. If the listener is
     * not currently registered, this request shall be silently ignored.
     *
     * @param listener The listener to remove
     */
    void removeX3DEventListener(X3DFieldEventListener listener);

</xsl:with-param>
<!-- TODO specification: these methods are never defined in specification other than the interface listing. Omitted.
    /**
     * Associate user data with this field. Whenever an field is generated
     * on this field, this data will be available with the Event through
     * its getData method.
     *
     * @param data The data to associate with this eventOut instance
     */
    void setUserData(Object data);

    /**
     * Get the user data that is associated with this field.
     *
     * @return The user data, if any, associated with this field
     */
    Object getUserData();
-->
		</xsl:call-template>
	</xsl:if>
		<!-- ===================================================== -->

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>MField</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DField</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Base interface for multiple-field (MF) array types.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.6 MField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#MField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text>
    /**
     * Get the size of the underlying data array. The size is the number of
     * elements for that data type. So for an MFFloat the size would be the
     * number of float values, but for an MFVec3f, it is the number of vectors
     * in the returned array (where a vector is 3 consecutive array indexes in
     * a flat array).
     *
     * @return The number of elements in this field array.
     */
	public int size();

    /**
     * Removes all values in the field array, changing the array size to zero.
     */
	public void clear();

    /**
     * Remove one element of the field array at index position, if found.  Initial element is at index 0.
     * @param index position of element in field array that gets removed
     */
	public void remove(int index);
</xsl:text></xsl:with-param>
		</xsl:call-template>

		<!-- ===================================================== -->

		<!-- TODO specification needs to be interface, not class -->
		<!-- TODO specification accessor methods missing trailing semicolons, should not have bodies -->
		<!-- TODO decide on best implementation and then add it -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>Matrix3</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Describes a 3x3 Matrix as required by the SAIMatrix abstract type.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.4 Matrix3</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#Matrix3</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.20 SAIMatrix</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIMatrix</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text><![CDATA[
@author Justin Couch
]]></xsl:text>
			</xsl:with-param>
			<!-- TODO: remove constructor definition from specification interface: public org.web3d.x3d.sai.Matrix3(); -->
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[

	public void setIdentity();

	public void set(int row, int column);

	public float get(int row, int column); // TODO SAI interface problem, needs to be double for Matrix3d Matrix4d types

//	public void setTransform(org.web3d.x3d.sai.SFVec3f translation, // TODO incompatible with double types
//		org.web3d.x3d.sai.SFRotation rotation,
//		org.web3d.x3d.sai.SFVec3f scale,
//		org.web3d.x3d.sai.SFRotation scaleOrientation,
//		org.web3d.x3d.sai.SFVec3f center);

//	public void getTransform(org.web3d.x3d.sai.SFVec3f translation, // TODO incompatible with double types
//		org.web3d.x3d.sai.SFRotation rotation,
//		org.web3d.x3d.sai.SFVec3f scale);

	public org.web3d.x3d.sai.Matrix3 inverse();

	public org.web3d.x3d.sai.Matrix3 transpose();

	public org.web3d.x3d.sai.Matrix3 multiplyLeft(org.web3d.x3d.sai.Matrix3 matrix3x3);

	public org.web3d.x3d.sai.Matrix3 multiplyRight(org.web3d.x3d.sai.Matrix3 matrix3x3);

//	public org.web3d.x3d.sai.Matrix3 multiplyRowVector(org.web3d.x3d.sai.SFVec3f vec3f); // TODO incompatible with double types

//	public org.web3d.x3d.sai.Matrix3 multiplyColVector(org.web3d.x3d.sai.SFVec3f vec3f); // TODO incompatible with double types
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- ===================================================== -->

		<!-- TODO specification accessor methods missing trailing semicolons -->
		<!-- TODO decide on best implementation and then add it -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>Matrix4</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Describes a 4x4 Matrix as required by the SAIMatrix abstract type.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.5 Matrix4</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#Matrix4</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.20 SAIMatrix</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIMatrix</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /* TODO: remove constructor definition from interface specification
	public org.web3d.x3d.sai.Matrix4();
     */

	public void setIdentity();

	public void set(int row, int column);

	public float get(int row, int column);

//	public void setTransform(org.web3d.x3d.sai.SFVec3f translation, // TODO incompatible with double types
//		org.web3d.x3d.sai.SFRotation rotation,
//		org.web3d.x3d.sai.SFVec3f scale,
//		org.web3d.x3d.sai.SFRotation scaleOrientation,
//		org.web3d.x3d.sai.SFVec3f center);

//	public void getTransform(org.web3d.x3d.sai.SFVec3f translation, // TODO incompatible with double types
//		org.web3d.x3d.sai.SFRotation rotation,
//		org.web3d.x3d.sai.SFVec3f scale);

	public org.web3d.x3d.sai.Matrix4 inverse();

	public org.web3d.x3d.sai.Matrix4 transpose();

	public org.web3d.x3d.sai.Matrix4 multiplyLeft(org.web3d.x3d.sai.Matrix4 matrix4x4);

	public org.web3d.x3d.sai.Matrix4 multiplyRight(org.web3d.x3d.sai.Matrix4 matrix4x4);

//	public org.web3d.x3d.sai.Matrix3 multiplyColVector(org.web3d.x3d.sai.SFVec3f vec3f);

//	public org.web3d.x3d.sai.Matrix3 multiplyColVector(org.web3d.x3d.sai.SFVec3f vec3f);
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- now concrete classes for field types-->

		<!-- loop over fields to find further imports -->
		<xsl:for-each select="//FieldTypes/FieldType">

			<xsl:variable name="fieldName" select="@type"/>
			<xsl:variable name="regexEscaped">
                <xsl:call-template name="escape-quote-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputValue">
						<xsl:call-template name="escape-backslash-characters"> <!-- tail recursion -->
							<xsl:with-param name="inputValue" select="@regex"/>
						</xsl:call-template>
					</xsl:with-param>
				</xsl:call-template>
			</xsl:variable>

			<xsl:variable name="javaType">
				<xsl:call-template name="javaType">
					<xsl:with-param name="x3dType" select="@type"/>
					<!-- isInterface true returns Java base types (e.g. float[] for SFColor, etc. -->
					<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="isSingletonType"><!-- tupleness -->
				<xsl:value-of select="(@type = 'MFBool')   or (@type = 'MFInt32') or (@type = 'MFDouble') or (@type = 'MFFloat') or
                                      (@type = 'MFString') or (@type = 'MFTime')  or (@type = 'MFNode') or
                                       starts-with(@type,'SF')"/>
			</xsl:variable>
			<xsl:variable name="tupleSize">
				<xsl:call-template name="tupleSize">
					<xsl:with-param name="x3dType" select="@type"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="javaPrimitiveType">
				<xsl:choose>
					<xsl:when test="($isSingletonType = 'true')">
						<xsl:value-of select="substring-before($javaType,'[')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$javaType"/><!-- array of array type -->
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="dimensionSuffix">
				<xsl:choose>
					<xsl:when test="false() and ($javaType = $javaPrimitiveType)">
						<xsl:text>.size()</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>.length</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="implements">
				<xsl:choose>
					<xsl:when test="contains($fieldName,'Matrix3')">
						<xsl:text> extends org.web3d.x3d.sai.Matrix3</xsl:text>
					</xsl:when>
					<xsl:when test="contains($fieldName,'Matrix4')">
						<xsl:text> extends org.web3d.x3d.sai.Matrix4</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="imports">
				<xsl:text>import org.web3d.x3d.jsail.*;</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text>import org.web3d.x3d.jsail.Core.*;</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:if test="starts-with($fieldName, 'field')">
					<xsl:text>import org.web3d.x3d.jsail.fields.*;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:if test="($fieldName = 'MFString')">
					<xsl:text>import java.util.ArrayList;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:if test="starts-with($fieldName,'MF') or ($fieldName = 'SFImage')">
					<xsl:text>import java.util.Arrays;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:choose>
					<xsl:when test="contains($fieldName,'FImage')">
						<xsl:text>import org.web3d.x3d.sai.InvalidFieldValueException;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>import java.awt.image.RenderedImage;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>import java.awt.image.WritableRenderedImage;</xsl:text>
					</xsl:when>
					<xsl:when test="contains($fieldName,'FMatrix')">
						<xsl:text>import org.web3d.x3d.sai.InvalidFieldValueException;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>// import org.web3d.x3d.sai.*;</xsl:text>
						<xsl:text>&#10;</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>import org.web3d.x3d.sai.InvalidFieldValueException;</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="javadocBlock">
				<xsl:value-of select="InterfaceDefinition/@appinfo"/>
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[ * Related field object: {@link ]]></xsl:text>
				<xsl:choose>
					<xsl:when test="starts-with($fieldName,'SF')">
						<xsl:text>MF</xsl:text>
						<xsl:value-of select="substring-after($fieldName,'SF')"/>
						<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>SF</xsl:text>
						<xsl:value-of select="substring-after($fieldName,'MF')"/>
						<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					</xsl:otherwise>
				</xsl:choose>
				<xsl:text>}</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[">X3D Tooltips: type ]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:variable>
<xsl:variable name="newValueNullExceptionCheck">
	<xsl:text>		if (</xsl:text>
	<xsl:value-of select="$newValue"/>
	<xsl:text> == null)</xsl:text>
	<xsl:text>&#10;</xsl:text>
	<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
	<xsl:text>("</xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> </xsl:text>
	<xsl:value-of select="$newValue"/>
	<xsl:text> is null and cannot be set"); // fieldTest</xsl:text>
	<xsl:text>&#10;</xsl:text>
</xsl:variable>
<xsl:variable name="newValueNullReturnSelf">
	<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
	<xsl:text>		if (</xsl:text>
	<xsl:value-of select="$newValue"/>
	<xsl:text> == null) return; // newValueNullReturnSelf2</xsl:text>
	<xsl:text>&#10;</xsl:text>
</xsl:variable>
<xsl:variable name="isArrayType">
    <!-- TODO remove restrictions when ArrayList types added -->
    <xsl:value-of select="starts-with(@type,'MF') or (contains(@type,'Color') or contains(@type,'Vec') or contains(@type,'Rotation') or contains(@type,'Matrix')) and contains($javaType,'[]')"/>
</xsl:variable>

<!-- debug
<xsl:if test="($debug = 'true')">
<xsl:message>
<xsl:text>// field ($fieldName=</xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:text>, $javaType=</xsl:text>
<xsl:value-of select="$javaType"/>
<xsl:text>, $isSingletonType=</xsl:text>
<xsl:value-of select="$isSingletonType"/>
<xsl:text>, tupleSize=</xsl:text>
<xsl:value-of select="$tupleSize"/>
<xsl:text>, $javaPrimitiveType=</xsl:text>
<xsl:value-of select="$javaPrimitiveType"/>
<xsl:text>, $dimensionSuffix=</xsl:text>
<xsl:value-of select="$dimensionSuffix"/>
<xsl:text>)</xsl:text>
</xsl:message>
</xsl:if> -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:value-of select="$imports"/></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text>X3DConcreteField</xsl:text></xsl:with-param>
				<xsl:with-param name="implements">
                    <xsl:text>org.web3d.x3d.sai.</xsl:text>
                    <xsl:value-of select="$fieldName"/>
                    <!-- TODO X3DField, X3DArrayField -->
                </xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
				<xsl:with-param name="description">
					<xsl:text>This utility class provides a concrete implementation corresponding to </xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> X3D field type.</xsl:text>
				</xsl:with-param>
				<!-- TODO update -->
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="substring-after(InterfaceDefinition/@specificationUrl,'#')"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock" disable-output-escaping="yes"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="implementationBlock">

				<xsl:variable name="newValueSizeCheck">
					<xsl:text disable-output-escaping="yes"><![CDATA[	if (size < 0)]]></xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>		throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
					<xsl:text>("requested setValue() array-copy size=" + size + </xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>			" is negative"); // newValueSizeCheck</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>	if (size > </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>.length)</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>		throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
					<xsl:text>("requested setValue() array-copy size=" + size + </xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>			" is greater than </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>.length()=" + </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>.length); // newValueSizeCheck</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:variable>

				<xsl:variable name="defaultValueExpression">
					<xsl:choose>
						<xsl:when test="contains($javaType,'[') or ($javaType = 'MFNode')">
							<xsl:text>java.util.Arrays.copyOf(DEFAULT_VALUE, DEFAULT_VALUE.length); // must be separate copy</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text>DEFAULT_VALUE;</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>

				<!-- FieldType default values -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>NAME</i> provides name of this element: <i>]]></xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[</i> */
	public static final String NAME = "]]></xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>";

	/** Default value for this field type</xsl:text>
				<xsl:choose>
					<xsl:when test="starts-with($fieldName, 'MF')">
						<xsl:text> is an empty array</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFNode')">
						<xsl:text> is a null node</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFBool')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ is a <i>true</i> value]]></xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFRotation')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ is a <i>0 0 1 0</i> identity-rotation value]]></xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFString')">
						<xsl:text> is an empty String</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFTime')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ is a <i>-1</i> value]]></xsl:text>
					</xsl:when>
					<xsl:when test="contains($fieldName, 'SFVec2')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ contains values of <i>0 0</i>]]></xsl:text>
					</xsl:when>
					<xsl:when test="contains($fieldName, 'SFVec3')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ contains values of <i>0 0 0</i>]]></xsl:text>
					</xsl:when>
					<xsl:when test="contains($fieldName, 'SFVec4')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ contains values of <i>0 0 0 0</i>]]></xsl:text>
					</xsl:when>
					<xsl:when test="contains($fieldName, 'SFImage')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ contains values of <i>0 0 0</i>]]></xsl:text>
					</xsl:when>
					<xsl:when test="not(contains($fieldName, 'Vec')) and not(contains($fieldName, 'Matrix'))">
						<xsl:text disable-output-escaping="yes"><![CDATA[ is <i>]]></xsl:text>
                        <xsl:value-of select="@defaultValue"/>
						<xsl:text disable-output-escaping="yes"><![CDATA[</i>]]></xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text disable-output-escaping="yes"><![CDATA[ contains values of <i>]]></xsl:text>
                        <xsl:value-of select="@defaultValue"/>
						<xsl:text disable-output-escaping="yes"><![CDATA[</i>]]></xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:text>.</xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank">Java Tutorials: Primitive Data Types</a>
     */]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:choose>
					<xsl:when test="($fieldName = 'SFBool')">
						<xsl:text>	public static final boolean DEFAULT_VALUE = false;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFInt32')">
						<xsl:text>	public static final int DEFAULT_VALUE = 0;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFFloat')">
						<xsl:text>	public static final float DEFAULT_VALUE = 0.0f;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFDouble')">
						<xsl:text>	public static final double DEFAULT_VALUE = 0.0;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFString')">
						<xsl:text>	public static final String DEFAULT_VALUE = "";</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFTime')">
						<xsl:text>	public static final double DEFAULT_VALUE = -1.0;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec2d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {0.0, 0.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec2f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec3d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {0.0, 0.0, 0.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec3f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFColor')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFColorRGBA')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec4d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {0.0, 0.0, 0.0, 1.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec4f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 0.0f, 1.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFRotation')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 1.0f, 0.0f};</xsl:text>
                        <xsl:text> // X3DUOM default value: </xsl:text>
                        <xsl:value-of select="@defaultValue"/>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>	/** Preferred default value for this field type, oriented for rotation about vertical Y axis. */</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>	public static final float[] DEFAULT_VALUE_PREFERRED = {0.0f, 1.0f, 0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFImage')">
						<xsl:text>	public static final int[] DEFAULT_VALUE = {0, 0, 0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFMatrix3d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFMatrix3f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFMatrix4d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFMatrix4f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFNode')">
						<xsl:text>	</xsl:text><!-- tab -->
						<xsl:text>public static final org.web3d.x3d.sai.Core.X3DNode </xsl:text>
						<xsl:text>DEFAULT_VALUE</xsl:text>
						<xsl:text> = </xsl:text>
						<xsl:text>null;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'MFNode')">
						<xsl:text>	</xsl:text><!-- tab -->
						<xsl:text>public static final org.web3d.x3d.sai.Core.X3DNode[] </xsl:text>
						<xsl:text>DEFAULT_VALUE</xsl:text>
						<xsl:text> = </xsl:text>
						<xsl:text>new org.web3d.x3d.sai.Core.X3DNode[0]; // initialize as empty array</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName,'MF')">
						<xsl:text>	public static final </xsl:text>
						<xsl:value-of select="$javaType"/>
						<xsl:text> </xsl:text>
						<xsl:text>DEFAULT_VALUE = new </xsl:text>
                        <xsl:variable name="saiPackagePath">
                            <xsl:call-template name="saiPackage">
                                <xsl:with-param name="nodeType" select="$javaType"/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:choose>
                            <xsl:when test="(string-length($saiPackagePath) > 0)">
                                <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 13a */</xsl:text></xsl:if> -->
                                <xsl:value-of select="$saiPackagePath"/>
                                <xsl:text>.</xsl:text>
                                <xsl:value-of select="substring-before($javaType, '[]')"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 13b, saiPackage not found */</xsl:text></xsl:if> -->
                                <xsl:value-of select="substring-before($javaType, '[]')"/>
                            </xsl:otherwise>
                        </xsl:choose>
						<xsl:text>[0]; // initialize as empty array</xsl:text>
					</xsl:when>
				</xsl:choose>
                <xsl:if test="(string-length(@defaultValue) > 0)">
                    <xsl:text> // X3DUOM default value: </xsl:text>
                    <xsl:value-of select="@defaultValue"/>
                </xsl:if>
				<xsl:text>&#10;</xsl:text>

				<xsl:text>
	/** Default string value for this field type is "</xsl:text>
				<xsl:value-of select="@defaultValue"/>
				<xsl:text>". */</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text>	public static final String </xsl:text>
				<xsl:text>DEFAULT_VALUE_STRING = "</xsl:text>
				<xsl:value-of select="@defaultValue"/>
				<xsl:text>";</xsl:text>
				<xsl:text>&#10;</xsl:text>

                <xsl:if test="(@tupleSize != $tupleSize)">
                    <xsl:message>
                        <xsl:text>*** Mismatched tuple size: name=</xsl:text>
                        <xsl:value-of select="$fieldName"/>
                        <xsl:text> with @tupleSize='</xsl:text>
                        <xsl:value-of select="@tupleSize"/>
                        <xsl:text>' does not match computed $tupleSize=</xsl:text>
                        <xsl:value-of select="$tupleSize"/>
                    </xsl:message>
                </xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Whether or not this field type is an array (<i>]]></xsl:text>
				<xsl:value-of select="@isArray"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[</i>)
      * @return true if array type */
	public static final boolean isArray()
    {
        return ]]></xsl:text>
				<xsl:value-of select="@isArray"/>
				<xsl:text>;
    }</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Default tuple size for this field type is <i>]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[</i> (i.e. number of component values making up a single-field SF object). */
	public static final int TUPLE_SIZE = ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text>;</xsl:text>
				<xsl:text>&#10;</xsl:text>

			<xsl:if test="not($fieldName = 'SFNode') and not($fieldName = 'MFNode')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Default regular expression (regex) pattern for this field type is <i>]]></xsl:text>
				<xsl:value-of select="@regex"/><!-- unescaped as HTML text -->
				<xsl:text disable-output-escaping="yes"><![CDATA[</i>
	 * @see #PATTERN
	 * @see #matches
	 * @see #matches(String)
	 * @see #validate
	 * @see <a href="https://www.web3d.org/specifications/X3dRegularExpressions.html#]]></xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[" target="_blank">X3D Regular Expressions: ]]></xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[</a>
	 */
	public static final String REGEX = "]]></xsl:text>
				<xsl:value-of select="$regexEscaped"/>
				<xsl:text>";</xsl:text>
				<xsl:text>&#10;</xsl:text>

				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Precompiled regular expression (regex) pattern for this field type using default <em>REGEX</em> value.
	 * @see REGEX
	 * @see #matches
	 * @see #matches(String)
	 * @see #validate
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 */
	public static final java.util.regex.Pattern PATTERN = java.util.regex.Pattern.compile(REGEX);

    /** Flag to minimize excessive regex warnings for this field type, helpful if memory limitations are present. */
    private static boolean priorRegexStackOverflowFound = false;
]]></xsl:text>
                <!-- special regexes for SimpleType definitions, for example SFVec3f bboxSizeType -->
                <xsl:for-each select="//SimpleType[@baseType = $fieldName][string-length(@regex) > 0]">
                    <!-- debug
                    <xsl:message>
                        <xsl:text>*** Found SimpleType name=</xsl:text>
                        <xsl:value-of select="@name"/>
                        <xsl:text> with @baseType='</xsl:text>
                        <xsl:value-of select="@baseType"/>
                        <xsl:text>' regex'=</xsl:text>
                        <xsl:value-of select="@regex"/>
                        <xsl:text>'</xsl:text>
                    </xsl:message> -->

                    <xsl:variable name="javaValue">
                        <xsl:call-template name="javaValue">
                            <xsl:with-param name="x3dType">
                                <xsl:value-of select="@name"/>
                            </xsl:with-param>
                            <xsl:with-param name="schemaValue">
                                <xsl:value-of select="@defaultValue"/>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:variable name="specialRegexEscaped">
                        <xsl:call-template name="escape-quote-characters"> <!-- tail recursion -->
                            <xsl:with-param name="inputValue">
                                <xsl:call-template name="escape-backslash-characters"> <!-- tail recursion -->
                                    <xsl:with-param name="inputValue" select="@regex"/>
                                </xsl:call-template>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:variable>

					<xsl:text>
	/** Special SimpleType </xsl:text>
                    <xsl:value-of select="@name"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ contains default value of <i>]]></xsl:text>
                    <xsl:value-of select="@defaultValue"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[</i>.
	 * @see <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank">Java Tutorials: Primitive Data Types</a>
     */
	public static final float[] DEFAULT_VALUE_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
					<xsl:text> = {</xsl:text>
                    <xsl:value-of select="translate(@defaultValue,' ',',')"/><!-- $javaValue -->
					<xsl:text>}; // X3DUOM default value: </xsl:text>
                    <xsl:value-of select="@defaultValue"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[

	/** Default string value for this special SimpleType is <i>"]]></xsl:text>
                    <xsl:value-of select="@defaultValue"/>
					<xsl:text disable-output-escaping="yes"><![CDATA["</i>. */
	public static final String DEFAULT_VALUE_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
					<xsl:text>_STRING = "</xsl:text>
                    <xsl:value-of select="@defaultValue"/>
					<xsl:text>";

	/** Special SimpleType </xsl:text>
                    <xsl:value-of select="@name"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ regular expression (regex) pattern for this field type is <i>]]></xsl:text>
                    <xsl:value-of select="$specialRegexEscaped"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[</i>";
	 * @see #PATTERN_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see #matches]]></xsl:text>
                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                    <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see #matches(String)
	 * @see #validate
	 * @see <a href="https://www.web3d.org/specifications/X3dRegularExpressions.html#]]></xsl:text>
                    <xsl:value-of select="@name"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[" target="_blank">X3D Regular Expressions: ]]></xsl:text>
                    <xsl:value-of select="@name"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[</a>
	 */
	public static final String REGEX_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text> = "</xsl:text>
                    <xsl:value-of select="$specialRegexEscaped"/>
                    <xsl:text>";</xsl:text>
                    <xsl:text>&#10;</xsl:text>

                    <xsl:text>
	/** Special SimpleType </xsl:text>
                    <xsl:value-of select="@name"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[ regular expression (regex) pattern for this field type.
	 * @see REGEX_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see #matches]]></xsl:text>
                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                    <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see #matches(String)
	 * @see #validate
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 */
	public static final java.util.regex.Pattern PATTERN_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text> = java.util.regex.Pattern.compile(REGEX_</xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text>);

	/** Special SimpleType regular expression (regex) </xsl:text>
                    <xsl:value-of select="@name"/>
                    <xsl:text> PATTERN_</xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[ match of current object's toString() value.
	 * @see #REGEX_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text>
	 * @see #PATTERN_</xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text>
	 * @see #matches</xsl:text>
                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                    <xsl:text disable-output-escaping="yes"><![CDATA[(String)
	 * @see #matches
	 * @see #matches(String)
	 * @see #validate
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 * @return true if PATTERN_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[ matches, false otherwise
	 */
	public final boolean matches]]></xsl:text>
                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                    <xsl:text>()
	{
        try
        {
            java.util.regex.Matcher m = PATTERN_</xsl:text>
                        <xsl:value-of select="upper-case(@name)"/>
                        <xsl:text>.matcher(toString());
            return m.matches();
		}
        catch (java.lang.StackOverflowError soe) // regex processing required too much memory for String version of this attribute
        {
            if (!priorRegexStackOverflowFound)
            {
                priorRegexStackOverflowFound = true;
                String validationMessage = "java.lang.StackOverflow warning: regular expression (regex) unable to evaluate large corresponding String value for </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:if test="starts-with(@name,'MF')">
                <xsl:text> array</xsl:text>
            </xsl:if>
            <!-- TODO compute full length for all types
            <xsl:text> (length " + </xsl:text>
            <xsl:value-of select="$fieldName"/><xsl:text>.toString().length() + " values)</xsl:text> -->
            <xsl:text>";
                validationResult.append(validationMessage).append("\n");
                System.out.println ("[exception] " + validationMessage);
		    }
            return false;
		}
	}
	/** Special SimpleType regular expression (regex) </xsl:text>
                    <xsl:value-of select="@name"/>
                    <xsl:text> PATTERN_</xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[ match of current object's toString() value.
     * @param value String value to check
	 * @see #REGEX_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text>
	 * @see #PATTERN_</xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see #matches]]></xsl:text>
                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                    <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see #matches
	 * @see #matches(String)
	 * @see #validate
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 * @return true if PATTERN_]]></xsl:text>
                    <xsl:value-of select="upper-case(@name)"/>
                    <xsl:text disable-output-escaping="yes"><![CDATA[ matches, false otherwise
	 */
	public static final boolean matches]]></xsl:text>
                    <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                    <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                    <xsl:text>(String value)
	{
        try
        {
            java.util.regex.Matcher m = PATTERN_</xsl:text>
                        <xsl:value-of select="upper-case(@name)"/>
                        <xsl:text>.matcher(value);
            return m.matches();
		}
        catch (java.lang.StackOverflowError soe) // regex processing required too much memory for String version of this attribute
        {
            String validationMessage = "java.lang.StackOverflow warning: regular expression (regex) unable to evaluate large corresponding String value for </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:if test="starts-with(@name,'MF')">
                <xsl:text> array</xsl:text>
            </xsl:if>
            <!-- TODO compute full length for all types
            <xsl:text> (length " + </xsl:text>
            <xsl:value-of select="$fieldName"/><xsl:text>.toString().length() + " values)</xsl:text> -->
            <xsl:text disable-output-escaping="yes"><![CDATA[";
                validationResult.append(validationMessage).append("\n");
                System.out.println ("[exception] " + validationMessage);
                return false;
		}
	}
]]></xsl:text>
                    </xsl:for-each>
				</xsl:if>

				<!-- Convenience contants -->
				<xsl:choose>
					<xsl:when test="($fieldName = 'SFBool')">
						<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant for boolean value <em>true</em>, note lower-case value is X3D XML syntax (upper-case value is VRML syntax) */
	public static String TRUE  = "true";
	/** String constant for boolean value <em>false</em>, note lower-case value is X3D XML syntax (upper-case value is VRML syntax) */
	public static String FALSE = "false";
]]></xsl:text>
					</xsl:when>
					<!-- SFColor convenience contants -->
					<xsl:when test="($fieldName = 'SFColor')">
						<!-- TODO add lower-case bookmarks -->
						<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ALICEBLUE = toFloatArray(0xf0f8ff); // decimal 240,248,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ANTIQUEWHITE = toFloatArray(0xfaebd7); // decimal 250,235,215
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] AQUA = toFloatArray(0x00ffff); // decimal 0,255,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] AQUAMARINE = toFloatArray(0x7fffd4); // decimal 127,255,212
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] AZURE = toFloatArray(0xf0ffff); // decimal 240,255,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BEIGE = toFloatArray(0xf5f5dc); // decimal 245,245,220
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BISQUE = toFloatArray(0xffe4c4); // decimal 255,228,196
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BLACK = toFloatArray(0x000000); // decimal 0,0,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BLANCHEDALMOND = toFloatArray(0xffebcd); // decimal 255,235,205
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BLUE = toFloatArray(0x0000ff); // decimal 0,0,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BLUEVIOLET = toFloatArray(0x8a2be2); // decimal 138,43,226
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BROWN = toFloatArray(0xa52a2a); // decimal 165,42,42
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BURLYWOOD = toFloatArray(0xdeb887); // decimal 222,184,135
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CADETBLUE = toFloatArray(0x5f9ea0); // decimal 95,158,160
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CHARTREUSE = toFloatArray(0x7fff00); // decimal 127,255,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CHOCOLATE = toFloatArray(0xd2691e); // decimal 210,105,30
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CORAL = toFloatArray(0xff7f50); // decimal 255,127,80
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CORNFLOWERBLUE = toFloatArray(0x6495ed); // decimal 100,149,237
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CORNSILK = toFloatArray(0xfff8dc); // decimal 255,248,220
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CRIMSON = toFloatArray(0xdc143c); // decimal 220,20,60
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CYAN = toFloatArray(0x00ffff); // decimal 0,255,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKBLUE = toFloatArray(0x00008b); // decimal 0,0,139
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKCYAN = toFloatArray(0x008b8b); // decimal 0,139,139
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKGOLDENROD = toFloatArray(0xb8860b); // decimal 184,134,11
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKGRAY = toFloatArray(0xa9a9a9); // decimal 169,169,169
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKGREEN = toFloatArray(0x006400); // decimal 0,100,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKGREY = toFloatArray(0xa9a9a9); // decimal 169,169,169
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKKHAKI = toFloatArray(0xbdb76b); // decimal 189,183,107
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKMAGENTA = toFloatArray(0x8b008b); // decimal 139,0,139
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKOLIVEGREEN = toFloatArray(0x556b2f); // decimal 85,107,47
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKORANGE = toFloatArray(0xff8c00); // decimal 255,140,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKORCHID = toFloatArray(0x9932cc); // decimal 153,50,204
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKRED = toFloatArray(0x8b0000); // decimal 139,0,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSALMON = toFloatArray(0xe9967a); // decimal 233,150,122
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSEAGREEN = toFloatArray(0x8fbc8f); // decimal 143,188,143
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSLATEBLUE = toFloatArray(0x483d8b); // decimal 72,61,139
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSLATEGRAY = toFloatArray(0x2f4f4f); // decimal 47,79,79
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSLATEGREY = toFloatArray(0x2f4f4f); // decimal 47,79,79
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKTURQUOISE = toFloatArray(0x00ced1); // decimal 0,206,209
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKVIOLET = toFloatArray(0x9400d3); // decimal 148,0,211
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DEEPPINK = toFloatArray(0xff1493); // decimal 255,20,147
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DEEPSKYBLUE = toFloatArray(0x00bfff); // decimal 0,191,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DIMGRAY = toFloatArray(0x696969); // decimal 105,105,105
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DIMGREY = toFloatArray(0x696969); // decimal 105,105,105
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DODGERBLUE = toFloatArray(0x1e90ff); // decimal 30,144,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] FIREBRICK = toFloatArray(0xb22222); // decimal 178,34,34
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] FLORALWHITE = toFloatArray(0xfffaf0); // decimal 255,250,240
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] FORESTGREEN = toFloatArray(0x228b22); // decimal 34,139,34
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] FUCHSIA = toFloatArray(0xff00ff); // decimal 255,0,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GAINSBORO = toFloatArray(0xdcdcdc); // decimal 220,220,220
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GHOSTWHITE = toFloatArray(0xf8f8ff); // decimal 248,248,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GOLD = toFloatArray(0xffd700); // decimal 255,215,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GOLDENROD = toFloatArray(0xdaa520); // decimal 218,165,32
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GRAY = toFloatArray(0x808080); // decimal 128,128,128
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GREEN = toFloatArray(0x008000); // decimal 0,128,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GREENYELLOW = toFloatArray(0xadff2f); // decimal 173,255,47
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GREY = toFloatArray(0x808080); // decimal 128,128,128
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] HONEYDEW = toFloatArray(0xf0fff0); // decimal 240,255,240
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] HOTPINK = toFloatArray(0xff69b4); // decimal 255,105,180
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] INDIANRED = toFloatArray(0xcd5c5c); // decimal 205,92,92
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] INDIGO = toFloatArray(0x4b0082); // decimal 75,0,130
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] IVORY = toFloatArray(0xfffff0); // decimal 255,255,240
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] KHAKI = toFloatArray(0xf0e68c); // decimal 240,230,140
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LAVENDER = toFloatArray(0xe6e6fa); // decimal 230,230,250
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LAVENDERBLUSH = toFloatArray(0xfff0f5); // decimal 255,240,245
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LAWNGREEN = toFloatArray(0x7cfc00); // decimal 124,252,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LEMONCHIFFON = toFloatArray(0xfffacd); // decimal 255,250,205
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTBLUE = toFloatArray(0xadd8e6); // decimal 173,216,230
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTCORAL = toFloatArray(0xf08080); // decimal 240,128,128
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTCYAN = toFloatArray(0xe0ffff); // decimal 224,255,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTGOLDENRODYELLOW = toFloatArray(0xfafad2); // decimal 250,250,210
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTGRAY = toFloatArray(0xd3d3d3); // decimal 211,211,211
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTGREEN = toFloatArray(0x90ee90); // decimal 144,238,144
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTGREY = toFloatArray(0xd3d3d3); // decimal 211,211,211
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTPINK = toFloatArray(0xffb6c1); // decimal 255,182,193
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSALMON = toFloatArray(0xffa07a); // decimal 255,160,122
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSEAGREEN = toFloatArray(0x20b2aa); // decimal 32,178,170
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSKYBLUE = toFloatArray(0x87cefa); // decimal 135,206,250
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSLATEGRAY = toFloatArray(0x778899); // decimal 119,136,153
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSLATEGREY = toFloatArray(0x778899); // decimal 119,136,153
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSTEELBLUE = toFloatArray(0xb0c4de); // decimal 176,196,222
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTYELLOW = toFloatArray(0xffffe0); // decimal 255,255,224
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIME = toFloatArray(0x00ff00); // decimal 0,255,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIMEGREEN = toFloatArray(0x32cd32); // decimal 50,205,50
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LINEN = toFloatArray(0xfaf0e6); // decimal 250,240,230
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MAGENTA = toFloatArray(0xff00ff); // decimal 255,0,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MAROON = toFloatArray(0x800000); // decimal 128,0,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMAQUAMARINE = toFloatArray(0x66cdaa); // decimal 102,205,170
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMBLUE = toFloatArray(0x0000cd); // decimal 0,0,205
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMORCHID = toFloatArray(0xba55d3); // decimal 186,85,211
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMPURPLE = toFloatArray(0x9370db); // decimal 147,112,219
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMSEAGREEN = toFloatArray(0x3cb371); // decimal 60,179,113
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMSLATEBLUE = toFloatArray(0x7b68ee); // decimal 123,104,238
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMSPRINGGREEN = toFloatArray(0x00fa9a); // decimal 0,250,154
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMTURQUOISE = toFloatArray(0x48d1cc); // decimal 72,209,204
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMVIOLETRED = toFloatArray(0xc71585); // decimal 199,21,133
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MIDNIGHTBLUE = toFloatArray(0x191970); // decimal 25,25,112
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MINTCREAM = toFloatArray(0xf5fffa); // decimal 245,255,250
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MISTYROSE = toFloatArray(0xffe4e1); // decimal 255,228,225
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MOCCASIN = toFloatArray(0xffe4b5); // decimal 255,228,181
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] NAVAJOWHITE = toFloatArray(0xffdead); // decimal 255,222,173
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] NAVY = toFloatArray(0x000080); // decimal 0,0,128
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] OLDLACE = toFloatArray(0xfdf5e6); // decimal 253,245,230
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] OLIVE = toFloatArray(0x808000); // decimal 128,128,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] OLIVEDRAB = toFloatArray(0x6b8e23); // decimal 107,142,35
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ORANGE = toFloatArray(0xffa500); // decimal 255,165,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ORANGERED = toFloatArray(0xff4500); // decimal 255,69,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ORCHID = toFloatArray(0xda70d6); // decimal 218,112,214
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PALEGOLDENROD = toFloatArray(0xeee8aa); // decimal 238,232,170
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PALEGREEN = toFloatArray(0x98fb98); // decimal 152,251,152
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PALETURQUOISE = toFloatArray(0xafeeee); // decimal 175,238,238
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PALEVIOLETRED = toFloatArray(0xdb7093); // decimal 219,112,147
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PAPAYAWHIP = toFloatArray(0xffefd5); // decimal 255,239,213
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PEACHPUFF = toFloatArray(0xffdab9); // decimal 255,218,185
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PERU = toFloatArray(0xcd853f); // decimal 205,133,63
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PINK = toFloatArray(0xffc0cb); // decimal 255,192,203
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PLUM = toFloatArray(0xdda0dd); // decimal 221,160,221
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] POWDERBLUE = toFloatArray(0xb0e0e6); // decimal 176,224,230
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PURPLE = toFloatArray(0x800080); // decimal 128,0,128
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] RED = toFloatArray(0xff0000); // decimal 255,0,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ROSYBROWN = toFloatArray(0xbc8f8f); // decimal 188,143,143
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ROYALBLUE = toFloatArray(0x4169e1); // decimal 65,105,225
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SADDLEBROWN = toFloatArray(0x8b4513); // decimal 139,69,19
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SALMON = toFloatArray(0xfa8072); // decimal 250,128,114
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SANDYBROWN = toFloatArray(0xf4a460); // decimal 244,164,96
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SEAGREEN = toFloatArray(0x2e8b57); // decimal 46,139,87
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SEASHELL = toFloatArray(0xfff5ee); // decimal 255,245,238
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SIENNA = toFloatArray(0xa0522d); // decimal 160,82,45
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SILVER = toFloatArray(0xc0c0c0); // decimal 192,192,192
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SKYBLUE = toFloatArray(0x87ceeb); // decimal 135,206,235
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SLATEBLUE = toFloatArray(0x6a5acd); // decimal 106,90,205
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SLATEGRAY = toFloatArray(0x708090); // decimal 112,128,144
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SLATEGREY = toFloatArray(0x708090); // decimal 112,128,144
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SNOW = toFloatArray(0xfffafa); // decimal 255,250,250
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SPRINGGREEN = toFloatArray(0x00ff7f); // decimal 0,255,127
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] STEELBLUE = toFloatArray(0x4682b4); // decimal 70,130,180
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] TAN = toFloatArray(0xd2b48c); // decimal 210,180,140
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] TEAL = toFloatArray(0x008080); // decimal 0,128,128
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] THISTLE = toFloatArray(0xd8bfd8); // decimal 216,191,216
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] TOMATO = toFloatArray(0xff6347); // decimal 255,99,71
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] TURQUOISE = toFloatArray(0x40e0d0); // decimal 64,224,208
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] VIOLET = toFloatArray(0xee82ee); // decimal 238,130,238
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] WHEAT = toFloatArray(0xf5deb3); // decimal 245,222,179
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] WHITE = toFloatArray(0xffffff); // decimal 255,255,255
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] WHITESMOKE = toFloatArray(0xf5f5f5); // decimal 245,245,245
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] YELLOW = toFloatArray(0xffff00); // decimal 255,255,0
	/** Color value alias.
         * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] YELLOWGREEN = toFloatArray(0x9acd32); // decimal 154,205,50
]]></xsl:text>
					</xsl:when>
					<!-- TODO indentity matrix values? -->
				</xsl:choose>

				<!-- method definitions for concrete fields -->
				<xsl:text><![CDATA[
	// Member value declaration is encapsulated and private, using preferred Java types for concretes library
	private ]]></xsl:text>
				<xsl:value-of select="$javaType"/>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text> = </xsl:text>
				<xsl:value-of select="$defaultValueExpression"/>
				<xsl:text>&#10;</xsl:text>

		<!-- Source code: constructor method applies default initial value -->
		<xsl:text>
	/**
	 * Constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> performs value initialization.
	 */
	public </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text>()
	{
		initialize();
	}
</xsl:text>
		<xsl:text>
	/**
	 * Initialization for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> applies default initial value.</xsl:text>
	<xsl:if test="(starts-with($fieldName,'SF') or starts-with($fieldName,'MF')) and not(contains($fieldName,'Node'))">
		<!-- https://stackoverflow.com/questions/6454482/how-can-i-add-javadoc-to-a-static-initializer-in-java -->
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * Static initializer also provided to verify that the regex pattern compiles and matches that default value.
	 * @see <a href="https://stackoverflow.com/questions/2704857/how-to-check-if-a-given-regex-is-valid">Stack Overflow: How to check if a given Regex is valid?</a>]]></xsl:text>
	</xsl:if>
	<xsl:text>
	 * @see #DEFAULT_VALUE
	 */
	@Override
	public final void initialize()
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/>
		<xsl:text> = </xsl:text>
		<xsl:value-of select="$defaultValueExpression"/>
		<xsl:if test="(starts-with($fieldName,'SF') or starts-with($fieldName,'MF')) and not(contains($fieldName,'Node'))">
            <xsl:text>
	}
	// static initializer
	static {
		try {
            // verify pattern is compiling OK, report exception if not
			java.util.regex.Pattern.compile(REGEX);

			// verify DEFAULT_VALUE matches pattern OK, report if not
			if ((new </xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(DEFAULT_VALUE)).matches() == false)
			{
				System.out.println("</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>.initialize() problem: failed to match DEFAULT_VALUE=" + </xsl:text>
                <xsl:choose>
                    <xsl:when test="($isArrayType='true')">
                        <xsl:text>java.util.Arrays.toString(DEFAULT_VALUE)</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>DEFAULT_VALUE</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
				<xsl:text>);
			}
        }
		catch (java.util.regex.PatternSyntaxException exception)
		{
			System.out.println("Exception in </xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text> initialization testing, regex pattern compilation failure.");
			System.out.println("REGEX=\"" + REGEX + "\"");
			System.out.println(exception.getDescription());
        }</xsl:text>
		</xsl:if>
		<xsl:text>
	}
</xsl:text>
		<!-- Static final utility methods -->
		<xsl:choose>
			<xsl:when test="($fieldName = 'SFString')">
				<xsl:text disable-output-escaping="yes"><![CDATA[

        // TODO better collect all regular expressions (regexes)
/*
        Names and Tokens https://www.w3.org/TR/xml11/#sec-common-syn
[4]   	NameStartChar	::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
[4a]   	NameChar	::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
[5]   	Name		::=   	NameStartChar (NameChar)*
[7]   	Nmtoken		::=   	(NameChar)+
*/
    /**
     * XML Regular Expression NameStartChar.
     * TODO integrate special-character support into regex.
     * [4]   	NameStartChar	::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
     * @see <a href="https://www.w3.org/TR/xml11/#NT-NameStartChar">XML 1.1 NameStartChar</a>
	 */
	public static final String NameStartCharFilter = "A-Z_a-z"; // "A-Z_a-z" TODO [\u00C0-\u00D6][\u00D8-\u00F6][\u00F8-\u02FF][\u0370-\u037D][\u037F-\u1FFF][\u200C-\u200D][\u2070-\u218F][\u2C00-\u2FEF][\u3001-\uD7FF][\uF900-\uFDCF][\uFDF0-\uFFFD][\u10000-\uEFFFF]";

    /**
     * XML Regular Expression NameChar.
     * TODO integrate special-character support into regex.
     * [4a]   	NameChar	::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
     * @see <a href="https://www.w3.org/TR/xml11/#NT-NameChar">XML 1.1 NameChar</a>
	 */
	public static final String NameCharFilter = NameStartCharFilter + "-.0-9"; // "A-Z_a-z-.0-9" TODO \u00B7[\u0300-\u036F][\u0203F-\u2040]";

    /**
     * XML Regular Expression NameFilter.
     * TODO integrate special-character support into regex.
     * [5]   	Name		::=   	NameStartChar (NameChar)*
     * @see <a href="https://www.w3.org/TR/xml11/#NT-NameFilter">XML 1.1 NameFilter</a>
	 */
	public static final String NameFilter = "[" + NameStartCharFilter + "][" + NameCharFilter + "]*"; // "[A-Z_a-z][A-Z_a-z-.0-9]*"

	/**
     * XML Regular Expression Nmtoken.
     * TODO integrate special-character support into regex.
     * [7]   	Nmtoken		::=   	(NameChar)+
     * @see <a href="https://www.w3.org/TR/xml11/#NT-Nmtoken">XML 1.1 Nmtoken</a>
	 */
	public static final String NmtokenFilter = "[" + NameCharFilter + "]+"; // "[A-Z_a-z-.0-9]+"

    /**
	 * Utility method to determine if string meets XML NMTOKEN requirements
	 * @param value string to check
	 * @return whether value meets NMTOKEN regex checks
	 * @see SFString#meetsX3dInteroperabilityNamingConventions(String)
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 * @see <a href="https://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
	 * @see <a href="https://www.w3.org/TR/REC-xml/#sec-common-syn">XML 1.0 Recommendation, 2.3 Common Syntactic Constructs</a>
	 * @see <a href="https://www.w3.org/TR/xml11/#NT-Nmtoken">XML 1.1 NMTOKEN</a>
	 * @see <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.2" target="_blank">Java Language Specification: 3 Lexical Structure, 3.2. Lexical Translations</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/i18n/text/unicode.html" target="_blank">Java Tutorials: Unicode</a>
	 * @see <a href="https://www.oracle.com/us/technologies/java/supplementary-142654.html" target="_blank">Java and Unicode: Supplementary Characters in the Java Platform</a>
	 */
	public static final boolean isNMTOKEN(String value)
	{
            if ((value == null) || value.trim().isEmpty())
                return false;
            // NMTOKEN character regex check
            boolean result = value.matches(NmtokenFilter);

/* original was simpler and not strictly correct
                boolean result = value.matches("[a-zA-Z_][a-zA-Z0-9_]*"); // NMTOKEN character regex check
                if (value.startsWith(".") || value.startsWith("-"))       // NameStartChar restrictions
                    result = false;
*/
		return result;
	}

    /**
	 * Utility method to determine if string meets suggested X3D naming conventions: starts with letter or underscore character, includes letter character numeral or underscore characters.
	 * Avoids whitespace, apostrophe, hyphen, minus, comma, period or other special characters in order to ensure portability
	 * @param value string to check
	 * @return whether value meets suggested X3D naming requirements
	 * @see SFString#isNMTOKEN(String)
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 * @see <a href="https://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
	 * @see <a href="https://www.w3.org/TR/REC-xml/#sec-common-syn">XML 1.0 Recommendation, 2.3 Common Syntactic Constructs</a>
	 * @see <a href="https://www.w3.org/TR/xml11/#NT-Nmtoken">XML 1.1 NMTOKEN</a>
	 * @see <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.2" target="_blank">Java Language Specification: 3 Lexical Structure, 3.2. Lexical Translations</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/i18n/text/unicode.html" target="_blank">Java Tutorials: Unicode</a>
	 * @see <a href="https://www.oracle.com/us/technologies/java/supplementary-142654.html" target="_blank">Java and Unicode: Supplementary Characters in the Java Platform</a>
	 */
	public static final boolean meetsX3dInteroperabilityNamingConventions(String value)
	{
            if ((value == null) || value.trim().isEmpty())
                return false;
            // TODO continue improving character regex checks.  Not identical to NMTOKEN.
            boolean result = // value.matches(NameFilter) &&             // XML Name
                                value.matches("[a-zA-Z_][a-zA-Z0-9_]*"); // X3D SAH, TODO Internationalization (I18N)

/* original was simpler and not strictly correct
                boolean result = value.matches("[a-zA-Z_][a-zA-Z0-9_]*"); // NMTOKEN character regex check
                if (value.startsWith(".") || value.startsWith("-"))       // NameStartChar restrictions
                    result = false;
*/
                String prefix = new String(); // "[SFString.meetsX3dInteroperabilityNamingConventions()] "
                if      (isX3dNodeName(value))
                {
                        System.out.print ("[warning]");
                        if (!prefix.isBlank())
                            System.out.print(" prefix='" + prefix + "'");
                        System.out.println(" name='" + value + "' matches an X3D node name, literal name collisions can have unexpected consequences");
                        return false; // special case
                }
                else if (isX3dStatementName(value))
                {
                        System.out.print ("[warning]");
                        if (!prefix.isBlank())
                            System.out.print(" prefix='" + prefix + "'");
                        System.out.println(" name='" + value + "' matches an X3D statement name, literal name collisions can have unexpected consequences");
                        return false; // special case
                }
                else if (value.equals(meta.NAME_CML_VERSION))
                        return true; // special case
                else if (value.equals(meta.NAME_SOUND) || value.equals(meta.NAME_TEXT))
                        // Sound component and Text component names are overloaded and match a corresponding node name -->
                        return true; // special case, TODO check parent before avoiding diagnostic reporting here
		else    return result;
	}

        /**
         * Case-insensitive test whether or not string is a reserved X3D node name.
         * @param value to check
         * @return whether value is a reserved X3D node name
         */
        public static boolean isX3dNodeName(String value)
        {
            boolean isReservedName =]]></xsl:text>
                <xsl:for-each select="//ConcreteNodes/ConcreteNode">
                    <xsl:text>
                        value.equals(org.web3d.x3d.jsail.</xsl:text>
                    <xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
                    <xsl:text>.</xsl:text>
                    <xsl:value-of select="@name"/>
                    <xsl:text>.NAME)</xsl:text>
                    <xsl:choose>
                        <xsl:when test="not(position() = last())">
                            <xsl:text> ||</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>; // avoid equalsIgnoreCase() since it overzealously flags field names</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
		<xsl:text>
            return isReservedName;
        }
        /**
         * Case-insensitive test whether or not string is a reserved X3D statement name.
         * @param value to check
         * @return whether value is a reserved X3D node name
         */
        public static boolean isX3dStatementName(String value)
        {
            boolean isReservedName =</xsl:text>
                <xsl:for-each select="//Statements/Statement">
                    <xsl:text>
                        value.equals(org.web3d.x3d.jsail.</xsl:text>
                    <xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
                    <xsl:text>.</xsl:text>
                    <xsl:value-of select="@name"/>
                    <xsl:text>.NAME)</xsl:text>
                    <xsl:choose>
                        <xsl:when test="not(position() = last())">
                            <xsl:text> ||</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>; // avoid equalsIgnoreCase() since it overzealously flags field names</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
		<xsl:text>
            return isReservedName;
        }

	/**
	 * Append an additional String to this field.
         * @see String#concat(String)
         * @see #prependValue(String)
	 * @param newValue The value to append.
	 */
	public void appendValue(String newValue)
	{
		SFString += newValue;
	}
	/**
	 * Prepend an additional String to this field.
         * @see #appendValue(String)
	 * @param newValue The value to prepend.
	 */
	public void prependValue(String newValue)
	{
		SFString = newValue + SFString;
	}</xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'MFString')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Modify current object values to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets.
	 * @see MFString#cleanupUnescapedEnclosingQuotes()
	 * @return {@link MFString} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public MFString]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ cleanupEnumerationValues()
	{
		MFString = cleanupEnumerationValues(MFString);
		return this;
	}
	/**
	 * Utility method for single enumeration value to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets to create an unadorned enumeration String.
	 * @param value single enumeration string intended for use as an SFString or MFString value
	 * @see MFString#cleanupUnescapedEnclosingQuotes(String)
	 * @return unquoted string values containing no whitespace as MFString list
	 */
	public static String cleanupEnumerationValue(String value)
	{
		String result = new String();
		if  (value != null)
			 result = value;
		// total elimination:
		return result.replaceAll("\""," ").replaceAll(","," ").replaceAll("\\["," ").replaceAll("\\]"," ").trim().replaceAll(" ","");
	}
	/**
	 * Utility method for a single String containing multiple enumeration values to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets to create unadorned MFString elements as a String[] array.
	 * @param values zero or more enumeration values intended for use as an MFString list
	 * @see MFString#cleanupUnescapedEnclosingQuotes(String)
	 * @return unquoted string values containing no whitespace as MFString list
	 */
	public static String[] cleanupEnumerationValues(String values)
	{
		String[] result = new String[1];
		if  (values == null)
			 result[0] = new String();
		else result[0] = values.trim();
		if (!result[0].contains("\""))
			 return result;
		else return result[0].replaceAll("\""," ").replaceAll(","," ").replaceAll("\\["," ").replaceAll("\\]"," ").trim().split("(\\s)+");
	}
	/**
	 * Utility method for multiple enumeration values to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets in a String[] array.
	 * @param values zero or more enumeration values intended for use as an MFString list
	 * @see MFString#cleanupEnumerationValue(String)
	 * @see MFString#cleanupEnumerationValues(String)
	 * @see MFString#cleanupUnescapedEnclosingQuotes(String)
	 * @return unquoted string values containing no whitespace as String[] array
	 */
	public static String[] cleanupEnumerationValues(String[] values)
	{
		String[] results = new String[0];
		if  (values != null)
			 results = values;
		for (int i = 0; i < results.length; i++)
		{
			results[i] = cleanupEnumerationValue(results[i]); // one singleton enumeration at a time
		}
		return results;
	}
	/**
	 * Utility method for multiple enumeration values to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets from a ArrayList of values.
	 * @param values zero or more enumeration values intended for use as an MFString list
	 * @see MFString#cleanupEnumerationValue(String)
	 * @see MFString#cleanupEnumerationValues(String)
	 * @see MFString#cleanupUnescapedEnclosingQuotes(String)
	 * @return unquoted string values containing no whitespace as MFString list
	 */
	public static ArrayList<String> cleanupEnumerationValues(ArrayList<String> values)
	{
		ArrayList<String> results = new ArrayList<>();
		if  (values != null)
			 results = values;
		for (String result : results)
		{
			result = cleanupEnumerationValue(result); // one singleton enumeration at a time
		}
		return results;
	}
	/**
	 * Modify current object values to trim enclosing quotes and outer whitespace.
	 * @see MFString#cleanupEnumerationValues()
	 * @return {@link MFString} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public MFString]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ cleanupUnescapedEnclosingQuotes()
	{
		MFString = cleanupUnescapedEnclosingQuotes(MFString);
		return this;
	}
	/**
	 * Utility method to trim enclosing quotes and outer whitespace from an arbitrary String value, without removing escaped quotation marks (<i>\"</i>).
	 * ]]></xsl:text>
	<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
	<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
	<xsl:text>&#10;</xsl:text>
	<xsl:text>	 * </xsl:text>
	<xsl:text disable-output-escaping="yes"><![CDATA[<i>Warning:</i> do not use this method on a String that contains multiple quoted values, use cleanupEnumerationValues() instead.
	 * @param singleValue input String for use with MFString list, which must be unquoted
	 * @see MFString#cleanupEnumerationValue(String)
	 * @return unquoted String value
	 */
	public static String cleanupUnescapedEnclosingQuotes(String singleValue)
	{
		String result = singleValue;
		if  (result == null)
			 result = new String();
		if (result.trim().startsWith("\""))
		{
			result = result.trim().substring(1);							 // trim unescaped quotation mark "
		}
		if (result.trim().endsWith("\"") && !result.trim().endsWith("\\\""))
		{
			result = result.trim().substring(0, result.trim().length() - 1); // trim unescaped quotation mark "
		}
		return result;
	}
	/**
	 * Utility method to trim enclosing quotes and outer whitespace from elements in an arbitrary String[] array.
	 * @param values String[] array for use with MFString list, which must be unquoted
	 * @see MFString#cleanupUnescapedEnclosingQuotes(String)
	 * @see MFString#cleanupEnumerationValue(String)
	 * @see MFString#cleanupEnumerationValues(String)
	 * @return unquoted String[] array
	 */
	public static String[] cleanupUnescapedEnclosingQuotes(String[] values)
	{
		String[] result = values;
		if  (result == null)
			 result = new String[0];
		for (int i = 0; i < result.length; i++)
		{
			result[i] = cleanupUnescapedEnclosingQuotes(result[i]);
		}
		return result;
	}
	/**
	 * Utility method to trim enclosing quotes and outer whitespace from elements in an ArrayList of arbitrary String values.
	 * @param values existing ArrayList of String values for use with MFString list, which must be unquoted
	 * @see MFString#cleanupUnescapedEnclosingQuotes(String)
	 * @see MFString#cleanupEnumerationValue(String)
	 * @see MFString#cleanupEnumerationValues(String)
	 * @return unquoted String[] array
	 */
	public static ArrayList<String> cleanupUnescapedEnclosingQuotes(ArrayList<String> values)
	{
		ArrayList<String> results = values;
		if  (results == null)
			 results = new ArrayList<>();
		for (String result : results)
		{
			result = cleanupUnescapedEnclosingQuotes(result);
		}
		return results;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'SFBool')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Provide String representation of a current value, capitalized TRUE FALSE for VRML97 syntax.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFBool">X3D Tooltips: SFBool</a>
	 * @return String version of the provided value, VRML97 syntax
	 */
	public String toStringVRML97 ()
	{
		return String.valueOf(SFBool).toUpperCase();
	}
	/**
	 * Provide String representation of a current value, capitalized TRUE FALSE for ClassicVRML syntax.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFBool">X3D Tooltips: SFBool</a>
	 * @return String version of the provided value, ClassicVRML syntax
	 */
	public String toStringClassicVRML ()
	{
		return String.valueOf(SFBool).toUpperCase();
	}
	/**
	 * Utility method to convert provided String representation of a correctly typed input value, capitalized TRUE FALSE for VRML97 syntax.
	 * @param value The value to convert to a String
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFBool">X3D Tooltips: SFBool</a>
	 * @return String version of the provided value, VRML97 syntax
	 */
	public static String toStringVRML97 (boolean value)
	{
		return String.valueOf(value).toUpperCase();
	}
	/**
	 * Utility method to convert provided String representation of a correctly typed input value, capitalized TRUE FALSE for ClassicVRML syntax.
	 * @param value The value to convert to a String
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFBool">X3D Tooltips: SFBool</a>
	 * @return String version of the provided value, ClassicVRML syntax
	 */
	public static String toStringClassicVRML (boolean value)
	{
		return String.valueOf(value).toUpperCase();
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'MFBool')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Provide current value as a String, capitalized TRUE FALSE for VRML97 syntax.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFBool">X3D Tooltips: type MFBool</a>
	 * @return String version of the provided value, VRML97 syntax
	 */
	public String toStringVRML97()
	{
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < MFBool.length; i++)
		{
			result.append(String.valueOf(MFBool[i]).toUpperCase());
			if (i < MFBool.length - 1)
				result.append(" ");
		}
		return result.toString();
	}
	/**
	 * Provide current value as a String, capitalized TRUE FALSE for ClassicVRML syntax.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFBool">X3D Tooltips: type MFBool</a>
	 * @return String version of the provided value, ClassicVRML syntax
	 */
	public String toStringClassicVRML()
	{
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < MFBool.length; i++)
		{
			result.append(String.valueOf(MFBool[i]).toUpperCase());
			if (i < MFBool.length - 1)
				result.append(" ");
		}
		return result.toString();
	}
	/**
	 * Utility method to convert provided value as a String, capitalized TRUE FALSE for VRML97 syntax.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFBool">X3D Tooltips: type MFBool</a>
	 * @return String version of the provided value, VRML97 syntax
	 */
	public static String toStringVRML97(boolean[] value)
	{
		return toStringClassicVRML(value);
	}
	/**
	 * Utility method to convert provided value as a String, capitalized TRUE FALSE for ClassicVRML syntax.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFBool">X3D Tooltips: type MFBool</a>
	 * @return String version of the provided value, ClassicVRML syntax
	 */
	public static String toStringClassicVRML(boolean[] value)
	{
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < value.length; i++)
		{
			result.append(String.valueOf(value[i]).toUpperCase());
			if (i < value.length - 1)
				result.append(" ");
		}
		return result.toString();
	}
]]></xsl:text>
			</xsl:when>
		</xsl:choose>

		<!-- Source code: regular expression (regex) pattern match -->
		<xsl:if test="not($fieldName = 'SFNode') and not($fieldName = 'MFNode')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Determine whether two objects contain equal values.
	 * @param comparison]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> field type to compare
	 * @return true if equivalent, false otherwise
	 */
	public boolean equals(</xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> comparison</xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text>)
	{
            if (comparison</xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> == null)
                 return false;
            else return (getPrimitiveValue() == comparison</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.getPrimitiveValue());
	}
	/**
	 * Validate current value via ]]></xsl:text>
        <xsl:choose>
            <xsl:when test="contains($fieldName, 'FString')">
                <xsl:text disable-output-escaping="yes"><![CDATA[regular expression (regex) check of current object's toString() value, reporting errors only if found.
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 * @return empty string if PATTERN matches, warning otherwise]]></xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>get/set comparison tests
	 * @return empty string if get/set testing passes, warning otherwise</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see #validate
	 * @see #validateRegex()
	 */
	public final String validate()
	{
        ]]></xsl:text>
        <xsl:if test="($fieldName = 'SFImage')">
            <xsl:text>if (SFImage.length != (getWidth() * getHeight() + 3)) // validity check
		{
			String errorNotice = "*** Illegal length of SFImage integer array (" + SFImage.length +
				") while ((width=" + getWidth() + " * height=" + getHeight() + " + 3)=" + (getWidth() * getHeight() + 3);
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
        </xsl:text>
        </xsl:if>
        <xsl:choose>
            <xsl:when test="contains($fieldName, 'FString')">
                <xsl:text>return (validateRegex());</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>// validation via get/set checks and comparison
        </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> tempHold = new </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(getPrimitiveValue());
        if  (!this.equals(tempHold))
             return "</xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> validate() error: failed get/set round-trip test";
        else return "";
        </xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text disable-output-escaping="yes"><![CDATA[
    }
	/**
	 * Validate current value via regular expression (regex) check of current object's toString() value, reporting errors only if found.
	 * @see #REGEX
	 * @see #PATTERN
	 * @see #matches
	 * @see #matches(String)
	 * @see #validate
	 * @see #validate()
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 * @return empty string if PATTERN matches, warning otherwise
	 */
	public final String validateRegex()
	{
        try
        {
            java.util.regex.Matcher m = PATTERN.matcher(toString());
            if (!m.matches())
            {
			String errorNotice = "*** [error] Regular expression (regex) failure, new ]]></xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text disable-output-escaping="yes"> PATTERN mismatch (\"" + toString() + "\")";
                return errorNotice;
            }
		}
        catch (java.lang.StackOverflowError soe) // regex processing required too much memory for String version of this attribute
        {
            String validationMessage = "java.lang.StackOverflow warning: regular expression (regex) unable to evaluate large corresponding String value for </xsl:text>
		<xsl:value-of select="$fieldName"/>
        <xsl:if test="starts-with($fieldName,'MF')">
                <xsl:text> array</xsl:text>
            </xsl:if>
            <!-- TODO compute full length for all types
        <xsl:text> (length " + </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>.toString().length() + " values)</xsl:text> -->
		<xsl:text disable-output-escaping="yes"><![CDATA[";
            validationResult.append(validationMessage).append("\n");
            System.out.println ("[exception] " + validationMessage);
            return validationMessage;
		}
        return "";
	}
	/**
	 * Test PATTERN match via regular expression (regex) check of current object's toString() value.
	 * @see #REGEX
	 * @see #PATTERN
	 * @see #matches
	 * @see #matches(String)
	 * @see #validate
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 * @return true if PATTERN matches, false otherwise
	 */
	public final boolean matches()
	{
        try
        {
            java.util.regex.Matcher m = PATTERN.matcher(toString());
            return m.matches();
		}
        catch (java.lang.StackOverflowError soe) // regex processing required too much memory for String version of this attribute
        {
            String validationMessage = "java.lang.StackOverflow warning: regular expression (regex) unable to evaluate large corresponding String value for ]]></xsl:text>
            <xsl:value-of select="$fieldName"/>
            <xsl:if test="starts-with($fieldName,'MF')">
                <xsl:text> array</xsl:text>
            </xsl:if>
            <!-- TODO compute full length for all types
            <xsl:text> (length " + </xsl:text>
            <xsl:value-of select="$fieldName"/><xsl:text>.toString().length() + " values)</xsl:text> -->
            <xsl:text disable-output-escaping="yes"><![CDATA[";
            validationResult.append(validationMessage).append("\n");
            System.out.println ("[exception] " + validationMessage);
            return false;
		}
	}
	/**
	 * Test PATTERN match with regular expression (regex) of provided value.
	 * @param value String to check against regex pattern for successful match
	 * @see #REGEX
	 * @see #PATTERN
	 * @see #matches
	 * @see #matches(String)
	 * @see #validate
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 * @return true if PATTERN matches, false otherwise
	 */
	public static final boolean matches(String value)
	{
		java.util.regex.Matcher m = PATTERN.matcher(value);
		return m.matches();
	}
]]></xsl:text>
		</xsl:if>
		<xsl:if test="($fieldName = 'bboxSize')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Validate current bboxValue via regular expression (regex) check of current object's toString() value, reporting errors only if found.
	 * @see #REGEX_BOXVALUE
	 * @see #patternBboxValue
	 * @see #matchesBboxValue
	 * @see #matchesBboxValue(String)
	 * @see #validate
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 * @return empty string if patternBboxValue matches, warning otherwise
	 */
	public final String validateBboxValue()
	{
		java.util.regex.Matcher m = patternBboxValue.matcher(toString());
		if (!m.matches())
		{
			String errorNotice = "*** [error] Regular expression (regex) failure, new SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ pattern mismatch (\"" + toString() + "\")";
			return errorNotice;
		}
		else return "";
	}
	/**
	 * Test pattern match via regular expression (regex) check of current object's toString() value.
	 * @see #REGEX_BboxValue
	 * @see #patternBboxValue
	 * @see #matchesBboxValue
	 * @see #matchesBboxValue(String)
	 * @see #validate
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 * @return true if patternBboxValue matches, false otherwise
	 */
	public final boolean matchesBboxValue()
	{
		java.util.regex.Matcher m = patternBboxValue.matcher(toString());
		return m.matches();
	}
	/**
	 * Test pattern match with regular expression (regex) of provided value.
	 * @param value String to check against regex pattern for successful match
	 * @see #REGEX_BOXVALUE
	 * @see #patternBboxValue
	 * @see #matchesBboxValue
	 * @see #matchesBboxValue(String)
	 * @see #validate
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a>
	 * @return true if patternBboxValue matches, false otherwise
	 */
	public static final boolean matchesBboxValue(String value)
	{
		java.util.regex.Matcher m = patternBboxValue.matcher(value);
		return m.matches();
	}
]]></xsl:text>
		</xsl:if>

		<!-- Source code: constructor method using initial String value.  Typically protected/hidden, designed for reflection use. -->
		<xsl:if test="not($fieldName = 'SFNode') and not($fieldName = 'MFNode')">
		<xsl:text>
	/**
	 * Utility accessor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using String value</xsl:text>
	<xsl:choose>
		<xsl:when test="($fieldName = 'SFString') or ($fieldName = 'MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @param newValue is new value to assign
	 * @return {@link MFMatrix4d} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text> setValueByString</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text disable-output-escaping="yes"><![CDATA[ (which must pass parsing validation checks).
	 * <br ><br >
	 * <i>Warning:</i> this method is not
	 * <i><a href="https://en.wikipedia.org/wiki/Type_safety" target="_blank">type safe</a></i>
	 * at compile time!  Best practice for X3DJSAIL programmers is to use strongly typed methods instead, in order to avoid potential for run-time errors.
	 * @see X3DLoaderDOM#toX3dModelInstance(org.w3c.dom.Node)
	 * @param newValue is new value to assign, if empty then assign DEFAULT_VALUE
	 * @return {@link MFMatrix4d} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text> setValueByString</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text> (String newValue) throws InvalidFieldValueException
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA) #1
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment

		if (!</xsl:text>
        <!--
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text>.</xsl:text>
-->
<xsl:text>matches(newValue)) // regex test
		{
			String errorNotice = "*** [error] Regular expression (regex) failure, new </xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text>(" + newValue + ")";
			validationResult.append(errorNotice).append("\n");
		}
		if (newValue.trim().isEmpty())
		{
			</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return this;
		}</xsl:text>
		<xsl:if test="not(contains($fieldName, 'FString')) and not(contains($fieldName, 'FBool'))">
			<xsl:text>
		try
		{</xsl:text>
		</xsl:if>
		<xsl:text>
			</xsl:text>
			<xsl:choose>
				<xsl:when test="($fieldName = 'SFBool')">
					<xsl:text disable-output-escaping="yes"><![CDATA[if (!newValue.equals("true") && !newValue.equals("false"))
		{
			String errorNotice = "*** illegal boolean value, must be 'true' or 'false' (case sensitive), new ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
			validationResult.append(errorNotice).append("\n");
                        // TODO convert, support, handle other values, provide notification instead of throwing exception
			throw new InvalidFieldValueException(errorNotice);
		}
		</xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = Boolean.parseBoolean(newValue); // case insensitive</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFInt32')">
					<xsl:text>// https://stackoverflow.com/questions/11194513/convert-hex-string-to-int
			if (newValue.startsWith("0x"))
			     </xsl:text><xsl:value-of select="$fieldName"/><xsl:text> = Integer.decode  (newValue); // read hex value
			else </xsl:text><xsl:value-of select="$fieldName"/><xsl:text> = Integer.parseInt(newValue); // read int value</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFFloat')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = Float.parseFloat(newValue);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFDouble')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = Double.parseDouble(newValue);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFString')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = newValue;</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFTime')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ = Double.parseDouble(newValue);
]]></xsl:text>
                    <!-- negative time values are allowed
					<xsl:text disable-output-escaping="yes"><![CDATA[
			if ((SFTime < 0.0) && (SFTime != DEFAULT_VALUE)) // initial value check
			{
				SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			}</xsl:text>
                    -->
				</xsl:when>
				<!-- https://stackoverflow.com/questions/225337/how-do-i-split-a-string-with-any-whitespace-chars-as-delimiters -->
				<xsl:when test="($fieldName = 'SFVec2d')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 2)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec2d[0] = Double.parseDouble(newValues[0]);
			SFVec2d[1] = Double.parseDouble(newValues[1]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec2f')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 2)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec2f[0] = Float.parseFloat(newValues[0]);
			SFVec2f[1] = Float.parseFloat(newValues[1]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec3d')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 3)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec3d[0] = Double.parseDouble(newValues[0]);
			SFVec3d[1] = Double.parseDouble(newValues[1]);
			SFVec3d[2] = Double.parseDouble(newValues[2]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec3f')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 3)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec3f[0] = Float.parseFloat(newValues[0]);
			SFVec3f[1] = Float.parseFloat(newValues[1]);
			SFVec3f[2] = Float.parseFloat(newValues[2]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFColor')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 3)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFColor[0] = Float.parseFloat(newValues[0]);
			SFColor[1] = Float.parseFloat(newValues[1]);
			SFColor[2] = Float.parseFloat(newValues[2]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFColorRGBA')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 4)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFColorRGBA[0] = Float.parseFloat(newValues[0]);
			SFColorRGBA[1] = Float.parseFloat(newValues[1]);
			SFColorRGBA[2] = Float.parseFloat(newValues[2]);
			SFColorRGBA[3] = Float.parseFloat(newValues[3]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec4d')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 4)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec4d[0] = Double.parseDouble(newValues[0]);
			SFVec4d[1] = Double.parseDouble(newValues[1]);
			SFVec4d[2] = Double.parseDouble(newValues[2]);
			SFVec4d[3] = Double.parseDouble(newValues[3]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec4f')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 4)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec4f[0] = Float.parseFloat(newValues[0]);
			SFVec4f[1] = Float.parseFloat(newValues[1]);
			SFVec4f[2] = Float.parseFloat(newValues[2]);
			SFVec4f[3] = Float.parseFloat(newValues[3]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFRotation')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 4)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFRotation[0] = Float.parseFloat(newValues[0]);
			SFRotation[1] = Float.parseFloat(newValues[1]);
			SFRotation[2] = Float.parseFloat(newValues[2]);
			SFRotation[3] = Float.parseFloat(newValues[3]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFMatrix3d')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 9)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFMatrix3d[0] = Double.parseDouble(newValues[0]);
			SFMatrix3d[1] = Double.parseDouble(newValues[1]);
			SFMatrix3d[2] = Double.parseDouble(newValues[2]);
			SFMatrix3d[3] = Double.parseDouble(newValues[3]);
			SFMatrix3d[4] = Double.parseDouble(newValues[4]);
			SFMatrix3d[5] = Double.parseDouble(newValues[5]);
			SFMatrix3d[6] = Double.parseDouble(newValues[6]);
			SFMatrix3d[7] = Double.parseDouble(newValues[7]);
			SFMatrix3d[8] = Double.parseDouble(newValues[8]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFMatrix3f')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 9)
			{
				String errorNotice = "*** illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFMatrix3f[0] = Float.parseFloat(newValues[0]);
			SFMatrix3f[1] = Float.parseFloat(newValues[1]);
			SFMatrix3f[2] = Float.parseFloat(newValues[2]);
			SFMatrix3f[3] = Float.parseFloat(newValues[3]);
			SFMatrix3f[4] = Float.parseFloat(newValues[4]);
			SFMatrix3f[5] = Float.parseFloat(newValues[5]);
			SFMatrix3f[6] = Float.parseFloat(newValues[6]);
			SFMatrix3f[7] = Float.parseFloat(newValues[7]);
			SFMatrix3f[8] = Float.parseFloat(newValues[8]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFMatrix4d')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 16)
			{
				String errorNotice = "*** illegal number of values in initialization string";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFMatrix4d [0] = Double.parseDouble(newValues[0]);
			SFMatrix4d [1] = Double.parseDouble(newValues[1]);
			SFMatrix4d [2] = Double.parseDouble(newValues[2]);
			SFMatrix4d [3] = Double.parseDouble(newValues[3]);
			SFMatrix4d [4] = Double.parseDouble(newValues[4]);
			SFMatrix4d [5] = Double.parseDouble(newValues[5]);
			SFMatrix4d [6] = Double.parseDouble(newValues[6]);
			SFMatrix4d [7] = Double.parseDouble(newValues[7]);
			SFMatrix4d [8] = Double.parseDouble(newValues[8]);
			SFMatrix4d [9] = Double.parseDouble(newValues[9]);
			SFMatrix4d[10] = Double.parseDouble(newValues[10]);
			SFMatrix4d[11] = Double.parseDouble(newValues[11]);
			SFMatrix4d[12] = Double.parseDouble(newValues[12]);
			SFMatrix4d[13] = Double.parseDouble(newValues[13]);
			SFMatrix4d[14] = Double.parseDouble(newValues[14]);
			SFMatrix4d[15] = Double.parseDouble(newValues[15]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFMatrix4f')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			if (newValues.length != 16)
			{
				String errorNotice = "*** illegal number of values in initialization string";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFMatrix4f [0] = Float.parseFloat(newValues[0]);
			SFMatrix4f [1] = Float.parseFloat(newValues[1]);
			SFMatrix4f [2] = Float.parseFloat(newValues[2]);
			SFMatrix4f [3] = Float.parseFloat(newValues[3]);
			SFMatrix4f [4] = Float.parseFloat(newValues[4]);
			SFMatrix4f [5] = Float.parseFloat(newValues[5]);
			SFMatrix4f [6] = Float.parseFloat(newValues[6]);
			SFMatrix4f [7] = Float.parseFloat(newValues[7]);
			SFMatrix4f [8] = Float.parseFloat(newValues[8]);
			SFMatrix4f [9] = Float.parseFloat(newValues[9]);
			SFMatrix4f[10] = Float.parseFloat(newValues[10]);
			SFMatrix4f[11] = Float.parseFloat(newValues[11]);
			SFMatrix4f[12] = Float.parseFloat(newValues[12]);
			SFMatrix4f[13] = Float.parseFloat(newValues[13]);
			SFMatrix4f[14] = Float.parseFloat(newValues[14]);
			SFMatrix4f[15] = Float.parseFloat(newValues[15]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFBool')">
                                    <!-- https://stackoverflow.com/questions/3958955/how-to-remove-duplicate-white-spaces-in-string-using-java -->
					<xsl:text><![CDATA[String[] newValues = newValue.replace(","," ").replaceAll("\\s+", " ").trim().split("\\s+");
			]]></xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text> = new </xsl:text><xsl:value-of select="$javaPrimitiveType"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[[newValues.length];
			int i = 0;
			for (String value : newValues)
			{
				if (!value.equals("true") && !value.equals("false"))
				{
					String errorNotice = "*** illegal boolean value for ]]></xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>() initialization, newValue[" + i + "]='" + value + "' but must be 'true' or 'false' (case sensitive)";
 					validationResult.append(errorNotice).append("\n");
					throw new InvalidFieldValueException(errorNotice);
				}
				</xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text>[i] = Boolean.parseBoolean(value); // append to array, case insensitive
				i++;
			}</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFString')">
					<xsl:text><![CDATA[if (!newValue.contains("\""))
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text> = new String[1];
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = newValue; // simple single string (value missing "wrapped quotes")
				return this;
			}
			String[] newValues = cleanupUnescapedEnclosingQuotes(newValue.trim()).split("\"[\\s+]\"");
			</xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text><![CDATA[ = new String[newValues.length];
			for (int i=0; i < newValues.length; i++)
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text>[i] = newValues[i].replace("\\\"","\""); // fill array, no backslash escapes preceding contained quote characters
			}</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFInt32') or ($fieldName = 'SFImage') or ($fieldName = 'MFImage')">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");
			</xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = new </xsl:text>
					<xsl:choose>
						<xsl:when test="contains($javaPrimitiveType,'[')">
							<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$javaPrimitiveType"/>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:text>[newValues.length];  // reset array size to match</xsl:text>
					<xsl:text disable-output-escaping="yes"><![CDATA[
			for (int i = 0; i < newValues.length;i++)
			{
				// https://stackoverflow.com/questions/11194513/convert-hex-string-to-int
				if  (newValues[i].startsWith("0x"))
				     ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[i] = Integer.decode  (newValues[i]); // insert hex value into array
				else </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[i] = Integer.parseInt(newValues[i]); // insert int value into array
			}</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFDouble') or ($fieldName = 'MFTime') or
                                                (starts-with($fieldName, 'MFVec') and ends-with($fieldName, 'd')) or
                                                (  contains($fieldName, 'Matrix') and ends-with($fieldName, 'd'))">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");</xsl:text>
					<xsl:if test="not($fieldName = 'MFDouble')">
						<xsl:text>
			if ((newValues.length % </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) != 0) // tupleSize modulus check
			{
				String errorNotice = "*** illegal number of values (" + newValues.length + ")" +
					" in initialization string, must be multiple of </xsl:text>
					<xsl:value-of select="$tupleSize"/><xsl:text> when declaring new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			</xsl:text>
			</xsl:if>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = new </xsl:text>
					<xsl:choose>
						<xsl:when test="contains($javaPrimitiveType,'[')">
							<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$javaPrimitiveType"/>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:text>[newValues.length];  // reset array size to match</xsl:text>
					<xsl:text disable-output-escaping="yes"><![CDATA[
			for (int i = 0; i < newValues.length;i++)
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[i] = Double.parseDouble(newValues[i]); // insert in array</xsl:text>
					<xsl:if test="($fieldName = 'MFTime')">
						<xsl:text disable-output-escaping="yes"><![CDATA[
				if ((MFTime[i] < 0.0) && (MFTime[i] != SFTime.DEFAULT_VALUE)) // initial value check
				{
					MFTime[i] = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
				}]]></xsl:text>
					</xsl:if>
					<xsl:text>
			}</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFFloat') or
                                                (contains($fieldName, 'FColor')) or (contains($fieldName, 'FRotation')) or
                                                (starts-with($fieldName, 'MFVec') and ends-with($fieldName, 'f')) or
                                                (  contains($fieldName, 'Matrix') and ends-with($fieldName, 'f'))">
					<xsl:text>String[] newValues = newValue.replace(","," ").trim().split("\\s+");</xsl:text>
					<xsl:if test="not($fieldName = 'MFFloat') and not($fieldName = 'MFTime')">
						<xsl:text>
			if ((newValues.length % </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) != 0) // tupleSize modulus check
			{
				String errorNotice = "*** illegal number of values (" + newValues.length + ")" +
					" in initialization string, must be multiple of </xsl:text>
					<xsl:value-of select="$tupleSize"/><xsl:text> when declaring new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}</xsl:text>
					</xsl:if>
					<xsl:text>
			</xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = new </xsl:text>
					<xsl:choose>
						<xsl:when test="contains($javaPrimitiveType,'[')">
							<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$javaPrimitiveType"/>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:text>[newValues.length];  // reset array size to match</xsl:text>
					<xsl:text disable-output-escaping="yes"><![CDATA[
			for (int i = 0; i < newValues.length;i++)
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[i] = Float.parseFloat(newValues[i]); // insert in array
			}</xsl:text>
				</xsl:when>
				<!-- TODO extraneous?? -->
				<xsl:when test="starts-with($fieldName,'MF')">
					<xsl:text> TODO extraneous?? </xsl:text>
				</xsl:when>
			</xsl:choose>
	<xsl:if test="not(contains($fieldName, 'FString')) and not(contains($fieldName, 'FBool'))">
		<xsl:text>
		}
		catch (</xsl:text>
		<xsl:choose>
			<xsl:when test="($fieldName = 'SFBool')">
				<xsl:text>TODO omit</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>NumberFormat</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
			<xsl:text>Exception e)
		{
			String errorNotice = "*** new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ") " + e.getMessage();
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException (errorNotice);
		}</xsl:text>
	</xsl:if>
	<xsl:text>
		return this;
	}
</xsl:text>
		</xsl:if>

		<!-- Source code: constructor method using default SFtype initial value -->
		<xsl:if test="starts-with(@type, 'MF') and ($tupleSize = 1) and not(contains($fieldName, 'FString')) and not(contains($fieldName, 'FBool')) and not(contains($fieldName, 'FImage'))">
			<xsl:text>
	/**
	 * Utility constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> to assign a single </xsl:text>
	<xsl:value-of select="substring-before($javaType,'[]')"/>
	<xsl:text> as new initial array value.
	 * @param newValue is new value to assign
	 */
	public </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> (</xsl:text>
	<xsl:value-of select="substring-before($javaType,'[]')"/>
	<xsl:text> newValue)
	{
		</xsl:text>
		<xsl:text>setValue(new S</xsl:text>
		<xsl:value-of select="substring(@type, 2)"/>
		<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
		<xsl:text>(newValue));
	}

	/**
	 * Utility constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using a corresponding S</xsl:text>
	<xsl:value-of select="substring(@type, 2)"/>
	<xsl:value-of select="$jsaiClassSuffix"/><xsl:text> as new initial value (which must pass parsing validation checks).
	 * @param newValue is new value to assign
	 */
	public </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> (</xsl:text>
	<xsl:text>S</xsl:text>
	<xsl:value-of select="substring(@type, 2)"/>
	<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
	<xsl:text> newValue)
	{
		if (newValue == null)
		{
			</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return;
		}
		</xsl:text>
	<xsl:choose>
		<xsl:when test="contains(@type,'FVec') and ends-with(@type,'d')">
			<xsl:text>setValue(newValue.toDoubleArray()); // create array</xsl:text>
		</xsl:when>
		<xsl:when test="contains(@type,'Color') or contains(@type,'Rotation') or contains(@type,'FVec') or starts-with(@type,'SFMatrix')">
			<xsl:text>setValue(newValue.toFloatArray()); // create array</xsl:text>
		</xsl:when>
		<xsl:when test="starts-with(@type,'MFMatrix') or (@type = 'MFImage')">
			<xsl:text>// TODO matrix initialization</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[ = new ]]></xsl:text>
			<xsl:value-of select="substring-before($javaType,'[]')"/>
			<xsl:text>[1]; // create array
		</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>[0] = newValue.getValue();</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
	}
</xsl:text>
		</xsl:if>

					<!-- common field constructor: setValue using another field of same type -->
					<xsl:text><![CDATA[
	/**
	 * Constructor to copy an ]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[ value as initial value for this new field object.
	 * @param newValue The newValue to apply
	 */
	public ]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text>(</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> newValue)
	{
		if (newValue == null)
		{
			</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return;
		}
		</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = newValue.getPrimitiveValue();
	}
]]></xsl:text>

		<!-- Source code: constructor method using typed primitive value -->
		<xsl:text>
	/**
	 * Constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using a corresponding Java primitive </xsl:text>
	<xsl:value-of select="$javaType"/>
	<xsl:text> </xsl:text>
	<xsl:if test="contains($javaType,'[')">
		<xsl:text>array </xsl:text>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[as new initial value.
	 * @param newValue is new value to assign]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * setContainerFieldOverride(containerFieldName); // apply checksConcreteField#getTupleSize(String)
	 */
	public ]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> (</xsl:text>
	<xsl:value-of select="$javaType"/>
	<xsl:text> newValue)
	{</xsl:text>
		<!-- initial value checks -->
		<xsl:choose>
			<xsl:when test="starts-with(@type,'MF') and ends-with($javaType, '[]') and not($tupleSize = '1')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length % </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ != 0) // ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[-tuple check
		{
			String errorNotice = "*** Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must be multiple of ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
		<xsl:when test="starts-with(@type,'SF') and ends-with($javaType, '[]') and not($tupleSize = '1')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length != </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[)
		{
			String errorNotice = "*** Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must equal ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="ends-with($javaType, '[]')"><!-- ($tupleSize == 1) -->
			<xsl:text disable-output-escaping="yes"><![CDATA[
		if (newValue == null)
			newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		</xsl:text>
			</xsl:when>
		</xsl:choose>
		<xsl:choose>
			<xsl:when test="(@type='MFString')">
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ = new String[newValue.length];
//		for (int i=0; i < newValue.length; i++)
//			newValue[i] = cleanupUnescapedEnclosingQuotes(newValue[i]); // fill array
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((newValue < 0.0) && (newValue != DEFAULT_VALUE)) // initial value check
		{
			SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return;
		}</xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		for (int i = 0; i < newValue.length; i++)
		{
			if ((newValue[i] < 0.0) && (newValue[i] != SFTime.DEFAULT_VALUE)) // initial value check
			{
				newValue[i] = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
			}
		}]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColor')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// initial value checks
		float   red = newValue[0];
		float green = newValue[1];
		float  blue = newValue[2];
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "*** Illegal SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			throw new InvalidFieldValueException(errorNotice);
		}]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColorRGBA')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// initial value checks
		float   red = newValue[0];
		float green = newValue[1];
		float  blue = newValue[2];
		float alpha = newValue[3];
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "*** Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}]]></xsl:text>
			</xsl:when>
		</xsl:choose>

        <xsl:text disable-output-escaping="yes"><![CDATA[
		]]></xsl:text>
		<xsl:value-of select="$fieldName"/>
		<xsl:text> = newValue;
	}
</xsl:text>

		<!-- Utility constructors for fields-->
		<xsl:choose>
			<xsl:when test="(@type='MFBool')">
	<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor for MFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ using a single corresponding Java primitive boolean as new initial value.
	 * @param newValue is new value to assign
	 */
	public MFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ (boolean newValue)
	{
		MFBool = new boolean[1]; // fix array size
		MFBool[0] = newValue;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFTime')">
	<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor for MFTime]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ using a single float as new initial value.
	 * @param newValue is new value to assign
	 */
	public MFTime]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ (float newValue)
	{
		setValue(newValue); // apply checks
	}
	/**
	 * Constructor for MFTime]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ using a float[] array as new initial value.
	 * @param newValue is new value to assign
	 */
	public MFTime]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ (float[] newValue)
	{
		setValue(newValue); // apply checks
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFString')">
				<xsl:text>
	/**
	 * Constructor to parse String as new initial value.
	 * @param newValue is new value to assign
	 */
	public MFString</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (String newValue)
	{
		setValueByString(newValue);
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFFloat')">
				<xsl:text>
	/**
	 * Constructor using double as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFFloat</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (double newValue)
	{
		SFFloat = (float) newValue;
	}
	/**
	 * Constructor using int as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int newValue)
	{
		SFFloat = (float) newValue;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFDouble')">
				<xsl:text><![CDATA[
	/**
	 * Constructor using float as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFDouble]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (float newValue)
	{
		SFDouble = (double) newValue;
	}
	/**
	 * Constructor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ using int as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFDouble]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int newValue)
	{
		SFDouble = (double) newValue;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFTime')">
				<xsl:text>
	/**
	 * Constructor using float as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFTime</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (float newValue)
	{
		SFTime = (double) newValue;
		if ((SFTime < 0.0) && (SFTime != DEFAULT_VALUE)) // initial value check
		{
			SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		}
	}
	/**
	 * Constructor using int as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFTime</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int newValue)
	{
		SFTime = (double) newValue;
		if ((SFTime < 0.0) && (SFTime != DEFAULT_VALUE)) // initial value check
		{
			SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		}
	}
</xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColor')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor using individual float types as new initial value (which must pass validation checks).
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (float red, float green, float blue)
	{
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "*** Illegal SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColor[0] = red;
		SFColor[1] = green;
		SFColor[2] = blue;
	}
	/**
	 * Constructor using individual double types as new initial value (which must pass validation checks).
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (double red, double green, double blue)
	{
		setValue ((float) red, (float) green, (float) blue);
	}
	/**
	 * Constructor using single HTML-style 0xRRGGBB hex value as new initial value.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int hexColorValue)
	{
		// https://stackoverflow.com/questions/12798611/splitting-a-hex-number

		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;

		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "*** Illegal SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColor[0] = red;
		SFColor[1] = green;
		SFColor[2] = blue;
	}
	/**
	 * Public utility method converting single HTML-style 0xRRGGBB hex value to three-tuple float array.
TODO: also MFColor.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return float[3] array containing X3D RGB values, each ranging [0..1]
	 */
	public static float[] toFloatArray (int hexColorValue)
	{
		// https://stackoverflow.com/questions/12798611/splitting-a-hex-number

		float[] newFloatArray = {0.0f, 0.0f, 0.0f};

		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;

		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "*** Illegal SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		newFloatArray[0] = red;
		newFloatArray[1] = green;
		newFloatArray[2] = blue;
		return newFloatArray;
	}
	/**
	 * Public utility accessor method setting single HTML-style 0xRRGGBB hex value as new value.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue (int hexColorValue)
	{
		// https://stackoverflow.com/questions/12798611/splitting-a-hex-number

		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;

		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "*** Illegal ;SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColor[0] = red;
		SFColor[1] = green;
		SFColor[2] = blue;
		return this;
	}
	/**
	 * Complement all color values in RGB space (i.e. subtract each component from 1).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementRGB()
	{
		SFColor[0] = 1.0f - SFColor[0];
		SFColor[1] = 1.0f - SFColor[1];
		SFColor[2] = 1.0f - SFColor[2];
		return this;
	}
	/**
	 * Scale all color values in RGB space.
	 * @param scaleFactor nonnegative scaling factor
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ scaleRGB (float scaleFactor)
	{
		if (scaleFactor < 0.0f)
		{
			String errorNotice = "*** Illegal scaleFactor value (" + scaleFactor + "), must be nonnegative";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColor[0] *= scaleFactor;
		SFColor[1] *= scaleFactor;
		SFColor[2] *= scaleFactor;
		return this;
	}
	/**
	 * Ensure all component color values are within range [0-1] by clipping as necessary.
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalizeClip()
	{
		if (SFColor[0] < 0.0f) SFColor[0] = 0.0f;
		if (SFColor[1] < 0.0f) SFColor[1] = 0.0f;
		if (SFColor[2] < 0.0f) SFColor[2] = 0.0f;
		if (SFColor[0] > 1.0f) SFColor[0] = 1.0f;
		if (SFColor[1] > 1.0f) SFColor[1] = 1.0f;
		if (SFColor[2] > 1.0f) SFColor[2] = 1.0f;
		return this;
	}
	/**
	 * Provide HTML color value for this object.
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @see <a href="https://www.w3.org/TR/html52/infrastructure.html#colors">HyperText Markup Language (HTML) 5.2, section 2.4.6 Colors</a>
	 * @see <a href="https://www.w3.org/TR/css-color-3">Cascading Style Sheets (CSS) Color Module Level 3</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/java/data/numberformat.html">Java Tutorials: Formatting Numeric Print Output</a>
	 * @see <a href="https://stackoverflow.com/questions/8689526/integer-to-two-digits-hex-in-java">stackoverflow: Integer to two digits hex in Java</a>
	 * @return HTML color value
	 */
	public String toStringHTML()
	{
		return "#" +
               String.format("%02X", (int)(SFColor[0] * 255.0)).toLowerCase() +
               String.format("%02X", (int)(SFColor[1] * 255.0)).toLowerCase() +
               String.format("%02X", (int)(SFColor[2] * 255.0)).toLowerCase();
	}
	/**
	 * Provide HTML color value for RGB values.
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @param red red value [0..1]
	 * @param green value value [0..1]
	 * @param blue blue value [0..1]
	 * @see <a href="https://www.w3.org/TR/html52/infrastructure.html#colors">HyperText Markup Language (HTML) 5.2, section 2.4.6 Colors</a>
	 * @see <a href="https://www.w3.org/TR/css-color-3">Cascading Style Sheets (CSS) Color Module Level 3</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/java/data/numberformat.html">Java Tutorials: Formatting Numeric Print Output</a>
	 * @see <a href="https://stackoverflow.com/questions/8689526/integer-to-two-digits-hex-in-java">stackoverflow: Integer to two digits hex in Java</a>
	 * @return HTML color value
	 */
	public static String toStringHTML(float red, float green, float blue)
	{
        SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue = new SFColor(red, green, blue);
		return newValue.toStringHTML();
	}
	/**
	 * Provide HTML color value for an RGB triplet.
	 * @param colors RGB triplet with values [0..1]
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @see <a href="https://www.w3.org/TR/html52/infrastructure.html#colors">HyperText Markup Language (HTML) 5.2, section 2.4.6 Colors</a>
	 * @see <a href="https://www.w3.org/TR/css-color-3">Cascading Style Sheets (CSS) Color Module Level 3</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/java/data/numberformat.html">Java Tutorials: Formatting Numeric Print Output</a>
	 * @see <a href="https://stackoverflow.com/questions/8689526/integer-to-two-digits-hex-in-java">stackoverflow: Integer to two digits hex in Java</a>
	 * @return HTML color value
	 */
	public static String toStringHTML(float[] colors)
	{
        SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue = new SFColor(colors);
		return newValue.toStringHTML();
	}
	/**
	 * Provide CSS color value for this object.
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @see <a href="https://www.w3.org/TR/html52/infrastructure.html#colors">HyperText Markup Language (HTML) 5.2, section 2.4.6 Colors</a>
	 * @see <a href="https://www.w3.org/TR/css-color-3/#numerical">Cascading Style Sheets (CSS) Color Module Level 3: section 4.2.1. RGB color values</a>
	 * @return CSS color value
	 */
	public String toStringCSS()
	{
		return "color:(" +
               Integer.toString((int)(SFColor[0] * 255.0)) + "," +
               Integer.toString((int)(SFColor[1] * 255.0)) + "," +
               Integer.toString((int)(SFColor[2] * 255.0)) + ")";
	}
	/**
	 * Provide CSS color value for RGB values.
	 * @param red red value [0..1]
	 * @param green value value [0..1]
	 * @param blue blue value [0..1]
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @see <a href="https://www.w3.org/TR/html52/infrastructure.html#colors">HyperText Markup Language (HTML) 5.2, section 2.4.6 Colors</a>
	 * @see <a href="https://www.w3.org/TR/css-color-3/#numerical">Cascading Style Sheets (CSS) Color Module Level 3: section 4.2.1. RGB color values</a>
	 * @return CSS color value
	 */
	public static String toStringCSS(float red, float green, float blue)
	{
        SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue = new SFColor(red, green, blue);
		return newValue.toStringCSS();
	}
	/**
	 * Provide CSS color value foran RGB triplet.
	 * @param colors RGB triplet with values [0..1]
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @see <a href="https://www.w3.org/TR/html52/infrastructure.html#colors">HyperText Markup Language (HTML) 5.2, section 2.4.6 Colors</a>
	 * @see <a href="https://www.w3.org/TR/css-color-3">Cascading Style Sheets (CSS) Color Module Level 3</a>
	 * @return CSS color value
	 */
	public static String toStringCSS(float[] colors)
	{
        SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue = new SFColor(colors);
		return newValue.toStringCSS();
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColorRGBA')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor using individual float types as new initial value (which must pass validation checks).
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @param alpha fourth component for opaqueness (1 - transparency) [0..1]
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[  (float red, float green, float blue, float alpha)
	{
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "*** Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColorRGBA[0] = red;
		SFColorRGBA[1] = green;
		SFColorRGBA[2] = blue;
		SFColorRGBA[3] = alpha;
	}
	/**
	 * Constructor using individual double types as new initial value (which must pass validation checks).
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @param alpha fourth component for opaqueness (1 - transparency) [0..1]
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[  (double red, double green, double blue, double alpha)
	{
		setValue ((float) red, (float) green, (float) blue, (float) alpha);
	}
	/**
	 * Constructor using single HTML-style 0xRRGGBB hex value as new initial value.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int hexColorValue, float alpha)
	{
		// https://stackoverflow.com/questions/12798611/splitting-a-hex-number

		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;

		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "*** Illegal SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColorRGBA[0] = red;
		SFColorRGBA[1] = green;
		SFColorRGBA[2] = blue;
		SFColorRGBA[3] = alpha;
	}
	/**
	 * Public utility accessor method setting single HTML-style 0xRRGGBB hex value as new value.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue (int hexColorValue, float alpha)
	{
		// https://stackoverflow.com/questions/12798611/splitting-a-hex-number

		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;

		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "*** Illegal SFColor value (" + red + "," + green + "," + blue + "," + alpha +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColorRGBA[0] = red;
		SFColorRGBA[1] = green;
		SFColorRGBA[2] = blue;
		SFColorRGBA[3] = alpha;
		return this;
	}
	/**
	 * Complement all color values in RGB space (i.e. subtract each component from 1), with no change in alpha.
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementRGB()
	{
		SFColorRGBA[0] = 1.0f - SFColorRGBA[0];
		SFColorRGBA[1] = 1.0f - SFColorRGBA[1];
		SFColorRGBA[2] = 1.0f - SFColorRGBA[2];
		return this;
	}
	/**
	 * Complement alpha value by subtracting it from 1, note transparency = (1 - alpha).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementAlpha()
	{
		SFColorRGBA[3] = 1.0f - SFColorRGBA[3];
		return this;
	}
	/**
	 * Ensure all component color values are within range [0-1] by clipping as necessary.
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalizeClip()
	{
		if (SFColorRGBA[0] < 0.0f) SFColorRGBA[0] = 0.0f;
		if (SFColorRGBA[1] < 0.0f) SFColorRGBA[1] = 0.0f;
		if (SFColorRGBA[2] < 0.0f) SFColorRGBA[2] = 0.0f;
		if (SFColorRGBA[3] < 0.0f) SFColorRGBA[3] = 0.0f;
		if (SFColorRGBA[0] > 1.0f) SFColorRGBA[0] = 1.0f;
		if (SFColorRGBA[1] > 1.0f) SFColorRGBA[1] = 1.0f;
		if (SFColorRGBA[2] > 1.0f) SFColorRGBA[2] = 1.0f;
		if (SFColorRGBA[3] > 1.0f) SFColorRGBA[3] = 1.0f;
		return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFColor')">
				<!-- TODO hex array constructor and accessors -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param index is position of selected value in current array
	 * @param hexColorValue HTML color value (such as 0xAA2288) to apply
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ set1Value(int index, int hexColorValue) throws ArrayIndexOutOfBoundsException
	{
		if (index < 0)
		{
			String errorNotice = "*** Index value is negative, thus cannot set1Value at index=" + index + ".";
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
		if (index >= MFColor.length / TUPLE_SIZE) // tupleSize factor
		{
			String errorNotice = "*** Provided array index=" + index + " (for 3-tuples) must be less than MFColor array length=" + MFColor.length / TUPLE_SIZE;
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		// https://stackoverflow.com/questions/12798611/splitting-a-hex-number

		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;

		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "*** Illegal SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		MFColor[3*index + 0] = red;
		MFColor[3*index + 1] = green;
		MFColor[3*index + 2] = blue;
		return this;
	}
	/**
	 * Complement all color values in RGB space (i.e. subtract each component from 1).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementRGB()
	{
		for (int index = 0; index+2 < MFColor.length; index = index + 3)
		{
			MFColor[3*index + 0] = 1.0f - MFColor[3*index + 0];
			MFColor[3*index + 1] = 1.0f - MFColor[3*index + 1];
			MFColor[3*index + 2] = 1.0f - MFColor[3*index + 2];
		}
		return this;
	}
	/**
	 * Ensure all component color values are within range [0-1] by clipping as necessary.
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalizeClip()
	{
		for (int index = 0; index+2 < MFColor.length; index = index + 3)
		{
			if (MFColor[3*index + 0] < 0.0f) MFColor[3*index + 0] = 0.0f;
			if (MFColor[3*index + 1] < 0.0f) MFColor[3*index + 1] = 0.0f;
			if (MFColor[3*index + 2] < 0.0f) MFColor[3*index + 2] = 0.0f;
			if (MFColor[3*index + 0] > 1.0f) MFColor[3*index + 0] = 1.0f;
			if (MFColor[3*index + 1] > 1.0f) MFColor[3*index + 1] = 1.0f;
			if (MFColor[3*index + 2] > 1.0f) MFColor[3*index + 2] = 1.0f;
		}
		return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFColorRGBA')">
				<!-- TODO hex array constructor and accessors -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param index is position of selected value in current array
	 * @param hexColorValue The HTML color value (such as 0xAA2288) to apply
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ set1Value(int index, int hexColorValue, float alpha) throws ArrayIndexOutOfBoundsException
	{
		if (index < 0)
		{
			String errorNotice = "*** Index value is negative, thus cannot set1Value at index=" + index + ".";
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
		if (index >= MFColorRGBA.length / TUPLE_SIZE) // tupleSize factor
		{
			String errorNotice = "*** Provided array index=" + index + " (for 4-tuples) must be less than MFColor array length=" + MFColorRGBA.length / TUPLE_SIZE;
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}

		// https://stackoverflow.com/questions/12798611/splitting-a-hex-number

		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;

		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "*** Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		MFColorRGBA[4*index + 0] = red;
		MFColorRGBA[4*index + 1] = green;
		MFColorRGBA[4*index + 2] = blue;
		MFColorRGBA[4*index + 3] = alpha;
		return this;
	}
	/**
	 * Complement all color values of array in RGB space (i.e. subtract each component from 1).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementRGB()
	{
		for (int index = 0; index+3 < MFColorRGBA.length; index = index + 4)
		{
			MFColorRGBA[4*index + 0] = 1.0f - MFColorRGBA[4*index + 0];
			MFColorRGBA[4*index + 1] = 1.0f - MFColorRGBA[4*index + 1];
			MFColorRGBA[4*index + 2] = 1.0f - MFColorRGBA[4*index + 2];
		}
		return this;
	}
	/**
	 * Complement each alpha value of array by subtracting it from 1, note transparency = (1 - alpha).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementAlpha()
	{
		for (int index = 0; index+3 < MFColorRGBA.length; index = index + 4)
		{
			MFColorRGBA[4*index + 3] = 1.0f - MFColorRGBA[4*index + 3];
		}
		return this;
	}
	/**
	 * Ensure all component color values are within range [0-1] by clipping as necessary.
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalizeClip()
	{
		for (int index = 0; index+3 < MFColorRGBA.length; index = index + 4)
		{
			if (MFColorRGBA[4*index + 0] < 0.0f) MFColorRGBA[4*index + 0] = 0.0f;
			if (MFColorRGBA[4*index + 1] < 0.0f) MFColorRGBA[4*index + 1] = 0.0f;
			if (MFColorRGBA[4*index + 2] < 0.0f) MFColorRGBA[4*index + 2] = 0.0f;
			if (MFColorRGBA[4*index + 3] < 0.0f) MFColorRGBA[4*index + 3] = 0.0f;
			if (MFColorRGBA[4*index + 0] > 1.0f) MFColorRGBA[4*index + 0] = 1.0f;
			if (MFColorRGBA[4*index + 1] > 1.0f) MFColorRGBA[4*index + 1] = 1.0f;
			if (MFColorRGBA[4*index + 2] > 1.0f) MFColorRGBA[4*index + 2] = 1.0f;
			if (MFColorRGBA[4*index + 3] > 1.0f) MFColorRGBA[4*index + 3] = 1.0f;
		}
		return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFRotation')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method converting degrees to radians.
	 * @param angleDegrees value to convert
	 * @return angle value in radians
	 */
	public static float degreesToRadians (float angleDegrees)
	{
		return (float) (angleDegrees * Math.PI / 180.0);
	}
	/**
	 * Utility method converting degrees to radians.
	 * @param angleDegrees value to convert
	 * @return angle value in radians
	 */
	public static float degreesToRadians (int angleDegrees)
	{
		return (float) (angleDegrees * Math.PI / 180.0);
	}
	/**
	 * Utility method converting degrees to radians.
	 * @param angleDegrees value to convert
	 * @return angle value in radians
	 */
	public static float degreesToRadians (double angleDegrees)
	{
		return (float) (angleDegrees * Math.PI / 180.0);
	}
	/**
	 * Utility method converting radians to degrees.
	 * @param angleRadians value to convert
	 * @return angle value in degrees
	 */
	public static float radiansToDegrees (float angleRadians)
	{
		return (float) (angleRadians * 180.0 / Math.PI);
	}
	/**
	 * Utility method converting radians to degrees.
	 * @param angleRadians value to convert
	 * @return angle value in degrees
	 */
	public static float radiansToDegrees (double angleRadians)
	{
		return (float) (angleRadians * 180.0 / Math.PI);
	}
	/**
	 * Constructor using individual float types as new initial axis-angle value.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (float x, float y, float z, float angleRadians)
	{
		if ((x == 0.0f) && (y == 0.0f) && (z == 0.0f))
		{
			String errorNotice = "*** Illegal SFRotation value (" + x + "," + y + "," + z + "," + angleRadians +
				") since (x,y,z) axis vector must have a direction and cannot be (0,0,0)";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		if (Math.abs(angleRadians) > 2.0 * Math.PI)
			System.out.println ("[warning] SFRotation constructor: questionable |angleRadians| = " + Math.abs(angleRadians) + " > 2pi");
		SFRotation[0] = x;
		SFRotation[1] = y;
		SFRotation[2] = z;
		SFRotation[3] = angleRadians;
	}
	/**
	 * Constructor using individual double types as new initial axis-angle value.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (double x, double y, double z, double angleRadians)
	{
		if ((x == 0.0) && (y == 0.0) && (z == 0.0))
		{
			String errorNotice = "*** Illegal SFRotation value (" + x + "," + y + "," + z + "," + angleRadians +
				") since (x,y,z) axis vector must have a direction and cannot be (0,0,0)";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		if (Math.abs(angleRadians) > 2.0 * Math.PI)
			System.out.println ("[warning] SFRotation constructor: questionable |angleRadians| = " + Math.abs(angleRadians) + " > 2pi");
		SFRotation[0] = (float) x;
		SFRotation[1] = (float) y;
		SFRotation[2] = (float) z;
		SFRotation[3] = (float) angleRadians;
	}
	/**
	 * Constructor using individual integer types as new initial axis, along with float angle value.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int x, int y, int z, float angleRadians)
	{
		if ((x == 0) && (y == 0) && (z == 0))
		{
			String errorNotice = "*** Illegal SFRotation value (" + x + "," + y + "," + z + "," + angleRadians +
				") since (x,y,z) axis vector must have a direction and cannot be (0,0,0)";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		if (Math.abs(angleRadians) > 2.0 * Math.PI)
			System.out.println ("[warning] SFRotation constructor: questionable |angleRadians| = " + Math.abs(angleRadians) + " > 2pi");
		SFRotation[0] = (float) x;
		SFRotation[1] = (float) y;
		SFRotation[2] = (float) z;
		SFRotation[3] =         angleRadians;
	}
	/**
	 * Utility method to normalize this rotation value: unit length for axis-angle vector, angle in range [0-2pi] radians, rotation with zero-length axis is reset to DEFAULT_VALUE.
	 * @return {@link SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalize()
	{
		float length = (float) Math.sqrt(SFRotation[0]*SFRotation[0] + SFRotation[1]*SFRotation[1] + +SFRotation[2]*SFRotation[2]);
		if (length == 0.0f)
		{
			SFRotation = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text disable-output-escaping="yes"><![CDATA[
			System.out.println ("SFRotation.normalize(): zero-length axis encountered, reset entire SFRotation to DEFAULT_VALUE: " + DEFAULT_VALUE);
		}
		else
		{
			SFRotation[0] = SFRotation[0] / length;
			SFRotation[1] = SFRotation[1] / length;
			SFRotation[2] = SFRotation[2] / length;
			while (SFRotation[3] < 0.0f)
				   SFRotation[3] += 2.0f * Math.PI;
			while (SFRotation[3] >= 2.0f * Math.PI)
				   SFRotation[3] -= 2.0f * Math.PI;
		}
		return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="starts-with($fieldName, 'SFVec')"><!-- both float and double types -->
				<xsl:variable name="typePrecision">
					<xsl:choose>
						<xsl:when test="ends-with($fieldName, 'f')">
							<xsl:text>float</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text>double</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
		<xsl:text>
	/**
	 * Utility constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using individual primitive values.</xsl:text>
				<xsl:choose>
					<xsl:when test="starts-with($fieldName, 'SFVec2')">
						<xsl:text><![CDATA[
	 * @param x first component of axis
	 * @param y second component of axis
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> (</xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> x, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> y)
	{
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = x;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = y;
	}
	/**
	 * Utility method to normalize this vector value to unit length, ignore if zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		</xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[1]);

		if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
		{
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] / length;
		}
		return this;
	}
</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName, 'SFVec3')">
						<xsl:text><![CDATA[
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> (</xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> x, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> y, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> z)
	{
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = x;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = y;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] = z;
	}
	/**
	 * Utility method to normalize this vector value to unit length, ignore if zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		</xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[2]);

		if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
		{
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] / length;
		}
		return this;
	}
</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName, 'SFVec4')">
						<xsl:text><![CDATA[
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param w fourth component
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> (</xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> x, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> y, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> z, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> w)
	{
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = x;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = y;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] = z;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[3] = w;
	}
	/**
	 * Utility method to normalize this vector value to unit length, ignore if zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		</xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[3]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[3]);

		if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
		{
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[3] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[3] / length;
		}
		return this;
	}
</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="starts-with($fieldName, 'MFVec')"><!-- both float and double types -->
				<xsl:variable name="typePrecision">
					<xsl:choose>
						<xsl:when test="ends-with($fieldName, 'f')">
							<xsl:text>float</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text>double</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:choose>
					<xsl:when test="starts-with($fieldName, 'MFVec2')">
						<xsl:text>
	/**
	 * Utility method to normalize vector values to unit length, ignore vector values with zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		for (int index = 0; index+</xsl:text><xsl:value-of select="$tupleSize"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ < ]]></xsl:text>
					<xsl:value-of select="$fieldName"/><xsl:text>.length; index = index + </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>)
		{
			</xsl:text><xsl:value-of select="$typePrecision"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[index+1]);

			if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
			{
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] / length;
			}
		}
		return this;
	}
</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName, 'MFVec3')">
						<xsl:text>
	/**
	 * Utility method to normalize vector values to unit length, ignore vector values with zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		for (int index = 0; index+</xsl:text><xsl:value-of select="$tupleSize"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ < ]]></xsl:text>
					<xsl:value-of select="$fieldName"/><xsl:text>.length; index = index + </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>)
		{
			</xsl:text><xsl:value-of select="$typePrecision"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[index+2]);

			if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
			{
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] / length;
			}
		}
		return this;
	}
</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName, 'MFVec4')">
						<xsl:text>
	/**
	 * Utility method to normalize vector values to unit length, ignore vector values with zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		for (int index = 0; index+</xsl:text><xsl:value-of select="$tupleSize"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ < ]]></xsl:text>
					<xsl:value-of select="$fieldName"/><xsl:text>.length; index = index + </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>)
		{
			</xsl:text><xsl:value-of select="$typePrecision"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+3]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[index+3]);

			if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
			{
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+3] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+3] / length;
			}
		}
		return this;
	}
</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:when>
		</xsl:choose>

		<!-- Alternate utility constructors -->

        <!-- utility constructors for singleton object of same type -->
        <xsl:variable name="subTypeObject">
            <xsl:text>S</xsl:text>
            <xsl:value-of select="substring($fieldName,2)"/>
            <xsl:value-of select="$jsaiClassSuffix"/>
        </xsl:variable>
        <xsl:if test="starts-with($fieldName, 'MF') and not($fieldName = 'MFFloat') and not($fieldName = 'MFDouble') and not($fieldName = 'MFInt32') and not($fieldName = 'MFTime') and not($fieldName = 'MFNode')">
			<xsl:text>
	/**
	 * Utility constructor for </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/>
            <xsl:text> to assign a single </xsl:text><xsl:value-of select="$subTypeObject"/>
            <xsl:text> as new initial value.
	 * @param newValue is new value to assign
	 */
	public </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> (</xsl:text>
            <xsl:value-of select="$subTypeObject"/><xsl:text> newValue)
	{
		setValue(newValue);
	}
</xsl:text>
        </xsl:if>
        <xsl:if test="starts-with($fieldName, 'MFMatrix')">
			<xsl:text>
	/**
	 * Utility method for </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/>
            <xsl:text> to assign a single </xsl:text><xsl:value-of select="$subTypeObject"/>
            <xsl:text disable-output-escaping="yes"><![CDATA[ as new initial value.
	 * @param newValue is new value to assign
	 * @return {@link SFColor} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> setValue(</xsl:text>
            <xsl:value-of select="$subTypeObject"/><xsl:text> newValue)
	{
		setValue(newValue.getPrimitiveValue());
        return this;
	}
</xsl:text>
        </xsl:if>
		<xsl:choose>
			<xsl:when test="($fieldName = 'MFFloat')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor for MFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ to assign a single double as new initial array value.
	 * @param newValue is new value to assign
	 */
	public MFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ (double newValue)
	{
		setValue(new SFFloat(newValue));
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'MFDouble')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor for MFDouble]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ to assign a single float as new initial array value.
	 * @param newValue is new value to assign
	 */
	public MFDouble]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ (float newValue)
	{
		setValue(new SFDouble(newValue));
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'SFVec2f')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor for SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ using double values.
	 * @param x first component
	 * @param y second component
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ (double x, double y)
	{
		setValue((float) x, (float) y);
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'SFVec3f')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor for SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ using double values.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ (double x, double y, double z)
	{
		setValue((float) x, (float) y, (float) z);
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'SFVec4f')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor for SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ using double values.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param t fourth component
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ (double x, double y, double z, double t)
	{
		setValue((float) x, (float) y, (float) z, (float) t);
	}
]]></xsl:text>
			</xsl:when>
		</xsl:choose>
		<!-- Alternate type conversion utility methods -->
		<xsl:choose>
			<xsl:when test="(@type='SFColor')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type SFColor tuple size of <i>3</i>.
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param newValue The replacement value to assign.
	 * @return {@link SFColor} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double[] newValue)
	{
		float[] floatArray = new float[newValue.length];
		for (int i = 0; i < newValue.length; i++)
			floatArray[i] = (float)newValue[i]; // cast each double to float
		setValue(floatArray); // perform checks
        return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColorRGBA')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type SFColorRGBA tuple size of <i>4</i>.
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param newValue The replacement value to assign.
	 * @return {@link SFColorRGBA} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double[] newValue)
	{
		float[] floatArray = new float[newValue.length];
		for (int i = 0; i < newValue.length; i++)
			floatArray[i] = (float)newValue[i]; // cast each double to float
		setValue(floatArray); // perform checks
        return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFRotation')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 * @return {@link SFRotation} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float x, float y, float z, float angleRadians)
	{
		float[] floatArray = new float[4];
		floatArray[0] = x;
		floatArray[1] = y;
		floatArray[2] = z;
		floatArray[3] = angleRadians;

		setValue(floatArray); // perform checks
        return this;
	}
	/**
	 * Assign a new value to this field.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 * @return {@link SFRotation} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y, double z, double angleRadians)
	{
		setValue((float) x, (float) y, (float) z, (float) angleRadians); // perform checks
        return this;
	}
	/**
	 * Assign a new value to this field.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type SFRotation tuple size of <i>4</i>.
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param newValue The replacement value to assign.
	 * @return {@link SFRotation} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double[] newValue)
	{
		float            x = (float) newValue[0];
		float            y = (float) newValue[1];
		float            z = (float) newValue[2];
		float angleRadians = (float) newValue[3];

		setValue(x, y, z, angleRadians); // perform checks
        return this;
	}
]]></xsl:text>
			</xsl:when>
		</xsl:choose>
		<!-- Alternate primitive constructors-->
		<xsl:choose>
			<xsl:when test="(@type = 'MFFloat') or (@type = 'MFVec2f') or (@type = 'MFVec3f') or (@type = 'MFVec4f') or
							                       (@type = 'SFVec2f') or (@type = 'SFVec3f') or (@type = 'SFVec4f') or
							(@type = 'SFColor') or (@type = 'SFColorRGBA') or (@type = 'MFColor') or (@type = 'MFColorRGBA') or
							(@type = 'SFRotation') or (@type = 'MFRotation')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor for ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ using an alternatively typed Java double[] array as new initial value.
	 * @param newValue is new value to assign
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
			<xsl:text>(double[] newValue)
	{
		setValue(newValue); // type conversion, doubles to floats
	}
</xsl:text>
			</xsl:when>
			<xsl:when test="(@type = 'MFDouble') or (@type = 'MFVec2d') or (@type = 'MFVec3d') or (@type = 'MFVec4d') or
													(@type = 'SFVec2d') or (@type = 'SFVec3d') or (@type = 'SFVec4d')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor for MFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ using an alternatively typed float[] array as new initial value.
	 * @param newValue is new value to assign
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
			<xsl:text>(float[] newValue)
	{
		setValue(newValue); // type conversion, floats to doubles
	}
</xsl:text>
			</xsl:when>
		</xsl:choose>

		<!-- Source code: parse method -->
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Static utility method to provide String representation of a correctly typed input value.
	 * @param value The value to convert to a String
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>]]></xsl:text>
		<xsl:choose>
			<xsl:when test="(@type='MFFloat') or (@type='SFRotation') or (@type='MFRotation') or
							contains(@type, 'Color') or
							((contains(@type,'Vec') or contains(@type,'Matrix')) and ends-with(@type,'f'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see SFFloat#stripTrailingZeroes(float)
	 * @return String version of the provided value, with trailing zeroes and decimal points omitted.]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFDouble') or (@type='MFTime') or
							((contains(@type,'Vec') or contains(@type,'Matrix')) and ends-with(@type,'d'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see SFDouble#stripTrailingZeroes(double)
	 * @return String version of the provided value, with trailing zeroes and decimal points omitted.]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFString') or (@type='MFString')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see SFString#toStringX3D
	 * @see MFString#toStringX3D
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFStringAndMFString">X3D Abstract Specification: 5.3.14 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/EncodingOfFields.html#SFString">X3D XML Encoding: 5.15 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#Text">X3D Tooltips: Text</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 * @return XML/X3D-escaped String version of the provided value]]></xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return String version of the provided value]]></xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 */
	public static String toString (]]></xsl:text>
	<xsl:value-of select="$javaType"/>
	<xsl:text> value)
	{</xsl:text>
	<xsl:choose>
		<xsl:when test="not(contains($javaType,'[]'))">
			<xsl:text>
		return String.valueOf(value);</xsl:text>
		</xsl:when>
		<xsl:when test="(@type='MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		String result = new String();
		for (String eachValue : value)
		{
			// https://www.regexplanet.com/advanced/java/index.html
			// https://www.regular-expressions.info/java.html see "backslash-mess"
			// https://docs.oracle.com/javase/tutorial/java/data/characters.html
			// append another quoted SFString value to MFString output
			result += " \"" + eachValue.replaceAll("&","&amp;")      // escape ampersands           in XML attributes
									   .replaceAll("<","&lt;")       // escape    less-than < signs in XML attributes
									   .replaceAll(">","&gt;")       // escape greater-than > signs in XML attributes
									   .replaceAll("'","&apos;")     // escape apostrophes since XML attributes in this output are delimited by apostrophes
									   .replaceAll("\\\\","\\\\")    // escape backslash \ as \\    in XML attributes
									   .replaceAll("\"",  "\\\\\"")  // escape     quote " as \"    in XML attributes
				    + "\"";
		}
		return (result.trim());]]></xsl:text>

		</xsl:when>
		<xsl:when test="(@type='MFFloat') or contains(@type,'Rotation') or contains(@type, 'Color') or
						 ends-with(@type,'2f') or ends-with(@type,'3f') or ends-with(@type,'4f')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder result = new StringBuilder();
		for (int i=0; i < value.length; i++)
		{
			if  (ConfigurationProperties.isStripTrailingZeroes())
				 result.append(org.web3d.x3d.jsail.fields.SFFloat.stripTrailingZeroes(value[i])).append(" ");
			else result.append(value[i]).append(" ");
		}
		return result.toString().trim();]]></xsl:text>
		</xsl:when>
		<xsl:when test="(@type='MFDouble') or (@type='MFTime') or
						 ends-with(@type,'2d') or ends-with(@type,'3d') or ends-with(@type,'4d')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder result = new StringBuilder();
		for (int i=0; i < value.length; i++)
		{
			if  (ConfigurationProperties.isStripTrailingZeroes())
				 result.append(org.web3d.x3d.jsail.fields.SFDouble.stripTrailingZeroes(value[i])).append(" ");
			else result.append(value[i]).append(" ");
		}
		return result.toString().trim();]]></xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder result = new StringBuilder();
		for (int i=0; i < value.length; i++)
		{
			result.append(value[i]).append(" ");
		}
		return result.toString().trim();]]></xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
	}
</xsl:text>

	<xsl:if test="(@type='SFString')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Static utility method to provide String representation of input String, properly escaped using XML-based X3D syntax.
	 * @param value The value to convert to an escaped String
	 * @see MFString#toStringX3D
	 * @see SFString#toStringClassicVRML
	 * @see MFString#toStringClassicVRML
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFStringAndMFString">X3D Abstract Specification: 5.3.14 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/EncodingOfFields.html#SFString">X3D XML Encoding: 5.15 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#Text">X3D Tooltips: Text</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString">X3D Tooltips: SFString</a>
	 * @return XML/X3D-escaped String version of the provided value
	 */
	public static String toStringX3D (String value)
	{
            return (new SFString(value)).toString()
                        .replaceAll("&","&amp;")	// escape ampersands
                        .replaceAll("<","&lt;")		// escape    less-than < signs
                        .replaceAll(">","&gt;")		// escape greater-than > signs in XML attributes
                        .replaceAll("'","&apos;")	// escape apostrophes since XML attributes in this output are delimited by apostrophes
                        .replaceAll("\"","\\\""); // escape embedded quotation marks
	}

	/**
	 * Static utility method to provide SFString representation of input String, properly escaped using ClassicVRML (.x3dv) or VRML97 (.wrl) syntax.
	 * @param value The value to convert to an escaped String
	 * @see SFString#toStringX3D
	 * @see MFString#toStringX3D
	 * @see MFString#toStringClassicVRML
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFStringAndMFString">X3D Abstract Specification: 5.3.14 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/EncodingOfFields.html#SFString">X3D ClassicVRML Encoding: 5.15 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#Text">X3D Tooltips: Text</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString">X3D Tooltips: SFString</a>
	 * @return ClassicVRML/VRML97-escaped String version of the provided value
	 */
	public static String toStringClassicVRML (String value)
	{
            // escape contained quotation marks " as \" since SFString attributes in ClassicVRML output are delimited by quotation marks "
            return (new SFString(value)).toString().replaceAll("\"","\\\\\\\"");
	}

	/**
	 * Provide String representation of this SFString object, properly escaped for XML-based X3D syntax and conforming to X3D Canonical Form.
	 * @see SFString#toStringX3D(String)
	 * @see MFString#toStringX3D
	 * @see X3D#FILE_EXTENSION_X3D
	 * @see X3D#FILE_EXTENSION_XML
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString">X3D Tooltips: type SFString</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
	 * @return XML/X3D-escaped version of this SFString
	 */
	public String toStringX3D()
	{
            return toStringX3D(SFString); // apply escaping to member value of this object
	}
	/**
	 * Provide String representation of this SFString object, properly escaped using ClassicVRML (.x3dv) or VRML97 (.wrl) syntax.
	 * @see SFString#toStringClassicVRML(String)
	 * @see MFString#toStringClassicVRML
	 * @see X3D#FILE_EXTENSION_CLASSICVRML
	 * @see X3D#FILE_EXTENSION_VRML97
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFStringAndMFString">X3D Abstract Specification: 5.3.14 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/EncodingOfFields.html#SFString">X3D ClassicVRML Encoding: 5.15 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#Text">X3D Tooltips: Text</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString">X3D Tooltips: SFString</a>
	 * @return ClassicVRML/VRML97-escaped version of this SFString
	 */
	public String toStringClassicVRML()
	{
            return toStringClassicVRML(SFString); // apply escaping to member value of this object
	}
]]></xsl:text>
	</xsl:if>

	<!-- TODO handle quote marks at the individual string level, before quoted strings produced -->
	<xsl:if test="(@type='MFString')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Provide String representation of this MFString object, properly escaped for XML-based X3D syntax and conforming to X3D Canonical Form.
	 * @see SFString#toStringX3D
	 * @see SFString#toStringX3D(String)
	 * @see X3D#FILE_EXTENSION_X3D
	 * @see X3D#FILE_EXTENSION_XML
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFString">X3D Tooltips: type MFString</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
	 * @return XML/X3D-escaped String version of this object
	 */
	public String toStringX3D()
	{
            // avoid StringBuilder since it clobbers \"
            String result = new String();
            for (int i = 0; i < MFString.length; i++)
            {
                // MFString[0] // trace
                if (!MFString[i].startsWith("\""))
                        result += "\"";
                // avoid SFString.toStringX3D(MFString[i]) due to additional contrary handling of \" and &
                // https://www.regexplanet.com/advanced/java/index.html
                // https://www.regular-expressions.info/java.html see "backslash-mess"
                // https://docs.oracle.com/javase/tutorial/java/data/characters.html
                String escapedValue = MFString[i]
                    .replaceAll("&","&amp;")      // escape ampersands           in XML attributes
                    .replaceAll("<","&lt;")       // escape    less-than < signs in XML attributes
                    .replaceAll(">","&gt;")       // escape greater-than > signs in XML attributes
                    .replaceAll("'","&apos;")     // escape apostrophes since XML attributes in this output are delimited by apostrophes
                    .replaceAll("\\\\","\\\\")    // escape backslash \ as \\    in XML attributes
                    .replaceAll("\"",  "\\\\\""); // escape     quote " as \"    in XML attributes

                result += escapedValue;			// apply escaping to each SFString value
                if (!MFString[i].startsWith("\""))
                    result += "\"";
                if (i < MFString.length - 1)
                    result += " ";
            }
            return result;
	}
	/**
	 * Provide String representation of this MFString object, properly escaped using ClassicVRML (.x3dv) or VRML97 (.wrl) syntax.
	 * @see SFString#toStringClassicVRML
	 * @see SFString#toStringClassicVRML(String)
	 * @see X3D#FILE_EXTENSION_CLASSICVRML
	 * @see X3D#FILE_EXTENSION_VRML97
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldsDef.html#SFStringAndMFString">X3D Abstract Specification: 5.3.14 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/EncodingOfFields.html#SFString">X3D ClassicVRML Encoding: 5.15 SFString and MFString</a>
	 * @see <a href="https://www.web3d.org/x3d/content/X3dTooltips.html#Text">X3D Tooltips: Text</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString">X3D Tooltips: SFString</a>
	 * @return ClassicVRML/VRML97-escaped String version of this object
	 */
	public String toStringClassicVRML()
	{
            // avoid StringBuilder since it clobbers \"
            String result = new String();
            boolean isUrl = false;
            if ((MFString.length > 0) && (MFString[0].trim().startsWith("https://") ||
                                          MFString[0].trim().startsWith("http://" )))
                isUrl = true;
            // initial address might be relative, so check twice
            if ((MFString.length > 1) && (MFString[1].trim().startsWith("https://") ||
                                          MFString[1].trim().startsWith("http://" )))
                isUrl = true;

            for (int i = 0; i < MFString.length; i++)
            {
                // MFString[0] // trace
                if (!MFString[i].startsWith("\""))
                        result += "\"";
                // avoid SFString.toStringClassicVRML(MFString[i]) due to additional contrary handling of \" and &
                // https://www.regexplanet.com/advanced/java/index.html
                // https://www.regular-expressions.info/java.html see "backslash-mess"
                // https://docs.oracle.com/javase/tutorial/java/data/characters.html

                // escape contained quotation marks " as \" since SFString attributes in ClassicVRML output are delimited by quotation marks "
                String escapedValue = MFString[i]
                        .replaceAll("\"","\\\"");

                result += escapedValue;			// apply escaping to each SFString value
                if (!MFString[i].startsWith("\""))
                        result += "\"";
                if (i < MFString.length - 1)
                        result += " ";
                if (isUrl)
                {
                    result += "\n"; // make VRML-encoded url values more readable
                }
            }
            return result;
	}
]]></xsl:text>
	</xsl:if>

	<xsl:choose>
		<xsl:when test="contains($fieldName,'FImage') or contains($fieldName,'FMatrix')">
			<!-- specialty methods defined later instead -->
		</xsl:when>
		<xsl:when test="contains($javaType,'[]')"> <!-- java array; may be SF type -->
<xsl:text><![CDATA[
	/**
	 * Get the current value of this ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text><![CDATA[ by copying it into the valueDestination array, leaving the current object unchanged.
	 * @param valueDestination The array to be filled in with current field values.
	 */
	/* @Override */
	public void getValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ valueDestination)
	{
		valueDestination = ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[;
	}
]]></xsl:text>
		</xsl:when>
		<xsl:otherwise>
<xsl:text><![CDATA[
	/**
	 * Get the current value.
	 * @return current value
	 */
	@Override
	public ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ getValue()
	{
		return ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[;
	}
]]></xsl:text>
		</xsl:otherwise>
	</xsl:choose>

<!-- consistent utility method -->
<xsl:text><![CDATA[
	/**
	 * Provides current value of the field as a Java primitive type.
	 * @return current value
	 */
	public ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ getPrimitiveValue()
	{
		return ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[;
	}]]></xsl:text>

<!-- consistent utility method -->
<xsl:text><![CDATA[
	/**
	 * Provides current value as a String.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[">X3D Tooltips: type ]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[</a>]]></xsl:text>
		<xsl:choose>
			<xsl:when test="(@type='MFFloat') or (@type='SFRotation') or (@type='MFRotation') or
							contains(@type, 'Color') or
							((contains(@type,'Vec') or contains(@type,'Matrix')) and ends-with(@type,'f'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see org.web3d.x3d.jsail.fields.SFFloat#stripTrailingZeroes(float)
	 * @return String version of the provided value, with trailing zeroes and decimal points omitted.]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFDouble') or (@type='MFTime') or
							((contains(@type,'Vec') or contains(@type,'Matrix')) and ends-with(@type,'d'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see org.web3d.x3d.jsail.fields.SFDouble#stripTrailingZeroes(double)
	 * @return String version of the provided value, with trailing zeroes and decimal points omitted.]]></xsl:text>
			</xsl:when>
			<xsl:when test="contains(@type, 'Image')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see #toStringHexadecimal
	 * @see #toStringDecimal
	 * @see ConfigurationProperties#SFImagePixelOutputHexadecimal_DEFAULT
	 * @see ConfigurationProperties#isSFImagePixelOutputHexadecimal
	 * @see ConfigurationProperties#setSFImagePixelOutputHexadecimal(boolean)
	 * @return String version of the provided value, with pixels in hexadecimal or decimal format.]]></xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return String version of the provided value]]></xsl:text>
			</xsl:otherwise>
		</xsl:choose>
<xsl:text><![CDATA[
	 */
	@Override
	public String toString()
	{
		]]></xsl:text>
	<xsl:choose>
		<xsl:when test="(@type = 'SFString')">
			<xsl:text>return </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>;</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFDouble') or (@type = 'SFFloat') or (@type = 'SFTime')">
			<xsl:text>return String.valueOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>);</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[StringBuilder result = new StringBuilder();
		for (int i = 0; i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length; i++)
		{
			if (!</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes">[i].startsWith("\""))
				result.append("\"");
			result.append(String.valueOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes">[i]));
			if (!</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[[i].startsWith("\""))
				result.append("\"");
			if (i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - 1)
				result.append(" ");
		}
		return result.toString();</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'SFImage') or (@type = 'MFImage')">
			<xsl:text>
		if  (ConfigurationProperties.isSFImagePixelOutputHexadecimal())
			 return toStringHexadecimal();
		else return toStringDecimal();
</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type = 'MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[StringBuilder result = new StringBuilder();
		for (int i = 0; i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length; i++)
		{
			result.append(String.valueOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[[i]));
			if (i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - 1)
				result.append(" ");
		}
		return result.toString();</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFFloat') or contains(@type,'Color') or contains(@type,'Rotation') or
                         ends-with(@type,'2f') or ends-with(@type,'3f') or ends-with(@type,'4f')">
			<xsl:text disable-output-escaping="yes"><![CDATA[StringBuilder result = new StringBuilder();
		for (int i = 0; i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length; i++)
		{
			if  (ConfigurationProperties.isStripTrailingZeroes())
				 result.append(org.web3d.x3d.jsail.fields.SFFloat.stripTrailingZeroes(</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>[i]));
			else result.append(</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[[i]);
			if (i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - 1)
				result.append(" ");
		}
		return result.toString();</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFDouble') or (@type = 'MFTime') or
                         ends-with(@type,'2d') or ends-with(@type,'3d') or ends-with(@type,'4d')">
			<xsl:text disable-output-escaping="yes"><![CDATA[StringBuilder result = new StringBuilder();
		for (int i = 0; i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length; i++)
		{
			if  (ConfigurationProperties.isStripTrailingZeroes())
				 result.append(org.web3d.x3d.jsail.fields.SFDouble.stripTrailingZeroes(</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>[i]));
			else result.append(</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[[i]);
			if (i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - 1)
				result.append(" ");
		}
		return result.toString();</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>return "TODO"; // unimplemented method toString() for type </xsl:text>
            <xsl:value-of select="@type"/>
		</xsl:otherwise>
	</xsl:choose>

	<xsl:text><![CDATA[
	}]]></xsl:text>

   <xsl:if test="(@type = 'SFInt32')">
<xsl:text><![CDATA[
	/**
	 * Provide value in hexadecimal format.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[">X3D Tooltips: type ]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[</a>
	 * @return String version of the provided value
	 */
	public String toStringHexadecimal()
	{
		// https://stackoverflow.com/questions/11194513/convert-hex-string-to-int
		return "0x" + Integer.toHexString(SFInt32);
	}
]]></xsl:text>
   </xsl:if>
   <xsl:if test="contains(@type, 'FImage')">
<xsl:text><![CDATA[
	/**
	 * Provide pixel values in decimal format.
	 * @see #toStringHexadecimal
	 * @see ConfigurationProperties#SFImagePixelOutputHexadecimal_DEFAULT
	 * @see ConfigurationProperties#isSFImagePixelOutputHexadecimal
	 * @see ConfigurationProperties#setSFImagePixelOutputHexadecimal(boolean)
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[">X3D Tooltips: type ]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[</a>
	 * @return String version of the provided value in decimal format
	 */
	public String toStringDecimal()
	{
		StringBuilder resultBuilder = new StringBuilder();
		for (int i = 0; i < ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>.length; i++)
		{
			resultBuilder.append(</xsl:text>
		<xsl:value-of select="$fieldName"/>
		<xsl:text disable-output-escaping="yes"><![CDATA[[i]);
			if  (i < ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>.length - 1)
				resultBuilder.append(" ");
		}
		return resultBuilder.toString();
	}
</xsl:text>
   </xsl:if>
   <xsl:if test="(@type = 'MFInt32') or contains(@type, 'FImage')">
<xsl:text><![CDATA[
	/**
	 * Provide pixel values in hexadecimal format.
]]></xsl:text>
   </xsl:if>
   <xsl:if test="contains(@type, 'FImage')">
<xsl:text><![CDATA[
	 * @see #toStringDecimal
	 * @see ConfigurationProperties#SFImagePixelOutputHexadecimal_DEFAULT
	 * @see ConfigurationProperties#isSFImagePixelOutputHexadecimal
	 * @see ConfigurationProperties#setSFImagePixelOutputHexadecimal(boolean)
]]></xsl:text>
   </xsl:if>
   <xsl:if test="(@type = 'MFInt32') or contains(@type, 'FImage')">
<xsl:text><![CDATA[
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[">X3D Tooltips: type ]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[</a>
	 * @return String version of the provided value in hexadecimal format
	 */
	public String toStringHexadecimal()
	{
		StringBuilder resultBuilder = new StringBuilder();
		// https://stackoverflow.com/questions/11194513/convert-hex-string-to-int
		for (int i = 0; i < ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>.length; i++)
		{
			</xsl:text>
			<xsl:if test="contains(@type, 'FImage')">
				<xsl:text disable-output-escaping="yes"><![CDATA[if (i < 3)
				 resultBuilder.append(]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[i]); // height, width, components in integer form
			else </xsl:text>
			</xsl:if>
			<xsl:text>resultBuilder.append("0x").append(Integer.toHexString(</xsl:text>
            <xsl:value-of select="$fieldName"/>
            <xsl:text disable-output-escaping="yes"><![CDATA[[i]));
			if  (i < ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>.length - 1)
				resultBuilder.append(" ");
		}
		return resultBuilder.toString();
	}
</xsl:text>
   </xsl:if>

   <xsl:if test="not(starts-with(@type,'MF')) and not(@type = 'SFImage') and not(contains(@type,'Matrix'))">
<xsl:text><![CDATA[
	/**
	 * Assign a new value to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param newValue The replacement value to assign.
	 */
	/* @Override */
	public void setValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
]]></xsl:text>
		<!-- initial value checks -->
		<xsl:choose>
			<xsl:when test="starts-with(@type,'MF') and ends-with($javaType, '[]') and not($tupleSize = '1')">
				<xsl:value-of select="$newValueNullReturnSelf"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length % </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ != 0) // ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[-tuple check
		{
			String errorNotice = "*** Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must be multiple of ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="starts-with(@type,'SF') and ends-with($javaType, '[]') and not($tupleSize = '1')">
				<xsl:value-of select="$newValueNullReturnSelf"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length != </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[)
		{
			String errorNotice = "*** Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must equal ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
		<xsl:when test="ends-with($javaType, '[]')"><!-- ($tupleSize == 1) -->
			<xsl:value-of select="$newValueNullReturnSelf"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[
		if (newValue == null)
			newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text disable-output-escaping="yes"><![CDATA[		]]></xsl:text><!-- indent -->
			</xsl:otherwise>
		</xsl:choose>
		<xsl:choose>
			<xsl:when test="(@type = 'SFRotation')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		float            x = newValue[0];
		float            y = newValue[1];
		float            z = newValue[2];
		float angleRadians = newValue[3];
		if ((x == 0.0f) && (y == 0.0f) && (z == 0.0f))
		{
			String errorNotice = "*** Illegal SFRotation value (" + x + "," + y + "," + z + "," + angleRadians +
				") since (x,y,z) axis vector must have a direction and cannot be (0,0,0)";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		if (Math.abs(angleRadians) > 2.0 * Math.PI)
			System.out.println ("[warning] SFRotation constructor: questionable |angleRadians| = " + Math.abs(angleRadians) + " > 2pi");
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColor')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// initial value checks
		float   red = newValue[0];
		float green = newValue[1];
		float  blue = newValue[2];
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "*** Illegal SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColorRGBA')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// initial value checks
		float   red = newValue[0];
		float green = newValue[1];
		float  blue = newValue[2];
		float alpha = newValue[3];
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "*** Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
				<xsl:when test="(@type='MFTime')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
		for (int i = 0; i < newValue.length; i++)
		{
			if ((newValue[i] < 0.0) && (newValue[i] != SFTime.DEFAULT_VALUE)) // initial value check
			{
				newValue[i] = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
			}
		}
		]]></xsl:text>
			</xsl:when>
		</xsl:choose>
	<xsl:if test="not($isSingletonType = 'true')">
		<xsl:text>if (newValue.length != </xsl:text>
		<xsl:value-of select="$tupleSize"/>
		<xsl:text><![CDATA[)
		{
			String errorNotice = "*** newValue.length=" + newValue.length + " is not equal to ]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ tuple size=" + ]]></xsl:text>
		<xsl:value-of select="$tupleSize"/><xsl:text disable-output-escaping="yes"><![CDATA[;
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
		]]></xsl:text>
	</xsl:if>
	<xsl:value-of select="$fieldName"/>
	<xsl:text><![CDATA[ = newValue;
	}
]]></xsl:text>

        <xsl:if test="not($tupleSize = '1')">
        <xsl:text><![CDATA[
	/**
	 * Assign a new array value to this field, pipelined.
	 * This is an alternate utility method since primary method returns void and cannot be overridden.]]></xsl:text>
        <xsl:if test="not($tupleSize = '1')">
            <xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
        </xsl:if>
        <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param newValue The replacement value to assign.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValueArray (]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
        setValue(newValue); // perform checks
        return this;
    }
]]></xsl:text>
        </xsl:if>
    </xsl:if>
                    <xsl:choose>
                        <xsl:when test="(@type = 'SFVec2f') or (@type = 'SFVec3f') or (@type = 'SFVec4f')">
		<!-- Source code: constructor method using typed primitive value, single precision -->
		<xsl:text>
	/**
	 * Constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using a corresponding Java primitive double[] array </xsl:text>
	<xsl:text disable-output-escaping="yes"><![CDATA[as new initial value.
	 * @param newValue is new value to assign]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValue (double[] newValue)
	{
        // https://stackoverflow.com/questions/7513434/convert-a-double-array-to-a-float-array
		float[] newFloatArray = new float[newValue.length];
		for (int i = 0; i < newValue.length; i++)
		{
			newFloatArray[i] = (float) newValue[i];
		}
		setValue(newFloatArray); // perform checks
		return this;
	}
]]></xsl:text>
                        </xsl:when>
                        <xsl:when test="(@type = 'SFVec2d') or (@type = 'SFVec3d') or (@type = 'SFVec4d')">
		<!-- Source code: constructor method using typed primitive value, single precision -->
		<xsl:text>
	/**
	 * Constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using a corresponding Java primitive float[] array </xsl:text>
	<xsl:text disable-output-escaping="yes"><![CDATA[as new initial value.
	 * @param newValue is new value to assign]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setValue (float[] newValue)
	{
        // https://stackoverflow.com/questions/7513434/convert-a-double-array-to-a-float-array
		double[] newDoubleArray = new double[newValue.length];
		for (int i = 0; i < newValue.length; i++)
		{
			newDoubleArray[i] = newValue[i];
		}
		setValue(newDoubleArray); // perform checks
		return this;
	}
]]></xsl:text>
                        </xsl:when>
                    </xsl:choose>
					<xsl:if test="(starts-with(@type,'MF') and not(@type = 'MFImage')) and not(contains(@type, 'FMatrix'))">
						<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* <p>
* Get an individual value from the existing field array.
* </p><p>
* If the index is outside the bounds of the current array of data values, an ArrayIndexOutOfBoundsException is thrown.
* </p>
* @param index is position of selected value in current array]]></xsl:text>
<xsl:choose>
	<xsl:when test="($isSingletonType = 'true')">
		<xsl:text>
* @return The selected value</xsl:text>
	</xsl:when>
	<xsl:otherwise>
		<xsl:text>
* @param destinationValue where to place result for selected value</xsl:text>
	</xsl:otherwise>
</xsl:choose>
<xsl:text disable-output-escaping="yes"><![CDATA[
* @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
*/
/* @Override */
public ]]></xsl:text>
    <xsl:variable name="saiPackagePath">
        <xsl:call-template name="saiPackage">
            <xsl:with-param name="nodeType" select="$javaPrimitiveType"/>
        </xsl:call-template>
    </xsl:variable>
	<xsl:choose>
		<xsl:when test="($isSingletonType = 'true')">
            <xsl:choose>
                <xsl:when test="(string-length($saiPackagePath) > 0)">
                    <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 15a */</xsl:text></xsl:if> -->
                    <xsl:value-of select="$saiPackagePath"/>
                    <xsl:text>.</xsl:text>
                    <xsl:value-of select="$javaPrimitiveType"/>
                </xsl:when>
                <xsl:otherwise>
                    <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 15b, saiPackage not found */</xsl:text></xsl:if> -->
                    <xsl:value-of select="$javaPrimitiveType"/>
                </xsl:otherwise>
            </xsl:choose>
			<xsl:text> get1Value(int index)</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>void get1Value(int index, </xsl:text>
            <xsl:choose>
                <xsl:when test="(string-length($saiPackagePath) > 0)">
                    <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 16a */</xsl:text></xsl:if> -->
                    <xsl:value-of select="$saiPackagePath"/>
                    <xsl:text>.</xsl:text>
                    <xsl:value-of select="$javaPrimitiveType"/>
                </xsl:when>
                <xsl:otherwise>
                    <!-- <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 16b, saiPackage not found */</xsl:text></xsl:if> -->
                    <xsl:value-of select="$javaPrimitiveType"/>
                </xsl:otherwise>
            </xsl:choose>
			<xsl:text> destinationValue)</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text disable-output-escaping="yes"><![CDATA[
{
	if (index < 0)
	{
		String errorNotice = "*** Index value is negative, thus cannot get1Value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ == 0)
	{
		String errorNotice = "*** Value array is empty, thus cannot get1Value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (index >= ]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$dimensionSuffix"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="$tupleSize"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[) // tupleSize factor
	{
		String errorNotice = "*** Provided array index=" + index + " must be less than ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ array length=" + ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="$tupleSize"/>
	<xsl:text><![CDATA[;
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	]]></xsl:text>
	<xsl:choose>
		<xsl:when test="($isSingletonType = 'true')">
			<xsl:text>return </xsl:text>
			<xsl:choose>
				<xsl:when test="not(contains($javaPrimitiveType,'['))">
					<xsl:value-of select="$fieldName"/>
					<xsl:text>[index];</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$fieldName"/>
					<xsl:text>;</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>destinationValue = Arrays.copyOfRange(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, index * </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text>, (index * </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text>) + </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text> - 1); // tupleSize factor </xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
}
</xsl:text>
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign an array subset to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
* @param newValue The replacement value array to (potentially) slice and then assign.
*/
/* @Override */
public void setValue(int size, ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ newValue)
{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:value-of select="$newValueSizeCheck"/>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	for (int i = 0; i < newValue.length; i++)
	{
		if ((newValue[i] < 0.0) && (newValue[i] != SFTime.DEFAULT_VALUE)) // initial value check
		{
			newValue[i] = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
		}
	}]]></xsl:text>
	</xsl:if>
	<xsl:text><![CDATA[
	]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ = Arrays.copyOf(newValue, size); // array size slicing
}
]]></xsl:text>

	<xsl:if test="not(contains($javaType,'['))">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a new array value to this field.
* @param newValue is replacement value array to assign
*/
public void setValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[[] newValue)
{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:value-of select="$fieldName"/>
	<xsl:text><![CDATA[ = newValue; // TODO verify

}
]]></xsl:text>
	</xsl:if>
	<xsl:if test="(@type = 'MFRotation') or contains(@type,'FVec')">
		<!-- also add methods for square arrays -->
<xsl:text disable-output-escaping="yes"><![CDATA[
  /**
   * Get the current value of this ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text><![CDATA[ by copying it into the valueDestination array, leaving the current object unchanged.
   */
  /* @Override */
  public void getValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[[] valueDestination)
  {
	// TODO square array adjustment //// valueDestination = ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[;
  }

/**
* Assign an array subset to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
* @param newValue The replacement value array to (potentially) slice and then assign.
*/
/* @Override */
public void setValue(int size, ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[[] newValue)
{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:value-of select="$newValueSizeCheck"/>
	<xsl:text><![CDATA[
	// TODO array size slicing, handle double subscripts
}
]]></xsl:text>
	</xsl:if>

    <xsl:if test="not(starts-with(@type,'MFMatrix'))">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a new ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ value to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
* <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param newValue is replacement value array to assign
*/
public void setValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ newValue)
{
	if (newValue == null)
		newValue = new ]]></xsl:text>
		<xsl:value-of select="substring-before($javaType,'[]')"/>
		<xsl:text>[0];
	</xsl:text>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	for (int i = 0; i < newValue.length; i++)
	{
		if ((newValue[i] < 0.0) && (newValue[i] != SFTime.DEFAULT_VALUE)) // initial value check
		{
			newValue[i] = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
		}
	}
	]]></xsl:text>
	</xsl:if>
		<xsl:value-of select="$fieldName"/>
		<xsl:text> = new </xsl:text>
		<xsl:choose>
			<xsl:when test="contains($javaPrimitiveType,'[')">
				<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$javaPrimitiveType"/>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>[newValue.length]; // reset array size
	</xsl:text>

	<xsl:choose>
		<xsl:when test="(@type = 'MFString')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
			for (int i=0; i < newValue.length; i++)
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text>[i] = cleanupUnescapedEnclosingQuotes(newValue[i]); // fill array
			}</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = newValue;</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
}
</xsl:text>
	</xsl:if>
	<!-- additional type-conversion utility methods -->
	<xsl:choose>
		<xsl:when test="(@type = 'MFFloat') or (@type = 'MFVec2f') or (@type = 'MFVec3f') or (@type = 'MFVec4f') or
						(@type = 'SFColor') or (@type = 'SFColorRGBA') or (@type = 'MFColor') or (@type = 'MFColorRGBA') or
						(@type = 'SFRotation') or (@type = 'MFRotation')">
            <!-- or
						(@type = 'MFMatrix3f') or (@type = 'MFMatrix4f') or (@type = 'MFMatrix3d') or (@type = 'MFMatrix4d') -->
			<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a double-precision array value to this single-precision field.
* <br ><br >
* <i>Warning:</i> this method casts type of input values from higher precision to lower precision.
* <br ><br >]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param newValue is replacement value array to assign
* @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
*/
public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> setValue(double[] newValue)
{
	if (newValue == null)
		newValue = new double[0];
	</xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ = new float[newValue.length]; // reset array size
	for (int i = 0; i < newValue.length; i++)
		]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[[i] = (float) newValue[i]; // cast types for new array
	return this;
}]]></xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFDouble') or (@type = 'MFVec2d') or (@type = 'MFVec3d') or (@type = 'MFVec4d') or
						(@type = 'MFMatrix3d') or (@type = 'MFMatrix4d')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a single-precision floating-point array value to this double-precision field.
* <br ><br >
* <i>Warning:</i> this method casts type of input values from lower precision to higher precision.
* <br ><br >]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param newValue is replacement value array to assign
* @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
*/
public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> setValue(float[] newValue)
{
	if (newValue == null)
		newValue = new float[0];
	</xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ = new double[newValue.length]; // reset array size
	for (int i = 0; i < newValue.length; i++)
		]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[[i] = (double) newValue[i]; // cast types for new array
	return this;
}]]></xsl:text>
		</xsl:when>
	</xsl:choose>

	<xsl:if test="starts-with(@type, 'MF')">

		<xsl:if test="(@type = 'MFBool') or (@type = 'MFInt32') or (@type = 'MFDouble') or (@type = 'MFFloat') or (@type = 'MFTime')">
            <xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a single ]]></xsl:text><xsl:value-of select="substring-before($javaType,'[]')"/><xsl:text><![CDATA[ value as new array (of length 1).
* @param newValue The replacement value to assign.
*/
public void setValue(]]></xsl:text><xsl:value-of select="substring-before($javaType,'[]')"/><xsl:text><![CDATA[ newValue)
{
	]]></xsl:text>

	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	if ((newValue < 0.0) && (newValue != SFTime.DEFAULT_VALUE)) // initial value check
	{
		newValue = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
	}
	]]></xsl:text>
	</xsl:if>
		<xsl:value-of select="$fieldName"/>
		<xsl:text disable-output-escaping="yes"><![CDATA[ = new ]]></xsl:text>
		<xsl:value-of select="substring-before($javaType,'[]')"/>
		<xsl:text>[1]; // create array
	</xsl:text>
		<xsl:value-of select="$fieldName"/>
		<xsl:text>[0] = newValue;
}
</xsl:text>
	</xsl:if>

<xsl:text>
/**
* Assign a single-field S</xsl:text>
	<xsl:value-of select="substring(@type, 2)"/>
	<xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ as new array value.
* @param newValue The replacement value to assign.
* @return {@link ]]></xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
*/
public ]]></xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text> setValue(S</xsl:text><xsl:value-of select="substring(@type, 2)"/><xsl:text><![CDATA[ newValue)
{
	if (newValue == null)
	{
		]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		return this;
	}
	</xsl:text>
		<xsl:choose>
			<xsl:when test="contains(@type,'FVec') and ends-with(@type,'d')">
				<xsl:text>setValue(newValue.toDoubleArray()); // create array</xsl:text>
			</xsl:when>
			<xsl:when test="contains(@type,'Color') or contains(@type,'Rotation') or contains(@type,'FVec') or starts-with(@type,'SFMatrix')">
				<xsl:text>setValue(newValue.toFloatArray()); // create array
		</xsl:text>
			</xsl:when>
			<xsl:when test="starts-with(@type,'MFMatrix')">
				<xsl:text>// TODO matrix initialization
		</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ = new ]]></xsl:text>
				<xsl:value-of select="substring-before($javaType,'[]')"/>
				<xsl:text>[1]; // create (or else clear) previous contents
	</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>[0] = newValue.getValue();</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	<xsl:text>
	return this;
}
</xsl:text>
	</xsl:if>

<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Replace a single value at the appropriate location in the existing value array.
* Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param index is position of selected value in current array
* @param newValue provides new value to apply
*/
/* @Override */
public void set1Value(int index, ]]></xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text><![CDATA[ newValue) throws ArrayIndexOutOfBoundsException
{
	if (index < 0)
	{
		String errorNotice = "*** Index value is negative, thus cannot set1Value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ == 0)
	{
		String errorNotice = "*** Value array is empty, thus cannot set1Value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}]]></xsl:text>
	<xsl:if test="not($tupleSize = '1')">
		<xsl:text><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length != </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[)
		{
			String errorNotice = "*** Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must equal ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}]]></xsl:text>
	</xsl:if>
	<xsl:text><![CDATA[
	if (index >= ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="$tupleSize"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[) // tupleSize factor
	{
		String errorNotice = "*** Provided array index=" + index + " must be less than ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ array length=" + ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="$tupleSize"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[;
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	]]></xsl:text>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	if ((newValue < 0.0) && (newValue != SFTime.DEFAULT_VALUE)) // initial value check
	{
		newValue = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
	}
	]]></xsl:text>
	</xsl:if>
	<xsl:choose>
		<xsl:when test="starts-with(@type, 'MF') and ($tupleSize = 1)">
			<xsl:value-of select="$fieldName"/><xsl:text>[index] = newValue;</xsl:text>
		</xsl:when>
		<xsl:when test="starts-with(@type, 'MF')"><!-- $tupleSize > 1 -->
			<xsl:text>int offset = 0;
	for (</xsl:text><xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/><xsl:text> value : newValue)
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>[index + offset] = value;
		offset++;
	}</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>// TODO copy or insert newValue to index position</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text><![CDATA[
}

/**
* Places new value(s) at the end of the existing value array, increasing the field length accordingly.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
* <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param newValue The newValue to append
*/
/* @Override */
public void append(]]></xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text><![CDATA[ newValue)
{]]></xsl:text>
			<!-- newValue size check -->
			<xsl:choose>
				<xsl:when test="($fieldName = 'MFNode') or ($fieldName = 'MFString')">
					<!-- no size check needed -->
					<xsl:text>
	</xsl:text>
				</xsl:when>
				<xsl:when test="not($fieldName = 'MFDouble') and not($fieldName = 'MFFloat') and not($fieldName = 'MFInt32') and
						  not($fieldName = 'MFBool') and not($fieldName = 'MFTime')">
					<xsl:text>
	if ((newValue.length % </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) != 0) // tupleSize modulus check
	{
		String errorNotice = "*** illegal number of values (" + newValue.length + ")" +
			" in initialization array, must be multiple of </xsl:text>
					<xsl:value-of select="$tupleSize"/><xsl:text> when declaring new </xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(" + newValue + ")";
		validationResult.append(errorNotice).append("\n");
		throw new InvalidFieldValueException (errorNotice);
	}
	</xsl:text>
				</xsl:when>
				<xsl:otherwise>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	if ((newValue < 0.0) && (newValue != SFTime.DEFAULT_VALUE)) // initial value check
	{
		newValue = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
	}]]></xsl:text>
	</xsl:if>
					<xsl:text>
	</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="not(not(contains($javaPrimitiveType,'[')) and ($tupleSize = '1'))"> <!-- opposite of below -->
				<xsl:text>int originalLength = </xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>.length;
				</xsl:text>
			</xsl:if>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text>
			<xsl:text>Arrays.copyOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length + </xsl:text>
			<xsl:choose>
				<xsl:when test="contains($javaPrimitiveType,'[')">
					<xsl:text>newValue.length</xsl:text><!-- array -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$tupleSize"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>); // increase array size for append
	</xsl:text>
			<xsl:choose>
				<xsl:when test="not(contains($javaPrimitiveType,'[')) and ($tupleSize = '1')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text>[</xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[.length-1] = newValue;]]></xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text><![CDATA[for (int i = 0; i < newValue.length; i++)
	{
		]]></xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text>[originalLength + i] = newValue[i];
	}</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>
}
</xsl:text>
			<xsl:if test="($fieldName = 'MFDouble') or ($fieldName = 'MFFloat') or ($fieldName = 'MFInt32') or
						  ($fieldName = 'MFBool')   or ($fieldName = 'MFTime')  or ($fieldName = 'MFNode') or
						  ($fieldName = 'MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[/**
* Appends another array at the end of the existing value array, increasing the field length accordingly.
* <i>Warning:</i> newValue array length must correspond to tuple size for base type MFVec4f tuple size of <i>4</i>.
* @see X3DConcreteField#getTupleSize(String)
* @param newValue The newValue to append
*/
public void append(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ newValue)
{
	if ((newValue.length % ]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) != 0) // tupleSize modulus check
	{
		String errorNotice = "*** illegal number of values (" + newValue.length + ")" +
			" in initialization array, must be multiple of 4 when declaring new MFVec4f(" + newValue + ")";
		validationResult.append(errorNotice).append("\n");
		throw new InvalidFieldValueException (errorNotice);
	}
	</xsl:text>
			<xsl:text>int originalLength = </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length;
	</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text>
			<xsl:text>Arrays.copyOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length + </xsl:text>
			<xsl:choose>
				<xsl:when test="contains($javaPrimitiveType,'[') or starts-with($fieldName,'MF')">
					<xsl:text>newValue.length</xsl:text><!-- array -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$tupleSize"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text><![CDATA[); // increase array size for append
	for (int i = 0; i < newValue.length; i++)
	{
		]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>[originalLength + i] = newValue[i];
	}
}
</xsl:text>
			</xsl:if>

			<xsl:variable name="javaSingletonType">
				<xsl:text>S</xsl:text>
				<xsl:value-of select="substring(@type,2)"/>
			</xsl:variable>
			<xsl:variable name="thisClassName">
				<xsl:value-of select="$fieldName"/>
				<xsl:value-of select="$jsaiClassSuffix"/>
			</xsl:variable>
			<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Appends a new singleton typed value at the end of the existing value array, increasing the field length accordingly.
* <i>Note:</i> this method can be useful for incrementally constructing arrays.
* @param newValue The newValue to append
* @return {@link ]]></xsl:text>
				<xsl:value-of select="$thisClassName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
*/
public ]]></xsl:text>
				<xsl:value-of select="$thisClassName"/><xsl:text> append(</xsl:text><xsl:value-of select="$javaSingletonType"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
{
	append(newValue.getPrimitiveValue());
	return this;
}
]]></xsl:text>

				<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Appends a new ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text><![CDATA[ to the end of the existing value array, increasing the field length accordingly.
* <i>Note:</i> this method can be useful for constructing long arrays.
* @see X3DConcreteField#getTupleSize(String)
* @param newValue The newValue to append
* @return {@link ]]></xsl:text>
				<xsl:value-of select="$thisClassName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
*/
public ]]></xsl:text>
				<xsl:value-of select="$thisClassName"/><xsl:text> append(</xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
{
	append(newValue.getPrimitiveValue());
	return this;
}
]]></xsl:text>

			<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param index The position for the inserted value in the current array
* @param newValue The newValue to insert
*/
/* @Override */
public void insertValue(int index, ]]></xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
{
	if (index < 0)
	{
		String errorNotice = "*** Index value is negative, thus cannot insertValue at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}]]></xsl:text>
			<!-- newValue size check -->
			<xsl:choose>
				<xsl:when test="($fieldName = 'MFNode') or ($fieldName = 'MFString')">
					<!-- no size check needed -->
				</xsl:when>
				<xsl:when test="not($fieldName = 'MFDouble') and not($fieldName = 'MFFloat') and not($fieldName = 'MFInt32') and
						  not($fieldName = 'MFBool') and not($fieldName = 'MFTime')">
					<xsl:text>
	if (newValue.length != </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) // array size check, account for tupleSize
	{
		String errorNotice = "*** illegal number of values (" + newValue.length + ")" +
			" for insertValue newValue array, must equal </xsl:text>
					<xsl:value-of select="$tupleSize"/><xsl:text> for </xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text>insertValue(" + newValue + ")";
		validationResult.append(errorNotice).append("\n");
		throw new InvalidFieldValueException (errorNotice);
	}
	</xsl:text>
				</xsl:when>
			</xsl:choose>
			<!-- bounds check -->
			<xsl:text><![CDATA[
	if (index >= ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length)
	{
		String errorNotice = "*** Provided array index=" + index + " must be less than ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ array length=" + ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length;
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	]]></xsl:text>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	if ((newValue < 0.0) && (newValue != SFTime.DEFAULT_VALUE)) // initial value check
	{
		newValue = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
	}]]></xsl:text>
	</xsl:if>
	<xsl:text>
	int sliceLength = </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - index;
	</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text>
			<xsl:text>Arrays.copyOf(</xsl:text><xsl:value-of select="$fieldName"/>
			<xsl:text>, </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length + </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text>); // increase array size for insert
	System.arraycopy(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, index, </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, index + </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text>, sliceLength); // move second half of array to right
	</xsl:text>
	<xsl:choose>
		<xsl:when test="starts-with(@type, 'MF') and ($tupleSize = 1)">
			<xsl:value-of select="$fieldName"/><xsl:text>[index] = newValue;</xsl:text>
		</xsl:when>
		<xsl:when test="starts-with(@type, 'MF')"><!-- $tupleSize > 1 -->
			<xsl:text>int offset = 0;
	for (</xsl:text><xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/><xsl:text> value : newValue)
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>[index + offset] = value;
		offset++;
	}</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>// TODO copy or insert newValue to index position</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
}
</xsl:text>
	<xsl:if test="(@type = 'MFTime')">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Places a new value at the end of the existing value array, increasing the field length accordingly.
* @param newValue The newValue to append
*/
/* @Override */
public void append(long newValue)
{
	if ((newValue < 0) && ((double)newValue != SFTime.DEFAULT_VALUE)) // initial value check
	{
		 append(SFTime.DEFAULT_VALUE); // unusual occurrence, TODO log it
	}
	else append((double) newValue);
}

/**
* Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
* @param index The position for the inserted value in the current array
* @param newValue The newValue to insert
*/
/* @Override */
public void insertValue(int index, long newValue)
{
	if ((newValue < 0) && ((double)newValue != SFTime.DEFAULT_VALUE)) // initial value check
	{
		 insertValue(index, SFTime.DEFAULT_VALUE); // unusual occurrence, TODO log it
	}
	else insertValue(index, (double) newValue);
}

/**
* Replace a single value at the appropriate location in the existing value array.
* Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param index is position of selected value in current array
* @param newValue provides new value to apply
*/
/* @Override */
public void set1Value(int index, long newValue) throws ArrayIndexOutOfBoundsException
{
	if ((newValue < 0) && ((double)newValue != SFTime.DEFAULT_VALUE)) // initial value check
	{
		 set1Value(index, SFTime.DEFAULT_VALUE); // unusual occurrence, TODO log it
	}
	else set1Value(index, (double) newValue);
}

/**
* Replace values at the appropriate location in the existing value array.
* Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param index is position of selected value in current array
* @param newValue provides new value to apply
*/
/* @Override */
public void setValue(int index, long[] newValue) throws ArrayIndexOutOfBoundsException
{
	double[] doubleTimeValues = new double[newValue.length];
	for (int i=0; i < newValue.length; i++)
	{
		if ((newValue[i] < 0) && ((double)newValue[i] != SFTime.DEFAULT_VALUE)) // initial value check
		{
			 doubleTimeValues[i] = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
		}
		else doubleTimeValues[i] = newValue[i];
	}
	setValue(index, doubleTimeValues);
}
]]></xsl:text>
	</xsl:if>
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
 * Get the size of the underlying data array, meaning the number of
 * simple S]]></xsl:text><xsl:value-of select="substring($fieldName,2)"/><xsl:text disable-output-escaping="yes"><![CDATA[ elements for the given data type.
 *
 * @return The number of S]]></xsl:text><xsl:value-of select="substring($fieldName,2)"/><xsl:text disable-output-escaping="yes"><![CDATA[ elements in this field array.
 */
/* @Override */
public int size()
{
	return ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[;
}

/**
 * Removes all values in the field array, changing the array size to zero.
 */
/* @Override */
public void clear()
{
	]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ = new ]]></xsl:text>
	<xsl:choose>
		<xsl:when test="contains($javaPrimitiveType,'[')">
			<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="$javaPrimitiveType"/>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text disable-output-escaping="yes"><![CDATA[[0];
}

/**
 * Remove one S]]></xsl:text><xsl:value-of select="substring($fieldName,2)"/><xsl:text disable-output-escaping="yes"><![CDATA[ element of the field array at index position, if found.  Initial element is at index 0.
 * @param index position of element in field array that gets removed
 */
/* @Override */
public void remove(int index)
{
	if (index < 0)
	{
		String errorNotice = "*** Index value is negative, thus cannot remove() value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ == 0)
	{
		String errorNotice = "*** Value array is empty, thus cannot remove value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (index >= ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length)
	{
		String errorNotice = "*** Provided array index=" + index + " must be less than ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ array length=" + ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length;
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	int offsetLength = ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>.length - (index + 1) * </xsl:text>
		<xsl:value-of select="$tupleSize"/><xsl:text>; // account for tupleSize
	System.arraycopy(</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>, (index + 1) * </xsl:text>
		<xsl:value-of select="$tupleSize"/><xsl:text>, </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>, index * </xsl:text>
		<xsl:value-of select="$tupleSize"/><xsl:text>, offsetLength); // copy over element being removed
	</xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text> = Arrays.copyOfRange(</xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text>, 0, </xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text>.length - </xsl:text>
	<xsl:value-of select="$tupleSize"/><xsl:text>); // finally reduce overall array size by one tuple
}
</xsl:text>
					</xsl:if>

					<!-- specialized utility methods for field types in Java SAI specification -->
					<xsl:choose>
						<xsl:when test="(@type = 'SFTime')">
<xsl:text><![CDATA[
/**
*	Get the current value.
* 	@return current value
*/
/* @Override */
public long getJavaValue()
{
	return (long)SFTime;
}
/**
* Assign a new value, converting seconds from (long) to (double).
* @param newValue The replacement value to assign.
*/
/* @Override */
public void setValue(long newValue)
{
	SFTime = (double)newValue;
	if ((SFTime < 0.0) && (SFTime != DEFAULT_VALUE)) // initial value check
	{
		SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
	}
}
</xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'MFTime')">
					<xsl:text><![CDATA[
/**
 * <p>
 * Get an individual value from the existing field array.
 * </p><p>
 * If the index is outside the bounds of the current array of data values,
 * an ArrayIndexOutOfBoundsException is thrown.
 * </p>
 * @param index is position of selected value in current array
 * @return The selected value
 * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
 */
/* @Override */
public long get1JavaValue(int index)
{
	if (index < 0)
	{
		String errorNotice = "*** Index value is negative, thus cannot get1JavaValue at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	return (long)MFTime[index];
}

/**
* Assign a new value array, converting seconds from (long) to (double).
* @param newValue is replacement value array to assign
*/
/* @Override */
public void setValue(long[] newValue)
{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:text><![CDATA[
	// create new array and cast each value
	MFTime = new double[newValue.length];
	for (int i=0; i < newValue.length; i++)
	{
		if ((newValue[i] < 0) && ((double)newValue[i] != SFTime.DEFAULT_VALUE)) // initial value check
		{
			 MFTime[i] = SFTime.DEFAULT_VALUE; // unusual occurrence, TODO log it
		}
		else MFTime[i] = (double)newValue[i];
	}
}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="starts-with(@type,'MFColor')">
							<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	/* @Override */
	public void getValue(float[][] valueDestination)
	{
		// TODO
	}

    /**
     * Assign an array subset to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	/* @Override */
	public void setValue(int size, float[][] newValue)
	{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:value-of select="$newValueSizeCheck"/>
	<xsl:text><![CDATA[
		// TODO
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test = "(@type = 'SFImage')">
							<xsl:text><![CDATA[
    /**
     * Get the width of the image.
     * @throws InvalidFieldValueException Invalid SFImage data found
     * @return The width of the image in pixels
     */
	/* @Override */
	public int getWidth()
	{
		if  ((SFImage == null) || (SFImage.length < 3))
		{
			String errorNotice = "*** Null array or illegal data length for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		int      width = SFImage[0];
		int     height = getHeight();
		if ((width < 0) || (height < 0))
		{
			String errorNotice = "*** Illegal negative value: width=" + width + ", height=" + height +
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		return SFImage[0];
	}

    /**
     * Get the height of the image.
     * @throws InvalidFieldValueException Invalid SFImage data found
     * @return The height of the image in pixels
     */
	/* @Override */
	public int getHeight()
	{
		if  ((SFImage == null) || (SFImage.length < 3))
		{
			String errorNotice = "*** Null array or illegal data length for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		int      width = getWidth();
		int     height = SFImage[1];
		if ((width < 0) || (height < 0))
		{
			String errorNotice = "*** Illegal negative value: width=" + width + ", height=" + height +
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		return SFImage[1];
	}

    /**
     * Get the number of color components in the image. The value will
     * always be between 0 and 4 indicating the number of components of
     * the color specification to be read from the image pixel data.
     * @throws InvalidFieldValueException Invalid SFImage data found
     * @return The number of components
     */
	/* @Override */
	public int getNumberComponents()
	{
		if  ((SFImage == null) || (SFImage.length < 3))
		{
			String errorNotice = "*** Null array or illegal data length for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		int components = SFImage[2];
		if ((components < 0) || (components > 4))
		{
			String errorNotice = "*** Illegal value, must be in range [0..4]: number of components=" + components +
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		return SFImage[2];
	}

    /**
     * Compute expected length of SFImage integer array (based on height and width values).
	 * Note that each integer pixel value must represent the full set of components for this SFImage.
	 * @see #getWidth
	 * @see #getHeight
	 * @return number of expected pixel values in SFImage integer array
	 */
	public int getExpectedLength()
	{
		return (getWidth() * getHeight());
	}
    /**
     * Compute number of pixel values in SFImage integer array (not counting height, width and components values).
	 * Note that each integer pixel value must represent the full set of components for this SFImage.
	 * @see #getWidth
	 * @see #getHeight
	 * @return number of pixel values in SFImage integer array
	 */
	public int getNumberOfPixelValues()
	{
		return Integer.max(SFImage.length - 3, 0);
	}

    /**
     * Get the image pixel value in the given eventOut.
     * <p>
     * The number of items in the pixels array will be
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     * @param destinationPixels The array to copy pixel values into
     * @throws InvalidFieldValueException Invalid SFImage data found
     */
	/* @Override */
	public void getPixels(int[] destinationPixels)
	{
		if  ((SFImage == null) || (SFImage.length < 3))
		{
			String errorNotice = "*** Null array or illegal data length for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		int      width = getWidth();
		int     height = getHeight();
		int components = getNumberComponents(); // includes error checks
		destinationPixels = new int[SFImage.length];
		if ((width == 0) || (height == 0) || (components == 0))
		{
			destinationPixels = new int[0];
		}
		else if (SFImage.length > 3)
		{
//  		destinationPixels = new int[width * height];                        // TODO necessary?
			destinationPixels = Arrays.copyOfRange(SFImage, 3, SFImage.length); // TODO verify
		}
		else
		{
			String errorNotice = "*** Illegal value for SFImage field type, getPixels() cannot get pixel array";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}

    /**
     * Fetch the Java representation of the underlying image from these pixels.
     * This is the same copy that the browser uses to generate texture
     * information from.
     * @return The image reference representing the current state
     */
	/* @Override */
	public java.awt.image.WritableRenderedImage getImage()
	{
		return null; // TODO
	}

    /**
     * Set the image value in the given writable field to the new image defined
     * by a set of pixels.
     * <p>
     * @param image The new image to use as the source
     */
	/* @Override */
	public void setImage(java.awt.image.RenderedImage image)
	{
		// TODO
	}

    /**
	 * Copy a region of the argument RenderedImage to replace a portion of the
	 * current SFimage.
	 * <p>
	 * The sub image set shall not resize the base image representation and
	 * therefore performs an intersection clip of the provided image. The user
	 * provided image shall be of the same format (pixel depth, pixel
	 * representation) as the original image obtained through the getImage()
	 * method.
	 * <p>
	 * RenderedImages are row order from top to bottom. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 0 |********|
	 * 1 |********|
	 * 2 |********|
	 * 3 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * SFImages are row order from bottom to top. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 3 |********|
	 * 2 |********|
	 * 1 |********|
	 * 0 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * <p>
	 * Note: The parameter srcYOffset is referenced to the RenderedImage object
	 * (indexed top to bottom).
	 * <br>
	 * The parameter destYOffset is referenced to the SFImage object
	 * (indexed bottom to top).
	 *
	 * @param image The new image to use as the source
	 * @param sourceWidth The width of the argument sub-image region to copy
	 * @param sourceHeight The height of the argument sub-image region to copy
	 * @param sourceXOffset The initial x dimension (width) offset into the
	 * argument sub-image that begins the region to copy
	 * @param sourceYOffset The initial y dimension (height) offset into the
	 * argument sub-image that begins the region to copy
	 * @param destinationXOffset The initial x dimension (width) offset in the SFimage
	 * object that begins the region to receive the copy
	 * @param destinationYOffset The initial y dimension (height) offset in the SFimage
	 * object that begins the region to receive the copy
	 */
	/* @Override */
	public void setSubImage(java.awt.image.RenderedImage image,
                            int sourceWidth,
                            int sourceHeight,
                            int sourceXOffset,
                            int sourceYOffset,
                            int destinationXOffset,
                            int destinationYOffset)
	{
		// TODO
	}

    /**
     * Set the image value in the given writable field.
     * <p>
     * Image values are specified using a width, height and the number of
     * components. The number of items in the pixels array must be at least
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components. If the integer
     * contains values in bytes that are not used by the number of components
     * for that image, the values are ignored.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     *
     * @param width The width of the image in pixels
     * @param height The height of the image in pixels
     * @param components The number of color components [1-4]
     * @param pixels The array of pixel values as specified above.
     * @exception IllegalArgumentException The number of components or width/
     *    height are illegal values.
     * @exception ArrayIndexOutOfBoundsException The number of pixels provided by the
     *    caller is not enough for the width * height.
     * @throws IllegalArgumentException Invalid parameter(s) provided, no change was made
     */
	/* @Override */
	public void setValue(int width,
                         int height,
                         int components,
                         int[] pixels)
	{
		if ((width < 0) || (height < 0))
		{
			String errorNotice = "*** Illegal negative value: width=" + width + ", height=" + height +
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
		if ((components < 0) || (components > 4))
		{
			String errorNotice = "*** Illegal value, must be in range [0..4]: number of components=" + components +
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
		if (((width * height * components) > 0) && (pixels.length < (width * height)))
		{
			String errorNotice = "*** Illegal number of pixels: pixels.length=" + pixels.length +
				", (width * height * components) = " + width + " * " + components + " * " + components + ") = " +
				(width * height * components) + " for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
		SFImage = new int[3 + (width * height)];
		SFImage[0] = width;
		SFImage[1] = height;
		SFImage[2] = components;
		System.arraycopy(pixels, 0, SFImage, 3, pixels.length);
	}

    /**
     * Set the image value as a primitive array.
	 * @param sfImageArray full set of SFImage values
	 */
	public void setValue(int[] sfImageArray)
	{
		if (sfImageArray == null)
		{
			String errorNotice = "*** Illegal sfImageArray, cannot be null.";
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
		else if (sfImageArray.length < 3)
		{
			String errorNotice = "*** Illegal sfImageArray.length=" + sfImageArray.length + ", must be at least 3.";
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
		setValue (sfImageArray[0], sfImageArray[1], sfImageArray[2], Arrays.copyOfRange(sfImageArray,3,sfImageArray.length));
	}

    /** index of width parameter in image array */
    static final int WIDTH_INDEX  = 0;
    /** index of height parameter in image array */
    static final int HEIGHT_INDEX = 1;
    /** index of numberComponents parameter in image array */
    static final int NUMBER_COMPONENTS_INDEX = 2;
    /** number of initialization parameters in image array preceding pixel values */
    static final int NUMBER_PARAMETERS = 3;

	/**
	 * Utility method to get format string for proper output of hexadecimal values.
     * @param numberComponents 1..4 for transparency, BW, RGB, RGBA texture
	 * @return format string for hexadecimal values
	 */
	public static String getPixelHexFormat(int numberComponents)
    {
        // https://stackoverflow.com/questions/13851743/how-to-format-numbers-to-a-hex-strings
        switch (numberComponents) {
            case 0:  return "0x%02X"; // allowed value for SFImage default (0 0 0)
            case 1:  return "0x%02X";
            case 2:  return "0x%04X";
            case 3:  return "0x%06X";
            case 4:  return "0x%08X";
            default:
            {
                String errorNotice = "*** erroneous image numberComponents=" + numberComponents + " for SFImage, unable to compute getPixelHexFormat()";
                validationResult.append(errorNotice).append("\n");
                throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
            }
        }
	}
	/**
	 * Utility method to get String value of pixels in SFImage image field.
	 * @return string value of pixels
	 */
	public String getPixelsString()
    {
        StringBuilder result = new StringBuilder();
        String hexFormat = getPixelHexFormat(getNumberComponents());

        int[] destinationPixels = Arrays.copyOfRange(SFImage, 3, SFImage.length);
		for (int i = 0; i < destinationPixels.length; i++)
        {
			result.append(String.format(hexFormat, destinationPixels[i]));
			result.append(" ");
		}
		return result.toString().trim();
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test = "(@type = 'MFImage')">
							<xsl:text><![CDATA[
    /**
     * Get the width of the image array.
     * @param imageIndex the index of the selected image
     * @return The width of the image in pixels
     */
	/* @Override */
	public int getWidth(int imageIndex)
	{
		return 0; // TODO access correct image, return value
	}

    /**
     * Get the height of the image array.
     * @param imageIndex the index of the selected image
     * @return The height of the image in pixels
     */
	/* @Override */
	public int getHeight(int imageIndex)
	{
		return 0; // TODO access correct image, return value
	}

    /**
     * Get the number of color components in the image. The value will
     * always be between 0 and 4 indicating the number of components of
     * the color specification to be read from the image pixel data.
     * @param imageIndex the index of the selected image
     * @return The number of components
     */
	/* @Override */
	public int getNumberComponents(int imageIndex)
	{
		return 0; // TODO access correct image, return value
	}

    /**
     * Get the image pixel value in the given eventOut.
     * <p>
     * The number of items in the pixels array will be
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     * @param imageIndex the index of the selected image
     * @param pixels The array to copy pixel values into
     */
	/* @Override */
	public void getPixels(int imageIndex, int[] pixels)
	{
		// TODO
	}

    /**
     * Fetch the Java representation of the underlying image from these pixels.
     * This is the same copy that the browser uses to generate texture
     * information from.
     * @param imageIndex the index of the selected image
     * @return The image reference representing the current state
     */
	/* @Override */
	public WritableRenderedImage getImage(int imageIndex)
	{
		return null; // TODO
	}

    /**
     * Set the image value in the given writable field to the new image defined
     * by a set of pixels.
     * @param imageIndex the index of the selected image
     * @param image The new image to use as the source
     */
	/* @Override */
	public void setImage(int imageIndex, RenderedImage image)
	{
		// TODO
	}

    /**
	 * Copy a region of the argument RenderedImage to replace a portion of the
	 * current SFimage.
	 * <p>
	 * The sub image set shall not resize the base image representation and
	 * therefore performs an intersection clip of the provided image. The user
	 * provided image shall be of the same format (pixel depth, pixel
	 * representation) as the original image obtained through the getImage()
	 * method.
	 * <p>
	 * RenderedImages are row order from top to bottom. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 0 |********|
	 * 1 |********|
	 * 2 |********|
	 * 3 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * SFImages are row order from bottom to top. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 3 |********|
	 * 2 |********|
	 * 1 |********|
	 * 0 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * <p>
	 * Note: The parameter srcYOffset is referenced to the RenderedImage object
	 * (indexed top to bottom).
	 * <br>
	 * The parameter destYOffset is referenced to the SFImage object
	 * (indexed bottom to top).
	 *
	 * @param imageIndex the index of the selected image
	 * @param image The new image to use as the source
	 * @param sourceWidth The width of the argument sub-image region to copy
	 * @param sourceHeight The height of the argument sub-image region to copy
	 * @param sourceXOffset The initial x dimension (width) offset into the
	 * argument sub-image that begins the region to copy
	 * @param sourceYOffset The initial y dimension (height) offset into the
	 * argument sub-image that begins the region to copy
	 * @param destinationXOffset The initial x dimension (width) offset in the SFimage
	 * object that begins the region to receive the copy
	 * @param destinationYOffset The initial y dimension (height) offset in the SFimage
	 * object that begins the region to receive the copy
	 */
	/* @Override */
	public void setSubImage(int imageIndex,
		RenderedImage image,
		int sourceWidth,
		int sourceHeight,
		int sourceXOffset,
		int sourceYOffset,
		int destinationXOffset,
		int destinationYOffset)
	{
		// TODO
	}

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param imageIndex the index of the selected image
     * @param newValue provides new value to apply
     */
	/* @Override */
	public void set1Value(int imageIndex, int newValue)
	{
		// TODO
	}

	/* @Override */
	public void set1Value(int imageIndex,
		int width,
		int height,
		int components,
		int[] pixels)
	{
		// TODO
	}

    /**
     * Assign a new value array; can be an SFImage primive array containing width, height, and components count, followed by array of pixels.
     * @param newValue the newValue to set
     */
	/* @Override */
	public void setValue(int[] newValue)
	{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:text><![CDATA[
		SFImage]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newSFImage = new SFImage(newValue); // checks values
		// TODO if initial image is OK then proceed; need to improve checks to handle arrays
		MFImage = newValue;
	}

    /**
     * Assign a new value array; can be an SFImage primive array containing width, height, and components count, followed by array of pixels.
     * @param newValue the newValue to set
     */
	public void setValue(SFImage]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:text><![CDATA[
		MFImage = newValue.getPrimitiveValue();
	}

	/* @Override */
	public void setImage(RenderedImage[] image)
	{
		// TODO
	}

    /**
     * Places a new SFImage value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	/* @Override */
	public void append(RenderedImage[] newValue)
	{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:text><![CDATA[
		// TODO
	}

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	/* @Override */
	public void insertValue(int index, RenderedImage newValue)
	{
		if (index < 0)
		{
			String errorNotice = "*** Index value is negative, thus cannot insertValue at index=" + index + ".";
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:text><![CDATA[
		// TODO
	}
	/**
	 * Remove one S]]></xsl:text><xsl:value-of select="substring($fieldName,2)"/><xsl:text disable-output-escaping="yes"><![CDATA[ element of the field array at index position, if found.  Initial element is at index 0.
	 * @param index position of element in field array that gets removed
	 */
	/* @Override */
	public void remove (int index)
	{
		if (index < 0)
		{
			String errorNotice = "*** Index value is negative, thus cannot remove value at index=" + index + ".";
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
		// TODO compute offset factor
		if (index >= ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>.length)
		{
				String errorNotice = "*** Provided array index=" + index + " must be less than </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> array length=" + </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>.length;
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
		// TODO remove (int index)
	}
	/**
	 * Removes all values in the field array, changing the array size to zero.
	 */
	/* @Override */
	public void clear()
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> = new </xsl:text><xsl:value-of select="substring-before($javaType,'[')"/><xsl:text>[0];
	}
	/**
	 * Get the size of the underlying data array. The size is the number of
	 * elements for that data type. So for an MFFloat the size would be the
	 * number of float values, but for an MFVec3f, it is the number of vectors
	 * in the returned array (where a vector is 3 consecutive array indexes in
	 * a flat array).
	 *
	 * @return The number of elements in this field array.
	 */
	/* @Override */
	public int size()
	{
		return </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>.length;
	}
</xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFMatrix3f') or (@type = 'MFMatrix3f')">
						<xsl:text>
	/**
	 * Apply an array of primitive values to this field.
	 * @param newValue The newValue to apply
	 * @return {@link </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> setValue(</xsl:text><xsl:value-of select="$javaType"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
		if (newValue == null)
		{
			]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> = java.util.Arrays.copyOf(DEFAULT_VALUE, DEFAULT_VALUE.length); // must be separate copy
			return this;
		}
        </xsl:text>
        <xsl:choose>
            <xsl:when test="starts-with(@type, 'SF')">
                <xsl:text>if (newValue.length != 9)</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>if ((newValue.length % 9) != 0) // modulo, must be a multiple of SFMatrix3 size</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>
		{
			String errorNotice = "*** Illegal array newValue=" + newValue + " must have base length 9 for setValue() on </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> = newValue;
		return this;
	}
	/* @Override */
	public void setIdentity()
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ = org.web3d.x3d.jsail.fields.SFMatrix3f.DEFAULT_VALUE;
	}

	/* @Override */
	public void set(int row, int column)
	{
		// TODO, problem with interface signature
	}

	/* @Override */
	public float get(int row, int column)
	{
		if ((row < 0) || (row > 4) || (column < 0) || (column > 4))
		{
			String errorNotice = "*** Illegal ]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>[row=" + row + ",column=" + column + "] access, " +
				"all values must be in numeric range [0..4]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		return </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[3*row + column]; // TODO typing
	}

	/* @Override */
	public void setTransform(org.web3d.x3d.sai.SFVec3f translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3f scale,
		org.web3d.x3d.sai.SFRotation scaleOrientation,
		org.web3d.x3d.sai.SFVec3f center)
	{
		// TODO
	}

	/* @Override */
	public void getTransform(org.web3d.x3d.sai.SFVec3f translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3f scale)
	{
		// TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 inverse()
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 transpose()
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 multiplyLeft (org.web3d.x3d.sai.Matrix3 matrix3x3)
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 multiplyRight(org.web3d.x3d.sai.Matrix3 matrix3x3)
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 multiplyRowVector(org.web3d.x3d.sai.SFVec3f vector3f) // TODO SFVec4f ?
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 multiplyColVector(org.web3d.x3d.sai.SFVec3f vector3f) // TODO SFVec4f ?
	{
		return null; // TODO
	}
]]></xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFMatrix3d') or (@type = 'MFMatrix3d')">
						<xsl:text>
	/**
	 * Apply an array of primitive values to this field.
	 * @param newValue The newValue to apply
	 * @return {@link </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> setValue(</xsl:text><xsl:value-of select="$javaType"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
		if (newValue == null)
		{
			]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> = java.util.Arrays.copyOf(DEFAULT_VALUE, DEFAULT_VALUE.length); // must be separate copy
			return this;
		}
        </xsl:text>
        <xsl:choose>
            <xsl:when test="starts-with(@type, 'SF')">
                <xsl:text>if (newValue.length != 9)</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>if ((newValue.length % 9) != 0) // modulo, must be a multiple of SFMatrix3 size</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>
		{
			String errorNotice = "*** Illegal array newValue=" + newValue + " must have base length 9 for setValue() on </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> = newValue;
		return this;
	}
	/* @Override */
	public void setIdentity()
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ = org.web3d.x3d.jsail.fields.SFMatrix3d.DEFAULT_VALUE;
	}

	/* @Override */
	public void set(int row, int column)
	{
		// TODO
	}

	/* @Override */
	public float get(int row, int column) // TODO SAI interface problem, needs to be double
	{
		if ((row < 0) || (row > 4) || (column < 0) || (column > 4))
		{
			String errorNotice = "*** Illegal ]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>[row=" + row + ",column=" + column + "] access, " +
				"all values must be in numeric range [0..4]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		return (float)</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[3*row + column]; // TODO typing
	}

	/* @Override */
	public void setTransform(org.web3d.x3d.sai.SFVec3d translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3d scale,
		org.web3d.x3d.sai.SFRotation scaleOrientation,
		org.web3d.x3d.sai.SFVec3d center)
	{
		// TODO
	}

	/* @Override */
	public void getTransform(org.web3d.x3d.sai.SFVec3d translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3d scale)
	{
		// TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 inverse()
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 transpose()
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 multiplyLeft (org.web3d.x3d.sai.Matrix3 matrix3x3)
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 multiplyRight(org.web3d.x3d.sai.Matrix3 matrix3x3)
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 multiplyRowVector(org.web3d.x3d.sai.SFVec3d vector3d) // TODO SFVec4d ?
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix3 multiplyColVector(org.web3d.x3d.sai.SFVec3d vector3d) // TODO SFVec4d ?
	{
		return null; // TODO
	}
]]></xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFMatrix4f') or (@type = 'MFMatrix4f')">
						<xsl:text>
	/**
	 * Apply an array of primitive values to this field.
	 * @param newValue The newValue to apply
	 * @return {@link </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> setValue(</xsl:text><xsl:value-of select="$javaType"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
		if (newValue == null)
		{
			]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> = java.util.Arrays.copyOf(DEFAULT_VALUE, DEFAULT_VALUE.length); // must be separate copy
			return this;
		}
        </xsl:text>
        <xsl:choose>
            <xsl:when test="starts-with(@type, 'SF')">
                <xsl:text>if (newValue.length != 16)</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>if ((newValue.length % 16) != 0) // modulo, must be a multiple of SFMatrix4 size</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>
		{
			String errorNotice = "*** Illegal array newValue=" + newValue + " must have base length 16 for setValue() on </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> = newValue;
		return this;
	}
	/* @Override */
	public void setIdentity()
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ = org.web3d.x3d.jsail.fields.SFMatrix4f.DEFAULT_VALUE;
	}

	/* @Override */
	public void set(int row, int column)
	{
		// TODO
	}

	/* @Override */
	public float get(int row, int column)
	{
		if ((row < 0) || (row > 4) || (column < 0) || (column > 4))
		{
			String errorNotice = "*** Illegal ]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>[row=" + row + ",column=" + column + "] access, " +
				"all values must be in numeric range [0..4]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		return </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[3*row + column]; // TODO typing
	}

	/* @Override */
	public void setTransform(org.web3d.x3d.sai.SFVec3f translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3f scale,
		org.web3d.x3d.sai.SFRotation scaleOrientation,
		org.web3d.x3d.sai.SFVec3f center)
	{
		// TODO
	}

	/* @Override */
	public void getTransform(org.web3d.x3d.sai.SFVec3f translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3f scale)
	{
		// TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 inverse()
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 transpose()
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 multiplyLeft (org.web3d.x3d.sai.Matrix4 matrix3x3)
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 multiplyRight(org.web3d.x3d.sai.Matrix4 matrix3x3)
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 multiplyRowVector(org.web3d.x3d.sai.SFVec3f vector3f) // TODO SFVec4f ?
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 multiplyColVector(org.web3d.x3d.sai.SFVec3f vector3f) // TODO SFVec4f ?
	{
		return null; // TODO
	}
]]></xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFMatrix4d') or (@type = 'MFMatrix4d')">
						<xsl:text>
	/**
	 * Apply an array of primitive values to this field.
	 * @param newValue The newValue to apply
	 * @return {@link </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> setValue(</xsl:text><xsl:value-of select="$javaType"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
		if (newValue == null)
		{
			]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> = java.util.Arrays.copyOf(DEFAULT_VALUE, DEFAULT_VALUE.length); // must be separate copy
			return this;
		}
        </xsl:text>
        <xsl:choose>
            <xsl:when test="starts-with(@type, 'SF')">
                <xsl:text>if (newValue.length != 16)</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>if ((newValue.length % 16) != 0) // modulo, must be a multiple of SFMatrix4 size</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>
		{
			String errorNotice = "*** Illegal array newValue=" + newValue + " must base have length 16 for setValue() on </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text> = newValue;
		return this;
	}
	/* @Override */
	public void setIdentity()
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ = org.web3d.x3d.jsail.fields.SFMatrix4d.DEFAULT_VALUE;
	}

	/* @Override */
	public void set(int row, int column)
	{
		// TODO
	}

	/* @Override */
	public float get(int row, int column) // TODO SAI interface problem, needs to be double
	{
		if ((row < 0) || (row > 4) || (column < 0) || (column > 4))
		{
			String errorNotice = "*** Illegal ]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>[row=" + row + ",column=" + column + "] access, " +
				"all values must be in numeric range [0..4]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		return (float)</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[3*row + column]; // TODO typing
	}

	/* @Override */
	public void setTransform(org.web3d.x3d.sai.SFVec3d translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3d scale,
		org.web3d.x3d.sai.SFRotation scaleOrientation,
		org.web3d.x3d.sai.SFVec3d center)
	{
		// TODO
	}

	/* @Override */
	public void getTransform(org.web3d.x3d.sai.SFVec3d translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3d scale)
	{
		// TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 inverse()
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 transpose()
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 multiplyLeft (org.web3d.x3d.sai.Matrix4 matrix3x3)
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 multiplyRight(org.web3d.x3d.sai.Matrix4 matrix3x3)
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 multiplyRowVector(org.web3d.x3d.sai.SFVec3d vector3d) // TODO SFVec4d ?
	{
		return null; // TODO
	}

	/* @Override */
	public org.web3d.x3d.sai.Matrix4 multiplyColVector(org.web3d.x3d.sai.SFVec3d vector3d) // TODO SFVec4d ?
	{
		return null; // TODO
	}
]]></xsl:text>
					</xsl:when>
					</xsl:choose>

					<!-- additional utility methods for field types in jsail -->
					<!-- setValue convenience methods -->
					<xsl:choose>
						<xsl:when test="(@type = 'SFBool')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to negate this boolean value.
	 * @return {@link SFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ negate()
	{
		SFBool = !SFBool; // negate
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'MFBool')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to negate this array of boolean values.
	 * @return {@link MFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public MFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ negate()
	{
		for (int i= 0; i < MFBool.length; i++)
		{
			MFBool[i] = !MFBool[i]; // negate
		}
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFFloat')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Apply a double value to this float field type, note change in precision.
	 * @param newValue The double newValue to apply
	 * @return {@link SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[  setValue(double newValue)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = (float) newValue;
		return this;
	}

	/**
	 * Apply an int value to this float field type, note change in precision.
	 * @param newValue The int newValue to apply
	 * @return {@link SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[  setValue(int newValue)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = (float) newValue;
		return this;
	}

	/**
	 * Utility method to strip trailing fractional zeroes from String representations of the current object's value.
	 * Applicability: first converting an integer (such as 100) to float and then String results in trailing decimal point and zero (such as
100.0).
	 * Functionality can be globally enabled/disabled by {@link ConfigurationProperties#setStripTrailingZeroes(boolean)}.
	 * @see <a href="https://stackoverflow.com/questions/14984664/remove-trailing-zero-in-java">StackOverflow: Remove trailing zero in Java</a>
	 * @see <a href="https://stackoverflow.com/questions/11284938/remove-trailing-zeros-from-double">StackOverflow: Remove trailing zeros from double (String manipulation solution)</a>
	 * @see <a href="https://stackoverflow.com/questions/703396/how-to-nicely-format-floating-numbers-to-string-without-unnecessary-decimal-0">StackOverflow: How to nicely format floating numbers to String without unnecessary decimal 0? (&quot;In short&quot; solution)</a>
	 * @see <a href="https://library.oreilly.com/book/0636920023630/regular-expressions-cookbook-2nd-edition/275.xhtml">Regular Expressions Cookbook, 6.6. Strip Leading Zeros, by Jan Goyvaerts, Steven Levithan</a>
	 * @return string value with trailing zeros and decimal points stripped
	 */
	public String stripTrailingZeroes()
	{
		return stripTrailingZeroes(getValue());
	}

	/**
	 * Utility method to always strip trailing fractional zeroes from String value of any given float.
	 * Applicability: first converting an integer (such as 100) to float and then String results in trailing decimal point and zero (such as 100.0).
	 * <i>Note:</i> not affected by {@link ConfigurationProperties#setStripTrailingZeroes(boolean)}.
	 * @param value a single-precision number
	 * @see #stripTrailingZeroes(float)
	 * @return string value with trailing zeros and decimal points stripped
	 */
	public static String stripTrailingZeroes(float value)
	{
		String stringValue = String.valueOf(value);
		if (stringValue.contains(".") && !stringValue.contains("E") && !stringValue.contains("e"))
			 // regex to strip trailing zeroes, then strip trailing decimal point (if no other fractional part remains)
			 return stringValue.replaceAll("[0]*$", "").replaceAll("\\.$", "");
		else return stringValue; // avoided values with decimal point or exponential scientific notation
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFDouble') or (@type = 'SFTime')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Apply a float value to this double field type, note change in precision.
	 * @param newValue The float newValue to apply
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> setValue(float newValue)
	{
		</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = (double) newValue;
		return this;
	}

	/**
	 * Apply an int value to this double field type, note change in precision.
	 * @param newValue The float newValue to apply
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> setValue(int newValue)
	{
		</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = (double) newValue;
		return this;
	}

	/**
	 * Utility method to strip trailing fractional zeroes from String representations of the current object's value.
	 * Applicability: first converting an integer (such as 100) to double and then String results in trailing decimal point and zero (such as
100.0).
	 * Functionality can be globally enabled/disabled by {@link ConfigurationProperties#setStripTrailingZeroes(boolean)}.
	 * @see <a href="https://stackoverflow.com/questions/14984664/remove-trailing-zero-in-java">StackOverflow: Remove trailing zero in Java</a>
	 * @see <a href="https://stackoverflow.com/questions/11284938/remove-trailing-zeros-from-double">StackOverflow: Remove trailing zeros from double (String manipulation solution)</a>
	 * @see <a href="https://stackoverflow.com/questions/703396/how-to-nicely-format-floating-numbers-to-string-without-unnecessary-decimal-0">StackOverflow: How to nicely format floating numbers to String without unnecessary decimal 0? (&quot;In short&quot; solution)</a>
	 * @see <a href="https://library.oreilly.com/book/0636920023630/regular-expressions-cookbook-2nd-edition/275.xhtml">Regular Expressions Cookbook, 6.6. Strip Leading Zeros, by Jan Goyvaerts, Steven Levithan</a>
	 * @return string value with trailing zeros and decimal points stripped
	 */
	public String stripTrailingZeroes()
	{
		return stripTrailingZeroes(getValue());
	}
	/**
	 * Utility method to always strip trailing fractional zeroes from String value of any given double.
	 * Applicability: first converting an integer (such as 100) to double and then String results in trailing decimal point and zero (such as 100.0).
	 * <i>Note:</i> not affected by {@link ConfigurationProperties#setStripTrailingZeroes(boolean)}.
	 * @param value a double-precision number
	 * @see #stripTrailingZeroes(double)
	 * @return string value with trailing zeros and decimal points stripped
	 */
	public static String stripTrailingZeroes(double value)
	{
		String stringValue = String.valueOf(value);
		if (stringValue.contains(".") && !stringValue.contains("E") && !stringValue.contains("e"))
			 // regex to strip trailing zeroes, then strip trailing decimal point (if no other fractional part remains)
			 return stringValue.replaceAll("[0]*$", "").replaceAll("\\.$", "");
		else return stringValue; // avoided values with decimal point or exponential scientific notation
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'MFTime')">
	<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a single float value as new double array (of length 1).
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float newValue)
	{
		setValue((double) newValue); // apply checks
		return this;
	}
	/**
	 * Assign a float array as new double array.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float[] newValue)
	{
		if (newValue == null)
		{
			initialize();
		}
		else
		{
			double[] doubleArray = new double[newValue.length]; // fix array size
			for (int i=0; i < newValue.length; i++)
				doubleArray[i] = (double) newValue[i];
			setValue(doubleArray); // apply checks
		}
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec2d')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @return {@link SFVec2d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFVec2d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec3d')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @return {@link SFVec3d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFVec3d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y, double z)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = z;
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec4d')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param t third component
	 * @return {@link SFVec4d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFVec4d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y, double z, double t)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = z;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[3] = t;
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec2f')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @return {@link SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float x, float y)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		return this;
	}
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @return {@link SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y)
	{
		setValue((float) x, (float) y);
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec3f')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @return {@link SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float x, float y, float z)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = z;
		return this;
	}
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @return {@link SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y, double z)
	{

		setValue((float) x, (float) y, (float) z);
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFColor')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float red, float green, float blue)
	{
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "*** Illegal SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = red;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = green;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = blue;
		return this;
	}

	/**
	 * Assign a new value to this field.
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double red, double green, double blue)
	{
		setValue ((float) red, (float) green, (float) blue);
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFColorRGBA')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @param alpha fourth component for opaqueness (1 - transparency) [0..1]
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float red, float green, float blue, float alpha)
	{
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "*** Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = red;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = green;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text disable-output-escaping="yes"><![CDATA[[2] = blue;
		return this;
	}
	/**
	 * Assign a new value to this field.
	 * @param red first component [0..1]
	 * @param green second component [0..1]
	 * @param blue third component [0..1]
	 * @param alpha fourth component for opaqueness (1 - transparency) [0..1]
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double red, double green, double blue, double alpha)
	{
		setValue ((float) red, (float) green, (float) blue, (float) alpha);
		return this;
	}
	/**
	 * Utility method to modify transparency
	 * @param newTransparency value [0..1]
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setTransparency (float newTransparency)
	{
		if ((newTransparency < 0.0f) || (newTransparency > 1.0f))
		{
			String errorNotice = "*** Illegal SFColorRGBA transparency value=" + newTransparency +
												 ", must be within numeric range [0..1] inclusive";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColorRGBA[3] = newTransparency;
		return this;
	}
	/**
	 * Utility method to modify transparency
	 * @param newTransparency value [0..1]
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setTransparency (double newTransparency)
	{
		setTransparency ((float) newTransparency);
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec4f')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param t fourth component
	 * @return {@link SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float x, float y, float z, float t)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = z;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[3] = t;
		return this;
	}
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param t fourth component
	 * @return {@link SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y, double z, double t)
	{
		setValue((float) x, (float) y, (float) z, (float) t);
		return this;
	}
]]></xsl:text>
						</xsl:when>
					</xsl:choose>
					<!-- primitive array methods -->
					<xsl:choose>
						<xsl:when test="contains(@type,'FVec2f')    or contains(@type,'FVec3f')    or contains(@type,'FVec4f')    or
										contains(@type,'FMatrix2f') or contains(@type,'FMatrix3f') or contains(@type,'FMatrix4f') or
										contains(@type,'MFFloat')   or contains(@type,'FColor')    or contains(@type,'FRotation')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Provide float array for this field type.
	 *
	 * @return Array of floats in this field array.
	 */
	public float[] toFloatArray()
	{
		return ]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="contains(@type,'FVec2d')    or contains(@type,'FVec3d')    or contains(@type,'FVec4d')    or
										contains(@type,'FMatrix2d') or contains(@type,'FMatrix3d') or contains(@type,'FMatrix4d') or
										contains(@type,'MFTime')    or contains(@type,'MFDouble')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Provide double array for this field type.
	 * @return Array of doubles in this field array.
	 */
	public double[] toDoubleArray()
	{
		return ]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[;
	}
]]></xsl:text>
						</xsl:when>
					</xsl:choose>

					<!-- common field accessor: setValue using another field of same type -->
					<xsl:text><![CDATA[
	/**
	 * Apply an ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[ value to this field.
	 * @param newValue The newValue to apply
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> setValue(</xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> newValue)
	{
		if (newValue == null)
		{
			</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return this;
		}
		</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = newValue.getPrimitiveValue();
		return this;
	}
]]></xsl:text>
					<!-- additional field utility classes -->
					<xsl:choose>
						<xsl:when test="($fieldName = 'SFNode')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to clear all contained children including nodes, statements and comments (if any).
	 * @return {@link SFNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public SFNode]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ clearChildren()
	{
		SFNode = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		return this;
	}
</xsl:text>
						</xsl:when>
						<xsl:when test="($fieldName = 'MFNode')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to clear all contained children including nodes, statements and comments (if any).
	 * @return {@link MFNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public MFNode]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ clearChildren()
	{
		MFNode = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		return this;
	}
</xsl:text>
						</xsl:when>
						<xsl:when test="contains($fieldName,'SFVec')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Multiply scaleFactor times all values in this field type.
	 * @param scaleFactor scalar value for vector multiplication
	 * @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> multiply(</xsl:text>
					 <xsl:value-of select="$javaPrimitiveType"/>
					 <xsl:text> scaleFactor)
	{
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] *= scaleFactor;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] *= scaleFactor;
		</xsl:text>
		<xsl:choose>
			<xsl:when test="contains($fieldName,'3')">
				<xsl:value-of select="$fieldName"/><xsl:text>[2] *= scaleFactor;
		</xsl:text>
			</xsl:when>
			<xsl:when test="contains($fieldName,'4')">
				<xsl:value-of select="$fieldName"/><xsl:text>[2] *= scaleFactor;
		</xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text>[3] *= scaleFactor;
		</xsl:text>
			</xsl:when>
		</xsl:choose>
		<xsl:text>
		return this;
	}
</xsl:text>
						<!-- TODO also write type-specific addOffset methods -->
						</xsl:when>
						<xsl:when test="contains($fieldName,'MFVec') or contains($fieldName,'Matrix') or
										($fieldName = 'MFInt32') or ($fieldName = 'MFFloat') or ($fieldName = 'MFDouble')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Multiply scaleFactor times all values in this field type.
	 * @param scaleFactor scalar value for vector multiplication
	 * @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> multiply(</xsl:text>
					 <xsl:choose>
						 <xsl:when test="contains($javaPrimitiveType,'[]')">
							<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
						 </xsl:when>
						 <xsl:otherwise>
							<xsl:value-of select="$javaPrimitiveType"/>
						 </xsl:otherwise>
					 </xsl:choose>
					 <xsl:text disable-output-escaping="yes"><![CDATA[ scaleFactor)
	{
		for (int i = 0; i < ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>.length; i++)
		{
			</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>[i] *= scaleFactor;
		}
		return this;
	}
</xsl:text>
						<!-- TODO also write type-specific addOffset methods -->
						</xsl:when>
					</xsl:choose>
					<xsl:text>
	/**
	 * Determine whether current value matches DEFAULT_VALUE
	 * @see #DEFAULT_VALUE
	 * @return whether current value matches DEFAULT_VALUE
	 */
    public boolean isDefaultValue()
    {
        return </xsl:text>
            <xsl:choose>
                <xsl:when test="starts-with($fieldName, 'MF')    or contains($fieldName, 'Vec')   or contains($fieldName, 'Matrix') or
                                   contains($fieldName, 'Color') or contains($fieldName, 'Image') or contains($fieldName, 'Rotation')">
                    <xsl:text>java.util.Arrays.equals(</xsl:text>
                    <xsl:value-of select="$fieldName"/>
                    <xsl:text>, DEFAULT_VALUE);</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>(</xsl:text>
                    <xsl:value-of select="$fieldName"/>
                    <xsl:text> == DEFAULT_VALUE);</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
			<xsl:text>
    }
</xsl:text>

					<!-- class implementation definitions are complete -->
				</xsl:with-param>
			</xsl:call-template>

		</xsl:for-each>

			<!-- concrete implementation customization classes -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:text>X3DConcreteField</xsl:text></xsl:with-param>
				<xsl:with-param name="imports">
					<xsl:text>import java.util.ArrayList;
import org.web3d.x3d.sai.X3DFieldEventListener;
import org.web3d.x3d.jsail.Core.*;</xsl:text>
				</xsl:with-param>
				<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text><!-- TODO X3DConcreteElement --></xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.X3DField</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
				<xsl:with-param name="description">
					<xsl:text>Concrete implementation class corresponding to X3DField.</xsl:text>
				</xsl:with-param>
				<!-- TODO update -->
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock">
					<xsl:value-of select="InterfaceDefinition/@appinfo"/>
				</xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[
	// ==== Member value declarations are encapsulated and private, using preferred Java types for concretes library ====

	private boolean readable = true;

	private boolean writable = true;

	private ArrayList<org.web3d.x3d.sai.X3DFieldEventListener> eventListenerList = new ArrayList<>();

	/** Results log of local validation. */
	protected static StringBuilder validationResult = new StringBuilder();

	/** Get output of results from prior validation, if any
	 * @return validation results (if any)
	 */
	public String getValidationResult()
	{
		return validationResult.toString();
	}
	/** WARNING not implemented
         * @return null
	 */
	public X3DConcreteFieldDefinition getDefinition()
	{
		return null; // TODO
	}

	/** Check whether field is readable, default /true/
	 * @see org.web3d.x3d.jsail.Core.field#getAccessType()
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
         * @return whether field is readable
	 */
	/* @Override */
	public boolean isReadable()
	{
		return readable;
	}

	/** Set whether field is readable
	 * @param newValue new status for readable
	 * @see org.web3d.x3d.jsail.Core.field#getAccessType()
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
	 */
	public void setReadable(boolean newValue)
	{
		readable = newValue;
	}

	/** Check whether field is writable, default /true/
	 * @see org.web3d.x3d.jsail.Core.field#getAccessType()
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
	 * @return whether field is writable
	 */
	/* @Override */
	public boolean isWritable()
	{
		return writable;
	}

	/** Set whether field is writable
	 * @param newValue new status for writable
	 * @see org.web3d.x3d.jsail.Core.field#getAccessType()
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
	 */
	public void setWritable(boolean newValue)
	{
		writable = newValue;
	}

	/** WARNING not tested
         * @param newListener the listener to add */
	/* @Override */
	public void addX3DEventListener(X3DFieldEventListener newListener)
	{
		eventListenerList.add(newListener);
	}

	/** WARNING not tested
         * @param oldListener the listener to remove */
	/* @Override */
	public void removeX3DEventListener(X3DFieldEventListener oldListener)
	{
		eventListenerList.remove(oldListener);
	}

	/**
	 * Compute tuple size for given type (for example, SFVec3f and MFVec3f have tupleSize of 3).
	 * @param fieldType of interest
	 * @return tuple size
	 */
	public static int getTupleSize(String fieldType)
	{
		if      (fieldType.equals(field.TYPE_SFBOOL)   || fieldType.equals(field.TYPE_MFBOOL)   ||
			     fieldType.equals(field.TYPE_SFINT32)  || fieldType.equals(field.TYPE_MFINT32)  ||
			     fieldType.equals(field.TYPE_SFFLOAT)  || fieldType.equals(field.TYPE_MFFLOAT)  ||
			     fieldType.equals(field.TYPE_SFDOUBLE) || fieldType.equals(field.TYPE_MFDOUBLE) ||
			     fieldType.equals(field.TYPE_SFSTRING) || fieldType.equals(field.TYPE_MFSTRING) ||
			     fieldType.equals(field.TYPE_SFTIME)   || fieldType.equals(field.TYPE_MFTIME)   ||
			     fieldType.equals(field.TYPE_SFIMAGE)  || fieldType.equals(field.TYPE_MFIMAGE)  ||
			     fieldType.equals(field.TYPE_SFNODE)   || fieldType.equals(field.TYPE_MFNODE))
		{
			return 1;
		}
		else if (fieldType.equals(field.TYPE_SFVEC2F)  || fieldType.equals(field.TYPE_MFVEC2F)   ||
			     fieldType.equals(field.TYPE_SFVEC2D)  || fieldType.equals(field.TYPE_MFVEC2D))
		{
			return 2;
		}
		else if (fieldType.equals(field.TYPE_SFCOLOR)  || fieldType.equals(field.TYPE_MFCOLOR)     ||
			     fieldType.equals(field.TYPE_SFVEC3F)  || fieldType.equals(field.TYPE_MFVEC3F)   ||
			     fieldType.equals(field.TYPE_SFVEC3D)  || fieldType.equals(field.TYPE_MFVEC3D))
		{
			return 3;
		}
		else if (fieldType.equals(field.TYPE_SFCOLORRGBA) || fieldType.equals(field.TYPE_MFCOLORRGBA) ||
			     fieldType.equals(field.TYPE_SFROTATION)  || fieldType.equals(field.TYPE_MFROTATION)  ||
			     fieldType.equals(field.TYPE_SFVEC4F)     || fieldType.equals(field.TYPE_MFVEC4F)   ||
			     fieldType.equals(field.TYPE_SFVEC4D)     || fieldType.equals(field.TYPE_MFVEC4D))
		{
			return 4;
		}
		else if (fieldType.equals(field.TYPE_SFMATRIX3F)  || fieldType.equals(field.TYPE_MFMATRIX3F) ||
			     fieldType.equals(field.TYPE_SFMATRIX3D)  || fieldType.equals(field.TYPE_MFMATRIX3D))
		{
			return 9;
		}
		else if (fieldType.equals(field.TYPE_SFMATRIX4F)  || fieldType.equals(field.TYPE_MFMATRIX4F) ||
			     fieldType.equals(field.TYPE_SFMATRIX4D)  || fieldType.equals(field.TYPE_MFMATRIX4D))
		{
			return 16;
		}
		else
		{
			String errorNotice = "*** Invalid fieldType provided for getTupleSize(" + fieldType + ")";
			throw new InvalidFieldValueException(errorNotice);
		}
	}

	/* Validation is handled by concrete subclasses
         * TODO is this commented-out funcion block needed ?
	@Override
	public String validate()
	{
		return ""; // TODO
	}
	*/

	/** Initialization sets default initial value.
	 */
	abstract public void initialize(); // must be overridden

	/** Provides Class corresponding to getValue() results.
	 * @return reflection Class for this field's values
	abstract public Class getReflectionClass(); // must be overridden
	 */
]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>

		<!-- ===================================================== -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:text>X3DConcreteFieldDefinition</xsl:text></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.X3DFieldDefinition</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
				<xsl:with-param name="description">
					<xsl:text>Concrete implementation class corresponding to X3DField.</xsl:text>
				</xsl:with-param>
				<!-- TODO update -->
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock">
					<xsl:text><![CDATA[
 * <p>
 * Representation of a node's field definition.
 * </p>
 * <p>
 * The field definition holds static field information such as the field
 * access type, data type and name of the field.
 * </p>
 * <p>
 * The implementation of the toString() method of this class shall return the
 * full IDL declaration of the field as per the specification, not the UTF8 or
 * XML format. Implementation of <code>.equals()</code> shall return true if
 * the two field definitions share the same access type, data type and name. It
 * shall not include the underlying field's values at that point in time.
 * </p>
 *
 * @author Justin Couch
]]></xsl:text>
					<xsl:value-of select="InterfaceDefinition/@appinfo"/>
				</xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[
	// Member value declarations are encapsulated and private, using preferred Java types for concretes library

	private String    name = "";

	private int accessType = org.web3d.x3d.sai.X3DFieldTypes.INPUT_OUTPUT;

	private int  fieldType = org.web3d.x3d.sai.X3DFieldTypes.SFSTRING;

    /**
     * Get the name of this field. This will be something like "children"
     * or "translation". If the field is an exposed field then the name
     * give will be the base name without any <i>set_</i> or <i>_changed</i>
     * added to the name, regardless of how the initial field was fetched.
     *
     * @return The name of this field
     */
	/* @Override */
	public String getName()
	{
		return name;
	}
    /** set new name for this field
     * @param newValue is replacement value array to assign
     */
	public void setName(String newValue)
	{
		if (name.contains(" ")) // TODO other validity checks for name
		name = newValue;
	}

    /**
     * Get the access type of the field. This will be one of field,
     * exposedField, eventIn or eventOut constants described in the
     * X3DFieldTypes interface.
     *
     * @see org.web3d.x3d.sai.X3DFieldTypes
     * @return The access type of this field
     */
	/* @Override */
	public int getAccessType()
	{
		return accessType;
	}
    /**
     * Set the access type of the field. This will be one of field,
     * exposedField, eventIn or eventOut constants described in the
     * X3DFieldTypes interface.
     *
     * @see org.web3d.x3d.sai.X3DFieldTypes
     * @throws InvalidFieldValueException Illegal value provided, no change made
     * @param newValue The access type of this field
     */
	public void setAccessType(int newValue)
	{
		if ((newValue >= org.web3d.x3d.sai.X3DFieldTypes.INPUT_ONLY) && (newValue <= org.web3d.x3d.sai.X3DFieldTypes.OUTPUT_ONLY))
			accessType = newValue;
		else
		{
			String errorNotice = "*** Illegal value " + newValue + " for field type";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}

    /**
     * Get the field type. This string represents the field type such as
     * MFNode, SFInt32. The definition of the returned int value is
     * described in the X3DFieldType interface.
     *
     * @return A constant describing the field type
     * @see org.web3d.x3d.sai.X3DFieldTypes
     */
	/* @Override */
	public int getFieldType()
	{
		return fieldType;
	}

    /**
     * Set the field type of the field. This will be one of SFBool,
     * SFInt32, MFString (etc.) constants described in the
     * X3DFieldTypes interface.
     *
     * @see org.web3d.x3d.sai.X3DFieldTypes
     * @throws InvalidFieldValueException Illegal value provided, no change made
     * @param newValue The access type of this field
     */
	public void setFieldType(int newValue)
	{
		if ((newValue >= org.web3d.x3d.sai.X3DFieldTypes.SFBOOL) && (newValue <= org.web3d.x3d.sai.X3DFieldTypes.MFMATRIX4D))
			fieldType = newValue;
		else
		{
			String errorNotice = "*** Illegal value " + newValue + " for field type";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}

    /**
     * Get the field type. This string represents the field type such as
     * MFNode, SFInt32, etc. A string is used to allow full extensibility.
     *
     * @return A string describing the field type
     */
	/* @Override */
	public String getFieldTypeString()
	{
		return X3DConcreteFieldTypes.toFieldString(fieldType);
	}
]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>

		<!-- ===================================================== -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:text>X3DConcreteFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text>import org.web3d.x3d.jsail.ConfigurationProperties;</xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:text>Methods for constants corresponding to each X3D field type and accessType.</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>5.3 Field types</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>fieldsDef.html#FieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[
		/**
		 * Convert accessType value to string
		 * @param accessType the accessType enumeration value to convert
		 * @return string name for accessType value */
		public static String toAccessTypeString (int accessType)
		{
			switch (accessType)
			{
				case INPUT_ONLY:
					return "inputOnly";
				case INITIALIZE_ONLY:
					return "initializeOnly";
				case INPUT_OUTPUT:
					return "inputOutput";
				case OUTPUT_ONLY:
					return "outputOnly";
				default:
					String message = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +" "  + accessType;
					System.out.println ("org.web3d.x3d.sai.X3DFieldTypes.toString(" + accessType + ") " + message);
					return message; // TODO throw exception?
			}
		}
		/**
		 * Convert fieldType value to string
		 * @param fieldType the fieldType enumeration value to convert
		 * @return string name for fieldType value */
		public static String toFieldString (int fieldType)
		{
			switch (fieldType)
			{
				case SFBOOL:
					return "SFBool";
				case MFBOOL:
					return "MFBool";
				case SFINT32:
					return "SFInt32";
				case MFINT32:
					return "MFInt32";
				case SFFLOAT:
					return "SFFloat";
				case MFFLOAT:
					return "MFFloat";
				case SFDOUBLE:
					return "SFDouble";
				case MFDOUBLE:
					return "MFDouble";
				case SFTIME:
					return "SFTime";
				case MFTIME:
					return "MFTime";
				case SFNODE:
					return "SFNode";
				case MFNODE:
					return "MFNode";
				case SFVEC2F:
					return "SFVec2f";
				case MFVEC2F:
					return "MFVec2f";
				case SFVEC3F:
					return "SFVec3f";
				case MFVEC3F:
					return "MFVec3f";
				case SFVEC3D:
					return "SFVec3d";
				case MFVEC3D:
					return "MFVec3d";
				case SFROTATION:
					return "SFRotation";
				case MFROTATION:
					return "MFRotation";
				case SFCOLOR:
					return "SFColor";
				case MFCOLOR:
					return "MFColor";
				case SFCOLORRGBA:
					return "SFColorRGBA";
				case MFCOLORRGBA:
					return "MFColorRGBA";
				case SFIMAGE:
					return "SFImage";
				case MFIMAGE:
					return "MFImage";
				case SFSTRING:
					return "SFString";
				case MFSTRING:
					return "MFString";

				// added in v3.3
				case SFVEC2D:
					return "SFVec2d";
				case MFVEC2D:
					return "MFVec2d";
				case SFVEC4F:
					return "SFVec4f";
				case MFVEC4F:
					return "MFVec4f";
				case SFVEC4D:
					return "SFVec4d";
				case MFVEC4D:
					return "MFVec4d";
				case SFMATRIX3D:
					return "SFMatrix3d";
				case MFMATRIX3D:
					return "MFMatrix3d";
				case SFMATRIX3F:
					return "SFMatrix3f";
				case MFMATRIX3F:
					return "MFMatrix3f";
				case SFMATRIX4D:
					return "SFMatrix4d";
				case MFMATRIX4D:
					return "MFMatrix4d";
				case SFMATRIX4F:
					return "SFMatrix4f";
				case MFMATRIX4F:
					return "MFMatrix4f";
				default:
					String message = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +" "  + fieldType;
					System.out.println ("org.web3d.x3d.sai.X3DFieldTypes.toString(" + fieldType + ") " + message);
					return message; // TODO throw exception?
			}
		}
	]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>

    </xsl:template> <!-- FieldDefinitions -->

    <!-- ===================================================== -->

	<xsl:template name="BaseTypeDefinitions">

		<xsl:variable name="subPackage">
			<xsl:if test="($modifySpecificationInterfaces = 'true')">
				<xsl:text>fields</xsl:text>
			</xsl:if>
		</xsl:variable>

		<!-- B.4 Field interfaces -->
		<!-- https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/abstracts.html#FieldInterfaces -->
		<!-- TODO specificaton table bookmark link is incorrect -->
		<!-- Implemented in X3D Unified Object Model (X3DUOM) -->

		<!-- TODO get enumeration values and create final int constant values -->

		<xsl:for-each select="//FieldTypes/FieldType">

			<xsl:variable name="name"                                select="@type"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>

			<xsl:variable name="tupleSize">
				<xsl:call-template name="tupleSize">
					<xsl:with-param name="x3dType" select="@type"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="extends">
				<!-- must have one; also note that each interface can be extended by another interface -->
				<xsl:choose>
					<xsl:when test="($name = 'bboxSizeType')">
						<xsl:text>SFVec3f</xsl:text>
					</xsl:when>
					<xsl:when test="contains($name,'Matrix3')">
						<xsl:text>Matrix3</xsl:text>
					</xsl:when>
					<xsl:when test="contains($name,'Matrix4')">
						<xsl:text>Matrix4</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($name,'SF')">
						<xsl:text>X3DField</xsl:text>
					</xsl:when>
					<xsl:otherwise> <!-- MF -->
						<xsl:text>MField</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>

			<xsl:variable name="imports">
				<xsl:choose>
					<xsl:when test="($name = 'MFImage')">
						<xsl:text>
import java.awt.image.RenderedImage;
import java.awt.image.WritableRenderedImage;</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode') or ($name = 'MFNode')">
						<xsl:text>
import org.web3d.x3d.sai.Core.X3DNode;</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>

			<!-- TODO turn into template for reuse -->
			<xsl:variable name="saiJavaSpecificationSection">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool')">
						<xsl:text>B.4.7</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFBool')">
						<xsl:text>B.4.8</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColor')">
						<xsl:text>B.4.9</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColor')">
						<xsl:text>B.4.10</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColorRGBA')">
						<xsl:text>B.4.11</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColorRGBA')">
						<xsl:text>B.4.12</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFDouble')">
						<xsl:text>B.4.13</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFDouble')">
						<xsl:text>B.4.14</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFFloat')">
						<xsl:text>B.4.15</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFFloat')">
						<xsl:text>B.4.16</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFImage')">
						<xsl:text>B.4.17</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFImage')">
						<xsl:text>B.4.18</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFInt32')">
						<xsl:text>B.4.19</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFInt32')">
						<xsl:text>B.4.20</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3d')">
						<xsl:text>B.4.21</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix3d')">
						<xsl:text>B.4.22</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3f')">
						<xsl:text>B.4.23</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix3f')">
						<xsl:text>B.4.24</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4d')">
						<xsl:text>B.4.25</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix4d')">
						<xsl:text>B.4.26</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4f')">
						<xsl:text>B.4.27</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix4f')">
						<xsl:text>B.4.28</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode')">
						<xsl:text>B.4.29</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFNode')">
						<xsl:text>B.4.30</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFRotation')">
						<xsl:text>B.4.31</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFRotation')">
						<xsl:text>B.4.32</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString')">
						<xsl:text>B.4.33</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFString')">
						<xsl:text>B.4.34</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFTime')">
						<xsl:text>B.4.35</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFTime')">
						<xsl:text>B.4.36</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2d')">
						<xsl:text>B.4.37</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2d')">
						<xsl:text>B.4.38</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2f')">
						<xsl:text>B.4.39</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2f')">
						<xsl:text>B.4.40</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec3d')">
						<xsl:text>B.4.41</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec3d')">
						<xsl:text>B.4.42</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec3f') or ($name = 'bboxSizeType')">
						<xsl:text>B.4.43</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec3f')">
						<xsl:text>B.4.44</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec4d')">
						<xsl:text>B.4.45</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec4d')">
						<xsl:text>B.4.46</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec4f')">
						<xsl:text>B.4.47</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec4f')">
						<xsl:text>B.4.48</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>

			<!-- TODO turn into template for reuse -->
			<xsl:variable name="saiAbstractSpecificationSection">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool') or ($name = 'MFBool')">
						<xsl:text>5.2.2 SAIBoolean</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString') or ($name = 'MFString')">
						<xsl:text>SAIString</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode') or ($name = 'MFNode')">
						<xsl:text>5.2.22 SAINode</xsl:text>
					</xsl:when>
					<xsl:when test="contains($name, 'Matrix')">
						<xsl:text>5.2.20 SAIMatrix</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>5.2.15 SAIFieldType</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>

			<!-- TODO turn into template for reuse -->
			<xsl:variable name="saiAbstractSpecificationRelativeUrl">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool') or ($name = 'MFBool')">
						<xsl:text>dataRef.html#SAIBoolean</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString') or ($name = 'MFString')">
						<xsl:text>dataRef.html#SAIString</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode') or ($name = 'MFNode')">
						<xsl:text>dataRef.html#SAINode</xsl:text>
					</xsl:when>
					<xsl:when test="contains($name, 'Matrix')">
						<xsl:text>dataRef.html#SAIMatrix</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>dataRef.html#SAIFieldType</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>

			<!-- TODO turn into template for reuse -->
			<xsl:variable name="x3dAbstractSpecificationSection">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool')">
						<xsl:text>5.3.1 SFBool and MFBool</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFBool')">
						<xsl:text>5.3.1 SFBool and MFBool</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColor')">
						<xsl:text>5.3.2 SFColor and MFColor</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColor')">
						<xsl:text>5.3.2 SFColor and MFColor</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColorRGBA')">
						<xsl:text>5.3.3 SFColorRGBA and MFColorRGBA</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColorRGBA')">
						<xsl:text>5.3.3 SFColorRGBA and MFColorRGBA</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFDouble')">
						<xsl:text>5.3.4 SFDouble and MFDouble</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFDouble')">
						<xsl:text>5.3.4 SFDouble and MFDouble</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFFloat')">
						<xsl:text>5.3.5 SFFloat and MFFloat</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFFloat')">
						<xsl:text>5.3.5 SFFloat and MFFloat</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFImage')">
						<xsl:text>5.3.6 SFImage and MFImage</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFImage')">
						<xsl:text>5.3.6 SFImage and MFImage</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFInt32')">
						<xsl:text>5.3.7 SFInt32 and MFInt32</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFInt32')">
						<xsl:text>5.3.7 SFInt32 and MFInt32</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3d')">
						<xsl:text>5.3.8 SFMatrix3d and MFMatrix3d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix3d')">
						<xsl:text>5.3.8 SFMatrix3d and MFMatrix3d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3f')">
						<xsl:text>5.3.9 SFMatrix3f and MFMatrix3f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix3f')">
						<xsl:text>5.3.9 SFMatrix3f and MFMatrix3f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4d')">
						<xsl:text>5.3.10 SFMatrix4d and MFMatrix4d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix4d')">
						<xsl:text>5.3.10 SFMatrix4d and MFMatrix4d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4f')">
						<xsl:text>5.3.11 SFMatrix4f and MFMatrix4f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix4f')">
						<xsl:text>5.3.11 SFMatrix4f and MFMatrix4f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode')">
						<xsl:text>5.3.12 SFNode and MFNode</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFNode')">
						<xsl:text>5.3.12 SFNode and MFNode</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFRotation')">
						<xsl:text>5.3.13 SFRotation and MFRotation</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFRotation')">
						<xsl:text>5.3.13 SFRotation and MFRotation</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString')">
						<xsl:text>5.3.14 SFString and MFString</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFString')">
						<xsl:text>5.3.14 SFString and MFString</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFTime')">
						<xsl:text>5.3.15 SFTime and MFTime</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFTime')">
						<xsl:text>5.3.15 SFTime and MFTime</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2d')">
						<xsl:text>5.3.16 SFVec2d and MFVec2d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2d')">
						<xsl:text>5.3.16 SFVec2d and MFVec2d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2f')">
						<xsl:text>5.3.17 SFVec2f and MFVec2f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2f')">
						<xsl:text>5.3.17 SFVec2f and MFVec2f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec3d')">
						<xsl:text>5.3.18 SFVec3d and MFVec3d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec3d')">
						<xsl:text>5.3.18 SFVec3d and MFVec3d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec3f') or ($name = 'bboxSizeType')">
						<xsl:text>5.3.19 SFVec3f and MFVec3f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec3f')">
						<xsl:text>5.3.19 SFVec3f and MFVec3f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec4d')">
						<xsl:text>5.3.20 SFVec4d and MFVec4d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec4d')">
						<xsl:text>5.3.20 SFVec4d and MFVec4d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec4f')">
						<xsl:text>5.3.21 SFVec4f and MFVec4f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec4f')">
						<xsl:text>5.3.21 SFVec4f and MFVec4f</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>

			<xsl:variable name="javadocBlock">
			</xsl:variable>
			<!-- debug
			<xsl:message>
				<xsl:text>*** //FieldTypes/FieldType name=</xsl:text>
				<xsl:value-of select="$name"/>
				<xsl:text>, $javadocBlock=</xsl:text>
				<xsl:value-of select="$javadocBlock"/>
			</xsl:message> -->

			<xsl:variable name="interfaceBlock">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool')">
						<xsl:text><![CDATA[
    /**
     *	Get the current value.
     * 	@return current value
     */
	public boolean getValue();

    /**
     * Assign a new value to this field.
     * @param newValue The newValue to assign
     */
	public void setValue(boolean newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFBool')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(boolean[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public boolean get1Value(int index);

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, boolean[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, boolean newValue) throws ArrayIndexOutOfBoundsException;

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(boolean newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, boolean newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColor')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param newValue the newValue to set
     */
	public void setValue(float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($name,'MFColor')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param numColors The number of 3-tuple RGB colors in the newValue array
     * @param newValue the newValue to set
     */
	public void setValue(int numColors, float[] newValue);

    /**
     * Assign a new value to this field.
     * @param numColors The number of 3-tuple RGB colors in the newValue array
     * @param newValue the newValue to set
     */
	public void setValue(int numColors, float[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float[] newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(float[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColorRGBA')">
						<xsl:text>
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param newValue the newValue to set
     */
	public void setValue(float[] newValue);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColorRGBA')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param numColors The number of 3-tuple RGB colors in the newValue array
     * @param newValue The new value to set
     */
	public void setValue(int numColors, float[] newValue);

    /**
     * Assign a new value to this field.
     * @param numColors The number of 3-tuple RGB colors in the newValue array
     * @param newValue The new value to set
     */
	public void setValue(int numColors, float[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float[] newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(float[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float[] newValue);
]]>
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFDouble')">
						<xsl:text>
    /**
     *	Get the current value.
     * 	@return current value
     */
	public double getValue();

    /**
     * Assign a new value to this field.
     * @param newValue The new value to set
     */
	public void setValue(double newValue);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFDouble')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public double get1Value(int index) throws ArrayIndexOutOfBoundsException;

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, double[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, double newValue) throws ArrayIndexOutOfBoundsException;

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(double newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, double newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFFloat')">
						<xsl:text><![CDATA[
    /**
     *	Get the current value.
     * 	@return current value
     */
	public float getValue();

    /**
     * Assign a new value to this field.
     * @param newValue The new value to set
     */
	public void setValue(float newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFFloat')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public float get1Value(int index) throws ArrayIndexOutOfBoundsException;

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, float[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float newValue) throws ArrayIndexOutOfBoundsException;

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(float newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFImage')">
						<xsl:text><![CDATA[
    /**
     * Get the width of the image.
     * @return The width of the image in pixels
     */
	public int getWidth();

    /**
     * Get the height of the image.
     * @return The height of the image in pixels
     */
	public int getHeight();

    /**
     * Get the number of color components in the image. The value will
     * always be between 0 and 4 indicating the number of components of
     * the color specification to be read from the image pixel data.
     * @return The number of components
     */
	public int getNumberComponents();

    /**
     * Get the image pixel value in the given eventOut.
     * <p>
     * The number of items in the pixels array will be
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     * @param pixels The array to copy pixel values into
     */
	public void getPixels(int[] pixels);

    /**
     * Fetch the Java representation of the underlying image from these pixels.
     * This is the same copy that the browser uses to generate texture
     * information from.
     * @return The image reference representing the current state
     */
	public java.awt.image.WritableRenderedImage getImage();

    /**
     * Set the image value in the given writable field to the new image defined
     * by a set of pixels.
     * <p>
     * @param image The new image to use as the source
     */
	public void setImage(java.awt.image.RenderedImage image);

    /**
	 * Copy a region of the argument RenderedImage to replace a portion of the
	 * current SFimage.
	 * <p>
	 * The sub image set shall not resize the base image representation and
	 * therefore performs an intersection clip of the provided image. The user
	 * provided image shall be of the same format (pixel depth, pixel
	 * representation) as the original image obtained through the getImage()
	 * method.
	 * <p>
	 * RenderedImages are row order from top to bottom. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 0 |********|
	 * 1 |********|
	 * 2 |********|
	 * 3 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * SFImages are row order from bottom to top. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 3 |********|
	 * 2 |********|
	 * 1 |********|
	 * 0 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * <p>
	 * Note: The parameter srcYOffset is referenced to the RenderedImage object
	 * (indexed top to bottom).
	 * <br>
	 * The parameter destYOffset is referenced to the SFImage object
	 * (indexed bottom to top).
	 *
	 * @param image The new image to use as the source
	 * @param sourceWidth The width of the argument sub-image region to copy
	 * @param sourceHeight The height of the argument sub-image region to copy
	 * @param sourceXOffset The initial x dimension (width) offset into the
	 * argument sub-image that begins the region to copy
	 * @param sourceYOffset The initial y dimension (height) offset into the
	 * argument sub-image that begins the region to copy
	 * @param destinationXOffset The initial x dimension (width) offset in the SFimage
	 * object that begins the region to receive the copy
	 * @param destinationYOffset The initial y dimension (height) offset in the SFimage
	 * object that begins the region to receive the copy
	 */
	public void setSubImage(java.awt.image.RenderedImage image,
                            int sourceWidth,
                            int sourceHeight,
                            int sourceXOffset,
                            int sourceYOffset,
                            int destinationXOffset,
                            int destinationYOffset);

    /**
     * Set the image value in the given writable field.
     * <p>
     * Image values are specified using a width, height and the number of
     * components. The number of items in the pixels array must be at least
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components. If the integer
     * contains values in bytes that are not used by the number of components
     * for that image, the values are ignored.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     *
     * @param width The width of the image in pixels
     * @param height The height of the image in pixels
     * @param components The number of color components [1-4]
     * @param pixels The array of pixel values as specified above.
     * @exception IllegalArgumentException The number of components or width/
     *    height are illegal values.
     * @exception ArrayIndexOutOfBoundsException The number of pixels provided by the
     *    caller is not enough for the width * height.
     */
	public void setValue(int width,
                         int height,
                         int components,
                         int[] pixels);

]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFImage')">
						<xsl:text><![CDATA[
    /**
     * Get the width of the image array.
     * @param imageIndex the index of the selected image
     * @return The width of the image in pixels
     */
	public int getWidth(int imageIndex);

    /**
     * Get the height of the image array.
     * @param imageIndex the index of the selected image
     * @return The height of the image in pixels
     */
	public int getHeight(int imageIndex);

    /**
     * Get the number of color components in the image. The value will
     * always be between 0 and 4 indicating the number of components of
     * the color specification to be read from the image pixel data.
     * @param imageIndex the index of the selected image
     * @return The number of components
     */
	public int getNumberComponents(int imageIndex);

    /**
     * Get the image pixel value in the given eventOut.
     * <p>
     * The number of items in the pixels array will be
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     * @param imageIndex the index of the selected image
     * @param pixels The array to copy pixel values into
     */
	public void getPixels(int imageIndex, int[] pixels);

    /**
     * Fetch the Java representation of the underlying image from these pixels.
     * This is the same copy that the browser uses to generate texture
     * information from.
     * @param imageIndex the index of the selected image
     * @return The image reference representing the current state
     */
	public WritableRenderedImage getImage(int imageIndex);

    /**
     * Set the image value in the given writable field to the new image defined
     * by a set of pixels.
     * @param imageIndex the index of the selected image
     * @param image The new image to use as the source
     */
	public void setImage(int imageIndex, RenderedImage image);

    /**
	 * Copy a region of the argument RenderedImage to replace a portion of the
	 * current SFimage.
	 * <p>
	 * The sub image set shall not resize the base image representation and
	 * therefore performs an intersection clip of the provided image. The user
	 * provided image shall be of the same format (pixel depth, pixel
	 * representation) as the original image obtained through the getImage()
	 * method.
	 * <p>
	 * RenderedImages are row order from top to bottom. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 0 |********|
	 * 1 |********|
	 * 2 |********|
	 * 3 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * SFImages are row order from bottom to top. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 3 |********|
	 * 2 |********|
	 * 1 |********|
	 * 0 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * <p>
	 * Note: The parameter srcYOffset is referenced to the RenderedImage object
	 * (indexed top to bottom).
	 * <br>
	 * The parameter destYOffset is referenced to the SFImage object
	 * (indexed bottom to top).
	 *
	 * @param imageIndex the index of the selected image
	 * @param image The new image to use as the source
	 * @param sourceWidth The width of the argument sub-image region to copy
	 * @param sourceHeight The height of the argument sub-image region to copy
	 * @param sourceXOffset The initial x dimension (width) offset into the
	 * argument sub-image that begins the region to copy
	 * @param sourceYOffset The initial y dimension (height) offset into the
	 * argument sub-image that begins the region to copy
	 * @param destinationXOffset The initial x dimension (width) offset in the SFimage
	 * object that begins the region to receive the copy
	 * @param destinationYOffset The initial y dimension (height) offset in the SFimage
	 * object that begins the region to receive the copy
	 */
	public void setSubImage(int imageIndex,
		RenderedImage image,
                            int sourceWidth,
                            int sourceHeight,
                            int sourceXOffset,
                            int sourceYOffset,
                            int destinationXOffset,
                            int destinationYOffset);

	/**
	 * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * @param imageIndex the index of the selected image
	 * @param newValue provides new value to apply
	 */
	public void set1Value(int imageIndex, int newValue);

	public void set1Value(int imageIndex,
                          int width,
                          int height,
                          int components,
                          int[] pixels);

	/**
	 * Assign a new value array containing imageIndex, width, height, and components count, followed by array of pixels.
	 * @param newValue the newValue to set
	 */
	public void setValue(int[] newValue);

	public void setImage(RenderedImage[] image);

	/**
	 * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * @param newValue The newValue to append
	 */
	public void append(RenderedImage[] newValue);

	/**
	 * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
	 * @param index The position for the inserted value in the current array
	 * @param newValue The newValue to insert
	 */
	public void insertValue(int index, RenderedImage newValue);
]]></xsl:text>
<!-- TODO specification missing closing } -->
					</xsl:when>
					<xsl:when test="($name = 'SFInt32')">
						<xsl:text><![CDATA[
	/**
	 *	Get the current value.
	 * 	@return current value
	 */
	public int getValue();

	/**
	 * Assign a new value to this field.
	 * @param newValue The new value to set
	 */
	public void setValue(int newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFInt32')">
						<xsl:text><![CDATA[
	/**
	 * Write out the current value of this field into the external valueDestination array.
	 *
	 * @param valueDestination The array to be filled in with current field values.
	 * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
	 */
	public void getValue(int[] valueDestination);

	/**
	 * <p>
	 * Get an individual value from the existing field array.
	 * </p><p>
	 * If the index is outside the bounds of the current array of data values,
	 * an ArrayIndexOutOfBoundsException is thrown.
	 * </p>
	 * @param index is position of selected value in current array
	 * @return The selected value
	 * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
	 */
	public int get1Value(int index) throws ArrayIndexOutOfBoundsException;

	/**
	 * Assign an array subset to this field.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
	 * @param newValue The replacement value array to (potentially) slice and then assign.
	 */
	public void setValue(int size, int[] newValue);

	/**
	 * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * @param imageIndex the index of the selected image
	 * @param newValue provides new value to apply
	 */
	public void set1Value(int imageIndex, int newValue) throws ArrayIndexOutOfBoundsException;

	/**
	 * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * @param newValue The newValue to append
	 */
	public void append(int newValue);

	/**
	 * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
	 * @param index The position for the inserted value in the current array
	 * @param newValue The newValue to insert
	 */
	public void insertValue(int index, int newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3d') or ($name = 'MFMatrix3d')">
						<xsl:text>
	public void setTransform(org.web3d.x3d.sai.SFVec3d translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3d scale,
		org.web3d.x3d.sai.SFRotation scaleOrientation,
		org.web3d.x3d.sai.SFVec3d center);

	public void getTransform(org.web3d.x3d.sai.SFVec3d translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3d scale);

	public org.web3d.x3d.sai.Matrix3 multiplyRowVector(org.web3d.x3d.sai.SFVec3d vec3d);

	public org.web3d.x3d.sai.Matrix3 multiplyColVector(org.web3d.x3d.sai.SFVec3d vec3d);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3f') or ($name = 'MFMatrix3f')">
						<xsl:text>
	public void setTransform(org.web3d.x3d.sai.SFVec3f translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3f scale,
		org.web3d.x3d.sai.SFRotation scaleOrientation,
		org.web3d.x3d.sai.SFVec3f center);

	public void getTransform(org.web3d.x3d.sai.SFVec3f translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3f scale);

	public org.web3d.x3d.sai.Matrix3 multiplyRowVector(org.web3d.x3d.sai.SFVec3f vec3f);

	public org.web3d.x3d.sai.Matrix3 multiplyColVector(org.web3d.x3d.sai.SFVec3f vec3f);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4d') or ($name = 'MFMatrix4d')">
						<xsl:text>
	public void setTransform(org.web3d.x3d.sai.SFVec3d translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3d scale,
		org.web3d.x3d.sai.SFRotation scaleOrientation,
		org.web3d.x3d.sai.SFVec3d center);

	public void getTransform(SFVec3d translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3d scale);

	public org.web3d.x3d.sai.Matrix4 multiplyRowVector(org.web3d.x3d.sai.SFVec3d vec3d);

	public org.web3d.x3d.sai.Matrix4 multiplyColVector(org.web3d.x3d.sai.SFVec3d vec3d);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4f') or ($name = 'MFMatrix4f')">
						<xsl:text>
	public void setTransform(org.web3d.x3d.sai.SFVec3f translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3f scale,
		org.web3d.x3d.sai.SFRotation scaleOrientation,
		org.web3d.x3d.sai.SFVec3f center);

	public void getTransform(org.web3d.x3d.sai.SFVec3f translation,
		org.web3d.x3d.sai.SFRotation rotation,
		org.web3d.x3d.sai.SFVec3f scale);

	public org.web3d.x3d.sai.Matrix4 multiplyRowVector(org.web3d.x3d.sai.SFVec3f vec3f);

	public org.web3d.x3d.sai.Matrix4 multiplyColVector(org.web3d.x3d.sai.SFVec3f vec3f);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode')">
						<xsl:text><![CDATA[
	/**
	 *	Get the current value.
	 * 	@return current value
	 */
	public org.web3d.x3d.sai.Core.X3DNode getValue();

	/**
	 * Assign a new value to this field.
	 * @param newValue The new value to set
	 */
	public void setValue(org.web3d.x3d.sai.Core.X3DNode newValue) throws InvalidNodeException;
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFNode')">
						<xsl:text><![CDATA[
	/**
	 * Write the current value of the field out to the provided copiedNodes array.
	 *
	 * @param copiedNodes The array to be filled in with current field values.
	 * @throws ArrayIndexOutOfBoundsException The provided copiedNodes array was too small
	 */
	public void getValue(org.web3d.x3d.sai.Core.X3DNode[] copiedNodes);

	/**
	 * <p>
	 * Get an individual value from the existing field array.
	 * </p>
	 * <p>
	 * If the index is outside the bounds of the current array of data values,
	 * an ArrayIndexOutOfBoundsException is thrown.
	 * </p>
	 * @param index is position of selected value in current array
	 * @return The selected value
	 * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
	 */
	public org.web3d.x3d.sai.Core.X3DNode get1Value(int index);

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, org.web3d.x3d.sai.Core.X3DNode[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param imageIndex the index of the selected image
     * @param newValue provides new value to apply
     */
	public void set1Value(int imageIndex, org.web3d.x3d.sai.Core.X3DNode newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(org.web3d.x3d.sai.Core.X3DNode newValue);

    /**
     * Insert a new value prior to the imageIndex location in the existing value array, increasing the field length accordingly.
     * @param imageIndex the index of the selected image
     * @param newValue The newValue to insert
     */
	public void insertValue(int imageIndex, org.web3d.x3d.sai.Core.X3DNode newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFRotation')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */
	public void setValue(float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFRotation')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param numRotations The number of 4-tuple rotations in the newValue array
     * @param newValue The newValue array of 4-tuple rotations to set
     */
	public void setValue(int numRotations, float[] newValue);

    /**
     * Assign a new value to this field.
     * @param numRotations The number of 4-tuple rotations in the newValue array
     * @param newValue The newValue square array of 4-tuple rotations to set
     */
	public void setValue(int numRotations, float[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float[] newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(float[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString')">
						<xsl:text><![CDATA[
    /**
     *	Get the current value.
     * 	@return current value
     */
	public String getValue();

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */
	public void setValue(String newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFString')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(String[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public String get1Value(int index);

    /**
     * Assign a new value to this field.
     * @param numStrings The number of strings in the newValue array
     * @param newValue The newValue array of strings to set
     */
	public void setValue(int numStrings, String[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, String newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(String newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, String newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFTime')">
						<xsl:text><![CDATA[
    /**
     *	Get the current value.
     * 	@return current value
     */
	public double getValue();

    /**
     *	Get the current value as a long.
     * 	@return current value
     */
	public long getJavaValue();

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */
	public void setValue(double newValue);

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */
	public void setValue(long newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFTime')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
	 * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public double get1Value(int index);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
	 * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public long get1JavaValue(int index);

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, double[] newValue);

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, long[] newValue);

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */
	public void setValue(long[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, double newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, long newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(double newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(long newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, long newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, double newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2d') or ($name = 'SFVec3d') or ($name = 'SFVec4d')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */
	public void setValue(double[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2d') or ($name = 'MFVec3d') or ($name = 'MFVec4d')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, double[] valueDestination);

    /**
     * Assign an array subset to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, double[] newValue);

    /**
     * Assign an array subset to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, double[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, double[] newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(double[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, double[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2f') or ($name = 'SFVec3f') or ($name = 'SFVec4f')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * Assign a new value to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue is replacement value array to assign
     */
	public void setValue(float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2f') or ($name = 'MFVec3f') or ($name = 'MFVec4f')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, float[] valueDestination);

    /**
     * Assign an array subset to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, float[] newValue);

    /**
     * Assign an array subset to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	public void setValue(int size, float[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float[] newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(float[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float[] newValue);
]]></xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>

			<!-- TODO javadoc url links -->

			<!-- B.4 Field interfaces -->
			<!-- https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/abstracts.html#FieldInterfaces -->

			<!-- abstract interfaces -->
			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:value-of select="$imports"/></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
				<!-- update specification prose to include full package -->
				<xsl:with-param name="extends"><xsl:value-of select="$extends"/></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:value-of select="$saiJavaSpecificationSection"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:value-of select="$saiAbstractSpecificationSection"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:value-of select="$saiAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="$x3dAbstractSpecificationSection"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock"><xsl:value-of select="$interfaceBlock"/></xsl:with-param>
			</xsl:call-template>

		</xsl:for-each>

    </xsl:template>

    <!-- ===================================================== -->

	<xsl:template name="ServiceInterfaces">

		<xsl:variable name="subPackage">
			<xsl:if test="($modifySpecificationInterfaces = 'true')">
				<xsl:text>services</xsl:text>
			</xsl:if>
		</xsl:variable>

		<!-- B.5 Service interfaces -->
		<!-- https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/abstracts.html#ServiceInterfaces -->
		<!-- TODO fix specification designations: some of these service definitions are interfaces, not classes -->

		<!-- Note:  BrowserEvent must be a class since it extends java.util.EventObject -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<!-- update specification prose to include full package -->
			<xsl:with-param name="extends"><xsl:text>java.util.EventObject</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Class representing events that happen in the Browser object.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.1 BrowserEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.4.1.2 SAI_Browser_Event</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIBrowserEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implementationBlock"><![CDATA[
    /**
     * The X3D player has completed initial loading of the world. Event is generated
     * just after the scene has been loaded and just before the first event has been sent.
     */
	public static final int INITIALIZED = 0;

    /**
     * The currently loaded world is about to be unloaded. Called just before
     * the scene is about to be unloaded. If another world is going to replace this,
     * then an initialize event will be generated following this one.
     */
	public static final int SHUTDOWN = 1;

    /**
     * An error occurred in loading a scene from a URL call. Origin can be either
     * a createVrmlFromURL call or loadURL.
     */
	public static final int URL_ERROR = 2;

    /**
     * An error has occurred that has caused the connection between the X3D player
     * and the external application to fail. Potential causes include X3D player
     * failure or a lost network connection.
     */
	public static final int CONNECTION_ERROR = 10;

    /**
     * The number of reserved identifier numbers for event conditions. Any
     * value below this is considered to be a general specification-defined event as
     * found in the Java Scene Authoring Interface (SAI) specification. Any values
     * above this value are browser-specific messages.
     */
	public static final int LAST_IDENTIFIER = 100;

    /** The identifier of the event that this class instance represents */
    private int id;

	/** Error message if incorrect Browser event value encountered.
	 * @see <a href="https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/abstracts.html#BrowserEvent">X3D Java SAI: B.5.1 BrowserEvent</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/concepts.html#Browser">X3D SAI: 4.4.6 Browser</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/concepts.html#Events">X3D SAI: 4.5 Events</a>
	 */
	public static final String ERROR_UNKNOWN_BROWSER_EVENT_VALUE = "ERROR_UNKNOWN_BROWSER_EVENT_VALUE"; // not defined in X3D Java SAI

	/**
     * Get the type of event that has occurred.
     *
     * @return The type of event as defined by the types
     * @see #INITIALIZED
     * @see #SHUTDOWN
     * @see #URL_ERROR
     * @see #CONNECTION_ERROR
     * @see #LAST_IDENTIFIER
     */
	public int getID()
    {
        return id;
	}

    /**
     * Create a new browser event.
     *
     * @param browser The source of the browser that generated this event
     * @param action The event type to create
     * @exception IllegalArgumentException if the action or browser id are not legal values
     */
	public BrowserEvent(Object browser, int action)
    {
        super(browser);

        if (browser == null)
		{
			String errorNotice = "*** Null browser reference";
//			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}

        if (action < 0)
		{
            String errorNotice = "*** Invalid event action type " + action;
//			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}

        id = action;
    }

    /**
     * Utility method providing the name of this event value.
     * @param value The BrowserEvent value of interest.
     * @return The name of this BrowserEvent value.
     */
	public String toString (int value)
	{
		switch (value)
		{
			case INITIALIZED:
				return "INITIALIZED";
			case SHUTDOWN:
				return "SHUTDOWN";
			case URL_ERROR:
				return "URL_ERROR";
			case CONNECTION_ERROR:
				return "CONNECTION_ERROR";
			case LAST_IDENTIFIER:
				return "LAST_IDENTIFIER";
			default:
				String message = BrowserEvent.ERROR_UNKNOWN_BROWSER_EVENT_VALUE + " " + value;
				System.out.println ("BrowserEvent.toString(" + value + ") " + message);
				return message; // TODO throw exception?
		}
	}
]]></xsl:with-param>
		</xsl:call-template>

		<!-- =========== -->

		<!-- TODO specification may need to define BrowserFactoryImpl X3DComponent and ExternalBrowser -->

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="imports">
import java.applet.Applet;
import java.io.InputStream;
import java.io.IOException;
// import java.lang.reflect;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Properties;
import java.util.Map;
</xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Factory class for obtaining references to browser instances.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
<p>
An implementation-independent representation of the class used to access
and create browsers. The model follows that used by java.net.Socket. A
setImpl method is provided for browser writers to provide the internal
implementations of the browser.
</p>
<p>
An alternative way of doing this is through properties. The class,
when it loads first looks for a System property with the key:
</p>
<ul>
<li><code>x3d.sai.factory.class</code></li>
</ul>
<p>
If a non-null value is found for this key, it is used as the name of
the class to load as the default browser implementation. If no matching
System property is found, the initializer looks for the file
<code>x3d.properties</code> in the class path.
(For more information on how this works read
<code>java.lang.ClassLoader.getSystemResourceAsStream()</code>). If found,
and the file contains a non-null value for the <code>x3d.sai.factory.class</code>
key, this value is used as the name of the class to load as the default browser
implementation.
</p>
<p>
In either case (System properties or x3d.properties file), this name must
represent the full package qualified name of the class.
If a System property with the required key does not exist, or an x3d.properties
file does not exist or the x3d.properties file does not contain a property with
the required key for the name of the factory class, then
the default class name <code>org.web3d.x3d.sai.DefaultBrowserImpl</code> is assigned.
</p>
<p>
The class is loaded when a call is made to <code>getBrowser()</code> or
<code>createX3DComponent()</code> using the following method:
</p>

 <pre>
 Class factory_class = Class.forName(factory_class_name);
 factory = (BrowserFactoryImpl)factory_class.newInstance();
 </pre>

<p>
If a class cast exception is raised at the end, then an error is printed
but nothing is done about it. The result would be NullPointerExceptions
later in the code. Also, this may cause some security errors in some
web browsers.
</p>
<p>
To provide a custom implementation of the factory (which all
implementations must do) the user has the choice of the above options
of either setting a System property, making sure that an x3d.properties
file appears in the classpath <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>before<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text> the sample implementation
that comes with the classes from the X3DC, or by calling setImpl. If
<code>setBrowserFactoryImpl</code> has not been called at the time that
any of the other methods have been, then the class will attempt to load
the implementation defined in the properties file. Attempting to call the
set implementation method after this point shall result in a X3DException
being generated. Otherwise, it shall use the set implementation.
</p>
@author Justin Couch</xsl:with-param>
			<xsl:with-param name="implementationBlock"><xsl:text><![CDATA[
    /** The name of the properties file to read things from */
    private static final String PROPERTIES_FILE_NAME = "x3d.properties";

    /** The name of all the properties that are used by this class */
    private static final String FACTORY_CLASS = "x3d.sai.factory.class";

    /** Properties file location that is Xj3D-specific */
    private static final String XJ3D_PROPERTIES_FILE =
        "config/3.0/spec/" + PROPERTIES_FILE_NAME;

    /** The default values of any properties */
    private static final String DEFAULT_FACTORY_CLASS =
        "org.web3d.x3d.sai.DefaultBrowserImpl";

    /** Null browser factory implementation error message */
    private static final String NULL_BROWSER_FACTORY_IMPL_ERR_MSG =
        "Provided factory is null";

    /** Factory has already been defined error message */
    private static final String FACTORY_ALREADY_DEFINED_ERR_MSG =
        "Factory already defined";

    /** Factory class not found error message */
    private static final String FACTORY_CLASS_NOT_FOUND_ERR_MSG =
        "Unable to find X3D player factory implementation\n";

    /** Unable to instantiate factory error message */
    private static final String UNABLE_TO_INSTANTIATE_FACTORY_ERR_MSG =
        "Error instantiating the X3D player factory\n";

    /** Class not a BrowserFactoryImpl error message */
    private static final String CLASS_NOT_A_BROWSER_FACTORY_IMPL_ERR_MSG =
        "The nominated browser factory is not an instance of ";

    /** NoSuchMethodException error message
     * @see <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/NoSuchMethodException.html">java.lang.NoSuchMethodException</a>
	 */
    private static final String CLASS_NO_SUCH_METHOD_ERR_MSG =
        "The nominated browser factory is not an instance of ";

    /** InvocationTargetException error message
     * @see <a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/reflect/InvocationTargetException.html">java.lang.reflect.InvocationTargetException</a>
	 */
    private static final String CLASS_INVOCATION_TARGET_ERR_MSG =
        "The class has an exception thrown by an invoked method or constructor ";

    /** BrowserFactoryImpl interface class name */
    private static final String BROWSER_FACTORY_IMPL_INTERFACE_CLASSNAME =
        "org.web3d.x3d.sai.BrowserFactoryImpl";

    /** The reference to the factory implementation used */
    private static BrowserFactoryImpl factory = null;

    /** The list of properties needed by this class */
    private final static Properties vrml_properties;

    /**
     * Static initializer method. Used to load the system properties for
     * this class. If there are none then it sets up the default values
     * that are needed.
     * <p>
     * At this stage it does not load the factory class, just in case the
     * user may set something at a later date.
     */
    static {
        vrml_properties = new Properties();

        // first look in System properties
        String factory_class_name = AccessController.doPrivileged(
                new PrivilegedAction<String>( ) {
                    @Override
                	public String run( ) {
                        return System.getProperty( FACTORY_CLASS );
                    }
                } );

        if ( factory_class_name != null ) {
            vrml_properties.put( FACTORY_CLASS, factory_class_name );
        }
        else {
            // a System property was not defined, look for an x3d.properties file
            InputStream propertiesFileInputstream = null;
            try {
                // fetch the properties file as a stream
                propertiesFileInputstream = AccessController.doPrivileged(
                    new PrivilegedAction<InputStream>() {
                        @Override
                    	public InputStream run() {
                            // privileged code goes here, for example:
                            return ClassLoader.getSystemResourceAsStream(PROPERTIES_FILE_NAME);
                        }
                    });

                // Fallback for WebStart
                if(propertiesFileInputstream == null)
                   propertiesFileInputstream = BrowserFactory.class.getClassLoader().getResourceAsStream(PROPERTIES_FILE_NAME);

                // Now try the Xj3D-internal version location.
                if(propertiesFileInputstream == null) {
                   propertiesFileInputstream = AccessController.doPrivileged(
                        new PrivilegedAction<InputStream>() {
                            @Override
                        	public InputStream run() {
                                // privileged code goes here, for example:
                                return ClassLoader.getSystemResourceAsStream(XJ3D_PROPERTIES_FILE);
                            }
                        });
                }

                // Fallback for WebStart
                if(propertiesFileInputstream == null)
                   propertiesFileInputstream = BrowserFactory.class.getClassLoader().getResourceAsStream(XJ3D_PROPERTIES_FILE);

                // If there is no x3d.properties file, then fill the properties list
                // ourselves so that everything works as advertised later on.
                if(propertiesFileInputstream == null)
                   vrml_properties.put(FACTORY_CLASS, DEFAULT_FACTORY_CLASS);
                else {
                    // from that stream load it into a properties table
                    vrml_properties.load(propertiesFileInputstream);
                }
            } catch(IOException ioe) {
                System.out.println(ioe);
            } finally {
                try {
                    if (propertiesFileInputstream != null)
                        propertiesFileInputstream.close();
                } catch(IOException ioe) { }
            }
        }
    }

    /**
     * Remove the constructor from public calling. Should never instantiate
     * this class.
     */
    private BrowserFactory() {
    }

    /**
     * Set the factory implementation to use. If the parameter value is null
     * an exception will be thrown.
     *
     * @param fac - The new implementation to use
     * @throws SecurityException The environment does not allow a factory
     *   to be set
     * @throws IllegalArgumentException The argument factory instance is null
     * @throws org.web3d.x3d.sai.X3DException The factory is already defined.
     */
	public static synchronized void setBrowserFactoryImpl( BrowserFactoryImpl fac )
        throws IllegalArgumentException, X3DException, SecurityException {

        if(fac == null)
		{
			String errorNotice = NULL_BROWSER_FACTORY_IMPL_ERR_MSG ;
//			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}

        if(factory != null)
		{
			String errorNotice =  FACTORY_ALREADY_DEFINED_ERR_MSG ;
//			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.X3DException(errorNotice);
		}

        // Check to see whether we can really set the factory needed.
        SecurityManager security = System.getSecurityManager();
        if(security != null)
            security.checkSetFactory();

        factory = fac;
    }

    /**
     * Create an X3D player that can be used as an AWT component. The component
     * returned is guaranteed to be an instance of X3DComponent.
     *
     * @param params - Parameters to control the look and feel.
     * @return The component browser initialised to be empty.
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D player.
     * @see X3DComponent
     */
	public static X3DComponent createX3DComponent(Map<String, Object> params) throws NotSupportedException
    {
        X3DComponent comp = null;

        try {
            if(factory == null)
                loadFactoryImpl();

            // comp = factory.createComponent(params);  // TODO fix incorrect method signature
        } catch (NotSupportedException nse) {
            System.out.println("Tracing exception for debug:   Factory: " + factory);
            nse.printStackTrace(System.out);
            throw nse;
        }
        return comp;
    }

    /**
     * Get a browser from the given java applet reference as a base in the
     * current HTML page. Used when attempting to access a browser on the current
     * page as this applet and is the first browser on the page. Generically, the
     * same as calling getBrowser(applet, "", 0);
     *
     * @param applet The applet reference to use
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D player
     * @exception NoSuchBrowserException Could not locate an X3D player on the
     *    same page as the applet.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
	public static ExternalBrowser getBrowser(Applet applet)
        throws NotSupportedException, NoSuchBrowserException, ConnectionException {

        if(factory == null)
            loadFactoryImpl();

        // return factory.getBrowser(applet);  // TODO fix incorrect method signature
		return null; // throw NotSupportedException(); // TODO fix incorrect method signature
    }

    /**
     * Get a browser from the given java applet reference one some named page and
     * at some embed location. Used when attempting to access a browser on
     * another HTML page within a multi-framed environment, or if there are a
     * number of X3D player instances located on the same page.
     * <p>
     * If the frame name is a zero length string or null then it is assumed to be
     * located on the same HTML page as the applet. The index is the number of
     * the embed X3D player starting from the top of the page. If there are
     * other non-X3D plugins embedded in the page these are not taken into
     * account in calculating the embed index.
     *
     * @param applet - The applet reference to use
     * @param frameName - The name of the frame to look into for the browser
     * @param index - The embed index of the X3D player in the page
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D player.
     * @exception NoSuchBrowserException Could not locate an X3D player on the
     *    same page as the applet.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
	public static ExternalBrowser getBrowser(Applet applet, String frameName, int index)
        throws NotSupportedException, NoSuchBrowserException, ConnectionException {

        if(factory == null)
            loadFactoryImpl();

        // return factory.getBrowser(applet, frameName, index);  // TODO fix incorrect method signature
		return null;
    }

    /**
     * Get a reference to a browser that is located on a remote machine. This
     * a server application to send scene updates to a number of client browsers
     * located on remote machines. If there are a number of browsers running on
     * a remote machine, they can be differentiated by the port number they are
     * listening on.
     * <p>
     * There is no default port number for X3D players.
     *
     * @param address - The address of the machine to connect to
     * @param port - The port number on that machine to connect to.
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D player.
     * @exception NoSuchBrowserException Could not locate an X3D player on the
     *    same page as the applet.
     * @exception UnknownHostException Could not find the machine named in the
     *    address.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
	public static ExternalBrowser getBrowser(InetAddress address, int port)
        throws NotSupportedException, NoSuchBrowserException, UnknownHostException,
    ConnectionException {

        if(factory == null)
            loadFactoryImpl();

        // return factory.getBrowser(address, port);  // TODO fix incorrect method signature
		return null;
    }

    /**
     * Private method to load the resource file and use the appropriate class
     * defined in the properties file for dealing with the resource management
     * <p>
     * Assumes that the factory reference is currently null as it automatically
     * writes over the top of it.
     */
    private static void loadFactoryImpl( )
    {
        String factory_class_name = new String();
        try {
            // load the factory class
            factory_class_name = vrml_properties.getProperty( FACTORY_CLASS, DEFAULT_FACTORY_CLASS );

            Class<?> factory_class = Class.forName( factory_class_name );
        //  factory = (BrowserFactoryImpl)factory_class.newInstance( ); // deprecated
        //  https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Class.html#newInstance()
            factory = (BrowserFactoryImpl)factory_class.getDeclaredConstructor().newInstance( );

        } catch( ClassNotFoundException cnfe ) {
            System.out.println( FACTORY_CLASS_NOT_FOUND_ERR_MSG + factory_class_name );
            //cnfe.printStackTrace(System.err);

        } catch( InstantiationException ie ) {
            System.out.println( UNABLE_TO_INSTANTIATE_FACTORY_ERR_MSG + factory_class_name );
            //ie.printStackTrace(System.err);

        } catch( IllegalAccessException iae ) {
            System.out.println( iae );
            //iae.printStackTrace(System.err);

        } catch( ClassCastException cce ) {
            System.out.println( CLASS_NOT_A_BROWSER_FACTORY_IMPL_ERR_MSG +
                BROWSER_FACTORY_IMPL_INTERFACE_CLASSNAME );
            //cce.printStackTrace(System.err);

        } catch( NoSuchMethodException nsme ) {
            System.out.println( CLASS_NO_SUCH_METHOD_ERR_MSG + factory_class_name );
            //nsme.printStackTrace(System.err);

        } catch( java.lang.reflect.InvocationTargetException ite ) {
            System.out.println( CLASS_INVOCATION_TARGET_ERR_MSG + factory_class_name );
            //ite.printStackTrace(System.err);
        }
    }
]]></xsl:text></xsl:with-param>
		</xsl:call-template>

		<!-- TODO not defined in specification but apparently necessary? -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserFactoryImpl</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text><![CDATA[
import java.applet.Applet;
import java.net.UnknownHostException;
import java.net.InetAddress;
import java.util.Map;
]]></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Implementation of factory class for obtaining references to browser instances.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text><![CDATA[
<p>
The factory implementation interface for obtaining references to browser
instances.
</p>
<p>
Any implementation of a X3D browser that wishes to provide their own
customised version of the browser factory should must subclass this class.
In particular this is useful if the implementation needs to stay within the
package defined by the application for other reasons.
</p>
<p>
A default implementation of this class is the DefaultBrowserFactoryImpl which
is package access only.
</p>]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /**
     * Create a X3D browser that can be used as an AWT component. The component
     * returned is guaranteed to be an instance of X3DComponent.
     *
     * @param params Parameters to control the look and feel.
     * @return The component browser initialised to be empty.
     * @exception NotSupportedException The implementation does not support this
     *    type of browser.
     * @see X3DComponent
     */
    X3DComponent createComponent(Map<String, Object> params) throws NotSupportedException;

    /**
     * Get a browser from the given java applet reference as a base in the
     * current HTML page. Used when attempting to access a browser on the current
     * page as this applet and is the first browser on the page. Generically, the
     * same as calling getBrowser(applet, "", 0);
     *
     * @param applet The applet reference to use
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D browser
     * @exception NoSuchBrowserException Could not locate a X3D browser on the
     *    same page as the applet.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
    ExternalBrowser getBrowser(Applet applet) throws NotSupportedException, NoSuchBrowserException, ConnectionException;

    /**
     * Get a browser from the given java applet reference one some named page and
     * at some embed location. Used when attempting to access a browser on
     * another HTML page within a multi-framed environment, or if there are a
     * number of X3D browser instances located on the same page.
     * <p>
     * If the frame name is a zero length string or null then it is assumed to be
     * located on the same HTML page as the applet. The index is the number of
     * the embed X3D browser starting from the top of the page. If there are
     * other non-X3D plugins embedded in the page these are not taken into
     * account in calculating the embed index.
     *
     * @param applet The applet reference to use
     * @param frameName The name of the frame to look into for the browser
     * @param index The embed index of the X3D browser in the page
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D browser.
     * @exception NoSuchBrowserException Could not locate a X3D browser on the
     *    same page as the applet.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
    ExternalBrowser getBrowser(Applet applet,
                               String frameName,
                               int index)
        throws NotSupportedException, NoSuchBrowserException, ConnectionException;

    /**
     * Get a reference to a browser that is located on a remote machine. This
     * a server application to send scene updates to a number of client browsers
     * located on remote machines. If there are a number of browsers running on
     * a remote machine, they can be differentiated by the port number they are
     * listening on.
     * <p>
     * There is no default port number for X3D browsers.
     *
     * @param address The address of the machine to connect to
     * @param port The port number on that machine to connect to.
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D browser.
     * @exception NoSuchBrowserException Could not locate a X3D browser on the
     *    same page as the applet.
     * @exception UnknownHostException Could not find the machine named in the
     *    address.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
    ExternalBrowser getBrowser(InetAddress address, int port)
        throws NotSupportedException, NoSuchBrowserException, UnknownHostException, ConnectionException;
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- TODO not defined in specification but apparently necessary? -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DComponent</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text><![CDATA[
<p>
Provides for implementation of a X3D player than runs as a
component and able to extract a Browser reference from it.
</p>
<p>
Generally this is used to provide a definition of an AWT component with a
VRML/X3D display capability. There is no reason why this can not be used for
other browser representations such as off-screen renderers or file savers.
</p>
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /**
     * Get a browser reference from this component that represents the
     * internals of this browser.
     *
     * @return A reference to the browser object represented by this component.
     */
    ExternalBrowser getBrowser();

    /**
     * Get a reference to the component implementation. For example, if this
     * is an AWT component, it would return an instance of {@link java.awt.Component}.
     * @return a reference to the component implementation
     */
    Object getImplementation();

    /**
     * Shutdown the component because it will no longer be needed. If the
     * component has already had this method called, it will silently ignore
     * any further requests.
     */
    void shutdown();
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- TODO not defined in specification but apparently necessary?? check duplicated inner class above -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>ExternalBrowser</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text><![CDATA[
<p>
Browser interface that represents the additional abilities an external
application is granted to the X3D browser.
</p>
<p>
A number of the methods in this application can take strings representing URLs.
relative URL strings contained in URL fields of nodes or these method
arguments are interpreted as follows:
</p>
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /**
     * Lock the output from the external interface to the browser as the code
     * is about to begin a series of updates. No events will be passed to the
     * X3D world. They will be buffered pending release due to a subsequent
     * call to endUpdate.
     * <p>
     * This call is a nesting call which means subsequent calls to beginUpdate
     * are kept on a stack. No events will be released to the X3D browser
     * until as many endUpdates have been called as beginUpdate.
     *
     * @exception InvalidBrowserException The dispose method has been called on
     *    this browser reference.
     * @exception ConnectionException An error occurred in the connection to the
     *    browser.
     */
    void beginUpdate() throws InvalidBrowserException;

    /**
     * Release the output of events from the external interface into the
     * X3D browser. All events posted to this point from the last time that
     * beginUpdate was called are released into the X3D browser for
     * processing at the next available opportunity.
     * <p>
     * This call is a nesting call which means subsequent calls to beginUpdate
     * are kept on a stack. No events will be released to the X3D browser
     * until as many endUpdates have been called as beginUpdate.
     * <p>
     * If no beginUpdate has been called before calling this method, it has
     * no effect.
     *
     * @exception InvalidBrowserException The dispose method has been called on
     *    this browser reference.
     * @exception ConnectionException An error occurred in the connection to the
     *    browser.
     */
    void endUpdate() throws InvalidBrowserException;

    /**
     * Add a listener for browser events. Any changes in the browser will be
     * sent to this listener. The order of calling listeners is not guaranteed.
     * Checking is performed on whether the nominated listener is already
     * registered to ensure that multiple registration cannot take place.
     * Therefore it is possible to multiply register the one class
     * instance while only receiving one event.
     *
     * @param l The listener to add.
     * @exception NullPointerException If the provided listener reference is
     *     null
     * @exception InvalidBrowserException The dispose method has been called on
     *    this browser reference.
     * @exception ConnectionException An error occurred in the connection to the
     *    browser.
     */
    void addBrowserListener(BrowserListener l) throws InvalidBrowserException;

    /**
     * Remove a listener for browser events. After calling this method, the
     * listener will no longer receive events from this browser instance. If the
     * listener passed as an argument is not currently registered, the method
     * will silently exit.
     *
     * @param l The listener to remove
     * @exception NullPointerException If the provided listener reference is
     *     null
     * @exception InvalidBrowserException The dispose method has been called on
     *    this browser reference.
     * @exception ConnectionException An error occurred in the connection to the
     *    browser.
     */
    void removeBrowserListener(BrowserListener l) throws InvalidBrowserException;

    /**
     * Dispose the resources that are used by this instance. Should be called
     * just prior to leaving the application.
     */
    void dispose();
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- TODO not defined in specification but apparently necessary?? check duplicated inner class above -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserListener</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>java.util.EventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Listener interface for classes wishing to know about changes in the browser</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /**
     * Process an event that has occurred in the X3D player.
     *
     * @param event The event that caused this method to be called
     */
    void browserChanged(BrowserEvent event);
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

    </xsl:template>

    <!-- ===================================================== -->

	<xsl:template name="StatementInterfaces">

		<xsl:variable name="subPackage">
			<xsl:if test="($modifySpecificationInterfaces = 'true')">
				<xsl:text>statements</xsl:text>
			</xsl:if>
		</xsl:variable>

		<!-- B.6 Statement interfaces -->
		<!-- https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/abstracts.html#StatementInterfaces -->

		<!-- TODO: specification  definitions for other statements; add accessor methods for setting values -->

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>Component</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<!-- TODO fix name in SAI: Component rather than ComponentInfo -->
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.1 ComponentInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#Component</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>7.2.5.4 COMPONENT statement</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>components/core.html#COMPONENTStatement</xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
Description of a single component.1188311883
A component description contains useful pieces of information about
the requirements. Of primary importance is the specification component name and level.
Additional information includes title and URL for the component provider.
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[
    /**
     * Get the name of this component.
     * @return name The name of the component
     */
	public String getName();

    /**
     * Get the level of the component. A level is always greater than zero.
     * The level information may represent one of two things, depending on
     * how the component info was created. When created as part of a file that
     * is requesting a specific level of support, the level will indicate the
     * requested level, not the maximum available on the system. When this is
     * returned from a query of the system to see what components are available
     * then the level is maximum supported by the implementation.
     *
     * @return The level value for the component
	 */
	public int getLevel();

    /**
     * Get the title of this component. This is a long-form version that can
     * be used in a UI. If no title is set, will return null.
     *
     * @return The title string of the component
     */
	public String getTitle();

    /**
     * Get the URL of the provider. This is used for user interface information
     * to point an end user at someone who has implemented this bit of
     * functionality. It is not used by the system to download the component
     * or its definition.
     *
     * @return The URL of the provider as a string
     */
	public String getProviderURL();

    /**
     * Return a formatted string version of this component that conforms to
     * the X3D specification for X3D file encoding. The string will start
     * with the <code>COMPONENT</code> keyword, as per specification.
     *
     * @return A correctly formatted string.
     */
	public String toX3DString(); // TODO re-check: toStringX3D
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>ProfileInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.2 ProfileInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#ProfileInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>7.2.5.3 PROFILE statement</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>components/core.html#PROFILEStatement</xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
Description of a single profile, which is a collection of components.
A profile defines the player or tool support needed for a particular scene.
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[
    /**
     * Get the name of this component.
     *
     * @return name The name of the component
     */
	public String getName();

    /**
     * Get the title of this component. This is a long-form version that can
     * be used in a UI.
     *
     * @return The title string of this component
     */
	public String getTitle();

    /**
     * Get the list of defined components for this profile. A profile will
     * always have one or more components.
     *
     * @return An array of Component definitions for this profile
     */
	public Component[] getComponents();

    /**
     * Return a formatted string version of this component that conforms to
     * the X3D specification for X3D file encoding. The string will start
     * with the <code>PROFILE</code> keyword, as per specification.
     *
     * @return A correctly formatted string
     */
	public String toX3DString(); // TODO re-check: toStringX3D
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>UnitInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.3 UnitInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#UnitInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>7.2.5.5 UNIT statement</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>components/core.html#UNITStatement</xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
UNIT statements define data conversion factors for a scene that can override default units of measure for angles in radians, length in meters, etc.
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[
    /**
     * Get the name of this UNIT statement.
     *
     * @return The name of the UNIT statement
     */
	public String getName();

    /**
     * Get the category (angle | length | force | mass) of this UNIT statement.
     *
     * @return The category of the UNIT statement
     */
	public String getCategory();

    /**
     * Get the positive double-precision factor that converts new base unit to default base unit.
     *
     * @return The positive double-precision conversion factor of the UNIT statement
     */
	public double getConversionFactor();

    /**
     * Return a formatted string version of this component that conforms to
     * the X3D specification for X3D file encoding. The string will start
     * with the <code>UNIT</code> keyword, as per specification.
     *
     * @return A correctly formatted string
     */
	public String toX3DString(); // TODO re-check: toStringX3D
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

    </xsl:template>

    <!-- ===================================================== -->

	<xsl:template name="ExceptionDefinitions">

		<xsl:variable name="subPackage">
			<xsl:if test="($modifySpecificationInterfaces = 'true')">
				<xsl:text>exceptions</xsl:text>
			</xsl:if>
		</xsl:variable>

		<!-- B.7 Exception definitions -->
		<!-- https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/abstracts.html#ExceptionDefinitions -->

		<!-- TODO fix specification definitions to be interfaces for all of these classes, can't simply define method stubs in class definitions -->

		<!-- TODO fix specification TOC bookmark -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>java.lang.RuntimeException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.1 X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The basic exception that is thrown by any X3D method call that needs to
throw an exception.

Based on RuntimeException so that the user has the choice of deciding
whether to catch the exception or not.
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public X3DException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public X3DException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserNotSharedException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.2 BrowserNotSharedException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserNotSharedException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to make method calls
that require this browser to be shared.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public BrowserNotSharedException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public BrowserNotSharedException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>ConnectionException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.3 ConnectionException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#ConnectionException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when an error occurs in the connection between
the external application and the X3D browser. Typically this might be a
network connection stopping or similar problem.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public ConnectionException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public ConnectionException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>ImportedNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.4 ImportedNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#ImportedNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to use an IMPORTed node
incorrectly in the scene graph.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public ImportedNodeException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public ImportedNodeException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InsufficientCapabilitiesException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.5 InsufficientCapabilitiesException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InsufficientCapabilitiesException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a node of greater capabilities than
the scene's declared profile and additional components is attempted to be
added to that scene.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InsufficientCapabilitiesException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InsufficientCapabilitiesException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.6 InvalidBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to access a method in
the Browser interface after the reference has had the dispose method called.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidBrowserException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidBrowserException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidDocumentException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.7 InvalidDocumentException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidDocumentException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to import a DOM Document
to make it into an X3DScene and the document is not correctly structured.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidDocumentException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidDocumentException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidExecutionContextException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.8 InvalidExecutionContextException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidExecutionContextException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a reference to an ExecutionContext is
not valid.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidExecutionContextException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidExecutionContextException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidFieldException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.9 InvalidFieldException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidFieldException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
<p>
The exception that is thrown when a reference to any field is not valid.
Generally used as a base class to more specific invalid field methods.
</p>
<p>
A field may be invalid for a number of reasons:
</p>
<ul>
	<li>The user may have typed in the wrong name through a typo.</li>
	<li>The name may not correspond to a field in that node at all.</li>
	<li>The name given refers to a valid field but the field cannot be
     accessed as an outputOnly field.</li>
</ul></xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidFieldException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidFieldException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidFieldValueException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.10 InvalidFieldValueException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidFieldValueException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
This exception may be generated when a node verifies the correctness of a setValue operation.
The exception can occur during the scene-parsing process, or else by the field during
runtime as the user is trying to modify it.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidFieldValueException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidFieldValueException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.11 InvalidNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a reference to a Node is not valid.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidNodeException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidNodeException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidOperationTimingException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.12 InvalidOperationTimingException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidOperationTimingException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to use an API call
outside of the predefined times when allowed.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidOperationTimingException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidOperationTimingException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidProtoException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.13 InvalidProtoException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidProtoException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a reference to a ProtoDeclare, ExternProtoDeclare
or ProtoInstance is not valid.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidProtoException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidProtoException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidRouteException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.14 InvalidRouteException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidRouteException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when any reference used by a ROUTE is not valid.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidRouteException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidRouteException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidURLException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text>B.7.15 InvalidURLException</xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidURLException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the ordered list of all URL and URN values are
invalid and cannot be parsed to form a proper URL/URN.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidURLException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidURLException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidX3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.16 InvalidX3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidX3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a the string passed to createVrmlFromString
or createX3dFromString method does not contain legal X3D, using either
UTF8 or XML syntax.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidX3DException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidX3DException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>NodeInUseException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.17 NodeInUseException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#NodeInUseException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a reference to a Node is already being
used when the user wants to add a new DEF, EXPORT or IMPORT definition.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public NodeInUseException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public NodeInUseException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>NodeUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.18 NodeUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#NodeUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when asking for a Node by name, and the
name is valid but the underlying node reference is not available from the
Inline yet.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public NodeUnavailableException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public NodeUnavailableException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>NoSuchBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.19 NoSuchBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#NoSuchBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the Browser factory is not able to locate
a browser with the given arguments.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public NoSuchBrowserException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public NoSuchBrowserException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>NotSupportedException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.20 NotSupportedException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#NotSupportedException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when an operation is not supported by an
underlying implementation.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public NotSupportedException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public NotSupportedException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>URLUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.sai.X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.21 URLUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#URLUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the URL is not specified for the currently
browser instance or there is some other problem.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public URLUnavailableException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public URLUnavailableException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>
    </xsl:template>

    <!-- ===================================================== -->

	<xsl:template name="NodeTypeDefinitions">

		<!-- B.2 Node type interfaces definitions -->
		<!-- https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/abstracts.html#NodeTypeInterfaces -->

		<xsl:for-each select="//AbstractNodeTypes/AbstractNodeType">

			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="extends">
                <xsl:variable name="saiPackagePath">
                    <xsl:call-template name="saiPackage">
                        <xsl:with-param name="nodeType" select="InterfaceDefinition/Inheritance/@baseType"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="(string-length($saiPackagePath) > 0)">
                        <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 7a */</xsl:text></xsl:if>
                        <xsl:value-of select="$saiPackagePath"/>
                        <xsl:text>.</xsl:text>
                        <xsl:value-of select="InterfaceDefinition/Inheritance/@baseType"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 7b, saiPackage not found */</xsl:text></xsl:if>
                        <xsl:value-of select="InterfaceDefinition/Inheritance/@baseType"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>

			<!-- TODO add specification parameters... -->

			<xsl:variable name="additionalInheritances">
				<xsl:for-each select="InterfaceDefinition/AdditionalInheritance">
                    <xsl:variable name="saiPackagePath">
                        <xsl:call-template name="saiPackage">
                            <xsl:with-param name="nodeType" select="@baseType"/>
                        </xsl:call-template>
                    </xsl:variable>
					<xsl:text>, </xsl:text>
                    <xsl:choose>
                        <xsl:when test="(string-length($saiPackagePath) > 0)">
                            <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 2a */</xsl:text></xsl:if>
                            <xsl:value-of select="$saiPackagePath"/>
                            <xsl:text>.</xsl:text>
                            <xsl:value-of select="@baseType"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 2b, saiPackage not found */</xsl:text></xsl:if>
                            <xsl:value-of select="@baseType"/>
                        </xsl:otherwise>
                    </xsl:choose>
				</xsl:for-each>
			</xsl:variable>

			<xsl:variable name="imports">
				<!-- TODO do not import inherited (extends) interface if in same package -->
				<xsl:variable name="baseType"   select="$extends"/>
				<xsl:variable name="subPackage" select="//*[@name=$baseType]/InterfaceDefinition/componentInfo/@name"/><!-- corresponding subPackage name -->
				<xsl:if test="(string-length($extends) > 0) and (string-length($subPackage) > 0) and (string-length($baseType) > 0) and
                              ($componentName != $subPackage)">
					<xsl:text>// import org.web3d.x3d.sai.</xsl:text>
					<xsl:if test="(string-length($subPackage) > 0)">
						<xsl:value-of select="$subPackage"/>
						<xsl:text>.</xsl:text>
					</xsl:if>
					<xsl:value-of select="$baseType"/>
					<xsl:text>;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>

				<xsl:for-each select="InterfaceDefinition/AdditionalInheritance">
					<xsl:variable   name="baseType" select="@baseType"/>
					<xsl:variable name="subPackage" select="//*[@name=$baseType]/InterfaceDefinition/componentInfo/@name"/><!-- corresponding subPackage name -->
					<!-- avoid imports from same package -->
					<xsl:if test="($componentName != $subPackage)">
						<xsl:text>// import org.web3d.x3d.sai.</xsl:text>
						<xsl:if test="(string-length($subPackage) > 0)">
							<xsl:value-of select="$subPackage"/>
							<xsl:text>.</xsl:text>
						</xsl:if>
						<xsl:value-of select="$baseType"/>
						<xsl:text>;</xsl:text>
						<xsl:text>&#10;</xsl:text>
					</xsl:if>
				</xsl:for-each>
			</xsl:variable>

			<!-- TODO specification needs to say that abstract node types need to go into subpackage corresponding to component -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:value-of select="$imports"/></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:value-of select="$extends"/><xsl:value-of select="$additionalInheritances"/></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>
			<xsl:variable name="inheritanceName"                       select="InterfaceDefinition/Inheritance/@baseType"/>
			<xsl:variable name="inheritanceComponent"                  select="concat(//AbstractNodeType  [@name = $inheritanceName]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $inheritanceName]/InterfaceDefinition/componentInfo/@name)"/>

			<xsl:variable name="additionalInheritanceName1"            select="InterfaceDefinition/AdditionalInheritance[1]/@baseType"/>
			<xsl:variable name="additionalInheritanceComponent1"       select="concat(//AbstractNodeType  [@name = $additionalInheritanceName1]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $additionalInheritanceName1]/InterfaceDefinition/componentInfo/@name)"/>
			<xsl:variable name="additionalInheritanceName2"            select="InterfaceDefinition/AdditionalInheritance[2]/@baseType"/>
			<xsl:variable name="additionalInheritanceComponent2"       select="concat(//AbstractNodeType  [@name = $additionalInheritanceName2]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $additionalInheritanceName2]/InterfaceDefinition/componentInfo/@name)"/>
			<xsl:variable name="extendsInterface">
				<xsl:text>org.web3d.x3d.sai.</xsl:text>
				<xsl:value-of select="$componentName"/>
				<xsl:text>.</xsl:text>
				<xsl:value-of select="$name"/>

					<xsl:if test="(count(InterfaceDefinition/Inheritance) > 0) and (string-length($inheritanceComponent) > 0)">
						<xsl:text>,</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>										org.web3d.x3d.jsail.</xsl:text>
						<xsl:value-of select="$inheritanceComponent"/>
						<xsl:text>.</xsl:text>
						<xsl:value-of select="$inheritanceName"/>
						<xsl:value-of select="$jsaiInterfaceSuffix"/>
					</xsl:if>
					<xsl:if test="(count(InterfaceDefinition/AdditionalInheritance) > 0) and (string-length($additionalInheritanceComponent1) > 0)">
						<xsl:text>,</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>										org.web3d.x3d.jsail.</xsl:text>
						<xsl:value-of select="$additionalInheritanceComponent1"/>
						<xsl:text>.</xsl:text>
						<xsl:value-of select="$additionalInheritanceName1"/>
						<xsl:value-of select="$jsaiInterfaceSuffix"/>
					</xsl:if>
					<xsl:if test="(count(InterfaceDefinition/AdditionalInheritance) > 1) and (string-length($additionalInheritanceComponent2) > 0)">
						<xsl:text>,</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>						org.web3d.x3d.jsail.</xsl:text>
						<xsl:value-of select="$additionalInheritanceComponent2"/>
						<xsl:text>.</xsl:text>
						<xsl:value-of select="$additionalInheritanceName2"/>
						<xsl:value-of select="$jsaiInterfaceSuffix"/>
					</xsl:if>
					<!-- debug
					<xsl:text> // end extendsInheritance</xsl:text>
					-->
			</xsl:variable>

<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
<xsl:text>// NodeTypeDefinitions interfaces ($nameInterface=</xsl:text>
<xsl:value-of select="$name"/><xsl:value-of select="$jsaiInterfaceSuffix"/>
<xsl:text>, $inheritanceName=</xsl:text>
<xsl:value-of select="$inheritanceName"/>
<xsl:text>, $inheritanceComponent=</xsl:text>
<xsl:value-of select="$inheritanceComponent"/>
<xsl:text>, $additionalInheritanceName1=</xsl:text>
<xsl:value-of select="$additionalInheritanceName1"/>
<xsl:text>, $additionalInheritanceComponent1=</xsl:text>
<xsl:value-of select="$additionalInheritanceComponent1"/>
<xsl:text>, $additionalInheritanceName2=</xsl:text>
<xsl:value-of select="$additionalInheritanceName2"/>
<xsl:text>, $additionalInheritanceComponent2=</xsl:text>
<xsl:value-of select="$additionalInheritanceComponent2"/>
<xsl:text>)</xsl:text>
</xsl:message>
</xsl:if>
		</xsl:for-each>
    </xsl:template>

    <!-- ===================================================== -->

	<xsl:template name="ObjectTypeDefinitions">

		<!-- B.3 Auxiliary node type interfaces definitions -->
		<!-- https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/abstracts.html#AuxiliaryNodeTypeInterfaces -->

		<xsl:for-each select="//AbstractObjectTypes/AbstractObjectType">

			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="extends"                             select="InterfaceDefinition/Inheritance/@baseType"/>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:value-of select="$extends"/></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:for-each>
    </xsl:template>

    <!-- ===================================================== -->

	<xsl:template name="NodeInterfacesDefinitions">

		<!-- B.3 Auxiliary node type interfaces definitions -->
		<!-- https://www.web3d.org/documents/specifications/19777-2/V3.3/Part2/abstracts.html#AuxiliaryNodeTypeInterfaces -->

		<xsl:for-each select="//ConcreteNodes/ConcreteNode[not(@name='ProtoInstance')]"><!-- TODO confirm  -->

			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="baseType"                            select="InterfaceDefinition/Inheritance/@baseType"/>
            <xsl:variable name="saiPackagePath">
                <xsl:call-template name="saiPackage">
                    <xsl:with-param name="nodeType" select="$baseType"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:variable name="extends">
                <xsl:choose>
                    <xsl:when test="(string-length($saiPackagePath) > 0)">
                        <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 4a */</xsl:text></xsl:if>
                        <xsl:value-of select="$saiPackagePath"/>
                        <xsl:text>.</xsl:text>
                        <xsl:value-of select="$baseType"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 4b, saiPackage not found */</xsl:text></xsl:if>
                        <xsl:value-of select="$baseType"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>

			<xsl:variable name="additionalInheritances">
				<xsl:for-each select="InterfaceDefinition/AdditionalInheritance">
                    <xsl:variable name="saiPackagePathInheritance">
                        <xsl:call-template name="saiPackage">
                            <xsl:with-param name="nodeType" select="@baseType"/>
                        </xsl:call-template>
                    </xsl:variable>
					<xsl:text>, </xsl:text>
                    <xsl:choose>
                        <xsl:when test="(string-length($saiPackagePathInheritance) > 0)">
                            <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 3a */</xsl:text></xsl:if>
                            <xsl:value-of select="$saiPackagePathInheritance"/>
                            <xsl:text>.</xsl:text>
                            <xsl:value-of select="@baseType"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 3b, saiPackageInheritance not found */</xsl:text></xsl:if>
                            <xsl:value-of select="@baseType"/>
                        </xsl:otherwise>
                    </xsl:choose>
				</xsl:for-each>
			</xsl:variable>

			<xsl:variable name="imports">
				<!-- TODO do not import inherited (extends) interface if in same package -->
				<xsl:variable name="baseType"   select="$extends"/>
				<xsl:variable name="subPackage" select="//*[@name=$baseType]/InterfaceDefinition/componentInfo/@name"/><!-- corresponding subPackage name -->

				<xsl:if test="(string-length($extends) > 0) and (string-length($subPackage) > 0) and (string-length($baseType) > 0) and
                              ($componentName != $subPackage)">
					<xsl:text>&#10;</xsl:text>
					<xsl:text>// import org.web3d.x3d.sai.</xsl:text>
					<xsl:if test="(string-length($subPackage) > 0)">
						<xsl:value-of select="$subPackage"/>
						<xsl:text>.</xsl:text>
					</xsl:if>
					<xsl:value-of select="$baseType"/>
					<xsl:text>;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>

				<xsl:for-each select="InterfaceDefinition/AdditionalInheritance">
					<xsl:variable   name="baseType" select="@baseType"/>
					<xsl:variable name="subPackage" select="//*[@name=$baseType]/InterfaceDefinition/componentInfo/@name"/><!-- corresponding subPackage name -->
					<!-- avoid imports from same package -->
					<xsl:if test="($componentName != $subPackage)">
						<xsl:text>// import org.web3d.x3d.sai.</xsl:text>
						<xsl:if test="(string-length($subPackage) > 0)">
							<xsl:value-of select="$subPackage"/>
							<xsl:text>.</xsl:text>
						</xsl:if>
						<xsl:value-of select="$baseType"/>
						<xsl:text>;</xsl:text>
						<xsl:text>&#10;</xsl:text>
					</xsl:if>
				</xsl:for-each>
			</xsl:variable>

			<!-- TODO add variable $x3dAbstractSpecificationSection -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:value-of select="$imports"/></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:value-of select="$extends"/><xsl:value-of select="$additionalInheritances"/></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>concretes.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>

		</xsl:for-each>

		<!-- create Javadoc package-info.java files for each subpackage -->
		<xsl:for-each select="//componentInfo[not(@name = preceding::componentInfo/@name)]">

            <xsl:variable name="componentName" select="translate(@name,'-','')"/>
            <xsl:variable name="sourceFilePath">
                <xsl:value-of select="$saiPackageDirectorySource"/>
                <xsl:text>/</xsl:text>
                <xsl:value-of select="$componentName"/><!-- no componentName hypens allowed (e.g. HAnim) -->
                <xsl:text>/</xsl:text>
                <xsl:text>package-info.java</xsl:text>
            </xsl:variable>

            <xsl:result-document href="{$targetPath}{$sourceFilePath}" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no">

                <xsl:variable name="componentName" select="translate(@name,'-','')"/> <!-- look out, prior variables have lost scope inside result-document -->
                <xsl:variable name="componentDescription" select="//SimpleType[@name='componentNameChoices']/enumeration[translate(@value,'-','') = $componentName]/@appinfo"/>

<xsl:text disable-output-escaping="yes"><![CDATA[/**
 * ]]></xsl:text>
    <xsl:value-of select="$componentDescription"/>
<xsl:text disable-output-escaping="yes"><![CDATA[
 * <p> The Scene Access Interface Library (sai) package provides abstract interface classes for each X3D node and statement,
 * in accordance witht the X3D SAI Specification.
 * </p>
 * <p> <i>Warning:</i> these interfaces are primarily for internal use to ensure consistency.
 * Java programmers typically only need to use concrete objects provided by the <code>org.web3d.x3d.jsail</code> classes.
 *</p>
 * <p> Online:
 *     <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html" target="_blank">X3D Java Scene Access Interface Library (X3DJSAIL)</a>
 *     and
 *     <a href="https://www.web3d.org/specifications/java/javadoc/index.html" target="_blank">X3DJSAIL Javadoc</a>.
 * </p>
 * @see java.lang.Package
 * @see <a href="https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful">https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful</a>
 * @see <a href="https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java">https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java</a>
 */

package org.web3d.x3d.sai.]]></xsl:text>
        <xsl:value-of select="$componentName"/>
        <xsl:text>;</xsl:text>
        <xsl:text>&#10;</xsl:text>
        <xsl:text>&#10;</xsl:text>

			<!-- debug
			<xsl:message>
				<xsl:text>*** componentName=</xsl:text>
				<xsl:value-of select="$componentName"/>
				<xsl:text>, sourceFilePath=</xsl:text>
				<xsl:value-of select="$sourceFilePath"/>
				<xsl:text>, componentDescription=</xsl:text>
				<xsl:value-of select="$componentDescription"/>
				<xsl:text>,</xsl:text>
                <xsl:text>&#10;</xsl:text>
                <xsl:text>javadocBody=</xsl:text>
				<xsl:value-of select="$javadocBody"/>
			</xsl:message>
			-->
        </xsl:result-document>
		</xsl:for-each><!-- finished Javadoc package-info.java files for each subpackage -->

		<!-- root package-info.java -->
		<xsl:result-document href="{$targetPath}{$saiPackageDirectorySource}/package-info.java" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
 *	<p> The X3D Java Scene Access Interface (SAI) package is designed to
 *	provide access to a browser and its contained scene graph,
 *	either as an internal X3D Script node, or as an standalone Java program.</p>
 *
 * <p> This package contains specification-defined X3D SAI interfaces
 *  and utility classes, used for compiling Java source code to be
 *  used by an X3D Script node.</p>
 *
 * <p> <i>Warning:</i> do not use this package for creating standalone Java programs, instead use the
 * <code>org.web3d.x3d.x3djsail</code>
 * package for concrete node implementations.</p>
 *
 * <p> Online:
 *     <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html" target="_blank">X3D Java Scene Access Interface Library (X3DJSAIL)</a>
 *     and
 *     <a href="https://www.web3d.org/specifications/java/javadoc/index.html" target="_blank">X3DJSAIL Javadoc</a>.
 * </p>
 * @see java.lang.Package
 * @see <a href="https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful">https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful</a>
 * @see <a href="https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java">https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java</a>
 */

package org.web3d.x3d.sai;

]]></xsl:text>
		</xsl:result-document>

		<!-- root package-info.java -->
		<xsl:result-document href="{$targetPath}{$testsPackageDirectorySource}/package-info.java" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
 *	The X3D Java tests package is designed to test the X3DJSAIL library.
 *
 *  This package contains unit tests of specification-defined X3DJSAIL interfaces and utility classes.
 *
 * <p> Online:
 *     <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html" target="_blank">X3D Java Scene Access Interface Library (X3DJSAIL)</a>
 *     and
 *     <a href="https://www.web3d.org/specifications/java/javadoc/index.html" target="_blank">X3DJSAIL Javadoc</a>.
 * </p>
 * @see java.lang.Package
 * @see <a href="https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful">https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful</a>
 * @see <a href="https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java">https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java</a>
 */

package org.web3d.x3d.tests;

]]></xsl:text>
		</xsl:result-document>

    </xsl:template>

    <!-- ===================================================== -->

	<xsl:template name="ConcreteNodeObjectDefinitions">

		<!-- TODO X3D Java Language Binding specification section on concrete classes that match X3D Abstract Specification -->
		<!-- https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/nodeIndex.html -->

		<!-- Concrete classes for X3D nodes - - - - - - - - - -->

		<xsl:for-each select="//ConcreteNodes/ConcreteNode">

			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="interfaceName"                       select="InterfaceDefinition/Inheritance/@baseType"/>
			<xsl:variable name="interfaceComponent"                  select="concat(//AbstractNodeType  [@name = $interfaceName]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $interfaceName]/InterfaceDefinition/componentInfo/@name)"/>
			<xsl:variable name="additionalInterfaceName1"            select="InterfaceDefinition/AdditionalInheritance[1]/@baseType"/>
			<xsl:variable name="additionalInterfaceComponent1"       select="concat(//AbstractNodeType  [@name = $additionalInterfaceName1]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $additionalInterfaceName1]/InterfaceDefinition/componentInfo/@name)"/>
			<xsl:variable name="additionalInterfaceName2"            select="InterfaceDefinition/AdditionalInheritance[2]/@baseType"/>
			<xsl:variable name="additionalInterfaceComponent2"       select="concat(//AbstractNodeType  [@name = $additionalInterfaceName2]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $additionalInterfaceName2]/InterfaceDefinition/componentInfo/@name)"/>

			<xsl:variable name="implements">
				<!-- SAI abstract interface reference -->
				<xsl:text>org.web3d.x3d.sai.</xsl:text>
				<xsl:value-of select="$componentName"/>
				<xsl:text>.</xsl:text>
                <xsl:choose>
                    <xsl:when test="(@name = 'ProtoInstance')">
                        <xsl:text>X3DPrototypeInstance, org.web3d.x3d.sai.Core.X3DChildNode</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="@name"/>
                    </xsl:otherwise>
                </xsl:choose>
				<!-- TODO: remove concrete-package interface references
				<xsl:text>, </xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text>										org.web3d.x3d.jsail.</xsl:text>
				<xsl:value-of select="$interfaceComponent"/>
				<xsl:text>.</xsl:text>
				<xsl:value-of select="$interfaceName"/>
				<xsl:value-of select="$jsaiInterfaceSuffix"/>
				<xsl:if test="(count(InterfaceDefinition/AdditionalInheritance) > 0) and (string-length($additionalInterfaceComponent1) > 0)">
					<xsl:text>,</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>										org.web3d.x3d.jsail.</xsl:text>
					<xsl:value-of select="$additionalInterfaceComponent1"/>
					<xsl:text>.</xsl:text>
					<xsl:value-of select="$additionalInterfaceName1"/>
					<xsl:value-of select="$jsaiInterfaceSuffix"/>
				</xsl:if>
				<xsl:if test="(count(InterfaceDefinition/AdditionalInheritance) > 1) and (string-length($additionalInterfaceComponent2) > 0)">
					<xsl:text>,</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>						org.web3d.x3d.jsail.</xsl:text>
					<xsl:value-of select="$additionalInterfaceComponent2"/>
					<xsl:text>.</xsl:text>
					<xsl:value-of select="$additionalInterfaceName2"/>
					<xsl:value-of select="$jsaiInterfaceSuffix"/>
				</xsl:if> -->
			</xsl:variable>

			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>

			<!-- ConcreteNode -->
			<!-- TODO add variable $x3dAbstractSpecificationSection -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteNode</xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:value-of select="$implements"/></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<!--
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>concretes.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param> -->

				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock"></xsl:with-param>
				<xsl:with-param name="implementationBlock"></xsl:with-param>
			</xsl:call-template>

		</xsl:for-each>

		<!-- Concrete classes for X3D statements - - - - - - - - - -->

		<xsl:for-each select="//Statements/Statement">

			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description">
				<xsl:value-of select="InterfaceDefinition/@appinfo"/> <!-- TODO duplicate -->
				<xsl:text> This concrete class represents an X3D </xsl:text>
				<xsl:if test="not($name = 'X3D')">
					<xsl:value-of select="$name"/>
					<xsl:text> </xsl:text>
				</xsl:if>
				<xsl:text>statement. </xsl:text>
			</xsl:variable>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="implements">
				<!-- X3D statements are not defined in specification abstract org.web3d.x3d.sai but are listed in X3DUOM as Statement elements -->
				<xsl:choose>
					<xsl:when test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or
							($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare') or ($name = 'ProtoInstance')">
						<xsl:text>org.web3d.x3d.sai.Core.X3DChildNode</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="extends">
				<!-- X3D statements are not defined in specification abstract org.web3d.x3d.sai -->
				<!-- created for this library to ensure consistency -->
				<xsl:text>org.web3d.x3d.jsail.X3DConcreteStatement</xsl:text>
			</xsl:variable>
			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>

			<!-- debug
			<xsl:message>
				<xsl:text>*** X3D Statement @name=</xsl:text>
				<xsl:value-of select="@name"/>
				<xsl:text>, $componentName=</xsl:text>
				<xsl:value-of select="$componentName"/>
				<xsl:text>, $implements=</xsl:text>
				<xsl:value-of select="$implements"/>
			</xsl:message>
			-->

			<!-- TODO add variable $x3dAbstractSpecificationSection -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteStatement</xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:value-of select="$implements"/></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<!--
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>concretes.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param> -->

				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock"></xsl:with-param>
			</xsl:call-template>

		</xsl:for-each>

        <xsl:for-each select="//componentInfo[not(@name = preceding::componentInfo/@name)]">

            <xsl:variable name="componentName" select="translate(@name,'-','')"/>
            <xsl:variable name="sourceFilePath">
                <xsl:value-of select="$concretePackageDirectorySource"/>
                <xsl:text>/</xsl:text>
                <xsl:value-of select="$componentName"/><!-- no componentName hypens allowed (e.g. HAnim) -->
                <xsl:text>/</xsl:text>
                <xsl:text>package-info.java</xsl:text>
            </xsl:variable>

            <!-- create Javadoc package-info.java files for each subpackage -->
            <xsl:result-document href="{$targetPath}{$sourceFilePath}" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no">

                <xsl:variable name="componentName" select="translate(@name,'-','')"/>
                <xsl:variable name="componentDescription" select="//SimpleType[@name='componentNameChoices']/enumeration[translate(@value,'-','') = $componentName]/@appinfo"/>

                <!-- debug
                <xsl:message>
                    <xsl:text>*** componentName=</xsl:text>
                    <xsl:value-of select="$componentName"/>
                    <xsl:text>, sourceFilePath=</xsl:text>
                    <xsl:value-of select="$sourceFilePath"/>
                    <xsl:text>, componentDescription=</xsl:text>
                    <xsl:value-of select="$componentDescription"/>
                </xsl:message>
                -->
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
 * ]]></xsl:text>
    <xsl:value-of select="$componentDescription"/>
<xsl:text disable-output-escaping="yes"><![CDATA[
 * <p> The X3D Java Scene Access Interface (x3djsail) package provides concrete classes for each X3D node and statement. </p>
 *
 * <p> Online:
 *     <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html" target="_blank">X3D Java Scene Access Interface Library (X3DJSAIL)</a>
 *     and
 *     <a href="https://www.web3d.org/specifications/java/javadoc/index.html" target="_blank">X3DJSAIL Javadoc</a>.
 * </p>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html">X3D Resources</a>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html">X3D Scene Authoring Hints</a>
 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html">X3D Tooltips</a>
 * @see java.lang.Package
 * @see <a href="https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful">https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful</a>
 * @see <a href="https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java">https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java</a>
 */

package org.web3d.x3d.jsail.]]></xsl:text>
                <xsl:value-of select="$componentName"/><!-- no componentName hypens allowed (e.g. HAnim) -->
                <xsl:text>;</xsl:text>
                <xsl:text>&#10;</xsl:text>
                <xsl:text>&#10;</xsl:text>

		    </xsl:result-document>
        </xsl:for-each>

		<!-- root package-info.java -->
		<xsl:result-document href="{$targetPath}{$concretePackageDirectorySource}/package-info.java" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
 *
 * <p> The X3D Java Scene Access Interface Library (X3DJSAIL) provides a
 * comprehensive set of strongly typed X3D Java interfaces for
 * concrete implementation classes.
 * This package also contains several library utility classes and
 * abstract interfaces that are used for all X3D nodes and statements.</p>
 *
 * <p> Online:
 *     <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html" target="_blank">X3D Java Scene Access Interface Library (X3DJSAIL)</a>
 *     and
 *     <a href="https://www.web3d.org/specifications/java/javadoc/index.html" target="_blank">X3DJSAIL Javadoc</a>.
 * </p>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html">X3D Resources</a>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html">X3D Scene Authoring Hints</a>
 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html">X3D Tooltips</a>
 * @see java.lang.Package
 * @see <a href="https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful">https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful</a>
 * @see <a href="https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java">https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java</a>
 */

package org.web3d.x3d.jsail;

]]></xsl:text>
		</xsl:result-document>

		<!-- fields package-info.java -->
		<xsl:result-document href="{$targetPath}{$concretePackageDirectorySource}/fields/package-info.java" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
 *
 * <p> The X3D Java fields package provides a
 * comprehensive set of strongly typed X3D Java classes for
 * concrete implementation of X3D field types.
 *
 * <p> Online:
 *     <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html" target="_blank">X3D Java Scene Access Interface Library (X3DJSAIL)</a>
 *     and
 *     <a href="https://www.web3d.org/specifications/java/javadoc/index.html" target="_blank">X3DJSAIL Javadoc</a>.
 * </p>
 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/fieldTypes.html">X3D Architecture: Field type reference</a>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html">X3D Resources</a>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html">X3D Scene Authoring Hints</a>
 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type Definitions</a>
 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FieldTypesTable">X3D Tooltips: Field Types Table</a>
 * @see java.lang.Package
 * @see <a href="https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful">https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful</a>
 * @see <a href="https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java">https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java</a>
 */

package org.web3d.x3d.jsail.fields;

]]></xsl:text>
		</xsl:result-document>

		<!-- EXI package-info.java -->
		<xsl:result-document href="{$targetPath}{$concretePackageDirectorySource}/../util/exi/package-info.java" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
 *
 * <p> The X3D Java x3duom package supports
 *  Java utility classes for Efficient XML Interchange (EXI) compression.
 *
 * <p> Online:
 *     <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html" target="_blank">X3D Java Scene Access Interface Library (X3DJSAIL)</a>
 *     and
 *     <a href="https://www.web3d.org/specifications/java/javadoc/index.html" target="_blank">X3DJSAIL Javadoc</a>.
 * </p>
 * @see <a href="https://openexi.sourceforge.net">Nagasena for EXI</a>
 * @see <a href="https://exificient.github.io">EXIficient for EXI</a>
 * @see <a href="https://www.w3.org/standards/xml/exi">World Wide Web Consortium (W3C) EFFICIENT INTERCHANGE</a>
 * @see <a href="https://www.w3.org/TR/2014/REC-exi-20140211">World Wide Web Consortium (W3C) Efficient XML Interchange (EXI) Format 1.0 (Second Edition)</a>
 * @see <a href="https://www.w3.org/TR/exi-for-json">World Wide Web Consortium (W3C) EXI for JSON (EXI4JSON)</a>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html">X3D Resources</a>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html">X3D Scene Authoring Hints</a>
 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html">X3D Tooltips</a>
 * @see java.lang.Package
 * @see <a href="https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful">https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful</a>
 * @see <a href="https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java">https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java</a>
 */

package org.web3d.x3d.util.exi;

]]></xsl:text>
		</xsl:result-document>
		<!-- X3DUOM package-info.java -->
		<xsl:result-document href="{$targetPath}{$concretePackageDirectorySource}/../util/x3duom/package-info.java" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
 *
 * <p> The X3D Java x3duom package provides a
 * set of Java utility classes for the X3D Unified Object Model (X3DUOM).
 *
 * <p> Online:
 *     <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html" target="_blank">X3D Java Scene Access Interface Library (X3DJSAIL)</a>
 *     and
 *     <a href="https://www.web3d.org/specifications/java/javadoc/index.html" target="_blank">X3DJSAIL Javadoc</a>.
 * </p>
 * @see <a href="https://www.web3d.org/specifications/X3DUOM.html">X3D Unified Object Model (X3DUOM)</a>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html">X3D Resources</a>
 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html">X3D Scene Authoring Hints</a>
 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html">X3D Tooltips</a>
 * @see java.lang.Package
 * @see <a href="https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful">https://stackoverflow.com/questions/22095487/why-is-package-info-java-useful</a>
 * @see <a href="https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java">https://stackoverflow.com/questions/624422/how-do-i-document-packages-in-java</a>
 */

package org.web3d.x3d.util.x3duom;

]]></xsl:text>
		</xsl:result-document>

    <!-- ===================================================== -->

	<!-- Utility concrete classes and interfaces for org.web3d.x3d.jsail package -->

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>CommandLine</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text>
// Desktop and Web browser
import java.awt.Desktop;
import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.nio.file.*;
import java.text.DecimalFormat;
import org.web3d.x3d.jsail.Core.*;
import org.web3d.x3d.sai.InvalidFieldValueException;
import org.web3d.x3d.sai.X3DException;
import org.web3d.x3d.tools.x3db.X3dCanonicalizer;

// XSLT operations: Saxon HE9
import net.sf.saxon.s9api.*;
// XSLT operations: Native Java
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.Result;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;
// XSLT operations
import org.w3c.dom.Document;
import org.xml.sax.SAXException;
// Script operations
import javax.script.ScriptEngineManager;
import javax.script.ScriptEngine;
import javax.script.ScriptException;</xsl:text>
        </xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isUtilityClass"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><!-- top level --></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text disable-output-escaping="yes"><![CDATA[Concrete class with a <code>main</code> method that provides command-line JAR access to various X3DJSAIL capabilities.]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
 * Usage: <code>% java -jar X3DJSAIL.4.0.classes.jar -help</code>
 * @see <a href="../../../../../X3DJSAIL.html#CommandLine" target="_blank">X3DJSAIL documentation: Command Line</a>
 * @see <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html">JAR File Specification</a>
 * @see <a href="https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html">Java Tutorials, Lesson: Packaging Programs in JAR Files</a>
]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
    // TODO JAR configuration

    /** CommandLine constructor creates an instance object of this class */
    public CommandLine()
    {
        // customized initialization can go here
    }

    // ==========================================================================================

	/** Loaded X3D model of interest, useful for initialization and use of CommandLine by other X3D Java programs. */
	private static X3D loadedX3dModel;

	/** Set already-loaded X3D model of interest, useful for initialization and use of CommandLine by other X3D Java programs.
	 * @param newX3dModel already-loaded X3D model of interest
	*/
	public static void setLoadedX3dModel (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newX3dModel)
	{
		loadedX3dModel = newX3dModel;
	}

	/** Reset already-loaded X3D model of interest to empty model */
	public static void clearLoadedX3dModel()
	{
		loadedX3dModel = new X3D();
	}

    // ==========================================================================================

    /** Initialize this CommandLine instance to default values. */
    public static final void initialize()
    {
        clearLoadedX3dModel();
    }

    /**
     *                                  Usage: <code>java [-classpath X3DJSAIL.*.jar] org.web3d.x3d.jsail.CommandLine [-help | -version | -home | -javadoc | -resources | -hints | -regexes | -tooltips | -X3DUOM] [-properties [propertiesFile]] [sourceModel.x3d | sourceModel.exi [-fromEXI] | sourceModel.gz [-fromGZIP] | sourceModel.zip [-fromZIP]] [-canonical] [-validate] [-EXIFICIENT | -OpenEXI] | [-Tidy | -toX3D | -toXML | -toClassicVrml | -toJava | -toJSON | -toPython | -toVRML97 | -toHTML | -toX3DOM | -toX_ITE | -toMarkdown | -toEXI | -toGZIP | -toZIP] [-tofile [resultFile.*]] [-toImage [snapshotName.*]]</code>
     */
    public  static final String USAGE      = "Usage: java [-classpath X3DJSAIL.*.jar] org.web3d.x3d.jsail.CommandLine\n       [-help | -version | -home | -javadoc | -resources | -hints | -regexes | -tooltips | -X3DUOM]\n       [-properties [propertiesFile]]\n       [sourceModel.x3d | sourceModel.exi [-fromEXI] | sourceModel.gz [-fromGZIP] | sourceModel.zip [-fromZIP]]\n       [-canonical] [-validate] [-EXIFICIENT | -OpenEXI]\n       [-Tidy | -toX3D | -toXML | -toClassicVrml | -toJava | -toJSON | -toPython | -toVRML97]\n       [-toHTML | -toX3DOM | -toX_ITE | -toMarkdown | -toEXI | -toGZIP | -toZIP]\n       [-tofile [resultFile.*]] [-toImage [snapshotName.*]]";
    /**
     *      Usage command-line switches with descriptions
     */
    public  static final String USAGE_LONG =
        "-classpath X3DJSAIL.*.jar         # optional classpath, can be set as environment variable" + "\n" +
        "org.web3d.x3d.jsail.CommandLine   # invoke CommandLine application" + "\n" +
        "==================================#====== informational ======================" + "\n" +
        "-help                             # provide this help message" + "\n" +
        "-version                          # version date when this X3DJSAIL build was autogenerated" + "\n" +
        "-home                             # launch X3DJSAIL home page" + "\n" +
        "-javadoc                          # launch X3DJSAIL javadoc page" + "\n" +
        "-resources                        # launch X3D Resources page" + "\n" +
        "-hints                            # launch X3D Scene Authoring Hints page" + "\n" +
        "-regex                            # launch X3D Regular Expressions page" + "\n" +
        "-tooltips                         # launch X3D Tooltips page" + "\n" +
        "-X3DUOM                           # launch X3D Unified Object Model (X3DUOM) page" + "\n" +
        " =================================#====== properties, inputs =================" + "\n" +
        "-properties [propertiesFile]      # override X3DJSAIL properties (default file: X3DJSAIL.properties)" + "\n" +
        "-EXIFICIENT                       # use Exificient (default) as EXI_ENGINE" + "\n" +
        "-OpenEXI                          # use OpenEXI (Nagasena)   as EXI_ENGINE (testing in progress)" + "\n" +
        "sourceModel.x3d                   # source model file name, X3D  format" + "\n" +
        "sourceModel.exi [-fromEXI]        # source model file name, EXI  format" + "\n" +
        "sourceModel.gz  [-fromGZIP]       # source model file name, GZIP format" + "\n" +
        "sourceModel.zip [-fromZIP]        # source model file name, ZIP  format" + "\n" +
        "==================================#====== operations =========================" + "\n" +
        "-canonical                        # canonical XML output using X3D Canonicalization (c14n)" + "\n" +
        "-validate                         # validate correctness of loaded model" + "\n" +
        "-Tidy                             # X3D-Tidy cleanup in .x3d (XML) format" + "\n" +
        "-toX3D                            # output in .x3d (XML) format" + "\n" +
        "-toXML                            # output in .xml (X3D) format" + "\n" +
        "-toClassicVrml                    # output in .x3dv (ClassicVrml) X3D format" + "\n" +
        "-toJava                           # output in .java source code using X3DJSAIL" + "\n" +
        "-toJSON                           # output in .json (JavaScript Object Notation) format" + "\n" +
        "-toPython                         # output in .py Python source code" + "\n" +
        "-toVRML97                         # output in .wrl  (VRML97) format" + "\n" +
        "-toHTML                           # output in .html  pretty-print documentation" + "\n" +
        "-toX3DOM                          # output in .xhtml page with X3DOM display of X3D model" + "\n" +
        "-toX_ITE                          # output in .html  page with X_ITE display of X3D model" + "\n" +
        "-toMarkdown                       # output document metadata (meta tags) in .md (Markdown) format" + "\n" +
        "-toEXI                            # output in .exi (Efficient XML Interchange) compressed-XML format" + "\n" +
        "-toGZIP                           # output in .gz  (X3D XML) format, with gzip compression" + "\n" +
        "-toZIP                            # output in .zip (X3D XML) format, with zip  compression" + "\n" +
        "==================================#====== outputs ============================" + "\n" +
        "-tofile  [resultFile.*]           # specify output filename (otherwise original name with extension)" + "\n" +
        "-toImage [snapshotName.*]         # create output images for each Viewpoint using Blender" + "\n";

    private static final String WARNING = "[Warning] ";
    private static final String ERROR   = "[Error] ";

    private static boolean canonicalize             = false;
    private static boolean convertToVRML97          = false;
    private static boolean convertToClassicVRML     = false;
    private static boolean convertToX3D             = false;
    private static boolean convertToXML             = false;
    private static boolean convertToHTML            = false; // pretty-print documentation
    private static boolean convertToMarkdown        = false; // model meta information
    private static boolean includeSubdirectoryPaths = true;  // model meta information, special switch for ModelExchange
    private static boolean convertToTidy            = false;
    private static boolean convertToJava            = false;
    private static boolean convertToJS              = false;
    private static boolean convertToJSON            = false;
    private static boolean convertToPython          = false;
    private static boolean convertToX3DOM           = false;
    private static boolean convertToX_ITE           = false;
    private static boolean convertToEXI             = false;
    private static boolean convertFromEXI           = false;
    private static boolean convertToGZIP            = false;
    private static boolean convertFromGZIP          = false;
    private static boolean convertToZIP             = false;
    private static boolean convertFromZIP           = false;
    private static boolean validateSwitch           = false;

	private static String  conversionExtension = new String();

	/** Reset switch values */
	private static void initializeConfigurationSwitches()
	{
        canonicalize             = false;
		convertToVRML97          = false;
		convertToClassicVRML     = false;
		convertToX3D             = false;
		convertToXML             = false;
		convertToHTML            = false;
		convertToMarkdown        = false;
		includeSubdirectoryPaths = true; // special markdown switch
		convertToTidy            = false;
		convertToJava            = false;
		convertToJS              = false;
		convertToJSON            = false;
		convertToPython          = false;
		convertToX3DOM           = false;
		convertToX_ITE           = false;
		convertToEXI             = false;
		convertFromEXI           = false;
		convertToGZIP            = false;
		convertFromGZIP          = false;
		convertToZIP             = false;
		convertFromZIP           = false;
		validateSwitch           = false;

		conversionExtension  = new String();
	}

    /**
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
     */
    private static BufferedWriter bufferedWriter;

    /** Default main() method provided for test and debugging purposes, invoking run() method.
     * @param args the command line arguments
     * @see #run(String[])
     * @see X3D#handleArguments(String[])
     */
    public static void main(String[] args)
    {
	run(args);
    }

    /** Utility run() method provided for test and debugging purposes, allowing invocation with a single String (rather than a String[] array).
	 * When invoked without parameters then reports results of validate() self-checks to system output.
     * @param singleStringArguments the command line arguments
     * @see #run(String[])
     */
    public static void run(String singleStringArguments)
    {
        run(singleStringArguments.split("(\\s)")); // split single string into string array
    }

    /** Default run() method provided for test and debugging purposes, first initializing ConfigurationProperties then reading properties file (if any) and processing arguments.
	 * When invoked without parameters then reports results of validate() self-checks to system output.
     * @param args the command line arguments
     * @see #main(String[])
     * @see ConfigurationProperties
     * @see X3D#handleArguments(String[])
     */
    public static void run(String[] args)
    {
        File    sourceFile           = null; // curiously, must be initialized as null
        long    sourceFileLength     = 0;
        String  sourceFileName       = "";
        String  sourceFileNameRoot   = "";
        String  resultFileName       = "";
        String  resultFileNameRoot   = "";
        final String tempFileName    = "temp9876543210.txt";
	File    resultFile           = new File(tempFileName); // overwritten or deleted
        boolean convertToFile        = false;
        boolean loadProperties       = false;
        String propertiesFileName    = "";
        String propertiesFileNameRoot= "";
        DecimalFormat formatPrecision2 = new DecimalFormat ("#0.00");
	String  compressionRatio;

        // https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
        // https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
        Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

	        initializeConfigurationSwitches();
                if (loadedX3dModel == null)
                    initialize();

		if ((args== null) || (args.length < 1))
		{
			System.out.println (USAGE);
			System.out.println();
			System.out.println (USAGE_LONG);
			return;
		}
		else
		{
			for (int i=0; i<=args.length-1; i++)
			{
				if  (args[i].trim().isEmpty())
				{
                    continue; // skip empty argument
                }
                args[i] = args[i].trim(); // eliminate excess whitespace, if called programmatically
				if  (!args[i].startsWith("-"))
				{
					if (!sourceFileName.isEmpty()) // slready found on previous pass
					{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] multiple source file names found, \"" + sourceFileName + "\" and \"" + args[i] + "\"");
						System.out.println(USAGE);
						return;
					}
					else
					{
						sourceFileName     = args[i];
						sourceFileNameRoot = sourceFileName;
						if (sourceFileNameRoot.contains("."))
							sourceFileNameRoot = sourceFileName.substring(0,sourceFileName.lastIndexOf("."));
						sourceFile = new File(sourceFileName);
						String messageSuffix = new String();
						if (!sourceFile.exists())
						{
							System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] file not found: " + sourceFileName);
							return;
						}
						else
						{
							sourceFileLength = sourceFile.length();
							System.out.println ("parameter: source file " + sourceFile.getName() + " filesize " + sourceFileLength + " bytes" + messageSuffix);
						}
                        if      (sourceFileName.endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_EXI))
                        {
                            convertFromEXI = true;
                        }
                        else if (sourceFileName.endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_GZIP))
                        {
                            convertFromGZIP = true;
                        }
                        else if (sourceFileName.endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_ZIP))
                        {
                            convertFromZIP = true;
                        }
					}
				}
				else if (args[i].equalsIgnoreCase("-tofile")) // followed by resultFileName
				{
					if ((args.length > i + 1) && !(args[i+1] == null) && !args[i+1].isEmpty() && !args[i+1].startsWith("-"))
					{
						 resultFileName     = args[i+1];
						 resultFileNameRoot = resultFileName.substring(0,resultFileName.lastIndexOf("."));
                         if (!resultFileName.contains("."))
                         {
                             resultFileNameRoot = resultFileName;
                             System.out.println ("[warning]  \"" + resultFileName + "\" contains no period or filename extension");
                         }
						 System.out.println ("CommandLine parameter: \"" + args[i] + "\" \"" + args[i+1] + "\" for result file name root " + resultFileNameRoot);
						 i++; // increment index, carefully!
					}
					else System.out.println ("parameter: \"" + args[i] + "\" for result file name root "+ resultFileNameRoot);
					convertToFile = true;
				}
				else if (args[i].equalsIgnoreCase("-properties") || args[i].equalsIgnoreCase("-propertiesFile")) // optionally followed by propertiesFileName
				{
					if ((args.length > i + 1) && !(args[i+1] == null) && !args[i+1].isEmpty() && !args[i+1].startsWith("-"))
					{
						 propertiesFileName     = args[i+1];
						 propertiesFileNameRoot = propertiesFileName.substring(0,propertiesFileName.lastIndexOf("."));
						 System.out.println ("CommandLine parameter: \"" + args[i] + "\" \"" + args[i+1] + "\" for properties file name root " + propertiesFileNameRoot);
						 i++; // increment index, carefully!
					}
					else System.out.println ("CommandLine parameter: \"" + args[i] + "\" for properties file name root "+ propertiesFileNameRoot);
					loadProperties = true; // set flag
				}
				else if (args[i].equalsIgnoreCase("-x3d") || args[i].equalsIgnoreCase("-tox3d"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToX3D = true;
					conversionExtension = X3D.FILE_EXTENSION_X3D;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to X3D encoding");
				}
				else if (args[i].equalsIgnoreCase("-xml") || args[i].equalsIgnoreCase("-toxml"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToXML = true;
					conversionExtension = X3D.FILE_EXTENSION_XML;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to XML encoding");
				}
				else  if (args[i].equalsIgnoreCase("-canonical")    || args[i].equalsIgnoreCase( "-c14n") ||
						  args[i].equalsIgnoreCase("-canonicalize") || args[i].equalsIgnoreCase("-canonicalization"))
				{
					clearPriorConversionSwitches(args[i]);
					canonicalize   = true;
                    convertToFile  = true;               // use same name unless otherwise specified,
                    if (resultFileName.isEmpty())        // may be overridden if followed by toFile
                        resultFileName = sourceFileNameRoot + "Canonical.xml";
					if      (resultFileName.endsWith(".x3d"))
					         conversionExtension = X3D.FILE_EXTENSION_X3D;
					else if (resultFileName.endsWith(".xml"))
					         conversionExtension = X3D.FILE_EXTENSION_XML;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for X3D and XML canonicalization (C14N)");
				}
				else if (args[i].equalsIgnoreCase("-html")  || args[i].equalsIgnoreCase("-tohtml")  || args[i].equalsIgnoreCase("-html5") || args[i].equalsIgnoreCase("-tohtml5") ||
						 args[i].equalsIgnoreCase("-xhtml") || args[i].equalsIgnoreCase("-toxhtml") || args[i].equalsIgnoreCase("-prettyprint"))
				{
				    /* pretty-print documentation */
					clearPriorConversionSwitches(args[i]);
					convertToHTML = true;
					if  (args[i].equalsIgnoreCase("-xhtml") || args[i].equalsIgnoreCase("-toxhtml"))
					     conversionExtension = X3D.FILE_EXTENSION_XHTML;
					else conversionExtension = X3D.FILE_EXTENSION_HTML;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for producing " + conversionExtension + " pretty-print documentation");
				}
				else if (args[i].equalsIgnoreCase("-md")  || args[i].equalsIgnoreCase("-tomd")  || args[i].equalsIgnoreCase("-markdown") || args[i].equalsIgnoreCase("-tomarkdown"))
				{
					/* model meta information to markdown, used in ModelExchange.nps.edu */
					clearPriorConversionSwitches(args[i]);
					includeSubdirectoryPaths = true;
					convertToMarkdown   = true;
					conversionExtension = X3D.FILE_EXTENSION_MARKDOWN;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for producing " + conversionExtension + " model meta information markdown");
				}
				else if (args[i].equalsIgnoreCase("-tidy") || args[i].equalsIgnoreCase("-totidy") || args[i].equalsIgnoreCase("-x3dtidy") || args[i].equalsIgnoreCase("-tox3dtidy"))
				{
				    /* X3D-Tidy cleanup */
					clearPriorConversionSwitches(args[i]);
					convertToTidy = true;
					conversionExtension = X3D.FILE_EXTENSION_X3D;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for producing X3D-Tidy cleanup of .x3d");
				}
				else if (args[i].equalsIgnoreCase("-x3dv") || args[i].equalsIgnoreCase("-tox3dv") ||
						 args[i].equalsIgnoreCase("-toClassicVRML") || args[i].equalsIgnoreCase("-ClassicVRML"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToClassicVRML = true;
					conversionExtension = X3D.FILE_EXTENSION_CLASSICVRML;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to ClassicVRML encoding");
				}
				else  if (args[i].equalsIgnoreCase("-java") || args[i].equalsIgnoreCase("-tojava"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToJava = true;
					conversionExtension = X3D.FILE_EXTENSION_JAVA;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to Java source code");
				}
				else  if (args[i].equalsIgnoreCase("-json") || args[i].equalsIgnoreCase("-tojson"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToJSON = true;
					conversionExtension = X3D.FILE_EXTENSION_JSON;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to JSON encoding");
				}
				else  if (args[i].equalsIgnoreCase("-Python") || args[i].equalsIgnoreCase("-toPython"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToPython = true;
					conversionExtension = X3D.FILE_EXTENSION_PYTHON;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to Python source code");
				}
 				else  if (args[i].equalsIgnoreCase("-js") || args[i].equalsIgnoreCase("-tojs"))
 				{
 					clearPriorConversionSwitches(args[i]);
 					convertToJS = true;
 					conversionExtension = X3D.FILE_EXTENSION_JAVASCRIPT;
 					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to X3DJSONLD JavaScript source");
 				}
				else  if (args[i].equalsIgnoreCase(  "-vrml") || args[i].equalsIgnoreCase(  "-vrml97") ||args[i].equalsIgnoreCase( "-wrl") ||
						  args[i].equalsIgnoreCase("-tovrml") || args[i].equalsIgnoreCase("-tovrml97"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToVRML97 = true;
					conversionExtension = X3D.FILE_EXTENSION_VRML97;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to VRML97 encoding");
				}
				else  if (args[i].equalsIgnoreCase("-x3dom") || args[i].equalsIgnoreCase("-tox3dom"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToX3DOM = true;
					conversionExtension = X3D.FILE_EXTENSION_HTML;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to X3DOM HTML page containing model");
				}
				else  if (args[i].equalsIgnoreCase("-X_ITE") || args[i].equalsIgnoreCase("-toX_ITE"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToX_ITE = true;
					conversionExtension = X3D.FILE_EXTENSION_HTML;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to X_ITE HTML page containing model");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-EXIFICIENT"))
				{
					ConfigurationProperties.setExiEngine(ConfigurationProperties.EXI_ENGINE_EXIFICIENT);
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" invoked ConfigurationProperties.setExiEngine(" + ConfigurationProperties.EXI_ENGINE_EXIFICIENT + ");");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-OPENEXI") || args[i].equalsIgnoreCase("-OPEN-EXI") || args[i].equalsIgnoreCase("-NAGASENA"))
				{
					ConfigurationProperties.setExiEngine(ConfigurationProperties.EXI_ENGINE_OPENEXI);
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" invoked ConfigurationProperties.setExiEngine(" + ConfigurationProperties.EXI_ENGINE_OPENEXI + ");");
					// TODO update when ready:
					System.out.println ("  [warning] \"" + ConfigurationProperties.EXI_ENGINE_OPENEXI + "\" testing in progress, can also use " + ConfigurationProperties.EXI_ENGINE_EXIFICIENT + " instead.");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-EXI") || args[i].equalsIgnoreCase("-toEXI"))
				{
					if (sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_EXI))
					{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert an .exi file -toEXI");
						System.out.println(USAGE);
						return;
					}
					clearPriorConversionSwitches(args[i]);
					convertToEXI  = true;
					convertToFile = true;
					conversionExtension = X3D.FILE_EXTENSION_EXI;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to compressed EXI containing model");
				}
				else  if ((args[i].equalsIgnoreCase("-EXI") &&  sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_EXI)) ||
						   args[i].equalsIgnoreCase("-fromEXI"))
				{
					if (!sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_EXI))
					{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert a non-exi file -toEXI");
						System.out.println(USAGE);
						return;
					}
					clearPriorConversionSwitches(args[i]);
					convertFromEXI = true;
					conversionExtension = X3D.FILE_EXTENSION_X3D;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion from compressed EXI containing model");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-toGZ") || args[i].equalsIgnoreCase("-toGZIP"))
				{
					if (sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_GZIP))
					{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert -toGZIP an already gzip .gz file " + sourceFileName);
						System.out.println(USAGE);
						return;
					}
					clearPriorConversionSwitches(args[i]);
					convertToGZIP = true;
					convertToFile = true;
					conversionExtension = X3D.FILE_EXTENSION_GZIP;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to compressed GZIP containing model");
				}
				else  if (args[i].equalsIgnoreCase("-fromGZ") || args[i].equalsIgnoreCase("-fromGZIP"))
				{
					if (!sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_GZIP))
					{
							System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert -fromGZIP an non-gzip file " + sourceFileName);
							System.out.println(USAGE);
							return;
					}
					clearPriorConversionSwitches(args[i]);
					convertFromGZIP = true;
					conversionExtension = X3D.FILE_EXTENSION_X3D;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion from compressed GZIP containing model");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-toZIP"))
				{
					if (sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_ZIP))
					{
							System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert -toZIP a non-zip file " + sourceFileName);
							System.out.println(USAGE);
							return;
					}
					clearPriorConversionSwitches(args[i]);
					convertToZIP = true;
					conversionExtension = X3D.FILE_EXTENSION_ZIP;
					System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion to compressed ZIP containing model");
				}
				else  if (args[i].equalsIgnoreCase("-fromZIP"))
				{
                                    if (!sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_ZIP))
                                    {
                                        System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert -fromZIP a non-zip file " + sourceFileName);
                                        System.out.println(USAGE);
                                        return;
                                    }
                                    // TODO also handle specification of filename of interest
                                    clearPriorConversionSwitches(args[i]);
                                    convertFromZIP = true;
                                    convertToFile  = true;
                                    conversionExtension = X3D.FILE_EXTENSION_X3D;
                                    System.out.println ("CommandLine parameter: \"" + args[i] + "\" for conversion from compressed ZIP containing model");
				}
				// ==========================================
				else if (args[i].equalsIgnoreCase("-toImage") || args[i].equalsIgnoreCase("-screenshot"))
				{
                                    initializeConfigurationSwitches();
                                    System.out.println ("CommandLine parameter: \"" + args[i] + "\" for creating screenshot image of default viewpoint");
                                    System.out.println ("Pass through to BlenderLauncher...");
                                    org.web3d.x3d.jsail.BlenderLauncher.run(args);
                                    return;
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-v") || args[i].equalsIgnoreCase("-validate"))
				{
                                    // usually invoked in isolation, but can coexist (superfluous) with conversions
                                    validateSwitch = true;
                                    if (resultFileName.isEmpty())
                                    {
                                             resultFileName = "Validation" + X3D.FILE_EXTENSION_TEXT; // be prepared with default name
                                             System.out.println ("CommandLine parameter: \"" + args[i] + "\" for model validation");
                                    }
                                    else System.out.println ("CommandLine parameter: \"" + args[i] + "\" for model validation to result file");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-home") || args[i].equalsIgnoreCase("-page") || args[i].equalsIgnoreCase("-homepage") || args[i].equalsIgnoreCase("-website") || args[i].equalsIgnoreCase("-X3DJSAIL"))
				{
					clearPriorConversionSwitches(args[i]);
                    System.out.println("Opening " + ConfigurationProperties.URL_X3DJSAIL);
					openHomePageX3DJSAIL();
					return;
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-javadoc"))
				{
					clearPriorConversionSwitches(args[i]);
                    System.out.println("Opening Javadoc at " + ConfigurationProperties.URL_X3DJSAIL);
					openJavadocX3DJSAIL();
					return;
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-resources") || args[i].equalsIgnoreCase("-X3dResources"))
				{
                    System.out.println("Opening " + ConfigurationProperties.URL_X3DRESOURCES);
					if  (i < args.length - 1)
                         openX3dResourcesPage(args[i+1]);
                    else openX3dResourcesPage();
					return;
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-hints") || args[i].equalsIgnoreCase("-SceneAuthoringHints") || args[i].equalsIgnoreCase("-X3dSceneAuthoringHints"))
				{
                    System.out.println("Opening " + ConfigurationProperties.URL_X3DSCENEAUTHORINGHINTS);
					 if  (i < args.length - 1)
                         openX3dSceneAuthoringHintsPage(args[i+1]);
                    else openX3dSceneAuthoringHintsPage();
					return;
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-tooltips") || args[i].equalsIgnoreCase("-X3dTooltips"))
				{
                    System.out.println("Opening " + ConfigurationProperties.URL_X3DTOOLTIPS);
                    if  (i < args.length - 1)
                         openX3dTooltipsPage(args[i+1]);
                    else openX3dTooltipsPage();
					return;
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-regex") || args[i].equalsIgnoreCase("-regexes") || args[i].equalsIgnoreCase("-RegularExpressions"))
				{
                    System.out.println("Opening " + ConfigurationProperties.URL_X3DREGEXES);
                    if  (i < args.length - 1)
                         openX3dRegexesPage(args[i+1]);
                    else openX3dRegexesPage();
					return;
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-X3DUOM"))
				{
                    System.out.println("Opening " + ConfigurationProperties.URL_X3DUOM);
                    openX3DUOMpage();
					return;
				}
				// ==========================================
				else  if (args[i].toLowerCase().contains("-help"))
				{
					clearPriorConversionSwitches(args[i]);
					System.out.println(USAGE);
                    System.out.println();
                    System.out.println (USAGE_LONG);
					return;
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-version"))
				{
					clearPriorConversionSwitches(args[i]);
					System.out.println("X3DJSAIL version date: " + ConfigurationProperties.VERSION_DATE);
                    if ((i == args.length-1) || (args.length > 2))
                        return;
					// otherwise do not return so that this output can be included with other commands
				}
				// ==========================================
				else // not found
				{
					System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] unrecognized CommandLine option \"" + args[i] + "\"");
					System.out.println(USAGE);
                    System.out.println();
                    System.out.println (USAGE_LONG);
					return;
				}
			}
		}
		// ===================================================================================
		if (loadProperties)
		{
			if (!propertiesFileName.isEmpty())
				ConfigurationProperties.setPropertiesFileName (propertiesFileName);
			ConfigurationProperties.loadProperties();
		}

		// compute/confirm resultFileName after all command-line switches are read
		if (!sourceFileName.isEmpty() && resultFileName.isEmpty())
		{
			resultFileNameRoot = sourceFileNameRoot;
			resultFileName     = resultFileNameRoot + conversionExtension;
		}
		if ((convertToX3D         &&  !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_X3D))    ||
			(convertToXML         &&  !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_XML))    ||
			(canonicalize         && (!conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_X3D) &&
                                      !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_XML))) ||
			(convertToHTML        && (!conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_HTML) &&
                                      !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_XHTML)))   ||
			(convertToMarkdown    &&  !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_MARKDOWN)) ||
			(convertToTidy        &&  !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_X3D))      ||
			(convertToClassicVRML &&  !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_CLASSICVRML)) ||
			(convertToVRML97      &&  !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_VRML97)) ||
			(convertToX3DOM       && (!conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_HTML) &&
                                      !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_XHTML))) ||
			(convertToX_ITE       && (!conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_HTML) &&
                                      !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_XHTML))) ||
			(convertToEXI         &&  !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_EXI))    ||
			(convertToGZIP        &&  !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_GZIP))   ||
			(convertToZIP         &&  !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_ZIP))    )
		{
			System.out.println(WARNING+" [org.web3d.x3d.jsail.CommandLine] mismatched file extension \"" + conversionExtension + "\" for conversion");
		}

		// ===================================================================================
        if (!sourceFileName.isEmpty()) // fully prepared, now get source file and proceed
        {
			if (convertFromGZIP)
			{
				if (!sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_GZIP))
				{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot -gunzip a non-gzip file " + sourceFileName);
						System.out.println(USAGE);
						return;
				}
				boolean result = loadedX3dModel.fromFileGZIP(sourceFileName);
				System.out.println("load result: " + result);
				return;
			}
			else if (convertFromZIP)
			{
				if (!sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_ZIP))
				{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot -gunzip a non-zip file " + sourceFileName);
						System.out.println(USAGE);
						return;
				}
				// if output resultFileName not specified, pick first available .x3d file
				boolean result = loadedX3dModel.fromFileZIP(sourceFileName,resultFileName);
				System.out.println("load result: " + result);
				return;
			}
			else if (convertFromEXI)
			{
				if (!sourceFileName.toLowerCase().endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_EXI))
				{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot -fromEXI a non-EXI file " + sourceFileName);
						System.out.println(USAGE);
						return;
				}
				// if output resultFileName not specified, pick first available .x3d file
				boolean result = loadedX3dModel.fromFileEXI(sourceFileName);
				System.out.println("load result: " + result);
				return;
			}
            else if (canonicalize) // TODO confirm whether this block is in correct place
            {
                //  open file, get scene string
                String sourceString = getFileContents(sourceFileName); // debug use

                // must pass full path to sourceFile
                if (sourceFile == null) // making sure, silence warning
                    sourceFile = new File(sourceFileName);
                // Do not use "-validate" because it employs DOM loader which fails on large models
                if (resultFileName.endsWith(".x3d")) // X3dC14n requirement, cannot end with .x3d for disambiguation
                {
                    resultFileName     = resultFileNameRoot + "Canonical.xml";
                    System.out.println("CommandLine invocation: changed resultFileName=" + resultFileName + " to meet X3dC14n requirement");
                }
                String[] invocationArguments = { sourceFile.getAbsolutePath(), resultFileName };
                System.out.println("CommandLine invocation: new X3dCanonicalizer(" + String.join(",", invocationArguments) + ")");
                X3dCanonicalizer x3dCanonicalizer = new X3dCanonicalizer(invocationArguments);
                // TODO process outputs.  Unable to process large scenes due to DOM loading?
                System.out.println("...x3dCanonicalizer.isCanonical()=" + x3dCanonicalizer.isCanonical());       // debug

                resultFile = new File(resultFileName); // unsaved
                if (resultFile == null)
                {
                       throw new org.web3d.x3d.sai.X3DException("ERROR: Failure to create resultFile " + resultFileName);
                }
                else if (resultFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
                {
                    System.out.println("Note: x3dCanonicalizer is overwriting prior file " + resultFileName);
                }
                else if  (resultFile.exists())
				{
					System.out.println ("[warning] x3dCanonicalizer is not allowed to overwrite prior file: " + resultFileName);
					System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
					return;
				}
                Path outputFilePath = Paths.get(resultFileName);
                if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
                {
                    String errorNotice = "*** [diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
                    System.out.println (errorNotice);
                }
                String outputSceneText = x3dCanonicalizer.getFinalC14nScene();
                try
                {
                    Path directoryPath = outputFilePath.getParent();
                    if ((directoryPath != null))
                         Files.createDirectories(directoryPath); // if needed
                    bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
                    bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
                    bufferedWriter.close(); // ensure file writing is complete
                    outputFilePath.toFile(); // success
                }
                catch (IOException exception)
                {
                    exception.printStackTrace();
                    throw new org.web3d.x3d.sai.X3DException("IOException for fileName " + resultFileName + ", unable to save file: " + exception);
                }
                return;
            }
            else if (convertToHTML)
            {
                System.out.println("convert to HTML files using " + ConfigurationProperties.STYLESHEET_HTML_DOCUMENTATION + ":");
                if (sourceFile == null)
                    sourceFile = new File(sourceFileName);
                if (!convertToFile) System.out.println();
                if  (convertToFile)
                       fileStylesheetConversion        (sourceFile, ConfigurationProperties.STYLESHEET_HTML_DOCUMENTATION, resultFileName);
                else System.out.println(
                       fileStylesheetConversionToString(sourceFile, ConfigurationProperties.STYLESHEET_HTML_DOCUMENTATION));
                return;
            }
            else if (convertToVRML97)
            {
                System.out.println("convert to VRML97 using " + ConfigurationProperties.STYLESHEET_VRML97 + ":");
                if (!convertToFile) System.out.println();
                if  (convertToFile)
                       fileStylesheetConversion        (sourceFile, ConfigurationProperties.STYLESHEET_VRML97, resultFileName);
                else System.out.println(
                       fileStylesheetConversionToString(sourceFile, ConfigurationProperties.STYLESHEET_VRML97));
                return;
            }
            else if (convertToClassicVRML)
            {
                System.out.println("convert to ClassicVRML using " + ConfigurationProperties.STYLESHEET_X3DV_CLASSICVRML + ":");
                if (!convertToFile) System.out.println();
                if  (convertToFile)
                       fileStylesheetConversion        (sourceFile, ConfigurationProperties.STYLESHEET_X3DV_CLASSICVRML, resultFileName);
                else System.out.println(
                       fileStylesheetConversionToString(sourceFile, ConfigurationProperties.STYLESHEET_X3DV_CLASSICVRML));
                return;
            }
            else if (convertToJava)
            {
                String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                System.out.println("convert to Java using " + ConfigurationProperties.STYLESHEET_JAVA + ":");
                if  (convertToFile)
                       fileStylesheetConversion        (sourceFile, ConfigurationProperties.STYLESHEET_JAVA, resultFileName);
                else System.out.println(
                       fileStylesheetConversionToString(sourceFile, ConfigurationProperties.STYLESHEET_JAVA));
                ConfigurationProperties.setXsltEngine(presetXsltEngine);
                return;
            }
            else if (convertToJSON)
            {
                String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                System.out.println("convert to JSON using " + ConfigurationProperties.STYLESHEET_JSON + ":");
                if  (convertToFile)
                       fileStylesheetConversion        (sourceFile, ConfigurationProperties.STYLESHEET_JSON, resultFileName);
                else System.out.println(
                       fileStylesheetConversionToString(sourceFile, ConfigurationProperties.STYLESHEET_JSON));
                ConfigurationProperties.setXsltEngine(presetXsltEngine);
                return;
            }
            else if (convertToPython)
            {
                String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                System.out.println("convert to Python using " + ConfigurationProperties.STYLESHEET_PYTHON + ":");
                if  (convertToFile)
                       fileStylesheetConversion        (sourceFile, ConfigurationProperties.STYLESHEET_PYTHON, resultFileName);
                else System.out.println(
                       fileStylesheetConversionToString(sourceFile, ConfigurationProperties.STYLESHEET_PYTHON));
                ConfigurationProperties.setXsltEngine(presetXsltEngine);
                return;
            }
            else if (convertToTidy)
            {
                System.out.println("convert to X3D Tidy cleaned-up version");
                if (!convertToFile) System.out.println();
                if  (convertToFile)
                       fileStylesheetConversion        (sourceFile, ConfigurationProperties.STYLESHEET_X3DTIDY, resultFileName);
                else System.out.println(
                       fileStylesheetConversionToString(sourceFile, ConfigurationProperties.STYLESHEET_X3DTIDY));
                return;
            }
            else if (convertToMarkdown) // model meta information
            {
                System.out.println("convert to " + conversionExtension + " model meta information markdown, include subdirectories in meta links: " + includeSubdirectoryPaths);
// TODO         loadedX3dModel.setIncludeSubdirectoryPaths(includeSubdirectoryPaths);
                if (!convertToFile) System.out.println();
                if  (convertToFile)
                       fileStylesheetConversion        (sourceFile, ConfigurationProperties.STYLESHEET_MODEL_META_TO_MARKDOWN, resultFileName);
                else System.out.println(
                       fileStylesheetConversionToString(sourceFile, ConfigurationProperties.STYLESHEET_MODEL_META_TO_MARKDOWN));
                return;
            }
			// otherwise
            System.out.println("Parsing using Document Object Model (DOM) based X3DLoaderDOM...");
            X3DLoaderDOM x3dLoader = new X3DLoaderDOM();
            boolean successfulLoad = x3dLoader.loadModelFromFileX3D(         sourceFileName);
//          boolean successfulLoad = x3dLoader.loadModelFromFileX3D(new File(sourceFileName)); // alternate form, tested OK

            if (successfulLoad && x3dLoader.isLoadSuccessful()) // two equivalent ways to check
            {
				ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version
                resultFile = new File(tempFileName); // unsaved
                try
				{
                    //debug
//                  System.out.println("loadedX3dModel initialization:");
//                  System.out.println(loadedX3dModel.toStringX3D());

                    X3DConcreteElement x3dConcreteElement = x3dLoader.getX3dObjectTree();

                    if (x3dConcreteElement instanceof X3D)
                    {
                        loadedX3dModel = (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[)x3dConcreteElement;
                    }
                    else if (x3dConcreteElement == null)
                    {
                        System.out.println(ERROR+"TODO problem with X3dLoader, x3dConcreteElement is null.");
                        return;
                    }
                    else
                    {
                        System.out.println(ERROR+"TODO problem with X3dLoader, result has type " + x3dConcreteElement.getClass().getCanonicalName());
                        return;
                    }
/* moved to direct file conversion:
                    if (convertToHTML) // pretty-print documentation
                    {
                        System.out.println("convert to " + conversionExtension + " pretty-print documentation using " + ConfigurationProperties.STYLESHEET_HTML_DOCUMENTATION + ":"");
                // TODO refactor if input file provided
                        if (!convertToFile) System.out.println();
                        if  (convertToFile)
                             resultFile =       loadedX3dModel.toFileHtmlDocumentation (resultFileName);
                        else System.out.println(loadedX3dModel.toStringHtmlDocumentation());
                    }
                    else if (convertToVRML97)
                    {
                        System.out.println("convert to VRML97 using " + ConfigurationProperties.STYLESHEET_VRML97 + ":");
                        if (!convertToFile) System.out.println();
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileVRML97 (resultFileName);
                        else System.out.println(loadedX3dModel.toStringVRML97());
                    }
                    else if (convertToClassicVRML)
                    {
                        System.out.println("convert to ClassicVRML using " + ConfigurationProperties.STYLESHEET_X3DV_CLASSICVRML + ":");
                        if (!convertToFile) System.out.println();
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileClassicVRML (resultFileName);
                        else System.out.println(loadedX3dModel.toStringClassicVRML());
                    }
                    else if (convertToJava)
                    {
                        String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                	ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                        System.out.println("convert to Java using " + ConfigurationProperties.STYLESHEET_JAVA + ":");
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileJava (resultFileName);
                        else System.out.println(loadedX3dModel.toStringJava());
                	ConfigurationProperties.setXsltEngine(presetXsltEngine);
                    }
                    else if (convertToJSON)
                    {
                        String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                	ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                        System.out.println("convert to JSON using " + ConfigurationProperties.STYLESHEET_JSON + ":");
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileJSON (resultFileName);
                        else System.out.println(loadedX3dModel.toStringJSON());
                	ConfigurationProperties.setXsltEngine(presetXsltEngine);
                    }
                    else if (convertToPython)
                    {
                        String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                	ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                        System.out.println("convert to Python using " + ConfigurationProperties.STYLESHEET_PYTHON + ":");
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFilePython (resultFileName);
                        else System.out.println(loadedX3dModel.toStringPython());
                	ConfigurationProperties.setXsltEngine(presetXsltEngine);
                    }
                    else if (convertToMarkdown) // model meta information
                    {
                        System.out.println("convert to " + conversionExtension + " model meta information markdown, include subdirectories in meta links: " + includeSubdirectoryPaths);
                        loadedX3dModel.setIncludeSubdirectoryPaths(includeSubdirectoryPaths);
                        if (!convertToFile) System.out.println();
                        if  (convertToFile)
                             resultFile =       loadedX3dModel.toFileModelMetaMarkdown (resultFileName);
                        else System.out.println(loadedX3dModel.toStringModelMetaMarkdown());
                    }
                    else if (convertToTidy)
                    {
                        System.out.println("convert to version cleaned up by X3D Tidy " + ConfigurationProperties.STYLESHEET_X3DTIDY + ":":");
                        if (!convertToFile) System.out.println();
                        if  (convertToFile)
                             resultFile =       loadedX3dModel.toFileX3dTidy (resultFileName);
                        else System.out.println(loadedX3dModel.toStringX3dTidy());
                    }
                    else
*/
                    if (convertToJS)
                    {
                        String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                	ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                        System.out.println("convert to JS JavaScript:");
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileJavaScript (resultFileName);
                        else System.out.println(loadedX3dModel.toStringJavaScript());
                	ConfigurationProperties.setXsltEngine(presetXsltEngine);
                    }
                    else if (convertToX3D)
                    {
                        System.out.println("convert to X3D:");
                        if (!convertToFile) System.out.println();
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileX3D (resultFileName);
                        else System.out.println(loadedX3dModel.toStringX3D());
                    }
                    else if (convertToXML)
                    {
                        System.out.println("convert to XML:");
                        if (!convertToFile) System.out.println();
                        if  (convertToFile)
                             resultFile =       loadedX3dModel.toFileXML (resultFileName);
                        else System.out.println(loadedX3dModel.toStringXML());
                    }
                    else if (convertToX3DOM)
                    {
                        System.out.println("convert to X3DOM using " + ConfigurationProperties.STYLESHEET_X3DOM + ":");
                        if (!convertToFile) System.out.println();
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileX3DOM (resultFileName);
                        else System.out.println(loadedX3dModel.toStringX3DOM());
                    }
                    else if (convertToX_ITE)
                    {
                        System.out.println("convert to X_ITE using " + ConfigurationProperties.STYLESHEET_X_ITE + ":");
                        if (!convertToFile) System.out.println();
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileX_ITE  (sourceFileName, resultFileName);
                        else System.out.println(loadedX3dModel.toStringX_ITE(sourceFileName));
                    }
                    else if (convertToEXI)
                    {
                        System.out.println("convert to EXI using " + ConfigurationProperties.getExiEngine() + ":");
                        System.out.println("source: " + sourceFileName + " filesize " + sourceFileLength + " bytes");
//						System.out.println("[trace] sourceFileName=" + sourceFileName + ", resultFileName=" + resultFileName);
                        resultFile = loadedX3dModel.toFileEXI (resultFileName);
						compressionRatio = formatPrecision2.format((double)resultFile.length()/(double)sourceFileLength * 100.0);
						System.out.println("result: " + resultFile.getName() + " filesize " + resultFile.length() + " bytes, compression " + compressionRatio + "% of original");
                    }
                    else if (convertToGZIP)
                    {
                        System.out.println("convert to GZIP:");
                        System.out.println("source: " + sourceFileName + " filesize " + sourceFileLength + " bytes");
//						System.out.println("[trace] sourceFileName=" + sourceFileName + ", resultFileName=" + resultFileName);
                        resultFile = loadedX3dModel.toFileGZIP (resultFileName);
						compressionRatio = formatPrecision2.format((double)resultFile.length()/(double)sourceFileLength * 100.0);
						System.out.println("result: " + resultFile.getName() + "  filesize " + resultFile.length() + " bytes, compression " + compressionRatio + "% of original");
                    }
                    else if (convertToZIP)
                    {
                        System.out.println("convert to ZIP:");
                        System.out.println("source: " + sourceFileName + " filesize " + sourceFileLength + " bytes");
//						System.out.println("[trace] sourceFileName=" + sourceFileName + ", resultFileName=" + resultFileName);
                        resultFile = loadedX3dModel.toFileZIP (resultFileName, sourceFileName);
						compressionRatio = formatPrecision2.format((double)resultFile.length()/(double)sourceFileLength * 100.0);
						System.out.println("result: " + resultFile.getName() + " filesize " + resultFile.length() + " bytes, compression " + compressionRatio + "% of original");
                    }
                    if (validateSwitch)
                    {
						// note that validation already performed as part of prior conversions
                        String outputValidationText = loadedX3dModel.validate();

                        if (!convertToFile)
                        {
                            if (outputValidationText.isEmpty())
							{
                                outputValidationText = "validate results: success, no problems noted";
								System.out.println(outputValidationText);
							}
                            else
							{
								System.out.println(    "validate results:");
								System.out.println(outputValidationText);
							}
                            return;
                        }
                        else if (convertToFile && outputValidationText.isEmpty())
                        {
                            outputValidationText = "success, no problems noted, no output file written";
                            System.out.println(outputValidationText);
                            return;
                        }
                        else if (convertToFile)
                        {
                            if (!resultFileName.endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_TEXT))
                            {
                                resultFileName += X3D.FILE_EXTENSION_TEXT;
                            }
                            Path outputFilePath = Paths.get(resultFileName);
                            String  errorNotice = new String();
                            if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
                            {
                                errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
                            }
                            System.out.println (errorNotice);

                            try // successful validation results in empty file
                            {
                                Path directoryPath = outputFilePath.getParent();
                                if ((directoryPath != null))
                                     Files.createDirectories(directoryPath); // if needed
                                bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
                                bufferedWriter.write(outputValidationText, 0, outputValidationText.length());
                                bufferedWriter.close(); // ensure file writing is complete
                                outputFilePath.toFile(); // success
                            }
                            catch (IOException exception)
                            {
                                exception.printStackTrace();
                                throw new org.web3d.x3d.sai.X3DException(ERROR+"IOException for resultFileName " + resultFileName + ", unable to save file: " + exception);
                            }
                        }
                    }
                    if      (convertToEXI || convertToGZIP || convertToZIP)
                    {
							// done
					}
                    else if (convertToFile && resultFile.exists() && !resultFile.getName().equals(tempFileName))
                             System.out.println("file conversion successful: " + resultFile.getName() + " (" + resultFile.length() + " bytes)");
                    else if (convertToFile)
                             System.out.println(ERROR+"file conversion unsuccessful!");
                    else if (validateSwitch)
                             System.out.println("model validation complete.");
                }
                catch (X3DException e)
                {
                    e.printStackTrace();
                    System.out.println(ERROR+"TODO must fix model - problem handling local exception within CommandLine, exiting.");
                //  return;
                }
            }
            else
            {
                System.out.println(ERROR+"Source model file load unsuccessful");
            //  return;
            }
		}
        // sourceFileName.isEmpty()
		else if (!loadProperties) // allow testing of properties without file operations
        {
            System.out.println(ERROR+"Source model file name is empty, therefore file loading not possible.");
        //  return;
        }
		if (resultFile.getName().equals(tempFileName))
			resultFile.delete();
    }

    /** Open X3DJSAIL Javadoc
     * @see <a href="javadoc/index.html">X3DJSAIL Javadoc (relative)</a>
     * @see <a href="https://www.web3d.org/specifications/java/javadoc/index.html">X3DJSAIL Javadoc (online)</a>
     * @see <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html">https://www.web3d.org/specifications/java/X3DJSAIL.html</a>
     */
    public static void openJavadocX3DJSAIL()
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java
        String onlineURL = ConfigurationProperties.URL_X3DJSAIL.substring(0,ConfigurationProperties.URL_X3DJSAIL.lastIndexOf("/")+1)
                                + "javadoc/index.html";
        try {
            if (Desktop.isDesktopSupported())
            {
                Desktop.getDesktop().browse(new URI("javadoc/index.html"));
            }
            else
            {
                System.out.println ("Java Desktop not supported, cannot open");
                System.out.println ("  " + onlineURL);
            }
        }
        catch (IOException | URISyntaxException e1)
        {
//         System.out.println ("Local url failure: " + e1.getMessage()); // debug
           try {
                Desktop.getDesktop().browse(new URI(onlineURL));
           }
           catch (IOException | URISyntaxException e2)
           {
                System.out.println ("URL_X3DJSAIL Javadoc: " + onlineURL);
                System.out.println ("URL_X3DJSAIL failure: " + e2.getMessage());
           }
        }
    }

    /** Open X3DJSAIL page
     * @see <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html">https://www.web3d.org/specifications/java/X3DJSAIL.html</a>
     */
    public static void openHomePageX3DJSAIL()
    {
         openHomePageX3DJSAIL (""); // relay invocation, no bookmark
    }

    /** Open X3DJSAIL page at a given bookmark
	 * @param bookmark anchor bookmark of interest for this page
     * @see <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html">https://www.web3d.org/specifications/java/X3DJSAIL.html</a>
     */
    public static void openHomePageX3DJSAIL (String bookmark)
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java
        try {
            if (Desktop.isDesktopSupported())
            {
                 if ((bookmark != null) && !bookmark.isEmpty())
                      Desktop.getDesktop().browse(new URI("X3DJSAIL.html" + "#" + bookmark));
                 else Desktop.getDesktop().browse(new URI("X3DJSAIL.html"));
            }
            else
            {
                System.out.println ("Java Desktop not supported, cannot open X3DJSAIL.html");
            }
        }
        catch (IOException | URISyntaxException e1)
        {
//         System.out.println ("Local url failure: " + e1.getMessage()); // debug
           try {
               if ((bookmark != null) && !bookmark.isEmpty())
                    Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DJSAIL + "#" + bookmark));
               else Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DJSAIL));
           }
           catch (IOException | URISyntaxException e2)
           {
               if ((bookmark != null) && !bookmark.isEmpty())
                    System.out.println ("URL_X3DJSAIL: " + ConfigurationProperties.URL_X3DJSAIL + "#" + bookmark);
               else System.out.println ("URL_X3DJSAIL: " + ConfigurationProperties.URL_X3DJSAIL);
               System.out.println ("URL_X3DJSAIL failure: " + e2.getMessage());
           }
        }
    }

    /** Open X3D Resources page
     * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html">https://www.web3d.org/x3d/content/examples/X3dResources.html</a>
     */
    public static void openX3dResourcesPage()
    {
         openX3dResourcesPage (""); // no bookmark
    }

    /** Open X3D Resources page at a given bookmark
	 * @param bookmark anchor bookmark of interest for this page
     * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html">https://www.web3d.org/x3d/content/examples/X3dResources.html</a>
     */
    public static void openX3dResourcesPage (String bookmark)
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java
        try {
            if (Desktop.isDesktopSupported())
            {
                if ((bookmark != null) && !bookmark.isEmpty())
                     Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DRESOURCES + "#" + bookmark));
                else Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DRESOURCES));
            }
        }
        catch (IOException | URISyntaxException e2)
        {
            if ((bookmark != null) && !bookmark.isEmpty())
                 System.out.println ("URL_X3DJSAIL: " + ConfigurationProperties.URL_X3DRESOURCES + "#" + bookmark);
            else System.out.println ("URL_X3DJSAIL: " + ConfigurationProperties.URL_X3DRESOURCES);

            System.out.println ("URL_X3DJSAIL failure: " + e2.getMessage());
        }
    }

    /** Open X3D Tooltips page
     * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html">X3D Tooltips</a>
     */
    public static void openX3dTooltipsPage()
    {
         openX3dTooltipsPage (""); // no bookmark
    }

    /** Open X3D Tooltips page at a given bookmark
	 * @param bookmark anchor bookmark of interest for this page
     * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html">X3D Tooltips</a>
     */
    public static void openX3dTooltipsPage (String bookmark)
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java

        try {
            if (Desktop.isDesktopSupported())
            {
                if ((bookmark != null) && !bookmark.isEmpty())
                     Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DTOOLTIPS + "#" + bookmark));
                else Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DTOOLTIPS));
            }
        }
        catch (IOException | URISyntaxException e2)
        {
            if ((bookmark != null) && !bookmark.isEmpty())
                 System.out.println ("URL_X3DTOOLTIPS: " + ConfigurationProperties.URL_X3DTOOLTIPS + "#" + bookmark);
            else System.out.println ("URL_X3DTOOLTIPS: " + ConfigurationProperties.URL_X3DTOOLTIPS );

            System.out.println ("URL_X3DTOOLTIPS failure: " + e2.getMessage());
        }
    }

    /** Open X3D Regexes page
     * @see <a href="https://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
     */
    public static void openX3dRegexesPage()
    {
         openX3dRegexesPage (""); // no bookmark
    }

    /** Open X3D Regex page at a given bookmark
	 * @param bookmark anchor bookmark of interest for this page
     * @see <a href="https://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
     * @see ConfigurationProperties#URL_X3DREGEXES
     */
    public static void openX3dRegexesPage (String bookmark)
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java

        try {
            if (Desktop.isDesktopSupported())
            {
                if ((bookmark != null) && !bookmark.isEmpty())
                     Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DREGEXES + "#" + bookmark));
                else Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DREGEXES));
            }
        }
        catch (IOException | URISyntaxException e2)
        {
            if ((bookmark != null) && !bookmark.isEmpty())
                 System.out.println ("URL_X3DREGEXES: " + ConfigurationProperties.URL_X3DREGEXES + "#" + bookmark);
            else System.out.println ("URL_X3DREGEXES: " + ConfigurationProperties.URL_X3DREGEXES );

            System.out.println ("URL_X3DREGEXES failure: " + e2.getMessage());
        }
    }

    /** Open X3D Unified Object Model (X3DUOM) page
     * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html">X3D Tooltips</a>
     */
    public static void openX3DUOMpage()
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java

        try {
            if (Desktop.isDesktopSupported())
            {
                Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DUOM));
            }
        }
        catch (IOException | URISyntaxException e2)
        {
            System.out.println ("URL_X3DUOM: " + ConfigurationProperties.URL_X3DUOM );

            System.out.println ("URL_X3DUOM failure: " + e2.getMessage());
        }
    }

    /** Open X3D Scene Authoring Hints page
     * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html">X3D Scene Authoring Hints</a>
     */
    public static void openX3dSceneAuthoringHintsPage()
    {
         openX3dSceneAuthoringHintsPage (""); // no bookmark
    }

    /** Open X3D Scene Authoring Hints page at a given bookmark
	 * @param bookmark anchor bookmark of interest for this page
     * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html">X3D Scene Authoring Hints</a>
     */
    public static void openX3dSceneAuthoringHintsPage (String bookmark)
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java

        try {
            if (Desktop.isDesktopSupported())
            {
                if ((bookmark != null) && !bookmark.isEmpty())
                     Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DSCENEAUTHORINGHINTS + "#" + bookmark));
                else Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DSCENEAUTHORINGHINTS));
            }
        }
        catch (IOException | URISyntaxException e2)
        {
            if ((bookmark != null) && !bookmark.isEmpty())
                 System.out.println ("URL_X3DSCENEAUTHORINGHINTS: " + ConfigurationProperties.URL_X3DSCENEAUTHORINGHINTS + "#" + bookmark);
            else System.out.println ("URL_X3DSCENEAUTHORINGHINTS: " + ConfigurationProperties.URL_X3DSCENEAUTHORINGHINTS );

            System.out.println ("URL_X3DSCENEAUTHORINGHINTS failure: " + e2.getMessage());
        }
    }

    /**
     * Reset all conversions switches to default (false)
     * @param newCommand provides diagnostic message when prior command gets overridden
     */
    private static void clearPriorConversionSwitches(String newCommand)
    {
        if (convertToVRML97 || convertToClassicVRML || convertToX3D    || convertToXML || convertToHTML  || convertToMarkdown ||
            convertToTidy   || convertToJava        || convertToPython || convertToJSON || convertToJS  || convertToX3DOM || convertToX_ITE)
            System.out.println(WARNING+"Prior conversion flag overridden by " + newCommand);

        convertToVRML97          = false;
        convertToClassicVRML     = false;
        convertToX3D             = false;
        convertToXML             = false;
        convertToHTML            = false;
        convertToMarkdown        = false;
        includeSubdirectoryPaths = true;  // model meta information, special switch for ModelExchange
        convertToTidy            = false;
        convertToJava            = false;
        convertToJS              = false;
        convertToJSON            = false;
        convertToPython            = false;
        convertToX3DOM           = false;
        convertToX_ITE           = false;
    }

    /**
     * Load file and apply stylesheet conversion to indicated path, return result as file.
     * @param  inputFilePath path and name of XML inputFile
     * @param stylesheetName XSLT stylesheet to apply
     * @param outputFileName path and name of resulting outputFile
     * @return output file (if any)
     */
    public static File fileStylesheetConversion(String inputFilePath, String stylesheetName, String outputFileName)
    {
        File  inputFile = new File (inputFilePath);
        return fileStylesheetConversion(inputFile, stylesheetName, outputFileName);
    }

    /**
     * Convert file using stylesheet, return result.
     * @param  inputFile XML inputFile
     * @param stylesheetName XSLT stylesheet to apply
     * @return output result (if any)
     */
    public static String fileStylesheetConversionToString(File inputFile, String stylesheetName)
    {
		String errorNotice = new String();
        String fileNameRoot  = "tempFile";
        String fileExtension = ConfigurationProperties.getExpectedOutputFileExtension(stylesheetName);
        String fileName = fileNameRoot + fileExtension;

        File outputFile;
        String resultText = new String();
        try
        {
            outputFile = File.createTempFile(fileNameRoot, fileExtension);
            if (outputFile == null)
            {
            	errorNotice += "outputFile not created: " + fileName + ", ";
            }
            else
            {
//              if (!outputFile.canWrite())
//                  errorNotice += "outputFile not writable: " + outputFile.getAbsolutePath() + ", ";
                outputFile.deleteOnExit();
            }
            fileStylesheetConversion(inputFile, stylesheetName, outputFile.getAbsolutePath());

            // https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
            // https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
//            Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

//            byte[] encoded = Files.readAllBytes(Paths.get(outputFile.getAbsolutePath()));
//            resultText = new String(encoded, charset);
            resultText = getFileContents(outputFile);
        }
        catch (IOException ex)
        {
            errorNotice += "IOException: " + ex.getMessage();
            ex.printStackTrace();
        }
        if (!errorNotice.isEmpty())
            System.out.println (errorNotice);
        return resultText;
    }

    // see toFileStylesheetConversion() for related code
    /**
     * Convert file using stylesheet, return result.
     * @param  inputFile XML inputFile
     * @param stylesheetName XSLT stylesheet to apply
     * @param outputFileName path and name of resulting outputFile
     * @return output file (if any)
     */
    public static File fileStylesheetConversion(File inputFile, String stylesheetName, String outputFileName)
    {
    // , String parameterName1, String parameterValue1, String parameterName2, String parameterValue2
        String parameterName1  = new String();
        String parameterValue1 = new String();
        String parameterName2  = new String();
        String parameterValue2 = new String();
		String errorNotice = new String();

		if ((inputFile == null || !inputFile.isFile() || !inputFile.canRead()))
		{
			throw new org.web3d.x3d.sai.X3DException("fileStylesheetConversion(inputFile, stylesheetName, outputFileName) inputFile not provided");
		}

		if ((stylesheetName == null || stylesheetName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("fileStylesheetConversion(stylesheetName, fileName) stylesheetName not provided;" +
				" (see ConfigurationProperties for allowed choices)");
		}
        else if (!ConfigurationProperties.isStylesheetSupported(stylesheetName))
		{
			throw new org.web3d.x3d.sai.X3DException("fileStylesheetConversion(stylesheetName, fileName) stylesheetName not recognized;" +
				" (see ConfigurationProperties for allowed choices)");
		}
        String expectedFileNameExtension = ConfigurationProperties.getExpectedOutputFileExtension(stylesheetName);

		if ((outputFileName == null || outputFileName.isEmpty()))
		{
			throw new org.web3d.x3d.sai.X3DException("toFileStylesheetConversionToFile(" + inputFile.getName() + "', " + stylesheetName + "', " +
                                    outputFileName + ") outputFileName not provided");
		}
		if (!((outputFileName.endsWith(expectedFileNameExtension)) || // some variations allowed
              (outputFileName.endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_XHTML)      && expectedFileNameExtension.equals(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_HTML)) ||
              (outputFileName.endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_JAVASCRIPT) && expectedFileNameExtension.equals(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_JSON))))
		{
			throw new org.web3d.x3d.sai.X3DException("outputFileName " + outputFileName + " does not end with expected extension \"" + expectedFileNameExtension + "\"");
		}

		Path outputFilePath = Paths.get(outputFileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[diagnostic] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		// https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

        File outputFile = outputFilePath.toFile();
        if (outputFile == null)
        {
                errorNotice += "outputFile not created: " + outputFilePath.getFileName() + ", ";
        }
//      else if (!outputFile.canWrite())
//              errorNotice += "outputFile not writable: " + outputFile.getAbsolutePath() + ", ";

		else if (outputFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			errorNotice += "Note: fileStylesheetConversion() is overwriting prior file " + outputFilePath;
		}
		else if  (outputFile.exists())
		{
			System.out.println ("[warning] fileStylesheetConversion() is not allowed to overwrite prior file: " + outputFilePath);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

        // convert file using stylesheet, collect result
		try // https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html
		{
            File stylesheetFile = X3D.getTempFileFromX3dJsailJar("/stylesheets", stylesheetName);
            if      (stylesheetFile == null)
				errorNotice += "Temporary stylesheet not created: " + stylesheetName + ", ";
            else if (!stylesheetFile.exists())
				errorNotice += "Temporary stylesheet not found: " + stylesheetFile.getAbsolutePath() + ", ";

            if (stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_X3DV_CLASSICVRML))
            {
                // special handling required in temp directory since STYLESHEET_X3DV_CLASSICVRML imports STYLESHEET_VRML97
                File stylesheetFile2 = X3D.getTempFileFromX3dJsailJar("/stylesheets", ConfigurationProperties.STYLESHEET_VRML97);
                if      (stylesheetFile2 == null)
                    errorNotice += "Temporary stylesheet not created: " + ConfigurationProperties.STYLESHEET_VRML97 + ", ";
                else if (!stylesheetFile2.exists())
                    errorNotice += "Temporary stylesheet not found: " + stylesheetFile2.getAbsolutePath() + ", ";

                // file copy in order to de-mung the temporary filename
                File   stylesheetFile3 = new File (stylesheetFile.getParent(), ConfigurationProperties.STYLESHEET_VRML97);
                String targetPath = stylesheetFile3.getAbsolutePath();
                if (stylesheetFile3.exists())
                    stylesheetFile3.delete(); // allow overwriting temporary-director stylesheet as needed
                Files.copy (Paths.get(stylesheetFile2.getAbsolutePath()), Paths.get(targetPath));
            }

            if (ConfigurationProperties.getXsltEngine().equals(ConfigurationProperties.XSLT_ENGINE_SAXON))
			{
				// reference: Saxon-HE 9.7 documentation and samples
				// S9APIExamples.jsail: private static class TransformA implements S9APIExamples.Test

				Processor           processor = new Processor(false);
				XsltCompiler     xsltCompiler = processor.newXsltCompiler();
				XsltExecutable xsltExecutable = xsltCompiler.compile (new StreamSource(stylesheetFile));// this call might  fail

				XdmNode source = processor.newDocumentBuilder().build(new StreamSource(inputFile));
				Serializer out = processor.newSerializer(outputFile);
				out.setOutputProperty(Serializer.Property.METHOD, "html");
				out.setOutputProperty(Serializer.Property.INDENT, "yes");
				XsltTransformer xsltTransformer = xsltExecutable.load();
				xsltTransformer.setInitialContextNode(source);
				xsltTransformer.setDestination(out);
				if (parameterName1.length() > 0)
					xsltTransformer.setParameter(new QName(parameterName1), new XdmAtomicValue(parameterValue1));
				if (parameterName2.length() > 0)
					xsltTransformer.setParameter(new QName(parameterName2), new XdmAtomicValue(parameterValue2));

                xsltTransformer.setParameter(new QName("produceSVGfigures"), new XdmAtomicValue("false"));
                xsltTransformer.transform();
			}
			else if (ConfigurationProperties.getXsltEngine().equals(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA))
			{
                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    //          factory.setNamespaceAware(true);
    //          factory.setValidating    (true);

				DocumentBuilder builder = factory.newDocumentBuilder();
				Document x3dDocument = builder.parse(inputFile);
				TransformerFactory tFactory = TransformerFactory.newInstance();
                StreamSource styleStreamSource;
                styleStreamSource = new StreamSource(stylesheetFile);// this call might  fail
				Transformer transformer = tFactory.newTransformer(styleStreamSource);
				if (parameterName1.length() > 0)
					transformer.setParameter(parameterName1, parameterValue1);
				if (parameterName2.length() > 0)
					transformer.setParameter(parameterName2, parameterValue2);
                transformer.setParameter("produceSVGfigures", "false");

				DOMSource       domSource = new DOMSource(x3dDocument);
                // https://stackoverflow.com/questions/23219728/convert-streamresult-to-string-or-xml
//                StringWriter writer = new StringWriter();
                // https://stackoverflow.com/questions/1937684/java-saving-streamresult-to-a-file
				StreamResult streamResult = new StreamResult(outputFile);
				transformer.transform(domSource, streamResult);
			}
			else // no joy
			{
				errorNotice = "Invalid ConfigurationProperties.getXsltEngine() value='" + ConfigurationProperties.getXsltEngine() +
									 "', legal values are ConfigurationProperties.XSLT_ENGINE_SAXON or ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA";
//				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
            if (!errorNotice.isEmpty())
                System.out.println (errorNotice);
            return outputFile;
		}
		catch (IOException | ParserConfigurationException | TransformerException | SAXException exception)
		{
			throw new org.web3d.x3d.sai.X3DException(errorNotice + exception.toString() + " exception when transforming and creating string, unable to save result: " + exception);
		}
		catch (SaxonApiException saxonApiException)
		{
//			Logger.getLogger(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.class.getName()).log(Level.SEVERE, null, saxonApiException);

			throw new org.web3d.x3d.sai.X3DException(errorNotice + "SaxonApiException when transforming and creating string, unable to save result: " + saxonApiException);
		}
//        String resultText = fileStylesheetConversionToString(inputFile, stylesheetName);
//
//		try // put result in outputFile
//		{
//			Path directoryPath = outputFilePath.getParent();
//			if ((directoryPath != null))
//				 Files.createDirectories(directoryPath); // if needed
//			bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
//			bufferedWriter.write(resultText, 0, resultText.length());
//			bufferedWriter.close(); // ensure file writing is complete
//			return outputFilePath.toFile(); // success
//		}
//		catch (IOException exception)
//		{
//			exception.printStackTrace();
//			throw new org.web3d.x3d.sai.X3DException("IOException for fileName " + outputFilePath + ", unable to save file: " + exception);
//		}
    }
    /**
     * Retrieve file contents as a string.
     * @param inputFileName name of file of interest
     * @return file contents as string
     */
    protected static String getFileContents (String inputFileName)
    {
        File inputFile = new File(inputFileName);
        return getFileContents (inputFile);
    }
    /**
     * Retrieve file contents as a string.
     * @param inputFile file of interest
     * @return file contents as string
     */
    protected static String getFileContents (File inputFile)
    {
        // https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
        // https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
        Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

        try
        {
            //  open file, get scene string
            byte[] encoded = Files.readAllBytes(Paths.get(inputFile.getAbsolutePath()));
            String sourceString = new String(encoded, charset);
            return sourceString;
        }
        catch (IOException ex)
        {
            ex.printStackTrace();
            String inputFileName = "[null]";
            if    (inputFile    != null)
                   inputFileName = inputFile.getPath();
            throw new org.web3d.x3d.sai.X3DException(ERROR+"CommandLine.getFileContents(" + inputFileName + ") IOException for inputFile " + inputFile + ", unable to read file: " + ex);
        }
    }
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>ConfigurationProperties</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text>
import org.web3d.x3d.jsail.Core.*;
import org.web3d.x3d.sai.InvalidFieldValueException;
import org.web3d.x3d.sai.X3DException;

import java.io.*;</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><!-- top level --></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Utility class that enables developers to set custom configuration properties when using X3D Java SAI Library (X3DJSAIL). Note use of static methods.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
* <a href="../../../../../X3DJSAIL.html#property" target="blank">Utility methods</a>
and
<a href="../../../../../X3DJSAIL.html#CommandLine" target="blank">command-line support</a>
are available to load Java .property files, such as
<a href="../../../../../X3DJSAIL.properties.template">X3DJSAIL.properties.template</a> for user preferences.
* <p>Output serialization support is provided for indentation,
<a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>,
showing default attribute values, and other custom settings.</p>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
 * @see <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html">Java Tutorials: Understanding (Static) Class Members</a>
 * @see <a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html#singleton">Java Tutorials: The Singleton Design Pattern</a>
]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
            <xsl:variable name="todaysDate">
                <xsl:value-of select="format-date(current-date(), '[D1] [MNn] [Y0001]')"/>
            </xsl:variable>
			<xsl:text disable-output-escaping="yes"><![CDATA[
        /** Default constructor */
        public ConfigurationProperties()
        {
            // avoid warning
        }

	// singleton pattern for property values

        // ==========================================================================================

	/** Default character-count increment for serializing scene output. */
	public static final int indentIncrement_DEFAULT = 2;

	private static int indentIncrement = indentIncrement_DEFAULT; // static initialization

	/** Whitespace character for indenting when serializing scene output. */
	public static final char indentCharacter_SPACE = ' ';

	/** Alternative whitespace character for indenting when serializing scene output. */
	public static final char indentCharacter_TAB   = '\t';

	/** Default character for indenting when serializing scene output, initial value is indentCharacter_SPACE. */
	public static final char indentCharacter_DEFAULT = indentCharacter_SPACE;

	private static char indentCharacter = indentCharacter_DEFAULT; // static initialization

	/** Default XML document encoding, used in the XML document declaration appearing in the first line of an XML file.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#X3D">X3D Tooltips: X3D</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	*/
	public static final String XML_ENCODING_DECLARATION_DEFAULT = "UTF-8"; // this must be exact!

	// TODO add additional encoding declarations as string constants, along with mutatable configuration property.

	/** Error message if configuration of X3DJSAIL is incorrect: CLASSPATH missing jar, or other error.
	 */
	public static final String ERROR_CONFIGURATION_X3DJSAIL = "ERROR_CONFIGURATION_X3DJSAIL";

	/** Warning message if configuration of X3DJSAIL is incorrect: properties file missing, or other error.
	 */
	public static final String WARNING_CONFIGURATION_X3DJSAIL = "WARNING_CONFIGURATION_X3DJSAIL";

	/** Warning message if model information is unexpected or missing.
	 */
	public static final String WARNING_MESSAGE = "WARNING_MESSAGE";

	/** Error message if an illegal value is provided as a method parameter.
	 */
	public static final String ERROR_ILLEGAL_VALUE = "ERROR_ILLEGAL_VALUE";

	/** Error message if an element is not currently connected to an existing scene graph object, and necessary checking  for model validation is not possible.
		Example: <i>field</i> or <i>fieldValue</i> creation may fail validation() if the field types cannot be checked in a
		corresponding <i>ProtoDeclare</i> or <i>ExternProtoDeclare</i>.
	 */
	public static final String ERROR_NOT_CONNECTED_TO_SCENE_GRAPH = "ERROR_NOT_CONNECTED_TO_SCENE_GRAPH";

	/** Error message if a field is required but no value is found.
	 */
	public static final String ERROR_VALUE_NOT_FOUND = "ERROR_VALUE_NOT_FOUND";

	/** Error message if a node is required but no reference is found.
	 */
	public static final String ERROR_NODE_NOT_FOUND = "ERROR_NODE_NOT_FOUND";

	/** Error message if incorrect field accessType value encountered.
	 * @see org.web3d.x3d.jsail.Core.field#getAccessType()
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
	 */
	public static final String ERROR_UNKNOWN_FIELD_ACCESSTYPE = "ERROR_UNKNOWN_FIELD_ACCESSTYPE";

	/** Error message if incorrect field type value encountered.
	 * @see org.web3d.x3d.jsail.Core.field#getType()
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public static final String ERROR_UNKNOWN_FIELD_TYPE = "ERROR_UNKNOWN_FIELD_TYPE";

	/** Error message if node type of ProtoDeclare is not found.
	 * @see ProtoDeclare
	 * @see ExternProtoDeclare
	 * @see ProtoInstance
	 * @see <a href="https://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/abstracts.html#InvalidProtoException">X3D SAI: B.7.13 InvalidProtoException</a>
	 */
	public static final String ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE = "ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE"; // not defined in X3D Java SAI

	/** Error message if node type of ExternProtoDeclare is not found.
	 * @see ExternProtoDeclare
	 * @see ProtoDeclare
	 * @see ProtoInstance
	 * @see <a href="https://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/abstracts.html#InvalidProtoException">X3D SAI: B.7.13 InvalidProtoException</a>
	 */
	public static final String ERROR_UNKNOWN_EXTERNPROTODECLARE_NODE_TYPE = "ERROR_UNKNOWN_EXTERNPROTODECLARE_NODE_TYPE"; // not defined in X3D Java SAI

	/** Error message if node type of ProtoInstance is not found.
	 * @see ProtoInstance
	 * @see ProtoDeclare
	 * @see ExternProtoDeclare
	 * @see <a href="https://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/abstracts.html#InvalidProtoException">X3D SAI: B.7.13 InvalidProtoException</a>
	 */
	public static final String ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE = "ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE"; // not defined in X3D Java SAI

	/** Warning message if a ProtoInstance corresponding to a given ProtoDeclare or ExternProtoDeclare is not found.
	 * @see ProtoInstance
	 * @see ProtoDeclare
	 * @see ExternProtoDeclare
	 */
	public static final String WARNING_PROTOINSTANCE_NOT_FOUND = "WARNING_PROTOINSTANCE_NOT_FOUND";

        // ==========================================================================================

	/** Default mode for debugging results, initial value is false. */
	public static boolean debugModeActive  = false;

	/** Whether SFImage pixel output values are in hexadecimal format when serializing scene output, initial value is <i>true</i>. */
	public  static final boolean SFImagePixelOutputHexadecimal_DEFAULT   = true;

	private static boolean SFImagePixelOutputHexadecimal = SFImagePixelOutputHexadecimal_DEFAULT;

	/** Whether to strip default attribute values when serializing scene output, initial value is <i>true;</i>. */
	public  static final boolean stripDefaultAttributes_DEFAULT   = true;

	private static boolean stripDefaultAttributes = stripDefaultAttributes_DEFAULT; // static initialization

	/** Set whether to allow partial output if validation exception occurs when serializing scene output, initial value is <i>false</i>. */
	public  static final boolean validationExceptionAllowed_DEFAULT   = false;

	private static boolean validationExceptionAllowed = validationExceptionAllowed_DEFAULT; // static initialization

	/** Set whether to allow partial output if validation exception occurs when creating an object, initial value is <i>true</i>. */
	public  static final boolean creationConnectionValidationExceptionAllowed_DEFAULT   = true;

	private static boolean creationConnectionValidationExceptionAllowed = creationConnectionValidationExceptionAllowed_DEFAULT;

	/** Set whether to normalize whitespace in comments, which can aid consistency in canonicalization and security; default value is <i>true</i>.
	 * @see ConfigurationProperties#setNormalizeCommentWhitespace(boolean)
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
         */
        public  static final boolean normalizeCommentWhitespace_DEFAULT   = true;

        private static boolean normalizeCommentWhitespace = normalizeCommentWhitespace_DEFAULT; // static initialization // static initialization

	/** Whether to allow overwriting previously existing files, initial value is <i>true</i>. */
	public  static final boolean overwriteExistingFiles_DEFAULT   = true;

        /** Whether to allow overwriting previously existing files, initial value is <i>true</i>. */
	private static boolean overwriteExistingFiles = overwriteExistingFiles_DEFAULT; // static initialization

        /** Whether to show console output while processing X3D model, initial value is <i>true</i>. */
	public  static final boolean consoleOutputVerbose_DEFAULT   = true;

        /** Whether to show console output while processing X3D model, initial value is <i>true</i>. */
        private static boolean consoleOutputVerbose = consoleOutputVerbose_DEFAULT; // static initialization

	// ==========================================================================================

	/** X3DJSAIL name
	 * @see <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html">https://www.web3d.org/specifications/java/X3DJSAIL.html</a> */
	public static final String NAME_X3DJSAIL     = "X3D Java Scene Access Interface Library (X3DJSAIL)";

	/** Date this version of X3DJSAIL was autogenerated: "]]></xsl:text>
            <xsl:value-of select="$todaysDate"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[".
	 * @see <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html">https://www.web3d.org/specifications/java/X3DJSAIL.html</a> */
	public static final String VERSION_DATE = "]]></xsl:text>
            <xsl:value-of select="$todaysDate"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[";

	/** X3DJSAIL documentation page
	 * @see <a href="https://www.web3d.org/specifications/java/X3DJSAIL.html">https://www.web3d.org/specifications/java/X3DJSAIL.html</a> */
	public static final String URL_X3DJSAIL     = "https://www.web3d.org/specifications/java/X3DJSAIL.html";

	/** X3D Resources documentation page
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html">https://www.web3d.org/x3d/content/examples/X3dResources.html</a> */
	public static final String URL_X3DRESOURCES = "https://www.web3d.org/x3d/content/examples/X3dResources.html";

	/** X3D Scene Authoring Hints documentation pages
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html">X3D Scene Authoring Hints</a> */
	public static final String URL_X3DSCENEAUTHORINGHINTS = "https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html";

	/** X3D Regular Expressions (regexes) documentation pages
     * @see <a href="https://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a> */
	public static final String URL_X3DREGEXES = "https://www.web3d.org/specifications/X3dRegularExpressions.html";

	/** X3D Tooltips documentation pages
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html">https://www.web3d.org/x3d/tooltips/X3dTooltips.html</a>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html#Tooltips">X3D Resources: Tooltips (multiple languages)</a> */
	public static final String URL_X3DTOOLTIPS = "https://www.web3d.org/x3d/tooltips/X3dTooltips.html";

	/** X3D Unified Object Model (X3DUOM) documentation page
	 * @see <a href="https://www.web3d.org/specifications/X3DUOM.html">X3D Unified Object Model (X3DUOM)</a> */
	public static final String URL_X3DUOM = "https://www.web3d.org/specifications/X3DUOM.html";

	/** XSLT stylesheet to create pretty-print HTML documentation page from X3D scene: <i>../lib/stylesheets/X3dToXhtml.xslt</i>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToXhtml.xslt" target="_blank">X3dToXhtml.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.html" target="_blank">examples/HelloWorldProgramOutput.html</a>
	 */
	public static final String STYLESHEET_HTML_DOCUMENTATION   = "X3dToXhtml.xslt";

	/** XSLT stylesheet to create VRML97 model from X3D scene: <i>../lib/stylesheets/X3dToVrml.xslt</i>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToVrml97.xslt" target="_blank">X3dToVrml97.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.wrl" target="_blank">examples/HelloWorldProgramOutput.wrl</a>
	 */
	public static final String STYLESHEET_VRML97   = "X3dToVrml97.xslt";

	/** XSLT stylesheet to create VRML97 model from X3D scene: <i>../lib/stylesheets/X3dToX3dvClassicVrmlEncoding.xslt</i>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToX3dvClassicVrmlEncoding.xslt" target="_blank">X3dToX3dvClassicVrmlEncoding.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.x3dv" target="_blank">examples/HelloWorldProgramOutput.x3dv</a>
	 */
	public static final String STYLESHEET_X3DV_CLASSICVRML   = "X3dToX3dvClassicVrmlEncoding.xslt";

	/** XSLT stylesheet to create model meta information as markdown: <i>../lib/stylesheets/X3dModelMetaToMarkdown.xslt</i>
	 * @see <a href="../../../../../../lib/stylesheets/X3dModelMetaToMarkdown.xslt" target="_blank">X3dModelMetaToMarkdown.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.md" target="_blank">examples/HelloWorldProgramOutput.md</a>
	 */
	public static final String STYLESHEET_MODEL_META_TO_MARKDOWN   = "X3dModelMetaToMarkdown.xslt";

	/** XSLT stylesheet to create X3D-Tidy cleaned-up version of X3D scene: <i>../lib/stylesheets/X3dToXhtml.xslt</i>
	 * @see <a href="https://www.web3d.org/x3d/stylesheets/X3dTidy.html">X3D Tidy for Scene Cleanup, Corrections and Modifications</a>
	 * @see <a href="../../../../../../lib/stylesheets/X3dTidy.xslt" target="_blank">X3dTidy.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutputTidy.x3d" target="_blank">examples/HelloWorldProgramOutputTidy.x3d</a>
	 */
	public static final String STYLESHEET_X3DTIDY   = "X3dTidy.xslt";

	/** XSLT stylesheet to create Extrusion node cross sections in SVG from X3D scene: <i>../lib/stylesheets/X3dExtrusionCrossSectionToSvg.xslt</i> */
	public static final String STYLESHEET_ExtrusionCrossSectionSVG   = "X3dExtrusionCrossSectionToSvg.xslt";

	/** XSLT stylesheet to create X3DOM XHTML page or X3DOM HTML page from X3D scene: <i>../lib/stylesheets/X3dToX3domX_ITE.xslt</i>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToX3domX_ITE.xslt" target="_blank">X3dToX3domX_ITE.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutputX_ITE.html" target="_blank">examples/HelloWorldProgramOutputX3dom.html</a>
	 */
	public static final String STYLESHEET_X3DOM    = "X3dToX3domX_ITE.xslt";

	/** XSLT stylesheet to create X_ITE XHTML page or X_ITE HTML page from X3D scene: <i>../lib/stylesheets/X3dToX3domX_ITE.xslt</i>
            TODO disambiguation needed?
	 * @see <a href="https://create3000.de/x_ite" target="_blank">X_ITE open-source X3D player</a>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToX3domX_ITE.xslt" target="_blank">X3dToX3domX_ITE.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutputX_ITE.html" target="_blank">examples/HelloWorldProgramOutputX_ITE.html</a>
	 */
	public static final String STYLESHEET_X_ITE    = "X3dToX3domX_ITE.xslt";

	/** XSLT stylesheet Cobweb (now X_ITE)
	 * @see <a href="https://create3000.de/x_ite" target="_blank">X_ITE open-source X3D player</a>
	 */
	@Deprecated
	public static final String STYLESHEET_COBWEB   = "X3dToX3domX_ITE.xslt";

	/** XSLT stylesheet to create Java source code (using X3DJSAIL library) from X3D scene: <i>../lib/stylesheets/X3dToJava.xslt</i>.
	 * TODO: documentation.
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJava.xslt" target="_blank">X3dToJava.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.java" target="_blank">examples/HelloWorldProgramOutput.java</a>
	 */
	public static final String STYLESHEET_JAVA   = "X3dToJava.xslt";

	/** XSLT stylesheet to create Javascript (ECMAScript) source code (using X3DJSAIL library) from X3D scene: <i>../lib/stylesheets/X3dToNodeJS.xslt</i>.
	 * TODO: documentation.
	 * @see <a href="../../../../../../lib/stylesheets/X3dToNodeJS.xslt" target="_blank">X3dToNodeJS.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.java" target="_blank">examples/HelloWorldProgramOutput.java</a>
	 */
	public static final String STYLESHEET_JAVASCRIPT   = "X3dToNodeJS.xslt";

	/** XSLT stylesheet to create JSON encoding from X3D scene: <i>../lib/stylesheets/X3dToJson.xslt</i>
	 * @see <a href="https://www.web3d.org/wiki/index.php/X3D_JSON_Encoding">X3D JSON Encoding</a>
	 * @see <a href="https://www.web3d.org/x3d/stylesheets/X3dToJson.html">X3D to JSON Stylesheet Converter</a>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJson.xslt" target="_blank">X3dToJson.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.json" target="_blank">examples/HelloWorldProgramOutput.json</a>
	 */
	public static final String STYLESHEET_JSON   = "X3dToJson.xslt";

	/** XSLT stylesheet to create Python source from X3D scene: <i>../lib/stylesheets/X3dToPython.xslt</i>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToPython.xslt" target="_blank">X3dToPython.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.py" target="_blank">examples/HelloWorldProgramOutput.py</a>
	 */
	public static final String STYLESHEET_PYTHON   = "X3dToPython.xslt";

    /**
     * Check whether stylesheet is supported by X3DJSAIL.
     * @param stylesheetName XSLT stylesheet to apply
     * @return whether stylesheet is supported by X3DJSAIL
     */
    public static boolean isStylesheetSupported(String stylesheetName)
    {
        return stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_HTML_DOCUMENTATION) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_JAVA) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_JAVASCRIPT) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_JSON) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_PYTHON) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_MODEL_META_TO_MARKDOWN) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_ExtrusionCrossSectionSVG) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_VRML97) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_X3DV_CLASSICVRML) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_X3DOM) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_X_ITE) ||
               stylesheetName.equalsIgnoreCase(ConfigurationProperties.STYLESHEET_X3DTIDY);
    }
    /**
     * Determine expected output filename extension based on stylesheet conversion.
     * @param stylesheetName XSLT stylesheet being applied
     * @return expected output filename extension
     */
    public static String getExpectedOutputFileExtension(String stylesheetName)
    {
        String expectedFileNameExtension = "";
        if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_ExtrusionCrossSectionSVG))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_SVG;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_HTML_DOCUMENTATION))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_HTML;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_X3DTIDY))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_X3D;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_VRML97))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_VRML97;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_X3DV_CLASSICVRML))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_CLASSICVRML;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_JAVASCRIPT))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_JAVASCRIPT;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_JAVA))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_JAVA;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_JSON))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_JSON;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_PYTHON))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_PYTHON;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_X3DOM))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_HTML;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_X_ITE))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_HTML;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_COBWEB))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_HTML;
        }
        else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_MODEL_META_TO_MARKDOWN))
        {
            expectedFileNameExtension = X3D.FILE_EXTENSION_MARKDOWN;
        }
        if (expectedFileNameExtension.isEmpty())
		{
			throw new org.web3d.x3d.sai.X3DException("getExpectedOutputFileExtension(" + stylesheetName + ") stylesheetName not recognized;" +
				" (see ConfigurationProperties for allowed choices)");
		}
        return expectedFileNameExtension;
    }

    // ==========================================================================================

	/** List of officially released X3DJSAIL jar files.X3D
	 */
        // https://stackoverflow.com/questions/21696784/how-to-declare-an-arraylist-with-values
        public static final ArrayList<String> X3DJSAIL_JAR_RELEASE_VERSIONS =
            new ArrayList<>(Arrays.asList("X3DJSAIL.4.0.classes.jar", "X3DJSAIL.4.0.full.jar","X3DJSAIL.3.3.classes.jar", "X3DJSAIL.3.3.full.jar"));

    // ==========================================================================================

	/** Whether to delete intermediate files generated as part of various transformations, this property can be helpful for debugging. */
	private static final boolean deleteIntermediateFiles_DEFAULT = true;

	/** Whether to delete intermediate files generated as part of various transformations, this property can be helpful for debugging. */
	private static boolean deleteIntermediateFiles = deleteIntermediateFiles_DEFAULT;

	/** Indicate whether to delete intermediate files generated as part of various transformations, this property method can be helpful can be helpful for debugging.
	 * @return configuration setting whether intermediate files are deleted
	 */
	public static final boolean isDeleteIntermediateFiles()
	{
		return deleteIntermediateFiles;
	}
	/** Set whether to delete intermediate files generated as part of various transformations, this property method can be helpful can be helpful for debugging.
	 * @param newValue is new value to assign
	 */
	public static final void setDeleteIntermediateFiles(boolean newValue)
	{
		deleteIntermediateFiles = newValue;
	}
    // ==========================================================================================

	/** Whether to omit trailing zeros from floating-point or double-precision output. */
	private static final boolean stripTrailingZeroes_DEFAULT = true;

	/** Whether to omit trailing zeros from floating-point or double-precision output. */
	private static boolean stripTrailingZeroes = stripTrailingZeroes_DEFAULT;

	/** Indicates whether trailing zeros are omitted from output of floating-point or double-precision values, this property can be helpful for debugging.
	 * @return configuration setting whether trailing zeros are stripped
	 */
	public static final boolean isStripTrailingZeroes()
	{
		return stripTrailingZeroes;
	}
	/** Set whether to omit trailing zeros from floating-point or double-precision output, this property can be helpful for debugging.
	 * @param newValue is new value to assign
	 */
	public static final void setStripTrailingZeroes(boolean newValue)
	{
		stripTrailingZeroes = newValue;
	}
    // ==========================================================================================

	/** XSLT transformation engine: SAXON (default).
	 * @see <a href="https://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://sourceforge.net/projects/saxon/files">Saxon distribution</a>
	 * @see <a href="https://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 */
	public static final String XSLT_ENGINE_SAXON = "SAXON9HE";

	/** XSLT transformation engine: native Java.
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 */
	public static final String XSLT_ENGINE_NATIVE_JAVA = "NATIVE_JAVA";

	/** XSLT transformation engine setting: default <i>XSLT_ENGINE_SAXON</i>. */
	private static String xsltEngine = XSLT_ENGINE_SAXON;

	/** Get preference for XSLT transformation engine to use: {@link XSLT_ENGINE_SAXON} or {@link XSLT_ENGINE_NATIVE_JAVA}.
	 * @return String constant regarding current configuration: XSLT_ENGINE_SAXON (default) or XSLT_ENGINE_NATIVE_JAVA
	 */
	public static final String getXsltEngine()
	{
		return xsltEngine;
	}
	/** Set preference for XSLT transformation engine to use: {@link XSLT_ENGINE_SAXON} or {@link XSLT_ENGINE_NATIVE_JAVA}.
	 * @param newValue is new value to assign */
	public static final void setXsltEngine(String newValue)
	{
		if (newValue.equals(XSLT_ENGINE_SAXON) || newValue.equals(XSLT_ENGINE_NATIVE_JAVA))
			xsltEngine = newValue;
		else
		{
			String errorNotice = "*** Invalid setXsltEngine(String newValue) invocation, newValue='" + newValue +
								 "', legal values are ConfigurationProperties.XSLT_ENGINE_SAXON or ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}
    // ==========================================================================================

	/** EXI transformation engine: OpenEXI Nagasena.
	 * <i>Warning:</i> testing in progress.
	 * @see <a href="https://openexi.sourceforge.net">OpenEXI Nagasena</a>
	 * @see <a href="https://openexi.sourceforge.net/tutorial">Nagasena Tutorial</a>
	 * @see <a href="https://www.youtube.com/watch?v=Rig2z9veUv0">Video: OpenEXI, A Quick Introduction</a>
	 * @see ConfigurationProperties#getExiEngine()
	 * @see ConfigurationProperties#setExiEngine(String)
	 * @see ConfigurationProperties#EXI_ENGINE_EXIFICIENT
	 */
	public static final String EXI_ENGINE_OPENEXI = "OPENEXI";

	/** XSLT transformation engine: EXIficient (default).
	 * @see <a href="https://github.com/EXIficient">EXIficient project page</a>
	 * @see <a href="https://github.com/EXIficient/exificient/blob/master/README.md">EXIficient README</a>
	 * @see ConfigurationProperties#getExiEngine()
	 * @see ConfigurationProperties#setExiEngine(String)
	 * @see ConfigurationProperties#EXI_ENGINE_OPENEXI
	 */
	public static final String EXI_ENGINE_EXIFICIENT = "EXIFICIENT";

	/** EXI transformation engine setting: default <i>EXI_ENGINE_EXIFICIENT</i>. */
	private static String exiEngine = EXI_ENGINE_EXIFICIENT;

	/** Get preference for XSLT transformation engine to use: {@link EXI_ENGINE_EXIFICIENT} or {@link EXI_ENGINE_OPENEXI}.
	 * @return String constant regarding current configuration: EXI_ENGINE_EXIFICIENT} (default) or EXI_ENGINE_OPENEXI
	 * @see ConfigurationProperties#EXI_ENGINE_EXIFICIENT
	 * @see ConfigurationProperties#EXI_ENGINE_OPENEXI
	 * @see ConfigurationProperties#setExiEngine(String)
	 */
	public static final String getExiEngine()
	{
		return exiEngine;
	}
	/** Set preference for EXI transformation engine to use: {@link EXI_ENGINE_EXIFICIENT} or {@link EXI_ENGINE_OPENEXI}.
	 * @param newValue is new value to assign
	 * @see ConfigurationProperties#EXI_ENGINE_EXIFICIENT
	 * @see ConfigurationProperties#EXI_ENGINE_OPENEXI
	 * @see ConfigurationProperties#getExiEngine()
     */
	public static final void setExiEngine(String newValue)
	{
		if (newValue.equals(EXI_ENGINE_EXIFICIENT) || newValue.equals(EXI_ENGINE_OPENEXI))
			exiEngine = newValue;
		else
		{
			String errorNotice = "*** Invalid setExiEngine(String newValue) invocation, newValue='" + newValue +
								 "', legal values are ConfigurationProperties.EXI_ENGINE_EXIFICIENT or ConfigurationProperties.EXI_ENGINE_OPENEXI";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}

    // ==========================================================================================

	/** Initialize this ConfigurationProperties instance to default values. */
	public static final void initialize()
	{
		indentIncrement               = indentIncrement_DEFAULT;
		indentCharacter               = indentCharacter_DEFAULT;
		SFImagePixelOutputHexadecimal = SFImagePixelOutputHexadecimal_DEFAULT;
		stripDefaultAttributes        = stripDefaultAttributes_DEFAULT;
		validationExceptionAllowed    = validationExceptionAllowed_DEFAULT;
		deleteIntermediateFiles       = deleteIntermediateFiles_DEFAULT;
		stripTrailingZeroes	      = stripTrailingZeroes_DEFAULT;
		normalizeCommentWhitespace    = normalizeCommentWhitespace_DEFAULT;
		overwriteExistingFiles        = overwriteExistingFiles_DEFAULT;
		consoleOutputVerbose          = consoleOutputVerbose_DEFAULT;
		setExiEngine (EXI_ENGINE_EXIFICIENT);
		setXsltEngine(XSLT_ENGINE_SAXON);
	}

	/** Default name of properties file: <code>X3DJSAIL.properties</code>
	 * @see ConfigurationProperties#getPropertiesFileName()
	 * @see ConfigurationProperties#setPropertiesFileName(String)
	 * @see ConfigurationProperties#loadProperties()
	 */
	public static final String PROPERTIES_FILENAME_DEFAULT = "X3DJSAIL.properties";

	/** Name of properties file. */
	private static String propertiesFileName = PROPERTIES_FILENAME_DEFAULT;

	/** Set name of properties file (optional directory path plus file name).
	 * @see ConfigurationProperties#PROPERTIES_FILENAME_DEFAULT
	 * @see ConfigurationProperties#getPropertiesFileName()
	 * @see ConfigurationProperties#loadProperties()
	 * @param fileName new name of properties file to load and parse
	 */
	public static void setPropertiesFileName(String fileName)
	{
		propertiesFileName = fileName;
	}

	/** Get name of current properties file (optional directory path plus file name).
	 * @see ConfigurationProperties#PROPERTIES_FILENAME_DEFAULT
	 * @see ConfigurationProperties#setPropertiesFileName(String)
	 * @see ConfigurationProperties#loadProperties()
	 * @return name of properties file to load and parse
	 */
	public static String getPropertiesFileName()
	{
		return propertiesFileName;
	}

	/** Update settings in this ConfigurationProperties instance using values in property file.
	 * @see ConfigurationProperties#PROPERTIES_FILENAME_DEFAULT
	 * @see ConfigurationProperties#getPropertiesFileName()
	 * @see ConfigurationProperties#setPropertiesFileName(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/environment/properties.html">Java Tutorials: Properties</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html">Javadoc: java.util.Properties</a>
	 */
	public static void loadProperties()
	{
		// create and load default properties
		Properties loadedProperties = new Properties();
		try {
			File propertiesFile = new File(getPropertiesFileName());
			if (!propertiesFile.exists())
			{
				System.out.println (WARNING_CONFIGURATION_X3DJSAIL + ": " + getPropertiesFileName() + " properties file not found");
			}
			FileInputStream propertiesFileInputStream = new FileInputStream(propertiesFile);
			loadedProperties.load(propertiesFileInputStream);
			propertiesFileInputStream.close();
		}
		catch (IOException ioe)
		{
            System.out.println (ERROR_CONFIGURATION_X3DJSAIL + ": " + ioe.getMessage());
            ioe.printStackTrace(); // further diagnosis needed
		}
		System.out.print (getPropertiesFileName() + " includes " + loadedProperties.size());
		if (loadedProperties.isEmpty())
			System.out.println (" properties");
		else if (loadedProperties.size() == 1)
			System.out.println (" property:");
		else
			System.out.println (" properties:");
		loadedProperties.list(System.out);

		if (loadedProperties.size() > 0)
		{
			if (loadedProperties.contains("indentIncrement"))
				indentIncrement = Integer.getInteger(loadedProperties.getProperty("indentIncrement"));
			if (loadedProperties.contains("indentCharacter"))
			{
				String indentCharacterProperty = loadedProperties.getProperty("indentCharacter");
				if		(indentCharacterProperty.toUpperCase().contains("SPACE"))
						 indentCharacter = indentCharacter_SPACE;
				else if (indentCharacterProperty.toUpperCase().contains("TAB"))
						 indentCharacter = indentCharacter_SPACE;
				else if (!indentCharacterProperty.isEmpty())
					System.out.println ("Error: unrecognized property indentCharacter='" + indentCharacterProperty +
						"' (allowed values are SPACE and TAB)");
			}
			// warning: properties are case sensitive
			// https://stackoverflow.com/questions/86780/how-to-check-if-a-string-contains-another-string-in-a-case-insensitive-manner-in

			if (loadedProperties.contains("SFImagePixelOutputHexadecimal"))
				SFImagePixelOutputHexadecimal = Boolean.getBoolean(loadedProperties.getProperty("SFImagePixelOutputHexadecimal"));
            if (loadedProperties.contains("showDefaultAttributes")) // original name, convert it
            {
				stripDefaultAttributes = !Boolean.getBoolean(loadedProperties.getProperty("showDefaultAttributes"));
                System.out.println ("[warning] legacy property showDefaultAttributes='" + !stripDefaultAttributes +
                    "' found, changed to stripDefaultAttributes='" + stripDefaultAttributes + "' instead");
            }
			if (loadedProperties.contains("stripDefaultAttributes"))
				stripDefaultAttributes = Boolean.getBoolean(loadedProperties.getProperty("stripDefaultAttributes"));
			if (loadedProperties.contains("validationExceptionAllowed"))
		     validationExceptionAllowed = Boolean.getBoolean(loadedProperties.getProperty("validationExceptionAllowed"));
			if (loadedProperties.contains("deleteIntermediateFiles"))
				deleteIntermediateFiles = Boolean.getBoolean(loadedProperties.getProperty("deleteIntermediateFiles"));
			if (loadedProperties.contains("stripTrailingZeroes"))
				stripTrailingZeroes = Boolean.getBoolean(loadedProperties.getProperty("stripTrailingZeroes"));
			if (loadedProperties.contains("normalizeCommentWhitespace"))
				normalizeCommentWhitespace = Boolean.getBoolean(loadedProperties.getProperty("normalizeCommentWhitespace"));
			if (loadedProperties.contains("overwriteExistingFiles"))
				overwriteExistingFiles = Boolean.getBoolean(loadedProperties.getProperty("overwriteExistingFiles"));
			if (loadedProperties.contains("consoleOutputVerbose"))
				consoleOutputVerbose   = Boolean.getBoolean(loadedProperties.getProperty("consoleOutputVerbose"));

			if      (loadedProperties.contains("EXI_ENGINE") && loadedProperties.getProperty("EXI_ENGINE").toUpperCase().contains("EXIFICIENT"))
					setExiEngine (EXI_ENGINE_EXIFICIENT);
			else if (loadedProperties.contains("EXI_ENGINE") && loadedProperties.getProperty("EXI_ENGINE").toUpperCase().contains("OPENEXI"))
					setExiEngine (EXI_ENGINE_OPENEXI);
			else if (loadedProperties.contains("EXI_ENGINE"))
					System.out.println ("Error: unrecognized property EXI_ENGINE=" + loadedProperties.getProperty("EXI_ENGINE") +
						"' (allowed values are EXIFICIENT and OPENEXI)");

			if      (loadedProperties.contains("XSLT_ENGINE") && loadedProperties.getProperty("EXI_ENGINE").toUpperCase().contains("SAXON"))
					setXsltEngine(XSLT_ENGINE_SAXON);
			else if (loadedProperties.contains("XSLT_ENGINE") && loadedProperties.getProperty("EXI_ENGINE").toUpperCase().contains("NATIVE_JAVA"))
					setXsltEngine(XSLT_ENGINE_NATIVE_JAVA);
			else if (loadedProperties.contains("XSLT_ENGINE"))
					System.out.println ("Error: unrecognized property XSLT_ENGINE=" + loadedProperties.getProperty("XSLT_ENGINE") +
						"' (allowed values are SAXON and NATIVE_JAVA)");

			if      (loadedProperties.contains("BLENDER_PATH"))
					BlenderLauncher.setBlenderPath(loadedProperties.getProperty("BLENDER_PATH"));
			if      (loadedProperties.contains("MESHLAB_PATH"))
					MeshLabLauncher.setMeshLabPath(loadedProperties.getProperty("MESHLAB_PATH"));

		}
		System.out.println ("------------------------");
		System.out.println (getPropertiesFileName() + " loading complete.");
	}

	/**
	 * Get current system CLASSPATH value.  Note that a current version of X3DJSAIL.*.jar is expected to be in the current CLASSPATH.
	 * @see <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/classpath.html">Java documentation: Setting the Class Path</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">Java Tutorials: PATH and CLASSPATH</a>
	 * @return system CLASSPATH value. */
	public static String getClassPath()
	{
		return System.getProperty("java.class.path");
	}
	/**
	 * Get indentCharacter used when serializing scene output.
	 * @see #setIndentCharacter(char)
	 * @see #setIndentIncrement(int)
	 * @return indentCharacter (either indentCharacter_SPACE or indentCharacter_TAB). */
	public static char getIndentCharacter()
	{
		return indentCharacter;
	}
	/**
	 * Set indentCharacter used when serializing scene output.
	 * @param newIndentCharacter is new indent value (non-negative).
	 * @see #setX3dCanonicalForm() */
	public static void setIndentCharacter (char newIndentCharacter)
	{
		if  ((newIndentCharacter == indentCharacter_SPACE) || (newIndentCharacter == indentCharacter_TAB))
			 indentCharacter = newIndentCharacter;
		else
		{
			String errorNotice = "*** Invalid indentCharacter='" + newIndentCharacter +
								 "' provided to ConfigurationProperties, expected indentCharacter_SPACE or indentCharacter_TAB";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}
	/**
	 * Get number of indent characters (space or tab characters) to indent when serializing scene output.
	 * @see #setIndentCharacter(char)
	 * @see #setIndentIncrement(int)
	 * @return number of characters (non-negative). */
	public static int getIndentIncrement()
	{
		return indentIncrement;
	}
	/**
	 * Set number of characters to indent when serializing scene output.
	 * @param newIndentIncrement is new indentIncrement value (non-negative).
	 * @see #setX3dCanonicalForm() */
	public static void setIndentIncrement (int newIndentIncrement)
	{
		if  (newIndentIncrement >= 0)
			 indentIncrement = newIndentIncrement;
		else
		{
			indentIncrement = 0;
			String errorNotice = "*** Invalid indentIncrement=" + indentIncrement + " provided to ConfigurationProperties";
//			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
	}]]></xsl:text><xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Indicate whether X3D Canonical Form is used for toStringX3D() XML output.
	 * @see #setIndentCharacter(char)
	 * @see #setIndentIncrement(int)
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed binary encoding, 4.2.3 X3D canonical form</a>
	 * @see <a href="https://www.w3.org/TR/xml-c14n">Canonical XML</a>
	 * @see <a href="https://www.w3.org/TR/exi-c14n">Canonical EXI</a>
	 * @see <a href="https://santuario.apache.org">Apache Santuario</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
	 * @return whether X3D Canonical Form is used. */
	public static boolean isX3dCanonicalForm()
	{
		return ((indentIncrement == indentIncrement_DEFAULT) &&
			    (indentCharacter == indentCharacter_DEFAULT));
	}
	/**
	 * Ensure that X3D Canonical Form is used for XML output, resetting default values for indentation.
	 * @see #setIndentIncrement(int)
	 * @see #setIndentCharacter(char)
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed binary encoding, 4.2.3 X3D canonical form</a>
	 * @see <a href="https://www.w3.org/TR/xml-c14n">Canonical XML</a>
	 * @see <a href="https://www.w3.org/TR/exi-c14n">Canonical EXI</a>
	 * @see <a href="https://santuario.apache.org">Apache Santuario</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
	 */
	public static void setX3dCanonicalForm()
	{
		indentIncrement = indentIncrement_DEFAULT;
		indentCharacter = indentCharacter_DEFAULT;
	}
	/**
	 * Indicate whether debug mode is active.
	 * @return whether debug mode is active. */
	public static boolean isDebugModeActive()
	{
		return debugModeActive;
	}
	/**
	 * Set whether debug mode is active.
	 * @param newDebugModeActive whether debug mode is active. */
	public static void setDebugModeActive(boolean newDebugModeActive)
	{
		debugModeActive = newDebugModeActive;
	}
	/**
	 * Indicate whether SFImage pixel output values are in hexadecimal format when serializing scene output.
	 * @return whether default attributes are shown. */
	public static boolean isSFImagePixelOutputHexadecimal()
	{
		return SFImagePixelOutputHexadecimal;
	}
	/**
	 * Set whether SFImage pixel output values are in hexadecimal format when serializing scene output.
	 * @param newSFImagePixelOutputHexadecimal whether SFImage pixel output values are in hexadecimal format. */
	public static void setSFImagePixelOutputHexadecimal(boolean newSFImagePixelOutputHexadecimal)
	{
		SFImagePixelOutputHexadecimal = newSFImagePixelOutputHexadecimal;
	}
	/**
	 * Indicate whether default attributes (and their values) are stripped when serializing scene output.
	 * @return whether default attributes are shown. */
	public static boolean getStripDefaultAttributes()
	{
		return stripDefaultAttributes;
	}
	/**
	 * Set whether default attributes (and their values) are stripped when serializing scene output.
	 * @param newStripDefaultAttributes whether default attributes are shown. */
	public static void setStripDefaultAttributes(boolean newStripDefaultAttributes)
	{
		stripDefaultAttributes = newStripDefaultAttributes;
	}
	/**
	 * Indicate whether partial results are allowed if validation exception occurs when serializing scene output.
	 * @return whether validation exceptions are allowed (and operation continues) */
	public static boolean isValidationExceptionAllowed()
	{
		return validationExceptionAllowed;
	}
	/**
	 * Set whether partial results are allowed (and operation continues) if validation exception occurs when serializing scene output.
	 * Can be useful technique for debugging, default value is <i>false</i> for strict operation.
	 * <i>Warning:</i> setting value to <i>true</i> permits creation of an invalid scene graph.
	 * @param newValidationExceptionAllowed whether validation exceptions are allowed (and operation continues) */
	public static void setValidationExceptionAllowed(boolean newValidationExceptionAllowed)
	{
		validationExceptionAllowed = newValidationExceptionAllowed;
	}
	/**
	 * Indicate whether continuation is allowed if validation exception occurs when creating an object.
	 * <i>Warning:</i> TODO experimental.
	 * @return whether validation exceptions are allowed (and operation continues) during object creation */
	public static boolean isCreationConnectionValidationExceptionAllowed()
	{
		return creationConnectionValidationExceptionAllowed;
	}
	/**
	 * Set whether partial results are allowed (and operation continues) if validation exception occurs when creating an object.
	 * Can be useful technique for debugging, default value is <i>true</i> for permissive order of object creation.
	 * <i>Warning:</i> be sure to validate() this scene once construction is complete.
	 * <i>Warning:</i> TODO experimental.
	 * @param newCreationConnectionValidationExceptionAllowed whether validation exceptions are allowed (and object creation continues) */
	public static void setCreationConnectionValidationExceptionAllowed(boolean newCreationConnectionValidationExceptionAllowed)
	{
		creationConnectionValidationExceptionAllowed = newCreationConnectionValidationExceptionAllowed;
	}
	/**
	 * Indicate whether to normalize whitespace in comments, which can aid consistency in canonicalization and security.
	 * @see ConfigurationProperties#normalizeCommentWhitespace_DEFAULT
	 * @see ConfigurationProperties#setNormalizeCommentWhitespace(boolean)
	 * @return whether to normalize whitespace in comments */
	public static boolean isNormalizeCommentWhitespace()
	{
		return normalizeCommentWhitespace;
	}
	/**
	 * Set whether to normalize whitespace in comments, which can aid consistency in canonicalization and security.
	 * @see ConfigurationProperties#normalizeCommentWhitespace_DEFAULT
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
	 * @param newNormalizeCommentWhitespace whether to normalize whitespace in comments */
	public static void setNormalizeCommentWhitespace(boolean newNormalizeCommentWhitespace)
	{
		normalizeCommentWhitespace = newNormalizeCommentWhitespace;
	}
	/**
	 * Indicate whether to allow overwriting previously existing files.
	 * @see overwriteExistingFiles_DEFAULT
	 * @return whether creation of new files can overwrite prior versions */
	public static boolean isOverwriteExistingFiles()
	{
		return overwriteExistingFiles;
	}
	/**
	 * Set whether to allow overwriting previously existing files.
	 * @see overwriteExistingFiles_DEFAULT
	 * @param newOverwriteExistingFiles whether creation of new files can overwrite prior versions */
	public static void setOverwriteExistingFiles(boolean newOverwriteExistingFiles)
	{
		overwriteExistingFiles = newOverwriteExistingFiles;
	}

        /** Get whether to show console output while processing X3D model
          * @return whether console output is verbose */
	public static boolean isConsoleOutputVerbose()
	{
            return consoleOutputVerbose;
	}
        /** Set whether to show console output while processing X3D model
	 * @see consoleOutputVerbose_DEFAULT
	 * @param newConsoleOutputVerbose whether to show console output while processing X3D model */
	public static void setConsoleOutputVerbose(boolean newConsoleOutputVerbose)
	{
            consoleOutputVerbose = newConsoleOutputVerbose;
	}
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>X3DConcreteElement</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Topmost abstract parent class for concrete X3D nodes and statements, containing common methods and member variables.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[

	/** the <i>id</i> attribute on each X3D node is considered a unique identifier when used as part of an encompassing HTML/DOM context.
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a> */
	private String htmlID = ID_DEFAULT_VALUE;

	/** The <i>class</i> field is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a> */
	private String cssClass = CLASS_DEFAULT_VALUE;

	/** The <i>style</i> field provides an inline block of CSS for element styling, reserved for use by CSS cascading stylesheets.
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a> */
	private String cssStyle = STYLE_DEFAULT_VALUE;

	/** SFString field named <i>id</i> for html has default value equal to an empty string. */
	public static final String ID_DEFAULT_VALUE = "";

	/** SFString field named <i>class</i> for CSS has default value equal to an empty string. */
	public static final String CLASS_DEFAULT_VALUE = "";

	/** SFString field named <i>style</i> for CSS has default value equal to an empty string. */
	public static final String STYLE_DEFAULT_VALUE = "";

	/** Initialize all member variables to default values. */
	public void initialize()
	{
		setParent(null);
		// no super to initialize, we are at the top of the hierarchy
          htmlID =    ID_DEFAULT_VALUE;
		cssClass = CLASS_DEFAULT_VALUE;
		cssStyle = STYLE_DEFAULT_VALUE;
	}

	/** Protected internal superclass method to keep cssClass private, scene authors should use method setCssClass(newValue) instead.
	 * This attribute is only functional if the X3D model is loaded within an HTML page.
	 * <i>Tooltip:</i> The class attribute is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @see <a href="https://www.w3.org/TR/css-2018">W3C CSS Snapshot</a>
	 * @see <a href="https://en.wikibooks.org/wiki/XML_-_Managing_Data_Exchange/XSLT_and_Style_Sheets">Wikibooks: XML - Managing Data Exchange/XSLT and Style Sheets</a>
	 * @param newValue is new value for the class field.
	 */
	protected void setConcreteCssClass(String newValue)
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA) #4
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment
		cssClass = newValue;
	}
	/** Protected internal superclass method to keep HTML id private, scene authors should use method setHtmlID(newValue) instead.
	 * This attribute is only functional if the X3D model is loaded within an HTML page.
	 * <i>Tooltip:</i> the id attribute on each X3D node is considered a unique identifier when used as part of an encompassing HTML/DOM context.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
     * <br />
     * <i>Warning:</i> the id attribute is in a distinct separate namespace from DEF identifiers and thus not applicable for USE nodes, ROUTE statements, or Script references.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#ContentDefinitionPagePresentation">X3D Architecture Annex L - HTML authoring guidelines, L.3.1 Content definition and page presentation</a>
	 * @see <a href="https://www.w3.org/TR/html52">HTML 5.2</a> W3C Recommendation
	 * @see <a href="https://www.w3.org/DOM/DOMTR">Document Object Model (DOM) Technical Reports</a>
	 * @see <a href="https://en.wikibooks.org/wiki/XML_-_Managing_Data_Exchange/XSLT_and_Style_Sheets">Wikibooks: XML - Managing Data Exchange/XSLT and Style Sheets</a>
	 * @param newValue is new value for the id field.
	 */
	protected void setConcreteHtmlID(String newValue)
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA) #4
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment
		htmlID = newValue;
	}
	/** Protected internal superclass method to keep cssStyles private, scene authors should use method setCssStyle(newValue) instead.
	 * This attribute is only functional if the X3D model is loaded within an HTML page.
	 * <i>Tooltip:</i> The style attribute is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @see <a href="https://www.w3.org/TR/css-2018">W3C CSS Snapshot</a>
	 * @see <a href="https://en.wikibooks.org/wiki/XML_-_Managing_Data_Exchange/XSLT_and_Style_Sheets">Wikibooks: XML - Managing Data Exchange/XSLT and Style Sheets</a>
	 * @param newValue is new value for the style field.
	 */
	protected void setConcreteCssStyle(String newValue)
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA) #4
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment
		cssStyle = newValue;
	}
	/**
	 * Provide String value from inputOutput SFString field named <i>id</i>.
	 * <br><br>
	 * <i>Tooltip:</i> the id attribute on each X3D node is considered a unique identifier when used as part of an encompassing HTML/DOM context.The class field is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @see <a href="https://www.w3.org/TR/css-2018">W3C CSS Snapshot</a>
	 * @see <a href="https://en.wikibooks.org/wiki/XML_-_Managing_Data_Exchange/XSLT_and_Style_Sheets">Wikibooks: XML - Managing Data Exchange/XSLT and Style Sheets</a>
	 * @return value of class field
	 */
	public String getHtmlID()
	{
		return htmlID;
	}
	/**
	 * Provide String value from inputOutput SFString field named <i>class</i>.
	 * <br><br>
	 * <i>Tooltip:</i> The class field is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @see <a href="https://www.w3.org/TR/css-2018">W3C CSS Snapshot</a>
	 * @see <a href="https://en.wikibooks.org/wiki/XML_-_Managing_Data_Exchange/XSLT_and_Style_Sheets">Wikibooks: XML - Managing Data Exchange/XSLT and Style Sheets</a>
	 * @return value of class field
	 */
	public String getCssClass()
	{
		return cssClass;
	}
	/**
	 * Provide String value from inputOutput SFString field named <i>style</i>.
	 * <br><br>
	 * <i>Tooltip:</i> The style field provides an inline block of CSS for element styling, reserved for use by CSS cascading stylesheets.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @see <a href="https://www.w3.org/TR/css-2018">W3C CSS Snapshot</a>
	 * @see <a href="https://en.wikibooks.org/wiki/XML_-_Managing_Data_Exchange/XSLT_and_Style_Sheets">Wikibooks: XML - Managing Data Exchange/XSLT and Style Sheets</a>
	 * @return value of style field
	 */
	public String getCssStyle()
	{
		return cssStyle;
	}

	/** Results log of local validation. */
	protected StringBuilder validationResult = new StringBuilder();

	/**
	 * Add comment as String to contained commentsList.
	 * @param newComment initial value
	 * @return <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public abstract X3DConcreteElement addComments (String newComment);

	/**
	 * Debug support: adding empty comment as CommentsBlock to children field has no effect.
	 * @return <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public X3DConcreteElement addComments()
	{
		return this;
	}

	/**
	 * Add comments as String[] array to contained commentsList.
	 * @param newComments array of comments
	 * @return <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public abstract X3DConcreteElement addComments (String[] newComments);

	/**
	 * Add CommentsBlock to element
	 * @param newCommentsBlock block of comments to add
	 * @return <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public abstract X3DConcreteElement addComments (CommentsBlock newCommentsBlock);

	/** Get output of results from prior validation, if any
	 * @return validation results (if any)
	 */
	public String getValidationResult()
	{
		return validationResult.toString();
	}

	/**
	 * Recursive method to provide X3D string serialization of this model subgraph, utilizing XML encoding and conforming to X3D Canonical Form.
	 * @see X3D#FILE_EXTENSION_X3D
	 * @see X3D#FILE_EXTENSION_XML
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
	 * @return X3D string
	 */
	public String toStringX3D()
	{
		return toStringX3D(0); // apply next method with initial indentation level 0
	}

	/**
	 * Recursive method to provide X3D string serialization of this model subgraph, utilizing XML encoding and conforming to X3D Canonical Form.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3D#FILE_EXTENSION_X3D
	 * @see X3D#FILE_EXTENSION_XML
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @see <a href="https://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
	 * @return X3D string
	 */
	abstract public String toStringX3D(int indentLevel); // must be overridden

	/**
	 * Recursive method to provide ClassicVRML string serialization.
	 * @see X3D#FILE_EXTENSION_CLASSICVRML
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/X3D_ClassicVRML.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/grammar.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding, Annex A: Grammar</a>
	 * @return ClassicVRML string
	 */
	public String toStringClassicVRML()
	{
		return toStringClassicVRML(0); // apply next method with initial indentation level 0
	}

	/**
	 * Recursive method to provide ClassicVRML string serialization.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3D#FILE_EXTENSION_CLASSICVRML
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/X3D_ClassicVRML.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/grammar.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding, Annex A: Grammar</a>
	 * @return ClassicVRML string
	 */
	abstract public String toStringClassicVRML(int indentLevel); // must be overridden

	/**
	 * Recursive method to provide VRML97 string serialization.
	 * @see X3D#FILE_EXTENSION_VRML97
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/14772/V2.0/index.html">Virtual Reality Modeling Language (VRML) 97 specification</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/14772-1/V2.1/index.html">VRML 97 v2.1 Amendment</a>
	 * @return VRML97 string
	 */
	public String toStringVRML97()
	{
		return toStringVRML97(0); // apply next method with initial indentation level 0
	}

	/**
	 * Recursive method to provide VRML97 string serialization.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3D#FILE_EXTENSION_VRML97
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/14772/V2.0/index.html">Virtual Reality Modeling Language (VRML) 97 specification</a>
	 * @see <a href="https://www.web3d.org/documents/specifications/14772-1/V2.1/index.html">VRML 97 v2.1 Amendment</a>
	 * @return VRML97 string
	 */
	abstract public String toStringVRML97(int indentLevel); // must be overridden

	/**
	 * Recursive method to determine whether this element is valid.
	 * @return true if validate() has no results
	 */
	public boolean isValid()
    {
        return validate().isEmpty();
    }

	/**
	 * Recursive method to validate this element plus all contained nodes and statements,
	 * using both datatype-specification value checks and regular expression (regex) checking of corresponding string values.
         * This method must be overridden, ensuring that a concrete method is provided for each class.
	 * @return validation results (if any)
	 */
	abstract public String validate();
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>X3DConcreteNode</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text>import org.web3d.x3d.jsail.fields.*;</xsl:text></xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteElement</xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Abstract parent class for concrete X3D nodes, containing common methods and member variables.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<!-- TODO include DEF_USE and global (class) attributeGroup entries in X3D Object Model -->
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to indicate whether this element is an X3D Graphics node (implementing X3DConcreteNode), returns <i>true</i>.
	 * <br><br>
	 * @see X3DConcreteNode
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/glossary.html#Node">X3D Abstract Specification, Terms and definitions: node</a>
	 * @return whether this element is an X3D Graphics node: true
	 */
	public static final boolean isNode()
	{
            // (this instanceof org.web3d.x3d.jsail.X3DConcreteNode)
            return true;
	}
	/**
	 * Utility method to indicate whether this element is an X3D Graphics statement (implementing X3DConcreteStatement), returns <i>false</i>.
	 * <br><br>
	 * @see X3DConcreteStatement
	 * @see CommentsBlock
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#AbstractX3DStructure">X3D Abstract Specification: 7.2.5 Abstract X3D structure</a>
	 * @return whether this element is an X3D Graphics statement: false
	 */
	public static final boolean isStatement()
	{
            //  (this instanceof org.web3d.x3d.jsail.X3DConcreteStatement) &&
            // !(this instanceof org.web3d.x3d.jsail.Core.CommentsBlock)
            return false;
	}

	// Member value declarations are encapsulated and protected, using preferred Java types for concretes library

	/** <i>Tooltip:</i> DEF defines a unique ID name for this node, referenceable by other nodes.
	 * <ul>
	 * <li> <i>Hint:</i> descriptive DEF names improve clarity and help document a model. </li>
	 * <li> <i>Hint:</i> well-defined names can simplify design and debugging through improved author understanding. </li>
	 * </ul>
	 * @see SFString#isNMTOKEN(String)
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 */
	private String DEF = DEF_DEFAULT_VALUE;

	/** <i>Tooltip:</i> USE means reuse an already DEF-ed node ID, excluding all child nodes and all other attributes (except for containerField, which can have a different value).
	 * <ul>
	 * <li> <i>Hint:</i> USE references to previously defined DEF geometry (instead of duplicating nodes) can improve performance. </li>
	 * <li> <i>Warning:</i> each USE value must match a corresponding DEF value that is defined earlier in the scene. </li>
	 * </ul>
	 * @see SFString#isNMTOKEN(String)
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 */
	private String USE = USE_DEFAULT_VALUE;

	// String constants for default field values match X3D Schema definitions

	/** SFString field named <i>DEF</i> has default value equal to an empty string. */
	public static final String DEF_DEFAULT_VALUE = "";

	/** SFString field named <i>USE</i> has default value equal to an empty string. */
	public static final String USE_DEFAULT_VALUE = "";

	/**
         * Warning: containerFieldOverride describes a non-default (and quite possibly incorrect) field relationship of a node to its parent,
         * overriding the default or alternate containerField value.
	 * Programmer usage is not ordinarily needed when using this API (in rare cases it may be needed for ProtoInstance nodes).
         * Instead of using containerFieldOverride workaround methods, focus on defining correct parent-child node relationships instead.
         * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 */
        public String containerFieldOverride = new String();

	/** Initialize all member variables to default values. */
	public void initialize()
	{
		setParent(null);
		super.initialize();
        DEF =   DEF_DEFAULT_VALUE;
        USE =   USE_DEFAULT_VALUE;
	}

    private boolean hasNameField = false;
    /**
     * Protected method for X3DJSAIL class initialize() methods to indicate whether the current concrete node has a getName() method
     */
    protected void includesNameField()
    {
        hasNameField = true;
    }
    /**
     * Whether or not this class has a getName() method
     * @return whether this X3D node includes a name field

     */
    public boolean hasNameField()
    {
        return hasNameField;
    }
    /**
     * Utility method to permit querying name value
     * @return name value if available for this class
     */
    public String getName()
    {
        if  (hasNameField())
             return this.getName();
        else return "";
    }
	/**
	 * Provide String value from inputOutput SFString field named <i>DEF</i>.
	 * <br><br>
	 * <i>Tooltip:</i> DEF defines a unique ID name for this node, referenceable by other nodes.
	 * <ul>
	 * <li> <i>Hint:</i> descriptive DEF names improve clarity and help document a model. </li>
	 * <li> <i>Hint:</i> well-defined names can simplify design and debugging through improved author understanding. </li>
	 * <li> <i>Hint:</i> USE references to previously defined DEF geometry (instead of duplicating nodes) can improve performance. </li>
	 * <li> <i>Warning:</i> each USE value must match a corresponding DEF value that is defined earlier in the scene. </li>
	 * </ul>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @return value of DEF field
	 */
	public String getDEF()
	{
		return DEF;
	}
	/**
	 * Utility method to indicate whether this element has a <i>DEF</i> identifier.
	 * <br><br>
	 * <i>Tooltip:</i> DEF defines a unique ID name for this node, referenceable by other nodes.
	 * <ul>
	 * <li> <i>Hint:</i> descriptive DEF names improve clarity and help document a model. </li>
	 * <li> <i>Hint:</i> well-defined names can simplify design and debugging through improved author understanding. </li>
	 * <li> <i>Hint:</i> USE references to previously defined DEF geometry (instead of duplicating nodes) can improve performance. </li>
	 * <li> <i>Warning:</i> each USE value must match a corresponding DEF value that is defined earlier in the scene. </li>
	 * </ul>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @return whether this node is a USE reference
	 */
	public boolean hasDEF()
	{
		return !DEF.isEmpty();
	}

	/**
	 * Provide String value from inputOutput SFString field named <i>USE</i>.
	 * <br><br>
	 * <i>Tooltip:</i> USE means reuse an already DEF-ed node ID, excluding all child nodes and all other attributes (except for containerField, which can have a different value).
	 * <ul>
	 * <li> <i>Hint:</i> USE references to previously defined DEF geometry (instead of duplicating nodes) can improve performance. </li>
	 * <li> <i>Warning:</i> each USE value must match a corresponding DEF value that is defined earlier in the scene. </li>
	 * </ul>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @return value of USE field
	 */
	public String getUSE()
	{
		return USE;
	}
	/**
	 * Utility method to indicate whether this element has a <i>USE</i> reference to another previously defined element (which means other fields must be empty).
	 * <br><br>
	 * <i>Tooltip:</i> USE means reuse an already DEF-ed node ID, excluding all child nodes and all other attributes (except for containerField, which can have a different value).
	 * <ul>
	 * <li> <i>Hint:</i> USE references to previously defined DEF geometry (instead of duplicating nodes) can improve performance. </li>
	 * <li> <i>Warning:</i> each USE value must match a corresponding DEF value that is defined earlier in the scene. </li>
	 * </ul>
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @return whether this node is a USE reference
	 */
	public boolean hasUSE()
	{
		return !USE.isEmpty();
	}

	/** Protected internal superclass method to keep DEF private, scene authors should use method setDEF(newValue) instead.
	 * @param newValue is new value for the DEF field.
	 * @see SFString#isNMTOKEN(String)
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 * @see <a href="https://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
	 */
	protected void setConcreteDEF(String newValue)
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA) #2
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment

		// Check that newValue parameter meets NMTOKEN requirements before assigning to scene graph
		if (!newValue.isEmpty() && !org.web3d.x3d.jsail.fields.SFString.isNMTOKEN(newValue))
		{
			throw new org.web3d.x3d.sai.InvalidFieldValueException(getElementName() + " DEF=\"" + newValue +
					"\" has an illegal value, must provide a valid NMTOKEN name string.");
		}
		DEF = newValue.trim();
	}
	/** Protected internal superclass method to keep USE private, scene authors should use method setUse(newValue) instead.
	 * @param newValue is new value for the USE field.
	 * @see SFString#isNMTOKEN(String)
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 */
	protected final void setConcreteUSE(String newValue)
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA) #3
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment

		// Check that newValue parameter meets NMTOKEN requirements before assigning to scene graph
		if (!newValue.isEmpty() && !org.web3d.x3d.jsail.fields.SFString.isNMTOKEN(newValue))
		{
			throw new org.web3d.x3d.sai.InvalidFieldValueException(getElementName() + " USE=\"" + newValue +
					"\" has an illegal value, must provide a valid NMTOKEN name string.");
		}
		USE = newValue.trim();
	}
	/** Each concrete class must independently override this abstract method to enable object-specific method pipelining.
	 * @param DEFlabel is new value for the DEF field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object). */
	abstract public X3DConcreteNode setDEF(String DEFlabel);

	/** Each concrete class must independently override this abstract method to enable object-specific method pipelining.
	 * <ul>
	 * <li> <i>Warning:</i> note that the <code>setUSE()</code> method on this node resets all other fields to their default values (except for containerField) and also releases all child nodes. </li>
	 * <li> <i>Warning:</i> no other operations can be performed to modify a USE node other than setting an alternate containerField value. </li>
	 * </ul>
	 * @param USEname is new value for the USE field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object). */
	abstract public X3DConcreteNode setUSE(String USEname);

	/** Each concrete class must independently override this abstract method to enable object-specific method pipelining.
	 * This attribute is only functional if the X3D model is loaded within an HTML page.
	 * <i>Tooltip:</i> The class attribute is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @see <a href="https://www.w3.org/TR/css-2018">W3C CSS Snapshot</a>
	 * @see <a href="https://en.wikibooks.org/wiki/XML_-_Managing_Data_Exchange/XSLT_and_Style_Sheets">Wikibooks: XML - Managing Data Exchange/XSLT and Style Sheets</a>
	 * @param cssClass is new value for the class field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object). */
	abstract public X3DConcreteNode setCssClass(String cssClass);

	/** Each concrete class must independently override this abstract method to enable object-specific method pipelining.
	 * This attribute is only functional if the X3D model is loaded within an HTML page.
	 * <i>Tooltip:</i> the id attribute on each X3D node is considered a unique identifier when used as part of an encompassing HTML/DOM context.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
     * <br />
     * <i>Warning:</i> the id attribute is in a distinct separate namespace from DEF identifiers and thus not applicable for USE nodes, ROUTE statements, or Script references.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#ContentDefinitionPagePresentation">X3D Architecture Annex L - HTML authoring guidelines, L.3.1 Content definition and page presentation</a>
	 * @see <a href="https://www.w3.org/TR/html52">HTML 5.2</a> W3C Recommendation
	 * @see <a href="https://www.w3.org/DOM/DOMTR">Document Object Model (DOM) Technical Reports</a>
	 * @see <a href="https://en.wikibooks.org/wiki/XML_-_Managing_Data_Exchange/XSLT_and_Style_Sheets">Wikibooks: XML - Managing Data Exchange/XSLT and Style Sheets</a>
	 * @param htmlID is new value for the id field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object). */
	abstract public X3DConcreteNode setHtmlID(String htmlID);

	/** Each concrete class must independently override this abstract method to enable object-specific method pipelining.
	 * This attribute is only functional if the X3D model is loaded within an HTML page.
	 * <i>Tooltip:</i> The style attribute provides an inline block of CSS source for element styling, reserved for use by CSS cascading stylesheets.
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/htmlGuidelines.html#CSS">X3D Architecture Annex L - HTML authoring guidelines, CSS considerations</a>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @see <a href="https://www.w3.org/TR/css-2018">W3C CSS Snapshot</a>
	 * @see <a href="https://en.wikibooks.org/wiki/XML_-_Managing_Data_Exchange/XSLT_and_Style_Sheets">Wikibooks: XML - Managing Data Exchange/XSLT and Style Sheets</a>
	 * @param cssStyle is new value for the class field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object). */
	abstract public X3DConcreteNode setCssStyle(String cssStyle);

	/**
	 * Assign X3DMetadataObject instance (using a properly typed node) to inputOutput SFNode field <i>metadata</i>.
	 * @param newValue is new value for the metadata field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>
	 */
	abstract public X3DConcreteNode setMetadata (X3DMetadataObject newValue);

	/**
	 * Assign X3DMetadataObject instance (using a properly typed ProtoInstance) to inputOutput SFNode field <i>metadata</i>.
	 * @param newValue is new value for the metadata field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>
	 */
	abstract public X3DConcreteNode setMetadata (ProtoInstance newValue); // TODO

	/**
	 * Assign field named <i>IS</i> for establishing IS/connect field connections between ProtoInterface fields and internal
ProtoBody nodes.
	 * The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
	 * @param newValue is new value for the description field.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS">X3D Tooltips: IS</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect">X3D Tooltips: connect</a>
	 * @return <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	abstract public X3DConcreteNode setIS(IS newValue);

	/**
	 * Provide field named <i>IS</i> for establishing IS/connect field connections between ProtoInterface fields and internal
ProtoBody nodes.
	 * The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS">X3D Tooltips: IS</a>
	 * @see <a href="https://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect">X3D Tooltips: connect</a>
	 * @return current IS, if any
	 */
	abstract public IS getIS();
]]></xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[
        /**
         * containerField describes the field relationship of a node to its parent.
	 * Modification of this value is not needed when using this API, since alternative values are provided for informational purposes.
	 * Each concrete class must independently override this array with a final value.
	 * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 * @see <a href="https://stackoverflow.com/questions/370962/why-cant-static-methods-be-abstract-in-java" target="_blank">StackOverflow: Why can't static methods be abstract in Java</a>
	 * @return default containerField value for this node
	 */
	abstract public String getContainerFieldDefault();

	/**
         * This string array provides all allowed containerField values for this node, starting with the default value.
	 * Note that containerField describes the field relationship of a node to its parent.
	 * Modification of this value is not needed when using this API, since alternative values are provided for informational purposes.
	 * When relevant, a concrete class independently overrides this array with final values.
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 */
	public String[] containerField_ALLOWED_VALUES = { };

        /**
         * containerField describes the field relationship of a node to its parent.
	 * Modification of this value is not ordinarily needed when using this API, since alternative values are provided for informational purposes.
	 * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 * @return array of allowed String values
	 */
	public String[] getContainerFieldAllowedValues()
	{
		return containerField_ALLOWED_VALUES;
	}

	/**
         * Warning: containerFieldOverride describes a non-default (and quite possibly incorrect) field relationship of a node to its parent,
         * overriding the default or alternate containerField value.
	 * Programmer usage is not ordinarily needed when using this API (in rare cases it may be needed for ProtoInstance nodes).
         * Instead of using containerFieldOverride workaround methods, focus on defining correct parent-child node relationships instead.
         *
	 * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 * @return containerFieldOverride value, if any
	 */
        public String getContainerFieldOverride()
	{
		return containerFieldOverride;
	}
	/**
         * Warning: containerFieldOverride describes a non-default (and quite possibly incorrect) field relationship of a node to its parent,
         * overriding the default or alternate containerField value.
	 * Programmer usage is not ordinarily needed when using this API (in rare cases it may be needed for ProtoInstance nodes).
         * Instead of using containerFieldOverride workaround methods, focus on defining correct parent-child node relationships instead.
         *
	 * @param value to set containerFieldOverride, must be allowed in containerField_ALLOWED_VALUES
         * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 * @see <a href="https://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 * @return object reference to node
	 */
        public X3DConcreteNode setContainerFieldOverride(String value)
	{
		if ((value == null) || value.isEmpty())
		{
			 containerFieldOverride = new String();
		}
		else if (getElementName().equals("ProtoInstance") ||
			 ((containerField_ALLOWED_VALUES != null) && Arrays.asList(containerField_ALLOWED_VALUES).contains(value)))
		{
			 containerFieldOverride = value;
		}
		else
		{
			String errorNotice = "*** Invalid setContainerFieldOverride() value='" + value +
				"', legal values for " + getElementName() + " are containerField_ALLOWED_VALUES='" +
				new org.web3d.x3d.jsail.fields.MFString(containerField_ALLOWED_VALUES).toStringX3D() + "'";
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
		return this;
	}
	/**
         * Warning: containerFieldOverride describes a non-default (and quite possibly incorrect) field relationship of a node to its parent,
         * overriding the default or alternate containerField value.
	 * Programmer usage is not ordinarily needed when using this API (in rare cases it may be needed for ProtoInstance nodes).
         * Instead of using containerFieldOverride workaround methods, focus on defining correct parent-child node relationships instead.
         * @see org.web3d.x3d.jsail.X3DConcreteNode#containerField_ALLOWED_VALUES
	 */
        public void resetContainerFieldOverride()
	{
		containerFieldOverride = new String();
	}
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>X3DConcreteStatement</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteElement</xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Abstract parent class for concrete X3D statements, containing common methods and member variables.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to indicate whether this element is an X3D Graphics node (implementing X3DConcreteNode), returns <i>false</i>.
	 * <br><br>
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#AbstractX3DStructure">X3D Abstract Specification: 7.2.5 Abstract X3D structure</a>
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/glossary.html#Node">X3D Abstract Specification, Terms and definitions: node</a>
	 * @return whether this element is an X3D Graphics node: false
	 */
	public static final boolean isNode()
	{
            // (this instanceof org.web3d.x3d.jsail.X3DConcreteNode)
            return false;
	}
	/**
	 * Utility method to indicate whether this element is an X3D Graphics statement (implementing X3DConcreteStatement), returns <i>true</i>.  (Does not include CommentsBlock objects.)
	 * <br><br>
	 * @see CommentsBlock
	 * @see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#AbstractX3DStructure">X3D Abstract Specification: 7.2.5 Abstract X3D structure</a>
	 * @return whether this element is an X3D Graphics statement: true
	 */
	public static final boolean isStatement()
	{
            //  (this instanceof org.web3d.x3d.jsail.X3DConcreteStatement) &&
            // !(this instanceof org.web3d.x3d.jsail.Core.CommentsBlock)
            return true;
	}

	/** Initialize all member variables to default values. */
	public void initialize()
	{
		setParent(null);
		super.initialize();
	}]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>X3DLoaderDOM</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text>
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.w3c.dom.Document;
import org.w3c.dom.DOMException;

import java.io.File;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.reflect.*;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.parsers.ParserConfigurationException;

import org.web3d.x3d.jsail.CADGeometry.*;
import org.web3d.x3d.jsail.Core.*;
import org.web3d.x3d.jsail.CubeMapTexturing.*;
import org.web3d.x3d.jsail.DIS.*;
import org.web3d.x3d.jsail.EnvironmentalEffects.*;
import org.web3d.x3d.jsail.EnvironmentalSensor.*;
import org.web3d.x3d.jsail.EventUtilities.*;
import org.web3d.x3d.jsail.fields.*;
import org.web3d.x3d.jsail.Followers.*;
import org.web3d.x3d.jsail.Geometry2D.*;
import org.web3d.x3d.jsail.Geometry3D.*;
import org.web3d.x3d.jsail.Geospatial.*;
import org.web3d.x3d.jsail.Grouping.*;
import org.web3d.x3d.jsail.HAnim.*;
import org.web3d.x3d.jsail.Interpolation.*;
import org.web3d.x3d.jsail.KeyDeviceSensor.*;
import org.web3d.x3d.jsail.Layering.*;
import org.web3d.x3d.jsail.Layout.*;
import org.web3d.x3d.jsail.Lighting.*;
import org.web3d.x3d.jsail.Navigation.*;
import org.web3d.x3d.jsail.Networking.*;
import org.web3d.x3d.jsail.NURBS.*;
import org.web3d.x3d.jsail.ParticleSystems.*;
import org.web3d.x3d.jsail.Picking.*;
import org.web3d.x3d.jsail.PointingDeviceSensor.*;
import org.web3d.x3d.jsail.Rendering.*;
import org.web3d.x3d.jsail.RigidBodyPhysics.*;
import org.web3d.x3d.jsail.Rendering.*;
import org.web3d.x3d.jsail.Scripting.*;
import org.web3d.x3d.jsail.Shaders.*;
import org.web3d.x3d.jsail.Shape.*;
import org.web3d.x3d.jsail.Sound.*;
import org.web3d.x3d.jsail.Text.*;
import org.web3d.x3d.jsail.TextureProjection.*;
import org.web3d.x3d.jsail.Texturing.*;
import org.web3d.x3d.jsail.Texturing3D.*;
import org.web3d.x3d.jsail.Time.*;
import org.web3d.x3d.jsail.VolumeRendering.*;

// node types are in SAI package, avoid exposing overloaded nodes here
import org.web3d.x3d.sai.Core.X3DNode;
import org.web3d.x3d.sai.Core.X3DBindableNode;
import org.web3d.x3d.sai.Core.X3DChildNode;
import org.web3d.x3d.sai.Core.X3DInfoNode;
import org.web3d.x3d.sai.Core.X3DMetadataObject;
import org.web3d.x3d.sai.Core.X3DPrototypeInstance;
import org.web3d.x3d.sai.Core.X3DSensorNode;
import org.web3d.x3d.sai.CubeMapTexturing.X3DEnvironmentTextureNode;
import org.web3d.x3d.sai.Grouping.X3DBoundedObject;
import org.web3d.x3d.sai.Grouping.X3DGroupingNode;
import org.web3d.x3d.sai.Rendering.X3DComposedGeometryNode;
import org.web3d.x3d.sai.Rendering.X3DColorNode;
import org.web3d.x3d.sai.Rendering.X3DComposedGeometryNode;
import org.web3d.x3d.sai.Rendering.X3DCoordinateNode;
import org.web3d.x3d.sai.Rendering.X3DGeometricPropertyNode;
import org.web3d.x3d.sai.Rendering.X3DGeometryNode;
import org.web3d.x3d.sai.Rendering.X3DNormalNode;
import org.web3d.x3d.sai.Shape.X3DAppearanceNode;
import org.web3d.x3d.sai.Shape.X3DAppearanceChildNode;
import org.web3d.x3d.sai.Shape.X3DMaterialNode;
import org.web3d.x3d.sai.Text.X3DFontStyleNode;
import org.web3d.x3d.sai.Texturing.X3DTextureNode;
import org.web3d.x3d.sai.Texturing.X3DTexture2DNode;
import org.web3d.x3d.sai.Texturing.X3DTextureCoordinateNode;
import org.web3d.x3d.sai.Texturing.X3DTextureTransformNode;
import org.web3d.x3d.sai.Texturing.X3DSingleTextureCoordinateNode;
import org.web3d.x3d.sai.Texturing.X3DSingleTextureTransformNode;
import org.web3d.x3d.sai.Shaders.X3DProgrammableShaderObject;
import org.web3d.x3d.sai.Shaders.X3DShaderNode;
import org.web3d.x3d.sai.Shaders.X3DVertexAttributeNode;
import org.web3d.x3d.sai.Sound.X3DSoundSourceNode;

import org.web3d.x3d.sai.X3DException;

// fully specified when occurring:
// import org.w3c.dom.DocumentType;
// import org.w3c.dom.NamedNodeMap;
// import org.w3c.dom.Node;
// import org.w3c.dom.NodeList;
</xsl:text></xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isUtilityClass"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Concrete class for loading an X3D graphics string, file or fragment, encoded in XML, using the Document Object Model (DOM).</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	@see <a href="https://docs.oracle.com/javase/tutorial/jaxp/dom/index.html">Java Tutorials: Document Object Model (DOM)</a>
	@see <a href="https://docs.oracle.com/javase/tutorial/jaxp/dom/readingXML.html">Java Tutorials: Reading XML Data into a DOM</a>
	@see <a href="https://www.web3d.org/specifications/X3Dv4/ISO-IEC19775-1v4-IS/Part01/components/core.html#AbstractX3DStructure">X3D Abstract Specification: 7.2.5 Abstract X3D structure</a>
]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text><!-- unused --></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	private DocumentBuilderFactory documentBuilderFactory;
	private DocumentBuilder        documentBuilder;
	private Document               document;
	private boolean loadSuccess = false;
	private StringBuilder validationResult = new StringBuilder();

	/** Default dtdValidate value for documentBuilderFactory */
	public final boolean DEFAULT_DTD_VALIDATE = false;
	/** Default xsdValidate value for documentBuilderFactory */
	public final boolean DEFAULT_XSD_VALIDATE = false;

	private boolean dtdValidate = DEFAULT_DTD_VALIDATE;
	private boolean xsdValidate = DEFAULT_XSD_VALIDATE;
//  private String schemaSource = null;

	/** indentation string is 2 blank characters */
	protected String indentLevel = "  ";
	/** lineBreakWidth is line length before breaking onto a new line for readability */
	protected int lineBreakWidth = 100;
	private int lineLength = 0;

	// persistent object needed for toX3dModelInstance parse process
	private static X3D         loadedX3dModelInstance;	// only one at a time; TODO consider passing as recursive parameter

	private X3DConcreteElement holdCopyElementObject; // remember elementObject, trying to keep from falling out of scope

	private String  currentProtoDeclareNameValue       = new String(); // remember name attribute for current ProtoDeclare element
	private String  currentExternProtoDeclareNameValue = new String(); // remember name attribute for current ExternProtoDeclare element
	private boolean currentProtoNodeTypeFound = false;
	private Map<String,String> protoNameToNodeTypesHashMap = new HashMap<>();
	private Map<String,String> protoDEFtoNodeTypesHashMap  = new HashMap<>();
	private Map<String,String> protoContainerFieldHashMap  = new HashMap<>();

	/** Default constructor to initialize X3DLoaderDOM */
	public X3DLoaderDOM()
	{
		initialize();
	}

	private void initialize()
	{
		if (documentBuilderFactory == null) // singleton pattern
			documentBuilderFactory = DocumentBuilderFactory.newInstance();
		documentBuilderFactory.setNamespaceAware(true);
		documentBuilderFactory.setValidating(dtdValidate || xsdValidate);
		loadSuccess = false;
	}

	/** Load the XML X3D file using DOM, report whether successful.  Fails if file is empty.
	 * @param fileName path and name of .x3d or .xml file (XML encoding)
	 * @return whether successful
	 * @see #loadModelFromFileX3D(File)
	*/
	public boolean loadModelFromFileX3D (String fileName)
	{
        return loadModelFromFileX3D ("", fileName);
	}

	/** Load the XML X3D file using DOM, report whether successful.  Fails if file is empty.
     * @param path directory path to file of interest
	 * @param fileName path and name of .x3d or .xml file (XML encoding)
	 * @return whether successful
	 * @see #loadModelFromFileX3D(File)
	*/
	public boolean loadModelFromFileX3D (String path, String fileName)
	{
		if (!fileName.endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_X3D) && !fileName.endsWith(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_XML))
		{
			throw new org.web3d.x3d.sai.X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + X3D.FILE_EXTENSION_X3D + "\" or " +
                            "\"" + X3D.FILE_EXTENSION_XML + "\"");
		}
		File x3dFile;
        if ((path == null) || path.isEmpty() || path.equals("."))
             x3dFile = new File(      fileName);
		else x3dFile = new File(path, fileName);

		if (!x3dFile.exists())
		{
			throw new org.web3d.x3d.sai.X3DException("path='" + path + "', fileName='" + fileName + "' does not exist and cannot be loaded, check path and filename.");
		}
		return loadModelFromFileX3D (x3dFile); // handoff
	}

	/** Load the XML X3D file using DOM, report success
	 * @param x3dFile existing x3d file (XML encoding)
	 * @return whether successful
	 * @see #loadModelFromFileX3D(String)
	*/
	public boolean loadModelFromFileX3D (File x3dFile)
	{
		try
		{
			documentBuilder = documentBuilderFactory.newDocumentBuilder();
			OutputStreamWriter errorWriter = new OutputStreamWriter(System.out, ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT);
			documentBuilder.setErrorHandler(new MyErrorHandler (new PrintWriter(errorWriter, true)));
			document = documentBuilder.parse(x3dFile);
			X3DConcreteElement concreteElement =  toX3dModelInstance(document);
            if (!concreteElement.getElementName().equals(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.NAME))
            {
                System.out.println ("[warning] loadModelFromFileX3D(\"" + x3dFile.getPath() + "\") has root element=" + concreteElement.getElementName());
            }
		}
		catch (ParserConfigurationException parserConfigurationException)
		{
			Logger.getLogger(X3DLoaderDOM.class.getName()).log(Level.SEVERE, null, parserConfigurationException);
                        loadSuccess = false;
                        return loadSuccess;
		}
		catch (SAXException saxException)
		{
			Logger.getLogger(X3DLoaderDOM.class.getName()).log(Level.SEVERE, null, saxException);
                        loadSuccess = false;
                        return loadSuccess;
		}
		catch (IOException ioException)
		{
			Logger.getLogger(X3DLoaderDOM.class.getName()).log(Level.SEVERE, null, ioException);
                        loadSuccess = false;
                        return loadSuccess;
		}
		loadSuccess = (document != null);
		return loadSuccess;
	}
	/**
	 * Provide DOM document version of externally loaded X3D file
	 * @return the DOM document, if XML-encoded X3D file was successfully loaded
	 */
	public Document getDomDocument()
	{
		return document;
	}
	/**
	 * Convenience method, use DOM to create X3D string from a previously loaded document with default zero indent.
	 * X3D output is XML encoding.
	 * @param node DOM Node to process
	 * @see X3D#FILE_EXTENSION_X3D
	 * @see X3D#FILE_EXTENSION_XML
	 * @return the loaded X3D document of interest, starting with regular <i>X3D</i> element headers or possibly a scene fragment
	 */
	public String toStringX3D(org.w3c.dom.Node node) {
		return toStringX3D(node, "");
	}

	/**
	 * Recursive method that uses DOM to create an X3D string from loaded document, where X3D output is in XML encoding.
	 * @param node DOM Node to process
	 * @return the previously loaded X3D document of interest, starting either with regular X3D headers or possibly a scene fragment
	 */
	private String toStringX3D(org.w3c.dom.Node node, String indent)
	{
		boolean nodeChildFound = false;
		StringBuilder result = new StringBuilder();

        if (node==null)
        {
            String message = "[error] invoking toStringX3D(node=" + node + ", indent=" + indent + ")";
            System.out.println(message);
            throw new org.web3d.x3d.sai.InvalidDocumentException(message);
        }
        if (indent==null)
            indent = "";
		switch (node.getNodeType())
		{
			case org.w3c.dom.Node.DOCUMENT_NODE:
				result.append("<?xml version=\"1.0\" encoding=\"").append(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT).append("\"?>").append("\n");
				org.w3c.dom.NodeList childNodeList = node.getChildNodes();	// recurse on children
				if (childNodeList != null)
				{
					for (int i = 0; i < childNodeList.getLength(); i++)
					{
						result.append(toStringX3D(childNodeList.item(i), ""));
					}
				}
				break;

			case org.w3c.dom.Node.DOCUMENT_TYPE_NODE:
				org.w3c.dom.DocumentType documentType = (org.w3c.dom.DocumentType) node;

				result.append("<!DOCTYPE ").append(documentType.getName());
				// first set X3D DOCTYPE to specified values
				if (documentType.getName().compareTo("X3D") == 0)
				{
					result.append(" PUBLIC \"ISO//Web3D//DTD X3D 3.3//EN\"");
					result.append(" \"https://www.web3d.org/specifications/x3d-3.3.dtd\"");
				}
				else if ((documentType.getPublicId() != null) && (documentType.getSystemId() != null))
				{
					result.append(" PUBLIC \"").append(documentType.getPublicId()).append("\"");
					result.append("        \"").append(documentType.getSystemId());
				}
				else if ((documentType.getPublicId() == null) && (documentType.getSystemId() != null))
				{
					result.append(" SYSTEM \"").append(documentType.getSystemId());
				}
				childNodeList = node.getChildNodes(); // recurse on children, e.g. CDATA and namespaces
				if (childNodeList != null)
				{
					for (int i = 0; i < childNodeList.getLength(); i++)
					{
						result.append(toStringX3D(childNodeList.item(i), ""));
					}
				}
				if ((documentType.getPublicId() != null) && (documentType.getSystemId() != null))
				{
					result.append(">").append("\n");
				}
				else if ((documentType.getPublicId() == null) && (documentType.getSystemId() != null))
				{
					result.append("\">").append("\n");
				}
				else
				{
					result.append(">").append("\n");
				}
				break;

			case org.w3c.dom.Node.ELEMENT_NODE:
				String name = node.getNodeName();
				result.append(indent).append("<").append(name);
				lineLength = name.length() + 2;
				org.w3c.dom.NamedNodeMap attributes = node.getAttributes(); // print attributes first

				for (int i = 0; i < attributes.getLength(); i++)
				{
					org.w3c.dom.Node current = attributes.item(i);
					String attributeValue = new String();
					if (current.getNodeValue() != null)
						attributeValue = current.getNodeValue();
					// looks like no conversion needed when reading from DOM!
//					if (attributeValue.contains("\\"))
//						attributeValue = attributeValue.replaceAll("\\\\","\\\\"); // replace literal \ with \\
//					if (attributeValue.contains("\""))
//						attributeValue = attributeValue.replaceAll("\"","\\\"");   // replace literal " with \"
//					if (attributeValue.contains("Immel")) // trace
//						System.out.println (attributeValue);
					result.append(" ").append(current.getNodeName()).append("=\'").append(attributeValue).append("\'");
				}

				// determine if any actual element child nodes are present
				org.w3c.dom.NodeList children = node.getChildNodes();
				for (int i = 0; i < children.getLength(); i++)
				{
					if (children.item(i).getNodeType() != org.w3c.dom.Node.TEXT_NODE)
					{
						nodeChildFound = true;
						break;
					}
				}
				// TODO confirm: handle CDATA text in Script (and Shader) nodes

				if (nodeChildFound == true) // recurse on each non-attribute child
				{
					result.append(">").append("\n");
				//	result.append ("<!-- iterating over children -->").append("\n"); // debug
					for (int i = 0; i < children.getLength(); i++)
					{
						result.append(toStringX3D(children.item(i), indent + indentLevel));
					}
					result.append(indent).append("</").append(name).append(">").append("\n"); // closing tag
				}
				else
				{
					result.append("/>").append("\n"); // singleton close
				}
				break;

			case org.w3c.dom.Node.TEXT_NODE:
				//	trim() removes leading and trailing whitespace
				result.append(node.getNodeValue().trim());
				break;

			case org.w3c.dom.Node.CDATA_SECTION_NODE:
				result.append(indent).append("<![CDATA[").append(node.getNodeValue()).append(]]></xsl:text>
				<xsl:text>"]</xsl:text><xsl:text>]>").append("\n");</xsl:text><!-- special handling for CDATA delimiter ]]> -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
				break;

			case org.w3c.dom.Node.COMMENT_NODE:
				result.append(indent).append("<!-- ").append(node.getNodeValue().trim()).append(" -->").append("\n");
				break;

			case org.w3c.dom.Node.PROCESSING_INSTRUCTION_NODE:
				// PROCESSING_INSTRUCTION_NODE typically unused; seems to repeat COMMENT_NODE, and so ignored
				// result.append(indent).append("<?").append(node.getNodeName()).append(" ")
				//		 .append(node.getNodeValue()).append("?>").append("\n");
				break;

			case org.w3c.dom.Node.ENTITY_REFERENCE_NODE:
				result.append("&").append(node.getNodeName()).append(";");
				break;
		}
		return result.toString();
	}

	/**
	 * Recursive method that uses DOM to create X3DJSAIL objects from a previously loaded document,
	 * taking advantage of Java Reflection and String-based field accessors with <i>protected</i> access that are not otherwise usable.
	 * @see <a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Java Tutorials: Reflection API</a>
	 * @see <a href="https://www.manning.com/books/java-reflection-in-action">Java Reflection in Action</a>
	 * @param node DOM Node to process
	 * @return the loaded X3D objects of interest, starting with regular X3D object or possibly a scene fragment
	 */
	public X3DConcreteElement toX3dModelInstance(org.w3c.dom.Node node)
	{
		toX3dModelInstance(node, null); // no parent
		return loadedX3dModelInstance;
	}

	/**
	 * Recursive method that uses DOM to create X3DJSAIL objects from a previously loaded document,
	 * taking advantage of Java Reflection and String-based field accessors with <i>protected</i> access that are not otherwise usable.
	 * @see <a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Java Tutorials: Reflection API</a>
	 * @see <a href="https://www.manning.com/books/java-reflection-in-action">Java Reflection in Action</a>
	 * @param node DOM Node to process
	 * @param parentElement the parent of this scene object, if any
	 * @return the loaded X3D objects of interest, starting with regular X3D object or possibly a scene fragment
	 */
	public X3DConcreteElement toX3dModelInstance(org.w3c.dom.Node node, X3DConcreteElement parentElement)
	{
		String indent = "  "; // TODO omit when refactored
		boolean   nodeChildFound = false;
		Class<X3DConcreteElement> elementClass; // TODO <X3DConcreteElement> ?
		X3DConcreteElement       elementObject = null;
		String errorNotice;

        if (node==null)
        {
            String message = "[error] invoking toX3dModelInstance(node=" + node + ", parentElement=" + parentElement + ")";
            System.out.println(message);
            throw new org.web3d.x3d.sai.InvalidDocumentException(message);
        }
		switch (node.getNodeType())
		{
			case org.w3c.dom.Node.DOCUMENT_NODE:
				// omit: ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
				org.w3c.dom.NodeList childNodeList = node.getChildNodes();	// recurse on children
				if (childNodeList != null)
				{
					for (int i = 0; i < childNodeList.getLength(); i++)
					{
						// recurse on children having elementObject as parent
						toX3dModelInstance(childNodeList.item(i), elementObject);
						// do not return from here, instead process all top-level nodes to completion
					}
				}
				break;

			case org.w3c.dom.Node.DOCUMENT_TYPE_NODE:
				// omit: org.w3c.dom.Node.DocumentType documentType = (org.w3c.dom.Node.DocumentType) node;
				childNodeList = node.getChildNodes();	// recurse on children, e.g. CDATA and namespaces
				if (childNodeList != null)
				{
					for (int i = 0; i < childNodeList.getLength(); i++)
					{
						// recurse on children having elementObject as parent
						toX3dModelInstance(childNodeList.item(i), elementObject);
						// do not return from here, instead process all top-level nodes to completion
					}
				}
				break;

			case org.w3c.dom.Node.ELEMENT_NODE:
				String                nodeName = node.getNodeName(); // DOM
				String             elementName = node.getNodeName(); // X3DJSAIL class name, formerly + "Object"
				String             packageName = X3DConcreteNode.getPackageName(elementName); // X3DJSAIL utility
				String	  elementSetMethodName;
				Method		  elementSetMethod;

				// https://stackoverflow.com/questions/7495785/java-how-to-instantiate-a-class-from-stringstring

				try // to create X3D object and related X3DConcreteElement node/statement objects
				{
					elementClass  = (Class<X3DConcreteElement>)Class.forName(packageName); // must be fully qualified packageName
                                // https://stackoverflow.com/questions/46393863/what-to-use-instead-of-class-newinstance
				//	elementObject = elementClass.newInstance(); // deprecated
					elementObject = elementClass.getDeclaredConstructor().newInstance(); // default value

					if ((elementObject instanceof org.web3d.x3d.jsail.Core.X3D) // remember root node of X3D model if found
						|| ((loadedX3dModelInstance == null) && (elementObject instanceof org.web3d.x3d.jsail.X3DConcreteNode))) // found fragment
					{
						loadedX3dModelInstance = (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[) elementObject; // remember X3D root
						// starting a new scene, reset hash maps
						protoNameToNodeTypesHashMap.clear();
						protoDEFtoNodeTypesHashMap.clear();
						protoContainerFieldHashMap.clear();
					}
					else if (elementObject instanceof org.web3d.x3d.jsail.Core.ProtoDeclare) // remember prototype declarations
					{
						// inspect DOM to find ProtoDeclare name
						currentProtoDeclareNameValue = node.getAttributes().getNamedItem("name").getNodeValue();
						currentProtoNodeTypeFound = false;
					}
					else if (elementObject instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclare) // remember external prototype declarations
					{
						// inspect DOM to find ExternProtoDeclare name
						currentExternProtoDeclareNameValue = node.getAttributes().getNamedItem("name").getNodeValue();
						currentProtoNodeTypeFound = false;
					}
				}
				catch (ClassNotFoundException cnfe)
				{
					// TODO logging
					errorNotice = "[error] X3DLoaderDOM: fully qualified object packageName=" + packageName + " not found," +
						"\n   " + cnfe + " " + cnfe.getMessage();
					if ((cnfe.getCause()!= null) && !cnfe.getCause().getMessage().isEmpty())
                                            errorNotice += "\n   " + cnfe.getCause();
					validationResult.append(errorNotice).append("\n");
					System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
					cnfe.printStackTrace();
                    return null; // draconian parse
				}
				catch (IllegalAccessException iae)
				{
					// TODO logging
					errorNotice = "[error] X3DLoaderDOM: visibility of no-parameter constructor inaccessible for packageName=" + packageName + "," +
                                            "\n   " + iae + " " + iae.getMessage();
                                        if ((iae.getCause()!= null) && !iae.getCause().getMessage().isEmpty())
                                            errorNotice += "\n   " + iae.getCause();
					validationResult.append(errorNotice).append("\n");
					System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
					iae.printStackTrace();
                    return null; // draconian parse
				}
				catch (InstantiationException ie)
				{
					// TODO logging
					errorNotice = "[error] X3DLoaderDOM: Failure occurred inside constructor for packageName=" + packageName + "," +
                                            "\n   " + ie + " " + ie.getMessage();
                                        if ((ie.getCause()!= null) && !ie.getCause().getMessage().isEmpty())
                                            errorNotice += "\n   " + ie.getCause();
					validationResult.append(errorNotice).append("\n");
					System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
					ie.printStackTrace();
                    return null; // draconian parse
				}
				catch (Exception e)
				{
					// TODO logging
					errorNotice = "[error] X3DLoaderDOM: Exception occurred inside constructor for packageName=" + packageName + "," +
                                            "\n   " + e + " " + e.getMessage();
                                        if ((e.getCause()!= null) && !e.getCause().getMessage().isEmpty())
                                            errorNotice += "\n   " + e.getCause();
					validationResult.append(errorNotice).append("\n");
					System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
					e.printStackTrace();
                    return null; // draconian parse
				}

				// determine if any actual element child nodes are present
				org.w3c.dom.NodeList children = node.getChildNodes();
				for (int i = 0; i < children.getLength(); i++)
				{
					if (children.item(i).getNodeType() != org.w3c.dom.Node.TEXT_NODE)
					{
						nodeChildFound = true;
						break;
					}
				}
				// recurse on each non-attribute child
				if (nodeChildFound == true)
				{
					// iterating over children, adding each child to current (parent) node using appropriate method.
					// n.b. assumes X3D scene is valid!
					for (int i = 0; i < children.getLength(); i++)
					{
						if ((children.item(i) == null) || (elementObject == null) ||
						    (children.item(i).getNodeType() == org.w3c.dom.Node.TEXT_NODE))
							continue; // break to end of loop, continue with next Node children.item(i)

						// recurse on children having elementObject as parent
						X3DConcreteElement childX3dElement = toX3dModelInstance(children.item(i), elementObject);
						if ((childX3dElement == null) || (childX3dElement.getElementName() == null))
							continue;
						String       childElementName = childX3dElement.getElementName();
						String childProtoInstanceName = new String();
						String childProtoInstanceUSE  = new String();
						String         containerField = new String();
						if (children.item(i).getAttributes().getNamedItem("containerField") != null)
						{
							containerField = children.item(i).getAttributes().getNamedItem("containerField").getNodeValue();
                            // TODO containerField synonyms
							if ((childX3dElement instanceof X3DConcreteNode) && !(containerField == null) && !containerField.isEmpty())
								 ((X3DConcreteNode)childX3dElement).setContainerFieldOverride(containerField);
						}
						String  protoInstanceNodeType = new String();
						String                    DEF = new String();

						try // adding this object to scene graph
						{
							// TODO better handling of prototypes is needed
							if      (nodeName.equals("ProtoBody"))
							{
								// remember ProtoDeclare type when found
								if (!currentProtoNodeTypeFound)
								{
									currentProtoNodeTypeFound = true;
									protoNameToNodeTypesHashMap.put(currentProtoDeclareNameValue, childElementName);
									// debug trace
									if (ConfigurationProperties.isDebugModeActive())
									{
										System.out.println ("[X3DLoaderDOM] ProtoBody/ProtoDeclare name='" + currentProtoDeclareNameValue +
										"' childElementName='" + childElementName +
										"' protoNameToNodeTypesHashMap.keySet()=" + protoNameToNodeTypesHashMap.keySet() +
										"' protoNameToNodeTypesHashMap.values()=" + protoNameToNodeTypesHashMap.values());
									}
								}
							}
							else if      (nodeName.equals("ExternProtoDeclare"))
							{
								// note ExternProtoDeclare type when found
								if (!currentProtoNodeTypeFound)
								{
									currentProtoNodeTypeFound = true;
									protoNameToNodeTypesHashMap.put(currentExternProtoDeclareNameValue, "ExternProtoDeclare");
									// debug trace
									if (ConfigurationProperties.isDebugModeActive())
									{
										System.out.println ("[X3DLoaderDOM] ExternProtoDeclare name='" + currentExternProtoDeclareNameValue +
												"' protoNameToNodeTypesHashMap.keySet()=" + protoNameToNodeTypesHashMap.keySet() +
												"' protoNameToNodeTypesHashMap.values()=" + protoNameToNodeTypesHashMap.values());
									}
								}
							}
							else if (childElementName.equals("ProtoInstance"))
							{
								// use DOM to find name for this element
								if (children.item(i).getAttributes().getNamedItem("name") != null)
									childProtoInstanceName = children.item(i).getAttributes().getNamedItem("name").getNodeValue();

								// containerField already found
// TODO confirm, remove:		protoInstanceNodeType = protoNameToNodeTypesHashMap.get(currentProtoDeclareNameValue);
								protoInstanceNodeType = protoNameToNodeTypesHashMap.get(childProtoInstanceName);
								// debug trace
								if (ConfigurationProperties.isDebugModeActive())
								{
									System.out.println ("[X3DLoaderDOM] ProtoInstance name='" + childProtoInstanceName +
											"' protoInstanceNodeType='" + protoInstanceNodeType  +
											"' protoNameToNodeTypesHashMap.keySet()=" + protoNameToNodeTypesHashMap.keySet() +
											"' protoNameToNodeTypesHashMap.values()=" + protoNameToNodeTypesHashMap.values());
								}

								if (children.item(i).getAttributes().getNamedItem("DEF") != null)		// DOM
								{
									// save node type for this ProtoInstance DEF so that ProtoInstance USE can find it later
									String childProtoInstanceDEF = children.item(i).getAttributes().getNamedItem("DEF").getNodeValue();
									protoDEFtoNodeTypesHashMap.put(childProtoInstanceDEF, protoInstanceNodeType);
									protoContainerFieldHashMap.put(childProtoInstanceDEF, containerField);
								}
								else if (children.item(i).getAttributes().getNamedItem("USE") != null)	// DOM
								{
									// ProtoInstance USE syntax does not include name, must find it via original DEF
									childProtoInstanceUSE = children.item(i).getAttributes().getNamedItem("USE").getNodeValue();
									protoInstanceNodeType = protoDEFtoNodeTypesHashMap.get(childProtoInstanceUSE); // find it
									       containerField = protoContainerFieldHashMap.get(childProtoInstanceUSE); // find it
								}
								if (!containerField.equals("children"))
									((ProtoInstance) childX3dElement).setContainerField(containerField);
								// diagnostics
								if ((childProtoInstanceUSE != null) && !childProtoInstanceUSE.isEmpty() &&
								    ((protoInstanceNodeType == null) ||  protoInstanceNodeType.isEmpty()))
								{

									// TODO logging
									errorNotice = "[error] X3DLoaderDOM: ProtoInstance " + childProtoInstanceName +
										" found with USE " + childProtoInstanceUSE + " but unable to find original ProtoInstance DEF node type, thus unable to add to scene graph";
									validationResult.append(errorNotice).append("\n");
									System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
									continue;
								}
								else if (((protoInstanceNodeType == null) || protoInstanceNodeType.isEmpty()) &&
								         ((       containerField == null) ||        containerField.isEmpty()))
								{
									// TODO logging
									errorNotice = "[warning] X3DLoaderDOM: ProtoInstance " + childProtoInstanceName +
										" found but node type is unknown and " +
										"containerField is missing, assuming default value 'children'";
									containerField = "children"; // ProtoInstance default
                                    // TODO lookup default containerField for this node type for more robust recovery from content errors
								}
								else if ((protoInstanceNodeType == null) || protoInstanceNodeType.isEmpty())
								{
									// TODO logging
									errorNotice = "[error] X3DLoaderDOM: ProtoInstance " + childProtoInstanceName +
										" found but node type is unknown and " +
										"containerField is " + containerField + ", unable to add to scene graph";
									validationResult.append(errorNotice).append("\n");
									System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
									continue;
								}
								if ((containerField == null) || containerField.isEmpty())
								{
									// TODO logging
									errorNotice = "[warning] X3DLoaderDOM: ProtoInstance " + childProtoInstanceName +
										" found and node type is " + protoInstanceNodeType + " but " +
										"containerField is missing, assuming default value 'children'";
									containerField = "children"; // ProtoInstance default
                                    // TODO lookup default containerField for this node type for more robust recovery from content errors
									validationResult.append(errorNotice).append("\n");
									System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
									continue;
								}
								/* no longer needed, using protoNodeTypeHashMap, wasn't yet connected by parse process anyway
								// must find node type of corresponding prototype in order to add it to current parent element
								ProtoDeclare protoDeclare = (ProtoDeclare) loadedX3dModelInstance.findElementByNameValue(childProtoInstanceName,ProtoDeclare.NAME);
								if (protoDeclare != null)
								{
								    protoInstanceNodeType = protoDeclare.getNodeType();
								}
								else // no protoDeclare found, look for externProtoDeclare
								{
									ExternProtoDeclare externProtoDeclare = (ExternProtoDeclare) loadedX3dModelInstance.findElementByNameValue(childProtoInstanceName,ExternProtoDeclare.NAME);
									if (externProtoDeclare != null)
										protoInstanceNodeType = externProtoDeclare.getNodeType();
								}
								*/
							}
                            // parent-child node addition according to typed methods
							if      (childElementName.equals("head"))
									((X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[)elementObject).setHead ((head) childX3dElement);
							else if (childElementName.equals("component"))
									((head)elementObject).addComponent ((component) childX3dElement);
							else if (childElementName.equals("meta"))
							{
									((head)elementObject).addMeta ((meta) childX3dElement);
									String metaName    = new String();
									String metaContent = new String();
									// use DOM to find name and content for this element, then post any error/warning/info for this document
									if (children.item(i).getAttributes().getNamedItem("name") != null)
										metaName    = children.item(i).getAttributes().getNamedItem("name").getNodeValue();
									if (children.item(i).getAttributes().getNamedItem("content") != null)
										metaContent = children.item(i).getAttributes().getNamedItem("content").getNodeValue();
									if (metaName.equalsIgnoreCase("error") || metaName.equalsIgnoreCase("warning") || metaName.equalsIgnoreCase("hint") || metaName.equalsIgnoreCase("info"))
									System.out.println ("[X3DLoaderDOM] <meta name='" + metaName + "' content='" + metaContent + "'/>");
							}
							else if (childElementName.equals("unit"))
									((head)elementObject).addUnit ((unit) childX3dElement);
							else if (childElementName.equals("Scene"))
									((X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[)elementObject).setScene ((Scene) childX3dElement);
							else if (nodeName.equals("Scene") && childElementName.startsWith("Metadata"))
									((Scene)elementObject).addMetadata ((X3DMetadataObject) childX3dElement);
							else if (nodeName.equals("Scene") && childElementName.equals("LayerSet"))
									((Scene)elementObject).addLayerSet ((LayerSet) childX3dElement);
							else if (nodeName.equals("Scene"))
									((Scene)elementObject).addChild((X3DChildNode) childX3dElement); // use non-pipelined method for max coverage
							// CommentsBlock handled by case org.w3c.dom.Node.COMMENT_NODE

							// proto and field handling begins here to avoid possible subsequent missteps
							else if (nodeName.equals("ProtoDeclare") && childElementName.equals("ProtoInterface"))
									((ProtoDeclare)elementObject).setProtoInterface((ProtoInterface) childX3dElement);
							else if (nodeName.equals("Script") && childElementName.equals("field"))
									((Script)elementObject).addField((field) childX3dElement);
							else if (nodeName.equals("ProtoInterface") && childElementName.equals("field"))
									((ProtoInterface)elementObject).addField((field) childX3dElement);
							else if (nodeName.equals("ExternProtoDeclare") && childElementName.equals("field"))
									((ExternProtoDeclare)elementObject).addField((field) childX3dElement);
							else if (nodeName.equals("ComposedShader") && childElementName.equals("field"))
									((ComposedShader)elementObject).addField((field) childX3dElement);
							else if (nodeName.equals("ProtoBody"))
									((ProtoBody)elementObject).addChild((X3DNode) childX3dElement); // note looser node type
							else if (childElementName.equals("ProtoBody"))
									((ProtoDeclare)elementObject).setProtoBody((ProtoBody) childX3dElement);
							else if (nodeName.equals("field"))
									((field)elementObject).addChild((X3DNode) childX3dElement); // avoid duplicative addChildren, not pipelined
							else if (nodeName.equals("fieldValue"))
									((fieldValue)elementObject).addChild((X3DNode) childX3dElement); // avoid duplicative addChildren, not pipelined
							else if (childElementName.equals("fieldValue"))
									((ProtoInstance)elementObject).setFieldValue((fieldValue) childX3dElement);
							else if (nodeName.equals("ShaderProgram") && childElementName.equals("field"))
									((ShaderProgram)elementObject).addField((field) childX3dElement);
							else if (nodeName.equals("ComposedShader") && childElementName.equals("field"))
									((ComposedShader)elementObject).addField((field) childX3dElement);
							else if (nodeName.equals("PackagedShader") && childElementName.equals("field"))
									((PackagedShader)elementObject).addField((field) childX3dElement);

							else if (nodeName.equals("Collision") && (containerField.equals("proxy")))
									((Collision)elementObject).setProxy ((X3DChildNode) childX3dElement);
							else if (nodeName.equals("Collision")  && childElementName.equals("ProtoInstance") && (containerField.equals("proxy"))) // Shape and grouping nodes
									((Collision)elementObject).setProxy ((ProtoInstance) childX3dElement);

							// TODO better checks for metadata containerField and various combinations
							else if (nodeName.equals("MetadataSet") && childElementName.startsWith("Metadata") && (!containerField.equals("metadata")))
									((MetadataSet)elementObject).addValue ((X3DNode) childX3dElement);
							else if (nodeName.equals("MetadataSet") && childElementName.equals("ProtoInstance") && (!containerField.equals("metadata")))
									((MetadataSet)elementObject).addValue ((X3DNode) childX3dElement);
							else if (childElementName.startsWith("Metadata"))
									((X3DConcreteNode)elementObject).setMetadata ((X3DMetadataObject) childX3dElement);
							else if ((protoInstanceNodeType.equals("Metadata") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("metadata") || containerField.isEmpty()))
									((X3DConcreteNode)elementObject).setMetadata ((ProtoInstance) childX3dElement);

							else if (childElementName.equals("Appearance"))
									((Shape)elementObject).setAppearance ((X3DAppearanceNode) childX3dElement);
							else if ((protoInstanceNodeType.equals("Appearance") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("appearance") || containerField.isEmpty()))
									((Shape)elementObject).setAppearance ((ProtoInstance) childX3dElement);

							else if (childElementName.equals("Material"))
									((Appearance)elementObject).setMaterial ((Material) childX3dElement);
							else if ((protoInstanceNodeType.equals("Material") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("material")))
									((Appearance)elementObject).setMaterial ((ProtoInstance) childX3dElement);

							else if (childElementName.equals("TwoSidedMaterial"))
									((Appearance)elementObject).setMaterial ((TwoSidedMaterial) childX3dElement);
							else if ((protoInstanceNodeType.equals("TwoSidedMaterial") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("material")))
									((Appearance)elementObject).setMaterial ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("Appearance") && childElementName.equals("LineProperties") && ((containerField.equals("lineProperties") || containerField.isEmpty())))
									((Appearance)elementObject).setLineProperties ((LineProperties) childX3dElement);
							else if (nodeName.equals("Appearance") && (protoInstanceNodeType.equals("LineProperties") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("lineProperties") || containerField.isEmpty())))
									((Appearance)elementObject).setLineProperties ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("Appearance") && childElementName.equals("FillProperties"))
									((Appearance)elementObject).setFillProperties ((FillProperties) childX3dElement);
							else if (nodeName.equals("Appearance") && (protoInstanceNodeType.equals("FillProperties") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("fillProperties") || containerField.isEmpty())))
									((Appearance)elementObject).setFillProperties ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("TextureBackground") && (childElementName.endsWith("Texture")) && (containerField.equals("backTexture")))
									((TextureBackground)elementObject).setBackTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("TextureBackground") && (protoInstanceNodeType.endsWith("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("backTexture") || containerField.isEmpty())))
									((TextureBackground)elementObject).setBackTexture ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("TextureBackground") && (childElementName.endsWith("Texture")) && (containerField.equals("bottomTexture")))
									((TextureBackground)elementObject).setBottomTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("TextureBackground") && (protoInstanceNodeType.endsWith("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("bottomTexture") || containerField.isEmpty())))
									((TextureBackground)elementObject).setBottomTexture ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("TextureBackground") && (childElementName.endsWith("Texture")) && (containerField.equals("frontTexture")))
									((TextureBackground)elementObject).setFrontTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("TextureBackground") && (protoInstanceNodeType.endsWith("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("frontTexture") || containerField.isEmpty())))
									((TextureBackground)elementObject).setFrontTexture ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("TextureBackground") && (childElementName.endsWith("Texture")) && (containerField.equals("leftTexture")))
									((TextureBackground)elementObject).setLeftTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("TextureBackground") && (protoInstanceNodeType.endsWith("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("leftTexture") || containerField.isEmpty())))
									((TextureBackground)elementObject).setLeftTexture ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("TextureBackground") && (childElementName.endsWith("Texture")) && (containerField.equals("rightTexture")))
									((TextureBackground)elementObject).setRightTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("TextureBackground") && (protoInstanceNodeType.endsWith("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("rightTexture") || containerField.isEmpty())))
									((TextureBackground)elementObject).setRightTexture ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("TextureBackground") && (childElementName.endsWith("Texture")) && (containerField.equals("topTexture")))
									((TextureBackground)elementObject).setTopTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("TextureBackground") && (protoInstanceNodeType.endsWith("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("topTexture") || containerField.isEmpty())))
									((TextureBackground)elementObject).setTopTexture ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("Sound") && (childElementName.equals("AudioClip") || childElementName.equals("MovieTexture")))
									((Sound)elementObject).setSource ((X3DSoundSourceNode) childX3dElement);
							else if (nodeName.equals("Sound") && (protoInstanceNodeType.equals("AudioClip") || protoInstanceNodeType.equals("MovieTexture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("source") || containerField.isEmpty())))
									((Sound)elementObject).setSource ((ProtoInstance) childX3dElement);
                            // TODO other audio-graph nodes

							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture")                                                            && (containerField.equals("front") || containerField.equals("frontTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setFrontTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && (protoInstanceNodeType.equals("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("front") || containerField.equals("frontTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setFrontTexture ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture")                                                            && (containerField.equals("back") || containerField.equals("backTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setBackTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && (protoInstanceNodeType.equals("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("back") || containerField.equals("backTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setBackTexture ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture")                                                            && (containerField.equals("left") || containerField.equals("leftTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setLeftTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && (protoInstanceNodeType.equals("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("left") || containerField.equals("leftTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setLeftTexture ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture")                                                            && (containerField.equals("right") || containerField.equals("rightTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setRightTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && (protoInstanceNodeType.equals("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("right") || containerField.equals("rightTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setRightTexture ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture")                                                            && (containerField.equals("top") || containerField.equals("topTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setTopTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && (protoInstanceNodeType.equals("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("top") || containerField.equals("topTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setTopTexture ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture")                                                            && (containerField.equals("bottom") || containerField.equals("bottomTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setBottomTexture ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && (protoInstanceNodeType.equals("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("bottom") || containerField.equals("bottomTexture") || containerField.isEmpty()))
									((ComposedCubeMapTexture)elementObject).setBottomTexture ((ProtoInstance) childX3dElement);
							// these checks follow preceding containerField-specific tests
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture"))
							{
										errorNotice = "[error] X3DLoaderDOM: parent " + nodeName + " has child " + childElementName + " with invalid containerField='" + containerField + "' (must have value of front, back, left, right, top or bottom)";
										validationResult.append(errorNotice).append("\n");
							}
							else if (nodeName.equals("ComposedCubeMapTexture") && protoInstanceNodeType.equals("Texture"))
							{
										errorNotice = "[error] X3DLoaderDOM: parent " + nodeName + " has child ProtoInstance with invalid containerField='" + containerField + "' (must have value of front, back, left, right, top or bottom)";
										validationResult.append(errorNotice).append("\n");
							}

							else if (nodeName.equals("Appearance") && childElementName.endsWith("Texture") && (containerField.equals("texture") || containerField.isEmpty()))
									((Appearance)elementObject).setTexture ((X3DTextureNode) childX3dElement);
							else if (nodeName.equals("Appearance") && (protoInstanceNodeType.endsWith("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texture") || containerField.isEmpty()))
									((Appearance)elementObject).setTexture ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("Appearance") && childElementName.contains("TextureTransform") && (containerField.equals("textureTransform") || containerField.isEmpty()))
									((Appearance)elementObject).setTextureTransform ((X3DTextureTransformNode) childX3dElement);
							else if (nodeName.equals("Appearance") && (protoInstanceNodeType.contains("TextureTransform") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("textureTransform") || containerField.isEmpty()))
									((Appearance)elementObject).setTextureTransform ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("Appearance") && (childElementName.equals("ComposedShader") || childElementName.equals("PackagedShader") || childElementName.equals("ProgramShader")) && (containerField.equals("shaders") || containerField.isEmpty()))
									((Appearance)elementObject).addShaders ((X3DShaderNode) childX3dElement);
							else if (nodeName.equals("Appearance") && (protoInstanceNodeType.contains("Shader") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("shaders") || containerField.isEmpty()))
									((Appearance)elementObject).addShaders ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("ComposedShader") && childElementName.equals("ShaderPart") && (containerField.equals("parts") || containerField.isEmpty()))
									((ComposedShader)elementObject).addParts ((ShaderPart) childX3dElement);
							else if (nodeName.equals("ComposedShader") && (protoInstanceNodeType.equals("ShaderPart") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("parts") || containerField.isEmpty()))
									((ComposedShader)elementObject).addParts ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("ProgramShader") && childElementName.equals("ShaderProgram") && (containerField.equals("programs") || containerField.isEmpty()))
									((ProgramShader)elementObject).addPrograms ((ShaderProgram) childX3dElement);
							else if (nodeName.equals("ProgramShader") && (protoInstanceNodeType.equals("ShaderProgram") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("programs") || containerField.isEmpty()))
									((ProgramShader)elementObject).addPrograms ((ProtoInstance) childX3dElement);

							else if ((childElementName.equals("Box") || childElementName.equals("Cone") || childElementName.equals("Cylinder") ||
									  childElementName.equals("Sphere") || childElementName.equals("Text") || childElementName.equals("IndexedFaceSet") ||
									  childElementName.equals("Arc2d") || childElementName.equals("ArcClose2d") || childElementName.equals("Circle2D") ||
									  childElementName.equals("Disk2D") || childElementName.equals("Polyline2D") || childElementName.equals("Polypoint2D") ||
									  childElementName.equals("Rectangle2D") || childElementName.equals("TriangleSet2D") ||
									  childElementName.equals("ElevationGrid") || childElementName.equals("Extrusion") || childElementName.equals("GeoElevationGrid") ||
									  childElementName.equals("IndexedLineSet") || childElementName.equals("IndexedPointSet") || childElementName.equals("IndexedQuadSet") ||
									  childElementName.equals("LineSet") || childElementName.equals("PointSet") || childElementName.equals("QuadSet") ||
									  childElementName.equals("IndexedTriangleFanSet") || childElementName.equals("IndexedTriangleSet") || childElementName.equals("IndexedTriangleStripSet") ||
									  childElementName.equals("TriangleFanSet") || childElementName.equals("TriangleSet") || childElementName.equals("TriangleStripSet") ||
									  childElementName.equals("NurbsCurve") || childElementName.equals("NurbsSweptSurface") || childElementName.equals("NurbsSwungSurface")
									 ) && containerField.equals("geometry")
									)
									  ((Shape)elementObject).setGeometry ((X3DGeometryNode) childX3dElement);

							else if ((protoInstanceNodeType.equals("Box") || protoInstanceNodeType.equals("Cone") || protoInstanceNodeType.equals("Cylinder") ||
									  protoInstanceNodeType.equals("Sphere") || protoInstanceNodeType.equals("Text") || protoInstanceNodeType.equals("IndexedFaceSet") ||
									  protoInstanceNodeType.equals("Arc2d") || protoInstanceNodeType.equals("ArcClose2d") || protoInstanceNodeType.equals("Circle2D") ||
									  protoInstanceNodeType.equals("Disk2D") || protoInstanceNodeType.equals("Polyline2D") || protoInstanceNodeType.equals("Polypoint2D") ||
									  protoInstanceNodeType.equals("Rectangle2D ") || protoInstanceNodeType.equals("TriangleSet2D") ||
									  protoInstanceNodeType.equals("ElevationGrid") || protoInstanceNodeType.equals("Extrusion") || protoInstanceNodeType.equals("GeoElevationGrid") ||
									  protoInstanceNodeType.equals("IndexedLineSet") || protoInstanceNodeType.equals("IndexedPointSet") || protoInstanceNodeType.equals("IndexedQuadSet") ||
									  protoInstanceNodeType.equals("LineSet") || protoInstanceNodeType.equals("PointSet") || protoInstanceNodeType.equals("QuadSet") ||
									  protoInstanceNodeType.equals("IndexedTriangleFanSet") || protoInstanceNodeType.equals("IndexedTriangleSet") || protoInstanceNodeType.equals("IndexedTriangleStripSet") ||
									  protoInstanceNodeType.equals("TriangleFanSet") || protoInstanceNodeType.equals("TriangleSet") || protoInstanceNodeType.equals("TriangleStripSet") ||
									  protoInstanceNodeType.equals("NurbsCurve") || protoInstanceNodeType.equals("NurbsSweptSurface") || protoInstanceNodeType.equals("NurbsSwungSurface") ||
									  protoInstanceNodeType.equals("ExternProtoDeclare")
									 ) && containerField.equals("geometry")
									)
									  ((Shape)elementObject).setGeometry ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("ElevationGrid") && (childElementName.equals("Color") || childElementName.equals("ColorRGBA")) && (containerField.equals("color") || containerField.isEmpty()))
									((ElevationGrid)elementObject).setColor((X3DColorNode) childX3dElement);
							else if (nodeName.equals("ElevationGrid") && (protoInstanceNodeType.equals("Color") || protoInstanceNodeType.equals("ColorRGBA") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("color"))
									((ElevationGrid)elementObject).setColor((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && (childElementName.equals("Color") || childElementName.equals("ColorRGBA")) && (containerField.equals("color") || containerField.isEmpty()))
									((GeoElevationGrid)elementObject).setColor((X3DColorNode) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && (protoInstanceNodeType.equals("Color") || protoInstanceNodeType.equals("ColorRGBA") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("color"))
									((GeoElevationGrid)elementObject).setColor((ProtoInstance) childX3dElement);

							else if (nodeName.equals("ElevationGrid") && childElementName.equals("Normal") && (containerField.equals("normal") || containerField.isEmpty()))
									((ElevationGrid)elementObject).setNormal((Normal) childX3dElement);
							else if (nodeName.equals("ElevationGrid") && (protoInstanceNodeType.equals("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("normal"))
									((ElevationGrid)elementObject).setNormal((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && childElementName.equals("Normal") && (containerField.equals("normal") || containerField.isEmpty()))
									((GeoElevationGrid)elementObject).setNormal((Normal) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && (protoInstanceNodeType.equals("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("normal"))
									((GeoElevationGrid)elementObject).setNormal((ProtoInstance) childX3dElement);

							else if (nodeName.equals("ElevationGrid") && childElementName.contains("TextureCoordinate") && (containerField.equals("texCoord") || containerField.isEmpty()))
									((ElevationGrid)elementObject).setTexCoord((X3DSingleTextureCoordinateNode) childX3dElement);
							else if (nodeName.equals("ElevationGrid") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("texcoord"))
									((ElevationGrid)elementObject).setTexCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && childElementName.contains("TextureCoordinate") && (containerField.equals("texCoord") || containerField.isEmpty()))
									((GeoElevationGrid)elementObject).setTexCoord((X3DSingleTextureCoordinateNode) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("texcoord"))
									((GeoElevationGrid)elementObject).setTexCoord((ProtoInstance) childX3dElement);

							else if (nodeName.equals("LoadSensor") && (childElementName.equals("Anchor")         || childElementName.equals("AudioClip")           || childElementName.equals("DISEntityTypeMapping") ||
                                                                       childElementName.equals("GeoMetadata")    || childElementName.equals("ImageCubeMapTexture") || childElementName.equals("ImageTexture3D") ||
                                                                       childElementName.equals("ImageTexture")   || childElementName.equals("Inline")              || childElementName.equals("MovieTexture") ||
                                                                       childElementName.equals("PackagedShader") || childElementName.equals("Script")              || childElementName.equals("ShaderPart") ||
                                                                       childElementName.equals("ShaderProgram"))
                                                                   && (containerField.equals("children") || containerField.equals("watchList") || containerField.equals("texture") || containerField.equals("programs") ||
                                                                       containerField.equals("parts")    || containerField.equals("mapping")   || containerField.equals("shaders") || containerField.equals("source"))) // children is new name in X3D4, otherwise still a common, unambiguous error
									((LoadSensor)elementObject).addChildren((X3DNode) childX3dElement); // formerly addWatchList in X3D3
							else if (nodeName.equals("LoadSensor") && (protoInstanceNodeType.equals("Anchor")         || protoInstanceNodeType.equals("AudioClip")           || protoInstanceNodeType.equals("DISEntityTypeMapping") ||
                                                                       protoInstanceNodeType.equals("GeoMetadata")    || protoInstanceNodeType.equals("ImageCubeMapTexture") || protoInstanceNodeType.equals("ImageTexture3D") ||
                                                                       protoInstanceNodeType.equals("ImageTexture")   || protoInstanceNodeType.equals("Inline")              || protoInstanceNodeType.equals("MovieTexture") ||
                                                                       protoInstanceNodeType.equals("PackagedShader") || protoInstanceNodeType.equals("Script")              || protoInstanceNodeType.equals("ShaderPart") ||
                                                                       protoInstanceNodeType.equals("ShaderProgram"))
                                                                   && (containerField.equals("children") || containerField.equals("watchList") || containerField.equals("texture") || containerField.equals("programs") ||
                                                                       containerField.equals("parts")    || containerField.equals("mapping")   || containerField.equals("shaders") || containerField.equals("source"))) // children is new name in X3D4, otherwise still a common, unambiguous error
									((LoadSensor)elementObject).addChildren((ProtoInstance) childX3dElement);

							else if (nodeName.equals("CADFace") && (childElementName.equals("Shape") || childElementName.equals("LOD") || childElementName.equals("Transform")) && containerField.equals("shape"))
									((CADFace)elementObject).setShape((X3DNode) childX3dElement);
							else if (nodeName.equals("CADFace") && (protoInstanceNodeType.equals("Shape") || protoInstanceNodeType.equals("LOD") || protoInstanceNodeType.equals("Transform") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("shape"))
									((CADFace)elementObject).setShape((ProtoInstance) childX3dElement);

							else if (nodeName.equals("Scene") && (childElementName.equals("EspduTransform") || childElementName.equals("ReceiverPdu") ||
                                                                  childElementName.equals("SignalPdu") || childElementName.equals("TransmitterPdu") ||
                                                                  childElementName.equals("DISEntityManager")) && containerField.equals("children"))
									((Scene)elementObject).addChild((EspduTransform) childX3dElement);
							else if ((childElementName.equals(EspduTransform.NAME)) && containerField.equals("children"))
									((X3DGroupingNode)elementObject).addChildren(new org.web3d.x3d.sai.Core.X3DNode[] { (X3DNode) childX3dElement } ); // default fallback can throw exception
							else if (nodeName.equals("DISEntityManager") && (childElementName.equals("DISEntityTypeMapping")) && (containerField.equals("children") || containerField.equals("mapping")))
									((DISEntityManager)elementObject).addChildren((DISEntityTypeMapping) childX3dElement); // formerly addMapping in X3D3
							else if (nodeName.equals("DISEntityManager") && protoInstanceNodeType.equals("DISEntityTypeMapping"))
									((DISEntityManager)elementObject).addChildren((ProtoInstance) childX3dElement);        // formerly addMapping in X3D3

							else if (nodeName.equals("GeoCoordinate") && childElementName.equals("GeoOrigin"))
									((GeoCoordinate)elementObject).setGeoOrigin((GeoOrigin) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && childElementName.equals("GeoOrigin"))
									((GeoElevationGrid)elementObject).setGeoOrigin((GeoOrigin) childX3dElement);
							else if (nodeName.equals("GeoLocation") && childElementName.equals("GeoOrigin"))
									((GeoLocation)elementObject).setGeoOrigin((GeoOrigin) childX3dElement);
							else if (nodeName.equals("GeoLOD") && childElementName.equals("GeoOrigin"))
									((GeoLOD)elementObject).setGeoOrigin((GeoOrigin) childX3dElement);
							else if (nodeName.equals("GeoPositionInterpolator") && childElementName.equals("GeoOrigin"))
									((GeoPositionInterpolator)elementObject).setGeoOrigin((GeoOrigin) childX3dElement);
							else if (nodeName.equals("GeoProximitySensor") && childElementName.equals("GeoOrigin"))
									((GeoProximitySensor)elementObject).setGeoOrigin((GeoOrigin) childX3dElement);
							else if (nodeName.equals("GeoTouchSensor") && childElementName.equals("GeoOrigin"))
									((GeoTouchSensor)elementObject).setGeoOrigin((GeoOrigin) childX3dElement);
							else if (nodeName.equals("GeoTransform") && childElementName.equals("GeoOrigin"))
									((GeoTransform)elementObject).setGeoOrigin((GeoOrigin) childX3dElement);
							else if (nodeName.equals("GeoViewpoint") && childElementName.equals("GeoOrigin"))
									((GeoViewpoint)elementObject).setGeoOrigin((GeoOrigin) childX3dElement);

							else if (nodeName.equals("GeoCoordinate") && protoInstanceNodeType.equals("GeoOrigin"))
									((GeoCoordinate)elementObject).setGeoOrigin((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && protoInstanceNodeType.equals("GeoOrigin"))
									((GeoElevationGrid)elementObject).setGeoOrigin((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoLocation") && protoInstanceNodeType.equals("GeoOrigin"))
									((GeoLocation)elementObject).setGeoOrigin((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoLOD") && protoInstanceNodeType.equals("GeoOrigin"))
									((GeoLOD)elementObject).setGeoOrigin((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoPositionInterpolator") && protoInstanceNodeType.equals("GeoOrigin"))
									((GeoPositionInterpolator)elementObject).setGeoOrigin((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoProximitySensor") && protoInstanceNodeType.equals("GeoOrigin"))
									((GeoProximitySensor)elementObject).setGeoOrigin((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoTouchSensor") && protoInstanceNodeType.equals("GeoOrigin"))
									((GeoTouchSensor)elementObject).setGeoOrigin((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoTransform") && protoInstanceNodeType.equals("GeoOrigin"))
									((GeoTransform)elementObject).setGeoOrigin((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoViewpoint") && protoInstanceNodeType.equals("GeoOrigin"))
									((GeoViewpoint)elementObject).setGeoOrigin((ProtoInstance) childX3dElement);

							// must follow GeoOrigin tests
                            else if (nodeName.equals("GeoLOD") && !protoInstanceNodeType.isEmpty())
									((GeoLOD)elementObject).addRootNode((ProtoInstance) childX3dElement);
							else if (nodeName.equals("GeoLOD"))
									((GeoLOD)elementObject).addRootNode((X3DNode) childX3dElement);

							else if (nodeName.equals("Scene") && (childElementName.equals("HAnimHumanoid")) && containerField.equals("children"))
									((Scene)elementObject).addChild((HAnimHumanoid) childX3dElement);
							else if ((childElementName.equals("HAnimHumanoid")) && containerField.equals("children"))
									((X3DGroupingNode)elementObject).addChildren(new org.web3d.x3d.sai.Core.X3DNode[] { (X3DNode) childX3dElement } ); // default fallback can throw exception
							else if (nodeName.equals("HAnimHumanoid") && (childElementName.equals("HAnimJoint") || childElementName.equals("HAnimSite")) && containerField.equals("skeleton"))
									((HAnimHumanoid)elementObject).addSkeleton((X3DNode) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && (protoInstanceNodeType.equals("HAnimJoint") || protoInstanceNodeType.equals("HAnimSite") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("skeleton"))
									((HAnimHumanoid)elementObject).addSkeleton((ProtoInstance) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && containerField.equals("skin"))
									((HAnimHumanoid)elementObject).addSkin((X3DNode) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && childElementName.equals("HAnimJoint") && containerField.equals("joints"))
									((HAnimHumanoid)elementObject).addJoints((HAnimJoint) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && (protoInstanceNodeType.equals("HAnimJoint") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("joints"))
									((HAnimHumanoid)elementObject).addJoints((ProtoInstance) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && childElementName.equals("HAnimSegment") && containerField.equals("segments"))
									((HAnimHumanoid)elementObject).addSegments((HAnimSegment) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && (protoInstanceNodeType.equals("HAnimSegment") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("segments"))
									((HAnimHumanoid)elementObject).addSegments((ProtoInstance) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && childElementName.equals("HAnimSite") && containerField.equals("sites"))
									((HAnimHumanoid)elementObject).addSites((HAnimSite) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && (protoInstanceNodeType.equals("HAnimSite") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("sites"))
									((HAnimHumanoid)elementObject).addSites((ProtoInstance) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && childElementName.equals("HAnimSite") && containerField.equals("viewpoints"))
									((HAnimHumanoid)elementObject).addViewpoints((HAnimSite) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && (protoInstanceNodeType.equals("HAnimSite") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("viewpoints"))
									((HAnimHumanoid)elementObject).addViewpoints((ProtoInstance) childX3dElement);

							else if (nodeName.equals("HAnimHumanoid") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble")) && containerField.equals("skinCoord"))
									((HAnimHumanoid)elementObject).setSkinCoord ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("skinCoord"))
									((HAnimHumanoid)elementObject).setSkinCoord ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && childElementName.equals("Normal") && containerField.equals("skinNormal"))
									((HAnimHumanoid)elementObject).setSkinNormal ((X3DNormalNode) childX3dElement);
							else if (nodeName.equals("HAnimHumanoid") && (protoInstanceNodeType.equals("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("skinNormal"))
									((HAnimHumanoid)elementObject).setSkinNormal ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("HAnimJoint") && (childElementName.equals("HAnimJoint") || childElementName.equals("HAnimSegment") || childElementName.equals("HAnimSite")) && containerField.equals("children"))
									((HAnimJoint)elementObject).addChild((X3DChildNode) childX3dElement);
							else if (nodeName.equals("HAnimJoint") && (protoInstanceNodeType.equals("HAnimDisplacer") || protoInstanceNodeType.equals("HAnimSegment") || protoInstanceNodeType.equals("HAnimSite") || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("children"))
									((HAnimJoint)elementObject).addChild((X3DChildNode) childX3dElement);
							else if (nodeName.equals("HAnimJoint") && childElementName.equals("HAnimDisplacer") && (containerField.equals("displacers") || containerField.isEmpty()))
									((HAnimJoint)elementObject).addDisplacers((HAnimDisplacer) childX3dElement);
							else if (nodeName.equals("HAnimJoint") && (protoInstanceNodeType.equals("HAnimDisplacer") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("displacers") || containerField.isEmpty()))
									((HAnimJoint)elementObject).addDisplacers((ProtoInstance) childX3dElement);

							else if (nodeName.equals("HAnimSegment") && childElementName.equals("HAnimDisplacer") && (containerField.equals("displacers") || containerField.isEmpty()))
									((HAnimSegment)elementObject).addDisplacers((HAnimDisplacer) childX3dElement);
							else if (nodeName.equals("HAnimSegment") && (protoInstanceNodeType.equals("HAnimDisplacer") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("displacers") || containerField.isEmpty()))
									((HAnimSegment)elementObject).addDisplacers((ProtoInstance) childX3dElement);
							else if (nodeName.equals("HAnimSegment") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble")) && (containerField.equals("coord") || containerField.isEmpty()))
									((HAnimSegment)elementObject).setCoord ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("HAnimSegment") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((HAnimSegment)elementObject).setCoord ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("IndexedLineSet") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble") || childElementName.equals("GeoCoordinate")) && (containerField.equals("coord") || containerField.isEmpty()))
									((IndexedLineSet)elementObject).setCoord ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("IndexedLineSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((IndexedLineSet)elementObject).setCoord ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("LineSet") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble") || childElementName.equals("GeoCoordinate")) && (containerField.equals("coord") || containerField.isEmpty()))
									((LineSet)elementObject).setCoord ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("LineSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((LineSet)elementObject).setCoord ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("PointSet") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble") || childElementName.equals("GeoCoordinate")) && (containerField.equals("coord") || containerField.isEmpty()))
									((PointSet)elementObject).setCoord ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("PointSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((PointSet)elementObject).setCoord ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("NurbsPositionInterpolator") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble")) && containerField.equals("controlPoint"))
									((NurbsPositionInterpolator)elementObject).setControlPoint ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("NurbsPositionInterpolator") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("controlPoint"))
									((NurbsPositionInterpolator)elementObject).setControlPoint ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("NurbsOrientationInterpolator") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble")) && containerField.equals("controlPoint"))
									((NurbsOrientationInterpolator)elementObject).setControlPoint ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("NurbsOrientationInterpolator") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("controlPoint"))
									((NurbsOrientationInterpolator)elementObject).setControlPoint ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("NurbsSurfaceInterpolator") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble")) && containerField.equals("controlPoint"))
									((NurbsSurfaceInterpolator)elementObject).setControlPoint ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("NurbsSurfaceInterpolator") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("controlPoint"))
									((NurbsSurfaceInterpolator)elementObject).setControlPoint ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("NurbsPatchSurface") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble")) && containerField.equals("controlPoint"))
									((NurbsPatchSurface)elementObject).setControlPoint ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("NurbsPatchSurface") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("controlPoint"))
									((NurbsPatchSurface)elementObject).setControlPoint ((ProtoInstance) childX3dElement);
							else if (nodeName.equals("NurbsTrimmedSurface") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble")) && containerField.equals("controlPoint"))
									((NurbsTrimmedSurface)elementObject).setControlPoint ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("NurbsTrimmedSurface") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && containerField.equals("controlPoint"))
									((NurbsTrimmedSurface)elementObject).setControlPoint ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("IndexedLineSet") && childElementName.startsWith("Color") && (containerField.equals("color") || containerField.isEmpty()))
									((IndexedLineSet)elementObject).setColor ((X3DColorNode) childX3dElement);
							else if (nodeName.equals("IndexedLineSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((IndexedLineSet)elementObject).setColor ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("LineSet") && childElementName.startsWith("Color") && (containerField.equals("color") || containerField.isEmpty()))
									((LineSet)elementObject).setColor ((X3DColorNode) childX3dElement);
							else if (nodeName.equals("LineSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((LineSet)elementObject).setColor ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("PointSet") && childElementName.startsWith("Color") && (containerField.equals("color") || containerField.isEmpty()))
									((PointSet)elementObject).setColor ((X3DColorNode) childX3dElement);
							else if (nodeName.equals("PointSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((PointSet)elementObject).setColor ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("MultiTextureCoordinate") && childElementName.contains("TextureCoordinate") && (containerField.equals("texCoord") || containerField.isEmpty()))
									((MultiTextureCoordinate)elementObject).addTexCoord ((X3DTextureCoordinateNode) childX3dElement);
							else if (nodeName.equals("MultiTextureCoordinate") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((MultiTextureCoordinate)elementObject).addTexCoord ((ProtoInstance) childX3dElement);

							// X3DComposedGeometryNode for IndexedFaceSet, TriangleSet, QuadSet etc. No abstract methods for ProtoInstances since this is in SAI.
							// Note this block must follow (Indexed)LineSet, PointSet and MultiTextureCoordinate tests.
							// Note that FogCoordinate and TextureCoordinate tests must precede Texture and Coordinate tests.
							else if (nodeName.endsWith("Set") && childElementName.contains("FogCoordinate") && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((X3DComposedGeometryNode)elementObject).setFogCoord((FogCoordinate) childX3dElement);
							else if (nodeName.equals("IndexedFaceSet") && (protoInstanceNodeType.contains("FogCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((IndexedFaceSet)elementObject).setFogCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedQuadSet") && (protoInstanceNodeType.contains("FogCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((IndexedQuadSet)elementObject).setFogCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleSet") && (protoInstanceNodeType.contains("FogCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((IndexedTriangleSet)elementObject).setFogCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleFanSet") && (protoInstanceNodeType.contains("FogCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((IndexedTriangleFanSet)elementObject).setFogCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleStripSet") && (protoInstanceNodeType.contains("FogCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((IndexedTriangleStripSet)elementObject).setFogCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("QuadSet") && (protoInstanceNodeType.contains("FogCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((QuadSet)elementObject).setFogCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleSet") && (protoInstanceNodeType.contains("FogCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((TriangleSet)elementObject).setFogCoord((ProtoInstance) childX3dElement);
								else if (nodeName.equals("TriangleFanSet") && (protoInstanceNodeType.contains("FogCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((TriangleFanSet)elementObject).setFogCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleStripSet") && (protoInstanceNodeType.contains("FogCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fogCoord") || containerField.isEmpty()))
									((TriangleStripSet)elementObject).setFogCoord((ProtoInstance) childX3dElement);

							else if ((nodeName.endsWith("Set") || nodeName.endsWith("Surface")) && childElementName.contains("TextureCoordinate") && (containerField.equals("texCoord") || containerField.isEmpty()))
									((X3DComposedGeometryNode)elementObject).setTexCoord((X3DSingleTextureCoordinateNode) childX3dElement);
							else if (nodeName.equals("IndexedFaceSet") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((IndexedFaceSet)elementObject).setTexCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedQuadSet") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((IndexedQuadSet)elementObject).setTexCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleSet") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((IndexedTriangleSet)elementObject).setTexCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleFanSet") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((IndexedTriangleFanSet)elementObject).setTexCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleStripSet") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((IndexedTriangleStripSet)elementObject).setTexCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("QuadSet") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((QuadSet)elementObject).setTexCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleSet") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((TriangleSet)elementObject).setTexCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleFanSet") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((TriangleFanSet)elementObject).setTexCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleStripSet") && (protoInstanceNodeType.contains("TextureCoordinate") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texCoord") || containerField.isEmpty()))
									((TriangleStripSet)elementObject).setTexCoord((ProtoInstance) childX3dElement);

							else if (nodeName.endsWith("Set") && childElementName.startsWith("Color") && (containerField.equals("color") || containerField.isEmpty()))
									((X3DComposedGeometryNode)elementObject).setColor((X3DColorNode) childX3dElement);
							else if (nodeName.equals("IndexedFaceSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((IndexedFaceSet)elementObject).setColor((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedQuadSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((IndexedQuadSet)elementObject).setColor((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((IndexedTriangleSet)elementObject).setColor((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleFanSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((IndexedTriangleFanSet)elementObject).setColor((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleStripSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((IndexedTriangleStripSet)elementObject).setColor((ProtoInstance) childX3dElement);
							else if (nodeName.equals("QuadSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((QuadSet)elementObject).setColor((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((TriangleSet)elementObject).setColor((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleFanSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((TriangleFanSet)elementObject).setColor((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleStripSet") && (protoInstanceNodeType.startsWith("Color") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("color") || containerField.isEmpty()))
									((TriangleStripSet)elementObject).setColor((ProtoInstance) childX3dElement);

							else if (nodeName.endsWith("Set") && (childElementName.equals("Coordinate") || childElementName.equals("CoordinateDouble") || childElementName.equals("GeoCoordinate")) && (containerField.equals("coord") || containerField.isEmpty()))
									((X3DComposedGeometryNode)elementObject).setCoord((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("IndexedFaceSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((IndexedFaceSet)elementObject).setCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedQuadSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((IndexedQuadSet)elementObject).setCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((IndexedTriangleSet)elementObject).setCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleFanSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((IndexedTriangleFanSet)elementObject).setCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleStripSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((IndexedTriangleStripSet)elementObject).setCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("QuadSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((QuadSet)elementObject).setCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((TriangleSet)elementObject).setCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleFanSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((TriangleFanSet)elementObject).setCoord((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleStripSet") && ((protoInstanceNodeType.equals("Coordinate") || protoInstanceNodeType.equals("CoordinateDouble") || protoInstanceNodeType.equals("GeoCoordinate")) || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("coord") || containerField.isEmpty()))
									((TriangleStripSet)elementObject).setCoord((ProtoInstance) childX3dElement);

							else if (nodeName.endsWith("Set") && childElementName.equals("Normal") && containerField.equals("normal"))
									((X3DComposedGeometryNode)elementObject).setNormal((Normal) childX3dElement);
							else if (nodeName.equals("IndexedFaceSet") && (protoInstanceNodeType.contains("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("normal") || containerField.isEmpty()))
									((IndexedFaceSet)elementObject).setNormal((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedQuadSet") && (protoInstanceNodeType.contains("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("normal") || containerField.isEmpty()))
									((IndexedQuadSet)elementObject).setNormal((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleSet") && (protoInstanceNodeType.contains("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("normal") || containerField.isEmpty()))
									((IndexedTriangleSet)elementObject).setNormal((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleFanSet") && (protoInstanceNodeType.contains("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("normal") || containerField.isEmpty()))
									((IndexedTriangleFanSet)elementObject).setNormal((ProtoInstance) childX3dElement);
							else if (nodeName.equals("IndexedTriangleStripSet") && (protoInstanceNodeType.contains("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("normal") || containerField.isEmpty()))
									((IndexedTriangleStripSet)elementObject).setNormal((ProtoInstance) childX3dElement);
							else if (nodeName.equals("QuadSet") && (protoInstanceNodeType.contains("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("normal") || containerField.isEmpty()))
									((QuadSet)elementObject).setNormal((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleSet") && (protoInstanceNodeType.contains("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("normal") || containerField.isEmpty()))
									((TriangleSet)elementObject).setNormal((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleFanSet") && (protoInstanceNodeType.contains("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("normal") || containerField.isEmpty()))
									((TriangleFanSet)elementObject).setNormal((ProtoInstance) childX3dElement);
							else if (nodeName.equals("TriangleStripSet") && (protoInstanceNodeType.contains("Normal") || protoInstanceNodeType.equals("ExternProtoDeclare")) && ((containerField.equals("normal") || containerField.isEmpty()) || containerField.isEmpty()))
									((TriangleStripSet)elementObject).setNormal((ProtoInstance) childX3dElement);

							else if (nodeName.equals("StaticGroup") && (containerField.equals("children") || containerField.isEmpty()))
									((StaticGroup)elementObject).addChild((X3DChildNode) childX3dElement);
                            // TODO fix for prototype:
							else if (nodeName.equals("StaticGroup") && (containerField.equals("children") || containerField.isEmpty()))
									((StaticGroup)elementObject).addChild((ProtoInstance) childX3dElement);

							else if (nodeName.equals("ViewpointGroup") && childElementName.contains("Viewpoint") && (containerField.equals("children") || containerField.isEmpty()))
									((ViewpointGroup)elementObject).addChild((X3DNode) childX3dElement);
							else if (nodeName.equals("ViewpointGroup") && (protoInstanceNodeType.equals("Viewpoint") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("children") || containerField.isEmpty()))
									((ViewpointGroup)elementObject).addChild((ProtoInstance) childX3dElement);

							else if (nodeName.equals("Text") && childElementName.equals("FontStyle") && (containerField.equals("fontStyle") || containerField.isEmpty()))
									((Text)elementObject).setFontStyle ((X3DFontStyleNode) childX3dElement);
							else if (nodeName.equals("Text") && (protoInstanceNodeType.equals("FontStyle") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("fontStyle") || containerField.isEmpty()))
									((Text)elementObject).setFontStyle ((ProtoInstance) childX3dElement);

							else if (nodeName.equals("MultiTexture") && childElementName.contains("Texture") && (containerField.equals("texture") || containerField.isEmpty()))
									((MultiTexture)elementObject).addTexture((X3DTextureNode) childX3dElement);
							else if (nodeName.equals("MultiTexture") && (protoInstanceNodeType.contains("Texture") || protoInstanceNodeType.equals("ExternProtoDeclare")) && (containerField.equals("texture") || containerField.isEmpty()))
									((MultiTexture)elementObject).addTexture((ProtoInstance) childX3dElement);

							// no prototype for IS or connect
							else if (childElementName.equals("IS"))
									((X3DConcreteNode)elementObject).setIS ((IS) childX3dElement);
							else if (nodeName.equals("IS") && childElementName.equals("connect"))
									((IS)elementObject).addConnect ((connect) childX3dElement);

							// TODO more

							// default fallback works for majority of parent-child relationships but throws exception otherwise, also gives misleading diagnostic
							else
                            {
                                // Note that Scene statement was already handled earlier
                                if (!(elementObject instanceof X3DGroupingNode))
                                {
                                    errorNotice = "[error] X3DLoaderDOM: Parent-child node relationship not found! (parent " + nodeName + ", child " + childElementName +
                                                   ", containerField='" + containerField + "') Please report this problem to brutzman@nps.edu";
                                    validationResult.append(errorNotice);
                                    System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
                                }
                                ((X3DGroupingNode)elementObject).addChildren(new org.web3d.x3d.sai.Core.X3DNode[] { (X3DNode) childX3dElement } ); // default fallback can throw exception
                            }
							// making it this far without exception means satisfactory parent-child relationship found
						}
						// https://stackoverflow.com/questions/3495926/can-i-catch-multiple-java-exceptions-in-the-same-catch-clause
						catch (DOMException | ClassCastException ex)
						{
							// TODO logging
							errorNotice = "[error] X3DLoaderDOM: Incorrectly handled X3DJSAIL object construction, current elementObject=" + nodeName +
										  " (" + elementObject.getElementName() + "), child=\"" + childElementName +
										  "\", containerField=\"" + containerField + "\", " + ex + "\n";
							errorNotice+= "    This error can be caused by incorrect parent-child node relationships or incorrect containerField values." + "\n";
							errorNotice+= "    X3D node typing is strict, check or validate your scene graph!" + "\n";
							errorNotice+= "    This error can also be caused by X3DLoaderDOM DOM omissions in X3DJSAIL. Please report mysterious problems, thank you." + "\n";
							validationResult.append(errorNotice);
							System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
							ex.printStackTrace(); // further diagnosis needed, DOM loader errors are tricky
							continue;
						}
					}
				}
				// properly handle contained CDATA text after child elements handled
				if      (nodeName.equals("Script") && !node.getTextContent().trim().isEmpty())
				{
					((Script)elementObject).setSourceCode (node.getTextContent().trim());
				}
				else if (nodeName.equals("ShaderProgram") && !node.getTextContent().trim().isEmpty())
				{
					(( ShaderProgram)elementObject).setSourceCode (node.getTextContent().trim());
				}
				else if (nodeName.equals("ShaderPart") && !node.getTextContent().trim().isEmpty())
				{
					(( ShaderPart)elementObject).setSourceCode (node.getTextContent().trim());
				}

				// handle attributes next, note that DOM includes all attributes (including those with default values)

				org.w3c.dom.NamedNodeMap attributes = node.getAttributes();
				for (int i = 0; i < attributes.getLength(); i++)
				{
					String				    fieldTypePrefix;
					String				    fieldName = "[uninitializedFieldName]";
					Class<X3DConcreteField> fieldClass; // TODO <X3DConcreteField> ?
					X3DConcreteField	    field;
					Method			 	    fieldSetMethod;
					String			 	    fieldSetMethodName = "setValueByString";

					org.w3c.dom.Node currentAttributeNode = attributes.item(i);
					String attributeName  = currentAttributeNode.getNodeName();
					String attributeValue = currentAttributeNode.getNodeValue();
					// https://www.regexplanet.com/advanced/java/index.html
					// https://www.regular-expressions.info/java.html see "backslash-mess"
					// https://docs.oracle.com/javase/tutorial/java/data/characters.html
					// looks like no conversion needed when reading from DOM!
//					if (attributeValue.contains("\\"))
//						attributeValue = attributeValue.replaceAll("\\\\","\\\\"); // replace literal \ with \\
//					if (attributeValue.contains("\""))
//						attributeValue = attributeValue.replaceAll("\"","\\\"");   // replace literal " with \"
//					if (attributeValue.contains("Immel")) // trace
//						System.out.println (attributeValue);

					// errorNotice prelude now gets predefined (in case needed later)
					errorNotice = "[error] X3DLoaderDOM: <" + nodeName + " " + attributeName + "='" + attributeValue + "'/> exception: ";

					// ignore unused attributes
					if      (attributeName.equals("containerField"))
					{
						 continue; // containerField not saved, instead handled by scene-graph structure during serialization
					}
					else if (attributeName.startsWith("xmlns:") || attributeName.startsWith("xsd:") || // X3D element
							 attributeName.contains  (":")) // also skip any qualified element name
					{
						// TODO logging, consider warning
						// errorNotice = nodeName + " attribute ignored: " + attributeName;
						// validationResult.append(errorNotice).append("\n");
						// System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
						continue;
					}
                    // FontStyle style->glyphStyle renaming rejected, can accept any kind of value for style field, Mantis 1335

					String attributeType  = elementObject.getFieldType(attributeName); // X3DJSAIL utility
                    if (attributeType.equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE) || attributeType.contains("ERROR"))
                    {
                        errorNotice = "[error] X3DLoaderDOM: Reflection parsing unexpectedly encountered " + attributeType + " type when parsing attribute, " +
                                        nodeName + " " + attributeName + "='" + attributeValue + "'";
                        validationResult.append(errorNotice).append("\n");
                        System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
                    }
					elementSetMethodName  = "set";
					if      (attributeName.equals("class") || attributeName.equals("style"))
					{
                    	     elementSetMethodName += "Css";
					         elementSetMethodName += attributeName.substring(0,1).toUpperCase() +
						   	    			         attributeName.substring(1); // setCamelCase
					}
					else if (attributeName.equals("id"))
						     elementSetMethodName += "HtmlID";
					else     elementSetMethodName += attributeName.substring(0,1).toUpperCase() +
						   	    			         attributeName.substring(1); // setCamelCase

					// check for proper handling of SFString/MFString escape characters, particularly backslashed quotes
					String unescapedAttributeValue = attributeValue.replace("\\\\\"", "\\\""); // TODO regex needed for other cases of special character inputss?
					if   (!unescapedAttributeValue.equals(attributeValue))
					{
						// trace statement for debug use
						System.out.println ("*trace of X3DLoaderDOM DOM import: attributeValue='" + attributeValue +
								"', unescapedAttributeValue='" + unescapedAttributeValue +
								"', attributeName='" + attributeName +
								"', attributeType='" + attributeType + "'");
						attributeValue = unescapedAttributeValue;
					}
					// now add each attribute to element
					try // to first create corresponding field object, then invoke set method on parent node object
					{
						// first create field object, e.g. org.web3d.x3d.jsail.fields.SFFloatObject
						if   (attributeType.equals(SFString.NAME))
						{
							// SFString attribute values are easy: set value directly on parent object
							elementSetMethod  = elementClass.getMethod(elementSetMethodName, ((Class<String>[])new Class[] { String.class }));
							elementSetMethod.invoke (elementObject, new Object[] { attributeValue });
						}]]></xsl:text>
						<!--
						// not needed: previously problematic case
						else if   (attributeType.equals(SFVec3f.NAME))
						{
							// directly create object
							SFVec3fObject sfv3fo = new SFVec3f();
							sfv3fo.setValueByString(attributeValue);
							elementSetMethod  = elementClass.getMethod(elementSetMethodName, new Class[] { SFVec3f.class });
							elementSetMethod.invoke (elementObject, new Object[] { sfv3fo });
						}
						--><xsl:text disable-output-escaping="yes"><![CDATA[
						else if (attributeType.equals(SFNode.NAME) || attributeType.equals(MFNode.NAME))
						{
							// TODO logging
							errorNotice = "[error] X3DLoaderDOM: Reflection parsing unexpectedly encountered " + attributeType + " type when parsing attribute, " +
                                        nodeName + " " + attributeName + "='" + attributeValue + "'" +
                                        ", possily due to naming mismatch between XML Schema/X3DUOM, DOCTYPE, or default-values cleanup.";
							validationResult.append(errorNotice).append("\n");
							System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
							continue;
						}
						else // other SF* or MF* type: build corresponding field, then invoke set method on element
						{
							fieldTypePrefix = "org.web3d.x3d.jsail.fields.";
							fieldName       = fieldTypePrefix + attributeType; // formerly + "Object"
							fieldClass      = (Class<X3DConcreteField>)Class.forName(fieldName);
							// Class.newInstance() creates constructor using no parameters
                            // https://stackoverflow.com/questions/46393863/what-to-use-instead-of-class-newinstance
						// 	field           = fieldClass.newInstance(); // default value; deprecated
                            field           = fieldClass.getDeclaredConstructor().newInstance(); // default value
							field.initialize(); // make sure reset

							// Invoke protected field.setValueByString() to match
							// fieldClass.getDeclaredMethods(); // debug use; must be Declared for protected visibility
							fieldSetMethod = fieldClass.getDeclaredMethod(fieldSetMethodName, ((Class<String>[])new Class[] { String.class }));

							// https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html
							if (!Modifier.isPublic(fieldSetMethod.getModifiers()))
							{
								// TODO logging
//								errorNotice = "[error] X3DLoaderDOM: Java reflection invocation problem, class-protected " + fieldName + "." +
//									fieldSetMethodName + "(\"" + attributeValue + "\") method not publicly accessible";
//								validationResult.append(errorNotice).append("\n");
//								System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
								// reason for this is not clear, but apparently it is necessary
								fieldSetMethod.setAccessible(true); // class-protected methods must be made accessible
							}
							// set value on org.web3d.x3d.jsail.fields.* field to reinitialize it
                            try
                            {
                                fieldSetMethod.invoke (field, new Object[] { attributeValue });
							}
                            catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e)
                            {
								// TODO logging
                                String insertionValue;
                                if (attributeValue.length() < 1000)
                                     insertionValue = "\"" + attributeValue + "\"";
                                else insertionValue = "\"" + attributeValue.substring(0,40) + "\" ... [attributeValue length=" + attributeValue.length() + " characters]";
								errorNotice = "[error] X3DLoaderDOM: Java reflection invocation problem for fieldName=" + fieldName + "." +
									fieldSetMethodName + "(" + insertionValue + ") method throws exception";
								if (e.getMessage() != null)
									errorNotice += " " + e.getMessage();
								if (e.getCause() != null)
									errorNotice += " caused by: " + e.getCause().toString();
								errorNotice += ", continuing...";
								validationResult.append(errorNotice).append("\n");
                                // do not report interim regex errors when setting large field values as strings, these later get resolved (or better reported) when typed methods are applied
                                if (!errorNotice.contains(".setValueByString") && !errorNotice.contains("StackOverflowError"))
                                {
                                    System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
                                    if ((e.getMessage() == null) && (e.getCause() == null))
                                         e.printStackTrace();
								}
                            }
							elementSetMethod  = elementClass.getMethod(elementSetMethodName, ((Class<field>[])new Class[] { fieldClass }));
							elementSetMethod.invoke (elementObject, new Object[] { field });
							// element now has correct attribute value set  8)
						}
					}
					catch (ClassNotFoundException cnfe)
					{
						// TODO logging
						errorNotice = "[error] X3DLoaderDOM: Reflection invocation: fully qualified object package not found for fieldName=" + fieldName + "," +
                                                    "\n   " + cnfe + " " + cnfe.getMessage();
						if ((cnfe.getCause()!= null) && !cnfe.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + cnfe.getCause();
						validationResult.append(errorNotice).append("\n");
						System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
						cnfe.printStackTrace();
						return null; // draconian parse
					}
					catch (IllegalAccessException iae)
					{
						// TODO logging
						errorNotice = "[error] X3DLoaderDOM: Reflection invocation visibility of no-parameter constructor inaccessible for fieldName=" + fieldName + "," +
                                                    "\n   " + iae + " " + iae.getMessage();
						if ((iae.getCause()!= null) && !iae.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + iae.getCause();
						validationResult.append(errorNotice).append("\n");
						System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
						iae.printStackTrace();
						return null; // draconian parse
					}
					catch (InstantiationException ie)
					{
						// TODO logging
						errorNotice = "[error] X3DLoaderDOM: Reflection invocation failure occurred inside constructor for fieldName=" + fieldName + "," +
                                                    "\n   " + ie + " " + ie.getMessage();
						if ((ie.getCause()!= null) && !ie.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + ie.getCause();
						validationResult.append(errorNotice).append("\n");
						System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
						ie.printStackTrace();
						return null; // draconian parse
					}
					catch (InvocationTargetException ite)
					{
						// TODO logging
						errorNotice = "[error] X3DLoaderDOM: Reflection invocation of " + nodeName + "." + elementSetMethodName + "(" +
													fieldName + "()." + fieldSetMethodName + "(\"" + attributeValue + "\")) failed (likely due to illegal value)," +
                                                    "\n   " + ite + " " + ite.getMessage();
						if ((ite.getCause() != null))
						{
                                                    errorNotice += "\n   getCause()=" + ite.getCause();
                                                    if (ite.getCause().toString().contains("java.lang.StackOverflowError"))
                                                        continue; // likely problem is regex checking of large attribute value, defer diagnosis and continue loading
						}
                                                if ((ite == null) || (ite.getMessage() == null) || ite.getMessage().contains("java.lang.StackOverflowError"))
                                                    continue; // likely problem is regex checking of large attribute value, defer diagnosis and continue loading
						validationResult.append(errorNotice).append("\n");
						System.out.println(errorNotice + "\n"); // avoiding System.err due to redirection difficulties
						ite.printStackTrace();
						return null; // draconian parse
					}
					catch (NoSuchMethodException nsme)
					{
						// TODO logging
						errorNotice = "[error] X3DLoaderDOM: Reflection invocation incorrectly constructed set method name for fieldName=" + fieldName + "," +
                                                    "\n   " + nsme + " " + nsme.getMessage();
						if ((nsme.getCause()!= null) && !nsme.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + nsme.getCause();
						validationResult.append(errorNotice).append("\n");
						System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
						nsme.printStackTrace();
						return null; // draconian parse
					}
					catch (Exception e)
					{
						// TODO logging
						errorNotice = "[error] X3DLoaderDOM: Reflection invocation incorrectly constructed set method name for fieldName=" + fieldName + "," +
                                                    "\n   " + e + " " + e.getMessage();
						if ((e.getCause()!= null) && !e.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + e.getCause();
						validationResult.append(errorNotice).append("\n");
						System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
						e.printStackTrace();
						return null; // draconian parse
					}
				}	// continue for each attribute until all are set

				break;

			case org.w3c.dom.Node.TEXT_NODE:
				//	trim() removes leading and trailing whitespace
				if (node.getNodeValue().trim().isEmpty())
				{
					// TODO logging
					errorNotice = "[error] X3DLoaderDOM: Unexpected plain text found: " + node.getNodeValue().trim();
					validationResult.append(errorNotice).append("\n");
					System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
				}
				break;

			case org.w3c.dom.Node.CDATA_SECTION_NODE:
				// CDATA content already handled by parent node (e.g. Script ShaderProgram ShaderPart above)
				break;

			case org.w3c.dom.Node.COMMENT_NODE:
				CommentsBlock commentsBlock = new CommentsBlock(node.getNodeValue());
				if (parentElement == null)
				{
                                    if (!node.getNodeValue().contains("produced using X3DJSAIL"))
                                    {
                                	// TODO logging
					errorNotice = "[warning] X3DLoaderDOM: CommentsBlock found without prior parent being saved.";
					errorNotice+= "\n";
					errorNotice+= "        <!-- " + node.getNodeValue() + " -->";
					validationResult.append(errorNotice).append("\n");
					System.out.println(errorNotice); // avoiding System.err due to redirection difficulties
                                    }
				}
				// TODO sort out X3D Unified Object Model (X3DUOM) to support
				else parentElement.addComments(commentsBlock);
				break;

			case org.w3c.dom.Node.PROCESSING_INSTRUCTION_NODE:
				// System.out.println(indent + "<?" + node.getNodeName() + " " + node.getNodeValue() + "?>");
				break;

			case org.w3c.dom.Node.ENTITY_REFERENCE_NODE:
				// System.out.print("&" + node.getNodeName() + ";");
				break;
		}
		// TODO what is this block for??
//		for (org.w3c.dom.Nodechild = node.getFirstChild(); child != null; child = child.getNextSibling())
//		{
//			// recurse on children having elementObject as parent
//			toX3dModelInstance(child, elementObject);
//		}
//		if (elementObject != null) // trace
//		{
//			holdCopyElementObject = elementObject; // remember elementObject, trying to keep from falling out of scope
//			System.out.print ("**************************************************\n" + holdCopyElementObject.toStringX3D()); // debug
//		}
		return elementObject; // complete
	}

	/** TODO javadoc */
	private static class MyErrorHandler implements ErrorHandler {

		private final PrintWriter out;

		MyErrorHandler(PrintWriter out)
		{
			this.out = out;
		}

		private String getParseExceptionInfo(SAXParseException spe)
		{
			String systemId = spe.getSystemId();
			if (systemId == null)
			{
				systemId = "null";
			}
			String info = "URI=" + systemId + " Line=" + spe.getLineNumber() +
						  ": " + spe.getMessage();
			return info;
		}
		/* @Override */
		public void warning(SAXParseException spe) throws SAXException
		{
			String message = "[warning] " + getParseExceptionInfo(spe);
//			validationResult.append(message).append("\n");
			out.println(message);
		}
		/* @Override */
		public void error(SAXParseException spe) throws SAXException
		{
			String message = "Error: " + getParseExceptionInfo(spe);
//			validationResult.append(message).append("\n");
			throw new SAXException(message);
		}
		/* @Override */
		public void fatalError(SAXParseException spe) throws SAXException
		{
			String message = "Fatal Error: " + getParseExceptionInfo(spe);
//			validationResult.append(message).append("\n");
			throw new SAXException(message);
		}
	}
	/**
	 * Accessor method indicating whether DTD validation is performed when loading an X3D file
	 * @return whether XML DTD validation is performed when loading an X3D file
	 */
	public boolean isDtdValidationPerformed()
	{
		return dtdValidate;
	}
	/**
	 * Accessor method to set whether DTD validation is performed when loading an X3D file, reconfiguring documentBuilderFactory
	 * @param newDtdValidationValue whether DTD validation is performed
	 */
	public void setDtdValidationPerformed(boolean newDtdValidationValue)
	{
		dtdValidate = newDtdValidationValue;
		documentBuilderFactory.setValidating(dtdValidate || xsdValidate);
	}
	/**
	 * Accessor method indicating whether DTD validation is performed when loading an X3D file
	 * @return whether XML Schema validation is performed when loading an X3D file
	 */
	public boolean isXmlSchemaValidationPerformed()
	{
		return xsdValidate;
	}
	/**
	 * Accessor method to set whether XML Schema validation is performed when loading an X3D file, reconfiguring documentBuilderFactory
	 * @param newXmlSchemaValidationValue whether XML Schema validation is performed
	 */
	public void setXmlSchemaValidation(boolean newXmlSchemaValidationValue)
	{
		xsdValidate = newXmlSchemaValidationValue;
		documentBuilderFactory.setValidating(dtdValidate || xsdValidate);
	}
	/**
	 * Provide X3DJSAIL object tree if loading succeeds
	 * @return X3D object tree if loading was successful, null otherwise
	 */
	public X3DConcreteElement getX3dObjectTree()
	{
		return loadedX3dModelInstance;
	}

	/**
	 * Accessor method to indicate whether loading was successful and loaded X3dObjectTree is available
	 * @return whether loading was successful
	 */
	public boolean isLoadSuccessful()
	{
		return loadSuccess && (loadedX3dModelInstance != null);
	}

	/**
	 * Provide detailed log of validation results following loading and serialization
	 * @return validationResult log following loading and serialization
	 */
	public String getValidationResult()
	{
		return validationResult.toString();
	}
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>BlenderLauncher</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text></xsl:text>
import java.awt.Desktop;
import java.io.*;
import java.net.*;
import java.io.*;
import java.util.*;
import java.text.DecimalFormat;
import org.web3d.x3d.jsail.Core.*;
import org.web3d.x3d.sai.InvalidFieldValueException;
import org.web3d.x3d.sai.X3DException;</xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isUtilityClass"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Utility class for invoking and launching Blender via local operating system to perform a variety of conversion tasks. Note use of static methods.</xsl:text>
        </xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[ @see <a href="https://Blender.org" target="_blank">Blender</a>
 @see <a href="https://docs.blender.org/api/blender_python_api_current/info_quickstart.html" target="_blank">Blender Quickstart Introduction</a>
 @see <a href="https://docs.blender.org/manual/en/dev/advanced/scripting/introduction.html" target="_blank">Blender API Introduction</a>
 @see <a href="https://docs.blender.org/api/blender_python_api_current" target="_blank">Blender Python API Documentation</a>
 @see <a href="https://docs.blender.org/manual/en/dev/advanced/scripting" target="_blank">Scripting &amp; Extending Blender</a>
 @see <a href="https://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro" target="_blank">Blender 3D: Noob to Pro</a>
 @see <a href="https://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/Advanced_Tutorials/Python_Scripting/Introduction" target="_blank">Blender 3D: Noob to Pro/Advanced Tutorials/Python Scripting/Introduction</a>
 @see <a href="https://www.youtube.com/watch?v=K0yb4sZ7B4g" target="_blank">Video: Blender Tutorial Introduction to Python Scripting: Writing a Script That Makes a Simple 3D Model</a>
 @see <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html">Java Tutorials: Understanding (Static) Class Members</a>
]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text><!-- unused --></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
    /** Default constructor */
    public BlenderLauncher()
    {
        // avoid warning
    }

    /** Blender website URL
     * @see #launchBlenderWebPage()
     */
    public static final String BLENDER_URL = "https://www.blender.org";

	/** Default name of <code>blender</code> executable on local system for command-line blender invocation: <code>blender.exe</code> on Windows, <code>blender</code> otherwise.
	 * @see <a href="https://www.blender.org" target="_blank">Blender</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Blender_(software)" target="_blank">Wikipedia: Blender (software)</a>
	 * @see #checkBlenderPath()
	 * @see #setBlenderPath(String)
    	 */
	private static final String blenderExecutableName_DEFAULT = "blender";

	/** Actual name of <code>blender</code> executable on local system for command-line Blender invocation: <code>blender.exe</code> on Windows, <code>blender</code> otherwise.
	 * @see <a href="https://www.blender.org" target="_blank">Blender</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Blender_(software)" target="_blank">Wikipedia: Blender (software)</a>
	 * @see #checkBlenderPath()
	 * @see #setBlenderPath(String)
	 */
	private static String blenderExecutableName = blenderExecutableName_DEFAULT;

	/** Get directory path for location of <code>blender</code> program:  <code>blender.exe</code> on Windows, <code>blender</code> otherwise.
	 * @return name of blender program
	 * @see #checkBlenderPath()
	 * @see #setBlenderPath(String)
	 */
	public static final String getBlenderExecutableName()
	{
            final String OPERATING_SYSTEM_NAME = System.getProperty("os.name");

            if (OPERATING_SYSTEM_NAME.toLowerCase(Locale.ENGLISH).contains("windows"))
            {
                if (blenderExecutableName.equals(blenderExecutableName_DEFAULT))
                {
                    blenderExecutableName += ".exe";
                }
            }
            return blenderExecutableName;
	}

	/** Blender path on local system for command-line Blender invocation.
	 * @see <a href="https://www.blender.org" target="_blank">Blender</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Blender_(software)" target="_blank">Wikipedia: Blender (software)</a>
	 * @see <a href="https://docs.blender.org/manual/en/latest/advanced/command_line/index.html">Blender Manual: Command Line</a>
	 * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
	 * @see <a href="https://docs.blender.org/manual/en/latest/advanced/scripting/index.html">Blender Manual: Scripting &amp; Extending Blender</a>
	 */
	private static String blenderPath = "";

	/** Default Blender path default for Windows 7 or 10 operating system, possibly unneeded if <code>blender</code> is in path already.
	 * Can also set <code>BLENDER_PATH</code> environment variable in operating system.
         * <i>Warning:</i> local settings vary, configure path if necessary.
	 * @see #checkBlenderPath()
	 * @see #setBlenderPath(String)
	 * @see <a href="../../../../../X3DJSAIL.html#properties" target="_blank">X3DJSAIL documentation: properties</a>
	 * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/index.html">Blender Command Line</a>
	 */
	public static final String BLENDER_PATH_DEFAULT_WINDOWS = "C:\\Program Files\\Blender Foundation\\Blender 4.3"; // escape \

	/** Default Blender path default for macOS operating system, possibly unneeded if <code>blender</code> is in path already.
	 * <i>Warning:</i> local settings vary, configure path if necessary.
	 * @see #checkBlenderPath()
	 * @see #setBlenderPath(String)
	 * @see <a href="../../../../../X3DJSAIL.html#properties" target="_blank">X3DJSAIL documentation: properties</a>
	 * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/index.html">Blender Command Line</a>
	 */
	public static final String BLENDER_PATH_DEFAULT_MACOS = "/Applications/blender.app/Contents/MacOS/blender";
    // thanks Mike Bailey, Terry Norbraten and Han Chen

	/** Default Blender path default for Linux operating system, possibly unneeded if <code>blender</code> is in path already.
	 * <i>Warning:</i> local settings vary, configure path if necessary.
	 * @see #checkBlenderPath()
	 * @see #setBlenderPath(String)
	 * @see <a href="../../../../../X3DJSAIL.html#properties" target="_blank">X3DJSAIL documentation: properties</a>
	 * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/index.html">Blender Command Line</a>
	 */
	public static final String BLENDER_PATH_DEFAULT_LINUX = "/usr/bin/blender"; // used on modelexchange.nps.edu

	/** Get preference for XSLT transformation engine to use: {@link ConfigurationProperties#XSLT_ENGINE_SAXON} or {@link ConfigurationProperties#XSLT_ENGINE_NATIVE_JAVA}.
	 * @return String constant regarding current configuration: XSLT_ENGINE_SAXON (default) or XSLT_ENGINE_NATIVE_JAVA
	 */
	public static final String getBlenderPath()
	{
		return blenderPath;
	}
	/** Set preference for XSLT transformation engine to use: {@link ConfigurationProperties#XSLT_ENGINE_SAXON} or {@link ConfigurationProperties#XSLT_ENGINE_NATIVE_JAVA}.
	 * @param newValue is new value to assign */
	public static final void setBlenderPath(String newValue)
	{
            if ((newValue == null) || newValue.isEmpty())
            {
                String errorNotice = "*** Invalid setBlenderPath(String newValue) invocation, newValue='" + newValue +
                                     "', " + getBlenderExecutableName() + " not found at this location";
//		validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice);
            }
            blenderPath = newValue;

            // verify Blender found, throw exception otherwise

            if  (blenderPath.endsWith(getBlenderExecutableName())) // strip executable if needed, save path only
            {
                 blenderPath = blenderPath.substring(0,blenderPath.lastIndexOf(getBlenderExecutableName()));
            }
            if (!blenderPath.endsWith("\\") && !blenderPath.endsWith(File.separator))
            {
                 blenderPath += File.separator;
            }
            // verify meshlabserver found, throw exception otherwise
            File blenderServerFile = new File(blenderPath, getBlenderExecutableName());

            if (!blenderServerFile.exists())
            {
                String errorNotice = "*** Invalid setBlenderPath(String newValue) invocation, newValue='" + newValue +
                                     "', " + blenderPath + getBlenderExecutableName() + " not found at this location";
//		validationResult.append(errorNotice).append("\n");
                throw new InvalidFieldValueException(errorNotice);
            }
	}

	/**
	 * Blender python script for converting X3D model into PNG image.
	 */
	public static final String BLENDER_PYTHON_SCRIPT_X3D_TO_PNG = "BlenderX3dToPng.py";

	/**
	 * Blender python script for converting STL model into X3D model.
	 */
	public static final String BLENDER_PYTHON_SCRIPT_STL_TO_X3D = "BlenderStlToX3d.py";

    //  TODO command-line invocation [-BLENDER_PATH | -convert | -import | -toImage]

    private static File BlenderX3dToPngPythonFile;

    /** Initialize this BlenderLauncher instance to default values. */
    public static final void initialize()
    {
        checkBlenderPath();
        initializeConfigurationSwitches();
    }
    /**
     *                               Usage: <code>java [-classpath X3DJSAIL.*.jar] org.web3d.x3d.jsail.BlenderLauncher sourceFile [-convert [resultFile]] [-toImage [snapshotName.*]] [-home | -help | -version | -properties fileName.properties | -BLENDER_PATH directoryPath]</code>
     */
    public  static final String USAGE   = "Usage: java [-classpath X3DJSAIL.*.jar] org.web3d.x3d.jsail.BlenderLauncher sourceFile [-convert [resultFile]] [-toImage [snapshotName.*]] [-home | -help | -version | -properties fileName.properties | -BLENDER_PATH directoryPath]";
    private static final String WARNING = "[Warning] ";
    private static final String ERROR   = "[Error] ";

    private static boolean modelConvert     = false;
    private static boolean modelExport      = false; // not used via main invocation
    private static boolean modelImport      = false; // not used via main invocation

    private static String  conversionExtension = new String();

    /** Reset configuration switch values */
    private static void initializeConfigurationSwitches()
    {
            modelConvert         = true;  // default choice, switch is optional
            modelExport          = false;
            modelImport          = false;

            conversionExtension  = new String();
    }

    /**
     * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
     */
    private static BufferedWriter bufferedWriter;

    /** Default main() method provided for test and debugging purposes, invoking run() method.
     * @param args the command line arguments
     * @see #run(String[])
     * @see X3D#handleArguments(String[])
     */
    public static void main(String[] args)
    {
        run(args);
    }

    /** Utility run() method provided for test and debugging purposes, allowing invocation with a single String (rather than a String[] array).
     * When invoked without parameters then reports results of validate() self-checks to system output.
     * @param singleStringArguments the command line arguments
     * @see #run(String[])
     */
    public static void run(String singleStringArguments)
    {
        run(singleStringArguments.split("(\\s)")); // split single string into string array
    }

    /** Default run() method provided for test and debugging purposes, first initializing ConfigurationProperties then reading properties file (if any) and processing arguments.
     * When invoked without parameters then reports results of validate() self-checks to system output.
     * @param args the command line arguments
     * @see #main(String[])
     * @see ConfigurationProperties
     * @see X3D#handleArguments(String[])
     */
    public static void run(String[] args)
    {
        File    sourceFile;
        long    sourceFileLength     = 0;
        String  sourceFileName       = "";
        String  sourceFileNameRoot   = "";
		File    resultFile;
        boolean convertToFile        = false;
        boolean createImageSnapshot  = false;
        boolean loadProperties       = false;
        boolean resetPath            = false;
        String  resultFileName       = "";
        String  resultFileNameRoot   = "";
        String propertiesFileName    = "";
        String propertiesFileNameRoot= "";
        String  compressionRatio;
        DecimalFormat formatPrecision2 = new DecimalFormat ("#0.00");

        initializeConfigurationSwitches();

        if ((args== null) || (args.length < 1))
        {
            System.out.println (USAGE);
            return;
        }
        else
        {
            for (int i=0; i<=args.length-1; i++)
            {
                args[i] = args[i].trim(); // eliminate excess whitespace, if called programmatically
                if  (!args[i].startsWith("-"))
                {
                    if (modelConvert && !sourceFileName.isEmpty() && !resultFileName.isEmpty())
                    {
                        System.out.println(ERROR+" [org.web3d.x3d.jsail.BlenderLauncher] too many file names found, source=\"" + sourceFileName + "\" and result \"" + resultFileName + "\" prior to argument \"" + args[i] + "\". Check usage:");
                        System.out.println(USAGE);
                        return;
                    }
//					else if ((modelExport || modelImport) && !sourceFileName.isEmpty())
//					{
//						System.out.println(ERROR+" [org.web3d.x3d.jsail.BlenderLauncher] too many source file names found, source=\"" + sourceFileName + "\" prior to argument \"" + args[i] + "\". Check usage:");
//						System.out.println(USAGE);
//						return;
//					}
                    else if (modelConvert && !sourceFileName.isEmpty()) // now have encountered resultFile value, overwrite default
                    {
                        resultFileName     = args[i];
                        resultFileNameRoot = resultFileName;
                        if (resultFileNameRoot.contains("."))
                                resultFileNameRoot = resultFileName.substring(0,resultFileNameRoot.lastIndexOf("."));
                        resultFile = new File(resultFileName);
                        conversionExtension = resultFileName.substring(resultFileName.lastIndexOf("."));
                        if (conversionExtension.isEmpty())
                        {
                                System.out.println(ERROR+" [org.web3d.x3d.jsail.BlenderLauncher] result file extension is needed for conversion but not found: " + resultFileName);
                                System.out.println(USAGE);
                                return;
                        }
                    }
                    else
                    {
                        sourceFileName     = args[i];
                        sourceFileNameRoot = sourceFileName;
                        if (sourceFileNameRoot.contains("."))
                            sourceFileNameRoot = sourceFileName.substring(0,sourceFileName.lastIndexOf("."));
                        sourceFile = new File(sourceFileName);

                        if (!sourceFile.exists())
                        {
                            System.out.println(ERROR+" [org.web3d.x3d.jsail.BlenderLauncher] file not found: " + sourceFileName);
                            return;
                        }
                        else
                        {
                            sourceFileLength = sourceFile.length();
                            System.out.println ("BlenderLauncher parameter: source file " + sourceFile.getName() + " filesize " + sourceFileLength + " bytes");
                        }
                    }
                }
                else if (args[i].equalsIgnoreCase("-properties") || args[i].equalsIgnoreCase("-propertiesFile")) // optionally followed by propertiesFileName
                {
                    if ((args.length > i + 1) && !(args[i+1] == null) && !args[i+1].isEmpty() && !args[i+1].startsWith("-"))
                    {
                             propertiesFileName     = args[i+1];
                             propertiesFileNameRoot = propertiesFileName.substring(0,propertiesFileName.lastIndexOf("."));
                             System.out.println ("BlenderLauncher parameter: \"" + args[i] + "\" \"" + args[i+1] + "\" for properties file name root " + propertiesFileNameRoot);
                             i++; // increment index, carefully!
                    }
                    else System.out.println ("BlenderLauncher parameter: \"" + args[i] + "\" for properties file name root "+ propertiesFileNameRoot);
                    loadProperties = true; // set flag
                }
                else if (args[i].equalsIgnoreCase("-BLENDER_PATH") || args[i].equalsIgnoreCase("-BLENDERPATH"))
                {
                    if ((args.length > i + 1) && !(args[i+1] == null) && !args[i+1].isEmpty() && !args[i+1].startsWith("-"))
                    {
                        String newPath = args[i + 1];
                        System.out.println ("parameters: \"" + args[i] + "\" \"" + newPath + "\" for setting Blender path");
                        setBlenderPath(newPath);
                        checkBlenderPath();
                        i++; // increment index, carefully!
                    }
                    else System.out.println ("Error: parameter: \"" + args[i] + "\" missing new Blender path value");
                    resetPath = true; // set flag
                }
                else if (args[i].equalsIgnoreCase("-toImage") || args[i].equalsIgnoreCase("-screenshot"))
                {
                    initializeConfigurationSwitches();
                    createImageSnapshot = true;
                    System.out.println ("BlenderLauncher parameter: \"" + args[i] + "\" for creating screenshot image of default viewpoint");
                }
                else if (args[i].equalsIgnoreCase("-convert"))
                {
                    initializeConfigurationSwitches();
                    modelConvert = true;
                    System.out.println ("BlenderLauncher parameter: \"" + args[i] + "\" for conversion between formats");
                }
//				else if (args[i].equalsIgnoreCase("-export"))
//				{
//                    initializeConfigurationSwitches();
//					modelExport = true;
//					System.out.println ("BlenderLauncher parameter: \"" + args[i] + "\" for model export");
//				}
//				else if (args[i].equalsIgnoreCase("-import"))
//				{
//                    initializeConfigurationSwitches();
//					modelImport = true;
//                    conversionExtension = X3D.FILE_EXTENSION_X3D; // default
//					System.out.println ("BlenderLauncher parameter: \"" + args[i] + "\" for model export");
//				}
                // ==========================================
                else  if (args[i].equalsIgnoreCase("-home") || args[i].equalsIgnoreCase("-page") || args[i].equalsIgnoreCase("-homepage") || args[i].equalsIgnoreCase("-website"))
                {
                        launchBlenderWebPage();
                        return;
                }
                // ==========================================
                else  if (args[i].equalsIgnoreCase("-version"))
                {
                        System.out.println("Blender version: " + getBlenderVersion());
                        return;
                }
                // ==========================================
                else  if (args[i].toLowerCase().contains("-help"))
                {
                        System.out.println(USAGE);
                        System.out.println(BLENDER_URL);
                        System.out.println("Blender help:");
                        System.out.println(getBlenderHelp());
//					launchBlenderWebPage();
                        return;
                }
                // ==========================================
                else // not found
                {
                        System.out.println(ERROR+" [org.web3d.x3d.jsail.BlenderLauncher] unrecognized BlenderLauncher option \"" + args[i] + "\"");
                        System.out.println(USAGE);
                        return;
                }
            }
    }
    // ===================================================================================
    if (loadProperties)
    {
            if (!propertiesFileName.isEmpty())
                    ConfigurationProperties.setPropertiesFileName (propertiesFileName);
            ConfigurationProperties.loadProperties();
    }

    // compute/confirm resultFileName after all command-line switches are read
    if (!sourceFileName.isEmpty() && resultFileName.isEmpty())
    {
        if  (createImageSnapshot)
             conversionExtension = X3D.FILE_EXTENSION_PNG;
        else conversionExtension = X3D.FILE_EXTENSION_X3D;

        resultFileName      = sourceFileNameRoot + conversionExtension;
        resultFileNameRoot  = sourceFileNameRoot;
        resultFile = new File(resultFileName);
    }
    // TODO confirm additional image, model formats
    if ((modelImport         && !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_X3D)) ||
        (createImageSnapshot && !conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_PNG)))
    {
        System.out.println(WARNING+" [org.web3d.x3d.jsail.BlenderLauncher] resultFile " + resultFileName + " has mismatched file extension \"" + conversionExtension + "\" for conversion");
    }

        // ===================================================================================
        if (!sourceFileName.isEmpty()) // fully prepared, now get source file and proceed
        {
            if (createImageSnapshot)
            {
                checkBlenderPath();

                // create temp file for BlenderX3dToPng.py so that it is invocable
                if (BlenderX3dToPngPythonFile == null)
                    BlenderX3dToPngPythonFile = X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.getTempFileFromX3dJsailJar("python/blenderScripts", "BlenderX3dToPng.py");

                // blender --background --factory-startup --python -- ${example.model.x3d} ${products.subdir}
                StringBuilder toImageCommand = new StringBuilder();
                toImageCommand
                    .append(getBlenderPath())
                    .append(getBlenderExecutableName())
                    .append(" ").append("--background")
                    .append(" ").append("--factory-startup")
                    .append(" ").append("--python")      // script name follows
                    .append(" ").append(BlenderX3dToPngPythonFile.getAbsolutePath()) // conversion script, obfuscated/unique temporary file name
                    .append(" ").append("--")            // delimiter, arguments to python script follow
                    .append(" ").append(sourceFileName)  // input X3D model
//                  .append(" ").append(resultFileName)  // optional output path
                    ;
            	System.out.println("executeCommand(\"" + toImageCommand.toString() + "\")");
                String result     = executeCommand(      toImageCommand.toString());
            	System.out.println("executeCommand() response:");
                System.out.println(result);
            	System.out.println("expected result: " + resultFileName);
            }
            else if (modelConvert)
            {
                    executeCommandSuccessful = convertModel (sourceFileName, resultFileName);
                    System.out.println("load success: " + executeCommandSuccessful);
                    return;
            }
        }
        else if (!loadProperties && !resetPath) // allows testing of properties without file operations
        {
            String message = ERROR+"Source model file name is empty, therefore file loading not possible.";
            System.out.println(message);
            throw new org.web3d.x3d.sai.InvalidExecutionContextException(message);
        }
    }

    /** Open Blender page
     * @see <a href="https://www.blender.org" target="_blank">Blender</a>
     * @see <a href="https://en.wikipedia.org/wiki/Blender_(software)" target="_blank">Wikipedia: Blender (software)</a>
     * @see BLENDER_URL
     */
    public static void launchBlenderWebPage()
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java
        try {
            if (Desktop.isDesktopSupported())
            {
                Desktop.getDesktop().browse(new URI(BLENDER_URL));
            }
        }
        catch (IOException | URISyntaxException e2)
        {
            System.out.println ("launchBlenderWebPage failure: " + e2.getMessage());
        }
    }

    /**
     * Check Blender local path and reset to operating system default, if necessary.
	 * @see #setBlenderPath(String)
     * @see <a href="https://blender.org" target="_blank">Blender</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/data_system/files/import_export.html" target="_blank">Blender Manual: Importing and Exporting Files</a>
     */
    public static void checkBlenderPath()
    {
        final String BLENDER_PATH_ENVIRONMENT_VARIABLE = System.getProperty("BLENDER_PATH");

        final String OPERATING_SYSTEM_NAME = System.getProperty("os.name");

        if ((getBlenderPath() == null) || (getBlenderPath().isEmpty()))
        {
            /* debug diagnostic
            System.out.println("OPERATING_SYSTEM_NAME=" + OPERATING_SYSTEM_NAME); */

            if ((BLENDER_PATH_ENVIRONMENT_VARIABLE != null) && !BLENDER_PATH_ENVIRONMENT_VARIABLE.isEmpty())
            {
                setBlenderPath(BLENDER_PATH_ENVIRONMENT_VARIABLE);
            }
            // https://stackoverflow.com/questions/228477/how-do-i-programmatically-determine-operating-system-in-java
            else if (OPERATING_SYSTEM_NAME.toLowerCase(Locale.ENGLISH).contains("windows"))
            {
                setBlenderPath(BLENDER_PATH_DEFAULT_WINDOWS);
            }
            else if (OPERATING_SYSTEM_NAME.toLowerCase(Locale.ENGLISH).contains("mac"))
            {
                setBlenderPath(BLENDER_PATH_DEFAULT_MACOS);
            }
            else if (OPERATING_SYSTEM_NAME.toLowerCase(Locale.ENGLISH).contains("linux"))
            {
                setBlenderPath(BLENDER_PATH_DEFAULT_LINUX);
            }
        }
        // ensure trailing \ or / is present in path
        String checkedBlenderPath =  getBlenderPath();
        if (!checkedBlenderPath.isEmpty() && !checkedBlenderPath.endsWith("\\") && !checkedBlenderPath.endsWith("/"))
        {
            checkedBlenderPath = checkedBlenderPath + File.separator;
            setBlenderPath(checkedBlenderPath);
        }
        /* debug diagnostic
        System.out.println("checkBlenderPath() result: getBlenderPath()=" + getBlenderPath()); */
    }
    /**
     * Keep track of whether prior command execution was successful.
     */
    private static boolean executeCommandSuccessful = false;
    /**
     * Report  whether prior command execution was successful.
     * @return whether prior command execution was successful.
     * @see <a href="https://stackoverflow.com/questions/3630281/is-it-possible-to-capture-a-windows-pop-up-message-box-from-inside-a-java-program">StackOverflow: possible to capture pop-up message box?</a>
     */
    public static boolean wasPriorCommandSuccessful()
    {
        return executeCommandSuccessful;
    }
    /**
     * Launch blender in operating system and run command.
     * @param command Blender invocation
     * @return console results
     * @see <a href="https://blender.org" target="_blank">Blender</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/data_system/files/import_export.html" target="_blank">Blender Manual: Importing and Exporting Files</a>
     * @see <a href="https://stackoverflow.com/questions/31776546/why-does-runtime-execstring-work-for-some-but-not-all-commands/" target="_blank">Why does Runtime.exec(String) work for some but not all commands?</a>
     * @see <a href="https://stackoverflow.com/questions/13008526/runtime-getruntime-execcmd-hanging" target="_blank">StackOverflow: Runtime.getRuntime().exec(cmd) hanging</a>
     * @see <a href="https://stackoverflow.com/questions/3468987/executing-another-application-from-java" target="_blank">StackOverflow: Executing another application from Java</a>
     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html" target="_blank">java.lang.Runtime</a>
     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html" target="_blank">java.lang.ProcessBuilder</a>
     */
    protected static String executeCommand (String command)
    {
        StringBuilder outputBuilder = new StringBuilder();
        Process process;
        ProcessBuilder processBuilder;

        try
        {
//          File directory = new File(getBlenderPath()); // debug
//          * @see <a href="https://stackoverflow.com/questions/7347856/how-to-convert-a-string-into-an-arraylist" target="_blank">StackOverflow: How to convert a String into an ArrayList?</a>

            ArrayList<String> commandArgs = new ArrayList<>(Arrays.asList(command.split("\\s")));
            processBuilder = new ProcessBuilder(commandArgs);
            process = processBuilder.start();
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));

            String  line;
            while ((line = reader.readLine())!= null)
            {
                outputBuilder.append(line).append("\n");
            }
        }
        catch (IOException e)
        {
            outputBuilder.append(e.getMessage()).append("\n").append(e.getCause()).append("\n");
            e.printStackTrace();
            throw new org.web3d.x3d.sai.InvalidExecutionContextException(command);
        }
        return outputBuilder.toString();
    }
    /**
     * TODO: Use Blender to convert model from one file to another.
     * @param  inputFileName for  input file
     * @param outputFileName for output file
     * @return whether successful
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static boolean convertModel (String inputFileName, String outputFileName)
    {
        return convertModel ("", inputFileName, outputFileName);
    }
    /**
     * TODO: Use Blender to convert model from one file to another based on filename extensions.
     * @param path directory path to file of interest
     * @param  inputFileName for  input file
     * @param outputFileName for output file
     * @return whether successful
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static boolean convertModel (String path, String inputFileName, String outputFileName)
    {
         return false; // TODO
    }
    /**
     * TODO: Use blender to import model to X3D
     * @param path directory path to file of interest
     * @param fileName for input file
     * @return result, null if unsuccessful
     * @see <a href="https://blender.org" target="_blank">Blender</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/data_system/files/import_export.html" target="_blank">Blender Manual: Importing and Exporting Files</a>
     */
    public static X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ importModel (String path, String fileName)
    {
            // use
            // determine and metadata
            return null;
    }
    /**
     * TODO finish: Use blender to import STL geometry as X3D model
     * @param path directory path to file of interest
     * @param fileName for input file
     * @return result, null if unsuccessful
     * @see <a href="https://blender.org" target="_blank">Blender</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/data_system/files/import_export.html" target="_blank">Blender Manual: Importing and Exporting Files</a>
     */
    public static X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ importSTL (String path, String fileName)
    {
        // https://blender.stackexchange.com/questions/1365/how-can-i-run-blender-from-command-line-or-a-python-script-without-opening-a-gui

        // https://blender.stackexchange.com/questions/16563/how-can-i-run-blender-from-the-command-line-to-export-and-import-models

        // .class or getClass().getResourceAsStream looks within each classpath .jar for stylesheetPath
        InputStream pythonScriptInputStream = BlenderLauncher.class.getResourceAsStream("/" + BLENDER_PYTHON_SCRIPT_STL_TO_X3D);
        if (pythonScriptInputStream == null)
        {
            String errorNotice = "*** File not found: " + BLENDER_PYTHON_SCRIPT_STL_TO_X3D;
        }
        // test file extension, determine if binary stl, add any metadata
        return null;
    }

    /**
     * TODO: Use blender to export geometry to STL
     * @param modelToExport X3D model of interest
     * @return plain-text STL file
     * @see <a href="https://en.wikipedia.org/wiki/STL_(file_format)" target="_blank">STL (file format)</a>
     * @see <a href="https://blender.org" target="_blank">Blender</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/data_system/files/import_export.html" target="_blank">Blender Manual: Importing and Exporting Files</a>
     */
    public static String exportSTL (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ modelToExport)
    {
            // determine and metadata
            return "";
    }

    /**
     * TODO: Use blender to export geometry to file
     * @param modelToExport X3D model of interest
     * @param path directory path to file of interest
     * @param fileName for output file
     * @return whether successful
     * @see <a href="https://en.wikipedia.org/wiki/STL_(file_format)" target="_blank">STL (file format)</a>
     * @see <a href="https://blender.org" target="_blank">Blender</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/data_system/files/import_export.html" target="_blank">Blender Manual: Importing and Exporting Files</a>
     */
    public static boolean exportSTLtoFile (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ modelToExport, String path, String fileName)
    {
            String result = exportSTL (modelToExport);
            try
            {
                    // TODO save to file
            }
            catch (Exception e)
            {
                    // Diagnostic
                    return false;
            }
            return true;
    }
    /**
     * TODO: Get Blender metrics for X3D model of interest.
     * @param modelOfInterest X3D model to analyze
     * @return Blender output
     * @see <a href="https://blender.org" target="_blank">Blender</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     */
    public static String getBlenderAnalytics (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ modelOfInterest)
    {
            // add optional method to create X3DMetadataSet
            return "";
    }
    /**
     * TODO: Get Blender metrics as MetadataSet object.
     * @param modelOfInterest X3D model to analyze
     * @return Blender output
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     */
    public static MetadataSet getBlenderAnalyticsX3dMetadataSet (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ modelOfInterest)
    {
            return null;
    }
    /**
     * Get Blender version.
     * <i>Warning:</i> ensure BLENDER_HOME or local path is set correctly, especially if more than one version is installed.
     * @return Blender version.
     * @see <a href="https://www.blender.org" target="_blank">www.blender.org</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     */
    public static String getBlenderVersion()
    {
	checkBlenderPath();
        StringBuilder blenderCommand = new StringBuilder();
        blenderCommand.append(getBlenderPath())
                      .append(getBlenderExecutableName())
                      .append(" --version");
        String result = executeCommand(blenderCommand.toString());
        return result.substring(0,result.indexOf("\n")).trim();
    }
    /**
     * Get Blender help.
     * <i>Warning:</i> ensure BLENDER_HOME or local path is set correctly, especially if more than one version is installed.
     * @return Blender version.
     * @see <a href="https://www.blender.org" target="_blank">www.blender.org</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     */
    public static String getBlenderHelp()
    {
	checkBlenderPath();
        StringBuilder blenderCommand = new StringBuilder();
        blenderCommand.append(getBlenderPath())
                      .append(getBlenderExecutableName())
                      .append(" --help"); // necessary
        String result = executeCommand(blenderCommand.toString());
        return result.replaceAll("\r\n", "\n").replaceAll("\n\n", "\n").trim(); // avoid double newlines in output
    }
    /**
     * Determine if Blender is locally available.
     * <i>Warning:</i> ensure BLENDER_HOME or local path is set correctly, especially if more than one version is installed.
     * @return whether Blender is found.
     * @see <a href="https://www.blender.org" target="_blank">www.blender.org</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/render/workflows/command_line.html" target="_blank">Blender Manual: Command Line</a>
     * @see <a href="https://docs.blender.org/manual/en/dev/advanced/command_line/arguments.html" target="_blank">Blender Manual: Command Line Arguments</a>
     */
    public static boolean hasBlender()
    {
        return (getBlenderVersion().startsWith("Blender"));
    }
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>MeshLabLauncher</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text></xsl:text>
import java.awt.Desktop;
import java.io.*;
import java.net.*;
import java.nio.file.*;
import java.text.DecimalFormat;
import java.util.*;
import org.web3d.x3d.jsail.Core.X3D;
import org.web3d.x3d.jsail.Core.MetadataSet;
import org.web3d.x3d.sai.InvalidDocumentException;
import org.web3d.x3d.sai.InvalidFieldValueException;</xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isUtilityClass"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Utility class for invoking and launching MeshLab via local operating system to perform a variety of conversion tasks. Note use of static methods.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
 @see <a href="https://en.wikipedia.org/wiki/STL_(file_format)" target="_blank">STL (file format)</a>
 @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
 @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
 @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
 @see <a href="https://sourceforge.net/p/meshlab/discussion/499533/thread/c266b0c3" target="_blank">SourceForge: meshlab in command-line?</a>
 @see <a href="https://sourceforge.net/p/meshlab/discussion/499533/thread/86cf0d34" target="_blank">SourceForge: Automating Meshlab conversion </a>
 @see <a href="https://github.com/cnr-isti-vclab/meshlab/blob/master/src/meshlabserver/meshlabserver.txt" target="_blank">GitHub: meshlabserver.txt command-line help</a>
 @see <a href="https://github.com/TheNerdJedi/MeshlabAuto" target="_blank">GitHub: TheNerdJedi/MeshlabAuto</a>
 @see <a href="https://www.youtube.com/playlist?list=PL8B1E816EAE236B4D" target="_blank">Mr. P. MeshLab Tutorials: MeshLab Basics</a>
 @see <a href="https://www.youtube.com/playlist?list=PL53FAE3EB5734126E" target="_blank">Mr. P. MeshLab Tutorials: 3D Scanning pipeline</a>
 @see <a href="https://www.youtube.com/playlist?list=PL60mCsep96JcJz_SIfXblsVmI1TYMsQJc" target="_blank">Mr. P. MeshLab Tutorials: Features</a>
 @see <a href="https://www.youtube.com/playlist?list=PLBBF41579E4B65566" target="_blank">Mr. P. MeshLab Tutorials: Cleaning</a>
 @see <a href="https://stackoverflow.com/questions/tagged/meshlab" target="_blank">StackOverflow: MeshLab</a>
 @see <a href="https://github.com/TheNerdJedi/MeshlabAuto" target="_blank">GitHub: MeshlabAuto</a>
 @see <a href="https://github.com/cnr-isti-vclab/meshlab/issues" target="_blank">GitHub: issues</a>
 @see <a href="https://www.meshlab.net/#references" target="_blank">MeshLab References</a>
 @see <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html">Java Tutorials: Understanding (Static) Class Members</a>
]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text><!-- unused --></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
    /** MeshLab website URL
     * @see #launchMeshLabWebPage()
     */
    public static final String MESHLAB_URL = "https://www.MeshLab.net";

    /** meshlabserver warning
     * @see #launchMeshLabWebPage()
     */
    public static final String MESHLABSERVER_ERROR_NOTICE =
            "\nFor MeshLab releases starting in 2021, meshlabserver is discontinued. See https://stackoverflow.com/questions/65825861/where-is-meshlabserver-exe-in-2020-12"
          + "\nCapabilities are in PyMeshLab which requires Python language support. See https://github.com/cnr-isti-vclab/PyMeshLab";

    /** Default name of <code>meshlabserver</code> executable on local system for command-line MeshLab invocation: <code>meshlabserver.exe</code> on Windows, <code>meshlabserver</code> otherwise.
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     * @see <a href="https://stackoverflow.com/questions/65825861/where-is-meshlabserver-exe-in-2020-12"><https://stackoverflow.com/questions/65825861/where-is-meshlabserver-exe-in-2020-12</a>
	 * @see #checkMeshLabPath()
	 * @see #setMeshLabPath(String)
     */
	private static final String meshLabServerExecutableName_DEFAULT = "meshlabserver";

	/** Actual name of <code>meshlabserver</code> executable on local system for command-line MeshLab invocation: <code>meshlabserver.exe</code> on Windows, <code>meshlabserver</code> otherwise.
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
	 * @see #checkMeshLabPath()
	 * @see #setMeshLabPath(String)
	 */
	private static String meshLabServerExecutableName = meshLabServerExecutableName_DEFAULT;

	/** Get directory path for location of <code>meshlabserver</code> program:  <code>meshlabserver.exe</code> on Windows, <code>meshlabserver</code> otherwise.
	 * @return name of meshlabserver program
	 * @see #checkMeshLabPath()
	 * @see #setMeshLabPath(String)
	 */
	public static final String getMeshLabServerExecutableName()
	{
            final String OPERATING_SYSTEM_NAME = System.getProperty("os.name");

            // https://stackoverflow.com/questions/228477/how-do-i-programmatically-determine-operating-system-in-java
            if (OPERATING_SYSTEM_NAME.toLowerCase(Locale.ENGLISH).contains("windows"))
            {
                if (meshLabServerExecutableName.equals(meshLabServerExecutableName_DEFAULT))
                {
                    meshLabServerExecutableName += ".exe";
                }
            }
            return meshLabServerExecutableName;
	}
	/** Set meshLabServerExecutableName for alternate name of <code>meshlabserver</code> program.
	 * @param newValue is new value to assign
    `    */
	public static final void setMeshLabServerExecutableName(String newValue)
	{
            meshLabServerExecutableName = newValue;
        }

	/** MeshLab path on local system for command-line MeshLab invocation.
         * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
         * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
         * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
	 */
	private static String meshLabPath = "";

	/** Default MeshLab path default for Windows operating system.
         * Can also set <code>MESHLAB_PATH</code> environment variable in operating system.
         * <i>Warning:</i> local settings vary, configure path if necessary.
	 * @see #checkMeshLabPath()
	 * @see #setMeshLabPath(String)
	 * @see <a href="../../../../../X3DJSAIL.html#properties" target="_blank">X3DJSAIL documentation: properties</a>
         * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
         * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
         * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
	 */
	public static final String MESHLAB_PATH_DEFAULT_WINDOWS = "C:\\Program Files\\VCG\\MeshLab"; // escape \

	/** Default MeshLab path default for macOS operating system, possibly unneeded if <code>meshlabserver</code> is in path already.
	 * <i>Warning:</i> local settings vary, configure path if necessary.
	 * @see #checkMeshLabPath()
	 * @see #setMeshLabPath(String)
	 * @see <a href="../../../../../X3DJSAIL.html#properties" target="_blank">X3DJSAIL documentation: properties</a>
         * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
         * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
         * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
	 */
	public static final String MESHLAB_PATH_DEFAULT_MACOS = "/Applications/meshlab.app/Contents/MacOS/meshlabserver"; // TODO confirm/correct

	/** Default MeshLab path default for Linux operating system, possibly unneeded if <code>meshlabserver</code> is in path already.
	 * <i>Warning:</i> local settings vary, configure path if necessary.
	 * @see #checkMeshLabPath()
	 * @see #setMeshLabPath(String)
	 * @see <a href="../../../../../X3DJSAIL.html#properties" target="_blank">X3DJSAIL documentation: properties</a>
         * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
         * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
         * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
	 */
	public static final String MESHLAB_PATH_DEFAULT_LINUX = "/usr/bin/meshlab"; // TODO confirm/correct

	/** Get directory path for location of <code>meshlabserver</code> program.
	 * @return directory path for location of meshlabserver program
	 */
	public static final String getMeshLabPath()
	{
		return meshLabPath;
	}
	/** Set directory path for location of <code>meshlabserver</code> program.
	 * @param newValue is new value to assign
         */
	public static final void setMeshLabPath(String newValue)
	{
            meshLabPath = newValue;

            if  (meshLabPath.endsWith(getMeshLabServerExecutableName())) // strip executable if needed, save path only
            {
                 meshLabPath = meshLabPath.substring(0,meshLabPath.lastIndexOf(getMeshLabServerExecutableName()));
            }
            if (!meshLabPath.endsWith("\\") && !meshLabPath.endsWith(File.separator))
            {
                 meshLabPath += File.separator;
            }
            // verify meshlabserver found, throw exception otherwise
            File meshLabServerFile = new File(meshLabPath, getMeshLabServerExecutableName());
            if (!meshLabServerFile.exists())
            {
                String errorNotice = "*** Invalid setMeshLabPath(String newValue) invocation, newValue='" + newValue +
                                     "', " + getMeshLabServerExecutableName() + " program not found at this location";
                errorNotice += MESHLABSERVER_ERROR_NOTICE;
                System.out.println(errorNotice);
//              throw new InvalidFieldValueException(errorNotice);
          }
	}

    /**
     * Check MeshLab local path and also executable name, reset to operating system defaults if necessary.
     * Executable name: <code>meshlabserver.exe</code> on Windows, <code>meshlabserver</code> otherwise.
     * @see #checkMeshLabPath()
     * @see #setMeshLabPath(String)
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     * @see #getMeshLabServerExecutableName()
     * @see #setMeshLabServerExecutableName(String)
     */
    public static void checkMeshLabPath()
    {
        final String MESHLAB_PATH_ENVIRONMENT_VARIABLE = System.getProperty("MESHLAB_PATH");

        final String OPERATING_SYSTEM_NAME = System.getProperty("os.name");

        if ((getMeshLabPath() == null) || (getMeshLabPath().isEmpty()))
        {
            if ((MESHLAB_PATH_ENVIRONMENT_VARIABLE != null) && !MESHLAB_PATH_ENVIRONMENT_VARIABLE.isEmpty())
            {
                setMeshLabPath(MESHLAB_PATH_ENVIRONMENT_VARIABLE);
            }
            // https://stackoverflow.com/questions/228477/how-do-i-programmatically-determine-operating-system-in-java
            else if (OPERATING_SYSTEM_NAME.toLowerCase(Locale.ENGLISH).contains("windows"))
            {
                setMeshLabPath(MESHLAB_PATH_DEFAULT_WINDOWS);
            }
            else if (OPERATING_SYSTEM_NAME.toLowerCase(Locale.ENGLISH).contains("mac"))
            {
                setMeshLabPath(MESHLAB_PATH_DEFAULT_MACOS);
            }
            else if (OPERATING_SYSTEM_NAME.toLowerCase(Locale.ENGLISH).contains("linux"))
            {
                setMeshLabPath(MESHLAB_PATH_DEFAULT_LINUX);
            }
        }
        // ensure trailing \ or / is present in path
        String systemMeshLabPath = getMeshLabPath();
        if (!systemMeshLabPath.isEmpty() && !systemMeshLabPath.endsWith("\\") && !systemMeshLabPath.endsWith("/"))
        {
            systemMeshLabPath = systemMeshLabPath + File.separator;
            setMeshLabPath(systemMeshLabPath);
        }
        /* debug diagnostic
        System.out.println("checkMeshLabPath() result: getMeshLabPath()=" + getMeshLabPath()); */
    }
    /**
     * Keep track of whether prior command execution was successful.
     */
    private static boolean executeCommandSuccessful = false;
    /**
     * Report  whether prior command execution was successful.
     * @return whether prior command execution was successful.
     * <em>[warning]</em> <code>meshlabserver</code> may popup an exception window while running headless (not very smart) which can cause exception to be lost following timeout.
     * @see <a href="https://stackoverflow.com/questions/3630281/is-it-possible-to-capture-a-windows-pop-up-message-box-from-inside-a-java-program">StackOverflow: possible to capture pop-up message box?</a>
     */
    public static boolean wasPriorCommandSuccessful()
    {
        return executeCommandSuccessful;
    }
    /**
     * Launch MeshLab in operating system and run command.
     * <em>[warning]</em> <code>meshlabserver</code> may popup an exception window while running headless (not very smart) which can cause exception to be lost following timeout.
     * @param command MeshLab invocation
     * @return console results
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     * @see <a href="https://stackoverflow.com/questions/3630281/is-it-possible-to-capture-a-windows-pop-up-message-box-from-inside-a-java-program">StackOverflow: possible to capture pop-up message box?</a>
     * @see <a href="https://stackoverflow.com/questions/31776546/why-does-runtime-execstring-work-for-some-but-not-all-commands/" target="_blank">Why does Runtime.exec(String) work for some but not all commands?</a>
     * @see <a href="https://stackoverflow.com/questions/13008526/runtime-getruntime-execcmd-hanging" target="_blank">StackOverflow: Runtime.getRuntime().exec(cmd) hanging</a>
     * @see <a href="https://stackoverflow.com/questions/3468987/executing-another-application-from-java" target="_blank">StackOverflow: Executing another application from Java</a>
     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html" target="_blank">java.lang.Runtime</a>
     * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html" target="_blank">java.lang.ProcessBuilder</a>
     */
    protected static String executeCommand (String command)
    {
        StringBuilder outputBuilder = new StringBuilder();
        Process process;
        ProcessBuilder processBuilder;

        try
        {
//          File directory = new File(getMeshLabPath()); // debug
//          * @see <a href="https://stackoverflow.com/questions/7347856/how-to-convert-a-string-into-an-arraylist" target="_blank">StackOverflow: How to convert a String into an ArrayList?</a>

            ArrayList<String> commandArgs = new ArrayList<>(Arrays.asList(command.split("\\s")));
            processBuilder = new ProcessBuilder(commandArgs);
            process = processBuilder.start();
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));

            String  line;
            while ((line = reader.readLine())!= null)
            {
                outputBuilder.append(line).append("\n");
            }
        }
        catch (IOException e)
        {
            outputBuilder.append(e.getMessage()).append("\n").append(e.getCause()).append("\n");
            e.printStackTrace();
            throw new org.web3d.x3d.sai.InvalidExecutionContextException(command);
        }
        return outputBuilder.toString();
    }
    /**
     * Use meshLab to convert model from one file to another.
     * @param  inputFileName for  input file
     * @param outputFileName for output file
     * @return whether successful
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static boolean convertModel (String inputFileName, String outputFileName)
    {
        return convertModel ("", inputFileName, outputFileName);
    }
    /**
     * Use meshLab to convert model from one file to another.
     * @param path directory path to file of interest
     * @param  inputFileName for  input file
     * @param outputFileName for output file
     * @return whether successful
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static boolean convertModel (String path, String inputFileName, String outputFileName)
    {
        checkMeshLabPath();
        String separator = "";
        if (path == null)
            path = "";
        if (!path.endsWith("\\") && !path.endsWith("/") && !path.isEmpty())
            separator = File.separator;

		File inputFile;
        if (path.isEmpty() || path.equals("."))
             inputFile = new File(      inputFileName);
        else inputFile = new File(path, inputFileName);

        if (!inputFile.exists())
        {
                throw new InvalidDocumentException("path='" + path + "', inputFile='" + inputFileName + "' does not exist and cannot be loaded, check path and filename.");
        }

        String fileNameRoot            = outputFileName.substring(0,outputFileName.lastIndexOf("."));
        String meshLabTraceLogFile     = fileNameRoot + ".MeshLab.log.txt";
               meshLabTraceLogFilePath = path + separator + meshLabTraceLogFile;

        StringBuilder meshLabCommand = new StringBuilder();
        meshLabCommand.append(getMeshLabPath())
                      .append(getMeshLabServerExecutableName())
                      .append(" -l ").append(meshLabTraceLogFilePath)                        //    log file
                      .append(" -i ").append(path).append(separator).append(inputFileName)   //  input file
                      .append(" -o ").append(path).append(separator).append(outputFileName); // output file
        System.out.println (meshLabCommand.toString());
        executeCommand(     meshLabCommand.toString());

	File outputFile;
        if ((path == null) || path.isEmpty() || path.equals("."))
             outputFile = new File(      outputFileName);
        else outputFile = new File(path, outputFileName);

        if (!outputFile.exists())
        {
                throw new InvalidDocumentException("path='" + path + "', outputFileName='" + outputFileName + "' does not exist and cannot be loaded, check path and filename.");
        }
        return wasPriorCommandSuccessful();
    }
    /**
     * Use meshLab to import model to X3D.
     * @param fileName for input file
     * @return result, null if unsuccessful
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ importModel (String fileName)
    {
        return importModel ("", fileName);
    }
    /**
     * Use meshLab to import model to X3D.
     * @param path directory path to file of interest
     * @param fileName for input file
     * @return result, null if unsuccessful
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ importModel (String path, String fileName)
    {
        String separator = "";
        if (path == null)
            path = "";
        if (!path.endsWith("\\") && !path.endsWith("/") && !path.isEmpty())
            separator = File.separator;
        String fileNameRoot            = fileName.substring(0,fileName.lastIndexOf("."));
        String fileNameX3dModel        = fileNameRoot + ".MeshLab.x3d";
        String meshLabTraceLogFile     = fileNameRoot + ".MeshLab.log.txt";
               meshLabTraceLogFilePath = path + separator + meshLabTraceLogFile;

        StringBuilder meshLabCommand = new StringBuilder();
        meshLabCommand.append(getMeshLabPath())
                      .append(getMeshLabServerExecutableName())
                      .append(" -l ").append(meshLabTraceLogFilePath)                          //    log file
                      .append(" -i ").append(path).append(separator).append(fileName)          //  input file
                      .append(" -o ").append(path).append(separator).append(fileNameX3dModel); // output file
        System.out.println (meshLabCommand.toString());
        executeCommand(     meshLabCommand.toString());

        // TODO option for X3D Tidy, X3D Canonical avoided for now since large-attribute STL files aren't loaded properly.
        X3DLoaderDOM x3dLoader = new X3DLoaderDOM();
        x3dLoader.loadModelFromFileX3D(path, fileNameX3dModel);
        return (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[) x3dLoader.getX3dObjectTree();
    }
    /**
     * TODO: Use meshLab to import STL geometry as X3D model
     * @param path directory path to file of interest
     * @param fileName for input file
     * @return result, null if unsuccessful
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ importSTL (String path, String fileName)
    {
        // test file extension, determine if binary stl, add any metadata
        return null;
    }

    /**
     * TODO: Use MeshLab to export geometry to STL
     * @param modelToExport X3D model of interest
     * @param path directory path for X3D model of interest
     * @param fileName file name for X3D model of interest
     * @return plain-text STL file
     * @see <a href="https://en.wikipedia.org/wiki/STL_(file_format)" target="_blank">STL (file format)</a>
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
    * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static boolean exportModelToFile (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ modelToExport, String path, String fileName)
    {
        // test file extension, determine if binary stl, add any metadata
        return false;
    }

    /**
     * TODO: Use MeshLab to export geometry to file
     * @param modelToExport X3D model of interest
     * @param path directory path to file of interest
     * @param fileName for output file
     * @return whether successful
     * @see <a href="https://en.wikipedia.org/wiki/STL_(file_format)" target="_blank">STL (file format)</a>
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
    * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static boolean exportSTLtoFile (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ modelToExport, String path, String fileName)
    {
        // TODO test file extension
        boolean result = exportModelToFile (modelToExport, path, fileName);
        try
        {
            // TODO save to file
        }
        catch (Exception e)
        {
            // Diagnostic
            return false;
        }
        return true;
    }
    /**
     * TODO: Get MeshLab metrics for X3D model of interest.
     * @param modelOfInterest X3D model to analyze
     * @return MeshLab output
     * @see <a href="https://en.wikipedia.org/wiki/STL_(file_format)" target="_blank">STL (file format)</a>
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
    * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static String getMeshLabAnalytics (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ modelOfInterest)
    {
        // add optional method to create X3DMetadataSet
        return "";
    }
    /**
     * TODO: Get MeshLab metrics as MetadataSet object.
     * @param modelOfInterest X3D model to analyze
     * @return MeshLab output
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static MetadataSet getMeshLabAnalyticsX3dMetadataSet (X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ modelOfInterest)
    {
        return null;
    }
    /**
     * Get MeshLab version.
     * <i>Warning:</i> ensure MESHLAB_HOME or local path is set correctly, especially if more than one version is installed.
     * @return MeshLab version.
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static String getMeshLabVersion()
    {
        String helpString = getMeshLabHelp() + "\n";
        return helpString.substring(0,helpString.indexOf("\n"));
    }
    /**
     * Determine if MeshLab is locally available.
     * <i>Warning:</i> ensure MESHLAB_HOME or local path is set correctly, especially if more than one version is installed.
     * @return whether MeshLab is found.
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static boolean hasMeshLab()
    {
        checkMeshLabPath();
        StringBuilder meshLabCommand = new StringBuilder();
        meshLabCommand.append(getMeshLabPath())
                      .append(getMeshLabServerExecutableName())
                      .append(" --help");
        String meshLabHelp = executeCommand(meshLabCommand.toString());
        return ((meshLabHelp != null) && meshLabHelp.contains("meshlabserver [logargs] [args]"));
    }
    /**
     * Get default MeshLab help message (from invocation without command-line parameters).
     * @return MeshLab help message.
     * @see <a href="https://www.MeshLab.net" target="_blank">MeshLab</a>
     * @see <a href="https://en.wikipedia.org/wiki/MeshLab" target="_blank">Wikipedia: MeshLab</a>
     * @see <a href="https://github.com/cnr-isti-vclab/PyMeshLab" target="_blank">PyMeshLab</a> for Python
     */
    public static String getMeshLabHelp()
    {
        checkMeshLabPath();
        StringBuilder meshLabCommand = new StringBuilder();
        meshLabCommand.append(getMeshLabPath())
                      .append(getMeshLabServerExecutableName());
//                    .append(" --help"); // unnecessary
        String meshLabHelp = executeCommand(meshLabCommand.toString());
        return meshLabHelp.replaceAll("\r\n", "\n").replaceAll("\n\n", "\n").trim(); // avoid double newlines in output
    }
    /**
     * Directory and file name for MeshLab trace log file produced during most recent MeshLab operation.
     * @return name of most recent MeshLab trace log file
     */
    private static String meshLabTraceLogFilePath = new String();
    /**
     * Get name of MeshLab trace log file produced during most recent MeshLab operation.
     * @return name of most recent MeshLab trace log file
     */
    public static String getPriorMeshLabTraceLogFilePath()
    {
        return meshLabTraceLogFilePath;
    }
    /**
     * Set name of MeshLab trace log file produced during most recent MeshLab operation.
     * @param value new path and file name for meshLabTraceLogFilePath
     */
    public static void setPriorMeshLabTraceLogFilePath(String value)
    {
        meshLabTraceLogFilePath = value;
    }
    /**
     * Get contents of MeshLab trace log file produced during most recent MeshLab operation.
     * @return contents of most recent MeshLab trace log file
     */
    public static String getPriorMeshLabTraceLogContents()
    {
        if ((meshLabTraceLogFilePath == null) || (meshLabTraceLogFilePath.isEmpty()))
            return ""; // nothing to behold
        List<String> priorMeshLabTraceLog;
        try
        {
            Path priorMeshLabTraceLogPath = FileSystems.getDefault().getPath(meshLabTraceLogFilePath);
            if  (priorMeshLabTraceLogPath == null)
                 return "";
            priorMeshLabTraceLog = Files.readAllLines(priorMeshLabTraceLogPath);
        }
        catch (IOException ioe)
        {
            String message = "Exception when trying to getPriorMeshLabTraceLogContents()\n" + ioe.getMessage();
            ioe.printStackTrace();
            throw new org.web3d.x3d.sai.InvalidExecutionContextException(message);
        }
        return priorMeshLabTraceLog.toString();
    }
    //  TODO command-line invocation [-MESHLAB_PATH | -convert | -import]

    /** Initialize this MeshLabLauncher instance to default values. */
    public static final void initialize()
    {
        checkMeshLabPath();
        initializeConfigurationSwitches();
    }
    /**
     *                               Usage: <code>java [-classpath X3DJSAIL.*.jar] org.web3d.x3d.jsail.MeshLabLauncher sourceFile [-convert [resultFile]] [-home | -help | -properties fileName.properties | -MESHLAB_PATH directoryPath]</code>
     */
    public  static final String USAGE   = "Usage: java [-classpath X3DJSAIL.*.jar] org.web3d.x3d.jsail.MeshLabLauncher sourceFile [-convert [resultFile]] [-home | -help | -properties fileName.properties | -MESHLAB_PATH directoryPath]";
    private static final String WARNING = "[Warning] ";
    private static final String ERROR   = "[Error] ";

    private static boolean modelConvert     = false;
    private static boolean modelExport      = false; // not used via main invocation
    private static boolean modelImport      = false; // not used via main invocation

	private static String  conversionExtension = new String();

	/** Reset configuration switch values */
	private static void initializeConfigurationSwitches()
	{
		modelConvert         = true;  // default choice, switch is optional
		modelExport          = false;
		modelImport          = false;

		conversionExtension  = new String();
	}

    /**
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
     */
    private static BufferedWriter bufferedWriter;

    /** Default main() method provided for test and debugging purposes, invoking run() method.
     * @param args the command line arguments
     * @see #run(String[])
     * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#handleArguments(String[])
     */
    public static void main(String[] args)
    {
        if (args.length == 0)
        {
            // test invocation
            args = new String[1];
            args[0] = "-version";
            // test invocation
//          String[] alternate = { "C:/x3d-code/www.web3d.org/x3d/stylesheets/java/examples/CleatClamp.x3d", "-toImage" };
//          args = alternate;
        }
//      run(args);
        System.out.println (MESHLABSERVER_ERROR_NOTICE);
    }

    /** Utility run() method provided for test and debugging purposes, allowing invocation with a single String (rather than a String[] array).
	 * When invoked without parameters then reports results of validate() self-checks to system output.
     * @param singleStringArguments the command line arguments
     * @see #run(String[])
     */
    public static void run(String singleStringArguments)
    {
		run(singleStringArguments.split("(\\s)")); // split single string into string array
	}

    /** Default run() method provided for test and debugging purposes, first initializing ConfigurationProperties then reading properties file (if any) and processing arguments.
	 * When invoked without parameters then reports results of validate() self-checks to system output.
     * @param args the command line arguments
     * @see #main(String[])
     * @see ConfigurationProperties
     * @see X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[#handleArguments(String[])
     */
    public static void run(String[] args)
    {
        File    sourceFile;
        long    sourceFileLength     = 0;
        String  sourceFileName       = "";
        String  sourceFileNameRoot   = "";
		File    resultFile;
        boolean convertToFile        = false;
        boolean createImageSnapshot  = false;
        boolean loadProperties       = false;
        boolean resetPath            = false;
        String  resultFileName       = "";
        String  resultFileNameRoot   = "";
        String propertiesFileName    = "";
        String propertiesFileNameRoot= "";
        DecimalFormat formatPrecision2 = new DecimalFormat ("#0.00");
		String  compressionRatio;

		initializeConfigurationSwitches();

		if ((args== null) || (args.length < 1))
		{
			System.out.println (USAGE);
			return;
		}
		else
		{
			for (int i=0; i<=args.length-1; i++)
			{
                args[i] = args[i].trim(); // eliminate excess whitespace, if called programmatically
				if  (!args[i].startsWith("-"))
				{
					if (modelConvert && !sourceFileName.isEmpty() && !resultFileName.isEmpty())
					{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.MeshLabLauncher] too many file names found, source=\"" + sourceFileName + "\" and result \"" + resultFileName + "\" prior to argument \"" + args[i] + "\". Check usage:");
						System.out.println(USAGE);
						return;
					}
//					else if ((modelExport || modelImport) && !sourceFileName.isEmpty())
//					{
//						System.out.println(ERROR+" [org.web3d.x3d.jsail.MeshLabLauncher] too many source file names found, source=\"" + sourceFileName + "\" prior to argument \"" + args[i] + "\". Check usage:");
//						System.out.println(USAGE);
//						return;
//					}
					else if (modelConvert && !sourceFileName.isEmpty()) // now have encountered resultFile value, overwrite default
					{
						resultFileName     = args[i];
						resultFileNameRoot = resultFileName;
						if (resultFileNameRoot.contains("."))
							resultFileNameRoot = resultFileName.substring(0,resultFileNameRoot.lastIndexOf("."));
						resultFile = new File(resultFileName);
                        conversionExtension = resultFileName.substring(resultFileName.lastIndexOf("."));
                        if (conversionExtension.isEmpty())
						{
							System.out.println(ERROR+" [org.web3d.x3d.jsail.MeshLabLauncher] result file extension is needed for conversion but not found: " + resultFileName);
							System.out.println(USAGE);
							return;
						}
					}
					else
					{
						sourceFileName     = args[i];
						sourceFileNameRoot = sourceFileName;
						if (sourceFileNameRoot.contains("."))
							sourceFileNameRoot = sourceFileName.substring(0,sourceFileName.lastIndexOf("."));
						sourceFile = new File(sourceFileName);

						if (!sourceFile.exists())
						{
							System.out.println(ERROR+" [org.web3d.x3d.jsail.MeshLabLauncher] file not found: " + sourceFileName);
							return;
						}
						else
						{
							sourceFileLength = sourceFile.length();
							System.out.println ("MeshLabLauncher parameter: source file " + sourceFile.getName() + " filesize " + sourceFileLength + " bytes");
						}
					}
				}
				else if (args[i].equalsIgnoreCase("-properties") || args[i].equalsIgnoreCase("-propertiesFile")) // optionally followed by propertiesFileName
				{
					if ((args.length > i + 1) && !(args[i+1] == null) && !args[i+1].isEmpty() && !args[i+1].startsWith("-"))
					{
						 propertiesFileName     = args[i+1];
						 propertiesFileNameRoot = propertiesFileName.substring(0,propertiesFileName.lastIndexOf("."));
						 System.out.println ("MeshLabLauncher parameter: \"" + args[i] + "\" \"" + args[i+1] + "\" for properties file name root " + propertiesFileNameRoot);
						 i++; // increment index, carefully!
					}
					else System.out.println ("MeshLabLauncher parameter: \"" + args[i] + "\" for properties file name root "+ propertiesFileNameRoot);
					loadProperties = true; // set flag
				}
				else if (args[i].equalsIgnoreCase("-MESHLAB_PATH") || args[i].equalsIgnoreCase("-MESHLABPATH"))
				{
					if ((args.length > i + 1) && !(args[i+1] == null) && !args[i+1].isEmpty() && !args[i+1].startsWith("-"))
					{
                        String newPath = args[i + 1];
                        System.out.println ("parameters: \"" + args[i] + "\" \"" + newPath + "\" for setting MeshLab path");
                        setMeshLabPath(newPath);
                        checkMeshLabPath();
                    	i++; // increment index, carefully!
					}
					else System.out.println ("Error: parameter: \"" + args[i] + "\" missing new MeshLab path value");
				    resetPath = true; // set flag
				}
				else if (args[i].equalsIgnoreCase("-convert"))
				{
                    initializeConfigurationSwitches();
					modelConvert = true;
					System.out.println ("MeshLabLauncher parameter: \"" + args[i] + "\" for conversion between formats");
				}
//				else if (args[i].equalsIgnoreCase("-export"))
//				{
//                    initializeConfigurationSwitches();
//					modelExport = true;
//					System.out.println ("MeshLabLauncher parameter: \"" + args[i] + "\" for model export");
//				}
//				else if (args[i].equalsIgnoreCase("-import"))
//				{
//                    initializeConfigurationSwitches();
//					modelImport = true;
//                    conversionExtension = X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_X3D; // default
//					System.out.println ("MeshLabLauncher parameter: \"" + args[i] + "\" for model export");
//				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-home") || args[i].equalsIgnoreCase("-page") || args[i].equalsIgnoreCase("-homepage") || args[i].equalsIgnoreCase("-website"))
				{
					launchMeshLabWebPage();
					return;
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-version"))
				{
					System.out.println(getMeshLabVersion());
					return;
				}
				// ==========================================
				else  if (args[i].toLowerCase().contains("-help"))
				{
					System.out.println(USAGE);
					System.out.println(MESHLAB_URL);
					System.out.println("Meshlab help:");
					System.out.println(getMeshLabHelp());
//                  launchMeshLabWebPage();
					return;
				}
				// ==========================================
				else // not found
				{
					System.out.println(ERROR+" [org.web3d.x3d.jsail.MeshLabLauncher] unrecognized MeshLabLauncher option \"" + args[i] + "\"");
					System.out.println(USAGE);
					return;
				}
			}
		}
		// ===================================================================================
		if (loadProperties)
		{
			if (!propertiesFileName.isEmpty())
				ConfigurationProperties.setPropertiesFileName (propertiesFileName);
			ConfigurationProperties.loadProperties();
		}
		// compute/confirm resultFileName after all command-line switches are read
		if (!sourceFileName.isEmpty() && resultFileName.isEmpty())
		{
            conversionExtension = X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_X3D;
            resultFileName      = sourceFileNameRoot + conversionExtension;
            resultFileNameRoot  = sourceFileNameRoot;
            resultFile = new File(resultFileName);
		}
		if (modelImport && (!conversionExtension.equalsIgnoreCase(X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[.FILE_EXTENSION_X3D)))
		{
			System.out.println(WARNING+" [org.web3d.x3d.jsail.MeshLabLauncher] resultFile " + resultFileName + " has mismatched file extension \"" + conversionExtension + "\" for conversion");
		}

		// ===================================================================================
        if (!sourceFileName.isEmpty()) // fully prepared, now get source file and proceed
        {
			if (modelConvert)
			{
				executeCommandSuccessful = convertModel (sourceFileName, resultFileName);
				System.out.println("load success: " + executeCommandSuccessful);
				return;
			}
		}
		else if (!loadProperties && !resetPath) // allows testing of properties without file operations
        {
            String message = ERROR+"Source model file name is empty, therefore file loading not possible.";
            System.out.println(message);
            throw new org.web3d.x3d.sai.InvalidExecutionContextException(message);
        }
    }

    /** Open MeshLab page
     * @see <a href="https://www.MeshLab.net">https://www.MeshLab.net</a>
     * @see MESHLAB_URL
     */
    public static void launchMeshLabWebPage()
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java
        try {
            if (Desktop.isDesktopSupported())
            {
                Desktop.getDesktop().browse(new URI(MESHLAB_URL));
            }
        }
        catch (IOException | URISyntaxException e2)
        {
            System.out.println ("launchMeshLabWebPage failure: " + e2.getMessage());
        }
    }
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>CommentsBlock</xsl:text></xsl:with-param>
		<xsl:with-param name="imports">
			<xsl:text>
import org.web3d.x3d.sai.Core.X3DMetadataObject;
import org.web3d.x3d.jsail.*;</xsl:text>
		</xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text>Core</xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteStatement</xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.Core.X3DChildNode</xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Utility class to enable adding one or more comment strings as a child node, treated as an X3D statement.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>NAME</i> provides name of this element. */
	@SuppressWarnings("FieldNameHidesFieldInSuperclass")
	protected static final String NAME = "CommentsBlock";

	/** Provides name of this element: CommentsBlock.
	 * @return name of this element
	 */
	@Override
	public final String getElementName()
	{
		return NAME;
	}
	/** String constant <i>COMPONENT</i> defines X3D component for comments: <i>Core</i>. */
	public static final String COMPONENT = "Core";

	/** Defines X3D component for comments: <i>Core</i>.
	 * @return X3D component for comments
	 */
	@Override
	public final String getComponent()
	{
		return COMPONENT;
	}

	/** Integer constant <i>LEVEL</i> provides default X3D <i>Core</i> component level for comments: <i>1</i>. */
	public static final int LEVEL = 1;

	/** Provides default X3D component level for comments: <i>1</i>.
	 * @return default X3D component level for comments
	 */
	@Override
	public final int getComponentLevel()
	{
		return LEVEL;
	}

	/** Constructor for CommentsBlock. */
	public CommentsBlock()
	{
	  initialize();
	};

	/** Constructor for CommentsBlock to initialize with initial comment string.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newComment initial comment, with no comment delimiters needed
	 */
	public CommentsBlock(String newComment)
	{
		initialize();
		commentsList.add(newComment);
	};

	/** Constructor for CommentsBlock to initialize with initial comments array.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newComments[] initial comments, with no comment delimiters needed
	 */
	public CommentsBlock(String newComments[])
	{
		initialize();
		if ((newComments != null) && (newComments.length > 0))
			commentsList.addAll(Arrays.asList(newComments));
	};

	/** Constructor for CommentsBlock to initialize with initial comments list.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newCommentsList initial comments, with no comment delimiters needed
	 */
	public CommentsBlock(ArrayList<String> newCommentsList)
	{
		initialize();
		commentsList.addAll(newCommentsList);
	};

	/**
	 * Add single comment to this CommentsBlock.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newComment initial value, with no comment delimiters needed
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	/* @Override */
	public CommentsBlock addComments(String newComment)
	{
		commentsList.add(newComment);
		return this;
	}
	/**
	 * Add comments as String[] array to this CommentsBlock.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newComments array of comments, with no comment delimiters needed
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	/* @Override */
	public CommentsBlock addComments(String[] newComments)
	{
		commentsList.addAll(Arrays.asList(newComments));
		return this;
	}
	/**
	 * Add comments array as ArrayList of String values to this CommentsBlock.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newCommentsList list of comments, with no comment delimiters needed
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public CommentsBlock addComments(ArrayList<String> newCommentsList)
	{
		commentsList.addAll(newCommentsList);
		return this;
	}
	/**
	 * Add CommentsBlock to this CommentsBlock.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newCommentsBlock block of comments to add, with no comment delimiters needed
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	/* @Override */
	public CommentsBlock addComments(CommentsBlock newCommentsBlock)
	{
		commentsList.addAll(Arrays.asList(newCommentsBlock.toStrings()));
		return this;
	}

	/**
	 * Provide CommentsBlock as string array.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @return all comments
	 */
	public String[] toStrings()
	{
		return (String[]) commentsList.toArray();
	}

	/**
	 * Provide CommentsBlock as ArrayList of string(s).
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @return all comments
	 */
	public ArrayList<String> toStringList()
	{
		return commentsList;
	}

	/** Initialize this CommentsBlock instance. */
	@Override
	public final void initialize()
	{
		super.initialize();
		commentsList = new ArrayList<>(); // reset
	}
	/** Clear all comments from this CommentsBlock.
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same object).
	 */
	public CommentsBlock clear()
	{
		initialize();
		return this;
	}
	/** Utility method to adjust XML comment delimiters <code>&lt;!--</code> and <code>--&gt;</code>, also replace invalid &quot;<code>--</code>&quot; characters with &quot;<code>- -</code>&quot;.
	 * Typically only used internally when exporting via toStringX3D() methods to avoid (illegal) nested XML comments.
	 * @param newComment is comment to be cleaned
	 * @return cleaned-up string with no problematic XML comment characters embedded
	 */
	public static String cleanXmlCommentDelimiters (String newComment)
	{
		String result = newComment;
		if (result == null)
			result = new String();
		if (result.contains("--"))
		{
			result = result.replaceAll("--","- -");
			// TODO consider log entry
		}
		return result;
	}
]]></xsl:text>

		</xsl:with-param>
	</xsl:call-template>

	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>X3DUnifiedObjectModel40</xsl:text></xsl:with-param>
		<xsl:with-param name="imports">
			<xsl:text>
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;

import org.web3d.x3d.jsail.Core.X3D;</xsl:text>
		</xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public final</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Utility class to expose X3D Unified Object Model (X3DUOM).</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
    private X3DUnifiedObjectModel x3duomInstance;

    private final String X3dUnifiedObjectModel40_XML_FILE = "X3dUnifiedObjectModel-4.0.xml";

    private JAXBContext jaxbContext;

    /** Constructor performs initialization */
    public X3DUnifiedObjectModel40()
    {
        initialize();
    }

    /** Load and initialize X3DUOM JAXB object
     */
    public void initialize()
    {
        try
        {
            X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ x3dObject = new X3D]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[(); // necessary for static object?  TODO visibility problems

            File x3duomXmlFile = x3dObject.getTempFileFromX3dJsailJar("/specifications", X3dUnifiedObjectModel40_XML_FILE);

            if (!x3duomXmlFile.exists())
            {
				String errorNotice = "*** [error] X3DUnifiedObjectModel40." +
								     "X3dUnifiedObjectModel40_XML_FILE=\"" + X3dUnifiedObjectModel40_XML_FILE + "\" not found";
				System.out.println(errorNotice);
                return;
            }
            jaxbContext = JAXBContext.newInstance(X3DUnifiedObjectModel.class);

            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();

            x3duomInstance = (X3DUnifiedObjectModel) unmarshaller.unmarshal(x3duomXmlFile);
        }
        catch (JAXBException e)
        {
            System.out.println("X3DUnifiedObjectModel initialize() failure:");
            System.out.println(e);
        }
    }
    /** Marshall X3DUOM JAXB object as XML String to file
     *@param outputFilePath path and filename for result
     */
    public void marshallToXmlFile(String outputFilePath)
    {
        try
        {
            Marshaller marshaller = jaxbContext.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
//          marshaller.marshal(x3duomInstance, System.out); // debug
            marshaller.marshal(x3duomInstance, new File(outputFilePath));
        }
        catch (JAXBException e)
        {
            System.out.println("X3DUnifiedObjectModel40 marshalToXML() marshaller.setProperty failure:");
            System.out.println(e);
        }
    }
    /** Provide XML String of X3DUOM from JAXB object
     *@return XML string
     */
    public String marshalToXml()
    {
        File tempFile;
        byte[] encodedByteArray = null;
        try
        {
            Marshaller marshaller = jaxbContext.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
//          marshaller.marshal(x3duomInstance, System.out); // debug
            tempFile = File.createTempFile("x3duomJaxb","temp.xml");
            marshaller.marshal(x3duomInstance, tempFile);

            // https://stackoverflow.com/questions/326390/how-do-i-create-a-java-string-from-the-contents-of-a-file
            encodedByteArray = Files.readAllBytes(Paths.get(tempFile.getPath()));
        }
        catch (IOException | JAXBException e)
        {
            System.out.println("X3DUnifiedObjectModel40 marshalToXML() failure:");
            System.out.println(e);
        }
        return new String(encodedByteArray);
    }
]]></xsl:text>

		</xsl:with-param>
	</xsl:call-template>

    <!-- ===================================================== -->

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DConcreteFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text>import org.web3d.x3d.sai.X3DFieldEvent;</xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Listener for events passing values from one X3D field to another.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.3 X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>6.3.20 registerBrowserInterest</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>servRef.html#RegisterBrowserInterest</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text disable-output-escaping="yes"><![CDATA[

	public void readableFieldChanged(X3DFieldEvent event)
	{
		// TODO;
	}
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

    </xsl:template> <!-- end of ConcreteNodeObjectDefinitions -->

    <!-- ===================================================== -->

<xsl:template name="set-newValue-validity-checks">
    <xsl:param name="elementName"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="canThrowFieldValueException"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="isArrayType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="isArrayListType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="x3dType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="javaReferenceType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="comparisonType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="debug"><xsl:text>false</xsl:text></xsl:param>

	<!-- TODO regular expression checks -->

	<xsl:variable name="tupleSize">
		<xsl:call-template name="tupleSize">
			<xsl:with-param name="x3dType" select="$x3dType"/>
		</xsl:call-template>
	</xsl:variable>
	<xsl:variable name="javaType">
		<!-- can include collections, must be escaped -->
		<xsl:call-template name="javaType">
			<xsl:with-param name="x3dType" select="$x3dType"/>
		</xsl:call-template>
	</xsl:variable>

    <!-- note that not all name attributes are NMTOKEN type but many are -->
    <!-- TODO consider checking baseType of enumeration array -->
	<xsl:variable name="isX3dNameType" select="
			($elementName = 'connect') or
			((@name = 'name') and not(starts-with($elementName,'Metadata')) and not(starts-with($elementName,'CAD')))"/>

	<xsl:variable name="isNMTOKENtype" select="$isX3dNameType or
			(@name = 'DEF') or (@name = 'USE') or ($elementName = 'ROUTE') or ($elementName = 'EXPORT') or ($elementName = 'IMPORT')"/>

	<!-- debug diagnostic
        <xsl:if test="true() or ($debug = 'true')">
            <xsl:message>
                    <xsl:text>set-newValue-validity-checks: name=</xsl:text>
                    <xsl:value-of select="@name"/>
                    <xsl:text>, type=</xsl:text>
                    <xsl:value-of select="$x3dType"/>
                    <xsl:text>, isArrayType=</xsl:text>
                    <xsl:value-of select="$isArrayType"/>
                    <xsl:text>, isArrayListType=</xsl:text>
                    <xsl:value-of select="$isArrayListType"/>
                    <xsl:text>, baseType=</xsl:text>
                    <xsl:value-of select="@baseType"/>
                    <xsl:text>, javaReferenceType=</xsl:text>
                    <xsl:value-of select="$javaReferenceType"/>
                    <xsl:text>, comparisonType=</xsl:text>
                    <xsl:value-of select="$comparisonType"/>
                    <xsl:text>, tupleSize=</xsl:text>
                    <xsl:value-of select="$tupleSize"/>
            </xsl:message>
        </xsl:if>
	-->
	<xsl:choose>
		<xsl:when test="($isArrayType='true')">
			<xsl:text>  int i = 0;</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>  for (</xsl:text>
            <xsl:variable name="saiPackagePath">
                <xsl:call-template name="saiPackage">
                    <xsl:with-param name="nodeType" select="$javaReferenceType"/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:choose>
                <xsl:when test="(string-length($saiPackagePath) > 0)">
                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 12a */</xsl:text></xsl:if>
                    <xsl:value-of select="$saiPackagePath"/>
                    <xsl:text>.</xsl:text>
                    <xsl:value-of select="$javaReferenceType"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:if test="$insertSourceMarkers"><xsl:text> /* marker 12b, saiPackage not found */</xsl:text></xsl:if>
                    <xsl:value-of select="$javaReferenceType"/>
                </xsl:otherwise>
            </xsl:choose>
			<xsl:text> arrayElement : </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:when>
		<xsl:when test="($isArrayListType = 'true')">
		</xsl:when>
	</xsl:choose>
	<xsl:variable name="newValueReference">
		<xsl:choose>
			<xsl:when test="($isArrayType='true')">
				<xsl:value-of select="$newValue"/>
				<xsl:text>[i]</xsl:text>
			</xsl:when>
			<xsl:when test="($isArrayListType = 'true')">
				<xsl:value-of select="$newValue"/>
				<xsl:text>[i]</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$newValue"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="dimensionSuffix">
		<xsl:choose>
			<xsl:when test="(@baseType = 'bboxSizeType')">
				<xsl:text>.length</xsl:text>
			</xsl:when>
			<xsl:when test="(($isArrayListType = 'true') and ($comparisonType = 'complex'))">
				<xsl:text>.size()</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>.length</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>

	<!-- TODO tupleSize modulus checks for MF types -->
	<xsl:choose>
		<xsl:when test="(($isArrayType = 'false') or ($isArrayListType = 'true')) and (number($tupleSize) > 1)">
			<xsl:text>		if (newValue == null)
			</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> = new </xsl:text>
		<xsl:value-of select="substring-before($javaType,'[]')"/>
		<xsl:text>[0];
		// Check that newValue parameter has legal size before assigning to scene graph</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		if (newValue</xsl:text>
			<xsl:value-of select="$dimensionSuffix"/>
			<xsl:choose>
				<xsl:when test="starts-with($x3dType,'SF')">
					<xsl:text> != </xsl:text>
					<xsl:value-of select="$tupleSize"/>
					<xsl:text>) // </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes">-tuple check
		{</xsl:text>
				</xsl:when>
				<xsl:otherwise><!-- MF type -->
					<xsl:text> % </xsl:text>
					<xsl:value-of select="$tupleSize"/>
					<xsl:text> != 0) // </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes">-tuple check
		{</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="contains($dimensionSuffix, 'size')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
					<xsl:text> + "</xsl:text>
					<xsl:text> has size=" + </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:value-of select="$dimensionSuffix"/>
					<xsl:text> + "</xsl:text>
					<xsl:choose>
						<xsl:when test="starts-with($x3dType,'SF')">
							<xsl:text> instead of required length </xsl:text>
							<xsl:value-of select="$tupleSize"/>
						</xsl:when>
						<xsl:otherwise><!-- MF type -->
							<xsl:text>, must be a multiple of </xsl:text>
							<xsl:value-of select="$tupleSize"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>) + "</xsl:text>
					<xsl:text> has length=" + </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:value-of select="$dimensionSuffix"/>
					<xsl:text> + "</xsl:text>
					<xsl:choose>
						<xsl:when test="starts-with($x3dType,'SF')">
							<xsl:text> instead of required length </xsl:text>
							<xsl:value-of select="$tupleSize"/>
						</xsl:when>
						<xsl:otherwise><!-- MF type -->
							<xsl:text>, must be a multiple of </xsl:text>
							<xsl:value-of select="$tupleSize"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:when>
	</xsl:choose>
    <xsl:variable name="isEnumerationType" select="(count(enumeration) > 0)"/>
    <xsl:variable name="isEnumerationTypeRequired" select="boolean(@additionalEnumerationValuesAllowed='false')"/>
	<xsl:choose>
		<xsl:when test="not($isArrayType = 'true')">
			<xsl:if test="($canThrowFieldValueException) and
                  (($x3dType='SFInt32') or ($x3dType='SFFloat') or ($x3dType='SFDouble') or ($x3dType='SFTime') or
                   ($x3dType='SFColor') or ($x3dType='SFColorRGBA') or
                   ($x3dType='SFVec2f') or ($x3dType='SFVec2d') or ($x3dType='SFVec3f')  or ($x3dType='SFVec3d') or
                   ($x3dType='SFVec4f') or ($x3dType='SFVec4d') or (@baseType='bboxSizeType') or
                   ((($x3dType='SFString') or ($x3dType='MFString')) and (enumeration) and $isEnumerationType))">

		<xsl:if test="(string-length(@minExclusive) > 0) or (string-length(@minInclusive) > 0) or (string-length(@maxExclusive) > 0) or (string-length(@maxInclusive) > 0)">
			<xsl:text>        </xsl:text>
			<xsl:text>// Check that newValue parameter has legal value(s) before assigning to scene graph</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:variable name="typeSuffix">
			<xsl:if test="($x3dType='SFFloat') or ends-with($x3dType,'f') or contains($x3dType,'Color')">
				<xsl:text>f</xsl:text><!-- float-to-float comparison to avoid float-to-double roundoff discrepancies -->
			</xsl:if>
		</xsl:variable>
		<xsl:if test="(string-length(@minExclusive) > 0)">
			<xsl:text>        </xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:choose>
				<xsl:when test="($x3dType='SFInt32') or ($x3dType='SFFloat') or ($x3dType='SFDouble') or ($x3dType='SFTime')">
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes"> &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec2f') or ($x3dType='SFVec2d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec3f') or ($x3dType='SFVec3d') or ($x3dType='SFColor')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec4f') or ($x3dType='SFVec4d') or ($x3dType='SFColorRGBA')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[3] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:message><xsl:text>[error] set-newValue-validity-checks code-generation error</xsl:text></xsl:message>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>                throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with($x3dType,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$newValue"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has component value less than (or equal to) restriction minExclusive=</xsl:text>
			<xsl:value-of select="@minExclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>        </xsl:text>
			<xsl:text>}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="(string-length(@minInclusive) > 0)">
			<xsl:text>        </xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:choose>
				<xsl:when test="($x3dType='SFInt32') or ($x3dType='SFFloat') or ($x3dType='SFDouble') or ($x3dType='SFTime')">
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes"> &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec2f') or ($x3dType='SFVec2d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec3f') or ($x3dType='SFVec3d') or ($x3dType='SFColor')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec4f') or ($x3dType='SFVec4d') or ($x3dType='SFColorRGBA')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[3] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>        </xsl:text>
			<xsl:text>    throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with($x3dType,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$newValue"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has component value less than restriction minInclusive=</xsl:text>
			<xsl:value-of select="@minInclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>        </xsl:text>
			<xsl:text>}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="(string-length(@maxExclusive) > 0)">
			<xsl:text>        </xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:choose>
				<xsl:when test="($x3dType='SFInt32') or ($x3dType='SFFloat') or ($x3dType='SFDouble') or ($x3dType='SFTime')">
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes"> &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec2f') or ($x3dType='SFVec2d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec3f') or ($x3dType='SFVec3d') or ($x3dType='SFColor')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec4f') or ($x3dType='SFVec4d') or ($x3dType='SFColorRGBA')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[3] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>        </xsl:text>
			<xsl:text>    throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with($x3dType,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has component value greater than (or equal to) restriction maxExclusive=</xsl:text>
			<xsl:value-of select="@maxExclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>        </xsl:text>
			<xsl:text>}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="(string-length(@maxInclusive) > 0)">
			<xsl:text>        </xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:choose>
				<xsl:when test="($x3dType='SFInt32') or ($x3dType='SFFloat') or ($x3dType='SFDouble') or ($x3dType='SFTime')">
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes"> &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec2f') or ($x3dType='SFVec2d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec3f') or ($x3dType='SFVec3d') or ($x3dType='SFColor')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="($x3dType='SFVec4f') or ($x3dType='SFVec4d') or ($x3dType='SFColorRGBA')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[3] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>        </xsl:text>
			<xsl:text>    throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with($x3dType,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has component value greater than restriction maxInclusive=</xsl:text>
			<xsl:value-of select="@maxInclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>            </xsl:text>
			<xsl:text>}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="(@baseType='bboxSizeType')">
			<xsl:text>		// Check legal value for bounding box bboxSize</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		</xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:text>(</xsl:text>
			<xsl:text>(</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[0] &lt; 0) || (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[1] &lt; 0) || (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[2] &lt; 0)</xsl:text>
			<xsl:text disable-output-escaping="yes">) &amp;&amp; !((</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[0] == -1) &amp;&amp; (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[1] == -1) &amp;&amp; (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[2] == -1))</xsl:text>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with($x3dType,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has negative value but is not equal to sentinel {-1,-1,-1} value.</xsl:text>
			<xsl:value-of select="@maxInclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="(($x3dType='SFString') or ($x3dType='MFString'))"><!-- TODO are there any other types with restricted values? -->
			<xsl:choose>
				<xsl:when test="($x3dType='SFString')">
					<xsl:text>		if (</xsl:text><xsl:value-of select="$newValue"/><xsl:text> == null)
		{
                    </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text> = new String(); // null string check
		}
</xsl:text>
					<xsl:variable name="isEnumerationType" select="(count(enumeration) > 0)"/>
					<xsl:variable name="isEnumerationTypeRequired" select="boolean(@additionalEnumerationValuesAllowed='false')"/>
					<xsl:if test="$isEnumerationType">
						<xsl:text>		</xsl:text>
						<xsl:value-of select="$newValue"/>
						<xsl:text> = MFString.cleanupUnescapedEnclosingQuotes(</xsl:text>
						<xsl:value-of select="$newValue"/>
						<xsl:text>); // handle potential enumeration value</xsl:text>
					</xsl:if>
				</xsl:when>
				<xsl:when test="($x3dType='MFString')">
					<xsl:text>		if (</xsl:text><xsl:value-of select="$newValue"/><xsl:text> == null)
                {
                    clear</xsl:text>
                        <xsl:value-of select="upper-case(substring(@name,1,1))"/>
                        <xsl:value-of select="substring(@name,2)"/><!-- upper camel case -->
                        <xsl:text>(); // null string check
                    return this;
                }
</xsl:text>
				</xsl:when>
				<!-- TODO multiple methods? works for String but not ArrayList<String>
				-->
			</xsl:choose>

			<xsl:text>
                // TODO check if SFString parameter has a multistring value, then split it
                // Check that newValue parameter has one of the allowed legal values before assigning to scene graph</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:if test="starts-with($elementName, 'HAnim') and (@name = 'name')">
                            <xsl:text>
//		String  namingMessage = new String();
//              boolean namingMessageAlreadyProvided = false;

                if (!</xsl:text>
				<xsl:value-of select="$newValue"/>
				<xsl:text>.toString().replace("\"","").equals(</xsl:text>
				<xsl:value-of select="$newValue"/>
				<xsl:text>.toLowerCase())</xsl:text>
                                <xsl:text disable-output-escaping="yes"><![CDATA[ && ]]></xsl:text>
				<xsl:text>!namingMessageAlreadyProvided)
		{
				namingMessage += "[info] recommended HAnim name values are lower case, note capitalization/spelling of </xsl:text>
				<xsl:value-of select="$elementName"/>
				<xsl:text> name='" + </xsl:text>
				<xsl:value-of select="$newValue"/>
				<xsl:text> + "'";
                                namingMessageAlreadyProvided = true;
		}
</xsl:text>
				<xsl:if test="($elementName = 'HAnimSite') and (@name = 'name')">
					<xsl:text>		</xsl:text>
					<xsl:text>String savedValue = </xsl:text><xsl:value-of select="$newValue"/><xsl:text>; // save invocation value
		if      (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>.endsWith("_tip"))
			</xsl:text><xsl:value-of select="$newValue"/><xsl:text> = </xsl:text><xsl:value-of select="$newValue"/><xsl:text>.substring(0,</xsl:text><xsl:value-of select="$newValue"/><xsl:text>.lastIndexOf("_tip"));
		else if (</xsl:text><xsl:value-of select="$newValue"/><xsl:text>.endsWith("_view"))
			</xsl:text><xsl:value-of select="$newValue"/><xsl:text> = </xsl:text><xsl:value-of select="$newValue"/><xsl:text>.substring(0,</xsl:text><xsl:value-of select="$newValue"/><xsl:text>.lastIndexOf("_view"));
		else if (</xsl:text><xsl:value-of select="$newValue"/><xsl:text>.endsWith("_pt"))
			</xsl:text><xsl:value-of select="$newValue"/><xsl:text> = </xsl:text><xsl:value-of select="$newValue"/><xsl:text>.substring(0,</xsl:text><xsl:value-of select="$newValue"/><xsl:text>.lastIndexOf("_pt"));
		else
		{
		//	</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> = ""; // missing necessary suffix
			if (!namingMessage.isEmpty())
				 namingMessage += "\n";
            namingMessage += "[warning] HAnimSite name='</xsl:text><xsl:value-of select="$newValue"/><xsl:text>' is required to end in \"_tip\" \"_view\" or \"_pt\".";
        }
</xsl:text>
				</xsl:if>
			</xsl:if>
            <xsl:if test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
                        <xsl:text disable-output-escaping="yes"><![CDATA[
        for (int i = 0; i < newValue.length; i++)
        {
]]></xsl:text>
                <xsl:if test="(@type='MFString')">
                        <xsl:text disable-output-escaping="yes"><![CDATA[            String priorValue = newValue[i];
            if (newValue[i].trim().startsWith("\"") || (newValue[i].trim().endsWith("\"") && !newValue[i].trim().endsWith("\\\"")) ||
                !newValue[i].trim().equals(priorValue))
            {
                newValue[i] = newValue[i].trim();
                if (ConfigurationProperties.isConsoleOutputVerbose())
                    System.out.println ("trimmed MFString newValue[" + i + "]=" + newValue[i]); // debug diagnostic

                // unquote quoted strings before comparison
                boolean reduced = false;
                if (newValue[i].startsWith("\""))
                {
                    newValue[i] = newValue[i].substring(1);
                    reduced = true;
                }
                if (newValue[i].endsWith("\"") && !newValue[i].endsWith("\\\""))
                {
                    newValue[i] = newValue[i].substring(1, newValue[i].length()-1);
                    reduced = true;
                }
                if (reduced)
                    if (ConfigurationProperties.isConsoleOutputVerbose())
                        System.out.println ("[error] trimmed MFString newValue[" + i + "]=" + newValue[i] +
                            " from prior value \"" + priorValue + "\""); // debug diagnostic
            }
]]></xsl:text>
                </xsl:if>
            </xsl:if>
			<xsl:text>		</xsl:text>
			<xsl:text>if (!(</xsl:text>
			<xsl:text>&#10;</xsl:text>
            <!-- debug
            <xsl:if test="($x3dType='MFString')">
                <xsl:text>// $isArrayType=</xsl:text>
                <xsl:value-of select="$isArrayType"/>
                <xsl:text>, $isArrayListType=</xsl:text>
                <xsl:value-of select="$isArrayListType"/>
                <xsl:text>, $dimensionSuffix=</xsl:text>
                <xsl:value-of select="$dimensionSuffix"/>
                <xsl:text>, $comparisonType=</xsl:text>
                <xsl:value-of select="$comparisonType"/>
                <xsl:text>, $javaType=</xsl:text>
                <xsl:value-of select="$javaType"/>
                <xsl:text>&#10;</xsl:text>
            </xsl:if> -->
            <!-- gyrations to figure out testing for MFString based on various method signatures -->
            <xsl:variable name="isNewValueEmptyExpression">
                <xsl:choose>
                <xsl:when test="($x3dType='SFString')">
                    <xsl:value-of select="$newValue"/>
                    <xsl:text>.isEmpty()</xsl:text>
                </xsl:when>
                <xsl:when test="($x3dType='MFString') and ($isArrayListType = 'true') and ($comparisonType = 'simple')">
                    <xsl:text>(</xsl:text>
                    <xsl:value-of select="$newValue"/>
                    <xsl:text>.length == 0)</xsl:text>
                </xsl:when>
                <xsl:when test="($x3dType='MFString') and ($isArrayListType = 'true')">
                    <xsl:text>(</xsl:text>
                    <xsl:value-of select="$newValue"/>
                    <xsl:value-of select="$dimensionSuffix"/>
                    <xsl:text> == 0)</xsl:text>
                </xsl:when>
                <xsl:when test="($x3dType='MFString') and ($isArrayListType = 'false') and ($comparisonType = 'simple')">
                    <xsl:value-of select="$newValue"/>
                    <xsl:text>.isEmpty()</xsl:text>
                </xsl:when>
                <xsl:when test="($x3dType='MFString') and ($isArrayListType = 'false')">
                    <xsl:value-of select="$newValue"/>
                    <xsl:text>.getValue().isEmpty()</xsl:text>
                </xsl:when>
                <xsl:when test="($x3dType='MFString')">
                    <xsl:value-of select="$newValue"/>
                    <xsl:text>isEmpty()</xsl:text>
                </xsl:when>
            </xsl:choose>
            </xsl:variable>
            <xsl:if test="(string-length($isNewValueEmptyExpression) > 0)">
                    <xsl:text>			</xsl:text>
                    <xsl:value-of select="$isNewValueEmptyExpression"/>
                    <xsl:text> ||</xsl:text>
                    <xsl:text>&#10;</xsl:text>
            </xsl:if>

			<xsl:for-each select="enumeration">
				<xsl:if test="position() > 1">
					<xsl:text> ||</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:text>			</xsl:text>
				<xsl:choose>
					<xsl:when test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
						<xsl:value-of select="$newValue"/>
						<xsl:text>[i]</xsl:text>
					</xsl:when>
					<xsl:when test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
						<xsl:text>Arrays.asList(</xsl:text>
						<xsl:value-of select="$newValue"/>
						<xsl:text>)</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$newValue"/>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:choose>
                                    <xsl:when test="($x3dType='SFString') or ($x3dType='MFString')">
                                        <xsl:text>.toString().replace("\"","")</xsl:text>
                                    </xsl:when>
				</xsl:choose>
				<xsl:text>.equals(</xsl:text>
				<xsl:value-of select="upper-case(../@name)"/>
				<xsl:text>_</xsl:text>
				<!-- enumeration name: omit " character, others become _ underscore -->
				<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
				<xsl:text>)</xsl:text>
			</xsl:for-each>
			<xsl:text>))</xsl:text>
                        <xsl:text>&#10;</xsl:text>
                        <xsl:text>		</xsl:text>
			<xsl:text>{</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:if test="($elementName = 'HAnimSite') and (@name = 'name')">
				<xsl:text>			</xsl:text>
				<xsl:value-of select="$newValue"/><xsl:text> = savedValue; // restore invocation value with suffix (if any)</xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:text>			String warningMessage = "</xsl:text>
            <xsl:choose>
                <xsl:when test="$isEnumerationTypeRequired">
                    <xsl:text>[warning] </xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>[info] </xsl:text>
                </xsl:otherwise>
            </xsl:choose>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>='" + </xsl:text>
			<xsl:choose>
				<xsl:when test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$newValue"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "'</xsl:text>
			<xsl:text> includes an unrecognized</xsl:text>
                        <xsl:if test="$isEnumerationTypeRequired">
                            <xsl:text> optional</xsl:text>
                        </xsl:if>
			<xsl:text> value</xsl:text>
                        <xsl:if test="($x3dType='MFString') and ($isArrayListType = 'true') and ($comparisonType = 'simple')">
                            <xsl:text> newValue[" + i + "]=" + newValue[i] + "</xsl:text>
                        </xsl:if>
			<xsl:text> not matching any of the </xsl:text>
            <xsl:choose>
                <xsl:when test="$isEnumerationTypeRequired">
                    <xsl:text>required enumeration</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>optional</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text> string tokens.";</xsl:text>
            <xsl:text>&#10;</xsl:text>
            <xsl:text>			if (!</xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>WarningAlreadyProvided)</xsl:text>
            <xsl:text>&#10;</xsl:text>
            <xsl:text>			{</xsl:text>
            <xsl:text>&#10;</xsl:text>
            <xsl:text>			    warningMessage += "\n" + "       Supported values are </xsl:text>
            <xsl:choose>
                <xsl:when test="(($elementName = 'HAnimJoint') or ($elementName = 'HAnimSegment') or ($elementName = 'HAnimSite')) and (@name = 'name')">
                    <xsl:text>found in X3D Tooltips for </xsl:text>
                    <xsl:value-of select="$elementName"/>
                    <xsl:text>.name at </xsl:text>
                    <xsl:text>https://www.web3d.org/x3d/content/X3dTooltips.html</xsl:text>
                    <xsl:text>#</xsl:text>
                    <xsl:value-of select="$elementName"/>
                    <xsl:text>.name"</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <!-- TODO list allowed values -->
                    <xsl:for-each select="enumeration">
                        <xsl:call-template name="backslash-quote-characters"> <!-- tail recursion -->
                                <xsl:with-param name="inputValue" select="@value"/>
                        </xsl:call-template>
                        <xsl:if test="not(position() = last())">
                            <xsl:text>, </xsl:text>
                        </xsl:if>
                    </xsl:for-each>
                    <xsl:text>"</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text>;</xsl:text>
            <xsl:text>&#10;</xsl:text>
            <xsl:text>			    </xsl:text>
            <xsl:value-of select="@name"/>
            <xsl:text>WarningAlreadyProvided = true;</xsl:text>
            <xsl:text>&#10;</xsl:text>
            <xsl:text>			}</xsl:text>

            <xsl:if test="($elementName = 'HAnimHumanoid') and (@name = 'version')">
                <xsl:text>&#10;</xsl:text>
                <xsl:text>			warningMessage += "\n" + "[warning] HAnimHumanoid version='1.0' models might not run correctly in X3D 4.0 and upgrading model to HAnim version='2.0' is advised.";</xsl:text>

                <xsl:text disable-output-escaping="yes"><![CDATA[
                        if (newValue.toString().replace("\"","").equals("1.0") && !(hasAncestorX3D() && findAncestorX3D().getVersion().startsWith("3")))
                        {
                            warningMessage += "\n" + "[warning] Note that HAnimHumanoid version='1.0' is only allowed in X3D version 3 models, not X3D version='4.0' models.";
                        }
]]></xsl:text>
            </xsl:if>
            <xsl:if test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
				<xsl:text>
			if (newValue[i].contains(" "))
                            warningMessage += " Note that enumeration value \"" + newValue[i] + "\" contains embedded whitespace, need to check necessary quoting of individual MFString values.";</xsl:text>
            </xsl:if>
            <!-- multiple accessor methods include this trace -->
            <xsl:if test="(ancestor::*[string-length(@name) > 0]/@name = 'NavigationInfo') and (@name = 'type')">
                <xsl:text>&#10;</xsl:text>
                <xsl:text>                        warningMessage += "\n[warning] trace: </xsl:text>
                <xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
                <xsl:text> </xsl:text>
                <xsl:value-of select="@name"/>
                <xsl:text> </xsl:text>
                <xsl:value-of select="$x3dType"/>
                <xsl:text> </xsl:text>
                <xsl:text> newValue=" + newValue + " with newValue.getClass().getTypeName()=" + newValue.getClass().getTypeName()</xsl:text>
                <xsl:text>;</xsl:text>
            </xsl:if>
            <xsl:text>&#10;</xsl:text>
			<xsl:if test="($elementName = 'meta') and (@name = 'name')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			if (newValue.equalsIgnoreCase("permissions"))
				warningMessage += " Suggested meta term: name='accessRights'";
			else if (newValue.equalsIgnoreCase("audio") || newValue.equalsIgnoreCase("midi") || newValue.equalsIgnoreCase("sounds"))
				warningMessage += " Suggested meta term: name='Sound'";
			else if (newValue.equalsIgnoreCase("generated") || newValue.equalsIgnoreCase("imported"))
				warningMessage += " Suggested meta term: name='created'";
			else if (newValue.equalsIgnoreCase("organization"))
				warningMessage += " Suggested meta term: name='contributor'";
			else if (newValue.equalsIgnoreCase("comment"))
				warningMessage += " Suggested meta term: name='hint' or name='info'";
			else if (newValue.toLowerCase().startsWith("revised") || newValue.equalsIgnoreCase("revision"))
				warningMessage += " Suggested meta term: name='modified' or name='contributor'";
			else if (newValue.toLowerCase().startsWith("film") || newValue.toLowerCase().startsWith("movie") || newValue.equalsIgnoreCase("video"))
				warningMessage += " Suggested meta term: name='MovingImage'";
			else if (newValue.toLowerCase().equalsIgnoreCase("diagram") || newValue.equalsIgnoreCase("painting") ||
					 newValue.equalsIgnoreCase("picture") || newValue.toLowerCase().contains("texture"))
				warningMessage += " Suggested meta term: name='Image'";
			else if (newValue.equalsIgnoreCase("documentation") || newValue.equalsIgnoreCase("example") || newValue.equalsIgnoreCase("resource"))
				warningMessage += " Suggested meta term: name='reference'";
			else if (newValue.equalsIgnoreCase("name") || newValue.equalsIgnoreCase("filename"))
				warningMessage += " Suggested meta term: name='title'";
			else if (newValue.trim().toUpperCase().startsWith("TODO "))
				warningMessage += " Suggested meta term: name='TODO' with additional information '" +
					 newValue.trim().substring(5) + "' moved into content attribute";
			else if (!newValue.equals("TODO") && newValue.toUpperCase().equals("TODO"))
				warningMessage += " Suggested meta term: name='TODO'";
			if (newValue.contains("[") || newValue.contains("]"))
				warningMessage += " Avoid [square brackets] in name value.";
			if (newValue.contains("(") || newValue.contains(")"))
				warningMessage += " Avoid (parentheses) in name value.";
			if (newValue.contains("'"))
				warningMessage += " Avoid 'apostrophes' in name value.";
			if (newValue.contains("\""))
				warningMessage += " Avoid \"quotation marks\" in name value.";
]]></xsl:text>
			</xsl:if>
			<xsl:text>			if (ConfigurationProperties.isConsoleOutputVerbose())</xsl:text>
                        <xsl:text>&#10;</xsl:text>
			<xsl:text>			    System.out.println(warningMessage);</xsl:text>
                        <xsl:text>&#10;</xsl:text>
			<xsl:if test="starts-with($elementName, 'FontStyle') and (@name = 'family')">
				<xsl:text>			// TODO figure out problem when checking ArrayList for single value
				if (newValue.equals("SANSERIF"))
				warningMessage += " FontStyle family value \"SANSERIF\" needs correction as \"SANS\" instead.";
</xsl:text>
			</xsl:if>
			<xsl:if test="($elementName = 'HAnimSite') and (@name = 'name')">
				<xsl:text> 			if (!</xsl:text><xsl:value-of select="$newValue"/><xsl:text disable-output-escaping="yes"><![CDATA[.endsWith("_tip") && ]]></xsl:text>
				    <xsl:text>!</xsl:text><xsl:value-of select="$newValue"/><xsl:text disable-output-escaping="yes"><![CDATA[.endsWith("_view") && ]]></xsl:text>
				    <xsl:text>!</xsl:text><xsl:value-of select="$newValue"/><xsl:text disable-output-escaping="yes"><![CDATA[.endsWith("_pt"))]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text>			    namingMessage += " Also note that HAnimSite name must end in \"_tip\" \"_view\" or \"_pt\".";</xsl:text>
                <xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="starts-with($elementName, 'HAnim') and (@name = 'name')">
				<xsl:text>			if (!namingMessage.trim().isEmpty()</xsl:text>
                                <xsl:text disable-output-escaping="yes"><![CDATA[ && ConfigurationProperties.isConsoleOutputVerbose())]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text>              System.out.println(namingMessage);</xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="$isEnumerationTypeRequired">
				<xsl:text>
            if (!</xsl:text>
                    <xsl:value-of select="$isNewValueEmptyExpression"/>
                    <xsl:if test="(($elementName = 'HAnimHumanoid') and (@name = 'version'))">

                        <xsl:text disable-output-escaping="yes"><![CDATA[ && !newValue.equals("1.0") /* HAnim 1.0 leniency */ ]]></xsl:text>
                    </xsl:if>
                    <xsl:text>) // @additionalEnumerationValuesAllowed='</xsl:text><xsl:value-of select="@additionalEnumerationValuesAllowed"/><xsl:text>'
            {
                throw new org.web3d.x3d.sai.InvalidFieldValueException(warningMessage);
            }
</xsl:text>
			</xsl:if>
			<xsl:text>		}</xsl:text>
			<xsl:text>&#10;</xsl:text>
            <xsl:if test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
                        <xsl:text disable-output-escaping="yes"><![CDATA[        }
]]></xsl:text>
            </xsl:if>
		</xsl:if>
	</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			<!-- TODO ArrayList comparisons -->
		</xsl:otherwise>
	</xsl:choose>
	<!-- SFString initialization and special tests -->
	<xsl:choose>
		<!-- X3D naming conventions include NMTOKEN checks -->
		<!-- NMTOKEN checks required for all name fields except meta (which matches HTML), CAD* and Metadata* -->
		<xsl:when test="$isNMTOKENtype">
			<xsl:text>		if (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> == null)
			</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> = new String();
		// Check that newValue parameter meets naming requirements before assigning to </xsl:text>
			<xsl:value-of select="$elementName"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text>
		if (</xsl:text>
			<xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'AS')) or
						   not(@use='required')">
				<!-- attribute is not #REQUIRED and so can be empty -->
				<xsl:text disable-output-escaping="yes"><![CDATA[!newValue.isEmpty() && ]]></xsl:text>
			</xsl:if>
			<xsl:text>!org.web3d.x3d.jsail.fields.SFString.isNMTOKEN(newValue))</xsl:text>
				<xsl:text>&#10;</xsl:text>
			<xsl:text>		{</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>='" + </xsl:text>
			<xsl:choose>
				<xsl:when test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$newValue"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "'"</xsl:text>
			<xsl:if test="InterfaceDefinition/field[@name = 'DEF']">
				<xsl:text> + " DEF='" + getDEF() + "'"</xsl:text>
			</xsl:if>
			<xsl:text> + </xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>				" has illegal name value, cannot be empty and must be defined with valid NMTOKEN name string"</xsl:text>
			<xsl:text> + </xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>				" (with legal characters and no embedded whitespace).</xsl:text>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		}</xsl:text>
            <xsl:text>&#10;</xsl:text>

            <xsl:if test="$isX3dNameType"><!-- additional test -->
                <xsl:text>
        if (</xsl:text>
                <xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'AS')) or
                               not(@use='required')">
                    <!-- attribute is not #REQUIRED and so can be empty -->
                    <xsl:text disable-output-escaping="yes"><![CDATA[!newValue.isEmpty() && ]]></xsl:text>
                </xsl:if>
                <xsl:choose>
                    <xsl:when test="($elementName = 'component') and  (@name = 'name')">
                        <!-- HAnim enumeration is poorly named, deserves specification change -->
                        <xsl:text disable-output-escaping="yes"><![CDATA[!newValue.equals(NAME_H_ANIM) && !newValue.equals(NAME_HANIM) && ]]></xsl:text>
                        <xsl:text>&#10;</xsl:text>
                        <xsl:text>                             </xsl:text>
                        <!-- Sound and Text component names are overloaded and match a corresponding node name -->
                        <xsl:text disable-output-escaping="yes"><![CDATA[!newValue.equals(NAME_SHAPE) && !newValue.equals(NAME_PARTICLESYSTEMS) && !newValue.equals(NAME_SOUND) && ]]></xsl:text>
                        <xsl:text>&#10;</xsl:text>
                        <xsl:text>                             </xsl:text>
                        <!-- Text component is overloaded and matches a node name -->
                        <xsl:text disable-output-escaping="yes"><![CDATA[!newValue.equals(NAME_TEXT) && ]]></xsl:text>
                    </xsl:when>
                    <xsl:when test="($elementName = 'meta') and (@name = 'name')">
                        <xsl:text>&#10;</xsl:text>
                        <xsl:text>                             </xsl:text>
                        <!-- DCMI metadata terms include "Sound" https://www.dublincore.org/specifications/dublin-core/dcmi-terms/dcmitype/Sound -->
                        <xsl:text disable-output-escaping="yes"><![CDATA[!newValue.equals(NAME_SOUND) && ]]></xsl:text>
                        <xsl:text>&#10;</xsl:text>
                        <xsl:text>                             </xsl:text>
                        <!-- DCMI metadata terms include "Text" https://www.dublincore.org/specifications/dublin-core/dcmi-terms/dcmitype/Text -->
                        <xsl:text disable-output-escaping="yes"><![CDATA[!newValue.equals(NAME_TEXT) && ]]></xsl:text>
                    </xsl:when>
                </xsl:choose>
                <xsl:text>!org.web3d.x3d.jsail.fields.SFString.meetsX3dInteroperabilityNamingConventions(newValue))</xsl:text>
                <xsl:text>&#10;</xsl:text>
                <xsl:text>		{</xsl:text>
                <xsl:text>&#10;</xsl:text>
                <xsl:text>			if (ConfigurationProperties.isConsoleOutputVerbose())</xsl:text>
                <xsl:text>&#10;</xsl:text>
                <xsl:text>                          System.out.println</xsl:text>
                <xsl:text>("[warning] </xsl:text>
                <xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
                <xsl:text> </xsl:text>
                <xsl:value-of select="@name"/>
                <xsl:text> </xsl:text>
                <xsl:value-of select="$newValue"/>
                <xsl:text>='" + </xsl:text>
                <xsl:choose>
                    <xsl:when test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
                        <xsl:text>Arrays.toString(</xsl:text>
                        <xsl:value-of select="$newValue"/>
                        <xsl:text>)</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$newValue"/>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:text> + "'"</xsl:text>
                <xsl:if test="InterfaceDefinition/field[@name = 'DEF']">
                    <xsl:text> + " DEF='" + getDEF() + "'"</xsl:text>
                </xsl:if>
                <xsl:text> + </xsl:text>
                <xsl:text>&#10;</xsl:text>
                <xsl:text>				" has name value that does not meet X3D naming conventions.</xsl:text>
                <xsl:text>");</xsl:text>
                <xsl:text>&#10;</xsl:text>
                <xsl:text>		}</xsl:text>
                <xsl:text>&#10;</xsl:text>
            </xsl:if>
		</xsl:when>
		<xsl:when test="($x3dType='SFString')">
			<xsl:text>		if (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> == null)
			</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> = new String(); // Principle of Least Astonishment (POLA) #5
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment
</xsl:text>
			<xsl:if test="$isNMTOKENtype">
				<xsl:text>
		// Check that newValue parameter meets naming requirements before assigning to </xsl:text>
			<xsl:value-of select="$elementName"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text>
		if (</xsl:text>
			<xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'AS')) or
						   not(@use='required')">
				<!-- attribute is not #REQUIRED and so can be empty -->
				<xsl:text disable-output-escaping="yes"><![CDATA[!newValue.isEmpty() && ]]></xsl:text>
			</xsl:if>
				<xsl:text>!org.web3d.x3d.jsail.fields.SFString.isNMTOKEN(newValue))
		{
			throw new org.web3d.x3d.sai.InvalidFieldValueException("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=\"" + </xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[newValue +
					"\" has illegal value, must use a valid string meeting NMTOKEN requirements.");
		}
		else if (]]></xsl:text>
			<xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'AS')) or
						   not(@use='required')">
				<!-- attribute is not #REQUIRED and so can be empty -->
				<xsl:text disable-output-escaping="yes"><![CDATA[!newValue.isEmpty() && ]]></xsl:text>
			</xsl:if>
				<xsl:text>!org.web3d.x3d.jsail.fields.SFString.meetsX3dInteroperabilityNamingConventions(newValue))
		{
			if (ConfigurationProperties.isConsoleOutputVerbose())
                            System.out.println ("[warning] ";
			throw new org.web3d.x3d.sai.InvalidFieldValueException("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=\"" + </xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[newValue +
					"\" does not meet X3D naming conventions.");
		}
]]></xsl:text>
			</xsl:if>
		</xsl:when>
	</xsl:choose>
	<xsl:choose>
		<xsl:when test="($isArrayType='true')">
			<xsl:text>	}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:when>
		<xsl:when test="($isArrayListType = 'true')">
		</xsl:when>
	</xsl:choose>
</xsl:template>

    <!-- ===================================================== -->

<!-- from BuildSpecificationLanguageBindingJava.xslt adapted for X3D Object Model-->
<xsl:template name="list-restrictions">
    <xsl:variable name="originalType" select="@type"/>
    <xsl:variable name="isEnumerationType" select="(count(enumeration) > 0)"/>
    <xsl:variable name="isEnumerationTypeRequired" select="boolean(@additionalEnumerationValuesAllowed='false')"/>
    <xsl:variable name="enumerationValues">
		<xsl:if test="enumeration">
            <xsl:if test="(string-length(@baseType) > 0)">
				<xsl:text>(baseType </xsl:text><!-- #2 -->
                <xsl:value-of select="@baseType"/>
				<xsl:text>) </xsl:text>
            </xsl:if>
			<xsl:text>[</xsl:text>
			<xsl:for-each select="enumeration">
				<!-- MFString enumeration values are already quoted -->
				<xsl:choose>
					<xsl:when test="contains(@value,'&#34;')">
						<xsl:text>'</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>"</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:value-of select="@value"/>
				<!-- MFString enumeration values are already quoted -->
				<xsl:choose>
					<xsl:when test="contains(@value,'&#34;')">
						<xsl:text>'</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>"</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:if test="not(position() = last())">
					<xsl:text> | </xsl:text>
				</xsl:if>
			</xsl:for-each>
			<xsl:if test="(@additionalEnumerationValuesAllowed='true')">
				<xsl:choose>
					<xsl:when test="(@type='SFString')">
						<xsl:text> | 'etc.'</xsl:text>
					</xsl:when>
					<xsl:when test="(@type='MFString')">
						<xsl:text> | '"etc."'</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:if>
			<xsl:text>]</xsl:text>
		</xsl:if>
    </xsl:variable>
    <xsl:choose>
        <xsl:when test="(@type='SFBool') or (@type='MFBool') or (@type='featurePointNames') or (@type='jointNames') or (@type='segmentNames') or (@type='siteNames')">
            <!-- no restriction-->
        </xsl:when>
        <xsl:when test="(@name = 'bboxSize')">
            <xsl:text>within allowed range of </xsl:text>
            <xsl:text>[0,infinity), or default value [-1 -1 -1], </xsl:text>
        </xsl:when>
        <xsl:when test="contains(@type,'RGBA')">
            <xsl:text>using RGBA values [0..1] </xsl:text>
        </xsl:when>
        <xsl:when test="contains(@type,'Color') or contains(@name,'Color') or contains(@name,'color')">
            <xsl:text>using RGB values [0..1] </xsl:text>
        </xsl:when>
        <xsl:when test="(@name = 'objectType')">
            <xsl:text>with quoted value(s) </xsl:text>
            <xsl:text>["ALL","NONE","TERRAIN",...] </xsl:text>
        </xsl:when>
        <xsl:when test="(@name = 'type') and (ancestor::*[@name='NavigationInfo'])">
            <xsl:text>with quoted value(s) </xsl:text>
            <xsl:text>["ANY","WALK","EXAMINE","FLY","LOOKAT","NONE","EXPLORE",...] </xsl:text>
        </xsl:when>
        <xsl:when test="(@name = 'transitionType') and (ancestor::*[@name='NavigationInfo'])">
            <xsl:text>with quoted value(s) </xsl:text>
            <xsl:text>["TELEPORT","LINEAR","ANIMATE",...] </xsl:text>
        </xsl:when>
        <xsl:when test="(@name = 'GeoOrigin') or (@name = 'geoOrigin')">
            <!-- https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html -->
            <xsl:text>(deprecated node, optional) </xsl:text>
        </xsl:when>
        <xsl:when test="((@type='SFString') or (@type='MFString')) and (string-length(xs:annotation/xs:documentation) > 0)">
            <xsl:value-of select="normalize-space(xs:annotation/xs:documentation)"/>
            <xsl:text> </xsl:text>
        </xsl:when>
        <xsl:when test="(string-length($enumerationValues) > 0)">
            <xsl:value-of select="$enumerationValues"/>
            <xsl:text> </xsl:text>
        </xsl:when>
        <xsl:when test="((@type='SFString') or (@type='MFString')) and (string-length(xs:simpleType/xs:restriction/@base) > 0)">
            <xsl:value-of select="xs:simpleType/xs:restriction/@base"/>
            <xsl:text> </xsl:text>
        </xsl:when>
        <xsl:when test="(@type='SFString') or (@type='MFString')">
            <!-- no restriction-->
        </xsl:when>
        <xsl:when test="(string-length(@minInclusive) > 0) or (string-length(@minExclusive) > 0) or (string-length(@maxInclusive) > 0) or (string-length(@maxExclusive) > 0)">
            <xsl:text>within allowed range of </xsl:text>
            <xsl:choose>
                <xsl:when test="(string-length(@minInclusive) > 0)">
                    <xsl:text>[</xsl:text>
                    <xsl:value-of select="@minInclusive"/>
                </xsl:when>
                <xsl:when test="(string-length(@minExclusive) > 0)">
                    <xsl:text>(</xsl:text>
                    <xsl:value-of select="@minExclusive"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>(-infinity</xsl:text> <!-- &#8734; &infin; infinity symbol -->
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text>,</xsl:text>
            <xsl:choose>
                <xsl:when test="(string-length(@maxInclusive) > 0)">
                    <xsl:value-of select="@maxInclusive"/>
                    <xsl:text>]</xsl:text>
                </xsl:when>
                <xsl:when test="(string-length(@maxExclusive) > 0)">
                    <xsl:value-of select="@maxExclusive"/>
                    <xsl:text>)</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>infinity)</xsl:text> <!-- &#8734; &infin; infinity symbol -->
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text> </xsl:text>
        </xsl:when>
        <!-- retrieve range for specially defined simpleTypes, e.g. intensityType -->
        <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction">
			<xsl:text>within allowed range of </xsl:text>
            <xsl:choose>
                <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:minInclusive">
                    <xsl:text>[</xsl:text>
                    <xsl:value-of select="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:minInclusive/@value"/>
                </xsl:when>
                <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:minExclusive">
                    <xsl:text>(</xsl:text>
                    <xsl:value-of select="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:minExclusive/@value"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>(-infinity</xsl:text> <!-- &infin; infinity symbol -->
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text>,</xsl:text>
            <xsl:choose>
                <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:maxInclusive">
                    <xsl:value-of select="/xs:schema/maxInclusive/@value"/>
                    <xsl:text>]</xsl:text>
                </xsl:when>
                <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:maxExclusive">
                    <xsl:value-of select="/xs:schema/maxExclusive/@value"/>
                    <xsl:text>)</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>infinity)</xsl:text> <!-- &infin; infinity symbol -->
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text> </xsl:text>
        </xsl:when>
        <xsl:when test="((@type='SFNode') or (@type='MFNode')) and (string-length(@acceptableNodeTypes) > 0) and (contains(@acceptableNodeTypes,'|'))">
            <xsl:text>with acceptable node types limited to </xsl:text>
			<xsl:value-of select="@acceptableNodeTypes"/>
            <xsl:text>, </xsl:text>
        </xsl:when>
    </xsl:choose>
</xsl:template>

<!-- from BuildSpecificationLanguageBindingJava.xslt -->

    <xsl:template name="escape-quotes-recurse">
        <xsl:param name="indent"><xsl:text></xsl:text></xsl:param>
        <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
        <xsl:variable name="inputString" select="string($inputValue)"/>
  <xsl:choose>
    <xsl:when test="not(contains($inputString,'&quot;'))">
      <xsl:value-of select="$inputString"/>
    </xsl:when>
    <!-- has quote, or has quote before \" -->
    <xsl:when test="not(contains($inputString,'\&quot;')) or (string-length(substring-before($inputString,'&quot;')) &lt; string-length(substring-before($inputString,'\&quot;')))">
      <xsl:value-of select="substring-before($inputString,'&quot;')"/>
      <xsl:text>\&quot;</xsl:text>
      <xsl:call-template name="escape-quotes-recurse">
        <xsl:with-param name="inputValue" select="substring-after($inputString,'&quot;')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="substring-before($inputString,'\&quot;')"/>
      <xsl:text>\&quot;</xsl:text>
      <xsl:call-template name="escape-quotes-recurse">
        <xsl:with-param name="inputValue" select="substring-after($inputString,'\&quot;')"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="append-f-to-float-values-recurse">
  <xsl:param name="indent"><xsl:text></xsl:text></xsl:param>
  <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
 <xsl:variable name="inputString" select="string($inputValue)"/>
  <xsl:choose>
    <xsl:when test="not(string-length(normalize-space($inputString)) > 0)">
      <!-- empty value -->
    </xsl:when>
      <!-- singleton value -->
    <xsl:when test="not(contains($inputString,' ')) and not(contains($inputString,','))">
      <xsl:value-of select="$inputString"/>
      <xsl:text>f</xsl:text>
    </xsl:when>
    <!-- space, or space precedes comma (if comma is present) -->
    <xsl:when test="contains($inputString,' ') and
                   (not(contains($inputString,',')) or
                       (string-length(substring-before($inputString,',')) > string-length(substring-before($inputString,' '))))">
     <xsl:value-of select="substring-before($inputString,' ')"/>
      <xsl:text>f,</xsl:text>
      <xsl:call-template name="append-f-to-float-values-recurse">
        <xsl:with-param name="inputValue" select="normalize-space(substring-after($inputString,' '))"/>
      </xsl:call-template>
    </xsl:when>
    <!-- comma precedes space -->
    <xsl:otherwise>
      <xsl:value-of select="substring-before($inputString,',')"/>
      <xsl:text>f,</xsl:text>
      <xsl:call-template name="append-f-to-float-values-recurse">
        <xsl:with-param name="inputValue" select="normalize-space(substring-after($inputString,','))"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="append-zero-to-double-values-recurse">
  <!-- boxing of generics requires that double values be in double form, e.g. 0.0 vice 0 -->
  <xsl:param name="indent"><xsl:text></xsl:text></xsl:param>
  <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
 <xsl:variable name="inputString" select="string($inputValue)"/>
  <xsl:choose>
    <xsl:when test="not(string-length(normalize-space($inputString)) > 0)">
      <!-- empty value -->
    </xsl:when>
      <!-- singleton value -->
    <xsl:when test="not(contains($inputString,' ')) and not(contains($inputString,','))">
      <xsl:value-of select="$inputString"/>
	  <xsl:if test="not(contains($inputString,'.'))">
		  <xsl:text>.0</xsl:text>
	  </xsl:if>
    </xsl:when>
    <!-- space, or space precedes comma (if comma is present) -->
    <xsl:when test="contains($inputString,' ') and
                   (not(contains($inputString,',')) or
                       (string-length(substring-before($inputString,',')) > string-length(substring-before($inputString,' '))))">
      <xsl:variable name="element">
		  <xsl:value-of select="substring-before($inputString,' ')"/>
	  </xsl:variable>
	  <xsl:value-of select="$element"/>
	  <xsl:if test="not(contains($element,'.'))">
		  <xsl:text>.0</xsl:text>
	  </xsl:if>
	  <xsl:text>,</xsl:text>
      <xsl:call-template name="append-zero-to-double-values-recurse">
        <xsl:with-param name="inputValue" select="normalize-space(substring-after($inputString,' '))"/>
      </xsl:call-template>
    </xsl:when>
    <!-- comma precedes space -->
    <xsl:otherwise>
      <xsl:variable name="element">
		  <xsl:value-of select="substring-before($inputString,',')"/>
	  </xsl:variable>
	  <xsl:value-of select="$element"/>
	  <xsl:if test="not(contains($element,'.'))">
		  <xsl:text>.0</xsl:text>
	  </xsl:if>
	  <xsl:text>,</xsl:text>
      <xsl:call-template name="append-zero-to-double-values-recurse">
        <xsl:with-param name="inputValue" select="normalize-space(substring-after($inputString,','))"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="insert-javadoc-line-breaks-recurse">
  <!-- boxing of generics requires that double values be in double form, e.g. 0.0 vice 0 -->
  <xsl:param name="breakText1"><xsl:text></xsl:text></xsl:param>
  <xsl:param name="breakText2"><xsl:text></xsl:text></xsl:param>
  <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
 <xsl:variable name="inputString" select="string($inputValue)"/>
  <xsl:choose>
    <xsl:when test="not(string-length(normalize-space($inputString)) > 0)">
      <!-- empty string -->
    </xsl:when>
    <xsl:when test="not(string-length(normalize-space($breakText1)) > 0)">
		<!-- no breakText1 to break on -->
		<xsl:value-of select="$inputString" disable-output-escaping="yes"/>
    </xsl:when>
    <xsl:when test="not(string-length(normalize-space($breakText2)) > 0)">
		<!-- no breakText2 to break on -->
		<xsl:value-of select="$inputString" disable-output-escaping="yes"/>
    </xsl:when>
    <xsl:when test="not(contains($inputString,$breakText1)) and not(contains($inputString,$breakText2))">
		<!-- no breakText found so all done -->
		<xsl:value-of select="$inputString" disable-output-escaping="yes"/>
    </xsl:when>
    <xsl:when test="starts-with(normalize-space($inputString),$breakText1)">
		<!-- starts with Hint: -->
		<!-- insert javadoc line break -->
		<xsl:text>&#10;</xsl:text>
		<xsl:text> * </xsl:text>
		<xsl:text disable-output-escaping="yes"> &lt;li&gt; </xsl:text>
		<!-- skip initial Hint: or Warning: and determine what is next -->
		<xsl:variable name="preambleHint"    select="normalize-space(substring-before(substring-after($inputString,$breakText1),'Hint:'))"/>
		<xsl:variable name="preambleWarning" select="normalize-space(substring-before(substring-after($inputString,$breakText1),'Warning:'))"/>
		<xsl:choose>
			<xsl:when test="(string-length($preambleHint) = 0) and (string-length($preambleWarning) = 0)">
				<!-- this is last substring, no preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="substring-before($inputString,':')" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes">:&lt;/i&gt; </xsl:text>
				<xsl:value-of select="substring-after($inputString,':')" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
			</xsl:when>
			<xsl:when test="(string-length($preambleHint) > 0) and
							 ((string-length($preambleWarning) = 0) or (string-length($preambleWarning) > string-length($preambleHint)))">
				<!-- Hint next follows this preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="$breakText1"/>
				<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$preambleHint" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
				<xsl:call-template name="insert-javadoc-line-breaks-recurse">
				  <xsl:with-param name="inputValue" select="normalize-space(substring-after($inputString,$preambleHint))"/>
				  <xsl:with-param name="breakText1"  select="$breakText1"/>
				  <xsl:with-param name="breakText2"  select="$breakText2"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<!-- Warning next follows this preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="$breakText1"/>
				<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$preambleWarning" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
				<xsl:call-template name="insert-javadoc-line-breaks-recurse">
				  <xsl:with-param name="inputValue" select="normalize-space(substring-after($inputString,$preambleWarning))"/>
				  <xsl:with-param name="breakText1"  select="$breakText1"/>
				  <xsl:with-param name="breakText2"  select="$breakText2"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
    </xsl:when>
	<xsl:otherwise>
		<!-- starts with [warning] -->
		<!-- insert javadoc line break -->
		<xsl:text>&#10;</xsl:text>
		<xsl:text> * </xsl:text>
		<xsl:text disable-output-escaping="yes"> &lt;li&gt; </xsl:text>
		<!-- skip initial Hint: or Warning: and determine what is next -->
		<xsl:variable name="preambleHint"    select="normalize-space(substring-before(substring-after($inputString,$breakText2),'Hint:'))"/>
		<xsl:variable name="preambleWarning" select="normalize-space(substring-before(substring-after($inputString,$breakText2),'Warning:'))"/>
		<xsl:choose>
			<xsl:when test="(string-length($preambleHint) = 0) and (string-length($preambleWarning) = 0)">
				<!-- this is last substring, no preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="substring-before($inputString,':')" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes">:&lt;/i&gt; </xsl:text>
				<xsl:value-of select="substring-after($inputString,':')" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
			</xsl:when>
			<xsl:when test="(string-length($preambleHint) > 0) and
					((string-length($preambleWarning) = 0) or (string-length($preambleWarning) > string-length($preambleHint)))">
				<!-- Hint next follows this preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="$breakText2"/>
				<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$preambleHint" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
				<xsl:call-template name="insert-javadoc-line-breaks-recurse">
				  <xsl:with-param name="inputValue" select="normalize-space(substring-after($inputString,$preambleHint))"/>
				  <xsl:with-param name="breakText1"   select="$breakText1"/>
				  <xsl:with-param name="breakText2"   select="$breakText2"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<!-- Warning next follows this preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="$breakText2"/>
				<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$preambleWarning" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
				<xsl:call-template name="insert-javadoc-line-breaks-recurse">
				  <xsl:with-param name="inputValue" select="normalize-space(substring-after($inputString,$preambleWarning))"/>
				  <xsl:with-param name="breakText1"   select="$breakText1"/>
				  <xsl:with-param name="breakText2"   select="$breakText2"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:otherwise>
  </xsl:choose>
</xsl:template>

    <xsl:template name="wrap-hyperlinks">
		<!-- further adapted from X3dTooltipConversions.xslt -->
        <!-- Search and replace urls in text:  adapted (with thanks) from
            https://www.dpawson.co.uk/xsl/rev2/regex2.html#d15961e67 by Jeni Tennison using url regex (https://[^ ]+) -->
        <!-- Justin Saunders https://regexlib.com/REDetails.aspx?regexp_id=37 url regex ((mailto:|(news|(ht|f)tp(s?))://){1}\S+) -->
        <xsl:param name="string" select="string(.)"/>
        <!-- wrap html text string with spaces to ensure no mismatches occur -->
        <xsl:variable name="spacedString">
            <xsl:text> </xsl:text>
            <xsl:value-of select="$string" disable-output-escaping="yes"/>
            <xsl:text> </xsl:text>
        </xsl:variable>
        <!-- debug diagnostic
        <xsl:if test="contains($spacedString,'http')">
            <xsl:message>
                <xsl:text>[warning] wrap-hyperlinks diagnostic: $spacedString=</xsl:text>
                <xsl:value-of select="normalize-space($spacedString)" disable-output-escaping="yes"/>
            </xsl:message>
        </xsl:if>
        -->
        <!-- First: find and link url values.  Avoid matching encompassing quote marks. -->
        <xsl:analyze-string select="$spacedString" regex='(")?(mailto:|((news|http|https|sftp)://)[a-zA-Z0-9._%+-/#()]+)(")?'>
            <xsl:matching-substring>
				<xsl:variable name="urlValue">
					<xsl:choose>
						<xsl:when test="starts-with(.,'&quot;') and ends-with(.,'&quot;')">
							<xsl:value-of select="substring(.,2,string-length(.)-2)" disable-output-escaping="no"/>
						</xsl:when>
						<xsl:when test="starts-with(.,'&quot;')">
							<xsl:value-of select="substring(.,2)" disable-output-escaping="no"/>
						</xsl:when>
						<xsl:when test="ends-with(.,'&quot;')">
							<xsl:value-of select="substring(.,1,string-length(.)-2)" disable-output-escaping="no"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="." disable-output-escaping="no"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
                <!-- diagnostic
					<xsl:message>
						<xsl:text>*** regex match success (</xsl:text>
						<xsl:value-of select="."/>
						<xsl:text>) (</xsl:text>
						<xsl:value-of select="$urlValue"/>
						<xsl:text>) </xsl:text>
					</xsl:message>
                -->
				<!-- originally no <br> inserted in javadoc since encompassing quotes didn't break across lines evenly
				<xsl:text disable-output-escaping="no"> &lt;br&gt; </xsl:text> -->
				<xsl:if test="starts-with(.,'&quot;')">
					<xsl:text>&quot;</xsl:text>
				</xsl:if>
				<xsl:text disable-output-escaping="no">&lt;a href="</xsl:text>
				<xsl:value-of select="$urlValue"/>
				<xsl:if test="(contains(.,'youtube.com') or contains(.,'youtu.be')) and not(contains(.,'rel='))">
					<!-- prevent advertising other YouTube videos when complete -->
					<xsl:text disable-output-escaping="yes">&amp;rel=0</xsl:text>
				</xsl:if>
				<xsl:text disable-output-escaping="no">" target="_blank"&gt;</xsl:text>
					<xsl:value-of select="$urlValue"/>
				<xsl:text disable-output-escaping="no">&lt;/a&gt;</xsl:text>
				<xsl:if test="ends-with(.,'&quot;')">
					<xsl:text>&quot;</xsl:text>
				</xsl:if>
				<!-- alternate form doesn't work because text is being produced, not elements
				<xsl:element name="a">
					<xsl:attribute name="href">
						<xsl:value-of select="."/>
					</xsl:attribute>
					<xsl:attribute name="target">
						<xsl:text>_blank</xsl:text>
					</xsl:attribute>
					<xsl:value-of select="."/>
				</xsl:element>
				-->
            </xsl:matching-substring>
            <xsl:non-matching-substring>
                <!-- diagnostic
                <xsl:if test="(string-length(normalize-space(.)) > 0)">
                    <xsl:message>
                        <xsl:text>**regex match failure (</xsl:text>
                        <xsl:copy-of select="."/>
                        <xsl:text>)**</xsl:text>
                    </xsl:message>
                </xsl:if>
                -->
                <!-- avoid returning excess whitespace -->
                <xsl:choose>
                    <xsl:when test="(string-length(.) > 0) and (string-length(normalize-space(.)) = 0)">
                        <xsl:text> </xsl:text>
                    </xsl:when>
                    <xsl:when test="string-length(normalize-space(.)) > 0">
						<!-- xsl:text> debug: escape-javadoc-characters4 </xsl:text -->
						<xsl:call-template name="escape-javadoc-characters">
							<xsl:with-param name="inputValue">
								<xsl:value-of select="." disable-output-escaping="yes"/>
							</xsl:with-param>
						</xsl:call-template>
                    </xsl:when>
                </xsl:choose>
            </xsl:non-matching-substring>
        </xsl:analyze-string>
    </xsl:template>

    <xsl:template name="escape-javadoc-characters">
        <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
        <xsl:variable name="inputString" select="string($inputValue)"/>
		<!-- don't escape apostrophes, that makes javadoc unhappy -->
		<xsl:call-template name="escape-greaterthan-characters">
			<xsl:with-param name="inputValue">
				<xsl:call-template name="escape-lessthan-characters">
					<xsl:with-param name="inputValue">
						<!-- do not escape-quote-characters!
						<xsl:call-template name="escape-quote-characters">
								<xsl:with-param name="inputValue">
								</xsl:with-param>
						</xsl:call-template>
						-->
                                            <xsl:call-template name="escape-tilde-characters">
                                                <xsl:with-param name="inputValue">
                                                        <!-- NOTE keep escape-ampersand-characters innermost so it doesn't get overzealous about escaped apostrophes or less-than characters -->
                                                        <xsl:call-template name="escape-ampersand-characters">
                                                                <xsl:with-param name="inputValue" select="$inputString"/>
                                                        </xsl:call-template>
                                                </xsl:with-param>
                                            </xsl:call-template>
					</xsl:with-param>
				</xsl:call-template>
			</xsl:with-param>
		</xsl:call-template>
    </xsl:template>

    <xsl:template name="escape-lessthan-characters">
        <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
        <xsl:variable name="inputString" select="string($inputValue)"/>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:message><xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/></xsl:message> -->
        <xsl:choose>
            <!-- &#60; is &lt; -->
            <xsl:when test="contains($inputString,'&#60;')">
				<xsl:value-of select="substring-before($inputString,'&#60;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="no">&amp;</xsl:text>
                <xsl:text disable-output-escaping="no">lt;</xsl:text>
                <xsl:call-template name="escape-lessthan-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'&#60;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="escape-greaterthan-characters">
        <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
        <xsl:variable name="inputString" select="string($inputValue)"/>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:message><xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/></xsl:message> -->
        <xsl:choose>
            <!-- &#62; is &gt; -->
            <xsl:when test="contains($inputString,'&#62;')">
                <xsl:value-of select="substring-before($inputString,'&#62;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="no">&amp;</xsl:text>
                <xsl:text disable-output-escaping="no">gt;</xsl:text>
                <xsl:call-template name="escape-greaterthan-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'&#62;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="escape-quote-characters">
        <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
        <xsl:variable name="inputString" select="string($inputValue)"/>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:message><xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/></xsl:message> -->
        <xsl:choose>
            <!-- &#62; is &gt; -->
            <xsl:when test="contains($inputString,'&#34;')">
                <xsl:value-of select="substring-before($inputString,'&#34;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="no">&amp;</xsl:text>
                <xsl:text disable-output-escaping="no">#34;</xsl:text>
                <xsl:call-template name="escape-quote-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'&#34;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="backslash-quote-characters">
        <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
        <xsl:variable name="inputString" select="string($inputValue)"/>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:message><xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/></xsl:message> -->
        <xsl:choose>
            <!-- &#62; is &gt; -->
            <xsl:when test="contains($inputString,'&#34;')">
                <xsl:value-of select="substring-before($inputString,'&#34;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="no">\"</xsl:text>
                <xsl:call-template name="backslash-quote-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'&#34;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="escape-backslash-characters">
        <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
        <xsl:variable name="inputString" select="string($inputValue)"/>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:message><xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/></xsl:message> -->
        <xsl:choose>
            <xsl:when test="contains($inputString,'\')">
                <xsl:value-of select="substring-before($inputString,'\')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="no">\\</xsl:text>
                <xsl:call-template name="escape-backslash-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'\')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>


    <xsl:template name="escape-tilde-characters">
        <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
        <xsl:variable name="inputString" select="string($inputValue)"/>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:message><xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/></xsl:message> -->
        <xsl:choose>
            <xsl:when test="contains($inputString,'~')">
                <xsl:value-of select="substring-before($inputString,'~')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="yes">&amp;</xsl:text>
                <xsl:text disable-output-escaping="no">#732;</xsl:text>
                <xsl:call-template name="escape-backslash-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'~')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="escape-ampersand-characters">
        <xsl:param name="inputValue"><xsl:text><!-- default value is empty --></xsl:text></xsl:param>
        <xsl:variable name="inputString" select="string($inputValue)"/>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/><xsl:text>&#10;</xsl:text> -->
        <xsl:choose>
            <!-- probably do not have to worry about solo cases with stray ampersands, because they are badly formed XML and will not parse:
                 and (starts-with(substring-after($inputString,'&amp;'),' ') or substring-after($inputString,''))-->
            <!-- first pass through escaped ampersand character, but only if other ampersand codes do not precede it -->
            <xsl:when test="contains($inputString,'&amp;amp;') and not(contains(substring-before($inputString,'&amp;amp;'),'&amp;'))">
                <xsl:value-of select="substring-before($inputString,'&amp;amp;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="yes">&amp;</xsl:text>
                <xsl:text disable-output-escaping="yes">amp;</xsl:text>
               <!-- <xsl:text disable-output-escaping="yes">amp;</xsl:text>-->
                <xsl:call-template name="escape-ampersand-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'&amp;amp;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="contains($inputString,'&amp;')">
                <xsl:value-of select="substring-before($inputString,'&amp;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="yes">&amp;</xsl:text>
                <xsl:text disable-output-escaping="yes">amp;</xsl:text>
                <xsl:call-template name="escape-ampersand-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'&amp;')"/>
                </xsl:call-template>
            </xsl:when>
			<!-- enable to support debugging
            <xsl:when test="true()">
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:when>
			-->
			<!-- buggy and no longer needed apparently
            <xsl:when test="contains($inputString,'&amp;#38;') and not(contains(substring-before($inputString,'&amp;#38;'),'&amp;'))">
                <xsl:value-of select="substring-before($inputString,'&amp;amp;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="yes">&amp;</xsl:text>
                <xsl:text disable-output-escaping="yes">#38;</xsl:text>
                <xsl:call-template name="escape-ampersand-characters">
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'&amp;amp;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="contains($inputString,'&amp;#') and not(contains(substring-before($inputString,'&amp;#'),'&amp;'))">
                <xsl:value-of select="substring-before($inputString,'&amp;#')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="yes">&amp;</xsl:text>
                <xsl:text disable-output-escaping="yes">amp;#</xsl:text>
                <xsl:call-template name="escape-ampersand-characters">
                    <xsl:with-param name="inputValue" select="substring-after($inputString,'&amp;#')"/>
                </xsl:call-template>
            </xsl:when> -->
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="bulletize-hints-warnings">
        <xsl:param name="tooltipText"><xsl:text></xsl:text><!-- default value is empty --></xsl:param>

		<xsl:variable name="containsHintWarning" select="contains($tooltipText,'Hint:') or contains($tooltipText,'Warning:')"/>
		<xsl:if test="(string-length($tooltipText) > 0)">
			<xsl:choose>
				<xsl:when test="$containsHintWarning">
					<xsl:variable name="preambleHint"    select="normalize-space(substring-before($tooltipText,'Hint:'))"/>
					<xsl:variable name="preambleWarning" select="normalize-space(substring-before($tooltipText,'Warning:'))"/>
					<xsl:choose>
						<xsl:when test="(string-length($preambleHint) > 0) and
								((string-length($preambleWarning) = 0) or (string-length($preambleWarning) > string-length($preambleHint)))">
							<xsl:value-of select="$preambleHint" disable-output-escaping="yes"/>
							<xsl:text>&#10;</xsl:text>
							<xsl:text> * </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;ul&gt;</xsl:text>
							<xsl:call-template name="insert-javadoc-line-breaks-recurse">
								<xsl:with-param name="inputValue">
									<xsl:value-of select="substring-after(normalize-space($tooltipText),$preambleHint)" disable-output-escaping="yes"/>
								</xsl:with-param>
								<xsl:with-param name="breakText1"><xsl:text>Hint:</xsl:text></xsl:with-param>
								<xsl:with-param name="breakText2"><xsl:text>Warning:</xsl:text></xsl:with-param>
							</xsl:call-template>
							<xsl:text>&#10;</xsl:text>
							<xsl:text> * </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;/ul&gt;</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$preambleWarning" disable-output-escaping="yes"/>
							<xsl:text>&#10;</xsl:text>
							<xsl:text> * </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;ul&gt;</xsl:text>
							<xsl:call-template name="insert-javadoc-line-breaks-recurse">
								<xsl:with-param name="inputValue">
									<xsl:value-of select="substring-after(normalize-space($tooltipText),$preambleWarning)" disable-output-escaping="yes"/>
								</xsl:with-param>
								<xsl:with-param name="breakText1"><xsl:text>Hint:</xsl:text></xsl:with-param>
								<xsl:with-param name="breakText2"><xsl:text>Warning:</xsl:text></xsl:with-param>
							</xsl:call-template>
							<xsl:text>&#10;</xsl:text>
							<xsl:text> * </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;/ul&gt;</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:otherwise>
					<!-- xsl:text> debug: escape-javadoc-characters5 </xsl:text -->
					<xsl:call-template name="escape-javadoc-characters">
						<xsl:with-param name="inputValue">
							<xsl:value-of select="$tooltipText" disable-output-escaping="yes"/>
						</xsl:with-param>
					</xsl:call-template>
				</xsl:otherwise>
			</xsl:choose>
			<!--
			<xsl:text>&#10;</xsl:text>
			<xsl:text> * </xsl:text>
			<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!- - line break - ->
			<xsl:text>&#10;</xsl:text>
			-->
			<xsl:if test="not($containsHintWarning)">
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
		</xsl:if>
    </xsl:template>

</xsl:stylesheet>
