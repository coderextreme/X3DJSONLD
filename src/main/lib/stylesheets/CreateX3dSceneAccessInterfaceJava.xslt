<?xml version="1.0" encoding="UTF-8"?>
<!--
    title       : CreateX3dSceneAccessInterfaceJava.xslt
    created     :  6 June 2016
    creator     : Don Brutzman
    description : Create open-source X3D Scene Access Interface (SAI) library in Java
    reference   : build.xml target BuildSceneAuthoringInterfacesJava.saxon
    reference   : AllX3dElementsAttributes.xml
    reference   : AllX3dElementsAttributesTextTemplate.xslt
    reference   : http://www.w3.org/TR/xslt
    identifier  : http://www.web3d.org/x3d/stylesheets/CreateX3dSceneAccessInterfaceJava.xslt
    history     : https://sourceforge.net/p/x3d/code/HEAD/tree/www.web3d.org/x3d/stylesheets/CreateX3dSceneAccessInterfaceJava.xslt
    license     : license.html
	
Additional references of interest:

1.	Array or List in Java. Which is faster?
	http://stackoverflow.com/questions/716597/array-or-list-in-java-which-is-faster
	"Answer: The common consensus is that the performance difference is minor. List interface provides more flexibility."

-->

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"
                xmlns:xs ="http://www.w3.org/2001/XMLSchema"
	            xmlns:fn ="http://www.w3.org/2005/xpath-functions"
				xmlns:saxon="http://saxon.sf.net/"><!-- http://www.saxonica.com/documentation9.5/extensions/attributes -->
	<!-- extension-element-prefixes="xs" -->
	<xsl:param name="targetDirectory"><xsl:text></xsl:text></xsl:param>
	
	<xsl:variable name="targetPath">
		<xsl:value-of select="$targetDirectory"/>
		<xsl:if test="(string-length($targetDirectory) > 0)">
			<xsl:text>/</xsl:text>
		</xsl:if>
	</xsl:variable>
	
	<xsl:output method="text" encoding="UTF-8" cdata-section-elements="javadocBlock interfaceBlock implementationBlock"/> <!-- output methods:  xml html text -->
    
	<xsl:variable name="debug"><xsl:text>false</xsl:text></xsl:variable>
	
	<xsl:variable name="saiPackage"               >           <xsl:text>org.web3d.x3d.sai</xsl:text></xsl:variable>
	<xsl:variable name="saiPackageDirectorySource">       <xsl:text>src/org/web3d/x3d/sai</xsl:text></xsl:variable>
	<xsl:variable name="saiPackageDirectoryBuild" >     <xsl:text>build/org/web3d/x3d/sai</xsl:text></xsl:variable>
	<!-- TODO restructure concrete hierarchy -->
	<xsl:variable name="concreteSubpackageName"   >                         <xsl:text>jsail</xsl:text></xsl:variable>
	<xsl:variable name="concretePackage"          >           <xsl:text>org.web3d.x3d.jsail</xsl:text></xsl:variable>
	<xsl:variable name="concretePackageDirectorySource">  <xsl:text>src/org/web3d/x3d/jsail</xsl:text></xsl:variable>
	<xsl:variable name="concretePackageDirectoryBuild" ><xsl:text>build/org/web3d/x3d/jsail</xsl:text></xsl:variable>
	<xsl:variable name="jsaiClassSuffix"    ><xsl:text>Object</xsl:text></xsl:variable>
	<xsl:variable name="jsaiInterfaceSuffix"><xsl:text>Interface</xsl:text></xsl:variable>

	<xsl:variable name="saiJavaSpecificationRootUrl"><xsl:text>http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2</xsl:text></xsl:variable>
	<xsl:variable name="saiAbstractSpecificationRootUrl"><xsl:text>http://www.web3d.org/documents/specifications/19775-2/V3.3/Part02</xsl:text></xsl:variable>
	<xsl:variable name="x3dAbstractSpecificationRootUrl"><xsl:text>http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01</xsl:text></xsl:variable>
	
	<xsl:variable name="newValue"><xsl:text>newValue</xsl:text></xsl:variable><!-- default parameter name -->
	<xsl:variable name="x3d.tooltips.path">
		<xsl:text>../tooltips/x3d-3.3.profile.xml</xsl:text>
	</xsl:variable>
	<xsl:variable name="x3d.tooltips.document" select="doc($x3d.tooltips.path)"/>
	
	<xsl:variable name="modifySpecificationInterfaces"><xsl:text>false</xsl:text></xsl:variable> 
	<!-- false: match original Java SAI design with many root-level classes and interfaces -->
	<!--  true: experimental, match good design practice by inserting relevant subpackages -->

    <!-- ======================================================= -->
    
    <xsl:template match="/"> <!-- process root of input document -->
	
		<!-- diagnostics
		<xsl:variable name="x3d.object.model.path">
			<xsl:text>../../specifications/X3DObjectModel-3.3.xml</xsl:text>
		</xsl:variable>
		<xsl:variable name="x3d.object.model.document" select="doc($x3d.object.model.path)"/>
		<xsl:message>
			<xsl:text>$x3d.object.model.document available: </xsl:text>
			<xsl:value-of select="doc-available(x3d.object.model.path)"/>
		</xsl:message> -->
	
		<!-- process fixed files -->
		<xsl:call-template name="FieldDefinitions"/>
		<xsl:call-template name="BaseTypeDefinitions"/>
		
		<xsl:call-template name="ServiceInterfaces"/>
		<xsl:call-template name="StatementInterfaces"/>
		<xsl:call-template name="ExceptionDefinitions"/>
		<xsl:call-template name="NodeTypeDefinitions"/>
		<xsl:call-template name="ObjectTypeDefinitions"/>
		<xsl:call-template name="NodeInterfacesDefinitions"/>
		
		<!-- instantiable Plain Old Java Object (POJO) classes -->
		<xsl:call-template name="ConcreteNodeObjectDefinitions"/>
        
        <!-- process elements and comments -->
        <xsl:apply-templates select="X3DObjectModel/* | comment()"/>
        
    </xsl:template>

    <!-- ===================================================== -->
    
    <xsl:template match="*"> <!-- rule to process each element -->
        
        <!-- common initial processing for each element -->
        <xsl:text disable-output-escaping="yes">&lt;</xsl:text>
        <xsl:value-of select="local-name()"/>
        
        <xsl:apply-templates select="@*"/> <!-- process attributes for this element -->
        
        <!-- <xsl:apply-templates select="*"/> no need to recurse on child elements -->
        
        <!-- common final processing for each element -->
        <xsl:text disable-output-escaping="yes">/&gt;</xsl:text><!-- end element -->
        <xsl:text>&#10;</xsl:text>
        
    </xsl:template>

    <!-- ===================================================== -->
    
    <xsl:template match="@*"> <!-- rule to process each attribute -->
        
        <!-- common processing for each attribute -->
        <xsl:text> </xsl:text>
        <xsl:value-of select="local-name()"/>
        <xsl:text>='</xsl:text>
        <xsl:value-of select="."/>
        <xsl:text>'</xsl:text>
        
    </xsl:template>

    <!-- ===================================================== -->
    
    <xsl:template match="comment()"> <!-- rule to process each comment -->
    
        <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
        <xsl:value-of select="."/>
        <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
        <xsl:text>&#10;</xsl:text>
        
    </xsl:template>

    <!-- ===================================================== -->
	
	<xsl:variable name="licenseBlock">
		<!-- inserted in each autogenerated source file -->
		<xsl:text>/*</xsl:text><xsl:text>&#10;</xsl:text>
			<xsl:variable name="license.filename"><xsl:text>license.txt</xsl:text></xsl:variable>
			<xsl:value-of select="unparsed-text($license.filename)"/>
		<xsl:text>*/</xsl:text><xsl:text>&#10;</xsl:text>
		<xsl:text>&#10;</xsl:text>
	</xsl:variable>
    <!-- ===================================================== -->
    
    <xsl:template name="isX3dStatement">
		<xsl:param name="name"/>
		<!-- note that ROUTE, *Proto*, IMPORT/EXPORT and CommentsBlock are X3D Statements which are also allowed as X3DChildNode -->
		<xsl:value-of select="
			($name = 'connect') or ($name = 'field') or ($name = 'fieldValue') or ($name = 'IS') or ($name = 'ROUTE') or 
			($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare') or ($name = 'ProtoInstance') or ($name = 'ProtoInterface') or ($name = 'ProtoBody') or 
			($name = 'X3D') or ($name = 'head') or ($name = 'component') or ($name = 'meta') or ($name = 'unit') or ($name = 'Scene') or 
            ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'CommentsBlock')"/>
	</xsl:template>

	<!-- ===================================================== -->
    
    <xsl:template name="javaType">
		<xsl:param name="x3dType"/>
		<xsl:param name="isInterface"/>
		<xsl:variable name="baseType" select="//SimpleType[@name = $x3dType]/@baseType"/>
		
		<xsl:choose>
			<xsl:when test="( $x3dType = 'SFString') or ( $x3dType = 'xs:string') or ( $x3dType = 'xs:token') or
                            ($baseType = 'SFString') or ($baseType = 'xs:string') or ($baseType = 'xs:token')">
				<xsl:text>String</xsl:text>
			</xsl:when>
			<xsl:when test="(($x3dType = 'MFString') or ($baseType = 'MFString')) and ($isInterface = 'true')">
				<xsl:text>String[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFString') or ($baseType = 'MFString')">
				<xsl:text disable-output-escaping="yes">ArrayList&lt;String&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'SFBool') or ($baseType = 'SFBool')">
				<xsl:text>boolean</xsl:text>
			</xsl:when>
			<xsl:when test="(($x3dType = 'MFBool') or ($baseType = 'MFBool')) and ($isInterface = 'true')">
				<xsl:text>boolean[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFBool') or ($baseType = 'MFBool')">
				<xsl:text disable-output-escaping="yes">ArrayList&lt;Boolean&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'SFInt32') or ($baseType = 'SFInt32')">
				<xsl:text>int</xsl:text>
			</xsl:when>
			<xsl:when test="(( $x3dType = 'MFInt32') or  ($x3dType = 'SFImage') or  ($x3dType = 'MFImage') or
                             ($baseType = 'MFInt32') or ($baseType = 'SFImage') or ($baseType = 'MFImage')) and ($isInterface = 'true')">
				<xsl:text>int[]</xsl:text>
			</xsl:when>
			<xsl:when test="( $x3dType = 'MFInt32') or  ($x3dType = 'SFImage') or  ($x3dType = 'MFImage') or
                            ($baseType = 'MFInt32') or ($baseType = 'SFImage') or ($baseType = 'MFImage')">
				<xsl:text>ArrayList&lt;Integer&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'SFFloat') or ($baseType = 'SFFloat')">
				<xsl:text>float</xsl:text>
			</xsl:when>
			<xsl:when test="(($x3dType = 'MFFloat') or ($baseType = 'MFFloat')) and ($isInterface = 'true')">
				<xsl:text>float[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFFloat') or ($baseType = 'MFFloat')">
				<xsl:text disable-output-escaping="yes">ArrayList&lt;Float&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="contains( $x3dType,'FVec2f') or contains( $x3dType,'FVec3f') or (@baseType='boundingBoxSizeType') or contains( $x3dType,'FVec4f') or contains( $x3dType,'FRotation') or contains( $x3dType,'FColor') or
                            contains($baseType,'FVec2f') or contains($baseType,'FVec3f') or ($baseType='boundingBoxSizeType') or contains($baseType,'FVec4f') or contains($baseType,'FRotation') or contains($baseType,'FColor')">
				<xsl:text>float[]</xsl:text>
			</xsl:when>
			<xsl:when test="( $x3dType = 'SFMatrix3f') or ( $x3dType = 'MFMatrix3f') or ( $x3dType = 'SFMatrix4f') or ($ x3dType = 'MFMatrix4f') or
                            ($baseType = 'SFMatrix3f') or ($baseType = 'MFMatrix3f') or ($baseType = 'SFMatrix4f') or ($baseType = 'MFMatrix4f')">
				<xsl:text>float[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'SFDouble') or ($x3dType = 'SFTime') or ($baseType = 'SFDouble') or ($baseType = 'SFTime')">
				<xsl:text>double</xsl:text>
			</xsl:when>
			<xsl:when test="(($x3dType = 'MFDouble') or ($x3dType = 'MFTime') or ($baseType = 'MFDouble') or ($baseType = 'MFTime')) and ($isInterface = 'true')">
				<xsl:text>double[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFDouble') or ($x3dType = 'MFTime') or ($baseType = 'MFDouble') or ($baseType = 'MFTime')">
				<xsl:text disable-output-escaping="yes">ArrayList&lt;Double&gt;</xsl:text>
			</xsl:when>
			<xsl:when test="contains( $x3dType,'FVec2d') or contains( $x3dType,'FVec3d') or contains( $x3dType,'FVec4d') or
                            contains($baseType,'FVec2d') or contains($baseType,'FVec3d') or contains($baseType,'FVec4d')">
				<xsl:text>double[]</xsl:text>
			</xsl:when>
			<xsl:when test="( $x3dType = 'SFMatrix3d') or ( $x3dType = 'MFMatrix3d') or ( $x3dType = 'SFMatrix4d') or ( $x3dType = 'MFMatrix4d') or
                            ($baseType = 'SFMatrix3d') or ($baseType = 'MFMatrix3d') or ($baseType = 'SFMatrix4d') or ($baseType = 'MFMatrix4d')">
				<xsl:text>double[]</xsl:text>
			</xsl:when>
			<!-- X3D Java Specification interface definitions are completely ambiguous, there is no benefit to 
                 including unnecessarily loose node typing accessors for a single node.  Omitted this general/harmful case.
			<xsl:when test="($x3dType = 'SFNode') and ($isInterface = 'true')">
				<xsl:text>X3DNode</xsl:text>
			</xsl:when> -->
			<xsl:when test="($x3dType = 'SFNode')">
				<xsl:choose>
					<xsl:when test="(string-length(@acceptableNodeTypes) > 0) and not(contains(@acceptableNodeTypes,'|'))">
						<!-- not always singular, example CADFace shape field (Shape|LOD|Transform) -->
						<xsl:value-of select="@acceptableNodeTypes"/>
						<xsl:variable name="isX3dStatement">
							<xsl:call-template name="isX3dStatement">
								<xsl:with-param name="name" select="@name"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:if test="($isX3dStatement = 'true')">
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
						</xsl:if>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>X3DNode</xsl:text><!-- TODO more precise node-type checks -->
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFNode') and ($isInterface = 'true')">
				<xsl:text>X3DNode[]</xsl:text>
			</xsl:when>
			<xsl:when test="($x3dType = 'MFNode')">
				<xsl:choose>
					<xsl:when test="(string-length(@acceptableNodeTypes) > 0) and not(contains(@acceptableNodeTypes,'|'))">
						<!-- not always singular, example CADFace shape field (Shape|LOD|Transform) -->
						<xsl:text disable-output-escaping="yes">ArrayList&lt;</xsl:text><!-- ArrayList<> -->
						<xsl:value-of select="@acceptableNodeTypes"/>
						<xsl:variable name="isX3dStatement">
							<xsl:call-template name="isX3dStatement">
								<xsl:with-param name="name" select="@name"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:if test="($isX3dStatement = 'true')">
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
						</xsl:if>
						<!--
						<xsl:if test="not($isInterface = 'true') and not($isX3dStatement = 'true')">
							<xsl:value-of select="$jsaiInterfaceSuffix"/>
						</xsl:if>
						--><!-- append to type name -->
						<xsl:text disable-output-escaping="yes">&gt;</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text disable-output-escaping="yes">ArrayList&lt;X3DNode&gt;</xsl:text><!-- TODO more precise node-type checks -->
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(string-length($x3dType) = 0)">
				<xsl:text> (error: Java type not provided) </xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text> (error: Java type not found for </xsl:text>
				<xsl:value-of select="$x3dType"/>
				<xsl:text>) </xsl:text>
			</xsl:otherwise>
		</xsl:choose>
    </xsl:template>

    <!-- ===================================================== -->
    
    <xsl:template name="javaValue">
		<xsl:param name="x3dType"/>
		<xsl:param name="schemaValue"/>
		<xsl:param name="javadoc"><xsl:text>false</xsl:text></xsl:param>
				
		<xsl:variable name="xmlValue">
			<xsl:choose>
				<xsl:when test="($schemaValue='[]')">
				</xsl:when>
				<xsl:when test="starts-with($schemaValue,'[') and ends-with($schemaValue,']')">
					<xsl:value-of select="substring($schemaValue,2,(string-length($schemaValue)-2))"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$schemaValue"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:choose>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFString')">
				<xsl:text>"</xsl:text>
				<!-- enumeration value: escape each quote character as \" -->
				<xsl:call-template name="escape-quotes-recurse">
					<xsl:with-param name="inputString" select="$xmlValue"/>
				</xsl:call-template>
				<xsl:text>"</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'EscapeQuotedSFString')">
				<xsl:text>"</xsl:text>
				<!-- enumeration value: escape each quote character as \" -->
				<xsl:call-template name="escape-quotes-recurse">
					<xsl:with-param name="inputString" select="concat('&quot;',$xmlValue,'&quot;')"/>
				</xsl:call-template>
				<xsl:text>"</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'MFString')">
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text disable-output-escaping="yes">new ArrayList&lt;String&gt;(Arrays.&lt;String&gt;asList(</xsl:text><!-- ArrayList<> -->
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>new String[] {</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<!-- avoid empty string when actual value is empty list -->
				<xsl:if test="(string-length(normalize-space($xmlValue)) > 0)">
					<!-- each enumeration value is quoted string, comma-separated -->
					<xsl:value-of select="translate($xmlValue,' ',',')"/>
				</xsl:if>
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text>))</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>}</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFBool')">
				<xsl:value-of select="$xmlValue"/>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'MFBool') or ($x3dType = 'MFInt32') or ($x3dType = 'SFImage') or ($x3dType = 'MFImage')">
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;(Arrays.asList(</xsl:text><!-- ArrayList<> -->
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>{</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:value-of select="translate($xmlValue,' ',',')"/>
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text>))</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>}</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFInt32')">
				<xsl:value-of select="$xmlValue"/>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFFloat')">
				<!-- Java float constants have 'f' appended, e.g. 1.0f -->
				<xsl:call-template name="append-f-to-float-values-recurse">
					<xsl:with-param name="inputString" select="normalize-space($xmlValue)"/>
				</xsl:call-template>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFDouble') or ($x3dType = 'SFTime')">
				<xsl:value-of select="$xmlValue"/>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'MFFloat') or ($x3dType = 'MFDouble') or ($x3dType = 'MFTime')">
				<!-- Java float constants have 'f' appended, e.g. 1.0f -->
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;(Arrays.asList(</xsl:text><!-- ArrayList<> -->
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>{</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:choose>
					<xsl:when test="($x3dType = 'MFFloat')">
						<xsl:call-template name="append-f-to-float-values-recurse">
							<xsl:with-param name="inputString" select="normalize-space($xmlValue)"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="append-zero-to-double-values-recurse">
							<xsl:with-param name="inputString" select="normalize-space($xmlValue)"/>
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:choose>
					<xsl:when test="($javadoc='false')">
						<xsl:text>))</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>}</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			 <!-- ========================================
			<xsl:when test="($x3dType = 'MFDouble') or ($x3dType = 'MFTime')">
				<xsl:text>{</xsl:text>
				<xsl:value-of select="translate($xmlValue,' ',',')"/>
				<xsl:text>}</xsl:text>
			</xsl:when> -->
			 <!-- ======================================== -->
			<xsl:when test="contains($x3dType,'FVec2f') or contains($x3dType,'FVec3f') or contains($x3dType,'FVec4f') or contains($x3dType,'FRotation') or contains($x3dType,'FColor')">
				<xsl:text>{</xsl:text>
				<!-- Java float constants have 'f' appended, e.g. 1.0f -->
				<xsl:call-template name="append-f-to-float-values-recurse">
					<xsl:with-param name="inputString" select="normalize-space($xmlValue)"/>
				</xsl:call-template>
				<xsl:text>}</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFMatrix3f') or ($x3dType = 'MFMatrix3f') or ($x3dType = 'SFMatrix4f') or ($x3dType = 'MFMatrix4f')">
				<xsl:text>{</xsl:text>
				<!-- Java float constants have 'f' appended, e.g. 1.0f -->
				<xsl:call-template name="append-f-to-float-values-recurse">
					<xsl:with-param name="inputString" select="normalize-space($xmlValue)"/>
				</xsl:call-template>
				<xsl:text>}</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="contains($x3dType,'FVec2d') or contains($x3dType,'FVec3d') or contains($x3dType,'FVec4d')">
				<xsl:text>{</xsl:text>
				<xsl:value-of select="translate($xmlValue,' ',',')"/>
				<xsl:text>}</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:when test="($x3dType = 'SFMatrix3d') or ($x3dType = 'MFMatrix3d') or ($x3dType = 'SFMatrix4d') or ($x3dType = 'MFMatrix4d')">
				<xsl:text>{</xsl:text>
				<xsl:value-of select="translate($xmlValue,' ',',')"/>
				<xsl:text>}</xsl:text>
			</xsl:when>
			 <!-- ======================================== -->
			<xsl:otherwise>
				<!-- default: treat as simple String -->
				<xsl:text>"</xsl:text>
				<xsl:value-of select="$xmlValue"/>
				<xsl:text>"</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
    </xsl:template>

    <!-- ===================================================== -->
    
    <xsl:template name="tupleSize">
		<xsl:param name="x3dType"/>
		
		<xsl:choose>
			<xsl:when test="contains($x3dType,'FBool')   or contains($x3dType,'FInt32')  or contains($x3dType,'FFloat') or 
                            contains($x3dType,'FDouble') or contains($x3dType,'FString') or contains($x3dType,'FTime') or 
                            contains($x3dType,'FNode')">
				<xsl:text>1</xsl:text>
			</xsl:when>
			<xsl:when test="contains($x3dType,'FVec2')">
				<xsl:text>2</xsl:text>
			</xsl:when>
			<xsl:when test="contains($x3dType,'FVec3') or ends-with($x3dType,'FColor') or (@baseType='boundingBoxSizeType')">
				<xsl:text>3</xsl:text>
			</xsl:when>
			<xsl:when test="contains($x3dType,'FVec4') or contains($x3dType,'Rotation') or ends-with($x3dType,'FColorRGBA')">
				<xsl:text>4</xsl:text>
			</xsl:when>
			<xsl:when test="contains($x3dType,'FMatrix3')">
				<xsl:text>9</xsl:text>
			</xsl:when>
			<xsl:when test="contains($x3dType,'FMatrix4')">
				<xsl:text>16</xsl:text>
			</xsl:when>
			<xsl:when test="contains($x3dType,'FImage')">
				<!-- irregular tuple size, ignore -->
				<xsl:text>1</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<!-- report problem -->
				<xsl:message>
					<xsl:text>*** tupleSize not computed for type=</xsl:text>
					<xsl:value-of select="$x3dType"/>
				</xsl:message>
				<xsl:text>0</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
				
    </xsl:template>

    <!-- ===================================================== -->
	
	<!-- template to create file containing interface or class source -->
	<xsl:template name="generateSourceFile">
		<xsl:param name="name"><xsl:text>..missing name..</xsl:text></xsl:param>
		<xsl:param name="imports"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="inConcretePackage"><xsl:text>false</xsl:text></xsl:param>
		<xsl:param name="visibility"><xsl:text>public</xsl:text></xsl:param>
		<xsl:param name="isAbstract"><xsl:text>false</xsl:text></xsl:param>
		<xsl:param name="isInterface"><xsl:text>false</xsl:text></xsl:param>
		<xsl:param name="isUtilityClass"><xsl:text>false</xsl:text></xsl:param>
		<xsl:param name="extends"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="implements"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="subPackage"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="description"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:param>
		<xsl:param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:param>
		<!-- How to Write Doc Comments for the Javadoc Tool http://www.oracle.com/technetwork/articles/java/index-137868.html -->
		<xsl:param name=       "javadocBlock"/> <!-- typically has additional javadoc for each member -->
		<xsl:param name=     "interfaceBlock"/> <!-- top-level insertion for interface signatures -->
		<xsl:param name="implementationBlock"/> <!-- top-level insertion for class implementations -->
			
		<!-- Determine if current source is an Exception, Field or service type defined by X3D SAI specification -->
		<xsl:variable   name="isException"
					  select="starts-with($saiJavaSpecificationSection,'B.7') or ends-with($name,'Exception')"/>
		<xsl:variable   name="isFieldInterface"   
					  select="starts-with($saiJavaSpecificationSection,'B.4')"/>
		<xsl:variable   name="isServiceInterface"
					  select="starts-with($saiJavaSpecificationSection,'B.5')"/>
		<xsl:variable   name="hasField"
					  select="(count(//InterfaceDefinition/field) > 0)"/>
		<xsl:variable   name="hasJavadocBlock"
					  select="(string-length(normalize-space($javadocBlock)) > 0)"/>
		<xsl:variable   name="hasInterfaceBlock"
					  select="(string-length(normalize-space($interfaceBlock)) > 0)"/>
		<xsl:variable   name="hasImplementationBlock"
					  select="(string-length(normalize-space($implementationBlock)) > 0)"/>
		<xsl:variable name="baseType" select="//ConcreteNode[@name=$name]/InterfaceDefinition/Inheritance/@baseType"/>
		<xsl:variable name="additionalInheritanceBaseType" select="//ConcreteNode[@name=$name]/InterfaceDefinition/AdditionalInheritance/@baseType"/>
		
		<!-- Determine if current source uses an Exception, Field or service type defined by X3D SAI specification -->
		<!-- B.4 Field interfaces -->
		<xsl:variable   name="hasFieldInterface"   
					  select="(   ($isInterface = 'true') and
							   (contains($interfaceBlock,'SF')     or
								contains($interfaceBlock,'MF')     or
								contains($interfaceBlock,'Matrix'))) or
							  (not($isInterface = 'true') and
							   (contains($implementationBlock,'SF')     or
								contains($implementationBlock,'MF')     or
								contains($implementationBlock,'Matrix'))) or
							  InterfaceDefinition/field[starts-with(@type,'SF')] or
							  InterfaceDefinition/field[starts-with(@type,'MF')] or
							  InterfaceDefinition/field[contains(@type,'Matrix')]"/>
		<!-- B.5 Service interfaces -->
		<xsl:variable   name="hasServiceInterface" 
					  select="(   ($isInterface = 'true') and
							   (contains($interfaceBlock,'BrowserEvent')    or
								contains($interfaceBlock,'BrowserFactory')  or
								contains($interfaceBlock,'X3DComponent')    or
								contains($interfaceBlock,'ExternalBrowser') or
								contains($interfaceBlock,'BrowserListener'))) or
							  (not($isInterface = 'true') and
							   (contains($implementationBlock,'BrowserEvent')    or
								contains($implementationBlock,'BrowserFactory')  or
								contains($implementationBlock,'X3DComponent')    or
								contains($implementationBlock,'ExternalBrowser') or
								contains($implementationBlock,'BrowserListener'))) or
							  InterfaceDefinition/field[starts-with(@type,'BrowserEvent')]    or
							  InterfaceDefinition/field[starts-with(@type,'BrowserFactory')]  or
							  InterfaceDefinition/field[starts-with(@type,'X3DComponent')]    or
							  InterfaceDefinition/field[starts-with(@type,'ExternalBrowser')] or
							  InterfaceDefinition/field[starts-with(@type,'BrowserListener')]"/>
		<!-- B.7 Exception definitions -->
		<xsl:variable   name="hasException"
					  select="(contains($interfaceBlock,'Exception') or contains($implementationBlock,'Exception'))"/>
		
		<xsl:variable name="thisClassName">
			<xsl:value-of select="$name"/>
			<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
						  not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not(starts-with($name,'X3DConcrete'))">
				<xsl:value-of select="$jsaiClassSuffix"/>
			</xsl:if>
		</xsl:variable>
		<xsl:variable name="sourceFilePath">
			<xsl:choose>
				<xsl:when test="($inConcretePackage = 'true')">
					<xsl:value-of select="$concretePackageDirectorySource"/>
				</xsl:when>
				<xsl:when test="($isInterface = 'true') or ($isException or $isServiceInterface) or ($name = 'X3DFieldEvent')">
					<xsl:value-of select="$saiPackageDirectorySource"/>
				</xsl:when>
				<xsl:otherwise><!-- concretes -->
					<xsl:value-of select="$concretePackageDirectorySource"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="not($isInterface = 'true') and ($isFieldInterface) and not($name = 'X3DFieldEvent')">
					<xsl:text>/</xsl:text>
					<xsl:text>fields</xsl:text>
				</xsl:when>
				<xsl:when test="(string-length($subPackage) > 0)">
					<xsl:text>/</xsl:text>
					<xsl:value-of select="translate($subPackage,'-','')"/><!-- no componentName hypens allowed (e.g. H-Anim) -->
				</xsl:when>
			</xsl:choose>
			<xsl:text>/</xsl:text>
			<xsl:value-of select="$thisClassName"/>
			<xsl:text>.java</xsl:text>
		</xsl:variable>
		<xsl:variable name="canThrowFieldValueException"
                    select="(string-length(@minExclusive) > 0) or (string-length(@maxExclusive) > 0) or
                            (string-length(@minInclusive) > 0) or (string-length(@maxInclusive) > 0)"/>
		
		<xsl:variable name="isClassX3dStatement">
			<xsl:call-template name="isX3dStatement">
				<xsl:with-param name="name" select="$name"/>
			</xsl:call-template>
		</xsl:variable>
		
		<xsl:variable name="hasChildrenField" select="string((count(InterfaceDefinition/field[@name = 'children']) > 0)
														and not($name = 'CADPart'))"/>
			<!-- note that GeoLOD has outputOnly children field -->
<!-- debug 
<xsl:message>
	<xsl:text>*** outputFile/$name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text>, $hasChildrenField=</xsl:text>
	<xsl:value-of select="$hasChildrenField"/>
	<xsl:text>, $isInterface=</xsl:text>EXTERNALPROTOTYPE
	<xsl:value-of select="$isInterface"/>
</xsl:message>
-->	
		<!-- create source file -->
		<xsl:result-document href="{$targetPath}{$sourceFilePath}" method="text" omit-xml-declaration="yes" encoding="UTF-8" indent="no"
			saxon:line-length="180"> 
			<!-- http://www.saxonica.com/documentation9.5/extensions/output-extras/line-length.html -->
			<!-- method="html" escapes inserted tooltips -->
			
			<xsl:value-of select="$licenseBlock"/>
			
			<xsl:text>package </xsl:text>
			<xsl:choose>
				<xsl:when test="($inConcretePackage = 'true')">
					<xsl:value-of select="$concretePackage"/>
				</xsl:when>
				<xsl:when test="($isInterface = 'true') or ($isException or $isServiceInterface) or ($name = 'X3DFieldEvent')">
					<xsl:value-of select="$saiPackage"/>
				</xsl:when>
				<xsl:otherwise><!-- concretes -->
					<xsl:value-of select="$concretePackage"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="string-length($subPackage) > 0">
				<xsl:text>.</xsl:text>
				<xsl:value-of select="translate($subPackage,'/-','.')"/><!-- trailing slash to dot., no componentName hypens allowed (e.g. H-Anim) -->
			</xsl:if>
			<xsl:text>;</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>&#10;</xsl:text>
			
			<xsl:if test="string-length(normalize-space($imports)) > 0">
				<xsl:value-of select="$imports" disable-output-escaping="yes"/> <!-- top-level insertion for class or interface -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<!-- imports for built-in types -->
			<xsl:if test="(not($isInterface = 'true') or //field[@type='MFNode']) and not(starts-with($name,'SF')) and not(starts-with($name,'MF')) and 
							  not(starts-with($thisClassName, 'X3DConcrete')) and not($isUtilityClass = 'true')">
				<xsl:text>import java.util.*;</xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="true()"><!-- ($isInterface = 'true') -->
				<xsl:choose>
					<xsl:when test="($isUtilityClass = 'true')">
						<!-- no additional imports for utility class -->
					</xsl:when>
					<xsl:when test="($modifySpecificationInterfaces = 'true')">
						<xsl:if test="$hasFieldInterface">
							<xsl:text>import org.web3d.x3d.sai.fields.*;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:if>
						<xsl:if test="$hasException or $canThrowFieldValueException">
							<xsl:text>import org.web3d.x3d.sai.exceptions.*;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:if>
						<xsl:if test="$hasServiceInterface">
							<xsl:text>import org.web3d.x3d.sai.services.*;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:if>
					</xsl:when>
					<xsl:otherwise>
						<xsl:choose>
							<xsl:when test="contains($name,'FNode')">
								<xsl:text>import org.web3d.x3d.sai.Core.*;  // making sure #0</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:if test="($inConcretePackage = 'true')">
									<xsl:text>import org.web3d.x3d.jsail.*; // again making sure #1</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
							</xsl:when>
							<xsl:when test="(($hasFieldInterface or $hasException or $hasServiceInterface or $canThrowFieldValueException) and (string-length($subPackage) > 0))
											 and not(starts-with($name,'SF')) and not(starts-with($name,'MF'))">
								<!-- TODO stronger filtering many be needed to avoid superfluous declaration -->
								<xsl:text>import org.web3d.x3d.sai.*;  // making sure #2</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:if test="($inConcretePackage = 'true')">
									<xsl:text>import org.web3d.x3d.jsail.*; // again making sure #2</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
							</xsl:when>
						</xsl:choose>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:if test="not($isInterface = 'true') and not($isUtilityClass = 'true')">
					<xsl:if test="($name = 'X3D')">
						<!-- X3D imports -->
						<xsl:text>
// X3DObject imports ========================
// Base classes and SAX reader for EXIFICIENT
import com.siemens.ct.exi.CodingMode;
import com.siemens.ct.exi.EXIFactory;
import com.siemens.ct.exi.GrammarFactory;
import com.siemens.ct.exi.api.sax.EXIResult;
import com.siemens.ct.exi.api.sax.EXISource;
import com.siemens.ct.exi.exceptions.EXIException;
import com.siemens.ct.exi.grammars.Grammars;
import com.siemens.ct.exi.helpers.DefaultEXIFactory;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
							
/* Base classes and SAX reader for OPENEXI
import org.openexi.proc.common.AlignmentType;
import org.openexi.proc.common.EXIOptionsException;
import org.openexi.proc.common.GrammarOptions;
import org.openexi.proc.grammars.GrammarCache;
import org.openexi.sax.Transmogrifier;
import org.openexi.sax.TransmogrifierException;
import org.openexi.schema.EXISchema;
import org.openexi.scomp.EXISchemaFactory;
import org.openexi.scomp.EXISchemaFactoryException;
import org.openexi.scomp.EXISchemaReader;
import org.xml.sax.InputSource;
*/

// File operations
import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.*;
// XSLT operations: Saxon HE9
import net.sf.saxon.s9api.*;
// XSLT operations: Native Java
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.Result;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;
// XSLT operations
import org.w3c.dom.Document;
import org.xml.sax.SAXException;
// Script operations
import javax.script.ScriptEngineManager;
import javax.script.ScriptEngine;
import javax.script.ScriptException;
</xsl:text>
					</xsl:if>
					<xsl:if test="($name = 'Scene')">
						<!-- Scene imports -->
						<xsl:text>
import org.web3d.x3d.jsail.Layering.LayerSetObject; // special case, as are Metadata* nodes
</xsl:text>
					</xsl:if>
					<xsl:if test="($inConcretePackage = 'true') and not($thisClassName = 'X3DConcreteField') and not($thisClassName = 'CommentsBlock')">
						<xsl:text>
import java.util.Arrays;
import org.web3d.x3d.sai.Core.*;  // making sure #3
import org.web3d.x3d.jsail.*;
import org.web3d.x3d.jsail.Core.*;
</xsl:text>
						<xsl:text>&#10;</xsl:text>
					</xsl:if>
				</xsl:if>
				<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and 
							  not($thisClassName = 'CommentsBlock') and not(starts-with($thisClassName, 'X3DConcrete')) and 
							  not($isUtilityClass = 'true') and not($thisClassName = 'ConfigurationProperties')">
					<xsl:text>import org.web3d.x3d.jsail.fields.*; // making sure #4</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:choose>
						<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ShaderPart') or ($name = 'ProtoInterface')">
							<xsl:text>import org.web3d.x3d.jsail.Core.fieldObject;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						</xsl:when>
						<!--
						<xsl:when test="($name = 'ProtoInstance')">
							<xsl:text>import org.web3d.x3d.jsail.Core.fieldValueObject;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						</xsl:when>
						-->
					</xsl:choose>
				</xsl:if>
			
				<!-- generalized
				<xsl:variable   name="hasCoreComponentType"   
							  select="contains($interfaceBlock,'Metadata')             or contains($implementationBlock,'Metadata')             or
									  contains($interfaceBlock,'ProtoInstance')        or contains($implementationBlock,'ProtoInstance')        or
									  contains($interfaceBlock,'WorldInfo')            or contains($implementationBlock,'WorldInfo')            or
									  contains($interfaceBlock,'X3DBindableNode')      or contains($implementationBlock,'X3DBindableNode')      or
									  contains($interfaceBlock,'X3DChildNode')         or contains($implementationBlock,'X3DChildNode')         or
									  contains($interfaceBlock,'X3DInfoNode')          or contains($implementationBlock,'X3DInfoNode')          or
									  contains($interfaceBlock,'X3DNode')              or contains($implementationBlock,'X3DNode')              or
									  contains($interfaceBlock,'X3DPrototypeInstance') or contains($implementationBlock,'X3DPrototypeInstance') or
									  contains($interfaceBlock,'X3DSensorNode')        or contains($implementationBlock,'X3DSensorNode')        or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'Metadata')]  or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'ProtoInstance')]  or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'WorldInfo')]  or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DBindableNode')]      or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DChildNode')]         or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DInfoNode')]          or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DNode')]              or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DPrototypeInstance')] or
									  InterfaceDefinition/field[contains(@acceptableNodeTypes, 'X3DSensorNode')]"/>
				<xsl:if test="($hasCoreComponentType) and ($subPackage != 'Core')">
					<xsl:text>import org.web3d.x3d.sai.Core.*;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				-->

				<!-- loop over fields to find further imports -->
				<!-- TODO filter out duplicates -->
				<xsl:for-each select="InterfaceDefinition/field[not(starts-with(@name,'set'))][string-length(@acceptableNodeTypes) > 0]">

					<xsl:variable name="fieldName" select="@name"/><!-- avoid duplicates -->
					<xsl:if test="not(preceding-sibling::*[@name = $fieldName]) and not($isUtilityClass = 'true')">
						<xsl:variable name="acceptableNodeTypes"          select="@acceptableNodeTypes"/>
						<xsl:variable name="acceptableTypeComponent" select="//*[@name = $acceptableNodeTypes]/InterfaceDefinition/componentInfo/@name"/>
						<xsl:if test="(string-length($acceptableNodeTypes) > 0)">
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
	<xsl:text>*** $name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text>, field/@name=</xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:text>, $acceptableNodeTypes=</xsl:text>
	<xsl:value-of select="$acceptableNodeTypes"/>
	<xsl:text>, $acceptableTypeComponent=</xsl:text>
	<xsl:value-of select="$acceptableTypeComponent"/>
</xsl:message>
</xsl:if>
							<!-- TODO make this filter more restrictive to eliminate redundant imports, perhaps by using tokenize -->
							<xsl:if test="(string-length($acceptableTypeComponent) > 0) and
                                          (count(preceding-sibling::*[contains(//*[@name = @acceptableNodeTypes]//componentInfo/@name, $acceptableTypeComponent)]) = 0)">
								<xsl:choose>
									<xsl:when test="($isInterface = 'true') and not($inConcretePackage = 'true')">
										<xsl:text>import org.web3d.x3d.sai.</xsl:text>
										<xsl:if test="not($acceptableTypeComponent = 'fields') or ($modifySpecificationInterfaces = 'true')">
											<xsl:value-of select="translate($acceptableTypeComponent,'-','')"/>
											<xsl:text>.</xsl:text>
										</xsl:if>
										<xsl:text>*;</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:if test="ancestor::ConcreteNode">
											<xsl:text>import org.web3d.x3d.sai.</xsl:text>
											<xsl:value-of select="translate(ancestor::ConcreteNode/InterfaceDefinition/componentInfo/@name,'-','')"/>
											<xsl:text>.*; // interfaces for this component</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:if>
										<!-- brute force, can't reach up into X3D Object Model from within string tokenizer -->
										<xsl:if test="//field[contains(@acceptableNodeTypes,'|')][contains(@acceptableNodeTypes,'X3DGroupingNode')][1]">
											<xsl:text>import org.web3d.x3d.sai.Grouping.*;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:if>
										<xsl:if test="//field[contains(@acceptableNodeTypes,'|')][contains(@acceptableNodeTypes,'X3DShapeNode')][1]">
											<xsl:text>import org.web3d.x3d.sai.Shape.*;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:if>
										<xsl:if test="//field[contains(@acceptableNodeTypes,'|')][contains(@acceptableNodeTypes, 'Inline')][1]">
											<xsl:text>import org.web3d.x3d.sai.Networking.*;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:if>
										
										<xsl:text>import org.web3d.x3d.sai.</xsl:text>
										<xsl:value-of select="translate($acceptableTypeComponent,'-','')"/>
										<xsl:text>.*;</xsl:text>
										<xsl:text>
import org.web3d.x3d.jsail.*; // again making sure #4
</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>import org.web3d.x3d.jsail.</xsl:text>
										<xsl:value-of select="translate($acceptableTypeComponent,'-','')"/>
										<xsl:text>.*;</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:if>
						</xsl:if>
					</xsl:if>
				</xsl:for-each>
				
				<!-- special imports -->
				<xsl:if test="InterfaceDefinition/field[(@type = 'MFNode') and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')))]">
					<xsl:text>import java.util.Arrays;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:if test="not($isInterface = 'true')">
					<xsl:choose>
						<xsl:when test="($name = 'Extrusion')">
							<xsl:text>import java.io.File;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'IndexedFaceSet') or ($name = 'IndexedLineSet')">
							<xsl:text>import org.web3d.x3d.jsail.NURBS.CoordinateDoubleObject;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:when>
					</xsl:choose>
				</xsl:if>
				
				<!-- TODO incorrect?
				<xsl:if test="($name = 'ROUTE')">
					<xsl:text>import org.web3d.x3d.jsail.Scripting.*; // for ROUTEObject</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if> -->
			</xsl:if>
			
			<!-- no need to include current package in imports -->
			<!-- convention: avoid adding import calls for fully qualified class references -->
			<!-- TODO confirm handling of more than one comma-separated import -->
			<!--
			<xsl:if test="(string-length($extends) > 0) and contains($extends,'.')">
				<xsl:text>import </xsl:text>
				<xsl:value-of select="$extends"/>
				<xsl:text>;</xsl:text>
				<xsl:text>&#10;</xsl:text><xsl:text>&#10;</xsl:text>
			</xsl:if>
			-->
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
	<xsl:text>*** field/@name=</xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:text>, $description=</xsl:text>
	<xsl:value-of select="$description"/>
	<xsl:text>, $javadocBlock=</xsl:text>
	<xsl:value-of select="$javadocBlock"/>
</xsl:message>
</xsl:if>
			<!-- start class/interface description, javadoc -->
			<xsl:text>&#10;</xsl:text>
			<xsl:text>/**</xsl:text><xsl:text>&#10;</xsl:text>
			<xsl:choose>
				<xsl:when test="string-length(normalize-space($description)) > 0">
					<xsl:text> * </xsl:text><xsl:value-of select="normalize-space($description)"/>
					<xsl:text>&#10;</xsl:text>
					<xsl:text> * </xsl:text><xsl:text>&#10;</xsl:text>
					<xsl:text> * </xsl:text>
					<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
					<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
					<xsl:text>&#10;</xsl:text>
				</xsl:when>
				<xsl:when test="($isInterface = 'true') and not($inConcretePackage = 'true')">
					<xsl:text> * Abstract node interface, defined by X3D specification to support X3D Java interoperability.</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text> * </xsl:text><xsl:text>&#10;</xsl:text>
					<xsl:text> * </xsl:text>
					<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
					<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
					<xsl:text>&#10;</xsl:text>
				</xsl:when>
				<xsl:when test="($isException)">
					<!-- exception description is provided by each exception -->
				</xsl:when>
				<xsl:when test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface)">
					<!-- node description is provided by first sentence of tooltip -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:message>
						<xsl:text> *** </xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text> has no description...</xsl:text>
					</xsl:message>
				</xsl:otherwise>
			</xsl:choose>
			
			<xsl:variable name="isX3dStatement">
				<xsl:call-template name="isX3dStatement">
					<xsl:with-param name="name" select="@name"/>
				</xsl:call-template>
			</xsl:variable>
			
			<xsl:if test="doc-available($x3d.tooltips.path)">
				<xsl:variable name="tooltipText" select="replace(replace($x3d.tooltips.document//element[@name = $name]/@tooltip,'&#8734;','infinity'),'&#960;','pi')"/>
				
				<xsl:variable name="containsHintWarning" select="contains($tooltipText,'Hint:') or contains($tooltipText,'Warning:')"/>
				<xsl:if test="(string-length($tooltipText) > 0)">
					<xsl:text> * </xsl:text>
					<xsl:text disable-output-escaping="yes">&lt;i&gt;X3D </xsl:text>
					<xsl:choose>
						<xsl:when test="($isX3dStatement = 'true')">
							<xsl:text>statement</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text>node</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:text disable-output-escaping="yes"> tooltip&lt;/i&gt;: </xsl:text>
					
					<xsl:variable name="tooltipHTML">
								<!-- debug
								<xsl:if test="contains($tooltipText,'http')">
									<xsl:message>
										<xsl:text>*** found http: </xsl:text>
										<xsl:value-of select="$tooltipText" disable-output-escaping="yes"/>
									</xsl:message>
								</xsl:if>
							</xsl:with-param>
						</xsl:call-template>
								-->
						<xsl:call-template name="bulletize-hints-warnings">
							<xsl:with-param name="tooltipText">
								<xsl:call-template name="wrap-hyperlinks">
									<xsl:with-param name="string">
										<!-- xsl:text> escape-javadoc-characters5 </xsl:text -->
										<xsl:call-template name="escape-javadoc-characters">
											<xsl:with-param name="inputString">
												<xsl:value-of select="$tooltipText" disable-output-escaping="yes"/>
											</xsl:with-param>
										</xsl:call-template>
									</xsl:with-param>
								</xsl:call-template>
							</xsl:with-param>
						</xsl:call-template>
					</xsl:variable>
					<!-- debug diagnostic
					<xsl:if test="contains($tooltipHTML,'http')">
						<xsl:message>
							<xsl:text>  * found http, wrapped: </xsl:text>
							<xsl:value-of select="$tooltipHTML" disable-output-escaping="yes"/>
						</xsl:message>
					</xsl:if>
					-->
					<xsl:value-of select="$tooltipHTML" disable-output-escaping="yes"/>
					<xsl:if test="not($containsHintWarning)">
						<xsl:text> * </xsl:text>
						<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
						<xsl:text>&#10;</xsl:text>
					</xsl:if>				
				</xsl:if>
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
	<xsl:text>*** $name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text>, $x3d.tooltips.path=</xsl:text>
	<xsl:value-of select="$x3d.tooltips.path"/>
	<xsl:text>, doc-available($x3d.tooltips.path)=</xsl:text>
	<xsl:value-of select="doc-available($x3d.tooltips.path)"/>
	<xsl:text>, $tooltipText=</xsl:text>
	<xsl:value-of select="$tooltipText" disable-output-escaping="no"/>
	<!--
	<xsl:text>&#10;</xsl:text>
	<xsl:text>  $tooltipTextWithHyperlinks=</xsl:text>
	<xsl:copy-of select="$tooltipTextWithHyperlinks"/>
	-->
</xsl:message>
</xsl:if>
			</xsl:if> <!-- end tooltip -->
			
			<xsl:if test="not($isInterface = 'true') and
						  (   contains($name, 'FColor')            or contains($name, 'Background')           or 
						   starts-with($name, 'ColorChaser')       or starts-with($name, 'ColorDamper')       or contains($name, 'Light')      or 
						   starts-with($name, 'ColorInterpolator') or starts-with($name, 'ParticleSystem')    or 
						   ($name = 'Fog') or ($name = 'LocalFog') or
						   starts-with($name, 'TextureProperties') or contains($name, 'Material')   or
						   starts-with($name, 'FillProperties')    or starts-with($name, 'LineProperties')    or starts-with($name, 'MultiTexture') or
						   starts-with($name, 'EdgeEnhancementVolumeStyle') or starts-with($name, 'CartoonVolumeStyle') or
						   starts-with($name, 'OpacityMapVolumeStyle')      or starts-with($name, 'ToneMappedVolumeStyle'))">
				
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * Note that {@linkplain SFColor</xsl:text>
				<xsl:value-of select="$jsaiClassSuffix"/>
				<xsl:text>#ALICEBLUE SFColor</xsl:text><xsl:value-of select="$jsaiClassSuffix"/>
				<xsl:text>} provides a variety of color constants.</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			
			<xsl:if test="($name = 'meta')">
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes"> Metadata terms for consistent referencing:</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;ul&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; Dublin Core Metadata Initiative (DCMI): &lt;a href="http://www.dublincore.org/documents/dcmi-terms" target="_blank"&gt;Terms&lt;/a&gt; and </xsl:text>
				<xsl:text disable-output-escaping="yes"> &lt;a href="http://www.dublincore.org/documents/dces" target="_blank"&gt;Element Set&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; HTML5 section 4.2.5: &lt;a href="https://www.w3.org/TR/html5/document-metadata.html#the-meta-element" target="_blank"&gt;The meta element&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; HTML4 section 7.4.4: &lt;a href="http://www.w3.org/TR/html4/struct/global.html#h-7.4.4" target="_blank"&gt;Meta data&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; &lt;a href="http://vancouver-webpages.com/META" target="_blank"&gt;Dictionary of HTML META Tags&lt;/a&gt; </xsl:text>
				<xsl:text disable-output-escaping="yes">   (&lt;a href="http://vancouver-webpages.com/META/about-mk-metas2.html" target="_blank"&gt;About&lt;/a&gt;) &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;/ul&gt;&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes"> Metadata terms for language codes:</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;ul&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; IETF Best Current Practice (BCP) 47: &lt;a href="https://tools.ietf.org/html/bcp47" target="_blank"&gt;Tags for Identifying Languages&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; ISO 639-2: &lt;a href="http://www.loc.gov/standards/iso639-2/langhome.html" target="_blank"&gt;Codes for the Representation of Names of Languages&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; Internet Assigned Numbers Authority (IANA) Protocol Registries: &lt;a href="http://www.iana.org/protocols#index_L" target="_blank"&gt;Language Tags&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;/ul&gt;&#10;</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			
			<xsl:if test="($name = 'unit')">
				<xsl:text>&#10;</xsl:text>`
				<xsl:text disable-output-escaping="yes"> * &lt;a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/concepts.html#Standardunitscoordinates" target="_blank"&gt;X3D specification: 4.3.6 Standard units and coordinate system&lt;/a&gt; &#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> defines how scale factors can modify an entire scene.</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * Scale-conversion constants provide correct names and values for common conversion factors. References:</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;ul&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; &lt;a href="http://www.unit-conversion.info" target="_blank"&gt;Unit conversion&lt;/a&gt; website &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; &lt;a href="http://en.wikipedia.org/wiki/Newton_%28unit%29#Conversion_factors" target="_blank"&gt;Wikipedia Conversion factors, units of force&lt;/a&gt; &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;li&gt; &lt;a href="http://www.unitsconversion.com.ar/massunitsconversion/index.htm" target="_blank"&gt;Unit conversion&lt;/a&gt; website &lt;/li&gt;&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"> * &lt;/ul&gt;&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			
			<xsl:if test="not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not($inConcretePackage = 'true')"> <!-- final entries -->
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;i&gt;Package hint:&lt;/i&gt; </xsl:text>
				<xsl:choose>
					<xsl:when test="($isInterface = 'true')">
						<xsl:text> This interface is defined by the X3D Java Language Binding Specification for the Scene Authoring Interface (SAI).</xsl:text>
					</xsl:when>
					<!-- TODO confirm wording OK in each case: -->
					<xsl:when test="($isFieldInterface or $isException or $isServiceInterface)">
						<xsl:text> This specification class is defined by the X3D Java Language Binding Specification for the Scene Authoring Interface (SAI).</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text> This </xsl:text>
						<xsl:value-of select="$concretePackage"/>
						<xsl:text> concrete class is used for implementing a standalone X3D object as a </xsl:text>
						<!-- https://stackoverflow.com/questions/1082050/linking-to-an-external-url-in-javadoc -->
						<xsl:text disable-output-escaping="yes"><![CDATA[<a href="https://en.wikipedia.org/wiki/Plain_old_Java_object" target="_blank">Plain Old Java Object (POJO)</a>.]]></xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text> * If you are writing Java code for use inside an X3D Script node, compile separate code using only the </xsl:text>
						<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
						<xsl:value-of select="$saiPackage"/>
						<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
						<xsl:text> package instead.</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			<xsl:text>&#10;</xsl:text>
			<xsl:if test="$hasJavadocBlock">
				<xsl:if test="not(starts-with(normalize-space($javadocBlock),'*'))">
					<xsl:text> * </xsl:text>
				</xsl:if>
				<xsl:value-of select="$javadocBlock" disable-output-escaping="yes"/>
				<xsl:text> * </xsl:text><xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:text> * @author Don Brutzman and Roy Walmsley</xsl:text><xsl:text>&#10;</xsl:text>
			
			<xsl:if test="(string-length($saiJavaSpecificationSection) > 0) or (string-length($saiJavaSpecificationRelativeUrl) > 0)">
				<!-- diagnostics if one is missing -->
				<xsl:if test="not($saiJavaSpecificationSection) or (string-length($saiJavaSpecificationSection) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains saiJavaSpecificationRelativeUrl but not saiJavaSpecificationSection</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="not($saiJavaSpecificationRelativeUrl) or (string-length($saiJavaSpecificationRelativeUrl) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains saiJavaSpecificationSection but not saiJavaSpecificationRelativeUrl</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="ends-with($saiJavaSpecificationRelativeUrl,'#')">
					<xsl:message>
						<xsl:text>*** Code-generation error: saiJavaSpecificationRelativeUrl=</xsl:text>
						<xsl:value-of select="$saiJavaSpecificationRelativeUrl"/>
						<xsl:text> ends with # and is missing bookmark</xsl:text>
					</xsl:message>
				</xsl:if>
				<!-- javadoc -->
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="]]></xsl:text>
				<xsl:value-of select="$saiJavaSpecificationRootUrl"/>
				<xsl:text>/</xsl:text>
				<xsl:value-of select="$saiJavaSpecificationRelativeUrl"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[" target="_blank">SAI Java Specification]]></xsl:text>
				<xsl:if test="string-length($saiJavaSpecificationSection) > 0">
					<xsl:text>: </xsl:text>
					<xsl:value-of select="$saiJavaSpecificationSection"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="(string-length($saiAbstractSpecificationSection) > 0) or (string-length($saiAbstractSpecificationRelativeUrl) > 0)">
				<!-- diagnostics if one is missing -->
				<xsl:if test="not($saiAbstractSpecificationSection) or (string-length($saiAbstractSpecificationSection) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains saiAbstractSpecificationRelativeUrl but not saiAbstractSpecificationSection</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="not($saiAbstractSpecificationRelativeUrl) or (string-length($saiAbstractSpecificationRelativeUrl) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains saiAbstractSpecificationSection but not saiAbstractSpecificationRelativeUrl</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="ends-with($saiAbstractSpecificationRelativeUrl,'#')">
					<xsl:message>
						<xsl:text>*** Code-generation error: saiAbstractSpecificationRelativeUrl=</xsl:text>
						<xsl:value-of select="$saiAbstractSpecificationRelativeUrl"/>
						<xsl:text> ends with # and is missing bookmark</xsl:text>
					</xsl:message>
				</xsl:if>
				<!-- javadoc -->
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="]]></xsl:text>
				<xsl:value-of select="$saiAbstractSpecificationRootUrl"/>
				<xsl:text>/</xsl:text>
				<xsl:value-of select="$saiAbstractSpecificationRelativeUrl"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[" target="blank">SAI Abstract Specification]]></xsl:text>
				<xsl:if test="string-length($saiAbstractSpecificationSection) > 0">
					<xsl:text>: </xsl:text>
					<xsl:value-of select="$saiAbstractSpecificationSection"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="(string-length($x3dAbstractSpecificationSection) > 0) or (string-length($x3dAbstractSpecificationRelativeUrl) > 0)">
				<!-- diagnostics if one is missing -->
				<xsl:if test="not($x3dAbstractSpecificationSection) or (string-length($x3dAbstractSpecificationSection) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains x3dAbstractSpecificationRelativeUrl but not x3dAbstractSpecificationSection</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="not($x3dAbstractSpecificationRelativeUrl) or (string-length($x3dAbstractSpecificationRelativeUrl) = 0)">
					<xsl:message>
						<xsl:text>*** Code-generation error: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> definition contains x3dAbstractSpecificationSection but not x3dAbstractSpecificationRelativeUrl</xsl:text>
					</xsl:message>
				</xsl:if>
				<xsl:if test="ends-with($x3dAbstractSpecificationSection,'#')">
					<xsl:message>
						<xsl:text>*** Code-generation error: x3dAbstractSpecificationSection=</xsl:text>
						<xsl:value-of select="$x3dAbstractSpecificationSection"/>
						<xsl:text> ends with # and is missing bookmark</xsl:text>
					</xsl:message>
				</xsl:if>
				<!-- javadoc -->
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="]]></xsl:text>
				<xsl:if test="not(contains($x3dAbstractSpecificationRelativeUrl,'http://'))">
					<!-- full url might have been retrieved from X3D Object Model, otherwise create it -->
					<xsl:value-of select="$x3dAbstractSpecificationRootUrl"/>
					<xsl:text>/</xsl:text>
				</xsl:if>
				<xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[" target="blank">X3D Abstract Specification]]></xsl:text>
				<xsl:if test="string-length($x3dAbstractSpecificationSection) > 0">
					<xsl:text>: </xsl:text>
					<xsl:value-of select="$x3dAbstractSpecificationSection"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock')">
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html]]></xsl:text>
				<xsl:if test="not(starts-with($name, 'SF')) and not(starts-with($name, 'MF')) and
							  not(starts-with($name, 'X3D') and (string-length($name) > 3))">
					<xsl:text>#</xsl:text>
					<xsl:value-of select="$name"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[" target="_blank">X3D Tooltips]]></xsl:text>
				<xsl:if test="not(starts-with($name, 'SF')) and not(starts-with($name, 'MF')) and
							  not(starts-with($name, 'X3D') and (string-length($name) > 3))">
					<xsl:text>: </xsl:text>
					<xsl:value-of select="$name"/>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:if test="starts-with($name,'SF') or starts-with($name,'MF')">
<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#field"      target="_blank">X3D Tooltips: field</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#fieldValue" target="_blank">X3D Tooltips: fieldValue</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			
			<xsl:variable name="sceneAuthoringHintSection">
					<xsl:choose>
						<xsl:when test="($name = 'AudioClip') or ($name = 'Sound')">
							<xsl:text>Audio</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'Color')">
							<xsl:text>Color</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'meta')">
							<xsl:text>metaStatements</xsl:text>
						</xsl:when>
						<xsl:when test="starts-with($name,'Metadata')">
							<xsl:text>Metadata</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'Inline') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'AS') or starts-with($name,'Proto')">
							<xsl:text>InlinesPrototypes</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'Script')">
							<xsl:text>Scripts</xsl:text>
						</xsl:when>
						<xsl:when test="contains($name, 'Texture')">
							<xsl:text>Images</xsl:text>
						</xsl:when>
						<xsl:when test="contains($name, 'Triangle') or contains($name, 'Face') or contains($name, 'Quad')">
							<xsl:text>Meshes</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'Transform')">
							<xsl:text>CoordinateSystems</xsl:text>
						</xsl:when>
						<xsl:when test="($name = 'url')">
							<xsl:text>urls</xsl:text>
						</xsl:when>
						<xsl:when test="contains($name,'Viewpoint') or ($name = 'NavigationInfo')">
							<xsl:text>Viewpoints</xsl:text>
						</xsl:when>
						<xsl:when test="contains($name, 'Volume')">
							<xsl:text>Volume</xsl:text>
						</xsl:when>
					</xsl:choose>
				</xsl:variable>

			<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html]]></xsl:text>
			<!-- append relevant bookmarks -->
			<xsl:if test="(string-length($sceneAuthoringHintSection) > 0)">
				<xsl:text>#</xsl:text>
				<xsl:value-of select="$sceneAuthoringHintSection"/>
			</xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[" target="_blank">X3D Scene Authoring Hints]]></xsl:text>
			<xsl:if test="(string-length($sceneAuthoringHintSection) > 0)">
				<xsl:text>: </xsl:text>
				<xsl:value-of select="$sceneAuthoringHintSection"/>
			</xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
			<!-- special javadoc links -->
			<xsl:choose>
				<xsl:when test="starts-with($name,'SFColor')">
					<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a>
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'IS')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
 * @see connectObject
 * @see ProtoDeclareObject
 * @see ProtoInterfaceObject
 * @see ProtoBodyObject
 * @see ProtoInstanceObject
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'connect')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
 * @see ISObject
 * @see ProtoDeclareObject
 * @see ProtoInterfaceObject
 * @see ProtoBodyObject
 * @see ProtoInstanceObject
]]></xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>&#10;</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			
			<xsl:text> */</xsl:text><!-- end javadoc -->
			<xsl:text>&#10;</xsl:text>
			
			<!-- ********************************************************************************** -->
			<!-- generate source code -->
			<xsl:value-of select="$visibility"/>
			<xsl:if test="(string-length($visibility) > 0)">
				<xsl:text> </xsl:text>
			</xsl:if>
			<xsl:if test="($isAbstract = 'true')">
				<xsl:text>abstract</xsl:text>
				<xsl:text> </xsl:text>
			</xsl:if>
			<xsl:choose>
				<xsl:when test="($isInterface = 'true')">
					<xsl:text>interface</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>class</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$name"/>
			<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
						  not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not(starts-with($name,'X3DConcrete'))">
				<xsl:value-of select="$jsaiClassSuffix"/>
			</xsl:if>
			<xsl:if test="string-length($extends) > 0">
				<xsl:text> extends </xsl:text>
				<xsl:choose>
					<xsl:when test="contains($extends,'.')">
						<!-- TODO substring after last . http://stackoverflow.com/questions/17468891/substring-after-last-character-in-xslt -->
						<xsl:value-of select="$extends"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$extends"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			<xsl:if test="string-length($implements) > 0">
				<xsl:text> implements </xsl:text>
				<xsl:value-of select="$implements"/>
			</xsl:if>
			
			<xsl:variable name="wrapClassBrackets">
				<!-- BrowserEvent and BrowserFactory are classes ; $isClassX3dStatement or -->
				<xsl:value-of select="(not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and not($name = 'CommentsBlock'))
                                       or ($name = 'BrowserFactory') or ($name = 'BrowserFactoryImpl') or ($name = 'BrowserListener')"/>
			</xsl:variable>
			<!-- debug or ($name = 'BrowserEvent') 
<xsl:message>
	<xsl:text>*** wrapClassBrackets open: $name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text>, $isInterface=</xsl:text>
	<xsl:value-of select="$isInterface"/>
	<xsl:text>, $isFieldInterface=</xsl:text>
	<xsl:value-of select="$isFieldInterface"/>
	<xsl:text>, $isException=</xsl:text>
	<xsl:value-of select="$isException"/>
	<xsl:text>, $isServiceInterface=</xsl:text>
	<xsl:value-of select="$isServiceInterface"/>
	<xsl:text>, $wrapClassBrackets=</xsl:text>
	<xsl:value-of select="$wrapClassBrackets"/>
</xsl:message>
-->	
			<xsl:if test="($wrapClassBrackets)">
				<xsl:text>&#10;</xsl:text>
				<xsl:text>{</xsl:text>
			</xsl:if>
			
			<!-- interfaceBlock and sourceFile completeness diagnostics -->
			<xsl:choose>
				<xsl:when test="($isInterface = 'true') and ($hasInterfaceBlock)">
					<xsl:if test="starts-with(normalize-space($interfaceBlock),'{')">
						<xsl:message>
							<xsl:text>*** Code-generation warning: $interfaceBlock starts with {</xsl:text>
						</xsl:message>
					</xsl:if>
					<xsl:value-of select="$interfaceBlock" disable-output-escaping="yes"/> <!-- typically has additional javadoc for each member -->
				</xsl:when>
				<xsl:when test="($isInterface = 'true') and not($hasField)">
					<xsl:message>
						<xsl:text>*** Code-generation warning: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> has no interfaceBlock defined, stub comment inserted</xsl:text>
						<!-- debug -->
						<xsl:text>; $hasField=</xsl:text>
						<xsl:value-of select="$hasField"/>
						<xsl:text>, $isInterface=</xsl:text>
						<xsl:value-of select="$isInterface"/>
						<xsl:text>, $hasInterfaceBlock=</xsl:text>
						<xsl:value-of select="$hasInterfaceBlock"/>
						<xsl:text>, $hasImplementationBlock=</xsl:text>
						<xsl:value-of select="$hasImplementationBlock"/>
					</xsl:message>
					<!--
					<xsl:if test="not($hasInterfaceBlock)">
						<xsl:text>

	// TODO define interfaceBlock in CreateX3dSceneAccessInterfaceJava.xslt</xsl:text>
					</xsl:if>
					-->
				</xsl:when>
				<xsl:when test="not($isInterface = 'true') and not($hasField) and not($hasImplementationBlock) and not($name = 'CommentsBlock')">
					<xsl:message>
						<xsl:text>*** Code-generation warning: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> has no implementationBlock defined, stub comment inserted</xsl:text>
						<!-- debug -->
						<xsl:text>; $hasField=</xsl:text>
						<xsl:value-of select="$hasField"/>
						<xsl:text>, $isInterface=</xsl:text>
						<xsl:value-of select="$isInterface"/>
						<xsl:text>, $hasInterfaceBlock=</xsl:text>
						<xsl:value-of select="$hasInterfaceBlock"/>
						<xsl:text>, $hasImplementationBlock=</xsl:text>
						<xsl:value-of select="$hasImplementationBlock"/>
					</xsl:message>
					<!--
					<xsl:text>
	// TODO define implementationBlock in CreateX3dSceneAccessInterfaceJava.xslt
					</xsl:text>
					-->
				</xsl:when>
				<xsl:when test="($isInterface = 'true') or not($isInterface = 'true')">
					<!-- fallthrough case, OK -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:message>
						<xsl:text>*** Code-generation warning: </xsl:text>
						<xsl:value-of select="$name"/>
						<xsl:text> has illegal definition, $isInterface=</xsl:text>
						<xsl:value-of select="$isInterface"/>
						<xsl:text> (allowed values are true or false)</xsl:text>
					</xsl:message>
					<xsl:text>
						
	// TODO code-generation error, need to correctly define $isInterface as true or false in CreateX3dSceneAccessInterfaceJava.xslt
					</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
					
			<xsl:if test="not($hasChildrenField = 'true') and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
                          not(starts-with($name, 'X3DConcrete')) and not($isUtilityClass = 'true')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** required by internal interface, empty list provided since no children array present in this class */
    private ArrayList<String> commentsList; 
]]></xsl:text>
			</xsl:if>
			
			<xsl:choose>
				<xsl:when test="($isInterface = 'true') and ($inConcretePackage = 'true')">
					<!-- all done with this interface, which extends SAI interface -->
				</xsl:when>
				<xsl:when test="($isUtilityClass = 'true')">
					<!-- additions for this concrete utility class --> 
					<xsl:if test="($hasImplementationBlock)">
						<xsl:if test="starts-with(normalize-space($implementationBlock),'{')">
							<xsl:message>
								<xsl:text>*** Code-generation warning: $implementationBlock starts with {</xsl:text>
							</xsl:message>
						</xsl:if>
						<xsl:value-of select="$implementationBlock" disable-output-escaping="yes"/> <!-- typically has additional javadoc included -->
					</xsl:if>
				</xsl:when>
				<xsl:when test="($hasField)">

					<!-- ===================================================== -->
					<!-- Source code: Member declarations -->
					<xsl:choose>
						<!-- define default attribute types and SFString/MFString enumeration constants (if any) -->
						<xsl:when test="($isInterface = 'true') or ($name = 'CommentsBlock') or ($name = 'ConfigurationProperties')">
							<!-- no output -->
						</xsl:when>
						<xsl:when test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface)">
							<!-- Source code: member object declarations -->
							<xsl:for-each select="InterfaceDefinition/field[((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')) and
												  not(@name = 'DEF') and not(@name = 'USE') and not(@name = 'class')]">

								<xsl:if test="position()=1">
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	// Member value declarations are encapsulated and private, using preferred Java types for concretes library</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:variable name="isX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="memberObjectName"><!-- lower camel case, usually -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="@name"/>
										</xsl:when>
										<xsl:when test="(@name = 'AS')"><!-- special case: IMPORT, EXPORT -->
											<xsl:value-of select="@name"/>
										</xsl:when>
										<xsl:when test="(@name = 'set_boolean')"> <!-- special case: BooleanFilter, BooleanToggle, IntegerTrigger -->
											<xsl:text>booleanField</xsl:text>
										</xsl:when>
										<xsl:when test="starts-with(@name,'set_')">
											<xsl:value-of select="translate(substring(substring-after(@name,'set_'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
											<xsl:value-of select="substring(substring-after(@name,'set_'),2)"/>
										</xsl:when>
										<xsl:when test="starts-with(@name,'set')">
											<xsl:value-of select="translate(substring(substring-after(@name,'set'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
											<xsl:value-of select="substring(substring-after(@name,'set'),2)"/>
										</xsl:when>
										<xsl:when test="contains(@name,'_changed')">
											<xsl:value-of select="translate(substring(substring-before(@name,'_changed'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
											<xsl:value-of select="substring(substring-before(@name,'_changed'),2)"/>
										</xsl:when>
										<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
											<!-- unmodified -->
											<xsl:value-of select="@name"/>
										</xsl:when>
										<xsl:when test="(@name = 'class')">
											<!-- getClass() is reserved by Java Object() class -->
											<xsl:text>cssClass</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="translate(substring(@name,1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
											<xsl:value-of select="substring(@name,2)"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:variable name="normalizedMemberObjectName">
									<!-- translate name into legal Java form here to avoid xpath problems -->
									<xsl:value-of select="translate($memberObjectName,'-','_')"/>
									<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
										<xsl:text>List</xsl:text><!-- append to member name -->
									</xsl:if>
								</xsl:variable>
								<xsl:if test="not(preceding-sibling::*[@name=$memberObjectName]) and not(preceding-sibling::*[@name=concat('set',$memberObjectName)]) and not(preceding-sibling::*[@name=concat('set_',$memberObjectName)]) and not(preceding-sibling::*[@name=concat($memberObjectName,'_changed')])">
									<xsl:variable name="javaType">
										<!-- can include collections, must be escaped -->
										<xsl:call-template name="javaType">
											<xsl:with-param name="x3dType" select="@type"/>
											<xsl:with-param name="isInterface" select="$isInterface"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	private </xsl:text>
									<xsl:value-of select="$javaType" disable-output-escaping="yes"/><!-- append to type name -->
									<xsl:if test="($isX3dStatement = 'true') and starts-with(@type,'X3D') and (ends-with(@type,'Node') or ends-with(@type,'Object'))">
										<xsl:value-of select="$jsaiInterfaceSuffix"/>
									</xsl:if>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:if test="contains($javaType,'ArrayList')">
										<xsl:text disable-output-escaping="yes"><![CDATA[ = new ArrayList<>()]]></xsl:text>
									</xsl:if>
									<xsl:text>;</xsl:text>
                                                                        <xsl:text> // </xsl:text>
                                                                        <xsl:value-of select="@type"/><!-- X3D field type -->
                                                                        <xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
                                                                                    <xsl:text> acceptable node types: </xsl:text>
                                                                                    <xsl:value-of select="@acceptableNodeTypes"/>
                                                                                    <!-- TODO is it possible to restrict these further when setting children? -->
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(@type = 'SFNode') and not($isX3dStatement = 'true')">
										<!-- add corresponding member variable for SFNode ProtoInstance substitution -->
									<xsl:text>	private ProtoInstanceObject </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>ProtoInstance; // allowed alternative for </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field</xsl:text>
									<xsl:text>&#10;</xsl:text>
									</xsl:if>
								</xsl:if>
							</xsl:for-each>
							
							<xsl:if test="($name = 'ProtoInstance')">
								<xsl:text>
					      ProtoDeclareObject referenceProtoDeclare;
					ExternProtoDeclareObject referenceExternProtoDeclare;
								</xsl:text>
							</xsl:if>
							<xsl:if test="($name = 'field') or ($name = 'fieldValue')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Default boolean value for this field type is an empty array. */
	private static final boolean[] DEFAULT_VALUE_BOOLEAN = new boolean[0]; // initialize as empty array

	/** boolean array, typed value holder */
	private boolean[] valueArrayBoolean;

	/** Default integer value for this field type is an empty array. */
	private static final int[] DEFAULT_VALUE_INTEGER = new int[0]; // initialize as empty array

	/** int array, typed value holder */
	private int[] valueArrayInteger;

	/** Default float value for this field type is an empty array. */
	private static final float[] DEFAULT_VALUE_FLOAT = new float[0]; // initialize as empty array
								
	/** float array, typed value holder */	
	private float[] valueArrayFloat;
									
	/** Default double value for this field type is an empty array. */
	private static final double[] DEFAULT_VALUE_DOUBLE = new double[0]; // initialize as empty array
									
	/** double array, typed value holder */	
	private double[] valueArrayDouble;

]]></xsl:text>
							</xsl:if>
						
							<!-- Source code: add special constant definitions -->
							<xsl:choose>
								<xsl:when test="($name = 'X3D')">
									<!-- Excerpt from X3D-Edit SchemaData.jsail -->
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/** XML declaration appears on first line of an XML document.
	 * <br> <i>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_HEADER = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
					
	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.1//EN" "http://www.web3d.org/specifications/x3d-4.1.dtd"&gt;</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_4_1 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 4.1//EN\" \"http://www.web3d.org/specifications/x3d-4.1.dtd\">";
	
	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.0//EN" "http://www.web3d.org/specifications/x3d-4.0.dtd"&gt;</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_4_0 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 4.0//EN\" \"http://www.web3d.org/specifications/x3d-4.0.dtd\">";
	
	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "http://www.web3d.org/specifications/x3d-3.3.dtd"&gt;</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_3_3 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.3//EN\" \"http://www.web3d.org/specifications/x3d-3.3.dtd\">";
	
	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.2//EN" "http://www.web3d.org/specifications/x3d-3.2.dtd"&gt;</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_3_2 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.2//EN\" \"http://www.web3d.org/specifications/x3d-3.2.dtd\">";
	
	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.1//EN" "http://www.web3d.org/specifications/x3d-3.1.dtd"&gt;</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_3_1 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.1//EN\" \"http://www.web3d.org/specifications/x3d-3.1.dtd\">";
	
	/** XML document type declaration. DOCTYPE supports element/attribute structural validation and follows the initial XML declaration, before the first element in an XML document.
	 * <br> <i>&lt;?DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "http://www.web3d.org/specifications/x3d-3.0.dtd"&gt;</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">W3C Recommendation, Extensible Markup Language (XML) 1.0 (Fifth Edition) section 2.8, Prolog and Document Type Declaration</a> */
	public static final String XML_DOCTYPE_X3D_3_0 = "<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.0//EN\" \"http://www.web3d.org/specifications/x3d-3.0.dtd\">";

	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.0.xsd'</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_3_0_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.0.xsd'";
	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.1.xsd'</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_3_1_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.1.xsd'";
	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.2.xsd'</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_3_2_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.2.xsd'";
	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.3.xsd'</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_3_3_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-3.3.xsd'";
	/**
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-4.0.xsd'</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_4_0_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-4.0.xsd'";
	/**  
	 * XML Schema attributes for X3D element.
	 * <br> <i>xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-4.1.xsd'</i>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-1/#xsi_schemaLocation">W3C Recommendation, XML Schema Part 1, Structures Second Edition, Section 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation</a>
	 * @see <a href="https://www.w3.org/TR/xmlschema-0">W3C Recommendation, XML Schema Part 0: Primer Second Edition</a> */
	public static final String X3D_XML_SCHEMA_4_1_ATTRIBUTES = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-4.1.xsd'";

]]></xsl:text>
								</xsl:when>
								<xsl:when test="not($isInterface = 'true') and ($name = 'unit')">
									<!-- unit factors from X3D-Edit X3dSchemaData.jsail -->
									<xsl:text disable-output-escaping="yes"><![CDATA[
	// Scale factors http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Scale

	/** unit statement conversionFactor for converting scene values of angles to Radians from Degrees */
	public static final double CONVERSIONFACTOR_ANGLES_toRadiansFromDegrees = 0.0174532925167;
	/** unit statement conversionFactor for converting scene values of angles to Radians from FullCircle */
	public static final double CONVERSIONFACTOR_ANGLES_toRadiansFromFullCircle = 6.283185307179;
	/** unit statement conversionFactor for converting scene values of angles to Radians from Grads */
	public static final double CONVERSIONFACTOR_ANGLES_toRadiansFromGrads = 0.01570796326795;

	/** unit statement conversionFactor for converting scene values of length to Meters from Pica */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromPica = 0.0042175176;
	/** unit statement conversionFactor for converting scene values of length to Meters from Inches */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromInches = 0.0254;
	/** unit statement conversionFactor for converting scene values of length to Meters from Feet */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromFeet = 0.3048;
	/** unit statement conversionFactor for converting scene values of length to Meters from Yards */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromYards = 0.9144;
	/** unit statement conversionFactor for converting scene values of length to Meters from Fathoms */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromFathoms = 1.8288;
	/** unit statement conversionFactor for converting scene values of length to Meters from Furlongs */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromFurlongs = 201.1684;
	/** unit statement conversionFactor for converting scene values of length to Meters from Miles */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromMiles = 1609.344;
	/** unit statement conversionFactor for converting scene values of length to Meters from Nautical Miles */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromNauticalMiles = 1852.0;
	/** unit statement conversionFactor for converting scene values of length to Meters from Microns */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromMicrons = 0.000001;
	/** unit statement conversionFactor for converting scene values of length to Meters from Millimeters */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromMillimeters = 0.001;
	/** unit statement conversionFactor for converting scene values of length to Meters from Centimeters */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromCentimeters = 0.01;
	/** unit statement conversionFactor for converting scene values of length to Meters from Kilometers */
	public static final double CONVERSIONFACTOR_LENGTH_toMetersFromKilometers = 1000.0;
										
	/** unit statement conversionFactor for converting scene values of force to Newtons from Dynes */
	public static final double CONVERSIONFACTOR_FORCE_toNewtonsFromDynes = 0.00001;
	/** unit statement conversionFactor for converting scene values of force to Newtons from Kilogram-force */
	public static final double CONVERSIONFACTOR_FORCE_toNewtonsFromKilogramForce = 9.8068;
	/** unit statement conversionFactor for converting scene values of force to Newtons from Pounds-force */
	public static final double CONVERSIONFACTOR_FORCE_toNewtonsFromPoundsForce = 4.4482;
	/** unit statement conversionFactor for converting scene values of force to Newtons from Poundal */
	public static final double CONVERSIONFACTOR_FORCE_toNewtonsFromPoundal = 0.13826;
										
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Grains Avoirdupois (gr) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromGrains = 0.00006479891;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Drams Avoirdupois (dr) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromDrams = 0.001771845195312;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Ounces Avoirdupois (oz) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromOunces = 0.028349523125;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Troy Ounces (toz) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromTroyOunces = 0.0311034768;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Pounds Avoirdupois (lb) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromPounds = 0.45359237;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Stone, i.e. 14 Pounds Avoirdupois (lb) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromStone = 6.35029318;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Tons (U.S. short) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromTons = 907.18474;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Micrograms */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFrom = 0.000000001;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Milligrams */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromMilligrams = 0.000001;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Centigrams */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromCentigrams = 0.00001;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Carats */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromCarats = 0.0002;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Grams (g) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromGrams = 0.001;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Dekagrams */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromDekagrams = 0.01;
	/** unit statement conversionFactor for converting scene values of mass to Kilograms (kg) from Metric Tonnes (t) */
	public static final double CONVERSIONFACTOR_MASS_toKilogramsFromMetricTonnes = 1000.0;
										
]]></xsl:text>
								</xsl:when>
								<xsl:when test="not($isInterface = 'true') and (($name = 'Script') or ($name = 'ShaderProgram'))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	private ArrayList<fieldObject> fieldList = new ArrayList<>(); // instantiation

	private String sourceCode;
]]></xsl:text>
								</xsl:when>
								<xsl:when test="not($isInterface = 'true') and (($name = 'ComposedShader') or ($name = 'PackagedShader'))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	private ArrayList<fieldObject> fieldList = new ArrayList<>(); // instantiation
]]></xsl:text>
								</xsl:when>
								<xsl:when test="not($isInterface = 'true') and ($name = 'ShaderPart')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	private String sourceCode;
]]></xsl:text>
								</xsl:when>
								<xsl:when test="not($isInterface = 'true') and (($name = 'ProtoBody'))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/** The first node of a prototype declaration determines its node type, and a reference is stored here. 
		The node itself also remains in the children list, in order with other CommentBlocks and additional ProtoBody contained nodes. */
	private X3DConcreteNode primaryNode;
]]></xsl:text>
								</xsl:when>
								<!--  ProtoInterface fieldList and ProtoInstance fieldValueList declarations handled separately -->
							</xsl:choose>
							
							<xsl:if test="not($isInterface = 'true') and (not($isX3dStatement = 'true') or ($name = 'ProtoInstance'))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/** IS/connect statements might be used if this node is within a ProtoBody and connections are defined between prototype fields and built-in node fields */
	private ISObject IS;
]]></xsl:text>
							</xsl:if>

							<!-- Source code: String enumeration constants -->
							<xsl:for-each select="InterfaceDefinition/field/enumeration[(@value!='...') and (string-length(normalize-space(@value)) > 0)]">

								<xsl:if test="position()=1">
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	// ==== String constants for enumeration values ensure correct syntax and avoid run-time errors ====</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:variable name="fieldName" select="translate(../@name,'-','_')"/>

								<xsl:text>&#10;</xsl:text>
								<xsl:text>	/** </xsl:text>
								<xsl:value-of select="../@type"/>
								<xsl:text> field named </xsl:text>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:value-of select="$fieldName"/>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:choose>
									<xsl:when test="(../@type = 'SFString')">
										<xsl:text> can equal this </xsl:text>
									</xsl:when>
									<xsl:when test="(../@type = 'MFString') and (../@additionalEnumerationValuesAllowed='true')">
										<xsl:text> is an array that can include this quoted </xsl:text>
									</xsl:when>
									<xsl:when test="(../@type = 'MFString')">
										<xsl:text> is an array that can equal this quoted </xsl:text>
									</xsl:when>
								</xsl:choose>
								<xsl:text>enumeration value </xsl:text>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:call-template name="javaValue">
									<xsl:with-param name="javadoc"><xsl:text>true</xsl:text></xsl:with-param>
									<xsl:with-param name="x3dType">
										<xsl:choose>
											<xsl:when test="(../@type='MFString') and not(contains(@value,'&quot;'))">
												<xsl:text>EscapeQuotedSFString</xsl:text><!-- intentional override -->
											</xsl:when>
											<xsl:when test="(../@type='MFString')">
												<xsl:text>MFString</xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:text>SFString</xsl:text><!-- intentional override -->
											</xsl:otherwise>
										</xsl:choose>
									</xsl:with-param>
									<xsl:with-param name="schemaValue">
										<xsl:value-of select="@value"/>
									</xsl:with-param>
								</xsl:call-template>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:text> (Java syntax) or </xsl:text>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:if test="(../@type='MFString')">
									<xsl:text>'</xsl:text>
								</xsl:if>
								<xsl:value-of select="@value"/>
								<xsl:if test="(../@type='MFString')">
									<xsl:text>'</xsl:text>
								</xsl:if>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:text> (XML syntax).</xsl:text>
								<xsl:if test="(string-length(@appinfo) > 0)">
									<!-- TODO why isn't @appinfo appearing?  example metaNameValues --> 
									<xsl:text>&#10;</xsl:text>
									<xsl:text>       * </xsl:text>
									<xsl:value-of select="@appinfo"/>
								</xsl:if>
								<xsl:text> */</xsl:text><!-- end javadoc -->
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	public static final </xsl:text>
								<!-- TODO not all String enumeration constants are final arrays, some are addable elements -->
								<xsl:value-of disable-output-escaping="yes">
									<!-- can include collections, must be escaped -->
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="../@type"/>
									</xsl:call-template>
								</xsl:value-of>
								<xsl:text> </xsl:text>
								<xsl:value-of select="upper-case($fieldName)"/>
								<xsl:text>_</xsl:text>
								<!-- enumeration name: omit " character, others become _ underscore -->
								<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
								<xsl:text> = </xsl:text>
								<xsl:call-template name="javaValue">
									<xsl:with-param name="x3dType">
										<xsl:value-of select="../@type"/>
									</xsl:with-param>
									<xsl:with-param name="schemaValue">
										<xsl:value-of select="@value"/>
									</xsl:with-param>
								</xsl:call-template>
								<xsl:text>;</xsl:text>
								<xsl:text>&#10;</xsl:text>
							</xsl:for-each>									
							
							<xsl:if test="not($isInterface = 'true') and not($isUtilityClass = 'true')">
								<xsl:choose>
									<xsl:when test="($name = 'X3DConcreteElement')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>NAME</i> provides name of this element; overridden by implementing class. */
	protected static final String NAME = ""; // must be overridden
]]></xsl:text>
									</xsl:when>
									<xsl:when test="starts-with($name, 'X3DConcrete')">
										<!-- do not re-declare NAME, let class definition provide override -->
									</xsl:when>
									<xsl:when test="($name = 'ConfigurationProperties')">
										<!-- do not re-declare NAME, let class definition provide override -->
									</xsl:when>
									<xsl:otherwise>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	// String constants for default field values match X3D Schema definitions</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>NAME</i> provides name of this element: <i>]]></xsl:text>
										<xsl:value-of select="@name"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[</i>. */
	@SuppressWarnings("FieldNameHidesFieldInSuperclass")
	public static final String NAME = "]]></xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text><![CDATA[";

	/** Provides name of this element: <i>]]></xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text><![CDATA[</i>
	 * @return name of this element
	 */
	@Override
	public final String getElementName()
	{
		return NAME;
	}
]]></xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>COMPONENT</i> defines X3D component for the <i>]]></xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text><![CDATA[</i> element: <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[</i> */
	public static final String COMPONENT = "]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
			<xsl:text><![CDATA[";

	/** Defines X3D component for the <i>]]></xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text><![CDATA[</i> element: <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
			<xsl:text><![CDATA[</i>
	 * @return X3D component for this element
	 */
	@Override
	public final String getComponent()
	{
		return COMPONENT;
	}
]]></xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Integer constant <i>LEVEL</i> provides default X3D <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@name"/>
			<xsl:text><![CDATA[</i> component level for this element: <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[</i> */
	public static final int LEVEL = ]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:text><![CDATA[;

	/** Provides default X3D component level for this element: <i>]]></xsl:text>
			<xsl:value-of select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:text><![CDATA[</i>
	 * @return default X3D component level for this element
	 */
	@Override
	public final int getComponentLevel()
	{
		return LEVEL;
	}
]]></xsl:text>
									</xsl:otherwise>
								</xsl:choose>
								</xsl:if>

							<!-- Source code: _DEFAULT_VALUE definitions -->
							<xsl:for-each select="InterfaceDefinition/field[((@type='SFString') or (@type='MFString') or (string-length(normalize-space(@default)) > 0)) and 
											      not(@type='SFNode') and not(@type='MFNode') and
												  not(@name = 'DEF') and not(@name = 'USE') and not(@name = 'class')]">


								<xsl:variable name="isX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="fieldName" select="translate(@name,'-','_')"/>

								<xsl:variable name="defaultValue">
									<xsl:value-of select="@default"/>
								</xsl:variable>

								<xsl:text>&#10;</xsl:text>
								<xsl:text>	/** </xsl:text>
								<xsl:if test="($name = 'field') and ((@name = 'type') or (@name = 'accessType'))">
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>Initial value is required to be set for validity:</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> </xsl:text>
								</xsl:if>
								<xsl:value-of select="@type"/>
								<xsl:text> field named </xsl:text>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:value-of select="$fieldName"/>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:text> has default </xsl:text>
								<xsl:choose>
									<xsl:when test="(string-length($defaultValue) > 0)">
										<xsl:if test="(@type = 'MFString')">
											<xsl:text>quoted </xsl:text>
										</xsl:if>
										<xsl:text>value </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:call-template name="javaValue">
											<xsl:with-param name="javadoc"><xsl:text>true</xsl:text></xsl:with-param>
											<xsl:with-param name="x3dType">
												<xsl:value-of select="@type"/>
											</xsl:with-param>
											<xsl:with-param name="schemaValue">
												<xsl:value-of select="$defaultValue"/>
											</xsl:with-param>
										</xsl:call-template>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> (Java syntax) or </xsl:text>
										<xsl:if test="(@type = 'MFString')">
											<xsl:text>quoted value </xsl:text>
										</xsl:if>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="$defaultValue"/>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> (XML syntax)</xsl:text>
									</xsl:when>
									<xsl:when test="starts-with(@type, 'MF')">
										<xsl:text>value equal to an empty list</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:text>value equal to an empty string</xsl:text>
									</xsl:otherwise>
								</xsl:choose>
								<xsl:text>. </xsl:text>
								<xsl:text>*/</xsl:text><!-- end javadoc -->
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	public static final </xsl:text>
								<xsl:value-of disable-output-escaping="yes">
									<!-- can include collections, must be escaped -->
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="@type"/>
										<xsl:with-param name="isInterface" select="$isInterface"/>
									</xsl:call-template>
								</xsl:value-of>
								<xsl:text> </xsl:text>
								<xsl:value-of select="upper-case($fieldName)"/>
								<xsl:text>_DEFAULT_VALUE</xsl:text>
								<xsl:text> = </xsl:text>
								<xsl:call-template name="javaValue">
									<xsl:with-param name="x3dType">
										<xsl:value-of select="@type"/>
									</xsl:with-param>
									<xsl:with-param name="schemaValue">
										<xsl:value-of select="$defaultValue"/>
									</xsl:with-param>
								</xsl:call-template>
								<xsl:text>;</xsl:text>
								<xsl:text>&#10;</xsl:text>
							</xsl:for-each>

							<xsl:variable name="isX3dStatement">
								<xsl:call-template name="isX3dStatement">
									<xsl:with-param name="name" select="@name"/>
								</xsl:call-template>
							</xsl:variable>
							
							<xsl:if test="InterfaceDefinition/field[((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove'))]">
								<!-- Source code: getFieldType -->
								<xsl:text disable-output-escaping="yes">
	/** Indicate type corresponding to given fieldName.
	 * @param fieldName name of field in this X3D </xsl:text>
								<xsl:choose>
								   <xsl:when test="($isX3dStatement = 'true')">
									   <xsl:text>statement</xsl:text>
								   </xsl:when>
								   <xsl:otherwise>
									   <xsl:text>node</xsl:text>
								   </xsl:otherwise>
								</xsl:choose>
								<xsl:text disable-output-escaping="yes">
	 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_TYPE
	 * @return X3D type (SFvec3f etc.), otherwise ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE if not recognized
	 */
	@Override		
	public String getFieldType(String fieldName)
	{
		String result;

		switch (fieldName)
		{</xsl:text>
								<xsl:for-each select="InterfaceDefinition/field"> <!-- [((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove'))] -->
									<xsl:if test="position()=1">
										<xsl:text>
			// String constants for exact field type values matching X3D Schema definitions,
			// thus avoiding spelling errors and allowing type-matching checks
											
			case "containerField":
				result = "SFString";
				break;</xsl:text>
									</xsl:if>
									<xsl:variable name="fieldName">
										<xsl:choose>
											<xsl:when test="starts-with(@name,'set_')">
												<xsl:value-of select="translate(substring-after(@name,'set_'),'-','_')"/>
											</xsl:when>
											<xsl:when test="ends-with(@name,'_changed')">
												<xsl:value-of select="translate(substring-before(@name,'_changed'),'-','_')"/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="translate(@name,'-','_')"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:variable name="hasPrecedingFieldDefinition">
										<!-- example: ParticleSystem has 'geometry' field annotation overriding Shape node -->
										<xsl:value-of select="(count(preceding-sibling::*[(@name = $fieldName) or (@name = concat('set_',$fieldName)) or (@name = concat($fieldName,'_changed'))]) > 0)"/>
									</xsl:variable>
									<xsl:if test="not($hasPrecedingFieldDefinition = 'true')">
										<xsl:text>
			case "</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>":
				result = "</xsl:text><xsl:value-of select="@type"/><xsl:text>";
				break;</xsl:text>
									</xsl:if>
								</xsl:for-each>
									<xsl:text disable-output-escaping="yes">
			default:
			{
				// if fieldName has a prefix "set_" prepended (or a suffix "_changed" appended) then try again by stripping it and recursing once
				if      (fieldName.trim().startsWith("set_"))
						 result = getFieldType(fieldName.trim().substring(4)); // after "set_"
				else if (fieldName.trim().endsWith("_changed"))
						 result = getFieldType(fieldName.trim().substring(0, fieldName.length() - 8)); // before "_changed"
				else     result = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE; // unique return value avoids mistaken matches
			}
		}
</xsl:text>
								<!-- now check special-case fields -->
								<xsl:choose>
									<xsl:when test="($name = 'ProtoDeclare')  or ($name = 'ExternProtoDeclare') or ($name = 'Script') or 
													($name = 'ShaderProgram') or ($name = 'ComposedShader')     or ($name = 'PackagedShader')">
										<xsl:text>		// now check author-defined fields
		fieldObject fieldDeclaration = this.findFieldByName(fieldName);
		if (fieldDeclaration != null)
			result = fieldDeclaration.getType(); // found it!
</xsl:text>
									</xsl:when>
									<xsl:when test="($name = 'ProtoInstance')">
										<xsl:text>		// now check author-defined fields
		fieldObject fieldDeclaration = null;
		if      (       hasProtoDeclare())
			fieldDeclaration =       referenceProtoDeclare.findFieldByName(fieldName);
		else if (hasExternProtoDeclare())
			fieldDeclaration = referenceExternProtoDeclare.findFieldByName(fieldName);
		if (fieldDeclaration != null)
			result = fieldDeclaration.getType(); // found it!
</xsl:text>
									</xsl:when>
								</xsl:choose>
								<xsl:text>		return result;
	}
</xsl:text>
								<!-- Source code: getAccessType -->
								<xsl:text disable-output-escaping="yes">
	/** Indicate accessType corresponding to given fieldName.
	 * @param fieldName name of field in this X3D </xsl:text>
								<xsl:choose>
								   <xsl:when test="($isX3dStatement = 'true')">
									   <xsl:text>statement</xsl:text>
								   </xsl:when>
								   <xsl:otherwise>
									   <xsl:text>node</xsl:text>
								   </xsl:otherwise>
								</xsl:choose>
								<xsl:text disable-output-escaping="yes">
	 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_ACCESSTYPE
	 * @return X3D accessType (inputOnly etc.), otherwise ConfigurationProperties.ERROR_UNKNOWN_FIELD_ACCESSTYPE if not recognized
	 */
	@Override
	public String getAccessType(String fieldName)
	{
		String result; // set by following checks
		switch (fieldName)
		{</xsl:text>
								<xsl:for-each select="InterfaceDefinition/field"><!-- [((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove'))] -->
									<xsl:if test="position()=1">
										<xsl:text>
			// String constants for field accessType values matching X3D Schema definitions,
			// thus avoiding spelling errors and allowing accessType-matching checks</xsl:text>
									</xsl:if>
									<xsl:variable name="fieldName" select="translate(@name,'-','_')"/>
									<xsl:variable name="hasPrecedingFieldDefinition">
										<!-- only example: ParticleSystem has 'geometry' field annotation overriding Shape node -->
										<!-- otherwise ignore preceding field definitions since each field variation (set_ or _changed or plain name) has different accessType -->
										<xsl:value-of select="($name = 'ParticleSystem') and ($fieldName = 'geometry') and (count(preceding-sibling::*[@name = $fieldName]) > 0)"/>
									</xsl:variable>
									<xsl:if test="not($hasPrecedingFieldDefinition = 'true')">
										<xsl:text>
			case "</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>":
				result = "</xsl:text><xsl:value-of select="@accessType"/><xsl:text>";
				break;</xsl:text>
									</xsl:if>
								</xsl:for-each>
								<xsl:text disable-output-escaping="yes">
			default:
			{
				// if user has added a prefix "set_" or suffix "_changed" then try again by stripping it and recursing once
				if      (fieldName.trim().startsWith("set_"))
						 result = getAccessType(fieldName.trim().substring(4)); // after "set_"
				else if (fieldName.trim().endsWith("_changed"))
						 result = getAccessType(fieldName.trim().substring(0, fieldName.length() - 8)); // before "_changed"
				else     result = ConfigurationProperties.ERROR_UNKNOWN_FIELD_ACCESSTYPE; // unique return value avoids mistaken matches
			}
		}
</xsl:text>
								<!-- now check special-case fields -->
								<xsl:choose>
									<xsl:when test="($name = 'ProtoDeclare')  or ($name = 'ExternProtoDeclare') or ($name = 'Script') or 
													($name = 'ShaderProgram') or ($name = 'ComposedShader')     or ($name = 'PackagedShader')">
										<xsl:text>		// now check author-defined fields
		fieldObject fieldDeclaration = this.findFieldByName(fieldName);
		if (fieldDeclaration != null)
			result = fieldDeclaration.getAccessType(); // found it!
</xsl:text>
									</xsl:when>
									<xsl:when test="($name = 'ProtoInstance')">
										<xsl:text>		// now check author-defined fields
		fieldObject fieldDeclaration = null;
		if      (       hasProtoDeclare())
			fieldDeclaration =       referenceProtoDeclare.findFieldByName(fieldName);
		else if (hasExternProtoDeclare())
			fieldDeclaration = referenceExternProtoDeclare.findFieldByName(fieldName);
		if (fieldDeclaration != null)
			result = fieldDeclaration.getAccessType(); // found it!
</xsl:text>
									</xsl:when>
								</xsl:choose>

									<xsl:text>		return result;
	}
</xsl:text>
							</xsl:if> <!-- end getType(fieldName), getAccessType(fieldName) -->
							
							<xsl:if test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ShaderPart')">
								<xsl:text>
	/** Contained plain-text source code */
	private String SOURCECODE_DEFAULT_VALUE = "";
								</xsl:text>
							</xsl:if>

							<!-- containerField defaults and methods -->
							<xsl:if test="(string-length(InterfaceDefinition/containerFieldDefault/@name) > 0)">
								<xsl:text>
	/** containerField describes typical field relationship of a node to its parent.
	 * Usage is not ordinarily needed when using this API, default value is provided for informational purposes. */
	public String containerField_DEFAULT_VALUE = "</xsl:text>
								<xsl:value-of select="InterfaceDefinition/containerFieldDefault/@name"/>
								<xsl:text>";
</xsl:text>
							</xsl:if>
							<xsl:if test="not($isX3dStatement = 'true')">
								<!-- Source code: _TOFIELD, FROM_FIELD definitions -->
								<xsl:for-each select="InterfaceDefinition/field[not((@name = 'DEF') or (@name = 'USE') or (@name = 'class'))]">
									<xsl:if test="position()=1">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	// String constants for field names usable in ROUTE statements</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:variable name="isX3dStatement">
										<xsl:call-template name="isX3dStatement">
											<xsl:with-param name="name" select="@name"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:variable name="name" select="@name"/>
									<xsl:variable name="fieldName" select="translate(@name,'-','_')"/>

									<xsl:variable name="hasPrecedingFieldDefinition">
										<!-- example: ParticleSystem has 'geometry' field annotation overriding Shape node -->
										<xsl:value-of select="(count(preceding-sibling::*[(@name = $fieldName) or (@name = concat('set_',$fieldName)) or (@name = concat($fieldName,'_changed'))]) > 0)"/>
									</xsl:variable>

									<!-- output event names -->
									<xsl:if test="(@accessType = 'outputOnly') or (@accessType='inputOutput') and not($hasPrecedingFieldDefinition = 'true')
												  and not($name = 'field') and not($name = 'fieldValue')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	/** fromField ROUTE name for </xsl:text>
										<xsl:value-of select="@type"/>
										<xsl:text> field named </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="$fieldName"/>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>. </xsl:text>
										<xsl:text>*/</xsl:text><!-- end javadoc -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	public static final String fromField_</xsl:text>
										<xsl:value-of select="upper-case($fieldName)"/>
										<xsl:text> = "</xsl:text>
										<xsl:value-of select="$fieldName"/>
										<xsl:text>";</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>

									<!-- input event names -->
									<xsl:if test="(@accessType = 'inputOnly') or (@accessType='inputOutput') and not($hasPrecedingFieldDefinition = 'true') and not($isX3dStatement = 'true')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	/** toField ROUTE name for </xsl:text>
										<xsl:value-of select="@type"/>
										<xsl:text> field named </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:value-of select="$fieldName"/>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text>. </xsl:text>
										<xsl:text>*/</xsl:text><!-- end javadoc -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	public static final String toField_</xsl:text>
										<xsl:value-of select="upper-case($fieldName)"/>
										<xsl:text> = "</xsl:text>
										<xsl:value-of select="$fieldName"/>
										<xsl:text>";</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
								</xsl:for-each>
							</xsl:if>
							
							<!-- Source code: constructor method -->
							<xsl:if test="not(starts-with($name, 'X3DConcrete'))"><!-- which have no initialize() method -->
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	/** Constructor for </xsl:text>
								<xsl:value-of select="$thisClassName"/>
								<xsl:if test="(@type='MFNode')">
									<xsl:text>[]</xsl:text>
								</xsl:if>
								<xsl:text> to initialize member variables with default values. */</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	public </xsl:text>
								<xsl:value-of select="$name"/>
								<xsl:if test="not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not(starts-with($name,'X3DConcrete'))">
									<xsl:value-of select="$jsaiClassSuffix"/>
								</xsl:if>
								<xsl:if test="(@type='MFNode')">
									<xsl:text>[]</xsl:text>
								</xsl:if>
								<xsl:text>()</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	{</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>		super(); // constructor invocation and corresponding initialize()</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>		initialize();</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	}</xsl:text>
								<xsl:text>&#10;</xsl:text>

								<!-- initialize() method -->
								<xsl:if test="not(contains($implementationBlock,' void initialize')) and
										      not($isUtilityClass = 'true')">
									<!-- Source code: initialize method -->
									<xsl:text>
	/** Initialize all member variables to default values. */
	@Override
	public final void initialize()
	{
		super.initialize();
</xsl:text>
									<xsl:if test="not($isX3dStatement = 'true')">
										<!-- as needed, containerField updates by checking parent node and SFNode field -->
										<!-- Reference list found at X3D Scene Authoring Hints: containerField -->
										<!-- http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField -->
										<xsl:text>
		containerField_ALTERNATE_VALUES = new String[] { "</xsl:text>
										<xsl:value-of select="InterfaceDefinition/containerFieldDefault/@name"/>
										<xsl:text>"</xsl:text>
										<!-- TODO once recorded in X3D XML Schema and X3D Object Model, iterate over values and add to array -->
										<xsl:choose>
											<xsl:when test="($name = 'Shape') or ($name = 'LOD') or ($name = 'Transform')">
												<xsl:text>, "proxy", "shape"</xsl:text>
											</xsl:when>
											<xsl:when test="($name = 'Group')  or ($name = 'StaticGroup') or ($name = 'Collision')   or
															($name = 'Anchor') or ($name = 'Billboard')   or ($name = 'CADAssembly') or 
															($name = 'CADLayer')   or ($name = 'CADPart') or ($name = 'Switch')">
												<!-- debatable whether support is appropriate for a few other X3DGroupingNode nodes -->
												<xsl:text>, "proxy"</xsl:text>
											</xsl:when>
											<xsl:when test="($name = 'ImageTexture') or ($name = 'PixelTexture')">
												<xsl:text>, "back",        "bottom",        "front",        "left",        "right",        "top"</xsl:text>
												<xsl:text>, "backTexture", "bottomTexture", "frontTexture", "leftTexture", "rightTexture", "topTexture"</xsl:text>
											</xsl:when>
											<xsl:when test="starts-with($name,'Metadata')">
												<xsl:text>, "value"</xsl:text>
											</xsl:when>
											<xsl:when test="($name = 'MovieTexture')">
												<xsl:text>, "source"</xsl:text>
												<xsl:text>, "back",        "bottom",        "front",        "left",        "right",        "top"</xsl:text>
												<xsl:text>, "backTexture", "bottomTexture", "frontTexture", "leftTexture", "rightTexture", "topTexture"</xsl:text>
											</xsl:when>
										</xsl:choose>
										<xsl:text> };
</xsl:text>
									</xsl:if>
									<!-- initialize each field with default values -->
									<xsl:for-each select="InterfaceDefinition/field[
													not(starts-with(@name,'set_')) and not(ends-with(@name,'_changed')) and
													not(@name = 'DEF') and not(@name = 'USE') and not(@name = 'class') and
												 ((@accessType='inputOutput') or (@accessType='initializeOnly') or (string-length(@accessType)=0))]">
										<xsl:variable name="isX3dStatement">
											<xsl:call-template name="isX3dStatement">
												<xsl:with-param name="name" select="@name"/>
											</xsl:call-template>
										</xsl:variable>

										<!-- TODO avoid duplication, refactor as call-template; alternatively override X3D Object Model -->
										<xsl:variable name="defaultValue">
											<!-- Provide default values where useRequired in XML Schema, e.g. X3D version -->
											<xsl:choose>
												<xsl:when test="(@type='SFNode') or (@default='NULL')">
													<xsl:text>null</xsl:text>
												</xsl:when>
												<xsl:when test="(@type='MFNode')">
													<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;()</xsl:text><!-- ArrayList<> -->
												</xsl:when>
												<xsl:when test="(string-length(@default) > 0)">
													<xsl:value-of select="@default"/>
												</xsl:when>
											</xsl:choose>
										</xsl:variable>

										<xsl:text>&#10;</xsl:text>
										<xsl:text>		</xsl:text>
										<xsl:choose>
											<xsl:when test="(@name = 'class')">
												<!-- getClass() is reserved by Java Object() class -->
												<xsl:text>cssClass</xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="translate(@name,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											</xsl:otherwise>
										</xsl:choose>
										<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
											<xsl:text>List</xsl:text><!-- append to member name -->
										</xsl:if>
										<xsl:text> = </xsl:text>
										<xsl:choose>
											<xsl:when test="(@type='SFNode') or (@type='MFNode')">
												<xsl:value-of select="$defaultValue" disable-output-escaping="yes"/>
												<xsl:text>;</xsl:text>
												<xsl:if test="($defaultValue = 'null')">
													<xsl:text> // clear out any prior node</xsl:text>
													<xsl:if test="(@type='MFNode')">
														<xsl:text>s</xsl:text>
													</xsl:if>
												</xsl:if>
											</xsl:when>
											<!-- TODO check if $defaultValue test is correct -->
											<xsl:when test="(@type='SFString') or (string-length(normalize-space($defaultValue)) > 0)">
												<xsl:value-of select="upper-case(translate(@name,'-','_'))"/> <!-- translate name here to avoid xpath problems -->
												<xsl:text>_DEFAULT_VALUE;</xsl:text>
											</xsl:when>
											<xsl:when test="(@type='MFString')">
												<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;(</xsl:text><!-- ArrayList<> -->
												<xsl:value-of select="upper-case(translate(@name,'-','_'))"/> <!-- translate name here to avoid xpath problems -->
												<xsl:text>_DEFAULT_VALUE</xsl:text>
												<xsl:text>);</xsl:text>
											</xsl:when>
											<xsl:when test="(@type='MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type='MFFloat') or (@type='MFDouble') or (@type='MFTime')">
												<xsl:text disable-output-escaping="yes">new ArrayList&lt;&gt;();</xsl:text><!-- ArrayList<> -->
											</xsl:when>
											<xsl:when test="starts-with(@type,'MF')">
												<xsl:text> new </xsl:text>
												<xsl:value-of disable-output-escaping="yes">
													<!-- can include collections, must be escaped -->
													<xsl:call-template name="javaType">
														<xsl:with-param name="x3dType" select="@type"/>
														<xsl:with-param name="isInterface" select="$isInterface"/>
													</xsl:call-template>
												</xsl:value-of>
												<xsl:text> { };</xsl:text>
											</xsl:when>
											<xsl:when test="(string-length($defaultValue) = 0)">
												<!-- all fields should have a default value; report error if found -->
												<xsl:message>
													<xsl:text>*** No default value found for </xsl:text>
													<xsl:value-of select="$name"/>
													<xsl:text> field </xsl:text>
													<xsl:value-of select="@name"/>
												</xsl:message>
											</xsl:when>
										</xsl:choose>
									</xsl:for-each>
									<xsl:text>&#10;</xsl:text>

									<xsl:if test="not($hasChildrenField = 'true') and not(starts-with($name, 'X3DConcrete'))">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		commentsList = new ArrayList<>(); // instantiate
]]></xsl:text>
									</xsl:if>
									<xsl:choose>
										<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
			fieldList = new ArrayList<>(); // instantiate

			sourceCode = SOURCECODE_DEFAULT_VALUE; // reset
	]]></xsl:text>
										</xsl:when>
										<xsl:when test="(($name = 'ComposedShader') or ($name = 'PackagedShader'))">
											<xsl:text disable-output-escaping="yes"><![CDATA[
			fieldList = new ArrayList<>(); // instantiate
	]]></xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'ShaderPart')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
			sourceCode = SOURCECODE_DEFAULT_VALUE; // reset
	]]></xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'ProtoInterface')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
			fieldList = new ArrayList<>(); // instantiate
	]]></xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'ProtoInstance')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
		fieldValueList = new ArrayList<>(); // instantiate
]]></xsl:text>
										</xsl:when>
									</xsl:choose>
							
									<xsl:if test="($name = 'field') or ($name = 'fieldValue')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		valueArrayBoolean = java.util.Arrays.copyOf(DEFAULT_VALUE_BOOLEAN, DEFAULT_VALUE_BOOLEAN.length); // must be separate copy
		valueArrayInteger = java.util.Arrays.copyOf(DEFAULT_VALUE_INTEGER, DEFAULT_VALUE_INTEGER.length); // must be separate copy
		valueArrayFloat   = java.util.Arrays.copyOf(DEFAULT_VALUE_FLOAT,   DEFAULT_VALUE_FLOAT.length  ); // must be separate copy
		valueArrayDouble  = java.util.Arrays.copyOf(DEFAULT_VALUE_DOUBLE,  DEFAULT_VALUE_DOUBLE.length ); // must be separate copy
]]></xsl:text>
									</xsl:if>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
							</xsl:if>

				
							<!-- Add class-specific methods and member definitions -->
							<xsl:variable name="protectedPreamble">
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	// Protected member value declarations are encapsulated and private, for internal library use only</xsl:text>
								<xsl:text>&#10;</xsl:text>
							</xsl:variable>
							<xsl:choose>
								<xsl:when test="($name = 'X3D')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * File extension for X3D XML Encoding, with dot prepended: <i>.x3d</i>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 */
	public static final String FILE_EXTENSION_X3D = ".x3d";
										
	/**
	 * File extension for X3D ClassicVRML Encoding, with dot prepended: <i>.x3dv</i>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/X3D_ClassicVRML.html">X3D ClassicVRML Encoding</a>
	 */
	public static final String FILE_EXTENSION_CLASSICVRML = ".x3dv";
	/**
	 * File extension for X3D Compressed Binary Encoding, with dot prepended: <i>.x3db</i>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/X3D_Binary.html">X3D Compressed Binary Encoding Encoding</a>
	 */
	public static final String FILE_EXTENSION_X3DB = ".x3db";
										
	/**
	 * File extension for VRML97 Encoding, with dot prepended: <i>.wrl</i>
	 * @see <a href="http://www.web3d.org/documents/specifications/14772/V2.0/index.html">VRML97 Encoding</a>
	 */
	public static final String FILE_EXTENSION_VRML97 = ".wrl";
										
	/**
	 * File extension for Extensible Markup Language, with dot prepended: <i>.xml</i>
	 * @see <a href="https://www.w3.org/TR/REC-xml">W3C Recommendation, Extensible Markup Language (XML)</a>
	 */
	public static final String FILE_EXTENSION_XML = ".xml";
										
	/**
	 * File extension for Scalable Vector Graphics (SVG), with dot prepended: <i>.svg</i>
	 * @see <a href="https://www.w3.org/Graphics/SVG">SVG Working Group</a>
	 */
	public static final String FILE_EXTENSION_SVG = ".svg";
										
	/**
	 * File extension for HTML Encoding, with dot prepended: <i>.html</i>
	 * @see <a href="https://www.w3.org/TR/html/syntax.html#syntax">HTML5: HTML syntax</a>
	 */
	public static final String FILE_EXTENSION_HTML = ".html";
										
	/**
	 * File extension for markdown encoding, with dot prepended: <i>.md</i>
	 * @see <a href="https://docs.gitlab.com/ee/user/markdown.html">GitLab Flavored Markdown (GFM)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Markdown">Wikipedia: Markdown</a>
	 */
	public static final String FILE_EXTENSION_MARKDOWN = ".md";
										
	/**
	 * File extension for XHTML Encoding, with dot prepended: <i>.xhtml</i>
	 * @see <a href="https://www.w3.org/TR/html/xhtml.html#xhtml">HTML5: XHTML syntax</a>
	 */
	public static final String FILE_EXTENSION_XHTML = ".xhtml";
										
	/**
	 * File extension for text files, with dot prepended: <i>.txt</i>
	 */
	public static final String FILE_EXTENSION_TEXT = ".txt";
										
	/**
	 * File extension for Java source code, with dot prepended: <i>.java</i>
	 * @see <a href="http://www.oracle.com/technetwork/java/javase/overview">Java Platform, Standard Edition (Java SE)</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Java" target="_blank">X3D Scene Authoring Hints: Java</a>
	 */
	public static final String FILE_EXTENSION_JAVA = ".java";
										
	/**
	 * File extension for JavaScript source code, with dot prepended: <i>.js</i>
	 * @see <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>
	 * @see <a href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript ECMA-262</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#JavaScript" target="_blank">X3D Scene Authoring Hints: JavaScript</a>
	 */
	public static final String FILE_EXTENSION_JAVASCRIPT = ".js";
										
	/**
	 * File extension for JavaScript Object Notation (JSON) source data, with dot prepended: <i>.json</i>
	 * @see <a href="https://en.wikipedia.org/wiki/JSON">JavaScript Object Notation (JSON)</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#JSON" target="_blank">X3D Scene Authoring Hints: JSON</a>
	 */
	public static final String FILE_EXTENSION_JSON = ".json";
										
	/**
	 * File extension for Efficient XML Interchange (EXI) compressed XML file, with dot prepended: <i>.exi</i>
	 * @see <a href="https://en.wikipedia.org/wiki/Efficient_XML_Interchange">Wikipedia: Efficient XML Interchange (EXI) file format</a>
	 * @see <a href="https://www.w3.org/TR/2014/REC-exi-20140211">Efficient XML Interchange (EXI) Format 1.0 (Second Edition) W3C Recommendation</a>
	 * @see <a href="https://www.w3.org/XML/EXI">EXI Working Group (public page)</a>
	 * @see <a href="https://www.w3.org/XML/Group/EXI">EXI Working Group (member page)</a>
	 */
	public static final String FILE_EXTENSION_EXI = ".exi";
										
	/**
	 * File extension for GZIP compressed file, with dot prepended: <i>.gz</i>
	 * @see <a href="https://en.wikipedia.org/wiki/Gzip">Wikipedia: gzip file format</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/package-summary.html">Java Package java.util.zip for ZIP and GZIP file formats</a>
	 * @see <a href="http://www.oracle.com/technetwork/articles/java/compress-1565076.html">Compressing and Decompressing Data Using Java APIs by Qusay H. Mahmoud</a>
	 */
	public static final String FILE_EXTENSION_GZIP = ".gz";
										
	/**
	 * File extension for ZIP compressed file, with dot prepended: <i>.zip</i>
	 * @see <a href="https://en.wikipedia.org/wiki/Zip_(file_format)">Wikipedia: zip file format</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/package-summary.html">Java Package java.util.zip for ZIP and GZIP file formats</a>
	 * @see <a href="http://www.oracle.com/technetwork/articles/java/compress-1565076.html">Compressing and Decompressing Data Using Java APIs by Qusay H. Mahmoud</a>
	 */
	public static final String FILE_EXTENSION_ZIP = ".zip";

	/** @see https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles */
	private BufferedWriter bufferedWriter;
	
	/**
	 *  Setup EXIFactory as required, TODO EXIFICIENT documentation
	 */
//    EXIFactory exiFactory = DefaultEXIFactory.newInstance();
	
	/** @see TODO EXIFICIENT docs */
	Grammars exificientGrammarX3D; // TODO public

	/**
	 * Provide XML string serialization of this model subgraph, utilizing X3D XML encoding and conforming to X3D Canonical Form.
	 * @see X3DObject#FILE_EXTENSION_X3D
	 * @see X3DObject#FILE_EXTENSION_XML
	 * @see X3DObject#toStringXML()
	 * @see X3DObject#toFileXML(String)
	 * @see X3DObject#toFileX3D(String)
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @return X3D string
	 */
	public String toStringXML()
	{
		return toStringX3D();
	}
	/**
	 * Provide XML string serialization of this model subgraph, utilizing X3D XML encoding and conforming to X3D Canonical Form.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3DObject#FILE_EXTENSION_X3D
	 * @see X3DObject#FILE_EXTENSION_XML
	 * @see X3DObject#toStringXML()
	 * @see X3DObject#toFileXML(String)
	 * @see X3DObject#toFileX3D(String)
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @return X3D string
	 */
	public String toStringXML(int indentLevel)
	{
		return toStringX3D(indentLevel);
	}

	/**
	 * Serialize scene graph using <i>toStringX3D()</i> to create a new XML-encoding X3D file with extension <i>x3d</i> or <i>xml</i>.
	 * @see X3DObject#toStringXML()
	 * @see X3DObject#toFileXML(String)
	 * @see X3DObject#toFileX3D(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .x3d
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileXML(String fileName)
	{
		return toFileX3D(fileName);
	}
/**
 * Check whether fileName is satisfactory NMTOKEN, ignoring prior path (if any).
 * @see SFStringObject#isNMTOKEN(String)
 * @see SFStringObject#meetsX3dNamingConventions(String)
 * @param fileName name of file to check
 * @return whether fileName is satisfactory NMTOKEN
 */
public static boolean isFileNameNMTOKEN(String fileName)
{
    String strippedFileName = fileName;
    if (strippedFileName.contains("/"))
        strippedFileName = strippedFileName.substring(strippedFileName.lastIndexOf("/")  + 1);
    if (strippedFileName.contains("\\"))
        strippedFileName = strippedFileName.substring(strippedFileName.lastIndexOf("\\") + 1);

    return SFStringObject.isNMTOKEN(strippedFileName);
}
/**
 * Check whether fileName meets X3D naming conventions, ignoring prior path (if any).
 * @see SFStringObject#isNMTOKEN(String)
 * @see SFStringObject#meetsX3dNamingConventions(String)
 * @param fileName name of file to check
 * @return whether fileName is satisfactory NMTOKEN
 */
public static boolean fileNameMeetsX3dNamingConventions(String fileName)
{
    String strippedFileName = fileName;
    if (strippedFileName.contains("/"))
        strippedFileName = strippedFileName.substring(strippedFileName.lastIndexOf("/")   + 1);
    if (strippedFileName.contains("\\"))
        strippedFileName = strippedFileName.substring(strippedFileName.lastIndexOf("\\")  + 1);
    if (strippedFileName.contains(".")) // strip file extension
       strippedFileName = strippedFileName.substring(0, strippedFileName.lastIndexOf(".") + 1);

    return SFStringObject.meetsX3dNamingConventions(strippedFileName);
}
	/**
	 * Serialize scene graph using <i>toStringX3D()</i> to create a new XML-encoding X3D file with extension <i>x3d</i> or <i>xml</i>.
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toStringXML()
	 * @see X3DObject#toFileXML(String)
	 * @see SFStringObject#isNMTOKEN(String)
	 * @see SFStringObject#meetsX3dNamingConventions(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .x3d
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileX3D(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new X3DException("toFileX3D(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_X3D + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_X3D) && !fileName.endsWith(FILE_EXTENSION_XML))
		{
			throw new X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_X3D + "\" or " +
                            "\"" + FILE_EXTENSION_XML + "\"");
		}
                if (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("Warning: " + fileName + " does not meet suggested X3D naming conventions. Output serialization allowed to continue, file may be editable...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("Warning: " + fileName + " is not a valid NMTOKEN. Output serialization allowed to continue, file may be editable...");

		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		
		// http://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"
									
		try
		{	
			validate(); // strict checks before serializing scene and saving file
		}
		catch (Exception e)
		{
			System.out.println (e); // output exception but allow serialization to continue, file may be editable
			e.printStackTrace();
			if (ConfigurationProperties.isValidationExceptionAllowed())
				 System.out.println ("Output serialization allowed to continue, file may be editable...");
			else throw (e);
		}
		File priorFile = new File(fileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Warning: toFileX3D() is overwriting prior file " + fileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("Warning: toFileX3D() is not allowed to overwrite prior file: " + fileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

		String outputSceneText = toStringX3D();
		try
		{
			bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
			bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
			bufferedWriter.close(); // ensure file writing is complete
			return outputFilePath.toFile(); // success
		}
		catch (IOException exception)
		{
			throw new X3DException("IOException for fileName " + fileName + ", unable to save file: " + exception);
		}
	}
	/**
	 * Serialize scene graph using <i>toStringClassicVRML()</i> to create a new X3D file with extension <i>x3dv</i>.
	 * @see X3DObject#toStringClassicVRML()
	 * @see SFStringObject#isNMTOKEN(String)
	 * @see SFStringObject#meetsX3dNamingConventions(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .x3dv
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileClassicVRML(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new X3DException("toFileClassicVRML(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_CLASSICVRML + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_CLASSICVRML))
		{
			throw new X3DException("fileName " + fileName + " does not end with extension \"" + FILE_EXTENSION_CLASSICVRML + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("Warning: " + fileName + " does not meet suggested X3D naming conventions. Output serialization allowed to continue, file may be editable...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("Warning: " + fileName + " is not a valid NMTOKEN. Output serialization allowed to continue, file may be editable...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			if (errorNotice.isEmpty()) errorNotice += "\n";
			errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		
		// http://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"
		
		try
		{	
			validate(); // strict checks before serializing scene and saving file
		}
		catch (Exception e)
		{
			System.out.println (e); // output exception but allow serialization to continue, file may be editable
			e.printStackTrace();
			if (ConfigurationProperties.isValidationExceptionAllowed())
				 System.out.println ("Output serialization allowed to continue, file may be editable...");
			else throw (e);
		}
		File priorFile = new File(fileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Warning: toFileClassicVRML() is overwriting prior file " + fileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("Warning: toFileClassicVRML() is not allowed to overwrite prior file: " + fileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

		String outputSceneText = toStringClassicVRML();
		try
		{
			bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
			bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
			bufferedWriter.close(); // ensure file writing is complete
			return outputFilePath.toFile(); // success
		}
		catch (IOException exception)
		{
			throw new X3DException("IOException for fileName " + fileName + ", unable to save file: " + exception);
		}
	}
	/**
	 * Serialize scene graph using <i>toStringVRML97()</i> to create a new X3D file with extension <i>wrl</i>.
	 * @see X3DObject#toStringVRML97()
	 * @see SFStringObject#isNMTOKEN(String)
	 * @see SFStringObject#meetsX3dNamingConventions(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .wrl
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileVRML97(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new X3DException("toFileVRML97(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_VRML97 + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_VRML97))
		{
			throw new X3DException("fileName " + fileName + " does not end with extension \"" + FILE_EXTENSION_VRML97 + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("Warning: " + fileName + " does not meet suggested X3D naming conventions. Output serialization allowed to continue, file may be editable...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("Warning: " + fileName + " is not a valid NMTOKEN. Output serialization allowed to continue, file may be editable...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			if (errorNotice.isEmpty()) errorNotice += "\n";
			errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		
		// http://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"
		
		try
		{	
			validate(); // strict checks before serializing scene and saving file
		}
		catch (Exception e)
		{
			System.out.println (e); // output exception but allow serialization to continue, file may be editable
			e.printStackTrace();
			if (ConfigurationProperties.isValidationExceptionAllowed())
				 System.out.println ("Output serialization allowed to continue, file may be editable...");
			else throw (e);
		}
		File priorFile = new File(fileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Warning: toFileVRML97() is overwriting prior file " + fileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("Warning: toFileVRML97() is not allowed to overwrite prior file: " + fileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

		String outputSceneText = toStringVRML97();
		try
		{
			bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
			bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
			bufferedWriter.close(); // ensure file writing is complete
			return outputFilePath.toFile(); // success
		}
		catch (IOException exception)
		{
			throw new X3DException("IOException for fileName " + fileName + ", unable to save file: " + exception);
		}
	}
	/**
	 * Utility method for toFileStylesheetConversion() with no stylesheet parameters.
	 * @param stylesheetName name of stylesheet to apply
	 * @param fileName name of file to create and save, can include local directory path, must end with allowed file extension (e.g. ".html")
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileStylesheetConversion(String stylesheetName, String fileName)
	{
            return toFileStylesheetConversion(stylesheetName, fileName, "", "", "", "");
	}
	/**
	 * Utility method for toFileStylesheetConversion() with a single stylesheet name=value parameter pair.
	 * @param stylesheetName name of stylesheet to apply
	 * @param fileName name of file to create and save, can include local directory path, must end with allowed file extension (e.g. ".html")
	 * @param parameterName1  first stylesheet parameter name
	 * @param parameterValue1 first stylesheet parameter value
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileStylesheetConversion(String stylesheetName, String fileName, String parameterName1, String parameterValue1)
	{
            return toFileStylesheetConversion(stylesheetName, fileName, parameterName1, parameterValue1, "", "");
	}

	/**
	 * Serialize scene graph using <i>toFileX3D()</i> and then create a new file with corresponding filename extension (e.g. <i>.html</i>) using an embedded stylesheet.
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toFileX3D(String)
	 * @see X3DObject#toFileJava(String)
	 * @see X3DObject#toFileJSON(String)
	 * @see X3DObject#toFileX3DOM(String)
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see X3DObject#toFileCobweb(String,String)
	 * @see SFStringObject#isNMTOKEN(String)
	 * @see SFStringObject#meetsX3dNamingConventions(String)
	 * @see ConfigurationProperties#X3DJSAIL_JAR_RELEASE_VERSIONS
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param stylesheetName name of stylesheet to apply
	 * @param fileName name of file to create and save, can include local directory path, must end with allowed file extension (e.g. ".html")
	 * @param parameterName1  first stylesheet parameter name
	 * @param parameterValue1 first stylesheet parameter value
	 * @param parameterName2  second stylesheet parameter name
	 * @param parameterValue2 second stylesheet parameter value
	 * @return File containing result (if operation succeeds), null otherwise
	 */
        // http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html
        // https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html
        // https://stackoverflow.com/questions/1858021/suppress-deprecated-import-warning-in-java
        @SuppressWarnings("deprecation")
	public File toFileStylesheetConversion(String stylesheetName, String fileName, String parameterName1, String parameterValue1, String parameterName2, String parameterValue2)
	{
		String errorNotice = new String();
                String expectedFileNameExtension = "";
		if ((stylesheetName == null || stylesheetName.isEmpty()))
		{
			throw new X3DException("toFileStylesheetConversion(stylesheetName, fileName) stylesheetName not provided;" +
				" (see ConfigurationProperties for allowed choices)");
		}
                else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_extrusionCrossSectionSVG))
                {
                    expectedFileNameExtension = FILE_EXTENSION_SVG;
                }
                else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_htmlDocumentation))
                {
                    expectedFileNameExtension = FILE_EXTENSION_HTML;
                }
                else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_X3DTIDY))
                {
                    expectedFileNameExtension = FILE_EXTENSION_X3D;
                }
                else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_JAVA))
                {
                    expectedFileNameExtension = FILE_EXTENSION_JAVA;
                }
                else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_JSON))
                {
                    expectedFileNameExtension = FILE_EXTENSION_JSON;
                }
                else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_X3DOM))
                {
                    expectedFileNameExtension = FILE_EXTENSION_HTML;
                }
                else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_X_ITE))
                {
                    expectedFileNameExtension = FILE_EXTENSION_HTML;
                }
                else if (stylesheetName.equals(ConfigurationProperties.STYLESHEET_COBWEB))
                {
                    expectedFileNameExtension = FILE_EXTENSION_HTML;
                }
                                                                            
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new X3DException("toFileStylesheetConversion(stylesheetName, fileName) fileName not provided;" +
				" (see ConfigurationProperties for allowed choices)");
		}
		if (!(fileName.endsWith(expectedFileNameExtension) || // some variations allowed
                     (fileName.endsWith(FILE_EXTENSION_XHTML)      && expectedFileNameExtension.equals(FILE_EXTENSION_HTML)) ||
                     (fileName.endsWith(FILE_EXTENSION_JAVASCRIPT) && expectedFileNameExtension.equals(FILE_EXTENSION_JSON))))
		{
			throw new X3DException("fileName " + fileName + " does not end with expected extension \"" + expectedFileNameExtension + "\"");
		}
                if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("Warning: " + fileName + " does not meet suggested X3D naming conventions. Output serialization allowed to continue, file may be editable...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("Warning: " + fileName + " is not a valid NMTOKEN. Output serialization allowed to continue, file may be editable...");
		
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
		}					
		
		String intermediateX3DFileName = fileName.substring(0, fileName.length() - 5) + "PrettyPrint.intermediate.x3d";
                Path   intermediateX3DFilePath = Paths.get(intermediateX3DFileName);
		if (ConfigurationProperties.isDebugModeActive())
			errorNotice += "[debug] intermediateX3DFilePath=" + intermediateX3DFilePath.toAbsolutePath() + "\n";

		// http://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"
										
		try
		{	
			validate(); // strict checks before serializing scene and saving file
		}
		catch (Exception e)
		{
			System.out.println (e); // output exception but allow serialization to continue, file may be editable
			e.printStackTrace();
			if (ConfigurationProperties.isValidationExceptionAllowed())
				 System.out.println ("Output serialization allowed to continue, file may be editable...");
			else throw (e);
		}
		File priorFile = new File(fileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Warning: toFileStylesheetConversion(" + stylesheetName + ") is overwriting prior file " + fileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("Warning: toFileStylesheetConversion() is not allowed to overwrite prior file: " + fileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

		String outputSceneText = toStringX3D();
		try
		{
			bufferedWriter = Files.newBufferedWriter(intermediateX3DFilePath, charset);
			bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
			bufferedWriter.close(); // ensure file writing is complete
		}
		catch (IOException exception)
		{
			throw new X3DException("IOException when creating intermediateX3DFilePath " + intermediateX3DFilePath + 
				", unable to save file: " + exception);
		}
		
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
//		factory.setNamespaceAware(true);
//		factory.setValidating    (true);
                
		try // https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html
		{
                        // background references
			// https://stackoverflow.com/questions/20389255/reading-a-resource-file-from-within-jar/20389418#20389418
			// https://stackoverflow.com/questions/403256/how-do-i-read-a-resource-file-from-a-java-jar-file
			// https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getResourceAsStream-java.lang.String-
			// https://stackoverflow.com/questions/11501418/is-it-possible-to-create-a-file-object-from-inputstream
			// targets: X3DJSAIL.3.3.full.jar and X3DJSAIL.3.3.classes.jar

			final String systemClassPath = ConfigurationProperties.getClassPath();

			String currentX3dJsailJar = new String();
			boolean foundX3dJsailJar = false;
			if    ( systemClassPath.contains("X3DJSAIL"))
			{
					 currentX3dJsailJar = systemClassPath.substring(systemClassPath.indexOf("X3DJSAIL"));
				if ((systemClassPath.indexOf("X3DJSAIL") > 0) &&
					(currentX3dJsailJar.indexOf(java.io.File.pathSeparatorChar) > 0))
					 currentX3dJsailJar = currentX3dJsailJar.substring(0,currentX3dJsailJar.indexOf(java.io.File.pathSeparatorChar));
				// X3DJSAIL.*.jar now extracted as currentX3dJsailJar
				for (String nextX3dJsailJar : ConfigurationProperties.X3DJSAIL_JAR_RELEASE_VERSIONS)
				{
					if (currentX3dJsailJar.equals(nextX3dJsailJar))
					{
						 foundX3dJsailJar = true;
						 break;
					}
				}
			}
			if (!foundX3dJsailJar)
			{
				errorNotice = ConfigurationProperties.ERROR_CONFIGURATION_X3DJSAIL + " X3DJSAIL jar archive \"" + currentX3dJsailJar 
								+ "\" not found in CLASSPATH=" + systemClassPath;
//				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}

                        // TODO jar flexibility, once working
                        // must end in !/ https://stackoverflow.com/questions/38488492/documentbuilder-gives-java-net-malformedurlexception-no-in-spec
			String        jarPath = "jar:file:" + currentX3dJsailJar + "!/";
			String stylesheetPath = "stylesheets/" + stylesheetName;

			if (ConfigurationProperties.isDebugModeActive())
			{
				errorNotice += "[debug] System java.class.path=" + systemClassPath   + "\n";
				errorNotice += "[debug] jarPath=" + jarPath + ", ";
				errorNotice += "[debug] stylesheetPath=" + stylesheetPath + "\n";
			}
                        // getClass().getResourceAsStream looks within each classpath .jar for stylesheetPath
			InputStream stylesheetInputStream = getClass().getResourceAsStream("/" + stylesheetPath);
 			if (stylesheetInputStream == null)
			{
				errorNotice += "Stylesheet not found in " + jarPath + ": " + stylesheetPath + ", ";
			}
            // if class loader jar invocation not working then here is a bad hack for build testing: use local path instead
			File stylesheetFile = new File("lib/stylesheets/", ConfigurationProperties.STYLESHEET_htmlDocumentation);
                        if ((stylesheetInputStream == null) && !stylesheetFile.exists())
				errorNotice += "Stylesheet not found: " + stylesheetFile.getAbsolutePath() + ", ";

			// TODO check for subdirectory writeable
                        File outputFile = outputFilePath.toFile();
			if (!outputFile.canWrite())
				errorNotice += "outputFile not writable: " + outputFile.getAbsolutePath() + ", ";
			
			if (ConfigurationProperties.getXsltEngine().equals(ConfigurationProperties.XSLT_ENGINE_SAXON))
			{
				// reference: Saxon-HE 9.7 documentation and samples
				// S9APIExamples.jsail: private static class TransformA implements S9APIExamples.Test

				Processor           processor = new Processor(false);
				XsltCompiler     xsltCompiler = processor.newXsltCompiler();
				XsltExecutable xsltExecutable;
                                if (stylesheetInputStream != null)
                                    xsltExecutable = xsltCompiler.compile (new StreamSource(stylesheetInputStream));
				else
                                    xsltExecutable = xsltCompiler.compile (new StreamSource(stylesheetFile)); // this fallback might easily fail

				XdmNode source = processor.newDocumentBuilder().build(new StreamSource(intermediateX3DFilePath.toFile()));
				Serializer out = processor.newSerializer(outputFile);
				out.setOutputProperty(Serializer.Property.METHOD, "html");
				out.setOutputProperty(Serializer.Property.INDENT, "yes");
				XsltTransformer xsltTransformer = xsltExecutable.load();
				xsltTransformer.setInitialContextNode(source);
				xsltTransformer.setDestination(out);
				if (parameterName1.length() > 0)
					xsltTransformer.setParameter(new QName(parameterName1), new XdmAtomicValue(parameterValue1));
				if (parameterName2.length() > 0)
					xsltTransformer.setParameter(new QName(parameterName2), new XdmAtomicValue(parameterValue2));
                                if (stylesheetInputStream != null)
                                        xsltTransformer.setParameter(new QName("produceSVGfigures"), new XdmAtomicValue("false"));
                                xsltTransformer.transform();
			}
			else if (ConfigurationProperties.getXsltEngine().equals(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA))
			{
				DocumentBuilder builder = factory.newDocumentBuilder();
				Document x3dDocument = builder.parse(intermediateX3DFilePath.toFile());
				TransformerFactory tFactory = TransformerFactory.newInstance();
                                StreamSource styleStreamSource;
                                if (stylesheetInputStream != null)
                                    styleStreamSource = new StreamSource(stylesheetInputStream);
				else
                                    styleStreamSource = new StreamSource(stylesheetFile);
				Transformer transformer = tFactory.newTransformer(styleStreamSource);
				if (parameterName1.length() > 0)
					transformer.setParameter(parameterName1, parameterValue1);
				if (parameterName2.length() > 0)
					transformer.setParameter(parameterName2, parameterValue2);
                                if (stylesheetInputStream != null)
                                        transformer.setParameter("produceSVGfigures", "false");

				DOMSource       domSource = new DOMSource(x3dDocument);
				StreamResult streamResult = new StreamResult(outputFile);
				transformer.transform(domSource, streamResult);
			}
			else // no joy
			{
				errorNotice = "Invalid ConfigurationProperties.getXsltEngine() value='" + ConfigurationProperties.getXsltEngine() + 
									 "', legal values are ConfigurationProperties.XSLT_ENGINE_SAXON or ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA";
//				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			if (ConfigurationProperties.isDeleteIntermediateFiles()) // clean up when done
				intermediateX3DFilePath.toFile().deleteOnExit();
		}
		catch (IOException | ParserConfigurationException | TransformerException | SAXException exception)
		{
			throw new X3DException(errorNotice + exception.toString() + " exception when transforming and creating fileName " + outputFilePath + 
				", unable to save result: " + exception);
		}
		catch (SaxonApiException saxonApiException)
		{
//			Logger.getLogger(X3DObject.class.getName()).log(Level.SEVERE, null, saxonApiException);
										
			throw new X3DException(errorNotice + "SaxonApiException when transforming and creating fileName " + outputFilePath + 
				", unable to save result: " + saxonApiException);
		}
		return outputFilePath.toFile(); // success
	}

	/**
	 * Serialize scene graph using <i>toFileX3D()</i> and then create a new pretty-print HTML file with extension <i>.html</i>, suitable for documentation purposes.
     * Also create SVG output file (with same base name) for Extrusion crossSection, if found.
	 * @see ConfigurationProperties#STYLESHEET_htmlDocumentation
	 * @see ConfigurationProperties#STYLESHEET_extrusionCrossSectionSVG
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toFileX3D(String)
	 * @see X3DObject#toFileJava(String)
	 * @see X3DObject#toFileJSON(String)
	 * @see X3DObject#toFileX3DOM(String)
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see X3DObject#toFileCobweb(String,String)
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileHtmlDocumentation(String fileName)
	{
            String   svgFileName = fileName;
            if (     svgFileName.endsWith(".html"))
                     svgFileName = svgFileName.replace(".html", ".svg");
            else if (svgFileName.endsWith(".xhtml"))
                     svgFileName = svgFileName.replace(".xhtml", ".svg");
            else     svgFileName+= ".svg";

//          if (true) // TODO consider adding method to check for presence of element (e.g. Extrusion)
//                    // though likely better to let stylesheet handle that
                   toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_extrusionCrossSectionSVG, svgFileName);

            return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_htmlDocumentation,           fileName);
/*
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new X3DException("toFileHtmlDocumentation(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_HTML + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_HTML) && !fileName.endsWith(FILE_EXTENSION_XHTML))
		{
			throw new X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_HTML + "\" or " +
                            "\"" + FILE_EXTENSION_XHTML + "\"");
		}

		// XSLT stylesheet parameter names and values
		String parameterName1  = "";
		String parameterValue1 = "";
		String parameterName2  = "";
		String parameterValue2 = "";
		Path outputFilePath = Paths.get(fileName);
		
		String intermediateX3DFileName = fileName.substring(0, fileName.length() - 5) + "PrettyPrint.intermediate.x3d";
		Path   intermediateX3DFilePath = Paths.get(intermediateX3DFileName);
		
		// http://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
		// http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
		Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"
										
		try
		{	
			validate(); // strict checks before serializing scene and saving file
		}
		catch (Exception e)
		{
			System.out.println (e); // output exception but allow serialization to continue, file may be editable
			e.printStackTrace();
			if (ConfigurationProperties.isValidationExceptionAllowed())
				 System.out.println ("Output serialization allowed to continue, file may be editable...");
			else throw (e);
		}
		File priorFile = new File(fileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Warning: toFileHtmlDocumentation() is overwriting prior file " + fileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("Warning: toFileHtmlDocumentation() is not allowed to overwrite prior file: " + fileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return null;
		}

		String outputSceneText = toStringX3D();
		try
		{
			bufferedWriter = Files.newBufferedWriter(intermediateX3DFilePath, charset);
			bufferedWriter.write(outputSceneText, 0, outputSceneText.length());
			bufferedWriter.close(); // ensure file writing is complete
		}
		catch (IOException exception)
		{
			throw new X3DException("IOException when creating intermediateX3DFilePath " + intermediateX3DFilePath + 
				", unable to save file: " + exception);
		}
		
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
//		factory.setNamespaceAware(true);
//		factory.setValidating    (true);

		String errorNotice = new String();
		try // https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html
		{
                        // background references
			// https://stackoverflow.com/questions/20389255/reading-a-resource-file-from-within-jar/20389418#20389418
			// https://stackoverflow.com/questions/403256/how-do-i-read-a-resource-file-from-a-java-jar-file
			// https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getResourceAsStream-java.lang.String-
			// https://stackoverflow.com/questions/11501418/is-it-possible-to-create-a-file-object-from-inputstream
			// targets: X3DJSAIL.3.3.full.jar and X3DJSAIL.3.3.classes.jar

			String systemClassPath = System.getProperty("java.class.path");
			
                        // TODO jar flexibility, once working
                        // must end in !/ https://stackoverflow.com/questions/38488492/documentbuilder-gives-java-net-malformedurlexception-no-in-spec
			String       jarPath1 = "jar:file:X3DJSAIL.3.3.classes.jar!/";
			String       jarPath2 = "jar:file:X3DJSAIL.3.3.full.jar!/";
                        String    jarPathUsed = jarPath1;
			String stylesheetPath = "stylesheets/" + ConfigurationProperties.STYLESHEET_htmlDocumentation;
			
			if (ConfigurationProperties.isDebugModeActive())
			{
				if (errorNotice.isEmpty()) errorNotice += "\n";
				errorNotice += "[debug] System java.class.path=" + systemClassPath   + "\n";
				errorNotice += "[debug] stylesheetPath=" + stylesheetPath + "\n";
			}
////// /*
                        // https://docs.oracle.com/javase/7/docs/api/java/net/JarURLConnection.html
                                                                            
                        // initial look for X3DJSAIL jar
                        URL url = new URL(jarPathUsed + stylesheetPath);
                        JarURLConnection jarConnection = (JarURLConnection)url.openConnection();
                        Manifest manifest;
                        
                        try
                        {
                            manifest = jarConnection.getManifest();
                        }
                        catch (IOException e1) // try again
                        {
                            errorNotice += "not found: " + URL(jarPathUsed + "\n";
                            // second look for X3DJSAIL jar
                            jarPathUsed = jarPath2;
                            url = new URL(jarPathUsed + stylesheetPath);
                            jarConnection = (JarURLConnection)url.openConnection();
                            try
                            {
                                manifest = jarConnection.getManifest(); // throws exception on failure
                            }
                            catch (IOException e2) // try again, ignoring .jar in case it is defined in path already
                            {
                                errorNotice += "not found: " + URL(jarPathUsed + "\n";
                                errorNotice += "now looking for stylesheet itself..." + "\n";
                                jarPathUsed = "";
                                url = new URL(jarPathUsed + stylesheetPath);
                                jarConnection = (JarURLConnection)url.openConnection();
                            }
                        }
////// * /
                        // first attempt: assume .jar is in classpath
			InputStream stylesheetInputStream = getClass().getResourceAsStream("/" + stylesheetPath);
                        if (stylesheetInputStream == null)
                            stylesheetInputStream = getClass().getResourceAsStream(jarPathUsed + stylesheetPath);
                        if (stylesheetInputStream == null)
                            stylesheetInputStream = getClass().getResourceAsStream(jarPath2 + stylesheetPath);
			
			if (stylesheetInputStream == null)
			{
				errorNotice += "Stylesheet not found in jar: " + stylesheetPath + ", ";
			}
            // TODO fix: if class loader jar invocation not working then here is a bad hack for build testing: use local path instead
			File stylesheetFile = new File("lib/stylesheets/", ConfigurationProperties.STYLESHEET_htmlDocumentation);
			if ((stylesheetInputStream == null) && !stylesheetFile.exists())
				errorNotice += "Stylesheet not found: " + stylesheetFile.getAbsolutePath() + ", ";					
			outputFilePath.toAbsolutePath(); // debug check, defaults to local directory

			// TODO check for subdirectory writeable
                        File outputFile = outputFilePath.toFile();
			if (!outputFile.canWrite())
				errorNotice += "outputFile not writable: " + outputFile.getAbsolutePath() + ", ";
			
			if (ConfigurationProperties.getXsltEngine().equals(ConfigurationProperties.XSLT_ENGINE_SAXON))
			{
				// reference: Saxon-HE 9.7 documentation and samples
				// S9APIExamples.jsail: private static class TransformA implements S9APIExamples.Test

				Processor           processor = new Processor(false);
				XsltCompiler     xsltCompiler = processor.newXsltCompiler();
				XsltExecutable xsltExecutable;
                                if (stylesheetInputStream != null)
                                    xsltExecutable = xsltCompiler.compile (new StreamSource(stylesheetInputStream));
				else
                                    xsltExecutable = xsltCompiler.compile (new StreamSource(stylesheetFile)); // this fallback might easily fail

				XdmNode source = processor.newDocumentBuilder().build(new StreamSource(intermediateX3DFilePath.toFile()));
				Serializer out = processor.newSerializer(outputFile);
				out.setOutputProperty(Serializer.Property.METHOD, "html");
				out.setOutputProperty(Serializer.Property.INDENT, "yes");
				XsltTransformer xsltTransformer = xsltExecutable.load();
				xsltTransformer.setInitialContextNode(source);
				xsltTransformer.setDestination(out);
				if (parameterName1.length() > 0)
					xsltTransformer.setParameter(new QName(parameterName1), new XdmAtomicValue(parameterValue1));
				if (parameterName2.length() > 0)
					xsltTransformer.setParameter(new QName(parameterName2), new XdmAtomicValue(parameterValue2));
                                if (stylesheetInputStream != null)
                                        xsltTransformer.setParameter(new QName("produceSVGfigures"), new XdmAtomicValue("false")); // avoid invoking hidden stylesheet
                                        // TODO invoke spearately
                                xsltTransformer.transform();
			}
			else if (ConfigurationProperties.getXsltEngine().equals(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA))
			{
				DocumentBuilder builder = factory.newDocumentBuilder();
				Document x3dDocument = builder.parse(intermediateX3DFilePath.toFile());
				TransformerFactory tFactory = TransformerFactory.newInstance();
                                StreamSource styleStreamSource;
                                if (stylesheetInputStream != null)
                                    styleStreamSource = new StreamSource(stylesheetInputStream);
				else
                                    styleStreamSource = new StreamSource(stylesheetFile);
				Transformer transformer = tFactory.newTransformer(styleStreamSource);
				if (parameterName1.length() > 0)
					transformer.setParameter(parameterName1, parameterValue1);
				if (parameterName2.length() > 0)
					transformer.setParameter(parameterName2, parameterValue2);
                                if (stylesheetInputStream != null)
                                        transformer.setParameter("produceSVGfigures", "false"); // avoid invoking hidden stylesheet
                                        // TODO invoke spearately

				DOMSource       domSource = new DOMSource(x3dDocument);
				StreamResult streamResult = new StreamResult(outputFile);
				transformer.transform(domSource, streamResult);
			}
			else // no joy
			{
				errorNotice = "Invalid ConfigurationProperties.getXsltEngine() value='" + ConfigurationProperties.getXsltEngine() + 
									 "', legal values are ConfigurationProperties.XSLT_ENGINE_SAXON or ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA";
//				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			if (ConfigurationProperties.isDeleteIntermediateFiles()) // clean up when done
				intermediateX3DFilePath.toFile().deleteOnExit();
		}
		catch (IOException | ParserConfigurationException | TransformerException | SAXException exception)
		{
			throw new X3DException(errorNotice + exception.toString() + " exception when transforming and creating fileName " + outputFilePath + 
				", unable to save result: " + exception);
		}
		catch (SaxonApiException saxonApiException)
		{
//			Logger.getLogger(X3DObject.class.getName()).log(Level.SEVERE, null, saxonApiException);
										
			throw new X3DException(errorNotice + "SaxonApiException when transforming and creating fileName " + outputFilePath + 
				", unable to save result: " + saxonApiException);
		}
		return outputFilePath.toFile(); // success
*/
	}

	// TODO refactor XSLT conversion methods to re-use common code

	/** Private method to read a file as a String
	 * @see https://stackoverflow.com/questions/326390/how-do-i-create-a-java-string-from-the-contents-of-a-file
	 * @return file contents
	 */
	private String readFile(String file) throws IOException
	{
		BufferedReader reader = new BufferedReader(new FileReader (file));
		String         line;
		StringBuilder  stringBuilder = new StringBuilder();
		String         ls = System.getProperty("line.separator");

		try {
			while((line = reader.readLine()) != null)
			{
				stringBuilder.append(line);
				stringBuilder.append(ls);
			}
			return stringBuilder.toString();
		} 
		finally
		{
			reader.close();
		}
	}

	/**
	 * Serialize scene graph using X3dToJson.xslt stylesheet to create a new JSON-encoding string.
	 * @see X3DObject#toFileJSON(String)
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
	 * @see <a href="http://www.web3d.org/wiki/index.php/X3D_JSON_Encoding">X3D JSON Encoding</a>
	 * @see <a href="http://www.web3d.org/x3d/stylesheets/X3dToJson.html">X3D to JSON Stylesheet Converter</a>
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringJSON()
	{
		String temporaryFileName = "temporaryJsonOutputFile.json";
		
		try
		{
			File     fileJSON = toFileJSON(temporaryFileName);

			if  ((fileJSON != null) && fileJSON.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileJSON.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Serialize scene graph using toFileJava() to create new Java source as a string.
	 * @see X3DObject#toFileJava(String)
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringJava()
	{
		String temporaryFileName = "temporaryJavaOutputFile.java";
		
		try
		{
			File     fileJava = toFileJava(temporaryFileName);

			if  ((fileJava != null) && fileJava.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileJava.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (Exception e)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Serialize scene graph using JavaScriptSerializer.js to create a JavaScript string.
	 * @see X3DObject#toFileJavaScript(String)
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringJavaScript()
	{
		String temporaryFileName = "temporaryJavaScriptOutputFile.js";
		
		try
		{
			File     fileJavaScript = toFileJavaScript(temporaryFileName);

			if  ((fileJavaScript != null) && fileJavaScript.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileJavaScript.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (Exception e)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Serialize scene graph using JavaScriptSerializer.js to create a JavaScript file.
	 * @author John Carlson
	 * @see X3DObject#toStringJavaScript()
	 * @see SFStringObject#isNMTOKEN(String)
	 * @see SFStringObject#meetsX3dNamingConventions(String)
	 * @param fileName name of file to create and save, can include local directory path, must end with .js
	 * @return File containing result (if operation succeeds), empty otherwise
	 */
    public File toFileJavaScript(String fileName)
    {
                if ((fileName == null || fileName.isEmpty()))
                {
                       throw new X3DException("toFileJavaScript(fileName) fileName not provided;" +
                               " be sure to end with extension \"" + X3DObject.FILE_EXTENSION_JAVASCRIPT + "\"");
                }
                if (!fileName.endsWith(X3DObject.FILE_EXTENSION_JAVASCRIPT))
                {
                       throw new X3DException("fileName " + fileName + " does not end with extension \"" + X3DObject.FILE_EXTENSION_JAVASCRIPT + "\"");
                }
		if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("Warning: " + fileName + " does not meet suggested X3D naming conventions. Output serialization allowed to continue, file may be editable...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("Warning: " + fileName + " is not a valid NMTOKEN. Output serialization allowed to continue, file may be editable...");

                Path outputFilePath = Paths.get(fileName);

                String intermediateJSFileName = fileName + ".intermediate.js";
                Path   intermediateJSFilePath = Paths.get(intermediateJSFileName);

                // http://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
                // http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
                Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

                try
                {
                       validate(); // strict checks before serializing scene and saving file
                }
                catch (Exception e)
                {
                       System.out.println (e); // output exception but allow serialization to continue, file may be editable
                       e.printStackTrace();
                       if (ConfigurationProperties.isValidationExceptionAllowed())
                                System.out.println ("Output serialization allowed to continue, file may be editable...");
                       else throw (e);
                }

                String errorNotice = new String();
                outputFilePath.toAbsolutePath(); // debug check, defaults to local directory
                File outputFile = outputFilePath.toFile();
                if (!outputFile.canWrite())
			    {
                    errorNotice += "outputFile not writable: " + outputFile.getAbsolutePath() + ", ";
                }
				File priorFile = new File(fileName);
				if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
				{
					System.out.println ("Warning: toFileJavaScript() is overwriting prior file " + fileName);
				}
				else if  (priorFile.exists())
				{
					System.out.println ("Warning: toFileJavaScript() is not allowed to overwrite prior file: " + fileName);
					System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
					return null;
				}

                ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                String outputSceneText = toStringJSON();
                try
                {
					// patches by John Carlson
                    bufferedWriter = Files.newBufferedWriter(intermediateJSFilePath, charset);
					String nashornFolder = "nashorn";
					String tmpStr = "load('"+nashornFolder+"/jvm-npm.js');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "load('"+nashornFolder+"/repeatPolyfill.js');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var xmldom = require('"+nashornFolder+"/node_modules/xmldom');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var DOMParser = xmldom.DOMParser;\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var XMLSerializer = new xmldom.XMLSerializer();\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var DOMImplementation = new xmldom.DOMImplementation();\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var json = "+outputSceneText+";\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var version = json['X3D']['@version'];\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var docType = DOMImplementation.createDocumentType('X3D', 'ISO//Web3D//DTD X3D '+version+'//EN', 'http://www.web3d.org/specifications/x3d-'+version+'.dtd', null);\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var document = DOMImplementation.createDocument(null, 'X3D', docType);\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var mapToMethod = require('"+nashornFolder+"/node/mapToMethod.js');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var mapToMethod2 = require('"+nashornFolder+"/node/mapToMethod2.js');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var fieldTypes = require('"+nashornFolder+"/node/fieldTypes.js');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "load('"+nashornFolder+"/node/X3DJSONLD.js');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "load('"+nashornFolder+"/node/JavaScriptSerializer.js');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var child = CreateElement('X3D');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "ConvertToX3DOM(json, '', child, 'flipper.json');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "print('Returning with', child);\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var output = new JavaScriptSerializer().serializeToString(json, child, '"+fileName+"', mapToMethod, fieldTypes);\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var FileWriter = Java.type('java.io.FileWriter');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "var fw = new FileWriter('"+fileName+"');\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "fw.write(output);\n";
					bufferedWriter.write(tmpStr, 0, tmpStr.length());
					tmpStr = "fw.close();\n";
                    bufferedWriter.write(tmpStr, 0, tmpStr.length());
                    bufferedWriter.close(); // ensure file writing is complete
                }
                catch (IOException exception)
                {
                       throw new X3DException("IOException when creating intermediateJSFileName " + intermediateJSFileName +
                               ", unable to save file: " + exception);
                }
                try {
					ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");
					 engine.eval("load('"+intermediateJSFileName+"');");
					if (ConfigurationProperties.isDeleteIntermediateFiles()) // clean up when done
							intermediateJSFilePath.toFile().deleteOnExit();
					engine.eval("print('Hello World!');");
                }
                catch (ScriptException exception)
                {
					throw new X3DException(errorNotice + "ScriptException when processing fileName " + intermediateJSFilePath +
							", unable to save result: " + exception);
                }
                return outputFilePath.toFile(); // success
	}

	/**
	 * Serialize scene graph using STYLESHEET_htmlDocumentation to create a new X3DOM html page as a string.
	 * @see X3DObject#toFileHtmlDocumentation(String)
	 * @see X3DObject#FILE_EXTENSION_HTML
	 * @see X3DObject#FILE_EXTENSION_XHTML
	 * @see ConfigurationProperties#STYLESHEET_htmlDocumentation
	 * @see <a href="http://www.x3dom.org">X3DOM open-source X3D player</a>
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringHtmlDocumentation()
	{
		String temporaryFileName = "temporaryPrettyPrintOutputFile.html";
		
		try
		{
			File     fileHTML = toFileHtmlDocumentation(temporaryFileName);

			if  ((fileHTML != null) && fileHTML.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileHTML.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Produce model meta information as `name`=`value` pairs, providing markdown output as a string.
	 * @see X3DObject#toFileModelMetaMarkdown(String)
	 * @see X3DObject#FILE_EXTENSION_MARKDOWN
	 * @see ConfigurationProperties#STYLESHEET_MODEL_META_TO_MARKDOWN
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringModelMetaMarkdown()
	{
		String temporaryFileName = "temporaryModelMetaMarkdownOutputFile.x3d";
		
		try
		{
			File     fileMarkdown = toFileModelMetaMarkdown(temporaryFileName);

			if  ((fileMarkdown != null) && fileMarkdown.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileMarkdown.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Produce alternate cleaned-up X3D scene using STYLESHEET_X3DTIDY, providing output as a string.
	 * @see X3DObject#toFileX3dTidy(String)
	 * @see X3DObject#FILE_EXTENSION_X3D
	 * @see ConfigurationProperties#STYLESHEET_X3DTIDY
	 * @see <a href="http://www.web3d.org/x3d/stylesheets/X3dTidy.html">X3D Tidy for Scene Cleanup, Corrections and Modifications</a>
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringX3dTidy()
	{
		String temporaryFileName = "temporaryPrettyPrintOutputFile.x3d";
		
		try
		{
			File     fileHTML = toFileX3dTidy(temporaryFileName);

			if  ((fileHTML != null) && fileHTML.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileHTML.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Serialize scene graph using STYLESHEET_X3DOM to create a new X3DOM html page as a string.
	 * @see X3DObject#toFileX3DOM(String)
	 * @see X3DObject#FILE_EXTENSION_HTML
	 * @see X3DObject#FILE_EXTENSION_XHTML
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see <a href="http://www.x3dom.org">X3DOM open-source X3D player</a>
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringX3DOM()
	{
		String temporaryFileName = "temporaryX3domOutputFile.html";
		
		try
		{
			File     fileX3DOM = toFileX3DOM(temporaryFileName);

			if  ((fileX3DOM != null) && fileX3DOM.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileX3DOM.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Serialize scene graph using STYLESHEET_X3DOM (with appropriate parameters) to create a new X_ITE html page as a string.
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see <a href="http://create3000.de/x_ite">X_ITE open-source X3D player</a>
	 * @see X3DObject#FILE_EXTENSION_HTML
	 * @see X3DObject#FILE_EXTENSION_XHTML
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see ConfigurationProperties#STYLESHEET_X_ITE
	 * @param sourceSceneName X3D file to load and view
	 * @return String containing result (if operation succeeds), empty otherwise
	 */
	public String toStringX_ITE(String sourceSceneName)
	{
		String temporaryFileName = "temporaryX3domOutputFile.html";
		
		try
		{
			File     fileX_ITE = toFileX_ITE(sourceSceneName, temporaryFileName);

			if  ((fileX_ITE != null) && fileX_ITE.exists())
			{
				String fileContents = readFile(temporaryFileName);
				fileX_ITE.delete();
				return fileContents;
//				List<String> lines = Files.readAllLines(Paths.get(temporaryFileName)); // debug
//				return String.join("\n",lines);
			}
		}
		catch (IOException ioe)
		{
			// TODO consider throwing exception instead
		}
		return "";
	}

	/**
	 * Serialize scene graph using X3dToJson.xslt stylesheet to create a new JSON-encoding X3D file with extension <i>json</i>.
	 * @see X3DObject#toStringJSON()
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toFileX3D(String)
	 * @see X3DObject#toFileJava(String)
	 * @see X3DObject#toFileHtmlDocumentation(String)
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see X3DObject#toFileCobweb(String,String)
	 * @see X3DObject#toFileX3DOM(String)
	 * @see X3DObject#FILE_EXTENSION_JSON
	 * @see X3DObject#FILE_EXTENSION_JAVASCRIPT
	 * @see ConfigurationProperties#STYLESHEET_JSON
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJson.xslt" target="_blank">X3dToJson.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.json" target="_blank">examples/HelloWorldProgramOutput.json</a>
	 * @see <a href="http://www.web3d.org/wiki/index.php/X3D_JSON_Encoding">X3D JSON Encoding</a>
	 * @see <a href="http://www.web3d.org/x3d/stylesheets/X3dToJson.html">X3D to JSON Stylesheet Converter</a>
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileJSON(String fileName)
	{
            return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_JSON, fileName,
                        "normalizeCommentWhitespace", Boolean.toString(ConfigurationProperties.isNormalizeCommentWhitespace()));
	}
	/**
	 * Serialize scene graph using X3dToJava.xslt stylesheet to create a new Java source file with extension <i>java</i>, no default license included.
	 * @see X3DObject#toFileJava(String,boolean)
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJava.xslt" target="_blank">X3dToJava.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.java" target="_blank">examples/HelloWorldProgramOutput.java</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileJava(String fileName)
	{
		return toFileJava(fileName, false); // no license
	}
	/**
	 * Serialize scene graph using X3dToJava.xslt stylesheet to create a new Java source file with extension <i>java</i>.
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toFileX3D(String)
	 * @see X3DObject#toFileJSON(String)
	 * @see X3DObject#toFileHtmlDocumentation(String)
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see X3DObject#toFileCobweb(String,String)
	 * @see X3DObject#toFileX3DOM(String)
	 * @see X3DObject#FILE_EXTENSION_JSON
	 * @see X3DObject#FILE_EXTENSION_JAVASCRIPT
	 * @see ConfigurationProperties#STYLESHEET_JSON
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJava.xslt" target="_blank">X3dToJava.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.java" target="_blank">examples/HelloWorldProgramOutput.java</a>
	 * @see <a href="http://www.web3d.org/wiki/index.php/X3D_JSON_Encoding">X3D JSON Encoding</a>
	 * @see <a href="http://www.web3d.org/x3d/stylesheets/X3dToJson.html">X3D to JSON Stylesheet Converter</a>
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @param includeWeb3dLicense whether to insert default open-source Web3D license at top of source file
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileJava(String fileName, boolean includeWeb3dLicense)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new X3DException("toFileJava(fileName, includeWeb3dLicense) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_X3D + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_JAVA))
		{
			throw new X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_JAVA + "\"");
		}
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		String className = fileName.substring(0,fileName.indexOf(".java"));
		if (className.contains("/"))
			className = className.substring(fileName.lastIndexOf("/")  + 1); // strip path
		if (className.contains("\\/"))
			className = className.substring(fileName.lastIndexOf("\\") + 1); // strip path

		// XSLT stylesheet parameter names and values
		String parameterName1  = "className";
		String parameterValue1 =  className;
		String parameterName2  = "";
		String parameterValue2 = "";
		if (includeWeb3dLicense)
		{
				parameterName2  = "includeLicenseoriginals";
				parameterValue2 = Boolean.toString(includeWeb3dLicense);
		}
		return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_JAVA, fileName,
					parameterName1, parameterValue1, parameterName2, parameterValue2);
	}
        
        /* whether to include subdirectory paths when creating markdown with  */
        private boolean includeSubdirectoryPaths = true;
        
        /* Set whether to include subdirectory paths when creating markdown (default is true)
         * @param value whether to omit subdirectory paths when creating markdown (default is true)
	 * @see X3DObject#toFileModelMetaMarkdown(String)
	 * @see X3DObject#toStringModelMetaMarkdown(String)
	 * @see X3DObject#FILE_EXTENSION_MARKDOWN
	 * @see ConfigurationProperties#STYLESHEET_MODEL_META_TO_MARKDOWN
         */
        public void setIncludeSubdirectoryPaths (boolean value)
        {
            includeSubdirectoryPaths = value;
        }

	/**
	 * Create model meta information as `name`=`value` pairs, providing markdown output as an output file having extension <i>.md</i>.
	 * @see X3DObject#toStringModelMetaMarkdown()
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toFileX3D(String)
	 * @see X3DObject#toFileJava(String)
	 * @see X3DObject#toFileJSON(String)
	 * @see X3DObject#toFileHtmlDocumentation(String)
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see X3DObject#toFileCobweb(String,String)
	 * @see SFStringObject#isNMTOKEN(String)
	 * @see SFStringObject#meetsX3dNamingConventions(String)
	 * @see ConfigurationProperties#STYLESHEET_MODEL_META_TO_MARKDOWN
	 * @see <a href="http://www.web3d.org/x3d/stylesheets/X3dTidy.html">X3D Tidy for Scene Cleanup, Corrections and Modifications</a>
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileModelMetaMarkdown(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new X3DException("toFileX3dTidy(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_MARKDOWN + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_MARKDOWN))
		{
			throw new X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_MARKDOWN + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("Warning: " + fileName + " does not meet suggested X3D naming conventions. Output serialization allowed to continue, file may be editable...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("Warning: " + fileName + " is not a valid NMTOKEN. Output serialization allowed to continue, file may be editable...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
        	return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_MODEL_META_TO_MARKDOWN, fileName, "includeSubdirectoryPaths", Boolean.toString(includeSubdirectoryPaths)); // one stylesheet parameter
	}

	/**
	 * Create alternate cleaned-up X3D scene using STYLESHEET_X3DTIDY within an output file having extension <i>.x3d</i>.
	 * @see X3DObject#toStringX3dTidy()
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toFileX3D(String)
	 * @see X3DObject#toFileJava(String)
	 * @see X3DObject#toFileJSON(String)
	 * @see X3DObject#toFileHtmlDocumentation(String)
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see X3DObject#toFileCobweb(String,String)
	 * @see SFStringObject#isNMTOKEN(String)
	 * @see SFStringObject#meetsX3dNamingConventions(String)
	 * @see ConfigurationProperties#STYLESHEET_X3DTIDY
	 * @see <a href="http://www.web3d.org/x3d/stylesheets/X3dTidy.html">X3D Tidy for Scene Cleanup, Corrections and Modifications</a>
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileX3dTidy(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new X3DException("toFileX3dTidy(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_X3D + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_X3D))
		{
			throw new X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_X3D + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("Warning: " + fileName + " does not meet suggested X3D naming conventions. Output serialization allowed to continue, file may be editable...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("Warning: " + fileName + " is not a valid NMTOKEN. Output serialization allowed to continue, file may be editable...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
        return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_X3DTIDY, fileName); // no stylesheet parameters
	}
										
	/**
	 * Create displayable scene page rendered with X3DOM, using STYLESHEET_X3DOM by serializing XML syntax within an XHTML file having extension <i>.xhtml</i>.
	 * @see <a href="http://www.x3dom.org">X3DOM open-source X3D player</a>
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toFileX3D(String)
	 * @see X3DObject#toFileJava(String)
	 * @see X3DObject#toFileJSON(String)
	 * @see X3DObject#toFileHtmlDocumentation(String)
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see X3DObject#toFileCobweb(String,String)
	 * @see SFStringObject#isNMTOKEN(String)
	 * @see SFStringObject#meetsX3dNamingConventions(String)
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param fileName name of file to create and save, can include local directory path, must end with .xhtml (preferred) or .html
	 * @return File containing result (if operation succeeds), null otherwise
	 */
	public File toFileX3DOM(String fileName)
	{
		String errorNotice = new String();
		if ((fileName == null || fileName.isEmpty()))
		{
			throw new X3DException("toFileX3DOM(fileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_HTML + "\" or \"" + FILE_EXTENSION_XHTML + "\"");
		}
		if (!fileName.endsWith(FILE_EXTENSION_HTML) && !fileName.endsWith(FILE_EXTENSION_XHTML))
		{
			throw new X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_HTML + "\" or \"" + FILE_EXTENSION_XHTML + "\"");
		}
		if      (!fileNameMeetsX3dNamingConventions(fileName))
                    System.out.println ("Warning: " + fileName + " does not meet suggested X3D naming conventions. Output serialization allowed to continue, file may be editable...");
                else if (!isFileNameNMTOKEN(fileName)) // less strict
                    System.out.println ("Warning: " + fileName + " is not a valid NMTOKEN. Output serialization allowed to continue, file may be editable...");
		Path outputFilePath = Paths.get(fileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
        return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_X3DOM, fileName, "player", "X3DOM");
	}
										
	/**
	 * Create displayable scene page rendered with X_ITE (formerly Cobweb) using STYLESHEET_X3DOM and special settings, by serializing XML syntax within an XHTML file having extension <i>.xhtml</i>.
	 * @see <a href="http://create3000.de/x_ite">X_ITE open-source X3D player</a>
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toFileX3D(String)
	 * @see X3DObject#toFileJava(String)
	 * @see X3DObject#toFileJSON(String)
	 * @see X3DObject#toFileHtmlDocumentation(String)
	 * @see X3DObject#toFileX3DOM(String)
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see X3DObject#toFileCobweb(String,String)
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param sourceSceneName X3D file to load and view
	 * @param resultFileName name of file to create and save, can include local directory path, must end with .html (preferred) or .xhtml
	 * @return File containing result (if operation succeeds), null otherwise
	 */
        // http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html
        // https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html
        // https://stackoverflow.com/questions/1858021/suppress-deprecated-import-warning-in-java
    @SuppressWarnings("deprecation")
	public File toFileX_ITE(String sourceSceneName, String resultFileName)
	{
		return toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_COBWEB, resultFileName, 
			"player", "Cobweb", "urlScene", sourceSceneName);
	}
										
	/**
	 * Create displayable scene page rendered with X_ITE (formerly Cobweb) using STYLESHEET_X3DOM and special settings, by serializing XML syntax within an XHTML file having extension <i>.xhtml</i>.
	 * @see <a href="http://create3000.de/x_ite">X_ITE open-source X3D player</a>
	 * @see X3DObject#toStringX3D()
	 * @see X3DObject#toFileX3D(String)
	 * @see X3DObject#toFileJava(String)
	 * @see X3DObject#toFileJSON(String)
	 * @see X3DObject#toFileHtmlDocumentation(String)
	 * @see X3DObject#toFileX3DOM(String)
	 * @see X3DObject#toFileX_ITE(String,String)
	 * @see ConfigurationProperties#STYLESHEET_X3DOM
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 * @param sourceSceneName X3D file to load and view
	 * @param resultFileName name of file to create and save, can include local directory path, must end with .html (preferred) or .xhtml
	 * @return File containing result (if operation succeeds), null otherwise
	 */
    @Deprecated
	public File toFileCobweb(String sourceSceneName, String resultFileName)
	{
		return toFileX_ITE (sourceSceneName, resultFileName);
	}
									
	/**
	 * Load new model from a zip file, using unzip to extract the model plus any associated files into the same path location.
	 * @see X3DObject#fromFileZIP(String,String,String)
	 * @param zipFileName name of zip file to load, can include local directory path, must end with .zip
	 * @param outputFileName name of output file to save, can include local directory path, must end with .x3d or .xml
	 * @return boolean if operation succeeds in creating this X3DObject, false otherwise
	 */
    public boolean fromFileZIP(String zipFileName, String outputFileName)
	{
		return fromFileZIP(zipFileName, outputFileName, ""); // use whatever filename is found internally
	}
									
	/**
	 * Load new model from a zip file, using unzip to extract the model plus any associated files into the same path location.
	 * <br ><br >
	 * <i>Warning:</i> If no <code>modelFileName</code> is provided, then the first <code>.x3d</code> model encountered in the zip file is returned (if any).
	 * <br ><br >
	 * <i>Warning:</i> this method overwrites any previously existing file versions when decompressing.
	 * @see <a href="https://en.wikipedia.org/wiki/Zip_(file_format)">Wikipedia: ZIP file format</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/package-summary.html">Java Package java.util.zip for ZIP and GZIP file formats</a>
	 * @see X3DObject#FILE_EXTENSION_EXI
	 * @see X3DObject#FILE_EXTENSION_GZIP
	 * @see X3DObject#FILE_EXTENSION_ZIP
	 * @see X3DObject#fromFileEXI(String)
	 * @see X3DObject#fromFileGZIP(String)
	 * @see X3DObject#toFileZIP(String,String)
	 * @see X3DObject#fromFileZIP(String,String)
	 * @param zipFileName name of zip file to load, can include local directory path, must end with .zip
	 * @param outputFileName name of output file to save, can include local directory path, must end with .x3d or .xml
	 * @param modelFileName name of model file to load, can include local directory path, must end with .x3d
	 * @return boolean if operation succeeds in creating this X3DObject, false otherwise
	 */
    public boolean fromFileZIP(String zipFileName, String outputFileName, String modelFileName)
	{
		if (modelFileName == null)
			modelFileName = new String(); // avoid NPE
		String errorNotice = new String();
		if ((zipFileName == null || zipFileName.isEmpty()))
		{
			throw new X3DException("fromFileZIP(zipFileName, modelFileName) zipFileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_ZIP + "\"");
		}
		if (!zipFileName.endsWith(FILE_EXTENSION_ZIP))
		{
			errorNotice += ("fromFileZIP zipFileName " + zipFileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_ZIP + "\"" + "\n");
			System.out.println (errorNotice);
			return false;
		}
		if (!zipFileName.endsWith(FILE_EXTENSION_ZIP))
		{
			errorNotice += ("fromFileZIP zipFileName " + zipFileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_ZIP + "\"" + "\n");
			System.out.println (errorNotice);
			return false;
		}
		Path inputFilePath = Paths.get(zipFileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] fromFileZIP zipFileName path=" + inputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		// Elliotte Rusty Harold, "Java I/O" Chapter 10 Compressing Streams, O'Reilly and Associates, 2nd edition, May 2006.
		// Example 10-11, adapted
		
		File zipFile = new File(zipFileName);
		if (!zipFile.exists() || (zipFile == null))
		{
			errorNotice += "zipFileName " + zipFileName + "not found\n";
			System.out.println (errorNotice);
			return false;
		}
		try
		{
			FileInputStream fileInputStream = new FileInputStream(zipFile);
			ZipInputStream  zipInputStream = new  ZipInputStream(fileInputStream);
			ZipEntry        zipEntry       = null;
			while ((zipEntry = zipInputStream.getNextEntry()) != null)
			{
				if (ConfigurationProperties.isDebugModeActive())
				{
					System.out.println ("Unzipping " + zipEntry.getName() + " size=" + zipEntry.getSize() + " bytes");
				}
		
				if (outputFileName.isEmpty())
				{
					outputFileName = zipEntry.getName(); // first found .x3d file in .zip
					System.out.println ("Warning: fromFileZIP() outputFileName was empty, unzipping found initial X3D file to save: " + outputFileName);
				}
				if (modelFileName.isEmpty() && (zipEntry.getName().endsWith(FILE_EXTENSION_X3D) ||
                                                zipEntry.getName().endsWith(FILE_EXTENSION_XML)))
				{
					modelFileName = zipEntry.getName(); // first found .x3d file in .zip
					System.out.println ("Warning: fromFileZIP() modelFileName was empty, unzipping found initial X3D file to load: " + modelFileName);
				}
				File priorFile = new File(outputFileName);
				if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
				{
					System.out.println ("Warning: fromFileZIP() is overwriting prior file " + outputFileName);
				}
				else if  (priorFile.exists())
				{
					System.out.println ("Warning: fromFileZIP() is not allowed to overwrite prior file: " + outputFileName);
					System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
					return false;
				}
				// TODO add optional output directory path
				FileOutputStream fileOutputStream = new FileOutputStream (outputFileName);
				for (int c = zipInputStream.read(); c != -1; c = zipInputStream.read())
				{
					fileOutputStream.write(c);
				}
				zipInputStream.closeEntry();
				fileOutputStream.close();
				System.out.println ("Unzipped " + outputFileName + " size=" + zipEntry.getSize() + " bytes");
			}
			zipInputStream.close();

			if (modelFileName.isEmpty())
			{
				System.out.println ("fromZIP output modelFileName not found in zipFileName " + zipFileName + ", no X3D model to load");
				return false;
			}
										
			X3DLoaderObject x3dLoader = new X3DLoaderObject();
			boolean x3dLoaderSuccess = x3dLoader.loadModelFromFileX3D(modelFileName);
			if (x3dLoaderSuccess)
				replace((X3DObject) x3dLoader.getX3dObjectTree());
		}
		catch (IOException e)
		{
			errorNotice += "zipFileName " + zipFileName + "not readable\n";
			System.out.println (errorNotice);
			return false;
		}
		return hasHead() || hasScene(); // success test
	}
									
	/**
	 * Load new model from a gz gzip file, using ungzip to extract the model into the same path location.
	 * <br ><br >
	 * <i>Warning:</i> this method overwrites any previously existing file versions when decompressing.
	 * @see <a href="https://en.wikipedia.org/wiki/Gzip">Wikipedia: GZIP file format</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/package-summary.html">Java Package java.util.zip for ZIP and GZIP file formats</a>
	 * @see X3DObject#FILE_EXTENSION_EXI
	 * @see X3DObject#FILE_EXTENSION_GZIP
	 * @see X3DObject#FILE_EXTENSION_ZIP
	 * @see X3DObject#fromFileEXI(String)
	 * @see X3DObject#fromFileZIP(String,String)
	 * @see X3DObject#toFileGZIP(String)
	 * @param gzipFileName name of file to load, can include local directory path, must end with .exi
	 * @return boolean if operation succeeds in creating this X3DObject, false otherwise
	 */
    public boolean fromFileGZIP(String gzipFileName)
	{
		String errorNotice = new String();
		if ((gzipFileName == null || gzipFileName.isEmpty()))
		{
			throw new X3DException("fromFileGZIP(gzipFileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_GZIP + "\"");
		}
		if (!gzipFileName.endsWith(FILE_EXTENSION_GZIP))
		{
			errorNotice += ("gzipFileName " + gzipFileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_GZIP + "\"" + "\n");
		}
		Path inputFilePath = Paths.get(gzipFileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] gzipFileName path=" + inputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		// Elliotte Rusty Harold, "Java I/O" Chapter 10 Compressing Streams, O'Reilly and Associates, 2nd edition, May 2006.
		// Example 10-11, adapted
		
		File gzipFile = new File(gzipFileName);
		if (!gzipFile.exists() || (gzipFile == null))
		{
			errorNotice += "gzipFileName " + gzipFileName + "not found\n";
			System.out.println (errorNotice);
			return false;
		}
		String modelFileName = gzipFileName;
		if (modelFileName.contains(FILE_EXTENSION_GZIP))
			modelFileName = modelFileName.substring(0, modelFileName.lastIndexOf(FILE_EXTENSION_GZIP));
		if (!modelFileName.endsWith (FILE_EXTENSION_X3D))
			 modelFileName += FILE_EXTENSION_X3D;
		if ( modelFileName.isEmpty())
			 return false;
		System.out.println ("  fromFileGZIP() output modelFileName " + modelFileName);
		File priorFile = new File(modelFileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Warning: fromFileGZIP() is overwriting prior file " + modelFileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("Warning: fromFileGZIP() is not allowed to overwrite prior file: " + modelFileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return false;
		}
		try
		{
			FileInputStream fileInputStream = new FileInputStream(gzipFile);
			GZIPInputStream gzipInputStream = new GZIPInputStream(fileInputStream);
			
			if (ConfigurationProperties.isDebugModeActive())
			{
				System.out.println ("gunzipping " + gzipFile);
			}
			// TODO add optional output directory path
			FileOutputStream fileOutputStream = new FileOutputStream (modelFileName);
			for (int c = gzipInputStream.read(); c != -1; c = gzipInputStream.read())
			{
				fileOutputStream.write(c);
			}
			gzipInputStream.close();
			fileOutputStream.close();
			File decompressedFile = new File(modelFileName);
			System.out.println ("gunzipped " + decompressedFile.getPath() + " size=" + decompressedFile.length() + " bytes");
										
			X3DLoaderObject x3dLoader = new X3DLoaderObject();
			boolean x3dLoaderSuccess = x3dLoader.loadModelFromFileX3D(modelFileName);
			if (x3dLoaderSuccess)
				replace((X3DObject) x3dLoader.getX3dObjectTree());
		}
		catch (IOException e)
		{
			errorNotice += "gzipFileName " + gzipFileName + "not readable\n";
			System.out.println (errorNotice);
			return false;
		}
		
		return hasHead() || hasScene(); // success test
	}
									
	/**
	 * Load new model from an EXI file, using unzip to extract the model plus any associated files into the same path location.
	 * TODO OpenEXI version is not yet implemented!
	 * <br ><br >
	 * <i>Warning:</i> this method overwrites any previously existing file versions when decompressing.
	 * @see <a href="https://openexi.sourceforge.net/tutorial/index.html">OpenEXI Nagasena Tutorial</a>
	 * @see <a href="https://exificient.github.io/java">EXIFICIENT Java Implementations</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Efficient_XML_Interchange">Wikipedia: Efficient XML Interchange (EXI) file format</a>
	 * @see ConfigurationProperties#getExiEngine()
	 * @see ConfigurationProperties#setExiEngine(String)
	 * @see X3DObject#FILE_EXTENSION_EXI
	 * @see X3DObject#FILE_EXTENSION_GZIP
	 * @see X3DObject#FILE_EXTENSION_ZIP
	 * @see X3DObject#toFileEXI(String)
	 * @see X3DObject#fromFileZIP(String,String)
	 * @see X3DObject#fromFileGZIP(String)
	 * @param exiFileName name of file to load, can include local directory path, must end with .exi
	 * @return boolean if operation succeeds in creating this X3DObject, false otherwise
	 */
    public boolean fromFileEXI(String exiFileName)
	{
		String errorNotice = new String();
		if ((exiFileName == null || exiFileName.isEmpty()))
		{
			throw new X3DException("fromFileEXI(exiFileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_EXI + "\"");
		}
		if (!exiFileName.endsWith(FILE_EXTENSION_EXI))
		{
			errorNotice += ("exiFileName " + exiFileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_EXI + "\"" + "\n");
		}
		File priorFile = new File(exiFileName);
		if  (priorFile.exists() && ConfigurationProperties.isOverwriteExistingFiles())
		{
			System.out.println ("Warning: fromFileEXI() is overwriting prior file " + exiFileName);
		}
		else if  (priorFile.exists())
		{
			System.out.println ("Warning: fromFileEXI() is not allowed to overwrite prior file: " + exiFileName);
			System.out.println ("  see X3DJSAIL.properties file, or ConfigurationProperties.isOverwriteExistingFiles() and .setOverwriteExistingFiles(), to get/set permissions");
			return false;
		}

		Path inputFilePath = Paths.get(exiFileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] exiFileName path=" + inputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		if (ConfigurationProperties.getExiEngine().equals(ConfigurationProperties.EXI_ENGINE_EXIFICIENT))
		{
			try
			{
				/*
				*  Setup EXIFactory as required
				*/
				EXIFactory exiFactory = DefaultEXIFactory.newInstance();
				// e.g., add additional settings beyond the default values
				// TODO separate string constants for schema addresses
				// TODO use local copy of schema rather than online; is identifier needed for consistency?
				// TODO can the grammar be precompiled and cached in X3DJSAIL library?
				// TODO is a grammar needed for file reading?
				if (exificientGrammarX3D == null) // only needed once, avoid recomputation
					exificientGrammarX3D = GrammarFactory.newInstance().createGrammars("http://www.web3d.org/specifications/x3d-3.3.xsd"); // use XML schema
				exiFactory.setGrammars(exificientGrammarX3D);
				exiFactory.setCodingMode(CodingMode.COMPRESSION); // use deflate compression for larger XML files

				/*
				 *  decode EXI to XML
				 */
				String xmlFileName = "temp.exiInputTransformed.x3d"; // XML output again
				Result result = new StreamResult(xmlFileName);
				InputSource is = new InputSource(exiFileName);
				SAXSource exiSource = new EXISource(exiFactory);
				exiSource.setInputSource(is);
				TransformerFactory tf = TransformerFactory.newInstance();
				Transformer transformer = tf.newTransformer();
				transformer.transform(exiSource, result);
				File decompressedFile = new File(xmlFileName);
				System.out.println ("gunzipped " + decompressedFile.getPath() + " size=" + decompressedFile.length() + " bytes");
				
				X3DLoaderObject x3dLoader = new X3DLoaderObject();
				boolean x3dLoaderSuccess = x3dLoader.loadModelFromFileX3D(xmlFileName);
				if (x3dLoaderSuccess)
					replace((X3DObject) x3dLoader.getX3dObjectTree());
					
				// TODO someday: efficiently parse as X3D, rather than using string-based methods
			}
			catch (EXIException | TransformerException ex)
			{
				System.out.println (ex.getMessage());
				ex.printStackTrace();
				return false;
			}
		}
		else if (ConfigurationProperties.getExiEngine().equals(ConfigurationProperties.EXI_ENGINE_OPENEXI)) // Nagasena
		{
			/*
			try
			{
				// TODO code block

				// TODO someday: efficiently parse as X3D, rather than using string-based methods
			}
			catch (Exception ex)
			{
				System.out.println (ex.getMessage());
				ex.printStackTrace();
				return false;
			}
			*/
		}
		else
		{
			errorNotice = ConfigurationProperties.ERROR_CONFIGURATION_X3DJSAIL + " illegal value \"" + ConfigurationProperties.getExiEngine() 
							+ "\" found for ConfigurationProperties.getExiEngine()\n"
							+ "   allowed values are ConfigurationProperties.EXI_ENGINE_EXIFICIENT and ConfigurationProperties.EXI_ENGINE_OPENEXI" ;
			if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
			{
				errorNotice += "[debug] exiFileName path=" + inputFilePath.toAbsolutePath() + "\n";
			}
			System.out.println (errorNotice);
			throw new InvalidFieldValueException(errorNotice);
		}
		return hasHead() || hasScene(); // success test
	}
											
	/** Determine if this X3D model is empty and no content is present.
	 * @return true if no head and no Scene found, otherwise false
	 */
	public boolean isEmpty()
	{
		return !(hasHead() || hasScene()); 
	}
											
	/** Load X3D model from file to initialize or replace contents of this X3DObject.
	 * Supports .x3d or .xml file encodings.
	 * @param fileName name of model file that replaces current X3DObject
	 * @return true if replacement successful, false otherwise
	 */
	public boolean loadModelFromFileX3D (String fileName)
	{
		File x3dFile = new File(fileName);
		
		if (!x3dFile.exists())
		{
			throw new X3DException("fileName " + fileName + " does not exist and cannot be loaded, check path and filename.");
		}
		return loadModelFromFileX3D (x3dFile);
	}
											
	/** Load X3D model from file to initialize or replace contents of this X3DObject.
	 * Supports .x3d or .xml file encodings.
	 * @param x3dFile model file that replaces current X3DObject
	 * @return true if replacement successful, false otherwise
	 */
	public boolean loadModelFromFileX3D (File x3dFile)
	{
				X3DLoaderObject x3dLoader = new X3DLoaderObject();
				boolean x3dLoaderSuccess = x3dLoader.loadModelFromFileX3D(x3dFile);
				if  (x3dLoaderSuccess)
					 return replace((X3DObject) x3dLoader.getX3dObjectTree());
				else return false;
	}
										
	/** Replaces current X3DObject with new X3DObject. 
	 * @param newX3DObject replaces current X3DObject
	 * @return true if replacement successful, false otherwise
	 */
	public boolean replace (X3DObject newX3DObject)
	{
		if (newX3DObject == null)
			return false;
		setHead (newX3DObject.getHead());
		setScene(newX3DObject.getScene());
		return true;
	}								
	/**
	 * Save current model as an EXI file.  TODO not yet implemented!
	 * @see <a href="https://openexi.sourceforge.net/tutorial/index.html">OpenEXI Nagasena Tutorial</a>
	 * @see ConfigurationProperties#getExiEngine()
	 * @see ConfigurationProperties#setExiEngine(String)
	 * @see X3DObject#FILE_EXTENSION_EXI
	 * @see X3DObject#FILE_EXTENSION_GZIP
	 * @see X3DObject#FILE_EXTENSION_ZIP
	 * @see X3DObject#fromFileEXI(String)
	 * @see X3DObject#toFileGZIP(String)
	 * @see X3DObject#toFileZIP(String,String)
	 * @see X3DObject#toFileX3D(String)
	 * @param resultFileName name of file to create and save, can include local directory path, must end with .exi
	 * @return File containing result (if operation succeeds), null otherwise
	 */
    public File toFileEXI(String resultFileName)
	{
		String errorNotice = new String();
		if ((resultFileName == null || resultFileName.isEmpty()))
		{
			throw new X3DException("toFileJava(resultFileName) fileName not provided;" +
				" be sure to end with extension \"" + FILE_EXTENSION_EXI + "\"");
		}
		if (!resultFileName.endsWith(FILE_EXTENSION_EXI))
		{
			throw new X3DException("resultFileName " + resultFileName + " does not end with extension " +
                            "\"" + FILE_EXTENSION_EXI + "\"");
		}
		Path outputFilePath = Paths.get(resultFileName);
		if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
		{
			errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			System.out.println (errorNotice);
		}
		File   newXmlFile = toFileX3D(resultFileName + ".temp.x3d");
		newXmlFile.deleteOnExit();
		String exiFileName = resultFileName;
		if   (!exiFileName.endsWith(FILE_EXTENSION_EXI))
		{
			exiFileName += FILE_EXTENSION_EXI;
			System.out.println (resultFileName + " changed to " + exiFileName);
		}
		File newExiFile = new File(exiFileName);
		// TODO convert this to an .exi file

		if (ConfigurationProperties.getExiEngine().equals(ConfigurationProperties.EXI_ENGINE_EXIFICIENT))
		{
			try
			{
				/*
				*  Setup EXIFactory as required
				*/
				EXIFactory exiFactory = DefaultEXIFactory.newInstance();
				// e.g., add additional settings beyond the default values
				// TODO separate string constants for schema addresses
				// TODO use local copy of schema rather than online; is identifier needed for consistency?
				// TODO can the grammar be precompiled and cached in X3DJSAIL library?
				if (exificientGrammarX3D == null) // only needed once, avoid recomputation
					exificientGrammarX3D = GrammarFactory.newInstance().createGrammars("http://www.web3d.org/specifications/x3d-3.3.xsd"); // use XML schema
				exiFactory.setGrammars(exificientGrammarX3D);
				exiFactory.setCodingMode(CodingMode.COMPRESSION); // use deflate compression for larger XML files

			   /*
				*  encode XML to EXI
				*/
				OutputStream osEXI = new FileOutputStream(exiFileName);
				EXIResult exiResult = new EXIResult(exiFactory);
				exiResult.setOutputStream(osEXI);
				XMLReader xmlReader = XMLReaderFactory.createXMLReader();
				xmlReader.setContentHandler(exiResult.getHandler());
				// TODO why doesn't have a parse(File) method? seems inefficient to use path
	//			xmlReader.parse(newXmlFile); // parse XML input
				xmlReader.parse(newXmlFile.getAbsolutePath()); // parse XML input
				osEXI.close(); // all done, close stream and file
			} 
			catch (SAXException | IOException | EXIException ex)
			{
				System.out.println (ex.getMessage());
				ex.printStackTrace();
				// not rethrown
			}
		}
		else if (ConfigurationProperties.getExiEngine().equals(ConfigurationProperties.EXI_ENGINE_OPENEXI)) // Nagasena
		{
/*
			// reference EncodeEXI.java from Nagasena tutorial

			FileInputStream   in = null;
			FileOutputStream out = null;
			GrammarCache grammarCache;

			try {

				// Encoding always requires the same steps.

				// 1. Instantiate a Transmogrifier
				Transmogrifier transmogrifier = new Transmogrifier();

				// 2. Initialize the input and output streams.
				in = new FileInputStream(sourceFile);
				out = new FileOutputStream(destinationFile);

				// 3. Create a Grammar Cache. This example uses default options and no schema.
				grammarCache = new GrammarCache((EXISchema)null, GrammarOptions.DEFAULT_OPTIONS);

				// 4. Set the configuration options in the Transmogrifier. Later examples will show more possible settings.
				transmogrifier.setGrammarCache(grammarCache);

				// 5. Set the output stream.
				transmogrifier.setOutputStream(out);

				// 6. Encode the input stream.
				transmogrifier.encode(new InputSource(in));
			}
			// 7.  Verify that the streams are closed.
			finally {
				if (in != null)
					in.close();
				if (out != null)
					out.close();
			}
*/
		}
		else
		{
			errorNotice = ConfigurationProperties.ERROR_CONFIGURATION_X3DJSAIL + " illegal value \"" + ConfigurationProperties.getExiEngine() 
							+ "\" found for ConfigurationProperties.getExiEngine()\n"
							+ "   allowed values are ConfigurationProperties.EXI_ENGINE_EXIFICIENT and ConfigurationProperties.EXI_ENGINE_OPENEXI" ;
			if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
			{
				errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
			}
			System.out.println (errorNotice);
			throw new InvalidFieldValueException(errorNotice);
		}
		return newExiFile;
	}
										
	/**
	 * Save current model as a GZIP file.
	 * @see <a href="https://openexi.sourceforge.net/tutorial/index.html">OpenEXI Nagasena Tutorial</a>
	 * @see X3DObject#FILE_EXTENSION_EXI
	 * @see X3DObject#FILE_EXTENSION_GZIP
	 * @see X3DObject#FILE_EXTENSION_ZIP
	 * @see X3DObject#toFileEXI(String)
	 * @see X3DObject#toFileZIP(String,String)
	 * @see X3DObject#toFileX3D(String)
	 * @param resultFileName name of file to create and save, can include local directory path, must end with .gz (TODO or .tgz)
	 * @return File containing result (if operation succeeds), null otherwise
	 */
    public File toFileGZIP(String resultFileName)
	{
		File resultFile = new File (resultFileName);
		try
		{
			FileOutputStream fos  = new FileOutputStream(resultFile);
			GZIPOutputStream gzos = new GZIPOutputStream (fos);
			gzos.write(toStringX3D().getBytes());
			gzos.close();
		}
		catch (IOException ioe)
		{
			System.out.println (ioe.getMessage());
			ioe.printStackTrace();
		}
		return resultFile;
	}
										
	/**
	 * Save current model as a ZIP file.
	 * @see <a href="https://openexi.sourceforge.net/tutorial/index.html">OpenEXI Nagasena Tutorial</a>
	 * @see X3DObject#FILE_EXTENSION_EXI
	 * @see X3DObject#FILE_EXTENSION_GZIP
	 * @see X3DObject#FILE_EXTENSION_ZIP
	 * @see X3DObject#toFileEXI(String)
	 * @see X3DObject#toFileGZIP(String)
	 * @see X3DObject#toFileX3D(String)
	 * @param zipFileName name of zip archive file to create and save, can include local directory path, must end with .zip
	 * @param modelName name of X3D file to create and save within the .zip archive
	 * @return File containing result (if operation succeeds), null otherwise
	 */
    public File toFileZIP(String zipFileName, String modelName)
	{
		File resultFile = new File (zipFileName);
		try
		{
			FileOutputStream fos = new FileOutputStream(resultFile);
			ZipOutputStream  zos = new ZipOutputStream (fos);
			zos.setMethod(ZipOutputStream.DEFLATED); // matches java default
			zos.setLevel(Deflater.BEST_COMPRESSION);
			zos.setComment("Created by " + ConfigurationProperties.NAME_X3DJSAIL + " " + ConfigurationProperties.URL_X3DJSAIL);
			ZipEntry         ze  = new ZipEntry(modelName);
			zos.putNextEntry(ze);
			zos.write(toStringX3D().getBytes());
			zos.close();
		}
		catch (IOException ioe)
		{
			System.out.println (ioe.getMessage());
			ioe.printStackTrace();
		}
		return resultFile;
	}
										
  /** Provide thorough X3DJSAIL validation results for this X3D model.
   * @return "success" or validation results plus exception information (if any)
   */
  public String validationReport()
  {
	String       metaResult = new String();
	String validationResult = new String();
	String  exceptionResult = new String();
	try
	{
		initialize();
										
		if (getHead() != null)
		{
			// first list informational meta elements of interest
			for (metaObject meta : getHead().getMetaList())
			{
				if (meta.getName().equals(metaObject.NAME_ERROR) ||
					meta.getName().equals(metaObject.NAME_WARNING) ||
					meta.getName().equals(metaObject.NAME_HINT) ||
					meta.getName().equals(metaObject.NAME_INFO) ||
					meta.getName().equals(metaObject.NAME_TODO))
				{
					metaResult += meta.toStringX3D();
				}
			}
		}
		validationResult += validate(); // walk entire tree to validate correctness
	}
	catch (Exception e)
	{
		exceptionResult = e.getMessage(); // report exception failures, if any
	    if (exceptionResult == null)
	    {
			exceptionResult = "Exception caught but null message!";
			e.printStackTrace();
	    }
	}
	if  (metaResult.isEmpty() && exceptionResult.isEmpty() && validationResult.isEmpty())
	     return "success";
	else
	{
		if (!metaResult.isEmpty())
			metaResult = "\n" + metaResult; // easier to read
		String returnMessage = metaResult;
		if  (!exceptionResult.isEmpty() && !validationResult.isEmpty())
			returnMessage += "\n*** ";
		returnMessage += exceptionResult;
		if  (exceptionResult.isEmpty() && !validationResult.isEmpty())
			returnMessage = "\n" + returnMessage; // skip line before meta tags, etc.
		returnMessage += validationResult;
		return returnMessage;
	}
  }
										
	/** Utility method for standalone programs that get created with stylesheet X3dToJava.xslt,
	 * also sets loaded X3D model in global CommandLine to this X3DObject.
	 * Invocation switches are listed in CommandLine.USAGE help.
	 * @see org.web3d.x3d.jsail.CommandLine
	 * @see org.web3d.x3d.jsail.CommandLine#USAGE
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJava.xslt" target="_blank">X3dToJava.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.java" target="_blank">examples/HelloWorldProgramOutput.java</a>
	 * @param args command-line arguments
	 */
	public void handleArguments(String[] args)
	{
		String fileName = new String();
		File   newFile;

		CommandLine.setLoadedX3dModel(this); // initialize using this object

		CommandLine.run(args);
	}
]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'X3DConcreteElement')">
									<xsl:value-of select="$protectedPreamble"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[
	private X3DConcreteElement parentObject = null; // X3D node or statement
										
	/**
	 * Provide object reference to parent X3D node or statement, if any.
	 * This reference is named "parentObject" rather than "parent" to avoid potential name collision with any X3D field named "parent".
	 * @return object reference to parent X3D node or statement, otherwise null if none
	 */			
	public X3DConcreteElement getParentObject()
	{
		return parentObject;
	}
										
	/**
	 * Package-internal method to set parent object reference.
	 * @param newParentObject object reference to parent node or X3D statement that contains this node
	 */			
	public void setParentObject(X3DConcreteElement newParentObject)
	{
		parentObject = newParentObject;
	}
										
	/**
	 * Package-protected internal method to clear local reference to parent object, if any.
	 */			
	public void clearParentObject()
	{
		setParentObject(null);
	}

	/**
	 * Find object reference to ancestor Scene element, assumes this object is an attached child.
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see #hasAncestorX3DObject()
	 * @see X3DConcreteElement#findAncestorX3DObject()
	 * @return ancestor Scene child reference if attached, otherwise null
	 */
	public SceneObject findAncestorSceneObject()
	{
		if ((this instanceof org.web3d.x3d.sai.Core.X3DNode) && ((X3DNode)this) instanceof org.web3d.x3d.jsail.Core.SceneObject)
			return (SceneObject)((X3DNode)this);
		X3DConcreteElement element = this.getParentObject();
		while (element != null)
		{
			if (element instanceof org.web3d.x3d.jsail.Core.SceneObject)
				 return (SceneObject)element;
			else element = element.getParentObject(); // walk up the tree to top, then back down to Scene
		}
		return null; // not found
	}
	/**
	 * Determine whether ancestor Scene element is found, meaning this object is an attached child.
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see #hasAncestorX3DObject()
	 * @see X3DConcreteElement#findAncestorX3DObject()
	 * @return whether ancestor Scene node is found
	 */
	public boolean hasAncestorSceneObject()
	{
		return (findAncestorSceneObject() != null);
	}

	/**
	 * Find object reference to ancestor element (i.e. node or statement), if this object is an attached child.
	 * @param ancestorElementName elementName of ancestor of interest (e.g. first Transform)
	 * @return ancestor node reference if attached and found, otherwise null
	 */
	public X3DConcreteElement findAncestorElementByName(String ancestorElementName)
	{
		if (this.getElementName().equals(ancestorElementName))
			return this;
		X3DConcreteElement element = this.getParentObject();
		while (element != null)
		{
			if (element.getElementName().equals(ancestorElementName))
				 return element;
			else element = element.getParentObject(); // walk up the tree to top
		}
		return null; // not found
	}
	/**
	 * Determine whether ancestor element (i.e. node or statement) is found, meaning this object is an attached child.
	 * @param ancestorElementName elementName of ancestor of interest (e.g. first Transform)
	 * @see #findAncestorProtoBody()
	 * @return whether ancestor element is found
	 */
	public boolean hasAncestorElementByName(String ancestorElementName)
	{
		return (findAncestorElementByName(ancestorElementName) != null);
	}

	/**
	 * Find object reference to ancestor ProtoBody, if this node or statement is a child.
	 * @see #hasAncestorProtoBody()
	 * @return ancestor ProtoBodyObject reference if attached and found, otherwise null
	 */
	public ProtoBodyObject findAncestorProtoBody()
	{
		return (ProtoBodyObject) findAncestorElementByName(ProtoBodyObject.NAME);
	}
	/**
	 * Determine whether ancestor ProtoBody element is found, meaning this object is an attached child.
	 * @see #findAncestorProtoBody()
	 * @return whether ancestor ProtoBody element is found
	 */
	public boolean hasAncestorProtoBody()
	{
		return (findAncestorProtoBody() != null);
	}
										
	/**
	 * Find object reference to ancestor X3D element, if this node or statement is part of an X3DObject model.
	 * @see #hasAncestorX3DObject()
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @return ancestor X3D reference if attached, otherwise null
	 */	
	public X3DObject findAncestorX3DObject()
	{
		if (((X3DNode)this) instanceof org.web3d.x3d.jsail.Core.X3DObject)
			return (X3DObject)((X3DNode)this);
		X3DConcreteElement element = this.getParentObject();
		while (element != null)
		{
			if (element instanceof org.web3d.x3d.jsail.Core.X3DObject)
				 return (X3DObject)element;
			else element = element.getParentObject(); // walk up the tree to top
		}
		return null; // not found
	}
	/**
	 * Determine whether ancestor X3D element is found, meaning this object is an attached child.
	 * @see X3DConcreteElement#findAncestorX3DObject()
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @return whether ancestor X3D element is found
	 */
	public boolean hasAncestorX3DObject()
	{
		return (findAncestorX3DObject() != null);
	}
										
	/** Provides name of this element.
	 * @return name of this element
	 */
	abstract public String getElementName(); // must be overridden (static methods cannot be abstract)
										
	/** Defines X3D component for this element.
	 * @return X3D component for this element
	 */
	abstract public String getComponent(); // must be overridden (static methods cannot be abstract)
										
	/** Provides default X3D component level for this element
	 * @return default X3D component level for this element
	 */
	abstract public int getComponentLevel(); // must be overridden (static methods cannot be abstract)

	/** Indicate type corresponding to given fieldName.
	 * @param fieldName name of field in this X3D statement
	 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_TYPE
	 * @return X3D type (SFvec3f etc.), otherwise ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE if not recognized
	 */			
	abstract public String getFieldType(String fieldName); // must be overridden
										
	/** Indicate accessType corresponding to given fieldName.
	 * @param fieldName name of field in this X3D statement
	 * @see ConfigurationProperties#ERROR_UNKNOWN_FIELD_TYPE
	 * @return X3D accessType (inputOnly etc.), otherwise ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE if not recognized
	 */			
	abstract public String getAccessType(String fieldName); // must be overridden
										
	/**
	 * Recursive method to provide object reference to node or statement by name attribute, if found as part of this element or in a contained element.
	 * Elements with name fields include meta, Metadata* nodes, field/fieldValue, ProtoDeclare/ExternProtoDeclare/ProtoInstance, HAnim nodes.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorSceneObject() to check entire scene graph, or findAncestorX3DObject() to check entire model document.
	 * <br ><br >
	 * @see #findNodeByDEF(String)
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3DObject()
	 * @see metaObject
	 * @see MetadataStringObject
	 * <i>Warning:</i> more than one element may be found that has the same name, this method does not handle that case.
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @param elementName identifies the element of interest (meta MetadataString ProtoDeclare CADassembly ProtoInstance HAnimHumanoid etc.)
	 * @return object reference to found element, null otherwise
	 */
	abstract public X3DConcreteElement findElementByNameValue(String nameValue, String elementName); // required interface
										
	/**
	 * Recursive method to provide object reference to node or statement by name attribute, if found as part of this element or in a contained element.
	 * Elements with name fields include meta, Metadata* nodes, field/fieldValue, ProtoDeclare/ExternProtoDeclare/ProtoInstance, HAnim nodes.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorSceneObject() to check entire scene graph, or findAncestorX3DObject() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same name, this method does not handle that case.
	 * @see #findNodeByDEF(String)
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3DObject()
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @return object reference to found element, null otherwise
	 */
	abstract public X3DConcreteElement findElementByNameValue(String nameValue); // required interface
										
	/**
	 * Recursive method to provide object reference to node by DEF, if found as this node or in a contained node.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorSceneObject() to check entire scene graph, or findAncestorX3DObject() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same DEF, this method does not handle that case.
	 * @see #findElementByNameValue(String)
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3DObject()
	 * @param DEFvalue is value of the name field being searched for in this element and child elements(if any)
	 * @return object reference to found node, null otherwise
	 */
	abstract public X3DConcreteNode findNodeByDEF(String DEFvalue); // required interface
										
	/** Provide fully qualified package for a given element object, including className.  Helpful for reflection.
	 * @param className X3D statement or node of interest
	 * @return fully qualified package for className
	 */
	static public String getPackageName(String className)
	{
		if (className.contains("Object"))
		    className = className.substring(0,className.indexOf("Object"));
		switch (className)
		{]]></xsl:text>
									<!-- node sequence catenation! 8) -->
									<xsl:for-each select="//ConcreteNodes/ConcreteNode, //Statements/Statement">
										<xsl:text>
			case "</xsl:text>
										<xsl:value-of select="@name"/>
										<xsl:text>":
				return "org.web3d.x3d.jsail.</xsl:text>
										<xsl:value-of select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
										<xsl:text>.</xsl:text>
										<xsl:value-of select="@name"/>
										<xsl:text>Object";</xsl:text>
									</xsl:for-each>
									<xsl:text>
			default:
				return "UnknownClassName_" + className;
		}
	}
</xsl:text>
								</xsl:when>
								<!--
								<xsl:when test="($name = 'X3DConcreteNode') or 
												(($isInterface = 'true') and (($name = 'ProtoBody') or ($name = 'Scene')))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide object reference to node by DEF name, found either as this node or in a contained node (if any).
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorSceneObject() to check entire scene graph, or findAncestorX3DObject() to check entire model document.
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3DObject()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findElementByNameValue(String,String)
	 * @param DEFlabel DEF name of node to find
	 * @return object reference to node
	 */
	abstract public X3DConcreteNode getNodeByDEF(String DEFlabel); // required interface
]]></xsl:text>
								</xsl:when>
								-->
							</xsl:choose>
						</xsl:when>
					</xsl:choose>
					<!-- ===================================================== -->
					<!-- Source code: accessor methods -->

					<xsl:for-each select="InterfaceDefinition/field[not(starts-with(@name,'set'))]"> <!-- TODO check filtering is consistently effective -->

						<xsl:if test="position()=1">
							<xsl:text>&#10;</xsl:text>
							<xsl:text>	// ==== Accessor methods: strongly typed get/set methods for compile-time strictness</xsl:text>
							<xsl:text>&#10;</xsl:text>
							<xsl:text>&#10;</xsl:text>
						</xsl:if>
						<xsl:variable name="isX3dStatement">
							<xsl:call-template name="isX3dStatement">
								<xsl:with-param name="name" select="@name"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:variable name="isX3dStatement">
							<xsl:call-template name="isX3dStatement">
								<xsl:with-param name="name" select="@name"/>
							</xsl:call-template>
						</xsl:variable>
						<!-- TODO why are duplicate field definitions in X3D Object Model? likely due to duplicate entries in appinfo and content model, e.g. LOD, ParticleSystems-->
						<xsl:variable name="fieldName" select="@name"/>

						<!-- avoid duplicates, avoid statement accessors for interfaces -->
						<xsl:if test="not(preceding-sibling::*[@name = $fieldName]) and not(($isInterface = 'true') and ($isX3dStatement = 'true'))">
							<xsl:variable name="javaType">
								<xsl:call-template name="javaType">
									<xsl:with-param name="x3dType" select="@type"/>
									<xsl:with-param name="isInterface" select="$isInterface"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="javaPrimitiveType">
								<xsl:call-template name="javaType">
									<xsl:with-param name="x3dType" select="@type"/>
									<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="javaReferenceType">
								<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
							</xsl:variable>
							<xsl:variable name="isArrayType">
								<!-- TODO remove restrictions when ArrayList types added -->
								<xsl:value-of select="starts-with(@type,'MF') and not(contains(@type,'Color') or contains(@type,'Vec') or contains(@type,'Rotation') or contains(@type,'Matrix')) and contains($javaType,'[]')"/>
							</xsl:variable>
							<xsl:variable name="isArrayListType">
								<xsl:value-of select="contains($javaType,'&lt;')"/>
							</xsl:variable>
							<xsl:variable name="tooltipText">
								<xsl:value-of select="$x3d.tooltips.document//element[@name = $name]/attribute[@name = $fieldName]/@tooltip" disable-output-escaping="yes"/>
							</xsl:variable>
							<xsl:variable name="fieldTooltip">
								<xsl:if test="(string-length(normalize-space($tooltipText)) > 0)"><!-- doc-available($x3d.tooltips.path) -->
									<xsl:value-of select="replace(replace($tooltipText,'&#8734;','infinity'),'&#960;','pi')" disable-output-escaping="yes"/>
									<!-- consistent javadoc punctuation -->
									<xsl:if test="not(ends-with(normalize-space($tooltipText),'.')) and not(contains($tooltipText,'http')) and not(contains($tooltipText,'mailto')) and not(contains($tooltipText,'ftp'))">
										<xsl:text>.</xsl:text>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:variable name="x3dType" select="@name"/>

							<!-- javadoc from BuildSpecificationLanguageBindingJava.xslt-->
							<xsl:variable name="type">
								<xsl:value-of select="@type"/>
							</xsl:variable>
							<xsl:variable name="isEnumerationType" select="(count(enumeration) > 0)"/>
							<xsl:variable name="tupleNess">
								<xsl:choose>
									<xsl:when test="contains($type,'FVec2')">
										<xsl:text>2-tuple </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'FVec3') or ends-with($type,'FColor') or (@baseType='boundingBoxSizeType')">
										<xsl:text>3-tuple </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'FVec4') or ends-with($type,'FRotation') or contains($type,'FColorRGBA')">
										<xsl:text>4-tuple </xsl:text>
									</xsl:when>
									<xsl:when test="starts-with($type,'MF')">
										<!-- <xsl:text>1-tuple </xsl:text> -->
									</xsl:when>
								</xsl:choose>
							</xsl:variable>

<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
	<xsl:text>*** @name=</xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:text>, $type=</xsl:text>
	<xsl:value-of select="$type"/>
	<xsl:text>, $tupleNess=</xsl:text>
	<xsl:value-of select="$tupleNess"/>
	<xsl:text>, $name=</xsl:text>
	<xsl:value-of select="$name"/>
</xsl:message>
</xsl:if>

							<xsl:variable name="enumerationValues">
								<xsl:for-each select="enumeration">
									<xsl:text>"</xsl:text>
									<xsl:value-of select="@value"/>
									<xsl:text>"</xsl:text>
									<xsl:if test="not(position() = last())">
										<xsl:text>|</xsl:text>
									</xsl:if>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="CamelCaseName"><!-- upper camel case -->
								<xsl:choose>
									<xsl:when test="starts-with(@name,'set_')">
										<xsl:value-of select="translate(substring(substring-after(@name,'set_'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
										<xsl:value-of select="substring(substring-after(@name,'set_'),2)"/>
									</xsl:when>
									<xsl:when test="starts-with(@name,'set')">
										<xsl:value-of select="translate(substring(substring-after(@name,'set'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
										<xsl:value-of select="substring(substring-after(@name,'set'),2)"/>
									</xsl:when>
									<xsl:when test="contains(@name,'_changed')">
										<xsl:value-of select="translate(substring(substring-before(@name,'_changed'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
										<xsl:value-of select="substring(substring-before(@name,'_changed'),2)"/>
									</xsl:when>
									<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
										<!-- unmodified -->
										<xsl:value-of select="@name"/>
									</xsl:when>
									<xsl:when test="(@name = 'class')">
										<!-- getClass() is reserved by Java Object() class -->
										<xsl:text>CssClass</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="translate(substring(@name,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
										<xsl:value-of select="substring(@name,2)"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="memberObjectName"><!-- lower camel case, usually -->
								<xsl:choose>
									<xsl:when test="($isX3dStatement = 'true')">
										<xsl:value-of select="@name"/>
									</xsl:when>
									<xsl:when test="(@name = 'AS')"><!-- special case: IMPORT, EXPORT -->
										<xsl:value-of select="@name"/>
									</xsl:when>
									<xsl:when test="(@name = 'set_boolean')"> <!-- special case: BooleanFilter, BooleanToggle, IntegerTrigger -->
										<xsl:text>booleanField</xsl:text>
									</xsl:when>
									<xsl:when test="(@name = 'set_boolean')"> <!-- special case: BooleanFilter, BooleanToggle, IntegerTrigger -->
										<xsl:text>booleanField</xsl:text>
									</xsl:when>
									<xsl:when test="starts-with(@name,'set_')">
										<xsl:value-of select="translate(substring(substring-after(@name,'set_'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
										<xsl:value-of select="substring(substring-after(@name,'set_'),2)"/>
									</xsl:when>
									<xsl:when test="starts-with(@name,'set')">
										<xsl:value-of select="translate(substring(substring-after(@name,'set'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
										<xsl:value-of select="substring(substring-after(@name,'set'),2)"/>
									</xsl:when>
									<xsl:when test="contains(@name,'_changed')">
										<xsl:value-of select="translate(substring(substring-before(@name,'_changed'),1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
										<xsl:value-of select="substring(substring-before(@name,'_changed'),2)"/>
									</xsl:when>
									<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
										<!-- unmodified -->
										<xsl:value-of select="@name"/>
									</xsl:when>
									<xsl:when test="(@name = 'class')">
										<!-- getClass() is reserved by Java Object() class -->
										<xsl:text>cssClass</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="translate(substring($CamelCaseName,1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')"/>
										<xsl:value-of select="substring($CamelCaseName,2)"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="normalizedMemberObjectName">
								<!-- translate name into legal Java form here to avoid xpath problems -->
								<xsl:value-of select="translate($memberObjectName,'-','_')"/>
								<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
									<xsl:text>List</xsl:text><!-- append to member name -->
								</xsl:if>
							</xsl:variable>

							<!-- TODO create Javadoc matching spec, including reference to (string-length(@acceptableNodeTypes) > 1) -->

							<!-- Source code: provide accessor methods according to accessType ========================= -->

							<!-- get method -->
							<xsl:if test="((@accessType='outputOnly') or (@accessType='initializeOnly') or (@accessType='inputOutput') or (string-length(@accessType) = 0))
										  and ((@name = 'address') or (not(starts-with(@name,'add')) 
										  and not(starts-with(@name,'remove'))
										  and not((@name = 'DEF') or (@name = 'USE') or (@name = 'class'))))">
								<!-- javadoc from BuildSpecificationLanguageBindingJava.xslt-->
								<xsl:text>	/**</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 * Provide </xsl:text>
	<xsl:if test="($debug = 'true')">
	<xsl:text>($javaType=</xsl:text>
	<xsl:value-of select="$javaType"/>
	<xsl:text>, isArrayType=</xsl:text>
	<xsl:value-of select="$isArrayType"/>
	<xsl:text>, isArrayListType=</xsl:text>
	<xsl:value-of select="$isArrayListType"/>
	<xsl:text>, javaPrimitiveType=</xsl:text>
	<xsl:value-of select="$javaPrimitiveType"/>
	<xsl:text>, javaReferenceType=</xsl:text>
	<xsl:value-of select="$javaReferenceType"/>
	<xsl:text>, isX3dStatement=</xsl:text>
	<xsl:value-of select="$isX3dStatement"/>
	<xsl:text>, isClassX3dStatement=</xsl:text>
	<xsl:value-of select="$isClassX3dStatement"/>
	<xsl:text>) </xsl:text>
	</xsl:if>
								<xsl:choose>
									<xsl:when test="contains($javaType,'[]')"><!-- array -->
										<xsl:text>array of </xsl:text>
										<xsl:value-of select="$tupleNess"/>
										<xsl:value-of select="substring-before($javaType,'[]')"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:text> results </xsl:text>
									</xsl:when>
									<xsl:when test="($isArrayListType = 'true')"><!-- boxed type such as ArrayList<String> -->
										<xsl:text>array of </xsl:text>
										<xsl:value-of select="$tupleNess"/>
										<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:text> results </xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$tupleNess"/>
										<xsl:choose>
											<xsl:when test="($name = 'ProtoBody') and (@name = 'children')">
												<xsl:text disable-output-escaping="yes"><![CDATA[ArrayList<X3DNode>]]></xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="$javaType" disable-output-escaping="yes"/><!-- append to type name -->
												<xsl:if test="($isX3dStatement = 'true') and starts-with(@type,'X3D') and (ends-with(@type,'Node') or ends-with(@type,'Object'))">
													<xsl:value-of select="$jsaiInterfaceSuffix"/>
												</xsl:if>
											</xsl:otherwise>
										</xsl:choose>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:choose>
											<xsl:when test="(ends-with(@type,'FNode'))">
												<xsl:text> instance </xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:text> value </xsl:text>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:otherwise>
								</xsl:choose>
								<!-- value restrictions, if any -->
								<xsl:choose>
									<xsl:when test="contains($type,'RGBA')">
										<xsl:text>using RGBA values [0..1] </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'Color')">
										<xsl:text>using RGB values [0..1] </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'otation') or contains(@name,'otation') or contains(@name,'angle') or contains(@name,'Angle')">
										<xsl:text>unit axis, angle (in radians) </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'Time')">
										<xsl:text>in seconds </xsl:text>
									</xsl:when>
									<xsl:when test="($type='SFNode')">
										<xsl:text>(using a properly typed node) </xsl:text>
									</xsl:when>
									<xsl:when test="($type='MFNode')">
										<xsl:text>(using an array consisting of properly typed nodes or X3DPrototypeInstance objects) </xsl:text>
									</xsl:when>
								</xsl:choose>
								<xsl:call-template name="list-restrictions"/>

								<xsl:text>from </xsl:text>
								<xsl:value-of select="@accessType"/>
								<xsl:text> </xsl:text>
								<xsl:value-of select="@type"/>
								<xsl:text> field </xsl:text>
								<xsl:if test="not(ends-with(@type,'FNode'))">
									<xsl:text>named </xsl:text>
								</xsl:if>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:text>.</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:if test="($type='SFNode') and not($isInterface = 'true') and not($isClassX3dStatement = 'true')">
									<xsl:text>	 * @see #get</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>ProtoInstance()</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(string-length($fieldTooltip) > 0)">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;Tooltip:&lt;/i&gt; </xsl:text>
									<xsl:call-template name="bulletize-hints-warnings">
										<xsl:with-param name="tooltipText">
											<xsl:call-template name="wrap-hyperlinks">
												<xsl:with-param name="string">
													<!-- xsl:text> escape-javadoc-characters1 </xsl:text -->
													<xsl:call-template name="escape-javadoc-characters">
														<xsl:with-param name="inputString">
															<xsl:value-of select="normalize-space(substring-after($fieldTooltip,']'))" disable-output-escaping="yes"/>
														</xsl:with-param>
													</xsl:call-template>
												</xsl:with-param>
											</xsl:call-template>
										</xsl:with-param>
									</xsl:call-template>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="((@type='SFString') or (@type='MFString')) and (enumeration) and not($isInterface = 'true')">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Available enumeration values for string comparison: </xsl:text>
									<xsl:for-each select="enumeration">
										<xsl:if test="position() > 1">
											<xsl:text>, </xsl:text>
										</xsl:if>
										<xsl:text>{@link </xsl:text>
										<xsl:text>#</xsl:text>
										<xsl:value-of select="upper-case(../@name)"/>
										<xsl:text>_</xsl:text>
										<!-- enumeration name: omit " character, others become _ underscore -->
										<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
										<xsl:text> </xsl:text>
										<!-- enumeration name: omit " character, others become _ underscore -->
										<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
										<xsl:text>}</xsl:text>
									</xsl:for-each>
									<xsl:text>.</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(@type = 'MFNode') and (string-length(@acceptableNodeTypes) > 1)">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[<i>Warning:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
									<xsl:value-of select="@acceptableNodeTypes"/>
									<xsl:text>.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									
									<xsl:variable name="X3DObjectModelTree" select="/"/>
									<xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
										<xsl:variable name="acceptableNodeType" select="string(.)"/>
										<xsl:text>	 * @see </xsl:text>
										<xsl:variable name="packageName">
											<xsl:choose>
												<xsl:when test="starts-with($acceptableNodeType,'X3D') and contains($acceptableNodeType,'Node')">
													<xsl:text>org.web3d.x3d.sai.</xsl:text>
													<xsl:value-of select="translate($X3DObjectModelTree//AbstractNodeType  [@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
												</xsl:when>
												<xsl:when test="starts-with($acceptableNodeType,'X3D') and contains($acceptableNodeType,'Object')">
													<xsl:text>org.web3d.x3d.sai.</xsl:text>
													<xsl:value-of select="translate($X3DObjectModelTree//AbstractObjectType[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>org.web3d.x3d.jsail.</xsl:text>
													<xsl:value-of select="translate($X3DObjectModelTree//Statements/Statement      [@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:value-of select="translate($X3DObjectModelTree//ConcreteNodes/ConcreteNode[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
													<xsl:text>Object</xsl:text>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<!-- debug trace
										<xsl:message>
											<xsl:text>acceptableNodeType=</xsl:text>
											<xsl:value-of select="$acceptableNodeType"/>
											<xsl:text>, packageName=</xsl:text>
											<xsl:value-of select="$packageName"/>											
										</xsl:message> -->
										<!-- find, insert package name -->
										<xsl:value-of select="$packageName"/>
										<xsl:text>&#10;</xsl:text>
									</xsl:for-each>
								</xsl:if>
								<xsl:if test="(@name = 'metadata')">
									<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:text>	 * @return value of </xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:if test="(@name != 'field')">
									<xsl:text> field</xsl:text>
								</xsl:if>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 */</xsl:text><!-- end javadoc -->
								<xsl:text>&#10;</xsl:text>
<!-- debug comment in source
-->
<xsl:if test="($debug = 'true')">
<xsl:text>// ($isInterface=</xsl:text>
<xsl:value-of select="$isInterface"/>
<xsl:text>, $isException=</xsl:text>
<xsl:value-of select="$isException"/>
<xsl:text>, $isServiceInterface=</xsl:text>
<xsl:value-of select="$isServiceInterface"/>
<xsl:text>, $isX3dStatement=</xsl:text>
<xsl:value-of select="$isX3dStatement"/>
<xsl:text>, $isClassX3dStatement=</xsl:text>
<xsl:value-of select="$isClassX3dStatement"/>
<xsl:text>, preceding-sibling::Inheritance=</xsl:text>
<xsl:value-of select="preceding-sibling::Inheritance"/>
<xsl:text>, $baseType=</xsl:text>
<xsl:value-of select="$baseType"/>
<xsl:text>, $additionalInheritanceBaseType=</xsl:text>
<xsl:value-of select="$additionalInheritanceBaseType"/>
<xsl:text>)</xsl:text>
<xsl:text>&#10;</xsl:text>
</xsl:if>
								<!-- source code: get method -->
								<xsl:if test="(not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')) or
												 (($isInterface = 'true') and //AbstractNodeType  [@name = $baseType                     ]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($isInterface = 'true') and //AbstractNodeType  [@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($isInterface = 'true') and //AbstractObjectType[@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($thisClassName = 'ProtoInstanceObject') and 
												  (($CamelCaseName = 'Metadata') or ($CamelCaseName = 'Name') or ($CamelCaseName = 'DEF') or ($CamelCaseName = 'USE') or ($CamelCaseName = 'CssClass')))">
									<xsl:text>	@Override</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:text>	public </xsl:text>
								<xsl:choose>
									<!--
									<xsl:when test="($name = 'ProtoBody') and (@name = 'children')">
										<xsl:text disable-output-escaping="yes"><![CDATA[ArrayList<X3DNode>]]></xsl:text>
									</xsl:when>
									-->
									<xsl:when test="(@type = 'MFNode') and (($isClassX3dStatement = 'true') or ($isX3dStatement = 'true') or (@name = 'addChildren') or (@name = 'removeChildren'))">
										<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$javaPrimitiveType"/>
									</xsl:otherwise>
								</xsl:choose>
								<xsl:text> get</xsl:text>
								<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
								<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
									<xsl:text>List</xsl:text><!-- append to member name -->
								</xsl:if>
								<xsl:text>()</xsl:text>
								<xsl:choose>
									<xsl:when test="($isInterface = 'true')">
										<xsl:text>;</xsl:text>
										<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
											<xsl:text> // acceptable node types #1:</xsl:text>
											<xsl:value-of select="@acceptableNodeTypes"/>
										</xsl:if>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	{</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:choose>
											<xsl:when test="(($name = 'field') or ($name = 'fieldValue')) and (@name = 'value') and not($isX3dStatement = 'true')">
												<xsl:text disable-output-escaping="yes"><![CDATA[
		String valueType = getType();
		// alternatives for return typed value
		if ((valueArrayBoolean != null) && (valueArrayBoolean.length > 0))
		{
			if      (valueType.equals(fieldObject.TYPE_SFBOOL)) return SFBoolObject.toString(valueArrayBoolean[0]);
			else if (valueType.equals(fieldObject.TYPE_MFBOOL)) return MFBoolObject.toString(valueArrayBoolean);
		}
		else if ((valueArrayInteger != null) && (valueArrayInteger.length > 0))
		{
			if      (valueType.equals(fieldObject.TYPE_SFINT32)) return SFInt32Object.toString(valueArrayInteger[0]);
			else if (valueType.equals(fieldObject.TYPE_MFINT32)) return MFInt32Object.toString(valueArrayInteger);
			else if (valueType.equals(fieldObject.TYPE_SFIMAGE)) return SFImageObject.toString(valueArrayInteger);
			else if (valueType.equals(fieldObject.TYPE_MFIMAGE)) return MFImageObject.toString(valueArrayInteger);
		}
		else if ((valueArrayFloat != null) && (valueArrayFloat.length > 0))
		{
			if      (valueType.equals(fieldObject.TYPE_SFFLOAT))     return SFFloatObject.toString(valueArrayFloat[0]);
			else if (valueType.equals(fieldObject.TYPE_MFFLOAT))     return MFFloatObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_SFCOLOR))     return SFColorObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_MFCOLOR))     return MFColorObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_SFCOLORRGBA)) return SFColorRGBAObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_MFCOLORRGBA)) return MFColorRGBAObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_SFROTATION))  return SFRotationObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_MFROTATION))  return MFRotationObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_SFVEC2F))     return SFVec2fObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_SFVEC3F))     return SFVec3fObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_SFVEC4F))     return SFVec4fObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_MFVEC2F))     return MFVec2fObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_MFVEC3F))     return MFVec3fObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_MFVEC4F))     return MFVec4fObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_MFMATRIX3F))  return MFMatrix3fObject.toString(valueArrayFloat);
			else if (valueType.equals(fieldObject.TYPE_MFMATRIX4F))  return MFMatrix4fObject.toString(valueArrayFloat);
		}
		else if ((valueArrayDouble != null) && (valueArrayDouble.length > 0))
		{
			if      (valueType.equals(fieldObject.TYPE_SFDOUBLE))    return SFDoubleObject.toString(valueArrayDouble[0]);
			else if (valueType.equals(fieldObject.TYPE_MFDOUBLE))    return MFDoubleObject.toString(valueArrayDouble);
			else if (valueType.equals(fieldObject.TYPE_SFTIME))      return SFTimeObject.toString(valueArrayDouble[0]);
			else if (valueType.equals(fieldObject.TYPE_MFTIME))      return MFTimeObject.toString(valueArrayDouble);
			else if (valueType.equals(fieldObject.TYPE_SFVEC2D))     return SFVec2dObject.toString(valueArrayDouble);
			else if (valueType.equals(fieldObject.TYPE_SFVEC3D))     return SFVec3dObject.toString(valueArrayDouble);
			else if (valueType.equals(fieldObject.TYPE_SFVEC4D))     return SFVec4dObject.toString(valueArrayDouble);
			else if (valueType.equals(fieldObject.TYPE_MFVEC2D))     return MFVec2dObject.toString(valueArrayDouble);
			else if (valueType.equals(fieldObject.TYPE_MFVEC3D))     return MFVec3dObject.toString(valueArrayDouble);
			else if (valueType.equals(fieldObject.TYPE_MFVEC4D))     return MFVec4dObject.toString(valueArrayDouble);
			else if (valueType.equals(fieldObject.TYPE_MFMATRIX3D))  return MFMatrix3dObject.toString(valueArrayDouble);
			else if (valueType.equals(fieldObject.TYPE_MFMATRIX4D))  return MFMatrix4dObject.toString(valueArrayDouble);
		}
		else if (value != null)
		{
			if      (valueType.equals(fieldObject.TYPE_SFSTRING) ||
					 valueType.equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE)) // matches XML default; might not be connected yet
				return new SFStringObject(value).toString();
			else if (valueType.equals(fieldObject.TYPE_MFSTRING))
				return new MFStringObject(value).toString();
		}
		// TODO error handling
		if (value == null)
		{
			return "";
		}
		else return value]]></xsl:text>
											</xsl:when>
											<!-- check if SFNode subtype cast necessary -->
											<xsl:when test="(@type = 'SFNode') and not($javaPrimitiveType = $javaType) and not($isX3dStatement = 'true')">
												<xsl:text>		return (</xsl:text>
												<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
												<xsl:text>)</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
											</xsl:when>
											<xsl:when test="(@type = 'MFNode') and (($isX3dStatement = 'true') or ($isClassX3dStatement = 'true'))">
												<xsl:text>		return </xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
											</xsl:when>
											<xsl:when test="not($isX3dStatement = 'true') and
															((($isArrayListType = 'true') and contains($javaType,'ArrayList')) or
															 ((@type = 'MFNode') and not(starts-with($javaPrimitiveType, $javaReferenceType)) and not($isClassX3dStatement = 'true')))">
												<xsl:text>		final </xsl:text>
												<xsl:choose>
													<xsl:when test="($isX3dStatement = 'true')">
														<xsl:value-of select="@name"/>
														<xsl:value-of select="$jsaiClassSuffix"/>
														<xsl:if test="(@type='MFNode')">
															<xsl:text>[]</xsl:text>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
													</xsl:otherwise>
												</xsl:choose>
												<xsl:text> valuesArray = new </xsl:text>
												<xsl:choose>
													<xsl:when test="($isX3dStatement = 'true')">
														<xsl:value-of select="$normalizedMemberObjectName"/>
													</xsl:when>
													<xsl:otherwise>
														<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
													</xsl:otherwise>
												</xsl:choose>
												<xsl:text>[</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>.size()];</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		int i = 0;</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		for (</xsl:text>
												<xsl:value-of select="$javaReferenceType"/>
												<xsl:text> arrayElement : </xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>) {</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			valuesArray[i++] = </xsl:text>
												<xsl:if test="(@type = 'MFNode') and not($javaPrimitiveType = $javaType) and not(starts-with($javaPrimitiveType, $javaReferenceType)) and not($isX3dStatement = 'true')">
													<!-- cast -->
													<xsl:text>(</xsl:text>
													<xsl:value-of select="substring-before($javaPrimitiveType,'[')" disable-output-escaping="yes"/>
													<xsl:text>)</xsl:text>
												</xsl:if>
												<xsl:text>arrayElement;</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		}</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		return valuesArray</xsl:text>
												<!--
												final boolean[] primitives = new boolean[booleanList.size()];
												for (Boolean object : booleanList) {
													primitives[i++] = object;
												}
												return primitives;
												-->
												<!-- http://docs.oracle.com/javase/8/docs/api/java/util/List.html#toArray -->
												<!-- http://stackoverflow.com/questions/5615664/coverting-a-boolean-object-array-to-boolean-primitive-array -->
											</xsl:when>
											<xsl:otherwise>
												<xsl:text>		return </xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
											</xsl:otherwise>
										</xsl:choose>
										<xsl:text>;</xsl:text>
										<xsl:text>&#10;</xsl:text>

										<xsl:text>	}</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:otherwise>
								</xsl:choose>

								<xsl:if test="((@type='MFNode') or (@type='MFString') or (@type='MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type='MFFloat') or (@type='MFDouble') or (@type='MFTime'))
											   and not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Utility method to get ArrayList </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #get</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>()}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="($name = 'field') or ($name = 'fieldValue')">
										<xsl:text disable-output-escaping="yes"><![CDATA[	 * <i>Hint:</i> for best performance, set type before setting value.]]></xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<!-- TODO
									<xsl:text> * @see java.util.ArrayList</xsl:text>
									<xsl:text>&#10;</xsl:text>
									-->
									<xsl:text>	 * @return value of </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:if test="(@name != 'field')">
										<xsl:text> field</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
									<xsl:text> get</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>List()</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		return </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<!-- end of get accessors -->
							</xsl:if>

							<!-- javadoc: set method accessor(s) -->
							<xsl:if test="((@accessType='inputOnly') or (@accessType='initializeOnly') or (@accessType='inputOutput') or (string-length(@accessType) = 0))
										  and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')))">
								<!-- javadoc from BuildSpecificationLanguageBindingJava.xslt-->
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	/**</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 * Assign </xsl:text>
	<xsl:if test="($debug = 'true')">
            <xsl:text>($javaType=</xsl:text>
            <xsl:value-of select="$javaType" disable-output-escaping="yes"/>
            <xsl:text>, isArrayType=</xsl:text>
            <xsl:value-of select="$isArrayType"/>
            <xsl:text>, isArrayListType=</xsl:text>
            <xsl:value-of select="$isArrayListType"/>
            <xsl:text>, javaPrimitiveType=</xsl:text>
            <xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
            <xsl:text>, javaReferenceType=</xsl:text>
            <xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
            <xsl:text>, isX3dStatement=</xsl:text>
            <xsl:value-of select="$isX3dStatement"/>
            <xsl:text>, isClassX3dStatement=</xsl:text>
            <xsl:value-of select="$isClassX3dStatement"/>
            <xsl:text>) </xsl:text>
	</xsl:if>
								<xsl:value-of select="$tupleNess"/>
								<xsl:choose>
									<xsl:when test="contains($javaType,'[]')">
										<xsl:value-of select="substring-before($javaType,'[]')"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:text> array </xsl:text>
									</xsl:when>
									<xsl:when test="($isArrayListType = 'true')"><!-- boxed type such as ArrayList<String> -->
										<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:text> array </xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
										<xsl:if test="$isEnumerationType">
											<xsl:text> enumeration</xsl:text>
										</xsl:if>
										<xsl:choose>
											<xsl:when test="(ends-with(@type,'FNode'))">
												<xsl:text> instance </xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:text> value </xsl:text>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:otherwise>
								</xsl:choose>
								<!-- value restrictions, if any -->
								<xsl:choose>
									<xsl:when test="$isEnumerationType">
										<xsl:text>(</xsl:text>
										<xsl:value-of select="$enumerationValues"/>
										<xsl:text>) </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'RGBA')">
										<xsl:text>using RGBA values [0..1] </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'Color')">
										<xsl:text>using RGB values [0..1] </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'otation') or contains(@name,'otation') or contains(@name,'angle') or contains(@name,'Angle')">
										<xsl:text>unit axis, angle (in radians) </xsl:text>
									</xsl:when>
									<xsl:when test="contains($type,'Time')">
										<xsl:text>in seconds </xsl:text>
									</xsl:when>
									<xsl:when test="($type='SFNode')">
										<xsl:text>(using a properly typed node) </xsl:text>
									</xsl:when>
									<xsl:when test="($type='MFNode')">
										<xsl:text>(using an array consisting of properly typed nodes or X3DPrototypeInstance objects) </xsl:text>
									</xsl:when>
								</xsl:choose>
								<xsl:call-template name="list-restrictions"/>
								<xsl:text>to </xsl:text>
								<xsl:value-of select="@accessType"/>
								<xsl:text> </xsl:text>
								<xsl:value-of select="@type"/>
								<xsl:text> field </xsl:text>
								<xsl:if test="not(ends-with(@type,'FNode'))">
									<xsl:text>named </xsl:text>
								</xsl:if>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:if test="((@type='SFString') or (@type='MFString')) and (enumeration) and not($isInterface = 'true')">
									<xsl:choose>
										<xsl:when test="not(@additionalEnumerationValuesAllowed='true')">
											<xsl:text>.</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	 * </xsl:text>
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text>&#10;</xsl:text>
											<xsl:text disable-output-escaping="yes"><![CDATA[	 * <i>Warning:</i> authors can only choose from a strict list of enumeration values ]]></xsl:text>
										</xsl:when>
										<xsl:when test="   (@additionalEnumerationValuesAllowed='true')">
											<xsl:text>.</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	 * </xsl:text>
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text>&#10;</xsl:text>
											<xsl:text disable-output-escaping="yes"><![CDATA[	 * <i>Hint:</i> authors have option to choose from an extendible list of predefined enumeration values ]]></xsl:text>
										</xsl:when>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:for-each select="enumeration">
										<xsl:if test="position() > 1">
											<xsl:text>, </xsl:text>
										</xsl:if>
										<xsl:text>{@link </xsl:text>
										<xsl:text>#</xsl:text>
										<xsl:value-of select="upper-case(../@name)"/>
										<xsl:text>_</xsl:text>
										<!-- enumeration name: omit " character, others become _ underscore -->
										<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
										<xsl:text> </xsl:text>
										<!-- enumeration name: omit " character, others become _ underscore -->
										<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
										<xsl:text>}</xsl:text>
									</xsl:for-each>
									<xsl:text>)</xsl:text>
								</xsl:if>
								<xsl:text>.</xsl:text>
								<xsl:text>&#10;</xsl:text>

								<xsl:if test="($type='SFNode') and not($isInterface = 'true') and not($isClassX3dStatement = 'true')">
									<xsl:text>	 * @see #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(ProtoInstanceObject)</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(string-length($fieldTooltip) > 0)">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;Tooltip:&lt;/i&gt; </xsl:text>
									<!-- TODO recurse to insert line breaks for each Hint: -->
									<!-- TODO regular expression to insert links for url text -->
									<!-- don't escape apostrophes, that makes javadoc unhappy -->
									<!-- xsl:text> escape-javadoc-characters2 </xsl:text -->
									<xsl:call-template name="escape-javadoc-characters">
										<xsl:with-param name="inputString">
											<xsl:value-of select="normalize-space(substring-after($fieldTooltip,']'))" disable-output-escaping="no"/>
										</xsl:with-param>
									</xsl:call-template>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:choose>
									<xsl:when test="(@name = 'DEF')">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text> Note that setting the DEF value clears the USE value.</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
									<xsl:when test="(@name = 'USE')">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> each <code>USE</code> node is still an independent object, with the <code>USE</code> value matching the <code>DEF</code> value in the preceding object. ]]></xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Warning:</i> invoking the <code>setUSE()</code> method on this node resets all other fields to their default values (except for containerField) and also releases all child nodes.]]></xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Warning:</i> no other operations can be performed to modify a USE node other than setting an alternate containerField value.]]></xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
								</xsl:choose>
								<xsl:if test="(@type = 'MFNode') and (string-length(@acceptableNodeTypes) > 1)">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
									<xsl:value-of select="@acceptableNodeTypes"/>
									<xsl:text>.</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(@name = 'name') and (($name = 'component') or ($name = 'meta') or ($name = 'unit') or ($name = 'field') or ($name = 'fieldValue') or starts-with($name, 'CAD') or starts-with($name, 'HAnim') or starts-with($name, 'Metadata') or contains($name, 'Proto'))">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
									<xsl:text disable-output-escaping="yes"><![CDATA[@see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="($name = 'meta')">
									<xsl:text>	 * </xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[@see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#metaStatements" target="_blank">X3D Scene Authoring Hints: meta Statements</a>]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:if test="(@name = 'metadata') or starts-with($name, 'Metadata')">
									<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:text>	 * @param </xsl:text>
								<xsl:value-of select="$newValue"/>
								<xsl:text> is new value for the </xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:text> field.</xsl:text>
								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 * @return {@link </xsl:text>
								<xsl:value-of select="$thisClassName"/>
								<xsl:text>} - namely </xsl:text>
								<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
								<xsl:text>this</xsl:text>
								<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
								<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
								<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
								<!-- http://parlab.eecs.berkeley.edu/wiki/_media/patterns
								     http://parlab.eecs.berkeley.edu/wiki/_media/patterns/pipeline-v1.pdf -->
								<!-- http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html -->

								<xsl:text>&#10;</xsl:text>
								<xsl:text>	 */</xsl:text><!-- end javadoc -->
								<xsl:text>&#10;</xsl:text>
								<xsl:variable name="isSingleValueType">
									<xsl:value-of select="starts-with(@type,'SF') and not(contains(@type, 'Vec')) and not(contains(@type, 'Rotation')) and not(contains(@type, 'Color')) and not(contains(@type, 'Matrix'))"/>
								</xsl:variable>
								<xsl:variable name="newValueNullExceptionCheck">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
									<xsl:text>("</xsl:text>
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is null and cannot be set"); // newValueNullExceptionCheck</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullClearsFieldReturnThis">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			</xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:if test="($isX3dStatement = 'true') and not(@name = 'children')">
										<xsl:text>List</xsl:text>
									</xsl:if>
									<xsl:text>.clear(); // newValueNullClearsFieldReturnThis</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			return</xsl:text>
									<xsl:if test="not(@name = 'children')">
										<xsl:text> this</xsl:text>
									</xsl:if>
									<xsl:text>;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullClearsFieldReturnVoid">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			</xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:if test="($isX3dStatement = 'true') and not(@name = 'children')">
										<xsl:text>List</xsl:text>
									</xsl:if>
									<xsl:text>.clear(); // newValueNullClearsFieldReturnVoid</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			return;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullReturnVoid">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null) return; // newValueNullReturnVoid</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullReturnThis">
									<!-- ignores addition of null node to array -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null) return this; // newValueNullReturnThis</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueNullSetDEFAULT_VALUE">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> == null)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:choose>
										<xsl:when test="($isSingleValueType = 'true')">
											<xsl:text>			return set</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											<xsl:text>(</xsl:text>
											<xsl:value-of select="upper-case(translate(@name,'-','_'))"/> <!-- translate name here to avoid xpath problems -->
											<xsl:text>_DEFAULT_VALUE); // newValueNullSetDEFAULT_VALUE</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>		{</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>			clear</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											<xsl:text>(); // newValueNullSetDEFAULT_VALUE</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>			return this;</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>		}</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:variable name="newProtoInstanceNodeNullReturnThis">
									<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
									<xsl:text>		if (newProtoInstanceNode == null) return this</xsl:text>
									<xsl:text>; // newProtoInstanceNodeNullReturnThis</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:variable>
								<xsl:variable name="newValueInstanceAcceptableNodeTypesTest">
									<xsl:if test="contains(@acceptableNodeTypes, '|')">
										<!-- debug trace -->
										<xsl:message>
											<xsl:value-of select="$name"/>	
											<xsl:text> field=</xsl:text>
											<xsl:value-of select="@name"/>	
											<xsl:text> @acceptableNodeTypes=</xsl:text>
											<xsl:value-of select="@acceptableNodeTypes"/>								
										</xsl:message>
										<xsl:text disable-output-escaping="yes">
		// newValueInstanceAcceptableNodeTypesTest checks are needed for methods that override/subset X3DNode interfaces #1
		boolean isNodeTypeAllowed =</xsl:text>
										<xsl:if test="(@type = 'MFNode') and ((@name='children') or contains(@acceptableNodeTypes, 'children'))">
											<!-- these statements do not qualify as SFNode fields -->
											<xsl:text disable-output-escaping="yes">
				(newValue instanceof org.web3d.x3d.jsail.Core.CommentsBlock) ||
				(newValue instanceof org.web3d.x3d.jsail.Core.ROUTEObject) ||
				(newValue instanceof org.web3d.x3d.jsail.Networking.IMPORTObject) ||
				(newValue instanceof org.web3d.x3d.jsail.Networking.EXPORTObject) ||
				(newValue instanceof org.web3d.x3d.jsail.Core.ProtoDeclareObject) ||
				(newValue instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclareObject) ||</xsl:text>
										</xsl:if>
										<xsl:if test="contains(@acceptableNodeTypes, 'LayerSet')">
										</xsl:if>

										<!-- must save access to object model tree before going inside an xsl:for-each that loops over strings -->
										<xsl:variable name="X3DObjectModelTree" select="/"/>
										<xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
											<xsl:variable name="acceptableNodeType" select="string(.)"/>
											<xsl:choose>
												<xsl:when test="($acceptableNodeType = 'LayerSet')">
													<xsl:text>
				(newValue instanceof org.web3d.x3d.jsail.Layering.LayerSetObject)</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>
				(((X3DConcreteNode)</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>) instanceof </xsl:text>
													<xsl:variable name="packageName">
														<xsl:choose>
															<xsl:when test="starts-with($acceptableNodeType,'X3D') and contains($acceptableNodeType,'Node')">
																<xsl:text>org.web3d.x3d.sai.</xsl:text>
																<xsl:value-of select="translate($X3DObjectModelTree//AbstractNodeType  [@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
																<xsl:text>.</xsl:text>
																<xsl:value-of select="$acceptableNodeType"/>
															</xsl:when>
															<xsl:when test="starts-with($acceptableNodeType,'X3D') and contains($acceptableNodeType,'Object')">
																<xsl:text>org.web3d.x3d.sai.</xsl:text>
																<xsl:value-of select="translate($X3DObjectModelTree//AbstractObjectType[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
																<xsl:text>.</xsl:text>
																<xsl:value-of select="$acceptableNodeType"/>
															</xsl:when>
															<xsl:otherwise>
																<xsl:text>org.web3d.x3d.jsail.</xsl:text>
																<xsl:value-of select="translate($X3DObjectModelTree//ConcreteNodes/ConcreteNode[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
																<xsl:text>.</xsl:text>
																<xsl:value-of select="$acceptableNodeType"/>
																<xsl:text>Object</xsl:text>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<!-- debug trace
													<xsl:message>
														<xsl:text>acceptableNodeType=</xsl:text>
														<xsl:value-of select="$acceptableNodeType"/>
														<xsl:text>, packageName=</xsl:text>
														<xsl:value-of select="$packageName"/>											
													</xsl:message> -->
													<!-- find, insert package name -->
													<xsl:value-of select="$packageName"/>
													<xsl:text>)</xsl:text>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:if test="not(position() = last())">
												<xsl:text> || </xsl:text>
											</xsl:if>
										</xsl:for-each>
										<xsl:text>;
		if  (!isNodeTypeAllowed)
		{
			throw new org.web3d.x3d.sai.InvalidFieldValueException("X3DNode newValue is not instanceof " +
				"acceptableNodeTypes </xsl:text>
			<xsl:value-of select="@acceptableNodeTypes"/>
			<xsl:text>; newValue=" + newValue);
		}
</xsl:text>
									</xsl:if>
								</xsl:variable>
								<xsl:variable name="newValueArrayAcceptableNodeTypesTest">
									<xsl:if test="contains(@acceptableNodeTypes, '|')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		// newValueArrayAcceptableNodeTypesTest checks are needed for methods that override/subset X3DNode interfaces #2
		for (int i = 0; i < ]]></xsl:text>
										<xsl:value-of select="$newValue"/>
										<xsl:text>.length; i++)
		{
			boolean isNodeTypeAllowed = </xsl:text>
										<xsl:if test="((@name='children') or contains(@acceptableNodeTypes, 'children'))">
											<xsl:text>
				(newValue[i] instanceof org.web3d.x3d.jsail.Core.CommentsBlock) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Core.ROUTEObject) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Networking.IMPORTObject) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Networking.EXPORTObject) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Core.ProtoDeclareObject) ||
				(newValue[i] instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclareObject) ||</xsl:text>
										</xsl:if>
										<!-- must save access to object model tree before going inside an xsl:for-each that loops over strings -->
										<xsl:variable name="X3DObjectModelTree" select="/"/>
										<xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
											<xsl:variable name="acceptableNodeType" select="string(.)"/>
											<xsl:choose>
												<xsl:when test="($acceptableNodeType = 'LayerSet')">
													<xsl:text>
				(newValue[i] instanceof org.web3d.x3d.jsail.Layering.LayerSetObject)</xsl:text>
												</xsl:when>
												<xsl:when test="not(starts-with($acceptableNodeType, 'X3D'))">
													<xsl:text>
				(((X3DConcreteNode)</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i]) instanceof </xsl:text>
													<xsl:text>org.web3d.x3d.jsail.</xsl:text>
													<xsl:value-of select="translate($X3DObjectModelTree//ConcreteNodes/ConcreteNode[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
													<xsl:text>Object</xsl:text>
													<xsl:text>)</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>
				(((X3DConcreteNode)</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i]) instanceof </xsl:text>
													<!-- can't reach up into X3D Object Model from within string tokenizer -->
													<xsl:value-of select="$acceptableNodeType"/>
													<xsl:text>)</xsl:text>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:if test="(last() > position())">
												<xsl:text> || </xsl:text>
											</xsl:if>
										</xsl:for-each>
										<xsl:text>;
			if  (!isNodeTypeAllowed)
			{
				throw new org.web3d.x3d.sai.InvalidFieldValueException("X3DNode[] newValue["+i+"] is not instanceof " +
					"acceptableNodeTypes </xsl:text>
				<xsl:value-of select="@acceptableNodeTypes"/>
				<xsl:text>; newValue["+i+"]=" + newValue[i]);
			}
		}
</xsl:text>
									</xsl:if>
								</xsl:variable>
								<xsl:variable name="newValueArrayListAcceptableNodeTypesTest">
									<xsl:if test="contains(@acceptableNodeTypes, '|')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		// newValueArrayListAcceptableNodeTypesTest checks are needed for methods that override/subset X3DNode interfaces #3
		for (X3DNode element : ]]></xsl:text>
										<xsl:value-of select="$newValue"/>
										<xsl:text>)
		{
			boolean isNodeTypeAllowed = </xsl:text>
										<xsl:if test="((@name='children') or contains(@acceptableNodeTypes, 'children'))">
											<xsl:text>
				(element instanceof org.web3d.x3d.jsail.Core.CommentsBlock) ||
				(element instanceof org.web3d.x3d.jsail.Core.ROUTEObject) ||
				(element instanceof org.web3d.x3d.jsail.Networking.IMPORTObject) ||
				(element instanceof org.web3d.x3d.jsail.Networking.EXPORTObject) ||
				(element instanceof org.web3d.x3d.jsail.Core.ProtoDeclareObject) ||
				(element instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclareObject) ||</xsl:text>
										</xsl:if>
										<!-- must save access to object model tree before going inside an xsl:for-each that loops over strings -->
										<xsl:variable name="X3DObjectModelTree" select="/"/>
										<xsl:for-each select="tokenize(@acceptableNodeTypes,'\|\s*')">
											<xsl:variable name="acceptableNodeType" select="string(.)"/>
											<xsl:choose>
												<xsl:when test="($acceptableNodeType = 'LayerSet')">
													<xsl:text>
				(element instanceof org.web3d.x3d.jsail.Layering.LayerSetObject)</xsl:text>
												</xsl:when>
												<xsl:when test="not(starts-with($acceptableNodeType, 'X3D'))">
													<xsl:text>
				(element instanceof org.web3d.x3d.jsail.</xsl:text>
													<xsl:value-of select="translate($X3DObjectModelTree//ConcreteNodes/ConcreteNode[@name = $acceptableNodeType]/InterfaceDefinition/componentInfo/@name,'-','')"/>
													<xsl:text>.</xsl:text>
													<xsl:value-of select="$acceptableNodeType"/>
													<xsl:text>Object</xsl:text>
													<xsl:text>)</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>
				(element instanceof </xsl:text>
													<!-- can't reach up into X3D Object Model from within string tokenizer -->
													<xsl:value-of select="$acceptableNodeType"/>
													<xsl:text>)</xsl:text>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:if test="(last() > position())">
												<xsl:text> || </xsl:text>
											</xsl:if>
										</xsl:for-each>
										<xsl:text>;
			if  (!isNodeTypeAllowed)
			{
				throw new org.web3d.x3d.sai.InvalidFieldValueException("X3DNode[] element is not instanceof " +
					"acceptableNodeTypes </xsl:text>
				<xsl:value-of select="@acceptableNodeTypes"/>
				<xsl:text>; element=" + element);
			}
		}
</xsl:text>
									</xsl:if>
								</xsl:variable>
								<xsl:variable name="isEnumerationType" select="(count(enumeration) > 0)"/>

								<!-- source code: set method -->
								<xsl:if test="(not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')) or
												 (($isInterface = 'true') and //AbstractNodeType  [@name = $baseType                     ]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($isInterface = 'true') and //AbstractNodeType  [@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($isInterface = 'true') and //AbstractObjectType[@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($thisClassName = 'ProtoInstanceObject') and 
												  (($CamelCaseName = 'Metadata') or ($CamelCaseName = 'Name') or ($CamelCaseName = 'DEF') or ($CamelCaseName = 'USE') or ($CamelCaseName = 'CssClass')))">
									<xsl:text>	@Override</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								<xsl:text>	public </xsl:text>
								<!-- might avoid final in case someone is subclassing someday, but logic is tricky and so conservative here -->
								<xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'class') or (@name = 'name')) and not($isInterface = 'true')">
									<xsl:text>final </xsl:text>
								</xsl:if>
								<xsl:value-of select="$thisClassName"/>
								<xsl:text> </xsl:text>
								<xsl:choose>
									<xsl:when test="(@name = 'addChildren') or (@name = 'removeChildren')">
										<!-- no change in corresponding method name -->
										<xsl:value-of select="@name"/>
										<!-- TODO update javadoc descriptions accordingly -->
										<!-- TODO SFNode utility methods corresponding to MFNode methods -->
									</xsl:when>
									<xsl:otherwise>
										<xsl:text>set</xsl:text>
										<xsl:choose>
											<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
												<!-- unmodified -->
												<xsl:value-of select="@name"/>
											</xsl:when>
											<xsl:when test="(@name = 'class')">
												<!-- getClass() is reserved by Java Object() class -->
												<xsl:text>CssClass</xsl:text>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											</xsl:otherwise>
										</xsl:choose>
										<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
											<xsl:text>List</xsl:text><!-- append to member name -->
										</xsl:if>
									</xsl:otherwise>
								</xsl:choose>
								<xsl:text>(</xsl:text>
								<xsl:choose>
									<xsl:when test="(@type = 'MFNode') and (($isClassX3dStatement = 'true') or ($isX3dStatement = 'true') or (@name = 'addChildren') or (@name = 'removeChildren'))">
										<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$javaPrimitiveType"/>
									</xsl:otherwise>
								</xsl:choose>
								<xsl:text> </xsl:text>
								<xsl:value-of select="$newValue"/>
								<xsl:text>)</xsl:text>
								<xsl:choose>
									<xsl:when test="($isInterface = 'true')">
										<xsl:text>;</xsl:text>
										<!-- note that node type cannot be constrained further here because this method implements/overrides an SAI interface -->
										<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
											<xsl:text> // acceptable node types #2: </xsl:text>
											<xsl:value-of select="@acceptableNodeTypes"/>
										</xsl:if>
										<xsl:text>&#10;</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	{</xsl:text>
										<xsl:text>&#10;</xsl:text>
									<xsl:text>		// set-newValue-validity-checks #0</xsl:text>
									<xsl:text>&#10;</xsl:text>
										<xsl:call-template name="set-newValue-validity-checks">
											<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
											<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
											<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
											<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
											<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
                                                                                        <xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
											<xsl:with-param name="comparisonType"   ><xsl:text>simple</xsl:text></xsl:with-param>
									        	<xsl:with-param name="debug"            ><xsl:text>true</xsl:text></xsl:with-param>
										</xsl:call-template>
										
										<xsl:if test="(($name = 'field') or ($name = 'fieldValue')) and (@name = 'type')">
											<xsl:text disable-output-escaping="yes"><![CDATA[
		// Changing type: if appropriate, shift prior string value to corresponding typed array
		if ( value.isEmpty() && (valueArrayBoolean.length == 0) && (valueArrayInteger.length == 0) && 
			(valueArrayFloat.length == 0) && (valueArrayDouble.length == 0))
		{
			// no action required
		}
		else if (newValue.equals(fieldObject.TYPE_SFNODE)   || newValue.equals(fieldObject.TYPE_MFNODE))
		{
			// clear all arrays
			value             = new   String(); // reset
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if (newValue.equals(fieldObject.TYPE_SFSTRING) || newValue.equals(fieldObject.TYPE_MFSTRING))
		{
			// leave String value array alone, clear other arrays
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if ((newValue.equals(fieldObject.TYPE_SFBOOL) || newValue.equals(fieldObject.TYPE_MFBOOL)) && 
				 (valueArrayBoolean.length == 0)) // don't overwrite prior array, if present
		{
			valueArrayBoolean = new MFBoolObject().setValueByString(value).getPrimitiveValue();
			value             = new   String(); // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if ((newValue.equals(fieldObject.TYPE_SFINT32) || newValue.equals(fieldObject.TYPE_MFINT32) ||
				  newValue.equals(fieldObject.TYPE_SFIMAGE) || newValue.equals(fieldObject.TYPE_MFIMAGE)) && 
				 (valueArrayInteger.length == 0)) // don't overwrite prior array, if present
		{
			valueArrayInteger = new MFInt32Object().setValueByString(value).getPrimitiveValue();
			value             = new   String(); // reset
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if ((newValue.equals(fieldObject.TYPE_SFCOLOR)    || newValue.equals(fieldObject.TYPE_MFCOLOR) ||
				  newValue.equals(fieldObject.TYPE_SFCOLORRGBA)|| newValue.equals(fieldObject.TYPE_MFCOLORRGBA) ||
				  newValue.equals(fieldObject.TYPE_SFFLOAT)    || newValue.equals(fieldObject.TYPE_MFFLOAT) ||
				  newValue.equals(fieldObject.TYPE_SFROTATION) || newValue.equals(fieldObject.TYPE_MFROTATION) ||
				  newValue.equals(fieldObject.TYPE_SFTIME)     || newValue.equals(fieldObject.TYPE_MFTIME) ||
				  newValue.equals(fieldObject.TYPE_SFVEC2F)    || newValue.equals(fieldObject.TYPE_MFVEC2F) ||
				  newValue.equals(fieldObject.TYPE_SFVEC3F)    || newValue.equals(fieldObject.TYPE_MFVEC3F) ||
				  newValue.equals(fieldObject.TYPE_SFVEC4F)    || newValue.equals(fieldObject.TYPE_MFVEC4F) ||
				  newValue.equals(fieldObject.TYPE_SFMATRIX3F) || newValue.equals(fieldObject.TYPE_MFMATRIX3F) ||
				  newValue.equals(fieldObject.TYPE_SFMATRIX4F) || newValue.equals(fieldObject.TYPE_MFMATRIX4F)) && 
				 (valueArrayFloat.length == 0)) // don't overwrite prior array, if present
		{
			valueArrayFloat = new MFFloatObject().setValueByString(value).getPrimitiveValue();
			value             = new   String(); // reset
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayDouble  = new  double[0]; // reset
		}
		else if ((newValue.equals(fieldObject.TYPE_SFDOUBLE)   || newValue.equals(fieldObject.TYPE_MFDOUBLE) ||
				  newValue.equals(fieldObject.TYPE_SFVEC2D)    || newValue.equals(fieldObject.TYPE_MFVEC2D) ||
				  newValue.equals(fieldObject.TYPE_SFVEC3D)    || newValue.equals(fieldObject.TYPE_MFVEC3D) ||
				  newValue.equals(fieldObject.TYPE_SFVEC4D)    || newValue.equals(fieldObject.TYPE_MFVEC4D) ||
				  newValue.equals(fieldObject.TYPE_SFMATRIX3D) || newValue.equals(fieldObject.TYPE_MFMATRIX3D) ||
				  newValue.equals(fieldObject.TYPE_SFMATRIX4D) || newValue.equals(fieldObject.TYPE_MFMATRIX4D)) && 
				 (valueArrayDouble.length == 0)) // don't overwrite prior array, if present
		{
			valueArrayDouble = new MFDoubleObject().setValueByString(value).getPrimitiveValue();
			value             = new   String(); // reset
			valueArrayBoolean = new boolean[0]; // reset
			valueArrayInteger = new     int[0]; // reset
			valueArrayFloat   = new   float[0]; // reset
		}
]]></xsl:text>
											<xsl:text>
</xsl:text>										
										</xsl:if>
										<xsl:if test="(($name = 'field') or ($name = 'fieldValue')) and (@name = 'value')">
													<xsl:text disable-output-escaping="yes"><![CDATA[		// check for legal type
		String valueType = getType();
		if (valueType.equals(ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE))
			valueType = fieldObject.TYPE_SFSTRING; // same as default found in file encodings, must recheck later

		if ((valueType.equals(fieldObject.TYPE_SFNODE) || valueType.equals(fieldObject.TYPE_MFNODE)) &&
			(newValue.length() > 0))
		{
			throw new InvalidProtoException("field name='" + getName() + "' with type='" + valueType +
					"' cannot have any simple-type value (newValue='" + newValue + "').  Use setChildren() method instead.");
		}
		else if (valueType.equals(fieldObject.TYPE_SFSTRING) || valueType.equals(fieldObject.TYPE_MFSTRING))
		{
			value = newValue;
		}]]></xsl:text>
						<xsl:for-each select="//FieldTypes/FieldType">
							<xsl:variable name="fieldName" select="@type"/>
							<xsl:variable name="upperCaseFieldName" select="upper-case($fieldName)"/>
							<xsl:variable name="baseValue">
								<xsl:choose>
									<xsl:when test="contains(@type,'String')">
										<xsl:text>value</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Bool')">
										<xsl:text>valueArrayBoolean</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Int32') or contains(@type,'Image')">
										<xsl:text>valueArrayInteger</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Float') or contains(@type,'Color') or contains(@type,'Rotation') or
													ends-with(@type,'f')">
										<xsl:text>valueArrayFloat</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Double') or contains(@type,'Time') or ends-with(@type,'d')">
										<xsl:text>valueArrayDouble</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'FNode')">
										<!-- handled by getChildren method -->
									</xsl:when>
									<xsl:otherwise>
										<xsl:message>
											<xsl:text>*** unhandled baseValue: </xsl:text>
											<xsl:value-of select="@type"/>
										</xsl:message>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<!-- typed get methods -->
							<xsl:choose>
								<xsl:when test="contains(@type,'FNode')">
									<!-- handled by getChildren() -->
								</xsl:when>
								<xsl:when test="contains(@type,'FString')">
									<!-- already handled prior to this loop -->
								</xsl:when>
								<xsl:when test="starts-with(@type,'SF')">
							<xsl:text>
		else if (valueType.equals(fieldObject.TYPE_</xsl:text><xsl:value-of select="$upperCaseFieldName"/><xsl:text>))
		{
			</xsl:text>
			<xsl:value-of select="$baseValue"/>
			<!--
			<xsl:if test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
				<xsl:text>[0]</xsl:text>
			</xsl:if>
			-->
			<xsl:text> = new M</xsl:text>
			<xsl:value-of select="substring($fieldName,2)"/>
			<xsl:value-of select="$jsaiClassSuffix"/>
			<xsl:text>().setValueByString(newValue).getPrimitiveValue();
		}
	</xsl:text>
								</xsl:when>
							</xsl:choose>
						</xsl:for-each>
										</xsl:if>
										<xsl:choose>
											<xsl:when test="(@name = 'DEF')">
												<xsl:text>		setConcreteUSE(""); // ensure that no previous USE value remains</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		setConcreteDEF(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>); // private superclass methods</xsl:text>
											</xsl:when>
											<xsl:when test="(@name = 'USE')">
												<xsl:text>		initialize(); // reset all other field values to default (equivalent to empty)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		setConcreteUSE(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>); // private superclass method</xsl:text>
											</xsl:when>
											<xsl:when test="(@name = 'class')">
												<xsl:text>		setConcreteCssClass(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>); // private superclass method</xsl:text>
											</xsl:when>
											<!-- http://stackoverflow.com/questions/10530353/convert-string-array-to-arraylist -->
											<xsl:when test="(@type = 'SFNode') and not($javaPrimitiveType = $javaType) and not($isX3dStatement = 'true')">
												<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
												<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
												<!-- SFNode subtype checks necessary -->
												<xsl:text>	if (</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text> instanceof </xsl:text>
												<xsl:value-of select="$javaType"/>
												<xsl:text>)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>	{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>       </xsl:text>
												<xsl:value-of select="@name"/>
												<xsl:text> = </xsl:text>
												<xsl:text>(</xsl:text>
												<xsl:value-of select="$javaType"/>
												<xsl:text>)</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>;</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>       ((X3DConcreteElement) </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>).setParentObject(this); // parentTest10</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>	}</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>	else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
												<xsl:text>("</xsl:text>
												<xsl:value-of select="$javaPrimitiveType"/>
												<xsl:text> </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>=(</xsl:text>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
												<xsl:text>) is not instanceof </xsl:text>
												<xsl:value-of select="$javaType"/>
												<xsl:text>; </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>=" + </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>);</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'MFNode') and (($isX3dStatement = 'true') or ($isClassX3dStatement = 'true'))">
												<xsl:if test="($name = 'ProtoBody')">
													<xsl:text>		if (primaryNode != null)
		{
			primaryNode.setParentObject(null); // housekeeping, clear prior object
		    primaryNode = null;
		}
</xsl:text>
												</xsl:if>
												<xsl:text>		</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text> = </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>;</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		for (</xsl:text>
												<xsl:value-of select="$javaReferenceType"/>
												<xsl:text> arrayElement : </xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		{</xsl:text>
												<xsl:if test="($name = 'ProtoBody')">
													<xsl:text disable-output-escaping="yes"><![CDATA[
			if ((primaryNode == null) && (arrayElement instanceof org.web3d.x3d.jsail.X3DConcreteNode))
			{
				primaryNode = (X3DConcreteNode) arrayElement; // remember node type
				primaryNode.setParentObject(this);
			}
]]></xsl:text>
												</xsl:if>
												<!-- special set method validation, assignment checks -->
												<xsl:choose>
													<xsl:when test="($name = 'ExternProtoDeclare') and (@name = 'field')">
		<!-- check to ensure that no value is present within field having parent ExternProtoDeclare -->
		<xsl:text disable-output-escaping="yes"><![CDATA[			// No value is allowed within field having parent ExternProtoDeclare
			if ((!arrayElement.getValue().isEmpty() || !arrayElement.getChildren().isEmpty()) && arrayElement.hasChildrenElements())
			{
				String foundValue;
				if (!arrayElement.getValue().isEmpty())
					 foundValue = arrayElement.getValue();
				else foundValue = arrayElement.getChildren().toString();
			
				throw new InvalidProtoException("ExternProtoDeclare name='" + name +
					"' with field name='" + arrayElement.getName() +
					"' cannot have any initial value (found \"" + foundValue + 
					"\"). Instead use ProtoInstance fieldValue to override the original default ProtoDeclare field value.");
			}
]]></xsl:text>
													</xsl:when>
												</xsl:choose>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			((X3DConcreteElement) arrayElement).setParentObject(this); // parentTest11</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		}</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'MFNode') and not(starts-with($javaType, $javaReferenceType)) and not($isX3dStatement = 'true')">
												<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
												<xsl:value-of select="$newValueArrayAcceptableNodeTypesTest" disable-output-escaping="yes"/>
												<xsl:text>		</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>.clear(); // reset</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<!-- MFNode subtype checks necessary -->
												<xsl:text>		for (int i = 0; i </xsl:text>
												<xsl:text disable-output-escaping="yes">&lt; </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>.length; i++)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			if  (</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>[i] instanceof </xsl:text>
												<xsl:value-of select="$javaReferenceType"/>
												<xsl:text>)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>				</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>.add(</xsl:text>
												<xsl:if test="not($isX3dStatement = 'true') and not($javaReferenceType = 'X3DNode')">
													<!-- cast -->
													<xsl:text>(</xsl:text>
													<xsl:value-of select="$javaReferenceType"/>
													<xsl:text>)</xsl:text>
												</xsl:if>
												<xsl:value-of select="$newValue"/>
												<xsl:text>[i]);</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:if test="($name = 'ProtoBody') and not($isInterface = 'true')">
													<xsl:text disable-output-escaping="yes"><![CDATA[
			if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof org.web3d.x3d.jsail.X3DConcreteNode))
			{
				primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>; // remember node type
				primaryNode.setParentObject(this);
			}
</xsl:text>	
												</xsl:if>
												<xsl:text>				((X3DConcreteElement) </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>[i]).setParentObject(this); // parentTest12</xsl:text>
												<xsl:text>&#10;</xsl:text>
													<xsl:choose>
														<!-- MFNode child -->
														<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
															<xsl:text>				((X3DConcreteNode)    </xsl:text>
															<xsl:value-of select="$newValue"/>
															<xsl:text>[i]).setContainerFieldOverride("value");</xsl:text>
															<xsl:text>&#10;</xsl:text>
														</xsl:when>
													</xsl:choose>
												<xsl:text>			}</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
												<xsl:text>("</xsl:text>
												<xsl:value-of select="$javaPrimitiveType"/>
												<xsl:text> </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>["+i+"] is not instanceof </xsl:text>
												<xsl:value-of select="$javaReferenceType"/>
												<xsl:text>; </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>=" + </xsl:text>
												<xsl:text>Arrays.toString(</xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>)</xsl:text>
												<xsl:text>);</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		}</xsl:text>
											</xsl:when>
											<xsl:when test="($isArrayListType = 'true') and not($javaReferenceType = 'X3DNode') and not($isX3dStatement = 'true')">
												<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
												<!-- http://stackoverflow.com/questions/39873596/convert-array-of-strings-to-boolean-list-in-java -->
												<xsl:text>		</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text>.clear(); // reset</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		for (int i = 0; i </xsl:text>
												<xsl:text disable-output-escaping="yes">&lt; </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>.length; i++)</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:choose>
													<xsl:when test="(@type = 'MFNode') and not(starts-with($javaPrimitiveType, $javaReferenceType))">
														<xsl:value-of select="$newValueArrayAcceptableNodeTypesTest" disable-output-escaping="yes"/>
														<!-- SFNode subtype checks necessary -->
														<xsl:text>			if (</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>[i] instanceof </xsl:text>
														<xsl:value-of select="$javaReferenceType"/>
														<xsl:value-of select="$jsaiClassSuffix"/>
														<xsl:text>)</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>			{</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:if test="($name = 'ProtoBody') and not($isInterface = 'true')">
															<xsl:text disable-output-escaping="yes"><![CDATA[
				if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof org.web3d.x3d.jsail.X3DConcreteNode))
				{
					primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>[i]; // remember node type
					primaryNode.setParentObject(this);
				}
</xsl:text>	
														</xsl:if>
														<xsl:text>				</xsl:text>
														<xsl:value-of select="@name"/>
														<xsl:text>.add(</xsl:text>
														<xsl:text>(</xsl:text>
														<xsl:value-of select="$javaReferenceType"/>
														<xsl:value-of select="$jsaiClassSuffix"/>
														<xsl:text>)</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>[i]);</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>       ((X3DConcreteElement) </xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>[i]).setParentObject(this); // apparently unused?</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>			}</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>			else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
														<xsl:text>("</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>["+i+"] is not instanceof </xsl:text>
														<xsl:value-of select="$javaReferenceType"/>
														<xsl:value-of select="$jsaiClassSuffix"/>
														<xsl:text>; </xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>=" + </xsl:text>
														<xsl:choose>
															<xsl:when test="starts-with(@type,'MF')">
																<xsl:text>Arrays.toString(</xsl:text>
																<xsl:value-of select="$newValue"/>
																<xsl:text>)</xsl:text>
															</xsl:when>
															<xsl:otherwise>
																<xsl:value-of select="$x3dType"/>
																<xsl:value-of select="$jsaiClassSuffix"/>
																<xsl:text>.toString(</xsl:text>
																<xsl:value-of select="$newValue"/>
																<xsl:text>)</xsl:text>
															</xsl:otherwise>
														</xsl:choose>
														<xsl:text>);</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>		}</xsl:text>
														<xsl:text>&#10;</xsl:text>
													</xsl:when>
													<xsl:otherwise>
														<xsl:text>			</xsl:text>
														<xsl:value-of select="@name"/>
														<xsl:text>.add(</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>[i]);</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>		}</xsl:text>
														<xsl:text>&#10;</xsl:text>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:when>
											<xsl:otherwise>
												<xsl:text>		</xsl:text>
												<xsl:value-of select="$normalizedMemberObjectName"/>
												<xsl:text> = </xsl:text>
												<xsl:value-of select="$newValue"/>
												<xsl:text>;</xsl:text>
												<!-- set SFNode -->
												<xsl:if test="(@type = 'SFNode')">
													<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
													<xsl:text>
		if (</xsl:text><xsl:value-of select="$newValue"/><xsl:text> != null)
		{
			((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>).setParentObject(this); // parentTest15</xsl:text>
													<xsl:text>&#10;</xsl:text>
									<!-- as needed, containerField updates by checking parent node and SFNode field -->
									<!-- Reference list found at X3D Scene Authoring Hints: containerField -->
									<!-- http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField -->
									<xsl:choose>
										<xsl:when test="(($name = 'CADFace') or ($name = 'CollidableShape')) and (@name = 'shape')">
											<xsl:text>			</xsl:text>
											<xsl:text>((X3DConcreteNode)</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("shape");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'Collision') and (@name = 'proxy')">
											<xsl:text>			</xsl:text>
											<xsl:text>((X3DConcreteNode)</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("proxy");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'ComposedCubeMapTexture') and 
														((@name = 'back') or (@name = 'bottom') or (@name = 'front') or
														 (@name = 'left') or (@name = 'right')  or (@name = 'top'))">
											<!-- ImageTexture check -->
											<xsl:text>			((X3DConcreteNode)</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("</xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'Sound') and (@name = 'source')">
											<xsl:text>			if (</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text> instanceof org.web3d.x3d.jsail.Texturing.MovieTextureObject)</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>				((X3DConcreteNode)    </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("source");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="($name = 'TextureBackground') and 
														((@name = 'backTexture') or (@name = 'bottomTexture') or (@name = 'frontTexture') or
														 (@name = 'leftTexture') or (@name = 'rightTexture')  or (@name = 'topTexture'))">
											<!-- ImageTexture check -->
											<xsl:text>			((X3DConcreteNode)</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>).setContainerFieldOverride("</xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
									</xsl:choose>
<xsl:text>		}</xsl:text>
													<xsl:if test="not($isX3dStatement = 'true')">
														<xsl:text>
		if (</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance != null)
		{
			</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance.setParentObject(null); // housekeeping, clear prior object
			</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance = null;
		}</xsl:text>
													</xsl:if>
												</xsl:if>
											</xsl:otherwise>
										</xsl:choose>

										<xsl:text>&#10;</xsl:text>
										<xsl:text>		return this;</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	}</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:otherwise>
								</xsl:choose>
								<xsl:text>&#10;</xsl:text>
								
								<!-- SFNode thoroughness: setFieldName(ProtoInstance newValue) -->
								<xsl:if test="(@type = 'SFNode') and not(@name = 'metadata') and not($isX3dStatement = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign ProtoInstance (using a properly typed node) to </xsl:text>
									<xsl:value-of select="@accessType"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="@type"/>
									<xsl:text> field </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text>.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @see #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<!-- also have setFieldName(ProtoInstance newValue) for SFNode fields -->
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> </xsl:text>
									<xsl:text>set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(ProtoInstance </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:choose>
										<xsl:when test="($isInterface = 'true')">
											<xsl:text>;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	{</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>		</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>ProtoInstance = (ProtoInstanceObject)</xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>;</xsl:text>
											<xsl:text>
		if (</xsl:text><xsl:value-of select="$newValue"/><xsl:text> != null)
		{
			((X3DConcreteElement) </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>ProtoInstance</xsl:text>
											<xsl:text>).setParentObject(this); // parentTest15.5</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	    }</xsl:text>
														<xsl:text>
		if (</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text> != null)
		{
			((X3DConcreteElement) </xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>).setParentObject(null); // housekeeping, clear prior object
			</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text> = null;
		}
</xsl:text>
											<xsl:text>	    return this;</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	}</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<!-- additional field utility methods for concrete classes -->

								<!-- set method using typed field object -->
								<xsl:if test="not(@type='SFNode') and not(@type='MFNode') and
											  not($isInterface = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign typed object </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value to </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$type" disable-output-escaping="yes"/>
									<xsl:value-of select="$jsaiClassSuffix"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									
									<xsl:if test="($isArrayListType = 'true') and not($javaReferenceType = 'X3DNode') and not($isX3dStatement = 'true')">
										<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									</xsl:if>
									<xsl:text>            // set-newValue-validity-checks #1 skipped, handled by set-primitive method</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<!-- stub
									<xsl:text>            // set-newValue-validity-checks #1</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>complex</xsl:text></xsl:with-param>
                                                                                <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									-->
									<xsl:text>            </xsl:text>
									<xsl:text>set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>.getPrimitiveValue());</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>            return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(@type = 'SFVec2f') or (@type = 'SFVec3f') or (@type = 'SFVec4f') or 
												  (@type = 'SFColor') or (@type = 'SFColorRGBA') or (@type = 'SFRotation')">
										<xsl:text>
	/**
	 * Assign values to </xsl:text>
										<xsl:value-of select="@type"/>
										<xsl:text> </xsl:text>
										<xsl:value-of select="$normalizedMemberObjectName"/>
										<xsl:text> field, similar to {@link #set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float[])}.
</xsl:text>
										<xsl:choose>
											<xsl:when test="(@type = 'SFVec2f')">
												<xsl:text>
	 * @param x first component
	 * @param y second component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec3f')">
												<xsl:text>
	 * @param x first component
	 * @param y second component
	 * @param z third component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec4f')">
												<xsl:text>
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param w fourth component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFColor')">
												<xsl:text>
	 * @param red first component
	 * @param green second component
	 * @param blue third component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFColorRGBA')">
												<xsl:text>
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @param alpha fourth component for opaqueness (1 - transparency)
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFRotation')">
												<xsl:text>
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
</xsl:text>
											</xsl:when>
										</xsl:choose>
												<xsl:text>
	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:choose>
											<xsl:when test="(@type = 'SFVec2f')">
												<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float x, float y)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {x, y});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec3f')">
												<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float x, float y, float z)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {x, y, z});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec4f')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float x, float y, float z, float w)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {x, y, z, w});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFColor')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float red, float green, float blue)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {red, green, blue});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFColorRGBA')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float red, float green, float blue, float alpha)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {red, green, blue, alpha});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFRotation')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(float x, float y, float z, float angleRadians)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new float[] {x, y, z, angleRadians});
		return this;
	}
</xsl:text>
											</xsl:when>
										</xsl:choose>
									</xsl:if>
									<xsl:if test="(@type = 'SFVec2d') or (@type = 'SFVec3d') or (@type = 'SFVec4d')">
										<xsl:text>
	/**
	 * Assign values to </xsl:text>
										<xsl:value-of select="@type"/>
										<xsl:text> </xsl:text>
										<xsl:value-of select="$normalizedMemberObjectName"/>
										<xsl:text> field, similar to {@link #set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(double[])}.
	 * @param x first component
	 * @param y second component
</xsl:text>
										<xsl:choose>
											<xsl:when test="(@type = 'SFVec3d')">
												<xsl:text>
	 * @param z third component
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec4d')">
												<xsl:text>
	 * @param z third component
	 * @param w fourth component
</xsl:text>
											</xsl:when>
										</xsl:choose>
												<xsl:text>
	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:choose>
											<xsl:when test="(@type = 'SFVec2d')">
												<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(double x, double y)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new double[] {x, y});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec3d')">
												<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(double x, double y, double z)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new double[] {x, y, z});
		return this;
	}
</xsl:text>
											</xsl:when>
											<xsl:when test="(@type = 'SFVec4d')">
											<xsl:text> set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(double x, double y, double z, double w)
	{
		set</xsl:text>
										<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										<xsl:text>(new double[] {x, y, z, w});
		return this;
	}
</xsl:text>
											</xsl:when>
										</xsl:choose>
									</xsl:if>
								</xsl:if>
								<xsl:if test="(@type = 'MFString')
											   and not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign single SFString object </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value to </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="$isEnumerationType">
										<xsl:text>	 * @see MFStringObject#cleanupEnumerationValues(String)</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:text>S</xsl:text>
									<xsl:value-of select="substring($type,2)" disable-output-escaping="yes"/>
									<xsl:value-of select="$jsaiClassSuffix"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="($isArrayListType = 'true') and not($javaReferenceType = 'X3DNode') and not($isX3dStatement = 'true')">
										<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									</xsl:if>
									<!-- assumption: SF/MF object assignment is OK due to object integrity
									-->
									<xsl:text>		// set-newValue-validity-checks #2</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>complex</xsl:text></xsl:with-param>
									        <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									<xsl:text>		</xsl:text>
									<xsl:text>set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:choose>
										<xsl:when test="$isEnumerationType">
											<xsl:text>MFStringObject.cleanupEnumerationValues(</xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>.toString())); // enumeration values</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$newValue"/>
											<xsl:text>.getValue());</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text></xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
									
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign singleton String </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value to </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="$isEnumerationType">
										<xsl:text>	 * @see MFStringObject#cleanupEnumerationValues(String)</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="($isArrayListType = 'true') and not($javaReferenceType = 'X3DNode') and not($isX3dStatement = 'true')">
										<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									</xsl:if>
									<!-- assumption: SF/MF object assignment is OK due to object integrity
									-->
									<xsl:text>		// set-newValue-validity-checks #3</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>complex</xsl:text></xsl:with-param>
									        <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									<xsl:choose>
										<xsl:when test="$isEnumerationType">			
											<xsl:text>		</xsl:text>
											<xsl:text>set</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
											<xsl:text>(</xsl:text>
											<xsl:text>MFStringObject.cleanupEnumerationValues(</xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>)</xsl:text>
											<xsl:text>); // enumeration values</xsl:text>
										</xsl:when>
										<xsl:otherwise>								
											<xsl:text>		</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>.clear();</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>		</xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
											<xsl:text>.add(</xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>);</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<xsl:if test="((@type='MFNode') or (@type='MFString') or (@type='MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type='MFFloat') or (@type='MFDouble') or (@type='MFTime'))
											   and not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign ArrayList </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									<xsl:text>		// set-newValue-validity-checks #4</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>complex</xsl:text></xsl:with-param>
									        <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									<xsl:value-of select="$newValueArrayListAcceptableNodeTypesTest" disable-output-escaping="yes"/>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> = </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(@type='MFNode')"><!-- setParentObject -->
										<xsl:text>		</xsl:text>
										<xsl:text>for (</xsl:text>
										<xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
										<xsl:text> element : </xsl:text>
										<xsl:value-of select="$newValue"/>
										<xsl:text>)</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>		{</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>			((X3DConcreteElement) element).setParentObject(this); // parentTest13</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:choose>
											<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
												<xsl:text>			((X3DConcreteNode)    element).setContainerFieldOverride("value");</xsl:text>
												<xsl:text>&#10;</xsl:text>
											</xsl:when>
										</xsl:choose>
										<xsl:text>		}</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>		return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<xsl:if test="(@type = 'MFNode') and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove'))) and not($isInterface = 'true')
											   and not($isInterface = 'true') and not($isX3dStatement = 'true')">
									<!-- source code: addSingleThing -->
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Add single </xsl:text>
									<xsl:if test="not(starts-with(@name,'child'))">
										<xsl:text>child </xsl:text>
									</xsl:if>
									<xsl:value-of select="@name"/>
									<xsl:text> node to array of existing nodes (if any).</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text>.</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value to be appended the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:if test="not(@name = 'children') or ($isX3dStatement = 'true')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text>} - namely </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:text>this</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
										<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									</xsl:if>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>

									<xsl:text>	public </xsl:text>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="not(@name = 'children') or ($isX3dStatement = 'true')">
											<xsl:value-of select="ancestor::*[@name]/@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>void</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:choose>
										<xsl:when test="not(starts-with(@name,'add'))">
											<xsl:text> add</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text> </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:when test="(string-length(@acceptableNodeTypes) > 1) and 
														 not(starts-with(@acceptableNodeTypes,'X3D')) and not(contains(@acceptableNodeTypes,'|'))">
											<xsl:value-of select="@acceptableNodeTypes"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- special method, TODO might need another if more than one acceptableNodeTypes -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$javaReferenceType"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>	
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:choose>
										<xsl:when test="(@name = 'children')">
											<xsl:value-of select="$newValueNullReturnVoid"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$newValueNullReturnThis"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>.add(</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>);</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		((X3DConcreteElement) </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>).setParentObject(this); // parentTest2</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:choose>
										<!-- MFNode child -->
										<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
											<xsl:text>		((X3DConcreteNode)    </xsl:text>
											<xsl:value-of select="$newValue"/>
											<xsl:text>).setContainerFieldOverride("value");</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
									</xsl:choose>
									<xsl:if test="($name = 'ProtoBody')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof org.web3d.x3d.jsail.X3DConcreteNode))
		{
			primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>; // remember node type
			primaryNode.setParentObject(this);
		}
</xsl:text>	
									</xsl:if>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="not(@name = 'children') or ($isX3dStatement = 'true')">
											<xsl:text>		return this;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<!-- requirement to match SAI interfaces prevents adding further support -->
									</xsl:choose>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>&#10;</xsl:text>
								
								<!-- duplicate -->
								<xsl:if test="false() and not($isX3dStatement = 'true') and (not($isInterface = 'true') and not(@name = 'children'))">
									<!-- source code: appendSingleThing -->
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Append single </xsl:text>
									<xsl:if test="not(starts-with(@name,'child'))">
										<xsl:text>child </xsl:text>
									</xsl:if>
									<xsl:value-of select="@name"/>
									<xsl:text> node to array of existing nodes (if any).</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text>.</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value to be appended the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:if test="($isX3dStatement = 'true') or (not($isInterface = 'true') and not(@name = 'children'))">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text>} - namely </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:text>this</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
										<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									</xsl:if>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>

									<xsl:text>	public </xsl:text>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true') or (not($isInterface = 'true') and not(@name = 'children'))">
											<xsl:value-of select="ancestor::*[@name]/@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>void</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:choose>
										<xsl:when test="not(starts-with(@name,'add'))">
											<xsl:text> add</xsl:text><!-- [previously append] -->
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text> </xsl:text>
											<xsl:value-of select="$normalizedMemberObjectName"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true') or (not($isInterface = 'true') and not(@name = 'children'))">
											<xsl:value-of select="@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$javaReferenceType"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>	
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:choose>
										<xsl:when test="(not($isInterface = 'true') and not(@name = 'children'))">
											<xsl:value-of select="$newValueNullReturnThis"/><!-- pipeline -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$newValueNullReturnVoid"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>.add(</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>);</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		((X3DConcreteElement) </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>).setParentObject(this); // parentTest4 unneeded?</xsl:text>
									<xsl:text>&#10;</xsl:text>
													<xsl:choose>
														<!-- MFNode child -->
														<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
															<xsl:text>		((X3DConcreteNode)    </xsl:text>
															<xsl:value-of select="$newValue"/>
															<xsl:text>).setContainerFieldOverride("value");</xsl:text>
															<xsl:text>&#10;</xsl:text>
														</xsl:when>
													</xsl:choose>
									<xsl:if test="($name = 'ProtoBody')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text> instanceof org.web3d.x3d.jsail.X3DConcreteNode))
		{
			primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>; // remember node type
			primaryNode.setParentObject(this);
		}
</xsl:text>	
									</xsl:if>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true') or (not($isInterface = 'true') and not(@name = 'children'))">
											<xsl:text>		return this;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<!-- requirement to match SAI interfaces prevents adding further support -->
									</xsl:choose>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>
								
								</xsl:if>

								<xsl:if test="((@type = 'MFNode') and (@name = 'children'))
											   and not($isX3dStatement = 'true') and not($isInterface = 'true')">
<!-- * <br ><br >
	 * <i>Warning:</i> acceptable child node types and statements are limited to X3DChildNode.-->
										<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to add single child element to contained list of existing children nodes (if any).
	 * @param newValue is new node value to be appended the children field.	 
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	*/
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addChild(</xsl:text>
	<xsl:choose>
		<xsl:when test="($name = 'field') or ($name = 'fieldValue')">
			<!-- SceneGraphFragmentContentModel -->
			<xsl:text>X3DNode</xsl:text>
		</xsl:when>
		<xsl:when test="(string-length(@acceptableNodeTypes) > 0) and not(contains(@acceptableNodeTypes, '|'))">
			<xsl:value-of select="@acceptableNodeTypes"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>X3DChildNode</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
]]></xsl:text>
									<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									<!-- $newValueArrayAcceptableNodeTypesTest apparently unnecessary/inappropriate since only single typed value being applied -->
									<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
									<xsl:text>
		children.add(newValue);
		((X3DConcreteElement) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>).setParentObject(this); // parentTest3
		return this;
	}
</xsl:text>
								</xsl:if>
								<!-- special addChild methods for Contour2DObject -->
								<xsl:if test="(($name = 'Contour2D') and (@name = 'children'))
											   and not($isX3dStatement = 'true') and not($isInterface = 'true')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Add single children node to array of existing children nodes (if any) for Contour2D.
	 * @param newValue is new node value to be appended the children field.
	 * @return {@link Contour2DObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public Contour2DObject addChild(NurbsCurve2DObject newValue)
	{
		if (newValue == null) return this; // newValueNullReturnVoid
		children.add(newValue);
		((X3DConcreteElement) newValue).setParentObject(this); // parentTest2
		return this;
	}
	/**
	 * Add single children node to array of existing children nodes (if any) for Contour2D.
	 * @param newValue is new node value to be appended the children field.
	 * @return {@link Contour2DObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public Contour2DObject addChild(ContourPolyline2DObject newValue)
	{
		if (newValue == null) return this; // newValueNullReturnVoid
		children.add(newValue);
		((X3DConcreteElement) newValue).setParentObject(this); // parentTest2
		return this;
	}
]]></xsl:text>
								</xsl:if>
								<xsl:if test="(@type = 'MFNode') and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')) and not(starts-with(@name,'field')))">
									<!-- source code: addSomething -->
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Add array of </xsl:text>
									<xsl:if test="not(starts-with(@name,'child'))">
										<xsl:text>child </xsl:text>
									</xsl:if>
									<xsl:value-of select="@name"/>
									<xsl:text> nodes to array of existing nodes (if any).</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * </xsl:text>
										<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are limited to ]]></xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text>.</xsl:text>
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value array to be appended the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:if test="($isX3dStatement = 'true')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text>} - namely </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:text>this</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
										<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
	<!-- debug -->
	<xsl:if test="($debug = 'true')">
	<xsl:text>// ($isInterface=</xsl:text>
	<xsl:value-of select="$isInterface"/>
	<xsl:text>, preceding-sibling::Inheritance=</xsl:text>
	<xsl:value-of select="preceding-sibling::Inheritance"/>
	<xsl:text>, $isX3dStatement=</xsl:text>
	<xsl:value-of select="$isX3dStatement"/>
	<xsl:text>)</xsl:text>
	<xsl:text>&#10;</xsl:text>
	</xsl:if>
									<xsl:if test="(not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')) or
													 (($isInterface = 'true') and //AbstractNodeType  [@name = $baseType                     ]/InterfaceDefinition/field[@name = $fieldName]) or
													 (($isInterface = 'true') and //AbstractNodeType  [@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
													 (($isInterface = 'true') and //AbstractObjectType[@name = $additionalInheritanceBaseType]/InterfaceDefinition/field[@name = $fieldName]) or
												 (($thisClassName = 'ProtoInstanceObject') and 
												  (($CamelCaseName = 'Metadata') or ($CamelCaseName = 'Name') or ($CamelCaseName = 'DEF') or ($CamelCaseName = 'USE') or ($CamelCaseName = 'CssClass')))">
										<xsl:text>	@Override</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>	public </xsl:text>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="ancestor::*[@name]/@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>void</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:choose>
										<xsl:when test="not(starts-with(@name,'add'))">
											<xsl:text>add</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$normalizedMemberObjectName"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$javaPrimitiveType"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>									
									<xsl:choose>
										<xsl:when test="($isInterface = 'true')">
											<xsl:text>;</xsl:text>
											<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
												<xsl:text> // acceptable node types #3: </xsl:text>
												<xsl:value-of select="@acceptableNodeTypes"/>
											</xsl:if>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	{</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true')">
													<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="$newValueNullReturnVoid"/>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:value-of select="$newValueArrayAcceptableNodeTypesTest" disable-output-escaping="yes"/>
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true') and (@type = 'MFNode')">
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		</xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>.add(</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>).setParentObject(this); // parentTest5</xsl:text>
												</xsl:when>
												<xsl:when test="(@type = 'MFNode')">
													<!-- do not reset array when adding to it -->
													<!-- MFNode subtype checks necessary -->
													<xsl:text>		for (int i = 0; i </xsl:text>
													<xsl:text disable-output-escaping="yes">&lt; </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>.length; i++)</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		{</xsl:text>
													<xsl:if test="($name = 'ProtoBody') and not($isInterface = 'true')">
														<xsl:text disable-output-escaping="yes"><![CDATA[
			if ((primaryNode == null) && (]]></xsl:text><xsl:value-of select="$newValue"/><xsl:text>[i] instanceof org.web3d.x3d.jsail.X3DConcreteNode))
			{
				primaryNode = (X3DConcreteNode) </xsl:text><xsl:value-of select="$newValue"/><xsl:text>[i]; // remember node type
				primaryNode.setParentObject(this);
			}
</xsl:text>	
													</xsl:if>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			if  (</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i] instanceof </xsl:text>
													<xsl:value-of select="$javaReferenceType"/>
													<xsl:text>)</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			{</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>				</xsl:text>
													<xsl:value-of select="@name"/>
													<xsl:text>.add(</xsl:text>
													<xsl:if test="not($isX3dStatement = 'true') and not($javaReferenceType = 'X3DNode')">
														<!-- cast -->
														<xsl:text>(</xsl:text>
														<xsl:value-of select="$javaReferenceType"/>
														<xsl:text>)</xsl:text>
													</xsl:if>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i]);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>				((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>[i]).setParentObject(this); // parentTest6</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:choose>
														<!-- MFNode child -->
														<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
															<xsl:text>				((X3DConcreteNode)    </xsl:text>
															<xsl:value-of select="$newValue"/>
															<xsl:text>[i]).setContainerFieldOverride("value");</xsl:text>
															<xsl:text>&#10;</xsl:text>
														</xsl:when>
													</xsl:choose>
													<xsl:text>			}</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
													<xsl:text>("</xsl:text>
													<xsl:value-of select="$javaPrimitiveType"/>
													<xsl:text> </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>["+i+"] is not instanceof </xsl:text>
													<xsl:value-of select="$javaReferenceType"/>
													<xsl:text>; </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>=" + </xsl:text>
													<xsl:text>Arrays.toString(</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>)</xsl:text>
													<xsl:text>);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		}</xsl:text>
												</xsl:when>
												<xsl:otherwise>
													<xsl:text>		</xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>.add(</xsl:text>
													<!--
													<xsl:if test="(@type = 'MFNode')">
														<xsl:text>(X3DNode)</xsl:text>
													</xsl:if>
													-->
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:if test="(@type = 'MFNode') and (string-length(@acceptableNodeTypes) > 0)">
														<xsl:text> // acceptable node types #4:</xsl:text>
														<xsl:value-of select="@acceptableNodeTypes"/>
													</xsl:if>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:text>&#10;</xsl:text>
											<!-- allow method pipelining, if appropropriate -->
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true')">
													<xsl:text>		return this;</xsl:text>
													<xsl:text>&#10;</xsl:text>
												</xsl:when>
												<!-- requirement to match SAI interfaces prevents adding further support -->
											</xsl:choose>
											<xsl:text>}</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>

								<xsl:if test="(@type = 'MFNode') and (((@name = 'address') or contains(@name, 'Entities') or not(starts-with(@name,'add'))) and not(starts-with(@name,'remove')))">
									<!-- source code: addMFNodeSomething(SFNodeValue) method -->
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Set single </xsl:text>
									<xsl:if test="not(starts-with(@name,'child'))">
										<xsl:text>child </xsl:text>
									</xsl:if>
									<xsl:value-of select="@name"/>
									<xsl:text> node, replacing prior array of existing nodes (if any).</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="($name = 'MetadataSet')">
										<xsl:text disable-output-escaping="yes"><![CDATA[ * <i>Warning:</i> this method can only accept Metadata* nodes.]]></xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:choose>
										<xsl:when test="not($isInterface = 'true') and (string-length(@acceptableNodeTypes) > 1) and not(ends-with(@acceptableNodeTypes,'Object'))">
											<xsl:text>	 * </xsl:text>
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	 * </xsl:text>
											<xsl:text disable-output-escaping="yes"><![CDATA[<i>Note:</i> according to X3D Unified Object Model (X3DUOM), acceptable node types are restricted to ]]></xsl:text>
											<xsl:value-of select="@acceptableNodeTypes"/>
											<xsl:text>.</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:when test="not($isX3dStatement = 'true') and not($isInterface = 'true')">
											<xsl:text>	 * Unable to return this object and pipeline methods since abstract SAI specifies void return type.</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="http://stackoverflow.com/questions/14694852/can-overridden-methods-differ-in-return-type" target="_blank">stackoverflow: Can overridden methods differ in return type?</a>]]></xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
									</xsl:choose>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new node for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field</xsl:text>
									<xsl:if test="not($isInterface = 'true') and (string-length(@acceptableNodeTypes) > 1) and not(ends-with(@acceptableNodeTypes,'Object'))">
										<xsl:text> (restricted to </xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text>)</xsl:text>
									</xsl:if>
									<xsl:if test="($isX3dStatement = 'true')">
										<xsl:text>&#10;</xsl:text>
										<xsl:text>	 * @return {@link </xsl:text>
										<xsl:value-of select="$thisClassName"/>
										<xsl:text>} - namely </xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
										<xsl:text>this</xsl:text>
										<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
										<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
										<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									</xsl:if>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
	<!-- debug -->
	<xsl:if test="($debug = 'true')">
	<xsl:text>// ($isInterface=</xsl:text>
	<xsl:value-of select="$isInterface"/>
	<xsl:text>, preceding-sibling::Inheritance=</xsl:text>
	<xsl:value-of select="preceding-sibling::Inheritance"/>
	<xsl:text>, $isX3dStatement=</xsl:text>
	<xsl:value-of select="$isX3dStatement"/>
	<xsl:text>)</xsl:text>
	<xsl:text>&#10;</xsl:text>
	</xsl:if>
									<xsl:if test="not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
										<xsl:text>	@Override</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>	public </xsl:text>
									<!-- allow method pipelining, if appropropriate -->
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="ancestor::*[@name]/@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<!-- TODO fix/figure out
										<xsl:when test="not($isInterface = 'true') and not(@name = 'children') and (string-length(@acceptableNodeTypes) > 1) and not(ends-with(@acceptableNodeTypes,'Object'))">
											<xsl:value-of select="$name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											< ! - - singleton, no [] - - >
										</xsl:when> --> 
										<xsl:otherwise>
											<xsl:text>void</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:choose>
										<xsl:when test="not(starts-with(@name,'add'))">
											<xsl:text>set</xsl:text>
											<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$normalizedMemberObjectName"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text>(</xsl:text>
									<xsl:choose>
										<xsl:when test="($isX3dStatement = 'true')">
											<xsl:value-of select="@name"/>
											<xsl:value-of select="$jsaiClassSuffix"/>
											<!-- singleton, no [] -->
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
										</xsl:otherwise>
									</xsl:choose>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>									
									<xsl:choose>
										<xsl:when test="($isInterface = 'true')">
											<xsl:text>;</xsl:text>
											<xsl:if test="(string-length(@acceptableNodeTypes) > 1)">
												<xsl:text> // acceptable node types #5: </xsl:text>
												<xsl:value-of select="@acceptableNodeTypes"/>
											</xsl:if>
											<xsl:text>&#10;</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>	{</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:if test="($name = 'ProtoBody')">
												<xsl:text disable-output-escaping="yes"><![CDATA[		if ((newValue == null) && (primaryNode != null))]]></xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		{</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			primaryNode.setParentObject(null); // housekeeping, clear prior object</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>			primaryNode = null; // clear from ProtoBody</xsl:text>
												<xsl:text>&#10;</xsl:text>
												<xsl:text>		}</xsl:text>
												<xsl:text>&#10;</xsl:text>
											</xsl:if>
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true')">
													<xsl:value-of select="$newValueNullClearsFieldReturnThis"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="$newValueNullClearsFieldReturnVoid"/>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:value-of select="$newValueInstanceAcceptableNodeTypesTest" disable-output-escaping="yes"/>
											<xsl:choose>
												<xsl:when test="($name = 'ExternProtoDeclare') and (@name = 'field')">
		<!-- check to ensure that no value is present within field having parent ExternProtoDeclare -->
		<xsl:text disable-output-escaping="yes"><![CDATA[		// No value is allowed within field having parent ExternProtoDeclare
		if ((!newValue.getValue().isEmpty() || !newValue.getChildren().isEmpty()) && newValue.hasChildrenElements())
		{
			String foundValue;
			if (!newValue.getValue().isEmpty())
				 foundValue = newValue.getValue();
			else foundValue = newValue.getChildren().toString();
			
			throw new InvalidProtoException("ExternProtoDeclare name='" + name +
					"' with field name='" + newValue.getName() +
					"' cannot have any initial value (found \"" + foundValue + 
					"\"). Instead use ProtoInstance fieldValue to override the original default ProtoDeclare field value.");
		}
]]></xsl:text>
												</xsl:when>
											</xsl:choose>
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true') and (@type = 'MFNode')">
													<xsl:text>		</xsl:text>
													<xsl:text>for (</xsl:text>
													<xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
													<xsl:text> element : </xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>)</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			((X3DConcreteElement) element).clearParentObject(); // remove references to facilitate Java memory management</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		</xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>.clear();</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		</xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>.add(</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>).setParentObject(this); // parentTest7</xsl:text>
													<xsl:text>&#10;</xsl:text>
												</xsl:when>
												<xsl:when test="(@type = 'MFNode')">
													<xsl:text>		if  (</xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text> instanceof </xsl:text>
													<xsl:choose>
														<xsl:when test="($name = 'ProtoBody')">
															<xsl:text>X3DNode</xsl:text>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="$javaReferenceType"/>
														</xsl:otherwise>
													</xsl:choose>
													<xsl:text>)</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		{</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			</xsl:text>
													<xsl:text>for (</xsl:text>
													<xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
													<xsl:text> element : </xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>)</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>				((X3DConcreteElement) element).clearParentObject(); // remove references to facilitate Java memory management</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			</xsl:text>
													<xsl:value-of select="@name"/>
													<xsl:text>.clear();</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>			((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>).setParentObject(this); // parentTest8</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:choose>
														<!-- MFNode child -->
														<xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
															<xsl:text>			((X3DConcreteNode)    </xsl:text>
															<xsl:value-of select="$newValue"/>
															<xsl:text>).setContainerFieldOverride("value");</xsl:text>
															<xsl:text>&#10;</xsl:text>
														</xsl:when>
													</xsl:choose>
													<xsl:text>			</xsl:text>
													<xsl:if test="($name = 'ProtoBody')">
														<xsl:text>if ((</xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text disable-output-escaping="yes"><![CDATA[ instanceof org.web3d.x3d.jsail.X3DConcreteNode) && (primaryNode == null))]]></xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>				 primaryNode = (X3DConcreteNode) </xsl:text>
														<xsl:value-of select="$newValue"/>
														<xsl:text>; // remember node type</xsl:text>
														<xsl:text>&#10;</xsl:text>
														<xsl:text>			</xsl:text><!-- continue and include primaryNode in children list -->
													</xsl:if>
													<xsl:value-of select="@name"/>
													<xsl:text>.add(</xsl:text>
													<xsl:choose>
														<xsl:when test="not($javaReferenceType = 'X3DNode')">
															<xsl:text>(</xsl:text>
															<xsl:value-of select="$javaReferenceType"/>
															<xsl:text>)</xsl:text>
														</xsl:when>
													</xsl:choose>
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		}</xsl:text>
													<xsl:text>&#10;</xsl:text>
													<xsl:text>		else throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
													<xsl:text>("</xsl:text>
													<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
													<xsl:text> </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text> is not instanceof </xsl:text>
													<xsl:value-of select="$javaReferenceType"/>
													<xsl:text>; </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>=" + </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
												</xsl:when>
												<xsl:otherwise><!-- apparently unused -->
													<xsl:text>		</xsl:text>
													<xsl:value-of select="$normalizedMemberObjectName"/>
													<xsl:text>.add(</xsl:text>
													<!--
													<xsl:if test="(@type = 'MFNode')">
														<xsl:text>(X3DNode)</xsl:text>
													</xsl:if>
													-->
													<xsl:value-of select="$newValue"/>
													<xsl:text>);</xsl:text>
													<xsl:if test="(@type = 'MFNode') and (string-length(@acceptableNodeTypes) > 0)">
														<xsl:text> // acceptable node types #6:</xsl:text>
														<xsl:value-of select="@acceptableNodeTypes"/>
													</xsl:if>
													<xsl:text>		((X3DConcreteElement) </xsl:text>
													<xsl:value-of select="$newValue"/>
													<xsl:text>).setParentObject(this); // parentTest9</xsl:text>
													<xsl:text>&#10;</xsl:text>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:text>&#10;</xsl:text>
											<!-- allow method pipelining, if appropropriate -->
											<xsl:choose>
												<xsl:when test="($isX3dStatement = 'true')">
													<xsl:text>		return this;</xsl:text>
													<xsl:text>&#10;</xsl:text>
												</xsl:when>
												<!-- requirement to match SAI interfaces prevents adding further support, must return void -->
											</xsl:choose>
											<xsl:text>}</xsl:text>
											<xsl:text>&#10;</xsl:text>
											<xsl:text>&#10;</xsl:text>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>

								<xsl:if test="((@type='SFNode') or starts-with($javaType,'X3D')) and not($isInterface = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Utility method to clear </xsl:text>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[ field.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).]]></xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> clear</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>()</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		((X3DConcreteElement) </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>).clearParentObject(); // remove references to facilitate Java memory management</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> = null; // reset SFNode field</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		</xsl:text>
									<xsl:text>return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<xsl:if test="((@type='MFNode') or (@type='MFString') or (@type='MFBool') or (@type = 'MFInt32') or (@type = 'SFImage') or (@type = 'MFImage') or (@type='MFFloat') or (@type='MFDouble') or (@type='MFTime')) and not($isInterface = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Utility method to clear </xsl:text>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[ field.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).]]></xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> clear</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>()</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:if test="(@type='MFNode')">
										<xsl:text>		</xsl:text>
										<xsl:text>for (</xsl:text>
										<xsl:value-of select="$javaReferenceType" disable-output-escaping="yes"/>
										<xsl:text> element : </xsl:text>
										<xsl:value-of select="$normalizedMemberObjectName"/>
										<xsl:text>)</xsl:text>
										<xsl:text>&#10;</xsl:text>
										<xsl:text>			((X3DConcreteElement) element).clearParentObject(); // remove references to facilitate Java memory management</xsl:text>
										<xsl:text>&#10;</xsl:text>
									</xsl:if>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text>.clear(); // reset</xsl:text>
									<xsl:text>&#10;</xsl:text>
	<xsl:if test="($name = 'ProtoBody')">
		<xsl:text>&#10;</xsl:text>
		<xsl:text>		if (primaryNode != null)</xsl:text>
		<xsl:text>&#10;</xsl:text>
		<xsl:text>		{</xsl:text>
		<xsl:text>&#10;</xsl:text>
		<xsl:text>			primaryNode.setParentObject(null); // housekeeping, clear prior object</xsl:text>
		<xsl:text>&#10;</xsl:text>
		<xsl:text>			primaryNode = null; // clear from ProtoBody</xsl:text>
		<xsl:text>&#10;</xsl:text>
		<xsl:text>		}</xsl:text>
		<xsl:text>&#10;</xsl:text>
	</xsl:if>
									<xsl:text>		</xsl:text>
									<xsl:text>return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<xsl:if test="((@type='MFFloat') or (@type='MFDouble') or (@type='MFTime'))
											   and not($isInterface = 'true') and not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * Assign floating-point array </xsl:text>
									<xsl:if test="not($normalizedMemberObjectName = 'value')">
										<xsl:text>value of </xsl:text>
									</xsl:if>
									<xsl:value-of select="@type"/>
									<xsl:text> </xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text> field, similar to {@link #set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(</xsl:text>
									<xsl:value-of select="$javaPrimitiveType" disable-output-escaping="yes"/>
									<xsl:text>)}.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @param </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text> is new value for the </xsl:text>
									<xsl:value-of select="@name"/>
									<xsl:text> field.</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 * @return {@link </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text>} - namely </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
									<xsl:text>this</xsl:text>
									<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
									<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).</xsl:text>
									<!-- https://en.wikipedia.org/wiki/Pipeline_(software) -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	 */</xsl:text><!-- end javadoc -->
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	public </xsl:text>
									<xsl:value-of select="$thisClassName"/>
									<xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(int[] </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:value-of select="$newValueNullSetDEFAULT_VALUE"/>
									<xsl:text>		// set-newValue-validity-checks #5</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:call-template name="set-newValue-validity-checks">
										<xsl:with-param name="elementName"      ><xsl:value-of select="$name"/></xsl:with-param>
										<xsl:with-param name="canThrowFieldValueException"><xsl:value-of select="$canThrowFieldValueException"/></xsl:with-param>
										<xsl:with-param name="isArrayType"      ><xsl:value-of select="$isArrayType"/></xsl:with-param>
										<xsl:with-param name="isArrayListType"  ><xsl:value-of select="$isArrayListType"/></xsl:with-param>
										<xsl:with-param name="x3dType"          ><xsl:value-of select="@type"/></xsl:with-param>
										<xsl:with-param name="javaReferenceType"><xsl:value-of select="$javaReferenceType"/></xsl:with-param>
										<xsl:with-param name="comparisonType"   ><xsl:text>complex</xsl:text></xsl:with-param>
									        <xsl:with-param name="debug"            ><xsl:text>false</xsl:text></xsl:with-param>
									</xsl:call-template>
									<xsl:value-of select="$newValueArrayAcceptableNodeTypesTest" disable-output-escaping="yes"/>
									<xsl:text>		</xsl:text>
									<xsl:value-of select="substring-before($javaPrimitiveType,'[]')" disable-output-escaping="yes"/>
									<xsl:text>[] holdArray = new </xsl:text>
									<xsl:value-of select="substring-before($javaPrimitiveType,'[]')" disable-output-escaping="yes"/>
									<xsl:text>[newValue.length];</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		for (int i = 0; i </xsl:text>
									<xsl:text disable-output-escaping="yes">&lt; </xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>.length; i++)</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		{</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>			</xsl:text>
									<xsl:text>holdArray[i] = (</xsl:text>
									<xsl:value-of select="substring-before($javaPrimitiveType,'[]')" disable-output-escaping="yes"/>
									<xsl:text>)</xsl:text>
									<xsl:value-of select="$newValue"/>
									<xsl:text>[i];</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		}</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		</xsl:text>
									<xsl:text>set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(holdArray);</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>		return this;</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text>	}</xsl:text>
									<xsl:text>&#10;</xsl:text>
								</xsl:if>

								<xsl:if test="(@type='SFNode') and not($isX3dStatement = 'true') and not($isInterface = 'true')">
									<xsl:text>	/**</xsl:text>
									<xsl:text>&#10;</xsl:text>
									<xsl:text disable-output-escaping="yes"><![CDATA[	 * Assign ProtoInstance to <i>]]></xsl:text>
									<xsl:value-of select="$normalizedMemberObjectName"/>
									<xsl:text disable-output-escaping="yes"><![CDATA[</i> field.]]></xsl:text>
									<xsl:if test="(string-length(@acceptableNodeTypes) > 0)">
										<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> ProtoInstance must match acceptable node type]]></xsl:text>
										<xsl:if test="contains(@acceptableNodeTypes,'|')">
											<xsl:text>s</xsl:text>
										</xsl:if>
										<xsl:text> </xsl:text>
										<xsl:value-of select="@acceptableNodeTypes"/>
										<xsl:text>.</xsl:text>
									</xsl:if>
									<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @param newProtoInstanceNode is the new ProtoInstance node for the ]]></xsl:text><xsl:value-of select="@name"/><xsl:text disable-output-escaping="yes"><![CDATA[ field
	 * @see #set]]></xsl:text><xsl:value-of select="translate($CamelCaseName,'-','_')"/>
		<xsl:text>(</xsl:text>
		<xsl:choose>
			<xsl:when test="(@type = 'MFNode') and (($isClassX3dStatement = 'true') or ($isX3dStatement = 'true') or (@name = 'addChildren') or (@name = 'removeChildren'))">
				<xsl:value-of select="$javaType" disable-output-escaping="yes"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$javaPrimitiveType"/>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>)</xsl:text>
		<xsl:if test="contains($CamelCaseName, 'Metadata')">
			<xsl:text>&#10;</xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
		</xsl:if>
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
]]></xsl:text>
									<xsl:text>	public </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> set</xsl:text>
									<xsl:value-of select="translate($CamelCaseName,'-','_')"/> <!-- translate name here to avoid xpath problems -->
									<xsl:text>(ProtoInstanceObject newProtoInstanceNode)
	{
		if (</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text> != null)
		{
			((X3DConcreteElement) </xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>).setParentObject(null); // housekeeping, clear prior object
			</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text> = null;
		}
		</xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance = newProtoInstanceNode;
		if (newProtoInstanceNode != null)
		{
			newProtoInstanceNode.setParentObject(this);
</xsl:text>
                        <xsl:choose>
                                <xsl:when test="(($name = 'CADFace') or ($name = 'CollidableShape')) and (@name = 'shape')">
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("shape");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <xsl:when test="($name = 'Collision') and (@name = 'proxy')">
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("proxy");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <xsl:when test="(($name = 'ComposedCubeMapTexture') and 
                                                    ((@name = 'back') or (@name = 'bottom') or (@name = 'front') or
                                                     (@name = 'left') or (@name = 'right')  or (@name = 'top'))) or
                                                (($name = 'Appearance') and (@name = 'material'))">
                                        <!-- ImageTexture check -->
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("</xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <!-- MFNode child -->
                                <xsl:when test="($name = 'MetadataSet') and (@name = 'value')">
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("value");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <xsl:when test="($name = 'Sound') and (@name = 'source')">
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("source");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                                <xsl:when test="($name = 'TextureBackground') and 
												((@name = 'backTexture') or (@name = 'bottomTexture') or (@name = 'frontTexture') or
												 (@name = 'leftTexture') or (@name = 'rightTexture')  or (@name = 'topTexture'))">
                                        <!-- ImageTexture check -->
                                        <xsl:text>			newProtoInstanceNode.setContainerFieldOverride("</xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
                                        <xsl:text>&#10;</xsl:text>
                                </xsl:when>
                        </xsl:choose>
			<xsl:text>		}
		return this;
	}
	/**
	 * Provide properly typed ProtoInstance for </xsl:text><xsl:value-of select="@accessType"/>
		<xsl:text disable-output-escaping="yes"><![CDATA[ SFNode field <i>]]></xsl:text>
		<xsl:value-of select="$normalizedMemberObjectName"/>
		<xsl:text disable-output-escaping="yes"><![CDATA[</i>, if available.
	 * @see #get]]></xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>()</xsl:text>
	<xsl:if test="contains($CamelCaseName, 'Metadata')">
		<xsl:text>&#10;</xsl:text>
		<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
	</xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return ProtoInstance value of geometry field
	 */
	public ProtoInstanceObject get]]></xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>ProtoInstance()
	{
		return </xsl:text><xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance;
	}
</xsl:text>
								</xsl:if>
								
								<xsl:if test="(($type='SFNode') or ($type='MFNode')) and not($isInterface = 'true')">
									<xsl:text>
	/**
	 * Indicate whether an object is available for </xsl:text><xsl:value-of select="@accessType"/>
		<xsl:text> </xsl:text><xsl:value-of select="$type"/><xsl:text disable-output-escaping="yes"><![CDATA[ field <i>]]></xsl:text>
		<xsl:value-of select="$normalizedMemberObjectName"/>
		<xsl:text disable-output-escaping="yes"><![CDATA[</i>.
	 * @return whether a ]]></xsl:text>
	 <xsl:choose>
		 <xsl:when test="($isX3dStatement = 'true')">
			 <xsl:text>concrete statement </xsl:text>
		 </xsl:when>
		 <xsl:otherwise>
			 <xsl:text>properly typed node or ProtoInstance </xsl:text>
		 </xsl:otherwise>
	 </xsl:choose>
	 <xsl:if test="($type='MFNode')">
		 <xsl:text>array </xsl:text>
	 </xsl:if>
	 <xsl:text>or CommentsBlock is available.
	 * @see #get</xsl:text><xsl:value-of select="$CamelCaseName"/>
	 <xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
		 <xsl:text>List</xsl:text>
	 </xsl:if>
	 <xsl:text>()</xsl:text>
	 <xsl:if test="($type='SFNode') and not($isX3dStatement = 'true')">
		 <xsl:text>
	 * @see #get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>ProtoInstance()</xsl:text>
	 </xsl:if>
	<xsl:if test="contains($CamelCaseName, 'Metadata')">
		<xsl:text>&#10;</xsl:text>
		<xsl:text disable-output-escaping="yes"><![CDATA[	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
	</xsl:if>
	 <xsl:text>
	 */
	public boolean has</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>()
	{
		return </xsl:text>
		<xsl:choose>
			<xsl:when test="($type='MFNode') and not($isX3dStatement = 'true')">
				<xsl:text>(!</xsl:text>
				<xsl:value-of select="$normalizedMemberObjectName"/>
				<xsl:text>.isEmpty())</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>(</xsl:text>
				<xsl:value-of select="$normalizedMemberObjectName"/>
				<xsl:choose>
					<xsl:when test="($isX3dStatement = 'true') and (@type='MFNode')">
						<xsl:text>.isEmpty() == false)</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text> != null)</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="($type='SFNode') and not($isX3dStatement = 'true')">
			<xsl:text> || (</xsl:text>
			<xsl:value-of select="$normalizedMemberObjectName"/><xsl:text>ProtoInstance != null)</xsl:text>
		</xsl:if>
		<xsl:text>;
	}
</xsl:text>
								</xsl:if>
								<!-- end of per-field set accessors and field utility methods for concrete classes -->
							</xsl:if>
							
								<xsl:choose>
									<xsl:when test="((@name = 'children') and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
														not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CADPart'))
													or (@name = 'GeoLOD')"> <!-- GeoLOD has outputOnly children field -->
										<xsl:text>
	/**
	 * Add comment as CommentsBlock to children field
	 * @param newComment initial value
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	@Override
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (String newComment)
	{
		if (newComment == null) return this;
		children.add(new CommentsBlock (newComment));
		return this;
	}
	/**
	 * Add comments as String[] array to children field
	 * @param newComments array of comments
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	@Override
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (String[] newComments)
	{
		if (newComments == null) return this;
		children.add(new CommentsBlock (newComments));
		return this;
	}
	/**
	 * Add CommentsBlock to children field
	 * @param newCommentsBlock block of comments to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	@Override
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (CommentsBlock newCommentsBlock)
	{
		if (newCommentsBlock == null) return this;
		children.add(newCommentsBlock);
		return this;
	}
										</xsl:text>
									</xsl:when>
								</xsl:choose>
								
							<!-- debug
							<xsl:message>
								<xsl:text>*** @CamelCaseName=</xsl:text>
								<xsl:value-of select="$CamelCaseName"/>
								<xsl:text>, accessType=</xsl:text>
								<xsl:value-of select="@accessType"/>
							</xsl:message> -->
						</xsl:if>
						
					</xsl:for-each>
					<!-- finished with InterfaceDefinition/field loop -->

					<xsl:if test="($hasImplementationBlock)">
						<xsl:if test="starts-with(normalize-space($implementationBlock),'{')">
							<xsl:message>
								<xsl:text>*** Code-generation warning: $implementationBlock starts with {</xsl:text>
							</xsl:message>
						</xsl:if>
						<xsl:value-of select="$implementationBlock" disable-output-escaping="yes"/> <!-- typically has additional javadoc included -->
					</xsl:if>

					<!-- Additional one-per-class utility methods -->
					<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
								  not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not(starts-with($thisClassName, 'X3DConcrete')) and
								  not($isUtilityClass = 'true')">
						
						<xsl:text>&#10;</xsl:text>
						<xsl:text>	// Additional utility methods for this class ==============================
</xsl:text>
						<xsl:variable name="hasChild">
							<xsl:value-of select="(count(*) + count(comment()) > 0)"/>
						</xsl:variable>
						<xsl:variable name="hasAttributes">
							<xsl:value-of select="(count(*) + count(comment()) > 0)"/>
						</xsl:variable>
						<xsl:variable name="isX3dStatement">
							<xsl:call-template name="isX3dStatement">
								<xsl:with-param name="name" select="@name"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:if test="(not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')) or ($name = 'ProtoInstance')">
	<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign field named <i>IS</i> for establishing IS/connect field connections between ProtoInterface fields and internal ProtoBody nodes.
	 * The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
	 * @param newValue is new value for the description field.
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS">X3D Tooltips: IS</a>
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect">X3D Tooltips: connect</a>
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	@Override
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setIS(ISObject newValue)
	{
		if (IS != null)
			IS.setParentObject(null); // housekeeping, clear prior object
		IS = newValue;
		IS.setParentObject(this);
		return this;
	}
	/**
	 * Provide field named <i>IS</i> for establishing IS/connect field connections between ProtoInterface fields and internal ProtoBody nodes.
	 * The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS">X3D Tooltips: IS</a>
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect">X3D Tooltips: connect</a>
	 * @return current ISObject, if any.
	 */
	@Override
	public ISObject getIS()
	{
		return IS;
	}
	/**
	 * Assign a USE reference to another DEF node of same node type, similar to {@link #setUSE(String)}.
	 * <br ><br >
	 * <i>Warning:</i> note that the <code>setUSE()</code> method on this node resets all other fields to their default values (except for containerField) and also releases all child nodes.
	 * <br><br>
	 * <i>Warning:</i> no other operations can be performed to modify a USE node other than setting an alternate containerField value.
	 * @param DEFnode must have a DEF value defined
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ setUSE(]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ DEFnode)
	{
		if (DEFnode.getDEF().isEmpty())
		{
			String errorNotice = "setUSE(DEFnode) invoked on ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[" +
				" that has no DEF name defined, thus a copy cannot be referenced as a USE node";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
		setUSE(DEFnode.getDEF());
		return this;
	}]]></xsl:text>
						</xsl:if>
						
						<!-- utility constructor for nodes -->
						<xsl:if test="not($isX3dStatement = 'true') and not($isClassX3dStatement = 'true')">
								<xsl:text>
	/**
	 * Utility constructor that assigns DEF label after initializing member variables with default values.
	 * @param DEFlabel unique DEF name for this X3D node
	 */
	public </xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String DEFlabel)
	{
		initialize();
		setDEF(DEFlabel); // apply checks
	}
]]></xsl:text>
						</xsl:if>
						<!-- Additional utility constructors -->
						<xsl:choose>
							<!-- Constructors for nodes with name attributes and string values -->
							<xsl:when test="($name = 'component')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor that assigns name and level attributes.
	 * @param newName  name for this component
	 * @param newLevel level value for this component element
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#component">X3D Tooltips: component</a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String newName, int newLevel)
	{
		initialize();
		setName   (newName);
		setLevel(newLevel);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'meta')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor that assigns name-value pair for name and content attributes.
	 * @param newName  name for this meta element
	 * @param newContent content value for this meta element
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#meta">X3D Tooltips: meta</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#metaStatements" target="_blank">X3D Scene Authoring Hints: meta Statements</a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String newName, String newContent)
	{
		initialize();
		setName   (newName);
		setContent(newContent);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'MetadataString')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor that assigns name-value pair, after initializing member variables with default values.
	 * @param DEFlabel unique DEF name for this X3D node
	 * @param newName  name for this meta element
	 * @param newValue content value for this meta element
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataString">X3D Tooltips: MetadataString</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String DEFlabel, String newName, String newValue)
	{
		initialize();
		setDEF  (DEFlabel);
		setName (newName);
		setValue(newValue);
	}
	/**
	 * Utility constructor that assigns DEF plus name-value pair, after initializing member variables with default values.
	 * @param newName  name for this meta element
	 * @param newValue content value for this meta element
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataString">X3D Tooltips: MetadataString</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String newName, String newValue)
	{
		initialize();
		setName (newName);
		setValue(newValue);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="starts-with($name, 'Metadata') or starts-with($name, 'CAD') or starts-with($name, 'HAnim')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor that assigns both DEF label and name, after initializing member variables with default values.
	 * @param DEFlabel unique DEF name for this X3D node
	 * @param newName  name for this meta element
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[">X3D Tooltips: ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[</a>]]></xsl:text>
			<xsl:if test="starts-with($name, 'Metadata')">
	<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>]]></xsl:text>
			</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[
	 */
	public ]]></xsl:text>
			<xsl:value-of select="$thisClassName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ (String DEFlabel, String newName)
	{
		initialize();
		setDEF  (DEFlabel);
		setName (newName);
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare') or ($name = 'ProtoInstance')">
		<xsl:choose>
			<xsl:when test="($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
								<xsl:text>
	/**
	 * Utility constructor that assigns </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> name after initializing member variables with default values.
	 * @param prototypeName initial name for this </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> statement
	 */
	public </xsl:text>
			<xsl:value-of select="$thisClassName"/><xsl:text><![CDATA[ (String prototypeName)
	{
		initialize();
		setName(prototypeName); // apply checks
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'ProtoInstance')">
				<xsl:text>
	/**
	 * Utility constructor that assigns </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> DEF and prototypeName after initializing member variables with default values.
	 * @param DEFlabel unique DEF name for this X3D node
	 * @param prototypeName initial name for this </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> statement
	 */
	public ProtoInstanceObject (String DEFlabel, String prototypeName)
	{
		initialize();
		setDEF (DEFlabel);       // apply checks
		setName(prototypeName); // apply checks
	}

	/**
	 * Utility method that assigns </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text><![CDATA[ containerField value
	 * <i>Hint:</i> ordinarily this method is unnecessary for end users.
	 * @param containerFieldName overriding value
	 * @see org.web3d.x3d.jsail.X3DConcreteNode#setContainerFieldOverride(String)
	 * @return {@link ProtoInstanceObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	// TODO consider making private
	public ProtoInstanceObject setContainerField(String containerFieldName)
	{
		setContainerFieldOverride(containerFieldName);
		return this;
	}
		 
	/**
	 * Determine whether a corresponding ProtoDeclare with same name is connected in this scene graph.
	 * @see #hasExternProtoDeclare
	 * @see #getProtoDeclare
	 * @see #getExternProtoDeclare
	 * @return {@link ProtoInstanceObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public boolean hasProtoDeclare ()
	{
		// check for corresponding declaration
		if  (findAncestorSceneObject() == null)
			 return false;
		X3DConcreteElement matchingDeclaration = findAncestorSceneObject().findElementByNameValue(getName(), ProtoDeclareObject.NAME); 
		if      ((matchingDeclaration != null) && (matchingDeclaration instanceof org.web3d.x3d.jsail.Core.ProtoDeclareObject))
		{
			 referenceProtoDeclare = (ProtoDeclareObject) matchingDeclaration;
			 return true;
		}
		else return false;
	}
		 
	/**
	 * Determine whether a corresponding ExternProtoDeclare with same name is connected in this scene graph.
	 * @see #hasProtoDeclare
	 * @see #getProtoDeclare
	 * @see #getExternProtoDeclare
	 * @return {@link ProtoInstanceObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public boolean hasExternProtoDeclare ()
	{
		// check for corresponding declaration
		if  (findAncestorSceneObject() == null)
			 return false;
		X3DConcreteElement matchingDeclaration = findAncestorSceneObject().findElementByNameValue(getName(), ExternProtoDeclareObject.NAME); 
		if      ((matchingDeclaration != null) && (matchingDeclaration instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclareObject))
		{
			 referenceExternProtoDeclare = (ExternProtoDeclareObject) matchingDeclaration;
			 return true;
		}
		else return false;
	}

	/**
	 * Provide corresponding ProtoDeclare with same name if connected in this scene graph.
	 * @see #hasProtoDeclare
	 * @see #hasExternProtoDeclare
	 * @see #getExternProtoDeclare
	 * @return {@link ProtoInstanceObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ProtoDeclareObject getProtoDeclare ()
	{
		if  (hasProtoDeclare())
			 return referenceProtoDeclare;
		else return null;
	}
	/**
	 * Provide corresponding ExternProtoDeclare with same name if connected in this scene graph.
	 * @see #hasProtoDeclare
	 * @see #hasExternProtoDeclare
	 * @see #getProtoDeclare
	 * @return {@link ProtoInstanceObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ExternProtoDeclareObject getExternProtoDeclare ()
	{
		if  (hasExternProtoDeclare())
			 return referenceExternProtoDeclare;
		else return null;
	}
]]></xsl:text>
			</xsl:when>
		</xsl:choose>
		
				<!-- getNodeType() -->
				<xsl:text>
	/**
	 * </xsl:text>
	 <xsl:if test="($name = 'ExternProtoDeclare')">
		 <xsl:text disable-output-escaping="yes"><![CDATA[(<i>Warning:</i> not yet supported in ExternProtoDeclareObject implementation, TODO) ]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[Inspect first node within ProtoDeclare ProtoBody to determine node type of corresponding ProtoInstance]]></xsl:text>
	 <xsl:if test="($name = 'ProtoDeclare')">
		 <xsl:text disable-output-escaping="yes"><![CDATA[, local copy maintained in ProtoBody <i>primaryNode</i>]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[.
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/concepts.html#PROTOdefinitionsemantics">X3D Abstract Specification: 4.4.4.3 PROTO definition semantics</a>]]></xsl:text>
	 <xsl:choose>
		 <xsl:when test="($name = 'ProtoDeclare')">
			 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see ProtoBodyObject#getNodeType()
	 * @see ExternProtoDeclareObject#getNodeType()
	 * @see ProtoInstanceObject#getNodeType()
	 * @see SceneObject]]></xsl:text>
		 </xsl:when>
		 <xsl:when test="($name = 'ExternProtoDeclare')">
			 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see ProtoDeclareObject#getNodeType()
	 * @see ProtoBodyObject#getNodeType()
	 * @see ProtoInstanceObject#getNodeType()
	 * @see SceneObject]]></xsl:text>
		 </xsl:when>
		 <xsl:when test="($name = 'ProtoInstance')">
			 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see ProtoDeclareObject#getNodeType()
	 * @see ProtoBodyObject#getNodeType()
	 * @see ExternProtoDeclareObject#getNodeType()
	 * @see SceneObject]]></xsl:text>
		 </xsl:when>
	 </xsl:choose>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
		 
	 * @return name of X3D node corresponding to node type for this ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> statement
	 */
	public String getNodeType()
	{</xsl:text>
		<xsl:choose>
			<xsl:when test="($name = 'ProtoDeclare')">
				<xsl:text>
		String errorNotice = new String();
		if (ProtoBody != null)
			 return ProtoBody.getNodeType();
		else 
		{
			errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE + ": " +
						   "ProtoDeclare name='" + getName() + "' has no ProtoBody and thus has no node type yet.";
			validationResult.append(errorNotice).append("\n");
			return errorNotice; // node type not found
		}</xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'ExternProtoDeclare')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		String errorNotice = new String();
		if (findAncestorSceneObject() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_UNKNOWN_EXTERNPROTODECLARE_NODE_TYPE + ": " +
						   "ExternProtoDeclare name='" + getName() + "' must first be connected to SceneObject scene graph in order to get checked.";
				validationResult.append(errorNotice).append("\n");
			}
			return errorNotice; // node type not found
		}
		// TODO contained-comment convention for noting node type
		// TODO remote loading of external ProtoDeclare lookup of type
		errorNotice = ConfigurationProperties.ERROR_UNKNOWN_EXTERNPROTODECLARE_NODE_TYPE + ": " +
					   "ExternProtoDeclare name='" + getName() + "' type cannot be remotely accessed at run time, TODO X3DJSAIL needs to add further capability.";
		validationResult.append(errorNotice).append("\n");
		return errorNotice; // node type not found]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'ProtoInstance')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// check for corresponding declaration
		String errorNotice = new String();
		if (findAncestorSceneObject() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE + ": " +
							   "ProtoInstance name='" + getName() + "' must first be connected to SceneObject scene graph in order to get checked.";
				validationResult.append(errorNotice).append("\n");
				return ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH + "_PrototypeNotFound"; // node type not found
			}
			else return errorNotice;
		}
		X3DConcreteElement matchingDeclaration = null;
		if (findAncestorSceneObject() != null)
			matchingDeclaration = findAncestorSceneObject().findElementByNameValue(getName(), ProtoDeclareObject.NAME); 
		if      ((matchingDeclaration != null) && (matchingDeclaration instanceof org.web3d.x3d.jsail.Core.ProtoDeclareObject))
		{
			// added matching methods for getNodeType() in ProtoDeclare, ProtoBody
			return ((ProtoDeclareObject) matchingDeclaration).getNodeType();
		}
		matchingDeclaration = findAncestorSceneObject().findElementByNameValue(getName(), ExternProtoDeclareObject.NAME);
		if ((matchingDeclaration != null) && (matchingDeclaration instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclareObject))
		{
			return ((ExternProtoDeclareObject) matchingDeclaration).getNodeType();
		}
		else
		{
			errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE + ": " +
						   "ProtoInstance name='" + getName() + "' has no corresponding ProtoDeclareObject or ExternProtoDeclareObject to provide type.";
			validationResult.append(errorNotice).append("\n");
			return errorNotice; // node type not found
		}]]></xsl:text>
			</xsl:when>
		</xsl:choose>
<xsl:text>
	}
</xsl:text>
								<xsl:if test="($name = 'ProtoDeclare')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Find contained field statement by name, if present in contained ProtoInterface.
	 * @param fieldName is name attribute for field of interest
	 * @return fieldObject reference of interest, null otherwise
	 */
	public fieldObject findFieldByName (String fieldName)
	{
		if  (hasProtoInterface())
			 return getProtoInterface().findFieldByName(fieldName);
		else return null;
	}
	/**
	 * Determine if field statement is present in contained ProtoInterface.
	 * @param fieldName is name attribute for field of interest
	 * @return whether field is found
	 */
	public boolean hasField (String fieldName)
	{
		return (findFieldByName(fieldName) != null);
	}
]]></xsl:text>
								</xsl:if>
							</xsl:when>
							<xsl:when test="($name = 'ProtoBody')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * First node within ProtoDeclare ProtoBody determines node type of corresponding ProtoInstance, local reference maintained in member variable named <i>primaryNode</i>.
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/concepts.html#PROTOdefinitionsemantics">X3D Abstract Specification: 4.4.4.3 PROTO definition semantics</a>
	 * @see ProtoDeclareObject#getNodeType()
	 * @see ExternProtoDeclareObject#getNodeType()
	 * @see ProtoInstanceObject#getNodeType()
	 * @see SceneObject
	 * @return name of X3D node corresponding to node type for this ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ statement
	 */
	public String getNodeType()
	{
		if (primaryNode != null)
		     return primaryNode.getElementName();
		else
		{
			String errorNotice = new String();
			String prototypeName = "ParentProtoDeclareNameNotKnown";
			if (getParentObject() !=  null)
				prototypeName = ((ProtoDeclareObject)getParentObject()).getName();
			errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE + ": " +
						   "ProtoDeclare name='" + prototypeName + "' ProtoBody has no initial node and thus has no node type yet.";
			validationResult.append(errorNotice).append("\n");
			return errorNotice; // node type not found
		}
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'field')">
								<xsl:text>
	// no other constructors because field must have name, type, accessType (required)
	/**
	 * Utility constructor that assigns name, type, accessType (required)
	 * @param fieldName name for this field (required, and locally unique among peer fields)
	 * @param fieldType appropriate type value for this field (required)
	 * @param fieldAccessType appropriate accessType value for this field (required)
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text> (String fieldName, String fieldType, String fieldAccessType)
	{
		initialize();
		      setName(fieldName);		// apply checks
		      setType(fieldType);		// apply checks
		setAccessType(fieldAccessType);	// apply checks
	}
	/**
	 * Utility constructor that assigns name, type, accessType (required) and default value (if appropriate)
	 * @param fieldName name for this field (required, and locally unique among peer fields)
	 * @param fieldType appropriate type value for this field (required)
	 * @param fieldAccessType appropriate accessType value for this field (required)
	 * @param defaultValue string version of default value for this field (if appropriate)
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text> (String fieldName, String fieldType, String fieldAccessType, String defaultValue)
	{
		initialize();
		      setName(fieldName);		// apply checks
		      setType(fieldType);		// apply checks
		setAccessType(fieldAccessType);	// apply checks
		     setValue(defaultValue);	// apply checks
	}
</xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'fieldValue')">
								<xsl:text>
	/**
	 * Utility constructor that also assigns fieldValueName
	 * @param fieldValueName unique DEF name for this X3D node
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text> (String fieldValueName)
	{
		initialize();
		setName(fieldValueName);
	}
	/**
	 * Utility constructor that also assigns fieldValueName, defaultValue
	 * @param fieldValueName unique name for this field
	 * @param defaultValue string version of defaultValue for this field
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text> (String fieldValueName, String defaultValue)
	{
		initialize();
		setName (fieldValueName);
	    setValue(defaultValue);
	}
</xsl:text>
							</xsl:when>

<!-- error prone, not included:

							<xsl:when test="($name = 'connect')">
								<xsl:text>
	/**
	 * Utility constructor that assigns both nodeField and protoField (be sure to get order correct).
	 * @param protoField field name in the containing Prototype interface
	 * @param nodeField field name in the parent node that is getting connected
	 */
	public </xsl:text>
	<xsl:value-of select="$thisClassName"/>
	<xsl:text> (String protoFieldName, String nodeFieldName)
	{
		initialize();
		setProtoField(protoFieldName);
		setNodeField( nodeFieldName);
	}
</xsl:text>
							</xsl:when>
-->
						</xsl:choose> <!-- utility constructors -->

						<!-- Additional utility methods -->
						<xsl:if test="($name = 'field') or ($name = 'fieldValue')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Indicate whether a node or statement is found in inputOutput MFNode field <i>children</i>.
	 * @return whether a node or statement is found; ignores CommentsBlock.
	 * @see #getChildren()
	 */
	public boolean hasChildrenElements()
	{
		if (children.isEmpty())
			return false; // nothing found
		for (X3DNode node : children)
		{
			if (!(node instanceof CommentsBlock))
				return true;
		}
		return false; // nothing but CommentsBlock found
	}
]]></xsl:text>
						</xsl:if>
						
						<!-- commentsBlock -->
						<xsl:if test="(not($hasChildrenField = 'true') and not(starts-with($name, 'X3DConcrete')) and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
									   not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock'))">
							<xsl:text>
	/**
	 * Add comment as String to contained commentsList.
	 * @param newComment initial value
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	@Override
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (String newComment)
	{</xsl:text>
							<xsl:if test="not($isX3dStatement = 'true')">
								<xsl:text>
		if (isUSE())
		{
			String errorNotice = "addComments(\"" + newComment + "\")" + "\n" +
					"cannot be applied to a USE node (USE='" + getUSE() + "') which only contains a reference to a DEF node";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
								</xsl:text>
							</xsl:if>
								<xsl:text>
		commentsList.add(newComment);
		return this;
	}
	/**
	 * Add comments as String[] array to contained commentsList.
	 * @param newComments array of comments
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	@Override
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (String[] newComments)
	{</xsl:text>
							<xsl:if test="not($isX3dStatement = 'true')">
								<xsl:text>
		if (isUSE())
		{
			String errorNotice = "addComments(" + Arrays.toString(newComments) + ")" + "\n" +
					"cannot be applied to a USE node (USE='" + getUSE() + "') which only contains a reference to a DEF node";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
								</xsl:text>
							</xsl:if>
								<xsl:text>
		commentsList.addAll(Arrays.asList(newComments));
		return this;
	}
	/**
	 * Add CommentsBlock to contained commentsList.
	 * @param newCommentsBlock block of comments to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	@Override
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addComments (CommentsBlock newCommentsBlock)
	{</xsl:text>
							<xsl:if test="not($isX3dStatement = 'true')">
								<xsl:text>
		if (isUSE())
		{
			String errorNotice = "addComments(CommentsBlock) " +
					"cannot be applied to a USE node (USE='" + getUSE() + "') which only contains a reference to a DEF node";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
								</xsl:text>
							</xsl:if>
								<xsl:text>
		commentsList.addAll(newCommentsBlock.toStringList());
		return this;
	}</xsl:text>
						</xsl:if>
							
						<!-- toStringX3D, toStringXML -->
						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">
							<xsl:text disable-output-escaping="yes"><![CDATA[
		
	/**
	 * Recursive method to provide X3D string serialization of this model subgraph, utilizing XML encoding and conforming to X3D Canonical Form.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3DObject#FILE_EXTENSION_X3D
	 * @see X3DObject#FILE_EXTENSION_XML
	 * @see X3DObject#toStringXML()
	 * @see X3DObject#toFileXML(String)
	 * @see X3DObject#toFileX3D(String)
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @return X3D string
	 */
	@Override
	public String toStringX3D(int indentLevel)
	{]]></xsl:text>
	<xsl:if test="not($name = 'CommentsBlock')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
		boolean hasAttributes = true; // TODO check for non-default attribute values
		boolean      hasChild = ]]></xsl:text>
		<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) or ($name = 'ProtoInstance')">
			<xsl:text>(IS != null) || </xsl:text>
		</xsl:if>
		<xsl:variable name="fieldsList" select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and 
														((@accessType='initializeOnly') or (@accessType='inputOutput'))]"/>
		<xsl:for-each select="$fieldsList">
			<xsl:variable name="isX3dStatement">
				<xsl:call-template name="isX3dStatement">
					<xsl:with-param name="name" select="@name"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram')">
					<xsl:text>(!fieldList.isEmpty()) || (!sourceCode.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ComposedShader') or ($name = 'PackagedShader')">
					<xsl:text>(!fieldList.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ShaderPart')">
					<xsl:text>(!sourceCode.isEmpty()) || </xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="(@type = 'SFNode')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="@name"/>
					<xsl:text> != null)</xsl:text>
					<xsl:if test="not($isX3dStatement = 'true')">
						<xsl:text> || (</xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text>ProtoInstance != null)</xsl:text>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise><!-- (@type='MFNode') -->
					<xsl:text>(!</xsl:text>
					<xsl:value-of select="@name"/>
					<xsl:if test="($isX3dStatement = 'true')">
						<xsl:text>List</xsl:text><!-- append to member name -->
					</xsl:if>
					<xsl:text>.isEmpty())</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			
			<xsl:if test="(last() > position()) or not($hasChildrenField = 'true')">
				<xsl:text> || </xsl:text>
			</xsl:if>
		</xsl:for-each>
		<xsl:choose>
			<xsl:when test="not($hasChildrenField = 'true')">
				<xsl:text disable-output-escaping="yes">!commentsList.isEmpty()</xsl:text>
			</xsl:when>
			<xsl:when test="1 > count($fieldsList)">
				<xsl:text>false</xsl:text><!-- TODO account for CommentsBlock -->
			</xsl:when>
		</xsl:choose>
		<xsl:text>;
</xsl:text><!-- hasChild definition complete -->
	</xsl:if>
	<xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
		if (isUSE())
			hasChild = false; // USE nodes only include attributes for USE and non-default containerField]]></xsl:text><!-- append to member name -->
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder indent = new StringBuilder();
		int  indentIncrement = ConfigurationProperties.getIndentIncrement();
		char indentCharacter = ConfigurationProperties.getIndentCharacter();
		for (int i = 0; i < (indentLevel * indentIncrement); i++)
			indent.append(indentCharacter); // level of indentation for this level

		StringBuilder stringX3D = new StringBuilder();
]]></xsl:text>						
		
		<!-- special constants needed for serialization toStringX3D -->
		<xsl:choose>					
			<xsl:when test="($name = 'X3D')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringX3D.append(XML_HEADER).append("\n");
		switch (version)
		{
			case "3.0":
				stringX3D.append(XML_DOCTYPE_X3D_3_0).append("\n");
				break;
			case "3.1":
				stringX3D.append(XML_DOCTYPE_X3D_3_1).append("\n");
				break;
			case "3.2":
				stringX3D.append(XML_DOCTYPE_X3D_3_2).append("\n");
				break;
			case "3.3":
				stringX3D.append(XML_DOCTYPE_X3D_3_3).append("\n");
				break;
			case "4.0":
				stringX3D.append(XML_DOCTYPE_X3D_4_0).append("\n");
				break;
			case "4.1":
				stringX3D.append(XML_DOCTYPE_X3D_4_1).append("\n");
				break;
			default:
				stringX3D.append("<!-- unknown DOCTYPE for X3D version ").append(version).append(" -->").append("\n");
		}]]></xsl:text>
			</xsl:when>
		</xsl:choose>
		
		<xsl:choose>
			<xsl:when test="($name = 'CommentsBlock')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		for (String comment : commentsList)
		{
                    if (ConfigurationProperties.isNormalizeCommentWhitespace())
                    {
                        // https://stackoverflow.com/questions/3958955/how-to-remove-duplicate-white-spaces-in-string-using-java
                        comment = comment.replaceAll("\\s+", " ");
                    }
                    stringX3D.append(indent).append("<!-- ").append(CommentsBlock.cleanXmlCommentDelimiters(comment).trim()).append(" -->").append("\n");
		}]]></xsl:text>
			</xsl:when>
			<xsl:otherwise>
				
		<xsl:text disable-output-escaping="yes"><![CDATA[
		stringX3D.append(indent).append("<]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA["); // start opening tag
		if (hasAttributes)
		{]]></xsl:text>
			<!-- DEF, USE, name attributes first for readability and to match X3D Canonical Form -->
			<xsl:if test="InterfaceDefinition/field[@name = 'DEF']">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			if (!getDEF().equals(DEF_DEFAULT_VALUE) && !isUSE())
			{
				stringX3D.append(" DEF='").append(SFStringObject.toString(getDEF())).append("'");
			}
			]]></xsl:text>
			</xsl:if>
			<xsl:if test="InterfaceDefinition/field[@name = 'USE']">
				<xsl:text>
			if (!getUSE().equals(USE_DEFAULT_VALUE))
			{
				stringX3D.append(" USE='").append(SFStringObject.toString(getUSE())).append("'");
			}
			</xsl:text>
			</xsl:if>
			<!-- output prior to other fields -->
			<xsl:if test="InterfaceDefinition/field[@name = 'name']">
				<xsl:if test="($name = 'ProtoInstance')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
			// note special case for ProtoInstance, do not include name field if USE is present]]></xsl:text>
				</xsl:if>
				<xsl:text disable-output-escaping="yes"><![CDATA[
			if (!getName().equals(NAME_DEFAULT_VALUE)]]></xsl:text>
			<xsl:if test="not($isX3dStatement = 'true') or ($name = 'ProtoInstance')">
				<xsl:text disable-output-escaping="yes"><![CDATA[ && !isUSE()]]></xsl:text>
			</xsl:if>
			<xsl:text>)
			{
				stringX3D.append(" name='").append(SFStringObject.toString(getName())).append("'");
			}
			</xsl:text>
			</xsl:if>
                        <xsl:choose>
                            <xsl:when test="starts-with(local-name(),'Metadata')">
                                    <xsl:text disable-output-escaping="yes"><![CDATA[
                            if      (getParentObject() instanceof SceneObject)
                            {
                                    // must be default value since it is one of children of Scene
                                    // stringX3D.append(" containerField='").append(containerField_DEFAULT_VALUE).append("'");
                            }
                            else if (!getContainerFieldOverride().isEmpty() && !getContainerFieldOverride().equals(containerField_DEFAULT_VALUE))
                            {
                                    stringX3D.append(" containerField='").append(getContainerFieldOverride()).append("'");
                            }
                            ]]></xsl:text>
                            </xsl:when>
                            <!-- this if statement might be more selective, but this approach is safest to avoid unintended omission and evolution -->
                            <xsl:when test="not($isX3dStatement = 'true') or ($name = 'ProtoInstance')">
                                    <xsl:text disable-output-escaping="yes"><![CDATA[
                            if (!getContainerFieldOverride().isEmpty() && !getContainerFieldOverride().equals(containerField_DEFAULT_VALUE))
                            {
                                    stringX3D.append(" containerField='").append(getContainerFieldOverride()).append("'");
                            }
                            ]]></xsl:text>
                            </xsl:when>
                        </xsl:choose>
			<!-- attributes (i.e. non-node fields) -->
			<xsl:for-each select="InterfaceDefinition/field[not(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and not(@name = 'DEF') and not(@name = 'USE') and not(@name = 'name') and 
                                                            ((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
				<xsl:variable name="fieldName" select="translate(@name,'-','_')"/><!-- handle http-equiv etc. -->
				<xsl:variable name="isSingleValueType">
					<xsl:value-of select="starts-with(@type,'SF') and not(contains(@type, 'Vec')) and not(contains(@type, 'Rotation')) and not(contains(@type, 'Color')) and not(contains(@type, 'Matrix'))"/>
				</xsl:variable>
				<xsl:variable name="CamelCaseName"><!-- upper camel case -->
					<xsl:choose>
						<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
							<!-- unmodified -->
							<xsl:value-of select="@name"/>
						</xsl:when>
						<xsl:when test="(@name = 'class')">
							<!-- getClass() is reserved by Java Object() class -->
							<xsl:text>CssClass</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="translate(substring($fieldName,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
							<xsl:value-of select="substring($fieldName,2)"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="javaType">
					<xsl:call-template name="javaType">
						<xsl:with-param name="x3dType" select="@type"/>
						<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
					</xsl:call-template>
				</xsl:variable>
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
<xsl:text>// ($fieldName=</xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:text>, $hasChild=</xsl:text>
<xsl:value-of select="$hasChild"/>
<xsl:text>, $hasAttributes=</xsl:text>
<xsl:value-of select="$hasAttributes"/>
<xsl:text>, CamelCaseName=</xsl:text>
<xsl:value-of select="$CamelCaseName"/>
<xsl:text>, javaType=</xsl:text>
<xsl:value-of select="$javaType"/>
<xsl:text>, isSingleValueType=</xsl:text>
<xsl:value-of select="$isSingleValueType"/>
<xsl:text>)</xsl:text>
</xsl:message>
</xsl:if>

				<xsl:text><![CDATA[
			if ((]]></xsl:text>
			<xsl:choose>
				<!-- required attributes -->
				<xsl:when test="(($name = 'X3D') and (($fieldName = 'profile') or ($fieldName = 'version'))) or
								(($name = 'HAnimHumanoid') and ($fieldName = 'version')) or
								(($name = 'component') and ($fieldName = 'level')) or
								(($name = 'unit')      and ($fieldName = 'conversionFactor'))">
					<xsl:text><![CDATA[true) /* required attribute */ ]]></xsl:text>
				</xsl:when>
				<xsl:when test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
					<xsl:text><![CDATA[(get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[() != ]]></xsl:text>
					<xsl:value-of select="upper-case($fieldName)"/>
					<xsl:text><![CDATA[_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())]]></xsl:text>
				</xsl:when>
				<xsl:when test="contains($javaType, 'ArrayList')">
					<xsl:text><![CDATA[(get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[().length > 0) || ConfigurationProperties.isShowDefaultAttributes())]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'LayerSet') and ($fieldName = 'order')">
					<xsl:text><![CDATA[!(get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[().equals(]]></xsl:text>
					<xsl:value-of select="upper-case($fieldName)"/>
					<xsl:text><![CDATA[_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())]]></xsl:text>
				</xsl:when>
				<xsl:when test="($isSingleValueType = 'true')">
					<xsl:text><![CDATA[!get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text><![CDATA[().equals(]]></xsl:text>
					<xsl:value-of select="upper-case($fieldName)"/>
					<xsl:text><![CDATA[_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())]]></xsl:text>
				</xsl:when>
				<xsl:when test="(string-length(@default) > 0)">
					<xsl:text><![CDATA[!Arrays.equals(get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text><![CDATA[(), ]]></xsl:text>
					<xsl:value-of select="upper-case($fieldName)"/>
					<xsl:text><![CDATA[_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())]]></xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text><![CDATA[get]]></xsl:text>
					<xsl:value-of select="$CamelCaseName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[().length > 0)]]></xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="not($isX3dStatement = 'true')">
				<xsl:text disable-output-escaping="yes"><![CDATA[ && !isUSE()]]></xsl:text>
			</xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[)
			{
				stringX3D.append(" ]]></xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>='").append(</xsl:text>
				<xsl:choose>
					<xsl:when test="(@type = 'SFString') or (@type = 'MFString')">
						<xsl:text>new </xsl:text>
						<xsl:value-of select="@type"/>
						<xsl:value-of select="$jsaiClassSuffix"/>
						<xsl:text>(get</xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text>())</xsl:text>
						<xsl:text>.toStringX3D()</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="@type"/>
						<xsl:value-of select="$jsaiClassSuffix"/>
						<xsl:text>.toString</xsl:text>
						<xsl:text>(get</xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text>())</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:text>).append("'");
			}</xsl:text>
			</xsl:for-each>
			<xsl:choose>					
				<xsl:when test="($name = 'X3D')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
				switch (version)
				{
					case "3.0":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_0_ATTRIBUTES);
						break;
					case "3.1":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_1_ATTRIBUTES);
						break;
					case "3.2":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_2_ATTRIBUTES);
						break;
					case "3.3":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_3_ATTRIBUTES);
						break;
					case "4.0":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_4_0_ATTRIBUTES);
						break;
					case "4.1":
						stringX3D.append(" ").append(X3D_XML_SCHEMA_4_1_ATTRIBUTES);
						break;
					default:
						stringX3D.append(" ").append(X3D_XML_SCHEMA_3_3_ATTRIBUTES); // TODO error condition
						break;
				}]]></xsl:text>
				</xsl:when>
			</xsl:choose>
			
			<xsl:text disable-output-escaping="yes"><![CDATA[
		}
		if ((hasChild)]]></xsl:text>
			<xsl:if test="not($isX3dStatement = 'true')">
				<xsl:text disable-output-escaping="yes"><![CDATA[ && !isUSE()]]></xsl:text>
			</xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[) // has contained node(s), comment(s), IS/connect and/or source code
		{
			stringX3D.append(">").append("\n"); // finish opening tag
]]></xsl:text>
		<xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock') and not($name = 'Script')">
			<!-- note ProtoInstance IS handled later due to serialization sequencing -->
			<xsl:text>
			if (getIS() != null)
				stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement));</xsl:text>
		</xsl:if>
			<xsl:text disable-output-escaping="yes"><![CDATA[

			// recursively iterate over child element]]></xsl:text>
			<xsl:if test="InterfaceDefinition/field[(@type = 'MFNode')] or
				   (count(InterfaceDefinition/field[contains(@type,'FNode')]) > 1)">
				<xsl:text>s</xsl:text>
			</xsl:if>
			
			<xsl:if test="(not($hasChildrenField = 'true') and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
							not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not($name = 'CADPart'))">
				<xsl:text><![CDATA[
			if (!commentsList.isEmpty())
			{
				CommentsBlock commentsBlock = new CommentsBlock(commentsList);
				stringX3D.append(commentsBlock.toStringX3D(indentLevel + indentIncrement));
			}]]></xsl:text>
			</xsl:if>
			
			<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and 
															((@accessType='initializeOnly') or (@accessType='inputOutput')) and
                                                            not(@name = 'meta')]">
				<!-- order is essential for the following name-attribute sorts -->
				<xsl:sort select="@name[not((. = 'head') or (. = 'Scene') or (. = 'metadata') or (. = 'ProtoBody') or (. = 'ProtoInterface'))]"/>
				<!-- necessary order for model validation: field/IS/metadata before all others -->
				<xsl:sort select="(@name = 'metadata')"/>
				<!-- apparently these are handled in content model, not interface definitions
				<xsl:sort select="(@name = 'IS')"/>
				<xsl:sort select="(@name = 'field')"/> 
				<xsl:sort select="(@name = 'fieldValue')"/> -->
				<!-- special order for head elements: meta comes last, handled afterwards
				<xsl:sort select="(@name = 'component')"/>
				<xsl:sort select="(@name = 'unit')"/>
				<xsl:sort select="(@name = 'meta')"/> -->
				<!-- sort head before Scene in X3D -->
				<xsl:sort select="(@name = 'Scene')"/>
				<xsl:sort select="(@name = 'head')"/>
				<!-- sort ProtoInterface before ProtoBody in ProtoDeclare -->
				<xsl:sort select="(@name = 'ProtoBody')"/>
				<xsl:sort select="(@name = 'ProtoInterface')"/>
				
				<xsl:variable name="javaType">
					<xsl:call-template name="javaType">
						<xsl:with-param name="x3dType" select="@type"/>
						<xsl:with-param name="isInterface" select="$isInterface"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="javaReferenceType">
					<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
				</xsl:variable>
				<xsl:variable name="isX3dStatement">
					<xsl:call-template name="isX3dStatement">
						<xsl:with-param name="name" select="@name"/>
					</xsl:call-template>
				</xsl:variable>

				<xsl:choose>
					<xsl:when test="(@type = 'SFNode')">
						<!-- cast abstract element to concrete type -->
						<xsl:text><![CDATA[
			if      (]]></xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
			{
				stringX3D.append(((X3DConcreteElement)</xsl:text><xsl:value-of select="@name"/>
						<xsl:text>).toStringX3D(indentLevel + indentIncrement));
			}</xsl:text>
						<xsl:if test="not($isX3dStatement = 'true')">
						<xsl:text><![CDATA[
			else if (]]></xsl:text><xsl:value-of select="@name"/><xsl:text><![CDATA[ProtoInstance != null)
			{
					 stringX3D.append(((X3DConcreteElement)]]></xsl:text><xsl:value-of select="@name"/>
						<xsl:text><![CDATA[ProtoInstance).toStringX3D(indentLevel + indentIncrement));
			}]]></xsl:text>
						</xsl:if>
					</xsl:when>
					<xsl:otherwise> <!-- MFNode -->
						<xsl:text><![CDATA[
			for (]]></xsl:text><xsl:value-of select="$javaReferenceType"/><xsl:text><![CDATA[ element : ]]></xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:if test="($isX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<!-- cast abstract element to concrete type -->
						<xsl:text>)
			{
				stringX3D.append(((X3DConcreteElement)element).toStringX3D(indentLevel + indentIncrement));
			}</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
			
			<xsl:if test="($name = 'head')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			// note required order of component, unit, meta (though relaxation of this requirement has been proposed)
			for (metaObject element : metaList)
				 stringX3D.append(element.toStringX3D(indentLevel + indentIncrement));
]]></xsl:text>
			</xsl:if>
			<xsl:if test="($name = 'ProtoInstance')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			if (getIS() != null)
				stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement)); // IS follows fieldValue definitions]]></xsl:text>
			</xsl:if>
			
			<xsl:choose>
				<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram')">
					<xsl:text disable-output-escaping="yes"><![CDATA[

			for (fieldObject element : fieldList)
				 stringX3D.append(element.toStringX3D(indentLevel + indentIncrement));

			if (getIS() != null)
				stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement)); // IS follows field definitions

			if (sourceCode.trim().length() > 0)
				stringX3D.append("<![CDATA[\n").append(sourceCode)
				         .append("\n]]></xsl:text><xsl:text>]]</xsl:text><xsl:text disable-output-escaping="yes"><![CDATA[>\n");
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ComposedShader') or ($name = 'PackagedShader')">
					<xsl:text disable-output-escaping="yes"><![CDATA[

			for (fieldObject element : fieldList)
				 stringX3D.append(element.toStringX3D(indentLevel + indentIncrement));

			if (getIS() != null)
				stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement)); // IS follows field definitions
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ShaderPart')">
					<xsl:text disable-output-escaping="yes"><![CDATA[

			if (getIS() != null)
				stringX3D.append(getIS().toStringX3D(indentLevel + indentIncrement)); // IS follows field definitions

			if (sourceCode.trim().length() > 0)
				stringX3D.append("<![CDATA[\n").append(sourceCode)
				         .append("\n]]></xsl:text><xsl:text>]]</xsl:text><xsl:text disable-output-escaping="yes"><![CDATA[>\n");
]]></xsl:text>
				</xsl:when>
			</xsl:choose>

			<xsl:text disable-output-escaping="yes"><![CDATA[
			stringX3D.append(indent).append("</]]></xsl:text>
			<xsl:value-of select="$name"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[>").append("\n"); // finish closing tag
		}
		else
		{
			stringX3D.append("/>").append("\n"); // otherwise finish singleton tag
		}]]></xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text disable-output-escaping="yes"><![CDATA[
		return stringX3D.toString();
	}
]]></xsl:text>
						</xsl:if>
							
						<!-- toStringClassicVRML -->
						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:text>// ($name=</xsl:text>
<xsl:value-of select="$name"/>
<xsl:text>, isX3dStatement=</xsl:text>
<xsl:value-of select="$isX3dStatement"/>
<xsl:text>, isClassX3dStatement=</xsl:text>
<xsl:value-of select="$isClassX3dStatement"/>
<xsl:text>, $hasChild=</xsl:text>
<xsl:value-of select="$hasChild"/>
<xsl:text>, $hasAttributes=</xsl:text>
<xsl:value-of select="$hasAttributes"/>
</xsl:if>

						<!-- toStringClassicVRML() encoding -->
						<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide ClassicVRML string serialization.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3DObject#FILE_EXTENSION_CLASSICVRML
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/X3D_ClassicVRML.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/grammar.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding, Annex A: Grammar</a>
	 * @return ClassicVRML string
	 */
	@Override
	public String toStringClassicVRML(int indentLevel)
	{
		StringBuilder stringClassicVRML = new StringBuilder();]]></xsl:text>
	<xsl:if test="not($name = 'CommentsBlock')">
		<xsl:text><![CDATA[
		boolean hasAttributes = ]]></xsl:text>
		<xsl:value-of select="$hasAttributes"/>
		<xsl:text><![CDATA[; // TODO further refinement
		boolean      hasChild = ]]></xsl:text>
		<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) or ($name = 'ProtoInstance')">
			<xsl:text>(IS != null) || </xsl:text>
		</xsl:if>
		<xsl:variable name="fieldsList" select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and 
														((@accessType='initializeOnly') or (@accessType='inputOutput'))]"/>
		<xsl:for-each select="$fieldsList">
			<xsl:variable name="isX3dStatement">
				<xsl:call-template name="isX3dStatement">
					<xsl:with-param name="name" select="@name"/>
				</xsl:call-template>
			</xsl:variable>
			
			<xsl:choose>
				<xsl:when test="($name = 'Script')  or ($name = 'ShaderProgram')">
					<xsl:text>(!fieldList.isEmpty()) || (!sourceCode.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ComposedShader') or ($name = 'PackagedShader')">
					<xsl:text>(!fieldList.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ShaderPart')">
					<xsl:text>(!sourceCode.isEmpty()) || </xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ProtoInstance')">
					<xsl:text>(!fieldValueList.isEmpty()) || </xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test="(@type = 'SFNode')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="@name"/>
					<xsl:text> != null)</xsl:text>
					<xsl:if test="not($isX3dStatement = 'true')">
						<xsl:text> || (</xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text>ProtoInstance != null)</xsl:text>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise><!-- (@type='MFNode') -->
					<xsl:text>(!</xsl:text>
					<xsl:value-of select="@name"/>
					<xsl:if test="($isX3dStatement = 'true')">
						<xsl:text>List</xsl:text><!-- append to member name -->
					</xsl:if>
					<xsl:text>.isEmpty())</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			
			<xsl:if test="(last() > position()) or not($hasChildrenField = 'true')">
				<xsl:text> || </xsl:text>
			</xsl:if>
		</xsl:for-each>
		<xsl:choose>
			<xsl:when test="not($hasChildrenField = 'true')">
				<xsl:text disable-output-escaping="yes">!commentsList.isEmpty()</xsl:text>
			</xsl:when>
			<xsl:when test="1 > count($fieldsList)">
				<xsl:text>false</xsl:text><!-- TODO account for CommentsBlock -->
			</xsl:when>
		</xsl:choose>
		<xsl:text>;</xsl:text><!-- hasChild definition complete -->
	</xsl:if>
	<xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
		if (isUSE())
		{
			hasAttributes = false;
			hasChild      = false; // USE nodes include no other fields
		}]]></xsl:text><!-- append to member name -->
	</xsl:if>
	<xsl:if test="not((@name = 'X3D') or (@name = 'head') or (@name = 'meta') or (@name = 'unit') or (@name = 'component') or (@name = 'Scene'))">
		<!-- avoid defining indentCharacter for nodes with no indentation, helps to ensure that consistent logic follows -->
		<xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder  indent = new StringBuilder();
		char  indentCharacter = ConfigurationProperties.getIndentCharacter();
		int   indentIncrement = ConfigurationProperties.getIndentIncrement();
		for (int i = 0; i < (indentLevel * indentIncrement); i++)
			indent.append(indentCharacter); // level of indentation for this level
]]></xsl:text>			
	</xsl:if>			
		
		<!-- preliminary special handling of statement names themselves, then proceed with additional content -->
		<xsl:choose>
			<xsl:when test="($name = 'X3D')">
				<!-- header needed for serialization toStringClassicVRML -->
				<xsl:text>
		stringClassicVRML.append("#X3D V").append(version).append(" utf8").append("\n");
		stringClassicVRML.append("PROFILE").append(" ").append(profile).append("\n");</xsl:text>
			</xsl:when>
			<xsl:when test="(@name = 'head') or (@name = 'Scene')">
				<!-- special output provided separately by X3D, only mention name as a comment here -->
				<xsl:text>
		stringClassicVRML.append("# </xsl:text><xsl:value-of select="@name"/><xsl:text>").append("\n");</xsl:text>
			</xsl:when>
		</xsl:choose>
		<!-- keep these xsl:choose statements separate -->
		<xsl:choose>
			<xsl:when test="($name = 'CommentsBlock')">
				<!-- might have embedded XML comments, that is OK here -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
		for (String comment : commentsList)
		{
                    if (ConfigurationProperties.isNormalizeCommentWhitespace())
                    {
                        // https://stackoverflow.com/questions/3958955/how-to-remove-duplicate-white-spaces-in-string-using-java
                        comment = comment.replaceAll("\\s+", " ");
                    }
                    // ensure that comments with embedded line breaks have # character at start of new line
                    stringClassicVRML.append("# ").append(comment.replaceAll("\n", "\n#\t")).append("\n").append(indent);
		}]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'component')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/concepts.html#ComponentStatementSyntax
		stringClassicVRML.append("COMPONENT ").append(name).append(":").append(getLevel()).append("\n");
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'meta')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/concepts.html#METAStatementSyntax
		stringClassicVRML.append("META \"").append(name).append("\" \"").append(content).append("\"").append("\n");
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'unit')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/concepts.html#UNITStatementSyntax
		stringClassicVRML.append("UNIT ").append(category).append(" ").append(name).append(" ").append(conversionFactor).append("\n");
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'ROUTE')">
				<!-- formatting note: "TO" preceded by tab character to alight consecutive ROUTE outputs, for some cases -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("ROUTE ").append(fromNode).append(".").append(fromField)
			.append(" TO ").append(toNode).append(".").append(toField).append("\n").append(indent);
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'IMPORT')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("IMPORT ");
		stringClassicVRML.append(getInlineDEF());
		if (getInlineDEF().equals(INLINEDEF_DEFAULT_VALUE))
		{
			stringClassicVRML.append("TODO_MISSING_INLINEDEF");
		}
		stringClassicVRML.append(".");
		stringClassicVRML.append(getImportedDEF());
		if (getImportedDEF().equals(IMPORTEDDEF_DEFAULT_VALUE))
		{
			stringClassicVRML.append("TODO_MISSING_IMPORTEDDEF");
		}
		if (!getAS().equals(AS_DEFAULT_VALUE))
		{
			stringClassicVRML.append(" AS ").append(SFStringObject.toString(getAS())).append(" ");
		}
		stringClassicVRML.append("\n").append(indent);
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="($name = 'EXPORT')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("EXPORT ").append(getLocalDEF());
		if (getLocalDEF().equals(LOCALDEF_DEFAULT_VALUE))
		{
			stringClassicVRML.append("TODO_MISSING_LOCALDEF");
		}
		if (!getAS().equals(AS_DEFAULT_VALUE))
		{
			stringClassicVRML.append(" AS ").append(SFStringObject.toString(getAS())).append(" ");
		}
		stringClassicVRML.append("\n").append(indent);
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@name = 'ProtoDeclare')">
				<!-- special handling -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("PROTO ").append(name).append(" [").append("\n").append(indent);
		
		if (!getAppinfo().equals(APPINFO_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())
		{
			stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append(" # [appinfo] ").append("\"").append(SFStringObject.toString(getAppinfo())).append("\"");
		}
		if (!getDocumentation().equals(DOCUMENTATION_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())
		{
			stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append("# [documentation] ").append("\"").append(SFStringObject.toString(getDocumentation())).append("\"").append("\n").append(indent).append(indentCharacter);
		}
				
		// recursively iterate over child elements
		if (ProtoInterface != null)
		{
			stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append(ProtoInterface.toStringClassicVRML(indentLevel + indentIncrement));
			for (fieldObject nextField : ProtoInterface.getFieldList())
			{
				stringClassicVRML.append(nextField.toStringClassicVRML(indentLevel + indentIncrement));
			}
		}
		if (!commentsList.isEmpty())
		{
			CommentsBlock commentsBlock = new CommentsBlock(commentsList);
			stringClassicVRML.append(commentsBlock.toStringClassicVRML(indentLevel));
		}
		stringClassicVRML.append("] {").append("\n").append(indent);
					
		if (ProtoBody != null)
		{
			stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append(ProtoBody.toStringClassicVRML(indentLevel + indentIncrement));
			stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter);
			for (X3DNode element : ProtoBody.getChildren())
			{
				stringClassicVRML.append(((X3DConcreteElement) element).toStringClassicVRML(indentLevel + indentIncrement));
			}
		}
		stringClassicVRML.append("}").append("\n").append(indent);
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@name = 'ExternProtoDeclare')">
				<!-- special handling -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append("EXTERNPROTO ").append(name).append(" [").append("\n").append(indent);
		
		if (!getAppinfo().equals(APPINFO_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())
		{
			stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter);
			stringClassicVRML.append(" # [appinfo] ").append("\"").append(SFStringObject.toString(getAppinfo())).append("\"");
		}
		if (!getDocumentation().equals(DOCUMENTATION_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())
		{
			stringClassicVRML.append("\n").append(indent).append(indentCharacter);
			stringClassicVRML.append("# [documentation] ").append("\"").append(SFStringObject.toString(getDocumentation())).append("\"").append("\n").append(indent).append(indentCharacter);
		}
		if (getUrl().length > 0)
		{
			stringClassicVRML.append("\n").append(indent).append(indentCharacter);
			stringClassicVRML.append("url ").append("[ ").append(MFStringObject.toString(getUrl())).append(" ]");
		}
				
		// recursively iterate over child elements
		for (fieldObject element : fieldList)
		{
			stringClassicVRML.append(((X3DConcreteElement)element).toStringClassicVRML(indentLevel));
		}
		if (!commentsList.isEmpty())
		{
			CommentsBlock commentsBlock = new CommentsBlock(commentsList);
			stringClassicVRML.append(commentsBlock.toStringClassicVRML(indentLevel));
		}
		stringClassicVRML.append("]").append("\n").append(indent);]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@name = 'ProtoInterface') or (@name = 'ProtoBody')">
				<!-- special output provided separately by ProtoDeclare, only mention name as a comment here -->
				<xsl:text>
		stringClassicVRML.append("# </xsl:text><xsl:value-of select="@name"/><xsl:text>");</xsl:text>
			</xsl:when>
			<xsl:otherwise>
			<!-- DEF, USE, name attributes first for readability and to match X3D Canonical Form -->
			<xsl:if test="InterfaceDefinition/field[@name = 'DEF']">
				<xsl:text>
		if (!getDEF().equals(DEF_DEFAULT_VALUE))
		{
			stringClassicVRML.append("DEF ").append(SFStringObject.toString(getDEF())).append(" ");
		}</xsl:text>
			</xsl:if>
			<xsl:if test="InterfaceDefinition/field[@name = 'USE']">
				<xsl:text>
		if (!getUSE().equals(USE_DEFAULT_VALUE))
		{
			 stringClassicVRML.append("USE ").append(SFStringObject.toString(getUSE())).append("\n");
		}
		else // only have further output if not a USE node
		{</xsl:text>
				<!-- all done with this USE node -->
			</xsl:if>
			<xsl:choose>
				<xsl:when test="($name = 'ProtoInstance')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
			if (getName().isEmpty())
				 stringClassicVRML.append("NoNameFoundError");
			else stringClassicVRML.append(getName());
			stringClassicVRML.append(" { "); // define ProtoInstance node name, fieldValue content follows
]]></xsl:text>
				</xsl:when>
				<xsl:when test="not($isX3dStatement = 'true')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
			stringClassicVRML.append("]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[").append(" { "); // define node name, node content follows
]]></xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:if test="not($isX3dStatement = 'true') and not($name = 'Script')">
				<xsl:text>
			if (hasAttributes || hasChild)
			{</xsl:text>
				<xsl:text>
				stringClassicVRML.append("\n")</xsl:text>
			<xsl:text>.append(indent).append(indentCharacter); // fields for this node follow</xsl:text>
			<xsl:text>
			}</xsl:text>
			</xsl:if>
			
			<xsl:if test="($name = 'fieldValue')">
				<xsl:text>
		// fieldValue type is figured out using ProtoDeclare/ExternProtoDeclare field getType()</xsl:text>
			</xsl:if>
			<xsl:choose>
				<!-- special handling -->
				<xsl:when test="($name = 'field') or ($name = 'fieldValue')">
					<xsl:text>
		// </xsl:text>
		<xsl:value-of select="$name"/>
					<xsl:text> definition
		stringClassicVRML.append("\n").append(indent).append(indentCharacter).append(indentCharacter)</xsl:text>
					<xsl:if test="($name = 'field')">
						<xsl:text disable-output-escaping="yes">.append(accessType).append(" ").append(type).append(" ")</xsl:text>
					</xsl:if>
					<!-- getType() defined for both field and fieldValue -->
					<xsl:text disable-output-escaping="yes"><![CDATA[.append(name);
		if (value.length() > 0)
		{
			stringClassicVRML.append(" ");
			if (getType().equals(fieldObject.TYPE_SFSTRING))
				 stringClassicVRML.append("\"").append(value).append("\"");
			else stringClassicVRML             .append(value);
		}]]></xsl:text>
					<xsl:if test="($name = 'field')">
						<!-- append field [appinfo], add field [documentation] -->
						<xsl:text disable-output-escaping="yes"><![CDATA[
		if (!getAppinfo().equals(APPINFO_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())
		{
			stringClassicVRML.append(" # [appinfo] ").append("\"").append(SFStringObject.toString(getAppinfo())).append("\"").append("\n").append(indent);
		}
		if (!getDocumentation().equals(DOCUMENTATION_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())
		{
			stringClassicVRML.append("# [documentation] ").append("\"").append(SFStringObject.toString(getDocumentation())).append("\"").append("\n").append(indent);
		}]]></xsl:text>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
			<xsl:text>
			if (hasAttributes)
			{
</xsl:text>
			<xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
				boolean hasISconnect = (getIS() != null) && !getIS().getConnectList().isEmpty();]]></xsl:text>
			</xsl:if>

			<xsl:for-each select="InterfaceDefinition/field[not(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and not(@name = 'DEF') and not(@name = 'USE') and
                                                            ((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
				<xsl:variable name="fieldName" select="translate(@name,'-','_')"/><!-- handle http-equiv etc. -->
				<xsl:variable name="isSingleValueType">
					<xsl:value-of select="starts-with(@type,'SF') and not(contains(@type, 'Vec')) and not(contains(@type, 'Rotation')) and not(contains(@type, 'Color')) and not(contains(@type, 'Matrix'))"/>
				</xsl:variable>
				<xsl:variable name="CamelCaseName"><!-- upper camel case -->
					<xsl:choose>
						<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
							<!-- unmodified -->
							<xsl:value-of select="@name"/>
						</xsl:when>
						<xsl:when test="(@name = 'class')">
							<!-- getClass() is reserved by Java Object() class -->
							<xsl:text>CssClass</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="translate(substring($fieldName,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
							<xsl:value-of select="substring($fieldName,2)"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="javaType">
					<xsl:call-template name="javaType">
						<xsl:with-param name="x3dType" select="@type"/>
						<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
					</xsl:call-template>
				</xsl:variable>
<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
<xsl:text>// ($fieldName=</xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:text>, CamelCaseName=</xsl:text>
<xsl:value-of select="$CamelCaseName"/>
<xsl:text>, javaType=</xsl:text>
<xsl:value-of select="$javaType"/>
<xsl:text>, isSingleValueType=</xsl:text>
<xsl:value-of select="$isSingleValueType"/>
<xsl:text>)</xsl:text>
</xsl:message>
</xsl:if>
				<xsl:if test="not($isX3dStatement = 'true') and not($name = 'CommentsBlock') and not($name = 'ProtoInstance')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
				if (hasISconnect)
				{
					for (connectObject element : getIS().getConnectList())
					{
						if (element.getNodeField().equals("]]></xsl:text><xsl:value-of select="@name"/><xsl:text><![CDATA["))
						{
							stringClassicVRML.append(indentCharacter).append("]]></xsl:text>
							<xsl:value-of select="@name"/>
							<xsl:text>").append(" IS ").append(element.getProtoField()).append("\n").append(indent).append(indentCharacter); // found matching connect
						}
					}
				}
				else </xsl:text>
				</xsl:if>
				<xsl:text>
				if (</xsl:text>
				<xsl:choose>
					<!-- avoided attributes -->
					<xsl:when test="($name = 'X3D')">
						<xsl:text><![CDATA[false) // attribute handled separately]]></xsl:text>
					</xsl:when>
					<!-- required attributes -->
					<xsl:when test="(($name = 'X3D') and (($fieldName = 'profile') or ($fieldName = 'version'))) or
									(($name = 'HAnimHumanoid') and ($fieldName = 'version')) or
									(($name = 'component')     and ($fieldName = 'level')) or
									(($name = 'unit')          and ($fieldName = 'conversionFactor'))">
						<xsl:text><![CDATA[true) /* required attribute */ ]]></xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
						<xsl:text><![CDATA[(get]]></xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text disable-output-escaping="yes"><![CDATA[() != ]]></xsl:text>
						<xsl:value-of select="upper-case($fieldName)"/>
						<xsl:text><![CDATA[_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())]]></xsl:text>
					</xsl:when>
					<xsl:when test="contains($javaType, 'ArrayList')">
						<xsl:text><![CDATA[get]]></xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text disable-output-escaping="yes"><![CDATA[().length > 0)]]></xsl:text>
					</xsl:when>
					<xsl:when test="($isSingleValueType = 'true')">
						<xsl:text><![CDATA[!get]]></xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text><![CDATA[().equals(]]></xsl:text>
						<xsl:value-of select="upper-case($fieldName)"/>
						<xsl:text><![CDATA[_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())]]></xsl:text>
					</xsl:when>
					<xsl:when test="(string-length(@default) > 0)">
						<xsl:text><![CDATA[!Arrays.equals(get]]></xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text><![CDATA[(), ]]></xsl:text>
						<xsl:value-of select="upper-case($fieldName)"/>
						<xsl:text><![CDATA[_DEFAULT_VALUE) || ConfigurationProperties.isShowDefaultAttributes())]]></xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text><![CDATA[(get]]></xsl:text>
						<xsl:value-of select="$CamelCaseName"/>
						<xsl:text disable-output-escaping="yes"><![CDATA[().length > 0) || ConfigurationProperties.isShowDefaultAttributes())]]></xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			
				<!-- output simple-field value -->
				<xsl:text><![CDATA[
				{
					stringClassicVRML]]></xsl:text>
				<xsl:text><![CDATA[.append("]]></xsl:text>
				<!-- unsupported attribute -->
				<xsl:if test="(@name = 'class')">
					<xsl:text># </xsl:text>
				</xsl:if>
				<xsl:value-of select="$fieldName"/>
				<xsl:text> ")</xsl:text>
				<xsl:choose>
					<xsl:when test="(@type = 'SFString')">
						<xsl:text>.append("\"")</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with(@type, 'MF')">
						<xsl:text>.append("[ ")</xsl:text>
					</xsl:when>
				</xsl:choose>
				<xsl:text>.append(</xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:value-of select="$jsaiClassSuffix"/>
				<xsl:text>.toString(get</xsl:text>
				<xsl:value-of select="$CamelCaseName"/>
				<xsl:text>()))</xsl:text>
				<xsl:choose>
					<xsl:when test="(@type = 'SFString')">
						<xsl:text>.append("\"")</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with(@type, 'MF')">
						<xsl:text>.append(" ]")</xsl:text>
					</xsl:when>
				</xsl:choose>
				<xsl:text>.append("\n")</xsl:text>
				<xsl:if test="not($isX3dStatement = 'true')">
					<xsl:text><![CDATA[.append(indent).append(indentCharacter)]]></xsl:text>
				</xsl:if>
				<xsl:text>;
				}</xsl:text>
			</xsl:for-each>
			
						<xsl:text disable-output-escaping="yes"><![CDATA[
			}]]></xsl:text>
						<xsl:if test="InterfaceDefinition/field[@name = 'USE']">
							<xsl:text>
		}</xsl:text>
						</xsl:if> <!-- end hasAttributes -->
					</xsl:otherwise>
				</xsl:choose>

				<xsl:text disable-output-escaping="yes"><![CDATA[
		if (hasChild) // has contained node(s), comment(s), IS/connect and/or source code
		{]]></xsl:text>
				<xsl:text>
			// recursively iterate over child element</xsl:text>
				<xsl:if test="InterfaceDefinition/field[(@type = 'MFNode')] or
					   (count(InterfaceDefinition/field[contains(@type,'FNode')]) > 1)">
					<xsl:text>s</xsl:text>
				</xsl:if>

			<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and 
															((@accessType='initializeOnly') or (@accessType='inputOutput')) and
                                                            not(@name = 'meta')]">
				<!-- special order for head elements: meta comes last, handled afterwards -->
				<!-- sort ProtoInterface before ProtoBody -->
				<xsl:sort select="(@name = 'ProtoBody')"/>
				<xsl:sort select="(@name = 'ProtoInterface')"/>
				<!-- TODO have ProtoDeclare handle ProtoBody and ProtoInterface -->
				
				<xsl:variable name="javaType">
					<xsl:call-template name="javaType">
						<xsl:with-param name="x3dType" select="@type"/>
						<xsl:with-param name="isInterface" select="$isInterface"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="javaReferenceType">
					<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
				</xsl:variable>
				<xsl:variable name="isFieldX3dStatement">
					<xsl:call-template name="isX3dStatement">
						<xsl:with-param name="name" select="@name"/>
					</xsl:call-template>
				</xsl:variable>

				<xsl:choose>
					<xsl:when test="(@type = 'X3D') or (@type = 'head') or (@type = 'Scene')">
						<!-- already handled -->
					</xsl:when>
					<xsl:when test="(@type = 'SFNode')">
						<xsl:text><![CDATA[
			if (]]></xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text><![CDATA[ != null)
			{]]></xsl:text>
						<xsl:if test="not($isX3dStatement = 'true')">
							<!-- TODO containerField name alternatives -->
							<xsl:text><![CDATA[
				stringClassicVRML.append(indentCharacter).append("]]></xsl:text>
							<xsl:value-of select="@name"/>
							<xsl:text>").append(" "); // containerField for SFNode</xsl:text><!-- watch out for CommentsBlock or ROUTE -->
						</xsl:if>
						<!-- cast abstract element to concrete type -->
						<xsl:text>
				stringClassicVRML.append(((X3DConcreteElement) </xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:choose>
							<xsl:when test="not($isX3dStatement = 'true')">
								<xsl:text>).toStringClassicVRML(indentLevel + indentIncrement));
				stringClassicVRML.append(indent); // end SFNode</xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text>).toStringClassicVRML(indentLevel)); // end X3D statement</xsl:text>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:text>
			}</xsl:text>
						<xsl:if test="not($isX3dStatement = 'true')"><!-- output ProtoInstance -->
							<xsl:text>
			else if (</xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text><![CDATA[ProtoInstance != null)
			{
				stringClassicVRML.append(indentCharacter).append("]]></xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text>").append(" "); // containerField for SFNode</xsl:text><!-- watch out for CommentsBlock or ROUTE -->
						<!-- cast abstract element to concrete type, output ProtoInstance alternative (if present) -->
						<xsl:text>
				stringClassicVRML.append(((X3DConcreteElement) </xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:text>ProtoInstance).toStringClassicVRML(indentLevel + indentIncrement));
				stringClassicVRML.append(indent); // end SFNode ProtoInstance
			}</xsl:text>
						</xsl:if>
					</xsl:when>
					<xsl:otherwise> <!-- MFNode -->
						<xsl:choose>
							<xsl:when test="not($isX3dStatement = 'true') or (@name = 'ROUTE')">
								<xsl:text>
			if (</xsl:text>
								<xsl:value-of select="@name"/>
								<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
									<xsl:text>List</xsl:text><!-- append to member name -->
								</xsl:if>
								 <xsl:text disable-output-escaping="yes"><![CDATA[.size() > 0)
			{
				stringClassicVRML.append(indentCharacter).append(indentCharacter).append("]]></xsl:text>
								<!-- TODO containerField name alternatives -->
								<xsl:value-of select="@name"/>
								<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
									<xsl:text>List</xsl:text><!-- append to member name -->
								</xsl:if>
								<xsl:text>").append(" [").append("\n")
					.append(indent).append(indentCharacter).append(indentCharacter); // containerField for MFNode array</xsl:text>
							</xsl:when>
							<xsl:otherwise>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:text>
			for (</xsl:text>
						<xsl:value-of select="$javaReferenceType"/>
						<xsl:text> element : </xsl:text>
						<xsl:value-of select="@name"/>
						<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<xsl:text>)
			{</xsl:text>
						<!-- cast abstract element to concrete type -->
						<xsl:text>
				stringClassicVRML.append(((X3DConcreteElement</xsl:text>
						<xsl:choose>
							<xsl:when test="not($isX3dStatement = 'true') or (@name = 'ROUTE') or (@name = 'IMPORT') or (@name = 'EXPORT')">
								<xsl:text><![CDATA[)element).toStringClassicVRML(indentLevel + indentIncrement + indentIncrement))]]></xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text><![CDATA[)element).toStringClassicVRML(indentLevel))]]></xsl:text>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:text>;</xsl:text>
						
						<xsl:if test="not((@type = 'X3D') or (@type = 'head') or (@type = 'Scene'))">
							<xsl:text>
			}</xsl:text>
						</xsl:if>
			
						<xsl:if test="not($isX3dStatement = 'true') or (@name = 'ROUTE') or (@name = 'IMPORT') or (@name = 'EXPORT')">
							<xsl:text>
				stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter).append("]").append("\n")
					.append(indent); // end MFNode array
			}
</xsl:text>
						</xsl:if>
			
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
			
			<!-- TODO confirm: IS handled per field
			<xsl:if test="($name = 'ProtoInstance')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			if (getIS() != null)
				stringClassicVRML.append(getIS().toStringClassicVRML(indentLevel + indentIncrement)); // IS follows fieldValue definitions]]></xsl:text>
			</xsl:if>
			-->
			
			<xsl:if test="($name = 'head')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
			// note required order of component, unit, meta (though relaxation of this requirement has been proposed)
			for (metaObject element : metaList)
			{
				 stringClassicVRML.append(element.toStringClassicVRML(indentLevel));
			}
]]></xsl:text>
			</xsl:if>
			
			<!-- special handling -->
			<xsl:choose>
				<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram')">
					<xsl:text disable-output-escaping="yes"><![CDATA[

			for (fieldObject element : fieldList)
			{
				 stringClassicVRML.append(element.toStringClassicVRML(indentLevel + indentIncrement));
			}
			if (sourceCode.trim().length() > 0)
			{
				String trimmedSource = sourceCode; // workaround, TODO fix BS Contact bug with leading whitespace
				stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter)
					.append("url [ \"").append(sourceCode).append("\n").append("\" ]").append("\n");
			}
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ComposedShader') or ($name = 'PackagedShader')">
					<xsl:text disable-output-escaping="yes"><![CDATA[

			for (fieldObject element : fieldList)
			{
				 stringClassicVRML.append(element.toStringClassicVRML(indentLevel + indentIncrement));
			}
]]></xsl:text>
				</xsl:when>
				<xsl:when test="($name = 'ShaderPart')">
					<xsl:text disable-output-escaping="yes"><![CDATA[

			if (sourceCode.trim().length() > 0)
			{
				String trimmedSource = sourceCode; // workaround, TODO fix BS Contact bug with leading whitespace
				stringClassicVRML.append(indent).append(indentCharacter).append(indentCharacter)
					.append("url [ \"").append(sourceCode).append("\n").append("\" ]").append("\n");
			}
]]></xsl:text>
				</xsl:when>
			</xsl:choose>
			
			<xsl:if test="(not($hasChildrenField = 'true') and not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
							not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock') and not($name = 'CADPart'))">
				<xsl:text><![CDATA[
			if (!commentsList.isEmpty())
			{
				CommentsBlock commentsBlock = new CommentsBlock(commentsList);]]></xsl:text>
				<xsl:choose>
					<xsl:when test="not($isX3dStatement = 'true')">
						<xsl:text>
				stringClassicVRML.append(commentsBlock.toStringClassicVRML(indentLevel));
				stringClassicVRML.append(indent); // end SFNode
			}</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>
				stringClassicVRML.append(commentsBlock.toStringClassicVRML(indentLevel));
			}</xsl:text>
						
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:text disable-output-escaping="yes"><![CDATA[
		}]]></xsl:text>
			<xsl:if test="not($isX3dStatement = 'true')">
				<xsl:text>
		if (hasAttributes || hasChild)
		{
			stringClassicVRML.append("}").append("\n"); // finish node content
		}</xsl:text>
			</xsl:if>
			</xsl:otherwise>
		</xsl:choose>

		<xsl:if test="($name = 'ProtoInstance')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		stringClassicVRML.append(indent).append("}").append("\n"); // finish closing tag]]></xsl:text>
		</xsl:if>
			
		<xsl:text disable-output-escaping="yes"><![CDATA[
		return stringClassicVRML.toString();
	}
]]></xsl:text>
						</xsl:if>
					
						<!-- toStringVRML97() -->
						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide VRML97 string serialization.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3DObject#FILE_EXTENSION_VRML97
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/14772/V2.0/index.html">Virtual Reality Modeling Language (VRML) 97 specification</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/14772-1/V2.1/index.html">VRML 97 v2.1 Amendment</a>
	 * @return VRML97 string
	 */
	@Override
	public String toStringVRML97(int indentLevel)
	{
		return toStringClassicVRML(indentLevel)]]></xsl:text>
	<xsl:choose>
		<xsl:when test="($name = 'X3D')">
			<!-- TODO fix this hack more thoroughly, possibly via ConfigurationProperties or else by optional parameter in method signature -->
			<xsl:text>
		.replace("#X3D V3.3 utf8","#VRML V2.0 utf8")
		.replace("#X3D V3.2 utf8","#VRML V2.0 utf8")
		.replace("#X3D V3.1 utf8","#VRML V2.0 utf8")
		.replace("#X3D V3.0 utf8","#VRML V2.0 utf8")
		.replaceAll("PROFILE ","#PROFILE ")
		.replaceAll("COMPONENT ","#COMPONENT ")
		.replaceAll("META ","#META ")
		.replaceAll("UNIT ","#UNIT "); // hide unavailable X3D features</xsl:text>
		</xsl:when>
		<xsl:when test="($name = 'component')">
			<xsl:text>.replaceAll("COMPONENT ","#COMPONENT "); // hide unavailable X3D feature</xsl:text>
		</xsl:when>
		<xsl:when test="($name = 'meta')">
			<xsl:text>.replaceAll("META ","#META "); // hide unavailable X3D feature</xsl:text>
		</xsl:when>
		<xsl:when test="($name = 'component')">
			<xsl:text>.replaceAll("UNIT ","#UNIT "); // hide unavailable X3D feature</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>;</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text disable-output-escaping="yes"><![CDATA[
	}
]]></xsl:text>
						</xsl:if>
					
						<!-- Scene includes nodes with DEF -->
						<!-- getNodeByDEF()
						<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock') and not(starts-with($thisClassName, 'X3DConcrete'))) or
									  ($name = 'ProtoBody') or ($name = 'ProtoInstance') or ($name = 'Scene')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide object reference to node by DEF name, if found as this node or in a contained node.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorSceneObject() to check entire scene graph, or findAncestorX3DObject() to check entire model document.
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3DObject()
	 * @see #findElementByNameValue(String,String)
	 * @param DEFlabel DEF name of node to find
	 * @return object reference to node
	 */]]></xsl:text>
							<xsl:if test="not($name = 'Scene') and not($name = 'ProtoBody')">
								<xsl:text>
	@Override</xsl:text>
							</xsl:if>
								<xsl:text>
	public X3DConcreteNode getNodeByDEF(String DEFlabel)
	{
		X3DConcreteNode referenceNode;
</xsl:text>
							<xsl:if test="not($name = 'Scene') and not($name = 'ProtoBody')">
								<xsl:text>
		if (getDEF().equals(DEFlabel))
			return this;
</xsl:text>
							</xsl:if>
							
							<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and 
															((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
								<xsl:variable name="isFieldX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaType">
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="@type"/>
										<xsl:with-param name="isInterface" select="$isInterface"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaReferenceType">
									<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
								</xsl:variable>
								<xsl:choose>
									<xsl:when test="($isFieldX3dStatement = 'true')">
										< ! - - ignore, statements do not include DEF - - >
									</xsl:when>
									<xsl:when test="(@type = 'SFNode')">
										<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
		{
			referenceNode = ((X3DConcreteNode) </xsl:text><xsl:value-of select="@name"/><xsl:text>).getNodeByDEF(DEFlabel); // SFNode
			if (referenceNode != null)
				return referenceNode;
		}</xsl:text>
									</xsl:when>
									<xsl:when test="(@type = 'MFNode')">
										<xsl:text>
		for (</xsl:text>
		<xsl:value-of select="$javaReferenceType"/>
		<xsl:text> element : </xsl:text><xsl:value-of select="@name"/><xsl:text>) // MFNode
		{
			if (element instanceof org.web3d.x3d.jsail.X3DConcreteNode)
			{
				if (((X3DConcreteNode) element).getDEF().equals(DEFlabel))
					return (X3DConcreteNode) element; // found, this node
			
				// not yet found, continue with depth-first search of current child element
				referenceNode = ((X3DConcreteNode) element).getNodeByDEF(DEFlabel);
				if (referenceNode != null)
					return referenceNode; // found in child
			}
		}</xsl:text>
									</xsl:when>
								</xsl:choose>
							</xsl:for-each>
							<xsl:if test="($name = 'ProtoInstance')">
								<xsl:text>
		// ProtoInstance node can contain other DEF'ed nodes in any contained fieldValue
		for (fieldValueObject fieldInitialization : getFieldValueList()) // MFNode
		{
			// not yet found, continue with depth-first search of current fieldValueList
			for (X3DNode child : fieldInitialization.getChildren())
			{
				if (child instanceof X3DConcreteNode)
				{
					referenceNode = ((X3DConcreteNode) child).getNodeByDEF(DEFlabel);
					if (referenceNode != null)
						return referenceNode; // found in child
				}
			}
		}</xsl:text>
							</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[
		return null; // not found, in this node or in children nodes
	}
]]></xsl:text>
						</xsl:if>
						 -->
					
						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">
							<!-- ======================== -->
							<!-- findElementByNameValue() -->
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide object reference to node or statement by name attribute, if found as part of this element or in a contained element.
	 * Elements with name fields include meta, Metadata* nodes, field/fieldValue, ProtoDeclare/ExternProtoDeclare/ProtoInstance, HAnim nodes.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorSceneObject() to check entire scene graph, or findAncestorX3DObject() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same name, this method does not handle that case.
	 * @see #findNodeByDEF(String)
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3DObject()
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @return object reference to found element, null otherwise
	 */
	@Override
	public X3DConcreteElement findElementByNameValue(String nameValue)
	{
		return findElementByNameValue(nameValue, ""); // empty string is wildcard, any element match is allowed
	}
								
	/**
	 * Recursive method to provide object reference to node or statement by name attribute, if found as part of this element or in a contained element.
	 * Elements with name fields include meta, Metadata* nodes, field/fieldValue, ProtoDeclare/ExternProtoDeclare/ProtoInstance, HAnim nodes.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorSceneObject() to check entire scene graph, or findAncestorX3DObject() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same name, this method does not handle that case.
	 * @see #findNodeByDEF(String)
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3DObject()
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @param elementName identifies the element of interest (meta MetadataString ProtoDeclare CADassembly ProtoInstance HAnimHumanoid etc.)
	 * @return object reference to found element, null otherwise
	 */
	@Override
	public X3DConcreteElement findElementByNameValue(String nameValue, String elementName)
	{
		if ((nameValue == null) || nameValue.isEmpty())
		{
			String errorNotice = "findElementByNameValue(\"\", " + elementName + ") cannot use empty string to find a name attribute";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}]]></xsl:text>
							<xsl:choose>
								<xsl:when test="($thisClassName = 'CommentsBlock')">
									<!-- no children to test -->
								</xsl:when>
								<xsl:when test="InterfaceDefinition/field[@name = 'name']">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (elementName == null)
			elementName = "";
		if (getName().equals(nameValue) &&
			(elementName.isEmpty() || elementName.equals(getElementName())))
			return this;]]></xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<xsl:text disable-output-escaping="yes"><![CDATA[
		// no name field available for this element]]></xsl:text>
								</xsl:otherwise>
							</xsl:choose>
							
							<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and 
															((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
								<xsl:if test="position() = 1">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		X3DConcreteElement referenceElement;]]></xsl:text>	
								</xsl:if>
								<xsl:variable name="isFieldX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaType">
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="@type"/>
										<xsl:with-param name="isInterface" select="$isInterface"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaReferenceType">
									<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
								</xsl:variable>
								<xsl:choose>
									<xsl:when test="(@name = 'field') or (@name = 'fieldValue')">
										<xsl:text>
		for (</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>Object element : </xsl:text><xsl:value-of select="@name"/><xsl:text disable-output-escaping="yes"><![CDATA[List)
		{
			if (element instanceof X3DConcreteElement)
			{
				referenceElement = ((X3DConcreteElement) element).findElementByNameValue(nameValue, elementName);
				if ((referenceElement != null))
					return referenceElement;
			}
		}]]></xsl:text>
									</xsl:when>
									<xsl:when test="(@type = 'SFNode') or (@name = 'ProtoDeclare') or (@name = 'ExternProtoDeclare') or (@name = 'ProtoInstance')">
										<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
		{
			referenceElement = ((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>).findElementByNameValue(nameValue, elementName);
			if (referenceElement != null)
				return referenceElement;
		}</xsl:text>
										<!-- now corresponding ProtoInstance for each SFNode field -->
										<xsl:if test="(@type = 'SFNode') and not($isX3dStatement = 'true')">
											<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance != null)
		{
			referenceElement = ((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance).findElementByNameValue(nameValue, elementName);
			if (referenceElement != null)
				return referenceElement;
		}</xsl:text>
										</xsl:if>
									</xsl:when>
									<xsl:when test="(@type = 'MFNode') and
													(not($isFieldX3dStatement = 'true') or starts-with(@name,'field'))">
										<xsl:text>
		for (</xsl:text>
		<xsl:value-of select="$javaReferenceType"/>
		<xsl:text> element : </xsl:text><xsl:value-of select="@name"/><xsl:text>) // MFNode
		{
			if (element instanceof X3DConcreteElement)
			{
				referenceElement = ((X3DConcreteElement) element).findElementByNameValue(nameValue, elementName);
				if (referenceElement != null)
					return referenceElement;
			}
		}</xsl:text>
									</xsl:when>
								</xsl:choose>
							</xsl:for-each>
	<xsl:text disable-output-escaping="yes"><![CDATA[
		return null; // not found
	}
	/**
	 * Recursive method to determine whether node or statement with given name attribute is found, meaning both objects are attached to same scene graph.
	 * @param nameValue is value of the name field being searched for in this element and child elements(if any)
	 * @param elementName identifies the element of interest (meta MetadataString ProtoDeclare CADassembly ProtoInstance HAnimHumanoid etc.)
	 * @see #findElementByNameValue(String, String)
	 * @return whether node is found
	 */
	public boolean hasElementByNameValue(String nameValue, String elementName)
	{
		return (findElementByNameValue(nameValue, elementName) != null);
	}
]]></xsl:text>
							<!-- ================================== -->
							<!-- findNodeByDEF() and hasNodeByDef() -->
<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Recursive method to provide object reference to node by DEF, if found as this node or in a contained node.
	 * <br ><br >
	 * <i>Warning:</i> first start with findAncestorSceneObject() to check entire scene graph, or findAncestorX3DObject() to check entire model document.
	 * <br ><br >
	 * <i>Warning:</i> more than one element may be found that has the same DEF, this method does not handle that case.
	 * @see #findElementByNameValue(String)
	 * @see X3DConcreteElement#hasAncestorSceneObject()
	 * @see org.web3d.x3d.jsail.X3DConcreteElement#findAncestorX3DObject()
	 * @param DEFvalue is value of the name field being searched for in this element and child elements(if any)
	 * @return object reference to found node, null otherwise
	 */
	@Override
	public X3DConcreteNode findNodeByDEF(String DEFvalue)
	{
		if ((DEFvalue == null) || DEFvalue.isEmpty())
		{
			String errorNotice = "findNodeByDEF(\"\") cannot use empty string to find a name";
			validationResult.append(errorNotice).append("\n");
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}]]></xsl:text>
							<xsl:choose>
								<xsl:when test="InterfaceDefinition/field[@name = 'DEF']">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (getDEF().equals(DEFvalue))
			return this;]]></xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<!-- no children to test -->
								</xsl:otherwise>
							</xsl:choose>
							
							<xsl:for-each select="InterfaceDefinition/field[(contains(@type,'FNode')) and not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and 
															((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
								<xsl:if test="position() = 1">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		X3DConcreteNode referenceNode;]]></xsl:text>	
								</xsl:if>
								<xsl:variable name="isFieldX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaType">
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="@type"/>
										<xsl:with-param name="isInterface" select="$isInterface"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaReferenceType">
									<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
								</xsl:variable>
								<xsl:choose>
									<xsl:when test="(@type = 'SFNode')">
										<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
		{
			referenceNode = ((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>).findNodeByDEF(DEFvalue);
			if (referenceNode != null)
				return referenceNode;
		}</xsl:text>
									</xsl:when>
									<xsl:when test="(@type = 'MFNode') and 
													not(($isFieldX3dStatement = 'true') or starts-with(@name,'field'))">
										<xsl:text>
		for (</xsl:text>
		<xsl:value-of select="$javaReferenceType"/>
		<xsl:text> element : </xsl:text><xsl:value-of select="@name"/><xsl:text>) // MFNode
		{
			if (element instanceof org.web3d.x3d.jsail.X3DConcreteNode)
			{
				referenceNode = ((X3DConcreteElement) element).findNodeByDEF(DEFvalue);
				if (referenceNode != null)
					return referenceNode;
			}
		}</xsl:text>
									</xsl:when>
								</xsl:choose>
							</xsl:for-each>
	<xsl:text disable-output-escaping="yes"><![CDATA[
		return null; // not found
	}
	/**
	 * Recursive method to determine whether node with DEFvalue is found, meaning both objects are attached to same scene graph.
	 * @param DEFvalue is value of the name field being searched for in this element and child elements(if any)
	 * @see #findNodeByDEF(String)
	 * @return whether node is found
	 */
	public boolean hasNodeByDEF(String DEFvalue)
	{
		return (findNodeByDEF(DEFvalue) != null);
	}
]]></xsl:text>
							<!-- ======================== -->
						</xsl:if>
					
						<!-- validate() -->
						<xsl:if test="not(starts-with($thisClassName, 'X3DConcrete'))">
							<xsl:text>
		
	/**
	 * Recursive method to validate this element plus all contained nodes and statements.
	 * @return validation results (if any)
	 */
	@Override
	public String validate()
	{
		validationResult = new StringBuilder(); // prepare for updated results
</xsl:text>
							<xsl:for-each select="InterfaceDefinition/field[not(starts-with(@name,'set')) and not(ends-with(@name,'changed')) and 
															((@accessType='initializeOnly') or (@accessType='inputOutput'))]">
								<xsl:sort select="contains(@type,'Node')"/> <!-- attributes first can simplify debugging -->
								<xsl:variable name="isFieldX3dStatement">
									<xsl:call-template name="isX3dStatement">
										<xsl:with-param name="name" select="@name"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaType">
									<xsl:call-template name="javaType">
										<xsl:with-param name="x3dType" select="@type"/>
										<xsl:with-param name="isInterface" select="$isInterface"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:variable name="javaReferenceType">
									<xsl:value-of select="substring-before(substring-after($javaType,'&lt;'),'&gt;')"/>
								</xsl:variable>
								<xsl:variable name="fieldName" select="translate(@name,'-','_')"/><!-- handle http-equiv etc. -->
								<xsl:variable name="CamelCaseName"><!-- upper camel case -->
									<xsl:choose>
										<xsl:when test="starts-with(@name,'set_')">
											<xsl:value-of select="translate(substring(substring-after(@name,'set_'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
											<xsl:value-of select="substring(substring-after(@name,'set_'),2)"/>
										</xsl:when>
										<xsl:when test="starts-with(@name,'set')">
											<xsl:value-of select="translate(substring(substring-after(@name,'set'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
											<xsl:value-of select="substring(substring-after(@name,'set'),2)"/>
										</xsl:when>
										<xsl:when test="contains(@name,'_changed')">
											<xsl:value-of select="translate(substring(substring-before(@name,'_changed'),1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
											<xsl:value-of select="substring(substring-before(@name,'_changed'),2)"/>
										</xsl:when>
										<xsl:when test="(@name = 'DEF') or (@name = 'USE')">
											<!-- unmodified -->
											<xsl:value-of select="@name"/>
										</xsl:when>
										<xsl:when test="(@name = 'class')">
											<!-- getClass() is reserved by Java Object() class -->
											<xsl:text>CssClass</xsl:text>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="translate(substring(@name,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
											<xsl:value-of select="substring($fieldName,2)"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:variable name="isRequired"><!-- either by X3D Schema/OM4X3D or X3D semantics -->
									<xsl:value-of select="(@use = 'required') or
														  ((@name = 'name') and not(ancestor::ConcreteNode[(@name = 'ProtoInstance')]) and
														   (ancestor::ConcreteNode[starts-with(@name,'HAnim') or starts-with(@name,'Metadata') or
																				   starts-with(@name,'field') or contains(@name,'ProtoDeclare')])) or
														  (ancestor::ConcreteNode[(@name = 'component') or (@name = 'connect') or (@name = '') or (@name = 'ROUTE') or (@name = 'unit')]) or
														  ((@name = 'localDEF')                               and (ancestor::ConcreteNode[(@name = 'EXPORT')])) or
														  (((@name = 'inlineDEF') or (@name = 'importedDEF')) and (ancestor::ConcreteNode[(@name = 'IMPORT')])) or
														  (((@name = 'type')    or (@name = 'accessType'))    and (ancestor::ConcreteNode[starts-with(@name,'field')])) or
														  (((@name = 'profile') or (@name = 'version'))       and (ancestor::ConcreteNode[(@name = 'X3D')])) or
														  ((@name = 'version') and (ancestor::ConcreteNode[(@name = 'HAnimHumanoid')])) or
														  ((@name = 'content') and (ancestor::ConcreteNode[(@name = 'meta')]))"/>
								</xsl:variable>
								<xsl:text>&#10;		</xsl:text><!-- indent -->
								
								<xsl:if test="($isRequired = 'true')">
									<!--
									<xsl:message>
										<xsl:text>[node=</xsl:text>
										<xsl:value-of select="ancestor::ConcreteNode/@name"/>
										<xsl:text>, attribute=</xsl:text>
										<xsl:value-of select="@name"/>
										<xsl:text>, $isRequired=</xsl:text>
										<xsl:value-of select="$isRequired"/>
										<xsl:text>]</xsl:text>
									</xsl:message>
									-->
									<xsl:choose>
										<xsl:when test="(@type = 'SFNode') or (@type = 'MFNode')">
											<xsl:text>// TODO check for required field</xsl:text>
										</xsl:when>
										<xsl:when test="(@type = 'SFString')">
											<xsl:text>if (get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>().isEmpty()</xsl:text>
											<xsl:if test="not($isX3dStatement = 'true')">
												<xsl:text disable-output-escaping="yes"><![CDATA[ && !isUSE()]]></xsl:text>
											</xsl:if>
											<xsl:text>) // required attribute
		{
			String errorNotice = ConfigurationProperties.ERROR_VALUE_NOT_FOUND + 
									", " + NAME + " </xsl:text><xsl:value-of select="$fieldName"/><xsl:text> field is required but no value found. ";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		// TODO duplicate name checks in setValue() method</xsl:text>
										</xsl:when>
									</xsl:choose>
									<xsl:text>&#10;		</xsl:text><!-- indent -->
								</xsl:if>
								<xsl:choose>
									<xsl:when test="(@type = 'SFNode')">
										<xsl:text>if (</xsl:text><xsl:value-of select="@name"/><xsl:text> != null)
		{
			set</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>(get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>());
			((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>).validate(); // exercise field checks, SFNode
			validationResult.append(((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>).getValidationResult());
		}</xsl:text>
				<xsl:if test="not($isX3dStatement = 'true')">
					<xsl:text>
		if (</xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance != null)
		{
			set</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>(get</xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>ProtoInstance());
			((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance).validate(); // exercise field checks, SFNode
			validationResult.append(((X3DConcreteElement) </xsl:text><xsl:value-of select="@name"/><xsl:text>ProtoInstance).getValidationResult());
		}
		if ((</xsl:text>   <xsl:value-of select="@name"/><xsl:text disable-output-escaping="yes"><![CDATA[ != null) && (]]></xsl:text>
						   <xsl:value-of select="@name"/><xsl:text>ProtoInstance != null))
		{
			String errorNotice = "Internal X3DJSAIL error: incorrect handling of contained SFNode field, both </xsl:text><xsl:value-of select="@name"/><xsl:text> and </xsl:text>
				<xsl:value-of select="@name"/><xsl:text>ProtoInstance are set simultaneously";
			validationResult.append(errorNotice);
			throw new InvalidProtoException(errorNotice); // report error
		}</xsl:text>
				</xsl:if>
									</xsl:when>
									<xsl:when test="(@type = 'MFNode')">
										<xsl:text>for (</xsl:text>
		<xsl:value-of select="$javaReferenceType"/>
		<xsl:text> element : </xsl:text><xsl:value-of select="@name"/>
						<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<xsl:text>) // MFNode
		{
			((X3DConcreteElement) element).validate(); // exercise field checks, MFNode element
			validationResult.append(((X3DConcreteElement) element).getValidationResult());
		}
		set</xsl:text><xsl:value-of select="$CamelCaseName"/>
						<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<xsl:text>(get</xsl:text><xsl:value-of select="$CamelCaseName"/>
						<xsl:if test="($isFieldX3dStatement = 'true') and (@type='MFNode')">
							<xsl:text>List</xsl:text><!-- append to member name -->
						</xsl:if>
						<xsl:text>()); // also test getter/setter validation
</xsl:text>
									</xsl:when>
									<xsl:otherwise>
										<xsl:if test="(@name = 'DEF')">
											<xsl:text>if (!isUSE()) // be careful! setting DEF via setDEF() method will reset USE value
			</xsl:text>
										</xsl:if>
										<xsl:if test="(@name = 'USE')">
											<xsl:text>if (isUSE()) // be careful! setting USE via setUSE() method resets all attributes to default values and wipes out all children
			</xsl:text>
										</xsl:if>
										<xsl:if test="(@name = 'value') and (($name = 'field') or ($name = 'fieldValue'))">
											<xsl:text>
		if (!hasChildren()) // be careful! only check simple types if no children nodes found
			</xsl:text>
										</xsl:if>
										<xsl:text>set</xsl:text><xsl:value-of select="translate($CamelCaseName,'-','_')"/>
<xsl:text>(get</xsl:text><xsl:value-of select="translate($CamelCaseName,'-','_')"/>
										<xsl:text>()); // exercise field checks, simple types
</xsl:text>
									</xsl:otherwise>
								</xsl:choose>
								<!-- ProtoInstance name checks -->
								<xsl:if test="($name = 'ProtoInstance') and (@name = 'name')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (getName().isEmpty() && !isUSE())
        {
			String errorNotice = "ProtoInstance missing name field, which is usually required (since this ProtoInstance is not a USE node).";
			validationResult.append(errorNotice);
			throw new InvalidProtoException(errorNotice); // report error
        }
		// check for corresponding ProtoDeclare/ExternProtoDeclare having same name, report if missing
		if (!getName().isEmpty() && getNodeType().startsWith(ConfigurationProperties.ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE))
        {
			String errorNotice = getNodeType();
			validationResult.append(errorNotice);
			throw new InvalidProtoException(errorNotice); // report error
        }
		// TODO check for legal containerField among allowed getContainerFieldAlternateValues() for given nodeType
]]></xsl:text>
                                                                </xsl:if>
								<!-- USE child checks -->
								<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) or ($name = 'ProtoInstance')">
									<xsl:choose>
										<xsl:when test="(@type = 'SFNode')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		if (isUSE() && has]]></xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>()) // test USE restrictions
		{
			String errorNotice = "</xsl:text><xsl:value-of select="$name"/><xsl:text> USE='" + getUSE() + "' is not allowed to have contained </xsl:text>
				<xsl:value-of select="@type"/><xsl:text> </xsl:text><xsl:value-of select="@name"/><xsl:text>";
			validationResult.append(errorNotice);
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		</xsl:text>
									<xsl:if test="not($hasChildrenField = 'true') and not(starts-with($name, 'X3DConcrete'))">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		if (isUSE() && !commentsList.isEmpty())// test USE restrictions
		{
			String errorNotice = "]]></xsl:text><xsl:value-of select="$name"/><xsl:text> USE='" + getUSE() + "' is not allowed to have contained comments";
			validationResult.append(errorNotice);
			throw new InvalidFieldValueException(errorNotice); // report error		
		}
</xsl:text>
									</xsl:if>
										</xsl:when>
										<xsl:when test="(@type = 'MFNode')">
										<xsl:text disable-output-escaping="yes"><![CDATA[
		if (isUSE() && has]]></xsl:text><xsl:value-of select="$CamelCaseName"/><xsl:text>()) // test USE restrictions
		{
			String errorNotice = "</xsl:text><xsl:value-of select="$name"/><xsl:text> USE='" + getUSE() + "' is not allowed to have contained </xsl:text>
				<xsl:value-of select="@type"/><xsl:text> </xsl:text><xsl:value-of select="@name"/><xsl:text>";
			validationResult.append(errorNotice);
			throw new InvalidFieldValueException(errorNotice); // report error		
		}
		</xsl:text>
										</xsl:when>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
							
							<!-- Special validation tests -->
							<!-- TODO regular expresions (regexes) -->
							
							<xsl:choose>
								<xsl:when test="(@name = 'ROUTE')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		// NMTOKEN checks for allowed characters and no whitespace are provided when
		// setting name of fromNode, fromField, toNode, toField

		// Now check ROUTE node-type validity; note that each ROUTE must already be connected to scene graph
		
		String errorNotice = new String();
		String ROUTE_description = "<ROUTE fromNode='" + fromNode + "' fromField='" + fromField + 
										  "' toNode='" +   toNode +   "' toField='" +   toField + "'/>";
		
		X3DConcreteNode fromNodeObject = null;
		X3DConcreteNode   toNodeObject = null;	
													
		if ((findAncestorSceneObject() == null) && (findAncestorProtoBody() == null))
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH + 
							   ", ROUTE is not currently connected to scene graph and thus fromNode/toNode fields cannot be checkedmust first be connected to scene graph in order to get checked. ";
				validationResult.append(ROUTE_description).append("\n").append(errorNotice).append("\n");
			}
		}
		if (getFromField().isEmpty())
		{
			errorNotice = " ROUTE has no DEF value for source node since fromNode value is empty. ";
			validationResult.append(errorNotice).append("\n");
		}
		else if (findAncestorProtoBody() != null) // look only within ProtoBody, if appropriate
		{
			fromNodeObject = findAncestorProtoBody().findNodeByDEF(getFromNode());
			if (fromNodeObject == null)
			{
				errorNotice = " ROUTE fromNode='" + getFromNode() + "' was not found within connected ProtoBody. ";
				validationResult.append(errorNotice).append("\n");
			}
		}
		else if (findAncestorSceneObject() != null) // otherwise look within Scene
		{
			fromNodeObject = findAncestorSceneObject().findNodeByDEF(getFromNode());
			if (fromNodeObject == null)
			{
				errorNotice = " ROUTE fromNode='" + getFromNode() + "' was not found in connected scene graph. ";
				validationResult.append(errorNotice).append("\n");
			}
		}
		if (getToField().isEmpty())
		{
			errorNotice = " ROUTE has no DEF value for target node since toNode value is empty. ";
			validationResult.append(errorNotice).append("\n");
		}
		else if (findAncestorProtoBody() != null) // look only within ProtoBody, if appropriate
		{
			toNodeObject = findAncestorProtoBody().findNodeByDEF(getToNode());
			if (toNodeObject == null)
			{
				errorNotice = " ROUTE toNode='" + getToNode() + "' was not found within connected ProtoBody. ";
				validationResult.append(errorNotice).append("\n");
			}
		}
		else if (findAncestorSceneObject() != null) // otherwise look within Scene
		{
			toNodeObject = findAncestorSceneObject().findNodeByDEF(getToNode());
			if (toNodeObject == null)
			{
				errorNotice = " ROUTE toNode='" + getToNode() + "' was not found in connected scene graph. ";
				validationResult.append(errorNotice).append("\n");
			}
		}
		if (fromNode.equals(toNode) && fromField.equals(toField)) // self-ROUTE check
		{
			errorNotice = " ROUTE source and destination are identical. ";
			validationResult.append(errorNotice).append("\n");
		}
		if (!errorNotice.isEmpty() || (fromNodeObject == null) || (toNodeObject == null))
		{
			validationResult.append(ROUTE_description).append("\n");
		}
		else // further checking
		{
			String  fromNodeType, toNodeType, fromFieldType, toFieldType, fromFieldAccessType, toFieldAccessType = new String();

			 fromNodeType = fromNodeObject.getClass().getSimpleName().split("Object")[0]; // substring-before Object
			   toNodeType =   toNodeObject.getClass().getSimpleName().split("Object")[0]; // substring-before Object

			      fromFieldType = fromNodeObject.getFieldType (fromField);
			        toFieldType =   toNodeObject.getFieldType (  toField);
			fromFieldAccessType = fromNodeObject.getAccessType(fromField);
			  toFieldAccessType =   toNodeObject.getAccessType(  toField);
										
			ROUTE_description = "ROUTE details: FROM " + 
				fromNode + "." + fromField + " [" + fromNodeType + "," + fromFieldType + "," + fromFieldAccessType + "] TO " +
				  toNode + "." +   toField + " [" +   toNodeType + "," +   toFieldType + "," +   toFieldAccessType + "]";

			if (!fromFieldType.equals(toFieldType))
			{
				errorNotice = " ROUTE has source-destination type mismatch, " + 
							   "fromField='" + fromField + "' source and toField='" + toField + "' destination have different types. ";
			}
			if (!fromFieldAccessType.equals(fieldObject.ACCESSTYPE_INPUTOUTPUT) &&
				!fromFieldAccessType.equals(fieldObject.ACCESSTYPE_OUTPUTONLY))
			{
				errorNotice = " ROUTE fromField (source) event can only have accessType='inputOutput' or accessType='outputOnly'. ";
			}
			if (  !toFieldAccessType.equals(fieldObject.ACCESSTYPE_INPUTOUTPUT) &&
				  !toFieldAccessType.equals(fieldObject.ACCESSTYPE_INPUTONLY))
			{
				errorNotice = " ROUTE toField (destination) event can only have accessType='inputOutput' or accessType='inputOnly'. ";
			}
			if (!errorNotice.isEmpty())
			{
				validationResult.append(errorNotice).append("\n").append(ROUTE_description).append("\n");
				throw new InvalidFieldValueException(ROUTE_description + "\n" + errorNotice);
			}
		}]]></xsl:text>
								</xsl:when>
								<xsl:when test="(@name = 'IndexedFaceSet') or (@name = 'IndexedLineSet')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (hasCoord() && coordIndex.isEmpty())
		{
			if (getCoordCount() > 0)
			{
				String errorNotice = NAME + " containing Coordinate nodel with " + getCoordCount() + " values must also include coordIndex field";
				validationResult.append(errorNotice);
				throw new InvalidFieldException(errorNotice); // report error
			}
		}
		if (((color != null) || (colorProtoInstance != null)) && colorIndex.isEmpty() && coordIndex.isEmpty())
		{
			if (getColorCount() > 0)
			{
				String errorNotice = NAME + " containing Color node with " + getColorCount() + " values must also include colorIndex or coordIndex field";
				validationResult.append(errorNotice);
				throw new InvalidFieldException(errorNotice); // report error
			}
		}]]></xsl:text>
		<xsl:if test="(@name = 'IndexedFaceSet')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((hasNormal()) && normalIndex.isEmpty() && coordIndex.isEmpty())
		{
			if (getNormalCount() > 0)
			{
				String errorNotice = NAME + " containing Normal node with " + getNormalCount() + " values must also include normalIndex or coordIndex field";
				validationResult.append(errorNotice);
				throw new InvalidFieldException(errorNotice); // report error
			}
		}
		if (((texCoord != null) || (texCoordProtoInstance != null)) && texCoordIndex.isEmpty() && coordIndex.isEmpty())
		{
			if (getTexCoordCount() > 0)
			{
				String errorNotice = NAME + " containing TextureCoordinate node with " + getTexCoordCount() + " values must also include texCoordIndex or coordIndex field";
				validationResult.append(errorNotice);
				throw new InvalidFieldException(errorNotice); // report error
			}
		}]]></xsl:text>
		</xsl:if>
								</xsl:when>
								<xsl:when test="(@name = 'IMPORT')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		// check IMPORT not overloading DEF name
		
		String errorNotice = new String();
		String IMPORT_description = "<IMPORT inlineDEF='" + inlineDEF + "' importedDEF='" + importedDEF + "' AS='" + AS + "'/>";
										
		if (findAncestorSceneObject() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH + 
							   ": IMPORT is not currently connected to SceneObject scene graph and thus cannot get checked.";
				validationResult.append(IMPORT_description).append("\n").append(errorNotice).append("\n");
			}
		}
		else
		{
			X3DConcreteNode          inlineDEFObject = findAncestorSceneObject().findNodeByDEF(  inlineDEF);
			X3DConcreteNode importedDEF_InlineObject = findAncestorSceneObject().findNodeByDEF(importedDEF);
			X3DConcreteNode          AS_InlineObject = findAncestorSceneObject().findNodeByDEF(         AS);
			
			if (inlineDEF.isEmpty())
			{
				errorNotice += "IMPORT error: no inlineDEF value defined. ";
			}
			else if (inlineDEFObject == null)
			{
				errorNotice += "IMPORT error: corresponding <Inline DEF='" + inlineDEF + "'/> not found. ";
			}
			if      (!AS.isEmpty() && (AS_InlineObject != null))
			{
				errorNotice += "IMPORT collision in parent scene: another " + AS_InlineObject.getElementName() + 
							   " node found with DEF value matching IMPORT AS value. ";
			}
			else if ( AS.isEmpty() && !importedDEF.isEmpty() && (importedDEF_InlineObject != null))
			{
				errorNotice += "IMPORT collision: another " + importedDEF_InlineObject.getElementName() + 
							   " node found with DEF value matching IMPORT importedDEF value. ";
			}					
			if (!errorNotice.isEmpty())
			{
				validationResult.append(IMPORT_description).append("\n").append(errorNotice).append("\n");
				throw new InvalidFieldValueException(IMPORT_description + "\n" + errorNotice);
			}
		}
]]></xsl:text>
								</xsl:when>
								<xsl:when test="(@name = 'EXPORT')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		// check EXPORT using valid DEF name
		
		String errorNotice = new String();
		String EXPORT_description = "<EXPORT localDEF='" + localDEF + "' AS='" + AS + "'/>";
										
		if (findAncestorSceneObject() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				errorNotice = ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH + 
							   ": EXPORT is not currently connected to SceneObject scene graph and thus cannot get checked.";
				validationResult.append(EXPORT_description).append("\n").append(errorNotice).append("\n");
			}
		}
		else
		{
			X3DConcreteNode   localDEFObject = findAncestorSceneObject().findNodeByDEF(localDEF);

			if (localDEF.isEmpty())
			{
				errorNotice = "EXPORT has no localDEF defined. ";
			}
			else if (localDEFObject == null)
			{
				errorNotice = "Local node with DEF=localDEF not found. ";
			}
			if (!errorNotice.isEmpty())
			{
				validationResult.append(EXPORT_description).append("\n").append(errorNotice).append("\n");
				throw new InvalidFieldValueException(EXPORT_description + "\n" + errorNotice);
			}
		}
]]></xsl:text>

								</xsl:when>
								<!-- ProtoDeclare, ExternProtoDeclare check for corresponding ProtoInstance -->
								<xsl:when test="($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (findAncestorSceneObject().findElementByNameValue (getName(), ProtoInstanceObject.NAME) == null)
		{
			String warningNotice = ConfigurationProperties.WARNING_PROTOINSTANCE_NOT_FOUND + 
									", " + NAME + " " + getName() + " has no corresponding " +
									ProtoInstanceObject.NAME + " attached to the scene graph. ";
			validationResult.append(warningNotice).append("\n");
		}
		// TODO pass through allowed containerField values array?
]]></xsl:text>
								</xsl:when>
								<xsl:when test="(@name = 'ProtoBody')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (children.isEmpty())
		{
			String errorNotice = ConfigurationProperties.ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE + 
						   ": ProtoBody does not have any child nodes and so ProtoDeclare has no node type. ";
			String ProtoDeclare_description = "Parent ProtoDeclare name: " + getName(); // may report error condition if no parent
			validationResult.append(ProtoDeclare_description).append("\n").append(errorNotice).append("\n");
		}
]]></xsl:text>
								</xsl:when>
								<xsl:when test="(@name = 'connect')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if (nodeField.equals("DEF") || nodeField.equals("USE") || nodeField.startsWith("css") || nodeField.startsWith("containerField")) 
		{
			String errorNotice = ConfigurationProperties.ERROR_ILLEGAL_VALUE + 
						   ": connect statement cannot modify DEF, USE, cssClass or containerField value of an internal node. ";
			String connect_description = "connectObject protoField='" + protoField + "' nodeField='" + nodeField + "'. ";
			validationResult.append(connect_description).append("\n").append(errorNotice).append("\n");
		}
]]></xsl:text>
								</xsl:when>
								<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ComposedShader') or ($name = 'PackagedShader')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		for (fieldObject field : fieldList) // check each field
		{
			field.validate(); // exercise field checks to ensure connected and valid
			validationResult.append(field.getValidationResult());
		}
]]></xsl:text>	
								</xsl:when>
								<!-- TODO review ProtoInstance checks
									<xsl:when test="($name = 'ProtoInstance')">
										<xsl:text>		// now check corresponding prototype declaration fields
		if (findAncestorSceneObject() == null)
		{
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				String errorNotice = "ProtoDeclare name='" + getName() + "' must first be connected to SceneObject scene graph in order to get checked.";
				validationResult.append(errorNotice).append("\n");
			}
			return "PrototypeNotFoundWhenNotConnectedToSceneGraph"; // not found
		}
		X3DConcreteElement declarationElement = findAncestorSceneObject().findElementByNameValue(getName(), ProtoDeclareObject.NAME); 
		if (declarationElement instanceof org.web3d.x3d.jsail.Core.ProtoDeclareObject)
		{
			fieldObject field = ((ProtoDeclareObject) declarationElement).getProtoInterface().findFieldByName(fieldName);
			if  (field != null)
				 result = field.getType();
			else result = "FieldDeclarationNotFound";
		}
		declarationElement = findAncestorSceneObject().findElementByNameValue(getName(), ExternProtoDeclareObject.NAME);
		if (declarationElement instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclareObject)
		{
			fieldObject field = ((ExternProtoDeclareObject) declarationElement).findFieldByName(fieldName);
			if  (field != null)
				 result = field.getType();
			else result = "FieldDeclarationNotFound";
		}
</xsl:text>
									</xsl:when>
									-->
								<!-- ProtoBody might contain only comments
								<xsl:when test="(@name = 'ProtoBody')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((primaryNode == null) && !getChildren().isEmpty()) // must have primaryNode if any children are present
		{
			String errorNotice = "ProtoBody primaryNode is null, but getChildren() has" + getChildren().size() + " entries";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidProtoException(errorNotice); // report error
		}
]]></xsl:text>
								</xsl:when> -->
							</xsl:choose>
							
							<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) or ($name = 'ProtoInstance')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
		if (getIS() != null)
		{
			if (getIS().getConnectList().isEmpty())
			{
				String errorNotice = "IS statement present, but contains no connect statements";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidProtoException(errorNotice); // report error
			}				
			// TODO also check that this node has ancestor ProtoBody, and that a field with same name also exists, so that IS is legal
		}]]></xsl:text>
							</xsl:if>
							<xsl:if test="(not($isX3dStatement = 'true') and not($name = 'CommentsBlock')) and not($name = 'ProtoInstance')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
		if (!getContainerFieldOverride().isEmpty() &&
			!Arrays.asList(containerField_ALTERNATE_VALUES).contains(getContainerFieldOverride()))
		{
			String errorNotice = ConfigurationProperties.ERROR_ILLEGAL_VALUE + 
				": illegal value encountered, containerField='" + getContainerFieldOverride() +
				"' but allowed values are containerField_ALTERNATE_VALUES='" + 
				new MFStringObject(containerField_ALTERNATE_VALUES).toStringX3D() + "'.";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldException(errorNotice); // report error
		}]]></xsl:text>
							</xsl:if>
							<!-- profileNames checking, add validation test if appropriate -->
							<xsl:variable name="profileNamesAppinfo" select="false()"/>
							<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
							<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
							<xsl:choose>
								<xsl:when test="($isX3dStatement = 'true') or ($name = 'CommentsBlock')">
									<!-- no validation test needed, all X3D statements allowed in all X3D profiles -->
								</xsl:when>
								<xsl:otherwise>
									<xsl:text disable-output-escaping="yes"><![CDATA[

		// profile validation test, if connected to full scene
		if (findAncestorX3DObject() != null)
		{
			String     modelProfile = findAncestorX3DObject().getProfile();
			headObject modelHead    = findAncestorX3DObject().getHead();
			ArrayList<componentObject> sceneComponentsList = new ArrayList<>();
			if (modelHead != null) 
				sceneComponentsList = modelHead.getComponentList();
			boolean hasSatisfactoryComponent = false;
			for (componentObject nextComponent : sceneComponentsList)
			{
				if ( nextComponent.getName().equals("]]></xsl:text><xsl:value-of select="$componentName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[") &&
					(nextComponent.getLevel() >= ]]></xsl:text>
					<xsl:value-of select="$componentLevel"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[))
					hasSatisfactoryComponent = true;
			}
			if (!hasSatisfactoryComponent &&]]></xsl:text>
			<xsl:for-each select="(//SimpleTypeEnumerations/SimpleType[@name='profileNames']/enumeration/allowedElement[.=$name])">
				<xsl:text>
				!modelProfile.equals("</xsl:text><xsl:value-of select="../@value"/><xsl:text disable-output-escaping="yes"><![CDATA[") &&]]></xsl:text>
			</xsl:for-each>
				<xsl:text disable-output-escaping="yes"><![CDATA[
				!modelProfile.equals("Full"))
			{
				String errorNotice = ConfigurationProperties.ERROR_ILLEGAL_VALUE + 
					" invalid X3D profile='" + modelProfile +
					"' for parent X3D model, add element <componentInfo name=']]></xsl:text><xsl:value-of select="$componentName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[' level=']]></xsl:text>
					<xsl:value-of select="$componentLevel"/>
					<xsl:text disable-output-escaping="yes"><![CDATA['/>\n" +
					"or source-code assignment: " +
					" findAncestorX3DObject().getHead().addComponentInfo(\"]]></xsl:text><xsl:value-of select="$componentName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[\").setLevel(]]></xsl:text>
					<xsl:value-of select="$componentLevel"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[);";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldException(errorNotice); // report error
			}
		}]]></xsl:text>
								</xsl:otherwise>
							</xsl:choose>

							<xsl:text>
		return validationResult.toString();
	}
</xsl:text>
						</xsl:if>

						<!-- addComments() for single String -->
						<xsl:if test="not($isInterface = 'true') and not($isFieldInterface or $isException or $isServiceInterface) and
									  not(//field[@name = 'children']) and not($name = 'CommandLine') and not($name = 'ConfigurationProperties') and not($name = 'CommentsBlock')">
							<xsl:text>
		/**
		 * Utility method to add a comment to this </xsl:text>
							<xsl:value-of select="$name"/>
							<xsl:text>.
		 * @param newComment is new comment string to add to list of comments.
		 * @see CommentsBlock
	</xsl:text>
							<xsl:text>	 * @return {@link </xsl:text>
							<xsl:value-of select="$thisClassName"/>
							<xsl:text>} - namely </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
							<xsl:text>this</xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
							<xsl:text> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
		 */
		public </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> addChild (String newComment) // found?
		{</xsl:text>
							<xsl:choose>
								<xsl:when test="//field[@name = 'children']">
									<xsl:text>
			addChild(new CommentsBlock(newComment));
			return this;</xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<xsl:text>
			commentsList.add(newComment);
			return this;</xsl:text>
								</xsl:otherwise>
							</xsl:choose>
							<xsl:text>
		}
	</xsl:text>
						</xsl:if>
						
						<xsl:choose><!-- utility methods for node-unique and statement-unique functionality -->
							
							<xsl:when test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ComposedShader') or ($name = 'PackagedShader') or ($name = 'ShaderPart')">
								<!-- field utilities -->
							<xsl:if test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ComposedShader') or ($name = 'PackagedShader')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Add field to fieldList for this ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text>
	 * @param newField is field to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ addField (fieldObject newField)
	{
		String errorNotice = new String();
		for (fieldObject priorField : fieldList) // check for field with duplicate name
		{
			if (priorField.getName().equals(newField.getName()))
			{
				errorNotice = "Illegal addField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/>
				<xsl:text> DEF='" + getDEF() + "'</xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[, provided duplicate newField name='" + newField.getName() + "'";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldException(errorNotice);
			}
		}
		String fieldValidationResult = newField.validate();
		if (!fieldValidationResult.trim().isEmpty())
		{
			errorNotice = "Illegal addField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/>
			<xsl:text> DEF='" + getDEF() + "'</xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[, newField.validation() failure: " + fieldValidationResult;
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldException(errorNotice);
		}
		fieldList.add(newField);
		newField.setParentObject(this);
		return this;
	}
	/**
	 * Remove a field from contained fieldList
	 * @param fieldToRemove matching field of interest
	 * @see #removeField(String)
	 * @return whether field was removed
	 */
	public boolean removeField (fieldObject fieldToRemove)
	{
		int  fieldIndex = fieldList.indexOf(fieldToRemove);
		if  (fieldIndex >= 0)
		{
			 fieldObject removedField = fieldList.remove(fieldIndex);
			 return (removedField != null);
		}
		else return false;
	}
	/**
	 * Remove a field by name from contained fieldList
	 * @param fieldName matching field of interest
	 * @see #removeField(fieldObject)
	 * @return whether field was removed
	 */
	public boolean removeField (String fieldName)
	{
		fieldObject fieldToRemove = findFieldByName (fieldName);
		if (fieldToRemove != null)
			return removeField (fieldToRemove);
		else return false;
	}

	/**
	 * Clear all fields
	 */
	public void clearFields ()
	{
		fieldList.clear();
	}

	/**
	 * Determine whether field(s) are available
	 * @return whether field(s) are found
	 */
	public boolean hasField ()
	{
		return !fieldList.isEmpty();
	}

	/**
	 * Provide list of fields.
	 * @return value of field list
	 */
	public ArrayList<fieldObject> getFieldList()
	{
		return fieldList;
	}
		
	/**
	 * Find contained field statement by name, if present.
	 * @param fieldName is name attribute for field of interest
	 * @return fieldObject reference of interest, null otherwise
	 */
	public fieldObject findFieldByName (String fieldName)
	{
		for (fieldObject element : fieldList)
		{
			 if (element.getName().equalsIgnoreCase(fieldName))
				 return element;
		}
		return null;
	}
	/**
	 * Determine if field statement is present.
	 * @param fieldName is name attribute for field of interest
	 * @return whether field is found
	 */
	public boolean hasField (String fieldName)
	{
		return (findFieldByName(fieldName) != null);
	}
]]></xsl:text>
							</xsl:if>
							<!-- ComposedShader, PackagedShader have no contained source <SourceText/> -->
							<xsl:if test="($name = 'Script') or ($name = 'ShaderProgram') or ($name = 'ShaderPart')">
								<xsl:text disable-output-escaping="yes"><![CDATA[

	/**
	 * Set new source code (for example, JavaScript).
	 * <i>WARNING</i>: be sure to prepend <i>ecmascript:</i> prior to any actual source code.
	 * @param newSourceText is source code to set
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setSourceCode (String[] newSourceText)
	{
		return setSourceCode (Arrays.toString(newSourceText));
	}

	/**
	 * Set new source code (for example, JavaScript).
	 * <i>WARNING</i>: be sure to prepend <i>ecmascript:</i> prior to any actual source code.
	 * @see <a href="http://www.web3d.org/x3d/content/X3dTooltips.html#CDATA" target="_blank">X3D Scene Authoring Hints: CDATA Character Data</a>
	 * @param newSourceText is source code to set
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setSourceCode (String newSourceText)
	{
		String errorNotice = new String();
		if (newSourceText == null)
		{
			errorNotice = "Illegal setSourceCode() invocation, String newSourceText is null. ";
			validationResult.append(errorNotice).append("\n");
		}
		else if (newSourceText.trim().isEmpty())
		{
			errorNotice = "Illegal setSourceCode() invocation, String newSourceText is empty. ";
			validationResult.append(errorNotice).append("\n");
		}
		else if (newSourceText.trim().startsWith("<![CDATA[") || newSourceText.endsWith("]" + "]>"))
		{
			errorNotice = "Illegal setSourceCode() invocation, String newSourceText is wrapped in <![CDATA[ ...(source)... ]]> block which can be omitted";
			validationResult.append(errorNotice).append("\n");
		}
		if (!newSourceText.trim().startsWith("<![CDATA[") && !newSourceText.trim().startsWith("ecmascript:"))
		{
			errorNotice = "Illegal setSourceCode() invocation, String newSourceText must start with \"ecmascript:\"";
			validationResult.append(errorNotice).append("\n");
		}
		if (!errorNotice.isEmpty())
			throw new InvalidFieldValueException(errorNotice);

		sourceCode = newSourceText;
		return this;
	}

	/**
	 * Set new source code (for example, JavaScript).
	 * <i>WARNING</i>: be sure to prepend <i>ecmascript:</i> prior to any actual source code.
	 * @param newSourceText is source to set
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ setSourceCode (StringBuilder newSourceText)
	{
		if (newSourceText == null)
		{
			String errorNotice = "Illegal setSourceCode() invocation, StringBuilder newSourceText is null";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		else if (!newSourceText.toString().trim().startsWith("ecmascript:") && (newSourceText.toString().trim().length() > 0))
		{
			String errorNotice = "Illegal setSourceCode() invocation, StringBuilder newSourceText must start with \"ecmascript:\"";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		setSourceCode(newSourceText.toString()); // apply further diagnostics
		return this;
	}

	/**
	 * Append source code (for example, JavaScript)
	 * @param newSourceText is source to append
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendSourceCode (String newSourceText)
	{
		sourceCode += newSourceText;
		return this;
	}

	/**
	 * Append source code (for example, JavaScript)
	 * @param newSourceText is source to append
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ appendSourceCode (StringBuilder newSourceText)
	{
		if (newSourceText == null)
		{
			String errorNotice = "Illegal appendSourceCode() invocation, StringBuilder newSourceText is null";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		else sourceCode += newSourceText.toString();
		return this;
	}

	/**
	 * Clear all contained CDATA source code.
	 * @return {@link ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ clearSource ()
	{
		sourceCode = SOURCECODE_DEFAULT_VALUE;
		return this;
	}
]]></xsl:text>
								</xsl:if>
								<!-- addField, findFieldByName methods are repeated for ProtoInterface and ExternProtoDeclare -->
							</xsl:when>
							<xsl:when test="($name = 'ProtoInterface') or ($name = 'ProtoBody') or ($name = 'ExternProtoDeclare')">
								<xsl:if test="($name = 'ProtoInterface') or ($name = 'ExternProtoDeclare')">
									<!-- addField, findFieldByName methods repeat a Script method -->
									<xsl:text>
	/**
	 * Add field to fieldList for this </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text>
	 * @param newField is field to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ addField (fieldObject newField)
	{
		String errorNotice = new String();
		for (fieldObject priorField : fieldList) // check for field with duplicate name
		{
			if (priorField.getName().equals(newField.getName()))
			{
				errorNotice = "Illegal addField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> </xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[ name='" + getName() +
					"', trying to add field with duplicate name='" + newField.getName() + "'";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldException(errorNotice);
			}
		}
		String fieldValidationResult = newField.validate();
		if (!fieldValidationResult.trim().isEmpty())
		{
			errorNotice = "Illegal addField() invocation for ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text> </xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[ name='" + getName() +
					"', newField.validation() failure: " + fieldValidationResult;
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldException(errorNotice);
		}
		fieldList.add(newField);
		newField.setParentObject(this);
		return this;
	}
		
	/**
	 * Find contained field statement by name, if present.
	 * @param fieldName is name attribute for field of interest
	 * @return fieldObject reference of interest, null otherwise
	 */
	public fieldObject findFieldByName (String fieldName)
	{
		for (fieldObject element : fieldList)
		{
			 if (element.getName().equalsIgnoreCase(fieldName))
				 return element;
		}
		return null;
	}
]]></xsl:text>
								</xsl:if>
								<xsl:if test="($name = 'ProtoInterface') or ($name = 'ProtoBody')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to inspect parent ProtoDeclare and provide String value from inputOutput SFString field named <i>name</i>.
	 * @return value of name field in parent ProtoDeclare
	 * @see ProtoDeclareObject#getName
	 */
	public String getName()
	{
		if  (getParentObject() != null)
			 return ((ProtoDeclareObject)getParentObject()).getName();
		else return ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH + 
				": " + getElementName() + "Object has no parent ProtoDeclareObject, thus getName() cannot be checked.";
	}
]]></xsl:text>
								</xsl:if>
							</xsl:when>
							<xsl:when test="($name = 'ProtoInstance')">
								<xsl:text>
	/**
	 * Add fieldValue
	 * @param newFieldValue is fieldValue to add
	 * @return {@link </xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ addFieldValue (fieldValueObject newFieldValue)
	{
		String errorNotice = new String();
		for (fieldValueObject priorFieldValue : fieldValueList) // check for field with duplicate name
		{
			if (priorFieldValue.getName().equals(newFieldValue.getName()))
			{
				errorNotice = "Illegal addFieldValue() invocation for ProtoInstanceObject name='" + getName() +
					"', trying to add fieldValue with duplicate name='" + newFieldValue.getName() + "'";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
		}
		String fieldValueValidationResult = newFieldValue.validate();
		if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed() &&
			!fieldValueValidationResult.trim().isEmpty())
		{
			errorNotice = "Illegal addFieldValue() invocation for ProtoInstanceObject name='" + getName() +
					"' fieldValue name='" + newFieldValue.getName() + "'" +
					", newFieldValue.validation() failure:\n   " + fieldValueValidationResult;
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldException(errorNotice);
		}
		fieldValueList.add(newFieldValue);
		newFieldValue.setParentObject(this);
		return this;
	}
	
	/**
	 * Find contained fieldValue statement by name, if present.
	 * @param fieldValueName is name attribute for fieldValue of interest
	 * @return fieldValueObject reference of interest, null otherwise
	 */
	public fieldValueObject findFieldValueByName (String fieldValueName)
	{
		for (fieldValueObject element : fieldValueList)
		{
			 if (element.getName().equalsIgnoreCase(fieldValueName))
				 return element;
		}
		return null;
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'Scene')">
								<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to add single X3DMetadataNode to contained list of existing Scene root nodes (if any).
         * <i>WARNING</i>: Scene is a statement that is implicit in several encodings and has no <i>metadata</i> field, so top-level metadata nodes are typically kept together within other top-level root nodes as Scene children.
	 * @param newValue is new node value to be appended the children field.	 
	 * @return {@link SceneObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	*/
	public SceneObject addMetadata(X3DMetadataObject newValue)
	{
		if (newValue == null)
		{
			return this;
		}
                // note Scene has no metadata field, add to children instead
		children.add((X3DNode)newValue);
		((X3DConcreteElement) newValue).setParentObject(this);
		return this;
	}
	/**
	 * Utility method to add single LayerSetObject to contained list of existing Scene root nodes (if any).
	 * @param newValue is new node value to be appended the children field.	 
	 * @return {@link SceneObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	*/
	public SceneObject addLayerSet(LayerSetObject newValue)
	{
		if (newValue == null)
		{
			return this;
		}
		children.add((X3DNode)newValue);
		((X3DConcreteElement) newValue).setParentObject(this);
		return this;
	}
]]></xsl:text>
							</xsl:when>
							<xsl:when test="($name = 'head')">
								<xsl:text>
	/**
	 * Find contained meta statement by name, if present.
	 * @param metaName is name attribute for meta element of interest
	 * @return metaObject reference of interest, null otherwise
	 */
	public metaObject findMetaByName (String metaName)
	{
		for (metaObject element : metaList)
		{
			 if (element.getName().equalsIgnoreCase(metaName))
				 return element;
		}
		return null;
	}
									
	/**
	 * Find contained component statement by name, if present.
	 * @param componentName is name attribute for component element of interest
	 * @return componentObject reference of interest, null otherwise
	 */
	public componentObject findComponentByName (String componentName)
	{
		for (componentObject element : componentList)
		{
			 if (element.getName().equalsIgnoreCase(componentName))
				 return element;
		}
		return null;
	}
									
	/**
	 * Find contained unit statement by name, if present.
	 * @param unitName is name attribute for unit element of interest
	 * @return unitObject reference of interest, null otherwise
	 */
	public unitObject findUnitByName (String unitName)
	{
		for (unitObject element : unitList)
		{
			 if (element.getName().equalsIgnoreCase(unitName))
				 return element;
		}
		return null;
	}
</xsl:text>
							</xsl:when>
                                                        <xsl:when test="($name = 'Extrusion')">
                                                                <xsl:text disable-output-escaping="yes"><![CDATA[
    /**
     * Whether crossSection array is open or closed (closed means that endpoints are coincident).
     * @return whether crossSection is closed, i.e. first and last points identical
     */
        public boolean isCrossSectionClosed()
        {
            boolean isClosed;
            if (crossSection == null) return false; // safety check
            int crossSectionTupleLength = crossSection.length / MFVec2fObject.TUPLE_SIZE;
            isClosed = (crossSectionTupleLength > 1) && 
                       (crossSection[0] == crossSection[(crossSectionTupleLength-1)*2 + 0]) && 
                       (crossSection[1] == crossSection[(crossSectionTupleLength-1)*2 + 1]);
            return isClosed;
        }

    /**
     * Whether spine array is open or closed (closed means that endpoints are coincident).
     * @return whether spine is closed, i.e. first and last points identical
     */
        public boolean isSpineClosed()
        {
            boolean isClosed;
            if (spine == null) return false; // safety check
            int spineTupleLength = spine.length / MFVec3fObject.TUPLE_SIZE;
            isClosed = (spineTupleLength > 1) && 
                       (spine[0] == spine[(spineTupleLength-1)*3 + 0]) && 
                       (spine[1] == spine[(spineTupleLength-1)*3 + 1]) && 
                       (spine[2] == spine[(spineTupleLength-1)*3 + 2]);
            return isClosed;
        }

    /**
     * Create SVG output file (with same base name) for Extrusion crossSection, if found.
     * @see X3DObject#FILE_EXTENSION_SVG
     * @see ConfigurationProperties#STYLESHEET_extrusionCrossSectionSVG
     * @see X3DObject#toFileStylesheetConversion(String,String)
     * @param fileName name of file to create and save, can include local directory path, must end with .svg
     * @return File containing result (if operation succeeds), null otherwise
   */
	public File toFileSvgCrossSection(String fileName)
        {
            if (!(fileName.endsWith(X3DObject.FILE_EXTENSION_SVG)))
            {
                    throw new X3DException("fileName " + fileName + " does not end with expected extension \"" + X3DObject.FILE_EXTENSION_SVG + "\"");
            }
            return findAncestorX3DObject().toFileStylesheetConversion(ConfigurationProperties.STYLESHEET_extrusionCrossSectionSVG, fileName);
        }
]]></xsl:text>
                                                        </xsl:when>
						</xsl:choose><!-- node-unique and statement-unique methods -->
						
					</xsl:if>
	
					<xsl:if test="($name = 'fieldValue') and not($isInterface = 'true')">
						<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Provide base type of this fieldValue declaration from corresponding ProtoDeclare/ExternProtoDeclare field declaration.
	 * String value ['SFBool'|'MFBool'|'SFColor'|'MFColor'|'SFColorRGBA'|'MFColorRGBA'|'SFDouble'|'MFDouble'|'SFFloat'|'MFFloat'|'SFImage'|'MFImage'|'SFInt32'|'SFNode'|'MFNode'|'MFInt32'|'SFRotation'|'MFRotation'|'SFString'|'MFString'|'SFTime'|'MFTime'|'SFVec2d'|'MFVec2d'|'SFVec2f'|'MFVec2f'|'SFVec3d'|'MFVec3d'|'SFVec3f'|'MFVec3f'|'SFVec4d'|'MFVec4d'|'SFVec4f'|'MFVec4f'|'SFMatrix3d'|'MFMatrix3d'|'SFMatrix3f'|'MFMatrix3f'|'SFMatrix4d'|'MFMatrix4d'|'SFMatrix4f'|'MFMatrix4f'] from inputOutput SFString field named <i>type</i>.
	 * <br><br>
	 * @see org.web3d.x3d.jsail.Core.fieldObject
	 * @return type value from corresponding field declaration, otherwise "fieldValueTypeNotFound"
	 */
	public String getType()
	{
		String prototypeName;
		String fieldValueType = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE; // default until found
		String errorNotice = new String();
							
		if (getParentObject() == null)
		{
			errorNotice = ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH + 
							": fieldValue name='" + getName() + "' is not currently connected to a ProtoInstanceObject and thus getType() cannot be checked.";
			validationResult.append(errorNotice).append("\n");
							
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				 throw new InvalidProtoException(errorNotice); // report error
			}
			else // can occur during object creation
			{
				return ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE;
			}
		}
		else prototypeName = ((ProtoInstanceObject) getParentObject()).getName();

		fieldObject fieldDefinition = new fieldObject();
		SceneObject ancestorSceneObject = findAncestorSceneObject();
		if (ancestorSceneObject == null)
		{
			errorNotice = "ProtoInstance name='" + prototypeName + "' with fieldValue  name='" + getName() + "' problem: " +
						   ConfigurationProperties.ERROR_NOT_CONNECTED_TO_SCENE_GRAPH;
			validationResult.append(errorNotice).append("\n");
							
			if (!ConfigurationProperties.isCreationConnectionValidationExceptionAllowed())
			{
				 throw new InvalidProtoException(errorNotice); // report error
			}
			else // can occur during object creation
			{
				return ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE;
			}
		}
		X3DConcreteElement correspondingPrototype = ancestorSceneObject.findElementByNameValue(prototypeName);
		if (correspondingPrototype == null)
		{
			errorNotice = "ProtoInstance name='" + prototypeName + "' does not have a corresponding " +
						  "ProtoDeclare or ExternProtoDeclare name='" + name + "' definition";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidProtoException(errorNotice); // report error
		}
		correspondingPrototype = findAncestorSceneObject().findElementByNameValue(prototypeName, ProtoDeclareObject.NAME);
		if (correspondingPrototype instanceof org.web3d.x3d.jsail.Core.ProtoDeclareObject)
		{
			fieldDefinition = ((ProtoDeclareObject) correspondingPrototype).getProtoInterface().findFieldByName(name);
			if (fieldDefinition != null)
				fieldValueType = fieldDefinition.getType(); // found in scene graph
			else
			{
				errorNotice = "fieldValue name='" + name + "' does not have a corresponding ProtoDeclare field name='" +
							   name + "' definition";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidProtoException(errorNotice); // report error
			}
			return fieldValueType;
		}
		// else
		correspondingPrototype = findAncestorSceneObject().findElementByNameValue(prototypeName, ExternProtoDeclareObject.NAME);
		if (correspondingPrototype instanceof org.web3d.x3d.jsail.Core.ExternProtoDeclareObject)
		{
			fieldDefinition = ((ExternProtoDeclareObject) correspondingPrototype).findFieldByName(name);
			if (fieldDefinition != null)
				fieldValueType = fieldDefinition.getType(); // found in scene graph
			else
			{
				errorNotice = "fieldValue name='" + name + "' does not have a corresponding ProtoDeclare field name='" +
							   name + "' definition";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidProtoException(errorNotice); // report error
			}
		}
		return fieldValueType;
	}
]]></xsl:text>
					</xsl:if>
	
					<xsl:if test="(($name = 'field') or ($name = 'fieldValue')) and not($isInterface = 'true')">
						
						<xsl:for-each select="//FieldTypes/FieldType">
							<xsl:variable name="fieldName" select="@type"/>
							<xsl:variable name="upperCaseFieldName" select="upper-case($fieldName)"/>
							<xsl:variable name="baseValue">
								<xsl:choose>
									<xsl:when test="contains(@type,'String')">
										<xsl:text>value</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Bool')">
										<xsl:text>valueArrayBoolean</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Int32') or contains(@type,'Image')">
										<xsl:text>valueArrayInteger</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Float') or contains(@type,'Color') or contains(@type,'Rotation') or
													ends-with(@type,'f')">
										<xsl:text>valueArrayFloat</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'Double') or contains(@type,'Time') or ends-with(@type,'d')">
										<xsl:text>valueArrayDouble</xsl:text>
									</xsl:when>
									<xsl:when test="contains(@type,'FNode')">
										<!-- handled by getChildren method -->
									</xsl:when>
									<xsl:otherwise>
										<xsl:message>
											<xsl:text>*** unhandled baseValue: </xsl:text>
											<xsl:value-of select="@type"/>
										</xsl:message>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="isSingletonType">
								<xsl:value-of select="(@type = 'MFBool')   or (@type = 'MFInt32') or (@type = 'MFDouble') or (@type = 'MFFloat') or 
													  (@type = 'MFString') or (@type = 'MFTime')  or (@type = 'MFNode') or
													   starts-with(@type,'SF')"/>
							</xsl:variable>
							<xsl:variable name="javaPrimitiveType">
								<xsl:call-template name="javaType">
									<xsl:with-param name="x3dType" select="@type"/>
									<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
								</xsl:call-template>
							</xsl:variable>
							<xsl:variable name="javaBaseType">
								<xsl:choose>
									<xsl:when test="contains($javaPrimitiveType,'[')">
										<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="$javaPrimitiveType"/><!-- array of array type -->
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:variable name="tupleSize">
								<xsl:call-template name="tupleSize">
									<xsl:with-param name="x3dType" select="@type"/>
								</xsl:call-template>
							</xsl:variable>
<!-- debug
<xsl:if test="($debug = 'true')">
</xsl:if>
<xsl:message>
<xsl:text>// field ($fieldName=</xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:text>, $isSingletonType=</xsl:text>
<xsl:value-of select="$isSingletonType"/>
<xsl:text>, $javaPrimitiveType=</xsl:text>
<xsl:value-of select="$javaPrimitiveType"/>
<xsl:text>, $javaPrimitiveType=</xsl:text>
<xsl:value-of select="$javaBaseType"/>
<xsl:text>, $tupleSize=</xsl:text>
<xsl:value-of select="$tupleSize"/>
<xsl:text>)</xsl:text>
</xsl:message> -->
							<!-- typed get methods -->
							<xsl:choose>
								<xsl:when test="contains(@type,'FNode')">
									<!-- handled by getChildren() -->
								</xsl:when>
								<xsl:when test="starts-with(@type,'SF')">
									<xsl:text>
	/**
	 * Get typed value of a </xsl:text><xsl:value-of select="$fieldName"/><xsl:text> </xsl:text><xsl:value-of select="$name"/><xsl:text> declaration.
	 * @return typed value object (if values are available), otherwise returns default object
	 */
	public </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/>
		<xsl:text> getValue</xsl:text><xsl:value-of select="@type"/>
		<xsl:text>()
	{
		if (getType().equals(fieldObject.TYPE_</xsl:text><xsl:value-of select="$upperCaseFieldName"/><xsl:text>))
		{
			if (</xsl:text>
			<xsl:choose>
				<xsl:when test="(@type = 'SFString') or (@type = 'MFString')">
					<xsl:value-of select="$baseValue"/>
					<xsl:text>.isEmpty())</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$baseValue"/>
					<xsl:text>.length == 0)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>
			{
				return new </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/>
		<xsl:text>();
			}
			else</xsl:text>
			<xsl:choose>
				<xsl:when test="(@type = 'SFString') or (@type = 'MFString')">
					<!-- no further test needed -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:text> if (</xsl:text>
					<xsl:value-of select="$baseValue"/>
					<xsl:text>.length == </xsl:text>
					<xsl:value-of select="$tupleSize"/>
					<xsl:text>)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>
			{
				return new </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>(</xsl:text><xsl:value-of select="$baseValue"/>
					<xsl:if test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
						<xsl:text>[0]</xsl:text>
					</xsl:if>
					<xsl:text>);
			}</xsl:text>
			<xsl:if test="not(@type = 'SFString') and not(@type = 'MFString')">
				<xsl:text>
			else // hopefully this case cannot occur, possible internal library error
			{
				String errorNotice = "Invalid invocation of field.getValue</xsl:text>
					<xsl:if test="not(@type = 'SFString') and not(@type = 'MFString')">
						<xsl:value-of select="@type"/>
					</xsl:if>
					<xsl:text>() singleton method when field value='" +
									 </xsl:text><xsl:value-of select="$baseValue"/><xsl:text>.toString() + "' has length=" + </xsl:text><xsl:value-of select="$baseValue"/><xsl:text>.length;
				throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
			}</xsl:text>
			</xsl:if>
				<xsl:text>
		}
		else
		{
			String errorNotice = "Invalid invocation of field.getValue</xsl:text>
					<xsl:if test="not(@type = 'SFString') and not(@type = 'MFString')">
						<xsl:value-of select="@type"/>
					</xsl:if>
					<xsl:text>() when declared field type='" + getType() + "'";
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
	}
</xsl:text>
								</xsl:when>
								<xsl:when test="starts-with(@type,'MF')">
		<xsl:text>
	/**
	 * Get typed value of this </xsl:text><xsl:value-of select="$name"/><xsl:text> declaration.
	 * @return typed value object, if values are available
	 */
	public </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/>
		<xsl:text> getValue</xsl:text><xsl:value-of select="@type"/><xsl:text>()
	{
		if (getType().equals(fieldObject.TYPE_</xsl:text><xsl:value-of select="$upperCaseFieldName"/><xsl:text>))
		{
			return new </xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text>(</xsl:text><xsl:value-of select="$baseValue"/><xsl:text>);
		}
		else
		{
			String errorNotice = "Invalid invocation of field.getValue</xsl:text>
					<xsl:if test="not(@type = 'SFString') and not(@type = 'MFString')">
						<xsl:value-of select="@type"/>
					</xsl:if>
					<xsl:text>() when declared field type='" + getType() + "'";
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
	}
</xsl:text>
								</xsl:when>
							</xsl:choose>
							<!-- typed set methods -->
							<xsl:choose>
								<xsl:when test="contains(@type,'FNode')">
									<!-- handled by getChildren() -->
								</xsl:when>
								<xsl:when test="not(contains(@type,'FString'))">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Set typed value of a ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text> </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.
	 * <i>WARNING</i>: must first <i>setType()</i> for the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text>
	 <xsl:value-of select="$name"/>
	 <xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> setValue(</xsl:text><xsl:value-of select="@type"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> newValue)
	{
		clearValues();
		</xsl:text>
		<!-- no need to test array tupleSize since this is already an object -->
		<xsl:choose>
			<xsl:when test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFFloat') or (@type = 'SFDouble') or (@type = 'SFTime')">
				<xsl:value-of select="$baseValue"/>
				<xsl:text> = new </xsl:text><xsl:value-of select="$javaBaseType"/><xsl:text>[1]; // fix array size
		</xsl:text>
				<xsl:value-of select="$baseValue"/>
				<xsl:text>[0] = newValue.getPrimitiveValue();</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<!-- no need to resize -->
				<xsl:value-of select="$baseValue"/>
				<xsl:text> = newValue.getPrimitiveValue();</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>
		return this;
	}						
</xsl:text>
								</xsl:when>
							</xsl:choose>
						</xsl:for-each>
						<!-- specialty set methods for field, fieldValue -->
						<xsl:text>
	/**
	 * Clear all values in a </xsl:text><xsl:value-of select="$name"/><xsl:text> declaration.
	 * @return {@link </xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> clearValues()
	{
		value = VALUE_DEFAULT_VALUE;
		valueArrayBoolean = java.util.Arrays.copyOf(DEFAULT_VALUE_BOOLEAN, DEFAULT_VALUE_BOOLEAN.length); // must be separate copy
		valueArrayInteger = java.util.Arrays.copyOf(DEFAULT_VALUE_INTEGER, DEFAULT_VALUE_INTEGER.length); // must be separate copy
		valueArrayFloat   = java.util.Arrays.copyOf(DEFAULT_VALUE_FLOAT,   DEFAULT_VALUE_FLOAT.length  ); // must be separate copy
		valueArrayDouble  = java.util.Arrays.copyOf(DEFAULT_VALUE_DOUBLE,  DEFAULT_VALUE_DOUBLE.length ); // must be separate copy
		clearChildren(); // clear all contained children including nodes, statements and comments (if any)
		return this;
	}
	/**
	 * Set typed value of a boolean </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.
	 * <i>WARNING</i>: must first <i>setType()</i> for the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(boolean newValue)
	{
		if (!getType().equals(fieldObject.TYPE_SFBOOL) && !getType().equals(fieldObject.TYPE_MFBOOL))
		{
			String errorNotice = "Illegal type: cannot setValue(boolean " + newValue + ") when ]]></xsl:text>
								<xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		clearValues();
		valueArrayBoolean = new boolean[1]; // fix array size
		valueArrayBoolean[0] = newValue;
		return this;
	}
	/**
	 * Set typed value of a boolean[] </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.
	 * <i>WARNING</i>: must first <i>setType()</i> for the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(boolean[] newValue)
	{
		if (!getType().equals(fieldObject.TYPE_SFBOOL) && !getType().equals(fieldObject.TYPE_MFBOOL))
		{
			String errorNotice = "Illegal type: cannot setValue(boolean[] " + newValue + ") when ]]></xsl:text>
							<xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		clearValues();
		if (newValue == null)
			return this;
		valueArrayBoolean = newValue;
		return this;
	}
	/**
	 * Set typed value of a integer </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.
	 * <i>WARNING</i>: must first <i>setType()</i> for the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(int newValue)
	{
		if (!getType().equals(fieldObject.TYPE_SFINT32) && !getType().equals(fieldObject.TYPE_MFINT32))
		{
			String errorNotice = "Illegal type: cannot setValue(int " + newValue + ") when ]]></xsl:text>
								<xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		clearValues();
		valueArrayInteger = new int[1]; // fix array size
		valueArrayInteger[0] = newValue;
		return this;
	}
	/**
	 * Set typed value of a integer array </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.
	 * <i>WARNING</i>: must first <i>setType()</i> for the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(int[] newValue)
	{
		if (!getType().equals(fieldObject.TYPE_SFINT32) && !getType().equals(fieldObject.TYPE_MFINT32) &&
			!getType().equals(fieldObject.TYPE_SFIMAGE) && !getType().equals(fieldObject.TYPE_MFIMAGE))
		{
			String errorNotice = "Illegal type: cannot setValue(int[] " + newValue + ") when ]]></xsl:text>
								<xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		clearValues();
		if (newValue == null)
			return this;
		valueArrayInteger = newValue;
		return this;
	}
	/**
	 * Set typed value of a float </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.
	 * <i>WARNING</i>: must first <i>setType()</i> for the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float newValue)
	{
		if (!getType().equals(fieldObject.TYPE_SFFLOAT)    && !getType().equals(fieldObject.TYPE_MFFLOAT) &&
			!getType().equals(fieldObject.TYPE_SFTIME)     && !getType().equals(fieldObject.TYPE_MFTIME))
		{
			String errorNotice = "Illegal type: cannot setValue(float " + newValue + ") when ]]></xsl:text>
								<xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		clearValues();
		if (getType().equals(fieldObject.TYPE_SFTIME) || !getType().equals(fieldObject.TYPE_MFTIME))
		{
			valueArrayDouble = new double[1]; // fix array size
			valueArrayDouble[0] = newValue;
		}
		else
		{
			valueArrayFloat = new float[1]; // fix array size
			valueArrayFloat[0] = newValue;
		}
		return this;
	}
	/**
	 * Set typed value of a float[] array </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.
	 * <i>WARNING</i>: must first <i>setType()</i> for the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float[] newValue)
	{
		if (!getType().equals(fieldObject.TYPE_SFCOLOR)    && !getType().equals(fieldObject.TYPE_MFCOLOR) &&
			!getType().equals(fieldObject.TYPE_SFCOLORRGBA)&& !getType().equals(fieldObject.TYPE_MFCOLORRGBA) &&
			!getType().equals(fieldObject.TYPE_SFFLOAT)    && !getType().equals(fieldObject.TYPE_MFFLOAT) &&
			!getType().equals(fieldObject.TYPE_SFROTATION) && !getType().equals(fieldObject.TYPE_MFROTATION) &&
			!getType().equals(fieldObject.TYPE_SFTIME)     && !getType().equals(fieldObject.TYPE_MFTIME) &&
			!getType().equals(fieldObject.TYPE_SFVEC2F)    && !getType().equals(fieldObject.TYPE_MFVEC2F) &&
			!getType().equals(fieldObject.TYPE_SFVEC3F)    && !getType().equals(fieldObject.TYPE_MFVEC3F) &&
			!getType().equals(fieldObject.TYPE_SFVEC4F)    && !getType().equals(fieldObject.TYPE_MFVEC4F) &&
			!getType().equals(fieldObject.TYPE_SFMATRIX3F) && !getType().equals(fieldObject.TYPE_MFMATRIX3F) &&
			!getType().equals(fieldObject.TYPE_SFMATRIX4F) && !getType().equals(fieldObject.TYPE_MFMATRIX4F))
		{
			String errorNotice = "Illegal type: cannot setValue(float[] " + newValue + ") when ]]></xsl:text>
								<xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}									
		if ((newValue.length % X3DConcreteField.getTupleSize(getType())) != 0) // tupleSize modulus check
		{
			String errorNotice = "illegal number of values (" + newValue.length + ")" +
				" in initialization string, must be multiple of " + X3DConcreteField.getTupleSize(getType());
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}			
		clearValues();
		if (newValue == null)
			return this;
		if (getType().equals(fieldObject.TYPE_SFTIME) || !getType().equals(fieldObject.TYPE_MFTIME))
		{
			setValue(new MFTimeObject(newValue));
		}
		else
		{
			valueArrayFloat = newValue;
		}
		return this;
	}
	/**
	 * Set typed value of a double </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.
	 * <i>WARNING</i>: must first <i>setType()</i> for the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double newValue)
	{
		if (!getType().equals(fieldObject.TYPE_SFDOUBLE)   && !getType().equals(fieldObject.TYPE_MFDOUBLE) &&
			!getType().equals(fieldObject.TYPE_SFTIME)     && !getType().equals(fieldObject.TYPE_MFTIME))
		{
			String errorNotice = "Illegal type: cannot setValue(double " + newValue + ") when ]]></xsl:text>
								<xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		clearValues();
		if (getType().equals(fieldObject.TYPE_SFTIME) || !getType().equals(fieldObject.TYPE_MFTIME))
		{
			
			setValue(new MFTimeObject(newValue));
		}
		else
		{
			valueArrayDouble = new double[1]; // fix array size
			valueArrayDouble[0] = newValue;
		}
		return this;
	}
	/**
	 * Set typed value of a double[] array </xsl:text><xsl:value-of select="$name"/><xsl:text disable-output-escaping="yes"><![CDATA[ declaration.
	 * <i>WARNING</i>: must first <i>setType()</i> for the proper corresponding X3D type.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$name"/><xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double[] newValue)
	{
		if (!getType().equals(fieldObject.TYPE_SFDOUBLE)   && !getType().equals(fieldObject.TYPE_MFDOUBLE) &&
			!getType().equals(fieldObject.TYPE_SFTIME)     && !getType().equals(fieldObject.TYPE_MFTIME) &&
			!getType().equals(fieldObject.TYPE_SFVEC2D)    && !getType().equals(fieldObject.TYPE_MFVEC2D) &&
			!getType().equals(fieldObject.TYPE_SFVEC3D)    && !getType().equals(fieldObject.TYPE_MFVEC3D) &&
			!getType().equals(fieldObject.TYPE_SFVEC4D)    && !getType().equals(fieldObject.TYPE_MFVEC4D) &&
			!getType().equals(fieldObject.TYPE_SFMATRIX3D) && !getType().equals(fieldObject.TYPE_MFMATRIX3D) &&
			!getType().equals(fieldObject.TYPE_SFMATRIX4D) && !getType().equals(fieldObject.TYPE_MFMATRIX4D))
		{
			String errorNotice = "Illegal type: cannot setValue(double[] " + newValue + ") when ]]></xsl:text>
								<xsl:value-of select="$name"/><xsl:text> type='" + getType() + "'";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice); // report error
		}
		if ((newValue.length % X3DConcreteField.getTupleSize(getType())) != 0) // tupleSize modulus check
		{
			String errorNotice = "illegal number of values (" + newValue.length + ")" +
				" in initialization string, must be multiple of " + X3DConcreteField.getTupleSize(getType());
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		clearValues();
		if (newValue == null)
			return this;
		valueArrayDouble = newValue;
		return this;
	}
</xsl:text>
						
					</xsl:if> <!-- end of field, fieldValue typed getValue methods -->
								<xsl:if test="(($name='IndexedFaceSet') or ($name='IndexedLineSet')) and not($isInterface = 'true')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/** 
	 * Utility method to get number of coordinate 3-tuple values in contained Coordinate/CoordinateDouble or ProtoInstance node 
	 * @see CoordinateObject
	 * @see CoordinateDoubleObject
	 * @see ProtoInstanceObject
	 * @return number of coordinate 3-tuple values
	 */
	public int getCoordCount()
	{
		if (getCoord() != null)
		{
			if      (getCoord() instanceof CoordinateObject)
				 return (((CoordinateObject      )getCoord()).getPoint().length / SFVec3fObject.TUPLE_SIZE);
			else if (getCoord() instanceof CoordinateDoubleObject)
				 return (((CoordinateDoubleObject)getCoord()).getPoint().length / SFVec3dObject.TUPLE_SIZE);
		}
		else if ((getCoordProtoInstance() != null) && getCoordProtoInstance().hasFieldValue())
		{
			for (fieldValueObject nextFieldValue : getCoordProtoInstance().getFieldValueList())
			{
				if      (nextFieldValue.getName().equals("point"))
					     return nextFieldValue.getValueMFVec3f().size();
				else if (nextFieldValue.getName().equals("point"))
					     return nextFieldValue.getValueMFVec3d().size();
			}
		}
		return 0; // otherwise
	}
	/** 
	 * Utility method to get number of 3-tuple Color RGB values (or 4-tuple ColorRGBA values) in contained Color/ColorRGBA or ProtoInstance node 
	 * @see ColorObject
	 * @see ColorRGBAObject
	 * @see ProtoInstanceObject
	 * @return number of color values
	 */
	public int getColorCount()
	{
		if (getColor() != null)
		{
			if      (getColor() instanceof ColorObject)
			         return (((ColorObject    )getColor()).getColor().length / SFColorObject.TUPLE_SIZE);
			else if (getColor() instanceof ColorRGBAObject)
				     return (((ColorRGBAObject)getColor()).getColor().length / SFColorRGBAObject.TUPLE_SIZE);
		}
		else if ((getColorProtoInstance() != null) && getColorProtoInstance().hasFieldValue())
		{
			for (fieldValueObject nextFieldValue : getColorProtoInstance().getFieldValueList())
			{
				if      (nextFieldValue.getName().equals("color"))
					     return nextFieldValue.getValueMFColor().size();
				else if (nextFieldValue.getName().equals("color"))
					     return nextFieldValue.getValueMFColorRGBA().size();
			}
		}
		return 0;
	}
]]></xsl:text>
								</xsl:if>
								<xsl:if test="($name='IndexedFaceSet') and not($isInterface = 'true')">
									<xsl:text disable-output-escaping="yes"><![CDATA[
	/** 
	 * Utility method to get number of 3-tuple normal vectors in contained Normal or ProtoInstance node
	 * @see NormalObject
	 * @see ProtoInstanceObject
	 * @return number of color values
	 */
	public int getNormalCount()
	{
		if (getNormal() != null)
		{
			return (((NormalObject)getNormal()).getVector().length / MFVec3fObject.TUPLE_SIZE);
		}
		else if ((getNormalProtoInstance() != null) && getColorProtoInstance().hasFieldValue())
		{
			for (fieldValueObject nextFieldValue : getColorProtoInstance().getFieldValueList())
			{
				if      (nextFieldValue.getName().equals("normal"))
					     return nextFieldValue.getValueMFVec3f().size();
			}
		}
		return 0;
	}
	/** 
	 * Utility method to get number of 2-tuple texture coordinate values in contained TextureCoordinate or ProtoInstance node
	 * @see TextureCoordinateObject
	 * @see ProtoInstanceObject
	 * @return number of color values
	 */
	public int getTexCoordCount()
	{
		if (getTexCoord() != null)
		{
			return (((TextureCoordinateObject)getTexCoord()).getPoint().length / SFVec2fObject.TUPLE_SIZE);
		}
		else if ((getTexCoordProtoInstance() != null) && getTexCoordProtoInstance().hasFieldValue())
		{
			for (fieldValueObject nextFieldValue : getTexCoordProtoInstance().getFieldValueList())
			{
				if      (nextFieldValue.getName().equals("texcoord"))
					     return nextFieldValue.getValueMFVec2f().size();
			}
		}
		return 0;
	}
]]></xsl:text>
								</xsl:if>

					<!-- TODO consider pass-through methods for ProtoDeclare that hand off to contained (or provided) ProtoInterface -->
					<!-- end Additional per-class utility methods -->
				</xsl:when>
				<xsl:when test="not($hasInterfaceBlock) and not($hasImplementationBlock)"><!-- and no fields present for this interface -->
					<!-- note definition error -->
					<xsl:message>
						<xsl:text>*** No fields, neither interfaceBlock or implementationBlock found</xsl:text>
					</xsl:message>
					<xsl:text>
	// No field interfaces defined in X3D Object Model
</xsl:text>
				</xsl:when>
			</xsl:choose>
					
			<!-- additional utility methods -->
			<xsl:if test="not($isInterface = 'true') and not($isUtilityClass = 'true') and
							(($name = 'CommentsBlock') or ($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or 
							 ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @return null, this method is deprecated and has no effect */
@Deprecated
@Override
public X3DMetadataObject getMetadata()
{
return null;
}

/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @param newValue ignored
 * @return unmodified object, this method is deprecated and has no effect */
@Deprecated
@Override
public ]]></xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:if test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
		<xsl:value-of select="$jsaiClassSuffix"/>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[	setMetadata(X3DMetadataObject newValue)
{
return this; // No action
}
]]></xsl:text>
<!--
<xsl:text disable-output-escaping="yes"><![CDATA[
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @return empty string, this method is deprecated and has no effect */
@Deprecated
public String getDEF()
{
return "";
}
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @return empty string, this method is deprecated and has no effect */
@Deprecated
public String getUSE()
{
return "";
}
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @return empty string, this method is deprecated and has no effect */
@Deprecated
public String getCssClass()
{
return "";
}
]]></xsl:text>
-->
<xsl:text disable-output-escaping="yes"><![CDATA[
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @param newValue ignored
 * @return unmodified object, this method is deprecated and has no effect */
@Deprecated
@Override
public ]]></xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:if test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
		<xsl:value-of select="$jsaiClassSuffix"/>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setDEF(String newValue)
{
return this; // no action
}
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @param newValue ignored
 * @return unmodified object, this method is deprecated and has no effect */
@Deprecated
@Override
public ]]></xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:if test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
		<xsl:value-of select="$jsaiClassSuffix"/>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setUSE(String newValue)
{
return this; // no action
}
@Deprecated
@Override
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, a stub method is necessary to implement X3DChildNode interface.
 * @param newValue ignored
 * @return unmodified object, this method is deprecated and has no effect */
public ]]></xsl:text>
	<xsl:value-of select="$name"/>
	<xsl:if test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or ($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare')">
		<xsl:value-of select="$jsaiClassSuffix"/>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[ setCssClass(String newValue)
{
return this; // no action
}
]]></xsl:text>
			</xsl:if>
			<xsl:if test="($name = 'CommentsBlock')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, it is only provided since a stub method is necessary to implement X3DChildNode interface.
 * @param fieldName ignored
 * @return empty string, this method is deprecated and has no effect */
@Deprecated
@Override
public String getFieldType(String fieldName)
{
    return "";
}
/** DO NOT USE: operation ignored since no such field exists for this element. This method has no effect, it is only provided since a stub method is necessary to implement X3DChildNode interface.
 * @param fieldName ignored
 * @return empty string, this method is deprecated and has no effect */
@Deprecated
@Override
public String getAccessType(String fieldName)
{
    return "";
}
]]></xsl:text>
			</xsl:if>

			<!-- finished source file definition -->
			<xsl:if test="($wrapClassBrackets)">
				<xsl:text>}</xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
				
			<!-- debug 
<xsl:message>
	<xsl:text>*** wrapClassBrackets close: $wrapClassBrackets=</xsl:text>
	<xsl:value-of select="$wrapClassBrackets"/>
</xsl:message>
-->	

		</xsl:result-document> <!-- save file -->
	</xsl:template><!-- sourceFile -->

    <!-- ===================================================== -->
    <!-- ===================================================== -->
    <!-- ===================================================== -->
    
    <!-- create fixed (unchanging) files -->
	
	<xsl:template name="FieldDefinitions">
		
		<xsl:variable name="subPackage">
			<xsl:choose>
				<xsl:when test="($modifySpecificationInterfaces = 'true')">
					<xsl:text>fields</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<!-- otherwise Java SAI specification has no subPackage for the interfaces, they go in the root package - very unusual. -->
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
	
		<!-- TODO specification: fix prose regarding X3DField, seems incorrect. -->
		<!-- TODO specification: change constant values to final, add toString method. -->
		<!-- TODO specification: add data types following MFString (officially approved version dates back to v3.0). -->
		<!-- Note that X3DFieldTypes an interface but it is not implemented by anything else. -->
		
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DFieldTypes</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Set of constants corresponding to each X3D field type and accessType.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>5.3 Field types</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>fieldsDef.html#FieldTypes</xsl:text></xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Enumeration constant <i>INPUT_ONLY</i> has value <i>1</i>. */
	public final int INPUT_ONLY = 1;
	/** Enumeration constant <i>INITIALIZE_ONLY</i> has value <i>2</i>. */
	public final int INITIALIZE_ONLY = 2;
	/** Enumeration constant <i>INPUT_OUTPUT</i> has value <i>3</i>. */
	public final int INPUT_OUTPUT = 3;
	/** Enumeration constant <i>OUTPUT_ONLY</i> has value <i>4</i>. */
	public final int OUTPUT_ONLY = 4;

	/** Enumeration constant <i>SFBOOL</i> has value <i>1</i>. */
	public final int SFBOOL = 1;
	/** Enumeration constant <i>MFBOOL</i> has value <i>2</i>. */
	public final int MFBOOL = 2;
	/** Enumeration constant <i>SFINT32</i> has value <i>3</i>. */
	public final int SFINT32 = 3;
	/** Enumeration constant <i>MFINT32</i> has value <i>4</i>. */
	public final int MFINT32 = 4;
	/** Enumeration constant <i>SFFLOAT</i> has value <i>5</i>. */
	public final int SFFLOAT = 5;
	/** Enumeration constant <i>MFFLOAT</i> has value <i>6</i>. */
	public final int MFFLOAT = 6;
	/** Enumeration constant <i>SFDOUBLE</i> has value <i>7</i>. */
	public final int SFDOUBLE = 7;
	/** Enumeration constant <i>MFDOUBLE</i> has value <i>8</i>. */
	public final int MFDOUBLE = 8;
	/** Enumeration constant <i>SFTIME</i> has value <i>9</i>. */
	public final int SFTIME = 9;
	/** Enumeration constant <i>MFTIME</i> has value <i>10</i>. */
	public final int MFTIME = 10;
	/** Enumeration constant <i>SFNODE</i> has value <i>11</i>. */
	public final int SFNODE = 11;
	/** Enumeration constant <i>MFNODE</i> has value <i>12</i>. */
	public final int MFNODE = 12;
	/** Enumeration constant <i>SFVEC2F</i> has value <i>13</i>. */
	public final int SFVEC2F = 13;
	/** Enumeration constant <i>MFVEC2F</i> has value <i>14</i>. */
	public final int MFVEC2F = 14;
	/** Enumeration constant <i>SFVEC3F</i> has value <i>15</i>. */
	public final int SFVEC3F = 15;
	/** Enumeration constant <i>MFVEC3F</i> has value <i>16</i>. */
	public final int MFVEC3F = 16;
	/** Enumeration constant <i>SFVEC3D</i> has value <i>17</i>. */
	public final int SFVEC3D = 17;
	/** Enumeration constant <i>MFVEC3D</i> has value <i>18</i>. */
	public final int MFVEC3D = 18;
	/** Enumeration constant <i>SFROTATION</i> has value <i>19</i>. */
	public final int SFROTATION = 19;
	/** Enumeration constant <i>MFROTATION</i> has value <i>20</i>. */
	public final int MFROTATION = 20;
	/** Enumeration constant <i>SFCOLOR</i> has value <i>21</i>. */
	public final int SFCOLOR = 21;
	/** Enumeration constant <i>MFCOLOR</i> has value <i>22</i>. */
	public final int MFCOLOR = 22;
	/** Enumeration constant <i>SFCOLORRGBA</i> has value <i>23</i>. */
	public final int SFCOLORRGBA = 23;
	/** Enumeration constant <i>MFCOLORRGBA</i> has value <i>24</i>. */
	public final int MFCOLORRGBA = 24;
	/** Enumeration constant <i>SFIMAGE</i> has value <i>25</i>. */
	public final int SFIMAGE = 25;
	/** Enumeration constant <i>MFIMAGE</i> has value <i>26</i>. */
	public final int MFIMAGE = 26;
	/** Enumeration constant <i>SFSTRING</i> has value <i>27</i>. */
	public final int SFSTRING = 27;
	/** Enumeration constant <i>MFSTRING</i> has value <i>28</i>. */
	public final int MFSTRING = 28;
	
	// added in v3.3
	/** Enumeration constant <i>SFVEC2D</i> has value <i>29</i>. */
	public final int SFVEC2D = 29;
	/** Enumeration constant <i>MFVEC2D</i> has value <i>30</i>. */
	public final int MFVEC2D = 30;
	/** Enumeration constant <i>SFVEC4F</i> has value <i>31</i>. */
	public final int SFVEC4F = 31;
	/** Enumeration constant <i>MFVEC4F</i> has value <i>32</i>. */
	public final int MFVEC4F = 32;
	/** Enumeration constant <i>SFVEC4D</i> has value <i>33</i>. */
	public final int SFVEC4D = 33;
	/** Enumeration constant <i>MFVEC4D</i> has value <i>34</i>. */
	public final int MFVEC4D = 34;
	/** Enumeration constant <i>SFMATRIX3F</i> has value <i>35</i>. */
	public final int SFMATRIX3F = 35;
	/** Enumeration constant <i>MFMATRIX3F</i> has value <i>36</i>. */
	public final int MFMATRIX3F = 36;
	/** Enumeration constant <i>SFMATRIX3D</i> has value <i>37</i>. */
	public final int SFMATRIX3D = 37;
	/** Enumeration constant <i>MFMATRIX3D</i> has value <i>38</i>. */
	public final int MFMATRIX3D = 38;
	/** Enumeration constant <i>SFMATRIX4F</i> has value <i>39</i>. */
	public final int SFMATRIX4F = 39;
	/** Enumeration constant <i>MFMATRIX4F</i> has value <i>40</i>. */
	public final int MFMATRIX4F = 40;
	/** Enumeration constant <i>SFMATRIX4D</i> has value <i>41</i>. */
	public final int SFMATRIX4D = 41;
	/** Enumeration constant <i>MFMATRIX4D</i> has value <i>42</i>. */
	public final int MFMATRIX4D = 42;
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>
	
		<!-- ===================================================== -->

		<!-- TODO specification Table 5.1 Topics index, _B_ should be _BROWSER_: 5.4.3 SAI_B_ConnectionError 5.4.4 SAI_B_Initialized 5.4.5 SAI_B_Shutdown 5.4.6 SAI_B_URLError -->
		<!-- ToDO B.4.2 X3DFieldEvent is incorrectly listed as class, but is actually interface --> 
		<!-- TODO specification B.5.3 X3DFieldEvent is a duplicate and should be removed. -->
		<!-- TODO specification interface missing void. -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DFieldEvent</xsl:text></xsl:with-param>
			<!-- Note that X3DFieldEvent is listed in specification as a class, but it gets generated alongside other SAI interfaces (not .jsail concretes) -->
			<xsl:with-param name="isAbstract"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>java.util.EventObject</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>The event type is implemented as the class X3DFieldEvent. This class contains methods for obtaining the source of the event, the time (in X3D time) and any user defined data that occurred with the event.</xsl:text></xsl:with-param>
			<!-- saiJavaSpecificationSection also has reference at 5.4.7 SAIFieldEvent -->
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.2 X3DFieldEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#EventTypesSAIFieldEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.4.2 SAIFieldEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text> @author Justin Couch
</xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[javadocBlock
	// unused
	/**
	 * Get the timestamp that this event occurred at.
	 * @return The time of this event, in X3D time coordinates.
	 */
	public double getTime();

	/**
	 * Construct a new X3DFieldEvent instance.
	 *
	 * @param sourceField The source field that generated this event
	 * @param newTimeStamp The timestamp of the event, in X3D time
	 * @param neweventDataObject Any user associated data with this event
	 */
	public X3DFieldEvent(Object sourceField, double newTimeStamp, Object neweventDataObject);

	/**
	 * Get data with this event.
	 * @return eventDataObject
	 */
	public Object getData();
]]></xsl:text>
			</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[
		/** The time stamp, in X3D time, that this event occurred at */
		protected double timeStamp;

		/** Passed field data for this event */
		protected Object eventDataObject;

		/**
		 * Construct a new X3DFieldEvent instance.
		 *
		 * @param sourceField The source field that generated this event
		 * @param newTimeStamp The timestamp of the event, in X3D time
		 * @param neweventDataObject Any user associated data with this event
		 */
		public X3DFieldEvent(Object sourceField, double newTimeStamp, Object neweventDataObject)
		{
			super(sourceField);

			timeStamp = newTimeStamp;
			eventDataObject = neweventDataObject;
		}

		/**
		 * Get the timestamp that this event occurred at.
		 * @return The time of this event, in X3D time coordinates.
		 */
		public double getTime() 
		{
			return timeStamp;
		}

		/**
		 * Get data with this event.
		 * @return eventDataObject
		 */
		public Object getData()
		{
			return eventDataObject;
		}
	]]></xsl:text>
				</xsl:with-param>
		</xsl:call-template>
	
		<!-- ===================================================== -->
	
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>java.util.EventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Listener for events passing values from one X3D field to another.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.3 X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>6.3.20 registerBrowserInterest</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>servRef.html#RegisterBrowserInterest</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[
	public void readableFieldChanged(X3DFieldEvent event);
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>
	
		<!-- ===================================================== -->
	
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Representation of a node's field definition.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.4 X3DFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#X3DFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>6.3.10 SAIFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>types.html#SAIFieldDefinition</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
<p>
The field definition holds the static field information such as the field
access type, the data type and the name of the field.
</p>
<p>
The implementation of the toString() method of this class shall return the
full IDL declaration of the field as per the specification, not the UTF8 or
XML format. Implementation of <code>.equals()</code> shall return true if
the two field definitions share the same access type, data type and name. It
shall not include the underlying field's values at that point in time.
</p>

@author Justin Couch
</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
    /**
     * Get the name of this field. This will be something like "children"
     * or "translation". If the field is an exposed field then the name
     * give will be the base name without any <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>set_<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text> or <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>_changed<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
     * added to the name, regardless of how the initial field was fetched.
     *
     * @return The name of this field
     */
	public String getName();

    /**
     * Get the access type of the field. This will be one of field,
     * exposedField, eventIn or eventOut constants described in the
     * X3DFieldTypes interface.
     *
     * @return The access type of this node
     * @see X3DFieldTypes
     */
	public int getAccessType();

    /**
     * Get the field type. This string represents the field type such as
     * MFNode, SFInt32. The definition of the returned int value is
     * described in the X3DFieldType interface.
     *
     * @return A constant describing the field type
     * @see X3DFieldTypes
     */
	public int getFieldType();

    /**
     * Get the field type. This string represents the field type such as
     * MFNode, SFInt32, etc. A string is used to allow full extensibility.
     *
     * @return A string describing the field type
     */
	public String getFieldTypeString();
</xsl:with-param>
		</xsl:call-template>
	
		<!-- ===================================================== -->
	
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DField</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Base representation of an X3D field type.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.5 X3DField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#X3DField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.13 SAIField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIField</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>4.4.2.2 Field semantics</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>concepts.html#FieldSemantics</xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock">
    /**
     * Get the definition of this field.
     *
     * @return The field definition to use
     */
    X3DFieldDefinition getDefinition();

    /**
     * Check to see if this field is readable. This may return two different
     * sets of values depending on the use. If this field is the field of a
     * script that has been passed to a script implementation, it will return
     * true if the field is an eventIn, exposedField or field and false for an
     * eventOut. If it is a field of any other circumstance (ie an external
     * application querying a node or a script querying another node it has a
     * reference to) it shall return true for eventOuts, exposedFields and
     * false for eventIn or field.
     *
     * @return true if the values of this field are readable
     */
    boolean isReadable();

    /**
     * Check to see if this field is writable. This may return two different
     * sets of values depending on the use. If this field is the field of a
     * script that has been passed to a script implementation, it will return
     * true if the field is an eventOut, exposedField or field and false for an
     * eventIn. If it is a field of any other circumstance (ie an external
     * application querying a node or a script querying another node it has a
     * reference to) it shall return true for eventIns, exposedFields and
     * false for eventOut or field.
     *
     * @return true if the values of this field are readable
     */
    boolean isWritable();

    /**
     * <p>
     * Add a listener for changes in this field. This works for listening to
     * changes in a readable field. A future extension to the specification,
     * or a browser-specific extension, may allow for listeners to be added
     * to writable nodes as well.
     * </p>
     * <p>
     * A listener instance cannot have multiple simultaneous registrations.
     * If the listener instance is currently registered, this request shall
     * be silently ignored.
     * </p>
     *
     * @param listener The listener to add
     */
    void addX3DEventListener(X3DFieldEventListener listener);

    /**
     * Remove a listener for changes in the readable field. If the listener is
     * not currently registered, this request shall be silently ignored.
     *
     * @param listener The listener to remove
     */
    void removeX3DEventListener(X3DFieldEventListener listener);

</xsl:with-param>
<!-- TODO specification: these methods are never defined in specification other than the interface listing. Omitted.
    /**
     * Associate user data with this field. Whenever an field is generated
     * on this field, this data will be available with the Event through
     * its getData method.
     *
     * @param data The data to associate with this eventOut instance
     */
    void setUserData(Object data);

    /**
     * Get the user data that is associated with this field.
     *
     * @return The user data, if any, associated with this field
     */
    Object getUserData();
-->
		</xsl:call-template>
	
		<!-- ===================================================== -->
	
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>MField</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DField</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Base interface for multiple-field (MF) array types.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.6 MField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#MField</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text>
    /**
     * Get the size of the underlying data array. The size is the number of
     * elements for that data type. So for an MFFloat the size would be the
     * number of float values, but for an MFVec3f, it is the number of vectors
     * in the returned array (where a vector is 3 consecutive array indexes in
     * a flat array).
     *
     * @return The number of elements in this field array.
     */
	public int size();

    /**
     * Removes all values in the field array, changing the array size to zero.
     */
	public void clear();

    /**
     * Remove one element of the field array at index position, if found.  Initial element is at index 0.
     * @param index position of element in field array that gets removed
     */
	public void remove(int index);
</xsl:text></xsl:with-param>
		</xsl:call-template>
		
		<!-- ===================================================== -->
			
		<!-- TODO specification needs to be interface, not class -->
		<!-- TODO specification accessor methods missing trailing semicolons, should not have bodies -->
		<!-- TODO decide on best implementation and then add it -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>Matrix3</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Describes a 3x3 Matrix as required by the SAIMatrix abstract type.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.4 Matrix3</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#Matrix3</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.20 SAIMatrix</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIMatrix</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text><![CDATA[
@author Justin Couch
]]></xsl:text>
			</xsl:with-param>
			<!-- TODO: remove constructor definition from specification interface: public Matrix3(); -->
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
				
	public void setIdentity();
				
	public void set(int row, int column);

	public float get(int row, int column);

//	public void setTransform(SFVec3f translation, // TODO incompatible with double types
//		SFRotation rotation,
//		SFVec3f scale,
//		SFRotation scaleOrientation,
//		SFVec3f center);

//	public void getTransform(SFVec3f translation, // TODO incompatible with double types
//		SFRotation rotation,
//		SFVec3f scale);

	public Matrix3 inverse();

	public Matrix3 transpose();

	public Matrix3 multiplyLeft(Matrix3 matrix3x3);

	public Matrix3 multiplyRight(Matrix3 matrix3x3);

//	public Matrix3 multiplyRowVector(SFVec3f vec3f); // TODO incompatible with double types

//	public Matrix3 multiplyColVector(SFVec3f vec3f); // TODO incompatible with double types
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>
		
		<!-- ===================================================== -->
			
		<!-- TODO specification accessor methods missing trailing semicolons -->
		<!-- TODO decide on best implementation and then add it -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>Matrix4</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Describes a 4x4 Matrix as required by the SAIMatrix abstract type.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.5 Matrix4</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#Matrix4</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.20 SAIMatrix</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIMatrix</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /* TODO: remove constructor definition from interface specification
	public Matrix4();
     */

	public void setIdentity();

	public void set(int row, int column);

	public float get(int row, int column);

//	public void setTransform(SFVec3f translation, // TODO incompatible with double types
//		SFRotation rotation,
//		SFVec3f scale,
//		SFRotation scaleOrientation,
//		SFVec3f center);

//	public void getTransform(SFVec3f translation, // TODO incompatible with double types
//		SFRotation rotation,
//		SFVec3f scale);

	public Matrix4 inverse();

	public Matrix4 transpose();

	public Matrix4 multiplyLeft(Matrix4 matrix4x4);

	public Matrix4 multiplyRight(Matrix4 matrix4x4);

//	public Matrix3 multiplyColVector(SFVec3f vec3f); // TODO SFVec4f ?  // TODO incompatible with double types

//	public Matrix3 multiplyColVector(SFVec3f vec3f); // TODO SFVec4f ?  // TODO incompatible with double types
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- now concrete classes for field types-->
		
		<!-- loop over fields to find further imports -->
		<xsl:for-each select="//FieldTypes/FieldType">
			
			<xsl:variable name="fieldName" select="@type"/>
			
			<xsl:variable name="javaType">
				<xsl:call-template name="javaType">
					<xsl:with-param name="x3dType" select="@type"/>
					<!-- isInterface true returns Java base types (e.g. float[] for SFColor, etc. -->
					<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="isSingletonType">
				<xsl:value-of select="(@type = 'MFBool')   or (@type = 'MFInt32') or (@type = 'MFDouble') or (@type = 'MFFloat') or 
                                      (@type = 'MFString') or (@type = 'MFTime')  or (@type = 'MFNode') or
                                       starts-with(@type,'SF')"/>
			</xsl:variable>
			<xsl:variable name="tupleSize">
				<xsl:call-template name="tupleSize">
					<xsl:with-param name="x3dType" select="@type"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="javaPrimitiveType">
				<xsl:choose>
					<xsl:when test="($isSingletonType = 'true')">
						<xsl:value-of select="substring-before($javaType,'[')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$javaType"/><!-- array of array type -->
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="dimensionSuffix">
				<xsl:choose>
					<xsl:when test="false() and ($javaType = $javaPrimitiveType)">
						<xsl:text>.size()</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>.length</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="implements">
				<xsl:choose>
					<xsl:when test="contains($fieldName,'Matrix3')">
						<xsl:text> extends Matrix3</xsl:text>
					</xsl:when>
					<xsl:when test="contains($fieldName,'Matrix4')">
						<xsl:text> extends Matrix4</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="imports">
				<xsl:text>import org.web3d.x3d.jsail.*;</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text>import org.web3d.x3d.jsail.Core.*;</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:if test="starts-with($fieldName, 'field')">
					<xsl:text>import org.web3d.x3d.jsail.fields.*;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:if test="($fieldName = 'MFString')">
					<xsl:text>import java.util.ArrayList;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:if test="starts-with($fieldName,'MF') or ($fieldName = 'SFImage')">
					<xsl:text>import java.util.Arrays;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:choose>
					<xsl:when test="contains($fieldName,'FImage')">
						<xsl:text>import org.web3d.x3d.sai.InvalidFieldValueException;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>import java.awt.image.RenderedImage;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>import java.awt.image.WritableRenderedImage;</xsl:text>
					</xsl:when>
					<xsl:when test="contains($fieldName,'FMatrix')">
						<xsl:text>import org.web3d.x3d.sai.*;</xsl:text>
						<xsl:text>&#10;</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>import org.web3d.x3d.sai.InvalidFieldValueException;</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="javadocBlock">
				<xsl:value-of select="InterfaceDefinition/@appinfo"/>
				<xsl:text>&#10;</xsl:text>
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[ * Related field object: {@link ]]></xsl:text>
				<xsl:choose>
					<xsl:when test="starts-with($fieldName,'SF')">
						<xsl:text>MF</xsl:text>
						<xsl:value-of select="substring-after($fieldName,'SF')"/>
						<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>SF</xsl:text>
						<xsl:value-of select="substring-after($fieldName,'MF')"/>
						<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					</xsl:otherwise>
				</xsl:choose>
				<xsl:text>}</xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[ * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[">X3D Tooltips: type ]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[</a>]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:variable>
<xsl:variable name="newValueNullExceptionCheck">
	<xsl:text>		if (</xsl:text>
	<xsl:value-of select="$newValue"/>
	<xsl:text> == null)</xsl:text>
	<xsl:text>&#10;</xsl:text>
	<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
	<xsl:text>("</xsl:text>
	<xsl:value-of select="@name"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> </xsl:text>
	<xsl:value-of select="$newValue"/>
	<xsl:text> is null and cannot be set"); // fieldTest</xsl:text>
	<xsl:text>&#10;</xsl:text>
</xsl:variable>
<xsl:variable name="newValueNullReturnVoid">
	<!-- TODO avoid null-value checks by replacing with empty values instead, where possible -->
	<xsl:text>		if (</xsl:text>
	<xsl:value-of select="$newValue"/>
	<xsl:text> == null) return; // newValueNullReturnVoid2</xsl:text>
	<xsl:text>&#10;</xsl:text>
</xsl:variable>

<!-- debug
<xsl:if test="($debug = 'true')">
<xsl:message>
<xsl:text>// field ($fieldName=</xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:text>, $javaType=</xsl:text>
<xsl:value-of select="$javaType"/>
<xsl:text>, $isSingletonType=</xsl:text>
<xsl:value-of select="$isSingletonType"/>
<xsl:text>, tupleSize=</xsl:text>
<xsl:value-of select="$tupleSize"/>
<xsl:text>, $javaPrimitiveType=</xsl:text>
<xsl:value-of select="$javaPrimitiveType"/>
<xsl:text>, $dimensionSuffix=</xsl:text>
<xsl:value-of select="$dimensionSuffix"/>
<xsl:text>)</xsl:text>
</xsl:message>
</xsl:if> -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:value-of select="$imports"/></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text>X3DConcreteField</xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.</xsl:text><xsl:value-of select="$fieldName"/></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
				<xsl:with-param name="description">
					<xsl:text>This utility class provides a concrete implementation corresponding to </xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> X3D field type.</xsl:text>
				</xsl:with-param>
				<!-- TODO update -->
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="substring-after(InterfaceDefinition/@specificationUrl,'#')"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock" disable-output-escaping="yes"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="implementationBlock">
				
				<xsl:variable name="newValueSizeCheck">
					<xsl:text disable-output-escaping="yes"><![CDATA[	if (size < 0)]]></xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>		throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
					<xsl:text>("requested setValue() array-copy size=" + size + </xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>			" is negative"); // newValueSizeCheck</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>	if (size > </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>.length)</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>		throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
					<xsl:text>("requested setValue() array-copy size=" + size + </xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>			" is greater than </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>.length()=" + </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>.length); // newValueSizeCheck</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:variable>
				
				<xsl:variable name="defaultValueExpression">
					<xsl:choose>
						<xsl:when test="contains($javaType,'[') or ($javaType = 'MFNode')">
							<xsl:text>java.util.Arrays.copyOf(DEFAULT_VALUE, DEFAULT_VALUE.length); // must be separate copy</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text>DEFAULT_VALUE;</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
					
				<!-- FieldType default values -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>NAME</i> provides name of this element: <i>]]></xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[</i> */
	public static final String NAME = "]]></xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>";

	/** Default value for this field type</xsl:text>
				<xsl:choose>
					<xsl:when test="starts-with($fieldName, 'MF')">
						<xsl:text> is an empty array</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFNode')">
						<xsl:text> is a null node</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFBool')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ is a <i>true</i> value]]></xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFRotation')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ is a <i>0 0 1 0</i> identity-rotation value]]></xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFString')">
						<xsl:text> is an empty String</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFTime')">
						<xsl:text disable-output-escaping="yes"><![CDATA[ is a <i>-1</i> value]]></xsl:text>
					</xsl:when>
					<xsl:when test="not(contains($fieldName, 'Vec')) and not(contains($fieldName, 'Matrix'))">
						<xsl:text disable-output-escaping="yes"><![CDATA[ is a <i>0</i> value]]></xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text disable-output-escaping="yes"><![CDATA[ contains values of <i>0</i>]]></xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:text>.</xsl:text>
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank">Java Tutorials: Primitive Data Types</a>
     */]]></xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:choose>
					<xsl:when test="($fieldName = 'SFBool')">
						<xsl:text>	public static final boolean DEFAULT_VALUE = true;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFInt32')">
						<xsl:text>	public static final int DEFAULT_VALUE = 0;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFFloat')">
						<xsl:text>	public static final float DEFAULT_VALUE = 0.0f;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFDouble')">
						<xsl:text>	public static final double DEFAULT_VALUE = 0.0;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFString')">
						<xsl:text>	public static final String DEFAULT_VALUE = "";</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFTime')">
						<xsl:text>	public static final double DEFAULT_VALUE = -1.0;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec2d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {0.0, 0.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec2f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec3d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {0.0, 0.0, 0.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec3f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFColor')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFColorRGBA')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec4d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {0.0, 0.0, 0.0, 1.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFVec4f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 0.0f, 1.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFRotation')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {0.0f, 0.0f, 1.0f, 0.0f};</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>	/** Preferred default value for this field type, oriented for rotation about Y axis. */</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>	public static final float[] PREFERRED_DEFAULT_VALUE = {0.0f, 1.0f, 0.0f, 0.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFImage')">
						<xsl:text>	public static final int[] DEFAULT_VALUE = {0, 0, 0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFMatrix3d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFMatrix3f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFMatrix4d')">
						<xsl:text>	public static final double[] DEFAULT_VALUE = {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFMatrix4f')">
						<xsl:text>	public static final float[] DEFAULT_VALUE = {1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f};</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'SFNode')">
						<xsl:text>	</xsl:text><!-- tab -->
						<xsl:text>public static final X3DNode </xsl:text>
						<xsl:text>DEFAULT_VALUE</xsl:text>
						<xsl:text> = </xsl:text>
						<xsl:text>null;</xsl:text>
					</xsl:when>
					<xsl:when test="($fieldName = 'MFNode')">
						<xsl:text>	</xsl:text><!-- tab -->
						<xsl:text>public static final X3DNode[] </xsl:text>
						<xsl:text>DEFAULT_VALUE</xsl:text>
						<xsl:text> = </xsl:text>
						<xsl:text>new X3DNode[0]; // initialize as empty array</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName,'MF')">
						<xsl:text>	public static final </xsl:text>
						<xsl:value-of select="$javaType"/>
						<xsl:text> </xsl:text>
						<xsl:text>DEFAULT_VALUE = new </xsl:text>
						<xsl:value-of select="substring-before($javaType, '[]')"/>
						<xsl:text>[0]; // initialize as empty array</xsl:text>
					</xsl:when>
				</xsl:choose>
				<xsl:text>&#10;</xsl:text>
				
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/** Default tuple size for this field type is <i>]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[</i> (i.e. number of component values making up a single-field SF object). */
	public static final int TUPLE_SIZE = ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text>;</xsl:text>
				<xsl:text>&#10;</xsl:text>
				
				<!-- Convenience contants -->
				<xsl:choose>
					<xsl:when test="($fieldName = 'SFBool')">
						<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant for boolean value <em>true</em>, note lower-case value is XML syntax (upper-case value is VRML syntax) */
	public static String TRUE  = "true";
	/** String constant for boolean value <em>false</em>, note lower-case value is XML syntax (upper-case value is VRML syntax) */
	public static String FALSE = "false";
]]></xsl:text>
					</xsl:when>
					<!-- SFColor convenience contants -->
					<xsl:when test="($fieldName = 'SFColor')">
						<!-- TODO add lower-case bookmarks -->
						<xsl:text disable-output-escaping="yes"><![CDATA[
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ALICEBLUE = toFloatArray(0xf0f8ff); // decimal 240,248,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ANTIQUEWHITE = toFloatArray(0xfaebd7); // decimal 250,235,215
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] AQUA = toFloatArray(0x00ffff); // decimal 0,255,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] AQUAMARINE = toFloatArray(0x7fffd4); // decimal 127,255,212
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] AZURE = toFloatArray(0xf0ffff); // decimal 240,255,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BEIGE = toFloatArray(0xf5f5dc); // decimal 245,245,220
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BISQUE = toFloatArray(0xffe4c4); // decimal 255,228,196
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BLACK = toFloatArray(0x000000); // decimal 0,0,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BLANCHEDALMOND = toFloatArray(0xffebcd); // decimal 255,235,205
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BLUE = toFloatArray(0x0000ff); // decimal 0,0,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BLUEVIOLET = toFloatArray(0x8a2be2); // decimal 138,43,226
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BROWN = toFloatArray(0xa52a2a); // decimal 165,42,42
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] BURLYWOOD = toFloatArray(0xdeb887); // decimal 222,184,135
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CADETBLUE = toFloatArray(0x5f9ea0); // decimal 95,158,160
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CHARTREUSE = toFloatArray(0x7fff00); // decimal 127,255,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CHOCOLATE = toFloatArray(0xd2691e); // decimal 210,105,30
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CORAL = toFloatArray(0xff7f50); // decimal 255,127,80
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CORNFLOWERBLUE = toFloatArray(0x6495ed); // decimal 100,149,237
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CORNSILK = toFloatArray(0xfff8dc); // decimal 255,248,220
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CRIMSON = toFloatArray(0xdc143c); // decimal 220,20,60
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] CYAN = toFloatArray(0x00ffff); // decimal 0,255,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKBLUE = toFloatArray(0x00008b); // decimal 0,0,139
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKCYAN = toFloatArray(0x008b8b); // decimal 0,139,139
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKGOLDENROD = toFloatArray(0xb8860b); // decimal 184,134,11
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKGRAY = toFloatArray(0xa9a9a9); // decimal 169,169,169
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKGREEN = toFloatArray(0x006400); // decimal 0,100,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKGREY = toFloatArray(0xa9a9a9); // decimal 169,169,169
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKKHAKI = toFloatArray(0xbdb76b); // decimal 189,183,107
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKMAGENTA = toFloatArray(0x8b008b); // decimal 139,0,139
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKOLIVEGREEN = toFloatArray(0x556b2f); // decimal 85,107,47
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKORANGE = toFloatArray(0xff8c00); // decimal 255,140,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKORCHID = toFloatArray(0x9932cc); // decimal 153,50,204
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKRED = toFloatArray(0x8b0000); // decimal 139,0,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSALMON = toFloatArray(0xe9967a); // decimal 233,150,122
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSEAGREEN = toFloatArray(0x8fbc8f); // decimal 143,188,143
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSLATEBLUE = toFloatArray(0x483d8b); // decimal 72,61,139
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSLATEGRAY = toFloatArray(0x2f4f4f); // decimal 47,79,79
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKSLATEGREY = toFloatArray(0x2f4f4f); // decimal 47,79,79
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKTURQUOISE = toFloatArray(0x00ced1); // decimal 0,206,209
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DARKVIOLET = toFloatArray(0x9400d3); // decimal 148,0,211
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DEEPPINK = toFloatArray(0xff1493); // decimal 255,20,147
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DEEPSKYBLUE = toFloatArray(0x00bfff); // decimal 0,191,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DIMGRAY = toFloatArray(0x696969); // decimal 105,105,105
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DIMGREY = toFloatArray(0x696969); // decimal 105,105,105
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] DODGERBLUE = toFloatArray(0x1e90ff); // decimal 30,144,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] FIREBRICK = toFloatArray(0xb22222); // decimal 178,34,34
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] FLORALWHITE = toFloatArray(0xfffaf0); // decimal 255,250,240
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] FORESTGREEN = toFloatArray(0x228b22); // decimal 34,139,34
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] FUCHSIA = toFloatArray(0xff00ff); // decimal 255,0,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GAINSBORO = toFloatArray(0xdcdcdc); // decimal 220,220,220
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GHOSTWHITE = toFloatArray(0xf8f8ff); // decimal 248,248,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GOLD = toFloatArray(0xffd700); // decimal 255,215,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GOLDENROD = toFloatArray(0xdaa520); // decimal 218,165,32
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GRAY = toFloatArray(0x808080); // decimal 128,128,128
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GREEN = toFloatArray(0x008000); // decimal 0,128,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GREENYELLOW = toFloatArray(0xadff2f); // decimal 173,255,47
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] GREY = toFloatArray(0x808080); // decimal 128,128,128
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] HONEYDEW = toFloatArray(0xf0fff0); // decimal 240,255,240
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] HOTPINK = toFloatArray(0xff69b4); // decimal 255,105,180
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] INDIANRED = toFloatArray(0xcd5c5c); // decimal 205,92,92
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] INDIGO = toFloatArray(0x4b0082); // decimal 75,0,130
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] IVORY = toFloatArray(0xfffff0); // decimal 255,255,240
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] KHAKI = toFloatArray(0xf0e68c); // decimal 240,230,140
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LAVENDER = toFloatArray(0xe6e6fa); // decimal 230,230,250
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LAVENDERBLUSH = toFloatArray(0xfff0f5); // decimal 255,240,245
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LAWNGREEN = toFloatArray(0x7cfc00); // decimal 124,252,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LEMONCHIFFON = toFloatArray(0xfffacd); // decimal 255,250,205
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTBLUE = toFloatArray(0xadd8e6); // decimal 173,216,230
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTCORAL = toFloatArray(0xf08080); // decimal 240,128,128
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTCYAN = toFloatArray(0xe0ffff); // decimal 224,255,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTGOLDENRODYELLOW = toFloatArray(0xfafad2); // decimal 250,250,210
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTGRAY = toFloatArray(0xd3d3d3); // decimal 211,211,211
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTGREEN = toFloatArray(0x90ee90); // decimal 144,238,144
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTGREY = toFloatArray(0xd3d3d3); // decimal 211,211,211
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTPINK = toFloatArray(0xffb6c1); // decimal 255,182,193
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSALMON = toFloatArray(0xffa07a); // decimal 255,160,122
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSEAGREEN = toFloatArray(0x20b2aa); // decimal 32,178,170
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSKYBLUE = toFloatArray(0x87cefa); // decimal 135,206,250
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSLATEGRAY = toFloatArray(0x778899); // decimal 119,136,153
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSLATEGREY = toFloatArray(0x778899); // decimal 119,136,153
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTSTEELBLUE = toFloatArray(0xb0c4de); // decimal 176,196,222
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIGHTYELLOW = toFloatArray(0xffffe0); // decimal 255,255,224
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIME = toFloatArray(0x00ff00); // decimal 0,255,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LIMEGREEN = toFloatArray(0x32cd32); // decimal 50,205,50
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] LINEN = toFloatArray(0xfaf0e6); // decimal 250,240,230
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MAGENTA = toFloatArray(0xff00ff); // decimal 255,0,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MAROON = toFloatArray(0x800000); // decimal 128,0,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMAQUAMARINE = toFloatArray(0x66cdaa); // decimal 102,205,170
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMBLUE = toFloatArray(0x0000cd); // decimal 0,0,205
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMORCHID = toFloatArray(0xba55d3); // decimal 186,85,211
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMPURPLE = toFloatArray(0x9370db); // decimal 147,112,219
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMSEAGREEN = toFloatArray(0x3cb371); // decimal 60,179,113
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMSLATEBLUE = toFloatArray(0x7b68ee); // decimal 123,104,238
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMSPRINGGREEN = toFloatArray(0x00fa9a); // decimal 0,250,154
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMTURQUOISE = toFloatArray(0x48d1cc); // decimal 72,209,204
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MEDIUMVIOLETRED = toFloatArray(0xc71585); // decimal 199,21,133
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MIDNIGHTBLUE = toFloatArray(0x191970); // decimal 25,25,112
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MINTCREAM = toFloatArray(0xf5fffa); // decimal 245,255,250
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MISTYROSE = toFloatArray(0xffe4e1); // decimal 255,228,225
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] MOCCASIN = toFloatArray(0xffe4b5); // decimal 255,228,181
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] NAVAJOWHITE = toFloatArray(0xffdead); // decimal 255,222,173
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] NAVY = toFloatArray(0x000080); // decimal 0,0,128
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] OLDLACE = toFloatArray(0xfdf5e6); // decimal 253,245,230
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] OLIVE = toFloatArray(0x808000); // decimal 128,128,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] OLIVEDRAB = toFloatArray(0x6b8e23); // decimal 107,142,35
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ORANGE = toFloatArray(0xffa500); // decimal 255,165,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ORANGERED = toFloatArray(0xff4500); // decimal 255,69,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ORCHID = toFloatArray(0xda70d6); // decimal 218,112,214
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PALEGOLDENROD = toFloatArray(0xeee8aa); // decimal 238,232,170
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PALEGREEN = toFloatArray(0x98fb98); // decimal 152,251,152
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PALETURQUOISE = toFloatArray(0xafeeee); // decimal 175,238,238
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PALEVIOLETRED = toFloatArray(0xdb7093); // decimal 219,112,147
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PAPAYAWHIP = toFloatArray(0xffefd5); // decimal 255,239,213
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PEACHPUFF = toFloatArray(0xffdab9); // decimal 255,218,185
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PERU = toFloatArray(0xcd853f); // decimal 205,133,63
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PINK = toFloatArray(0xffc0cb); // decimal 255,192,203
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PLUM = toFloatArray(0xdda0dd); // decimal 221,160,221
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] POWDERBLUE = toFloatArray(0xb0e0e6); // decimal 176,224,230
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] PURPLE = toFloatArray(0x800080); // decimal 128,0,128
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] RED = toFloatArray(0xff0000); // decimal 255,0,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ROSYBROWN = toFloatArray(0xbc8f8f); // decimal 188,143,143
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] ROYALBLUE = toFloatArray(0x4169e1); // decimal 65,105,225
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SADDLEBROWN = toFloatArray(0x8b4513); // decimal 139,69,19
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SALMON = toFloatArray(0xfa8072); // decimal 250,128,114
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SANDYBROWN = toFloatArray(0xf4a460); // decimal 244,164,96
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SEAGREEN = toFloatArray(0x2e8b57); // decimal 46,139,87
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SEASHELL = toFloatArray(0xfff5ee); // decimal 255,245,238
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SIENNA = toFloatArray(0xa0522d); // decimal 160,82,45
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SILVER = toFloatArray(0xc0c0c0); // decimal 192,192,192
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SKYBLUE = toFloatArray(0x87ceeb); // decimal 135,206,235
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SLATEBLUE = toFloatArray(0x6a5acd); // decimal 106,90,205
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SLATEGRAY = toFloatArray(0x708090); // decimal 112,128,144
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SLATEGREY = toFloatArray(0x708090); // decimal 112,128,144
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SNOW = toFloatArray(0xfffafa); // decimal 255,250,250
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] SPRINGGREEN = toFloatArray(0x00ff7f); // decimal 0,255,127
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] STEELBLUE = toFloatArray(0x4682b4); // decimal 70,130,180
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] TAN = toFloatArray(0xd2b48c); // decimal 210,180,140
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] TEAL = toFloatArray(0x008080); // decimal 0,128,128
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] THISTLE = toFloatArray(0xd8bfd8); // decimal 216,191,216
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] TOMATO = toFloatArray(0xff6347); // decimal 255,99,71
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] TURQUOISE = toFloatArray(0x40e0d0); // decimal 64,224,208
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] VIOLET = toFloatArray(0xee82ee); // decimal 238,130,238
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] WHEAT = toFloatArray(0xf5deb3); // decimal 245,222,179
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] WHITE = toFloatArray(0xffffff); // decimal 255,255,255
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] WHITESMOKE = toFloatArray(0xf5f5f5); // decimal 245,245,245
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] YELLOW = toFloatArray(0xffff00); // decimal 255,255,0
	/** @see <a href="https://www.w3.org/TR/css3-color/#svg-color" target="_blank">CSS Color Module Level 3, 4.3. Extended color keywords</a> */
	public static float[] YELLOWGREEN = toFloatArray(0x9acd32); // decimal 154,205,50
]]></xsl:text>
					</xsl:when>
					<!-- TODO indentity matrix values? -->
				</xsl:choose>
							
				<!-- method definitions for concrete fields -->
				<xsl:text><![CDATA[
	// Member value declaration is encapsulated and private, using preferred Java types for concretes library
	private ]]></xsl:text>
				<xsl:value-of select="$javaType"/>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text> = </xsl:text>
				<xsl:value-of select="$defaultValueExpression"/>
				<xsl:text>&#10;</xsl:text>

		<!-- Source code: constructor method applies default initial value -->
		<xsl:text>
	/**
	 * Constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> performs value initialization.
	 */
	public </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> ()
	{
		initialize();
	}
</xsl:text>
		<xsl:text>
	/**
	 * Initialization for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> applies default initial value.
	 */
	@Override
	public void initialize()
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/>
		<xsl:text> = </xsl:text>
		<xsl:value-of select="$defaultValueExpression"/>
		<xsl:text>
	}
</xsl:text>
		<!-- Static final utility methods -->
		<xsl:choose>
			<xsl:when test="($fieldName = 'SFString')">
				<xsl:text disable-output-escaping="yes"><![CDATA[

        // TODO better collect all regular expressions (regexes)
/*
        Names and Tokens https://www.w3.org/TR/xml11/#sec-common-syn
[4]   	NameStartChar	::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
[4a]   	NameChar	::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
[5]   	Name		::=   	NameStartChar (NameChar)*
[7]   	Nmtoken		::=   	(NameChar)+
*/
        /**
         * XML Regular Expression NameStartChar.
         * TODO integrate special-character support into regex.
         * [4]   	NameStartChar	::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
         * @see <a href="https://www.w3.org/TR/xml11/#NT-NameStartChar">XML 1.1 NameStartChar</a>
	 */
	public static final String NameStartCharFilter = "A-Z_a-z"; // TODO [\u00C0-\u00D6][\u00D8-\u00F6][\u00F8-\u02FF][\u0370-\u037D][\u037F-\u1FFF][\u200C-\u200D][\u2070-\u218F][\u2C00-\u2FEF][\u3001-\uD7FF][\uF900-\uFDCF][\uFDF0-\uFFFD][\u10000-\uEFFFF]";

        /**
         * XML Regular Expression NameChar.
         * TODO integrate special-character support into regex.
         * [4a]   	NameChar	::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
         * @see <a href="https://www.w3.org/TR/xml11/#NT-NameChar">XML 1.1 NameChar</a>
	 */
        public static final String NameCharFilter = NameStartCharFilter + "-.0-9"; // TODO \u00B7[\u0300-\u036F][\u0203F-\u2040]";

        /**
         * XML Regular Expression NameFilter.
         * TODO integrate special-character support into regex.
         * [5]   	Name		::=   	NameStartChar (NameChar)*
         * @see <a href="https://www.w3.org/TR/xml11/#NT-NameFilter">XML 1.1 NameFilter</a>
	 */
        public static final String NameFilter = "[" + NameStartCharFilter + "][" + NameCharFilter + "]*"; // "[A-Z_a-z][A-Z_a-z-.0-9]*"

        /**
         * XML Regular Expression Nmtoken.
         * TODO integrate special-character support into regex.
         * [7]   	Nmtoken		::=   	(NameChar)+
         * @see <a href="https://www.w3.org/TR/xml11/#NT-Nmtoken">XML 1.1 Nmtoken</a>
	 */
        public static final String NmtokenFilter = "[" + NameCharFilter + "]+"; // "[A-Z_a-z-.0-9]+"

        /**
	 * Utility method to determine if string meets XML NMTOKEN requirements
	 * @param value string to check
	 * @return whether value meets NMTOKEN regex checks
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 * @see <a href="http://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
	 * @see <a href="http://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
	 * @see <a href="https://www.w3.org/TR/REC-xml/#sec-common-syn">XML 1.1 Common Syntactic Constructs</a>
	 * @see <a href="https://www.w3.org/TR/xml11/#NT-Nmtoken">XML 1.1 NMTOKEN</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @see <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.2" target="_blank">Java Language Specification: 3 Lexical Structure, 3.2. Lexical Translations</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/i18n/text/unicode.html" target="_blank">Java Tutorials: Unicode</a>
	 * @see <a href="http://www.oracle.com/us/technologies/java/supplementary-142654.html" target="_blank">Java and Unicode: Supplementary Characters in the Java Platform</a>
	 */
	public static final boolean isNMTOKEN(String value)
	{
            if ((value == null) || value.trim().isEmpty())
                return false;
            // NMTOKEN character regex check
            boolean result = value.matches(NmtokenFilter);

/* original was simpler and not strictly correct
                boolean result = value.matches("[a-zA-Z_][a-zA-Z0-9_]*"); // NMTOKEN character regex check
                if (value.startsWith(".") || value.startsWith("-"))       // NameStartChar restrictions
                    result = false;
*/
		return result;
	}

        /**
	 * Utility method to determine if string meets suggested X3D naming conventions
	 * @param value string to check
	 * @return whether value meets suggested X3D naming requirements
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 * @see <a href="http://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
	 * @see <a href="http://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
	 * @see <a href="https://www.w3.org/TR/REC-xml/#sec-common-syn">XML 1.1 Common Syntactic Constructs</a>
	 * @see <a href="https://www.w3.org/TR/xml11/#NT-Nmtoken">XML 1.1 NMTOKEN</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @see <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.2" target="_blank">Java Language Specification: 3 Lexical Structure, 3.2. Lexical Translations</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/i18n/text/unicode.html" target="_blank">Java Tutorials: Unicode</a>
	 * @see <a href="http://www.oracle.com/us/technologies/java/supplementary-142654.html" target="_blank">Java and Unicode: Supplementary Characters in the Java Platform</a>
	 */
	public static final boolean meetsX3dNamingConventions(String value)
	{
            if ((value == null) || value.trim().isEmpty())
                return false;
            // TODO continue improving character regex checks.  Not identical to NMTOKEN.
            boolean result = // value.matches(NameFilter) &&               // XML Name
                                value.matches("[a-zA-Z_][a-zA-Z0-9_.-]*"); // X3D SAH; TODO reconcile guidance . and -

/* original was simpler and not strictly correct
                boolean result = value.matches("[a-zA-Z_][a-zA-Z0-9_]*"); // NMTOKEN character regex check
                if (value.startsWith(".") || value.startsWith("-"))       // NameStartChar restrictions
                    result = false;
*/
		return result;
	}]]></xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'MFString')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Modify current object values to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets.
	 * @see MFStringObject#cleanupUnescapedEnclosingQuotes()
	 * @return {@link MFStringObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public MFStringObject cleanupEnumerationValues()
	{
		MFString = cleanupEnumerationValues(MFString);
		return this;
	}
	/**
	 * Utility method for single enumeration value to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets to create an unadorned enumeration String.
	 * @param value single enumeration string intended for use as an SFString or MFString value
	 * @see MFStringObject#cleanupUnescapedEnclosingQuotes(String)
	 * @return unquoted string values containing no whitespace as MFString list
	 */
	public static String cleanupEnumerationValue(String value)
	{
		String result = new String();
		if  (value != null)
			 result = value;
		// total elimination:
		return result.replaceAll("\""," ").replaceAll(","," ").replaceAll("["," ").replaceAll("]"," ").replaceAll(" ","");
	}
	/**
	 * Utility method for a single String containing multiple enumeration values to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets to create unadorned MFString elements as a String[] array.
	 * @param values zero or more enumeration values intended for use as an MFString list
	 * @see MFStringObject#cleanupUnescapedEnclosingQuotes(String)
	 * @return unquoted string values containing no whitespace as MFString list
	 */
	public static String[] cleanupEnumerationValues(String values)
	{
		String[] result = new String[1];
		if  (values == null)
			 result[0] = new String();
		else result[0] = values.trim();
		if (!result[0].contains("\""))
			 return result;
		else return result[0].replaceAll("\""," ").replaceAll(","," ").replaceAll("["," ").replaceAll("]"," ").split("(\\s)*");
	}
	/**
	 * Utility method for multiple enumeration values to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets in a String[] array.
	 * @param values zero or more enumeration values intended for use as an MFString list
	 * @see MFStringObject#cleanupEnumerationValue(String)
	 * @see MFStringObject#cleanupEnumerationValues(String)
	 * @see MFStringObject#cleanupUnescapedEnclosingQuotes(String)
	 * @return unquoted string values containing no whitespace as String[] array
	 */
	public static String[] cleanupEnumerationValues(String[] values)
	{
		String[] results = new String[0];
		if  (values != null)
			 results = values;
		for (int i = 0; i < results.length; i++)
		{
			results[i] = cleanupEnumerationValue(results[i]); // one singleton enumeration at a time
		}
		return results;
	}
	/**
	 * Utility method for multiple enumeration values to ignore all whitespace, remove all embedded quotes, remove all commas, and remove all square brackets from a ArrayList of values.
	 * @param values zero or more enumeration values intended for use as an MFString list
	 * @see MFStringObject#cleanupEnumerationValue(String)
	 * @see MFStringObject#cleanupEnumerationValues(String)
	 * @see MFStringObject#cleanupUnescapedEnclosingQuotes(String)
	 * @return unquoted string values containing no whitespace as MFString list
	 */
	public static ArrayList<String> cleanupEnumerationValues(ArrayList<String> values)
	{
		ArrayList<String> results = new ArrayList<>();
		if  (values != null)
			 results = values;
		for (String result : results)
		{
			result = cleanupEnumerationValue(result); // one singleton enumeration at a time
		}
		return results;
	}
	/**
	 * Modify current object values to trim enclosing quotes and outer whitespace.
	 * @see MFStringObject#cleanupEnumerationValues()
	 * @return {@link MFStringObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public MFStringObject cleanupUnescapedEnclosingQuotes()
	{
		MFString = cleanupUnescapedEnclosingQuotes(MFString);
		return this;
	}
	/**
	 * Utility method to trim enclosing quotes and outer whitespace from an arbitrary String value, without removing escaped quotation marks (<i>\"</i>).
	 * ]]></xsl:text>
	<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
	<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
	<xsl:text>&#10;</xsl:text>
	<xsl:text>	 * </xsl:text>
	<xsl:text disable-output-escaping="yes"><![CDATA[<i>Warning:</i> do not use this method on a String that contains multiple quoted values, use cleanupEnumerationValues() instead.
	 * @param singleValue input String for use with MFString list, which must be unquoted
	 * @see MFStringObject#cleanupEnumerationValue(String)
	 * @return unquoted String value
	 */
	public static String cleanupUnescapedEnclosingQuotes(String singleValue)
	{
		String result = singleValue;
		if  (result == null)
			 result = new String();
		if (result.trim().startsWith("\""))
		{
			result = result.trim().substring(1);							 // trim unescaped quotation mark "
		}
		if (result.trim().endsWith("\"") && !result.trim().endsWith("\\\"")) 
		{
			result = result.trim().substring(0, result.trim().length() - 1); // trim unescaped quotation mark "
		}
		return result;
	}
	/**
	 * Utility method to trim enclosing quotes and outer whitespace from elements in an arbitrary String[] array.
	 * @param values String[] array for use with MFString list, which must be unquoted
	 * @see MFStringObject#cleanupUnescapedEnclosingQuotes(String)
	 * @see MFStringObject#cleanupEnumerationValue(String)
	 * @see MFStringObject#cleanupEnumerationValues(String)
	 * @return unquoted String[] array
	 */
	public static String[] cleanupUnescapedEnclosingQuotes(String[] values)
	{
		String[] result = values;
		if  (result == null)
			 result = new String[0];
		for (int i = 0; i < result.length; i++)
		{
			result[i] = cleanupUnescapedEnclosingQuotes(result[i]);
		}
		return result;
	}
	/**
	 * Utility method to trim enclosing quotes and outer whitespace from elements in an ArrayList of arbitrary String values.
	 * @param values existing ArrayList of String values for use with MFString list, which must be unquoted
	 * @see MFStringObject#cleanupUnescapedEnclosingQuotes(String)
	 * @see MFStringObject#cleanupEnumerationValue(String)
	 * @see MFStringObject#cleanupEnumerationValues(String)
	 * @return unquoted String[] array
	 */
	public static ArrayList<String> cleanupUnescapedEnclosingQuotes(ArrayList<String> values)
	{
		ArrayList<String> results = values;
		if  (results == null)
			 results = new ArrayList<>();
		for (String result : results)
		{
			result = cleanupUnescapedEnclosingQuotes(result);
		}
		return results;
	}
]]></xsl:text>
			</xsl:when>
		</xsl:choose>

		<!-- Source code: constructor method using initial String value.  Typically protected/hidden, designed for reflection use. -->
		<xsl:if test="not($fieldName = 'SFNode') and not($fieldName = 'MFNode')">
		<xsl:text>
	/**
	 * Utility accessor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using String value</xsl:text>
	<xsl:choose>
		<xsl:when test="($fieldName = 'SFString') or ($fieldName = 'MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @param newValue is new value to assign
	 * @return {@link MFMatrix4dObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text> setValueByString</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text disable-output-escaping="yes"><![CDATA[ (which must pass parsing validation checks).
	 * <br ><br >
	 * <i>Warning:</i> this method is not 
	 * <i><a href="https://en.wikipedia.org/wiki/Type_safety" target="_blank">type safe</a></i>
	 * at compile time!  Best practice for X3DJSAIL programmers is to use strongly typed methods instead, in order to avoid potential for run-time errors.
	 * @see X3DLoaderObject#toX3dObjectTree(org.w3c.dom.Node)
	 * @param newValue is new value to assign, if empty then assign DEFAULT_VALUE
	 * @return {@link MFMatrix4dObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
	 */
	public ]]></xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text> setValueByString</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text> (String newValue) throws InvalidFieldValueException
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA)
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment
		if (newValue.trim().isEmpty())
		{
			</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return this;
		}</xsl:text>
		<xsl:if test="not(contains($fieldName, 'FString')) and not(contains($fieldName, 'FBool'))">
			<xsl:text>
		try
		{</xsl:text>
		</xsl:if>
		<xsl:text>
			</xsl:text>
			<xsl:choose>
				<xsl:when test="($fieldName = 'SFBool')">
					<xsl:text disable-output-escaping="yes"><![CDATA[if (!newValue.equals("true") && !newValue.equals("false"))
		{
			String errorNotice = "illegal boolean value, must be 'true' or 'false' (case sensitive), new ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		</xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = Boolean.parseBoolean(newValue);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFInt32')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = Integer.parseInt(newValue);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFFloat')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = Float.parseFloat(newValue);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFDouble')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = Double.parseDouble(newValue);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFString')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = newValue;</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFTime')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ = Double.parseDouble(newValue);
			if ((SFTime < 0.0) && (SFTime != DEFAULT_VALUE)) // initial value check
			{
				SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			}</xsl:text>
				</xsl:when>
				<!-- http://stackoverflow.com/questions/225337/how-do-i-split-a-string-with-any-whitespace-chars-as-delimiters -->
				<xsl:when test="($fieldName = 'SFVec2d')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 2)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec2d[0] = Double.parseDouble(newValues[0]);
			SFVec2d[1] = Double.parseDouble(newValues[1]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec2f')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 2)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec2f[0] = Float.parseFloat(newValues[0]);
			SFVec2f[1] = Float.parseFloat(newValues[1]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec3d')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 3)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec3d[0] = Double.parseDouble(newValues[0]);
			SFVec3d[1] = Double.parseDouble(newValues[1]);
			SFVec3d[2] = Double.parseDouble(newValues[2]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec3f')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 3)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec3f[0] = Float.parseFloat(newValues[0]);
			SFVec3f[1] = Float.parseFloat(newValues[1]);
			SFVec3f[2] = Float.parseFloat(newValues[2]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFColor')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 3)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFColor[0] = Float.parseFloat(newValues[0]);
			SFColor[1] = Float.parseFloat(newValues[1]);
			SFColor[2] = Float.parseFloat(newValues[2]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFColorRGBA')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 4)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFColorRGBA[0] = Float.parseFloat(newValues[0]);
			SFColorRGBA[1] = Float.parseFloat(newValues[1]);
			SFColorRGBA[2] = Float.parseFloat(newValues[2]);
			SFColorRGBA[3] = Float.parseFloat(newValues[3]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec4d')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 4)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec4d[0] = Double.parseDouble(newValues[0]);
			SFVec4d[1] = Double.parseDouble(newValues[1]);
			SFVec4d[2] = Double.parseDouble(newValues[2]);
			SFVec4d[3] = Double.parseDouble(newValues[3]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFVec4f')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 4)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFVec4f[0] = Float.parseFloat(newValues[0]);
			SFVec4f[1] = Float.parseFloat(newValues[1]);
			SFVec4f[2] = Float.parseFloat(newValues[2]);
			SFVec4f[3] = Float.parseFloat(newValues[3]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFRotation')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 4)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFRotation[0] = Float.parseFloat(newValues[0]);
			SFRotation[1] = Float.parseFloat(newValues[1]);
			SFRotation[2] = Float.parseFloat(newValues[2]);
			SFRotation[3] = Float.parseFloat(newValues[3]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFMatrix3d')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 9)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFMatrix3d[0] = Double.parseDouble(newValues[0]);
			SFMatrix3d[1] = Double.parseDouble(newValues[1]);
			SFMatrix3d[2] = Double.parseDouble(newValues[2]);
			SFMatrix3d[3] = Double.parseDouble(newValues[3]);
			SFMatrix3d[4] = Double.parseDouble(newValues[4]);
			SFMatrix3d[5] = Double.parseDouble(newValues[5]);
			SFMatrix3d[6] = Double.parseDouble(newValues[6]);
			SFMatrix3d[7] = Double.parseDouble(newValues[7]);
			SFMatrix3d[8] = Double.parseDouble(newValues[8]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFMatrix3f')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 9)
			{
				String errorNotice = "illegal number of values in initialization string, new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFMatrix3f[0] = Float.parseFloat(newValues[0]);
			SFMatrix3f[1] = Float.parseFloat(newValues[1]);
			SFMatrix3f[2] = Float.parseFloat(newValues[2]);
			SFMatrix3f[3] = Float.parseFloat(newValues[3]);
			SFMatrix3f[4] = Float.parseFloat(newValues[4]);
			SFMatrix3f[5] = Float.parseFloat(newValues[5]);
			SFMatrix3f[6] = Float.parseFloat(newValues[6]);
			SFMatrix3f[7] = Float.parseFloat(newValues[7]);
			SFMatrix3f[8] = Float.parseFloat(newValues[8]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFMatrix4d')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 16)
			{
				String errorNotice = "illegal number of values in initialization string";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFMatrix4d [0] = Double.parseDouble(newValues[0]);
			SFMatrix4d [1] = Double.parseDouble(newValues[1]);
			SFMatrix4d [2] = Double.parseDouble(newValues[2]);
			SFMatrix4d [3] = Double.parseDouble(newValues[3]);
			SFMatrix4d [4] = Double.parseDouble(newValues[4]);
			SFMatrix4d [5] = Double.parseDouble(newValues[5]);
			SFMatrix4d [6] = Double.parseDouble(newValues[6]);
			SFMatrix4d [7] = Double.parseDouble(newValues[7]);
			SFMatrix4d [8] = Double.parseDouble(newValues[8]);
			SFMatrix4d [9] = Double.parseDouble(newValues[9]);
			SFMatrix4d[10] = Double.parseDouble(newValues[10]);
			SFMatrix4d[11] = Double.parseDouble(newValues[11]);
			SFMatrix4d[12] = Double.parseDouble(newValues[12]);
			SFMatrix4d[13] = Double.parseDouble(newValues[13]);
			SFMatrix4d[14] = Double.parseDouble(newValues[14]);
			SFMatrix4d[15] = Double.parseDouble(newValues[15]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'SFMatrix4f')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			if (newValues.length != 16)
			{
				String errorNotice = "illegal number of values in initialization string";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			SFMatrix4f [0] = Float.parseFloat(newValues[0]);
			SFMatrix4f [1] = Float.parseFloat(newValues[1]);
			SFMatrix4f [2] = Float.parseFloat(newValues[2]);
			SFMatrix4f [3] = Float.parseFloat(newValues[3]);
			SFMatrix4f [4] = Float.parseFloat(newValues[4]);
			SFMatrix4f [5] = Float.parseFloat(newValues[5]);
			SFMatrix4f [6] = Float.parseFloat(newValues[6]);
			SFMatrix4f [7] = Float.parseFloat(newValues[7]);
			SFMatrix4f [8] = Float.parseFloat(newValues[8]);
			SFMatrix4f [9] = Float.parseFloat(newValues[9]);
			SFMatrix4f[10] = Float.parseFloat(newValues[10]);
			SFMatrix4f[11] = Float.parseFloat(newValues[11]);
			SFMatrix4f[12] = Float.parseFloat(newValues[12]);
			SFMatrix4f[13] = Float.parseFloat(newValues[13]);
			SFMatrix4f[14] = Float.parseFloat(newValues[14]);
			SFMatrix4f[15] = Float.parseFloat(newValues[15]);</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFBool')">
					<xsl:text><![CDATA[String[] newValues = newValue.trim().split("\\s+");
			]]></xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text> = new </xsl:text><xsl:value-of select="$javaPrimitiveType"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[[newValues.length];
			int i = 0;
			for (String value : newValues)
			{
				if (!value.equals("true") && !newValue.equals("false"))
				{
					String errorNotice = "illegal boolean value for ]]></xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text>Object() initialization, newValue[" + i + "]='" + value + "' but must be 'true' or 'false' (case sensitive)";
 					validationResult.append(errorNotice).append("\n");
					throw new InvalidFieldValueException(errorNotice);
				}
				</xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text>[i] = Boolean.parseBoolean(value); // append to array
				i++;
			}</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFString')">
					<xsl:text><![CDATA[if (!newValue.contains("\""))
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text> = new String[1];
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = newValue; // simple single string (value missing "wrapped quotes")
				return this;
			}
			String[] newValues = cleanupUnescapedEnclosingQuotes(newValue.trim()).split("\"[\\s+]\"");
			</xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text><![CDATA[ = new String[newValues.length];
			for (int i=0; i < newValues.length; i++)
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text>[i] = newValues[i].replace("\\\"","\""); // fill array, no backslash escapes preceding contained quote characters
			}</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFInt32') or ($fieldName = 'SFImage') or ($fieldName = 'MFImage')">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");
			</xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = new </xsl:text>
					<xsl:choose>
						<xsl:when test="contains($javaPrimitiveType,'[')">
							<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$javaPrimitiveType"/>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:text>[newValues.length];  // reset array size to match</xsl:text>
					<xsl:text disable-output-escaping="yes"><![CDATA[
			for (int i = 0; i < newValues.length;i++)
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[i] = Integer.parseInt(newValues[i]); // insert in array
			}</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFDouble') or ($fieldName = 'MFTime') or 
								(starts-with($fieldName, 'MFVec') and ends-with($fieldName, 'd')) or 
								(  contains($fieldName, 'Matrix') and ends-with($fieldName, 'd'))">
					<xsl:text>String[] newValues = newValue.trim().split("\\s+");</xsl:text>
					<xsl:if test="not($fieldName = 'MFDouble')">
						<xsl:text>
			if ((newValues.length % </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) != 0) // tupleSize modulus check
			{
				String errorNotice = "illegal number of values (" + newValues.length + ")" +
					" in initialization string, must be multiple of </xsl:text>
					<xsl:value-of select="$tupleSize"/><xsl:text> when declaring new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}
			</xsl:text>
			</xsl:if>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = new </xsl:text>
					<xsl:choose>
						<xsl:when test="contains($javaPrimitiveType,'[')">
							<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$javaPrimitiveType"/>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:text>[newValues.length];  // reset array size to match</xsl:text>
					<xsl:text disable-output-escaping="yes"><![CDATA[
			for (int i = 0; i < newValues.length;i++)
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[i] = Double.parseDouble(newValues[i]); // insert in array</xsl:text>
					<xsl:if test="($fieldName = 'MFTime')">
						<xsl:text disable-output-escaping="yes"><![CDATA[		
				if ((MFTime[i] < 0.0) && (MFTime[i] != SFTimeObject.DEFAULT_VALUE)) // initial value check
				{
					MFTime[i] = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
				}]]></xsl:text>
					</xsl:if>
					<xsl:text>
			}</xsl:text>
				</xsl:when>
				<xsl:when test="($fieldName = 'MFFloat') or 
								(contains($fieldName, 'FColor')) or (contains($fieldName, 'FRotation')) or 
								(starts-with($fieldName, 'MFVec') and ends-with($fieldName, 'f')) or 
								(  contains($fieldName, 'Matrix') and ends-with($fieldName, 'f'))">
					<xsl:text>String[] newValues = newValue.trim().trim().split("\\s+");</xsl:text>
					<xsl:if test="not($fieldName = 'MFFloat') and not($fieldName = 'MFTime')">
						<xsl:text>
			if ((newValues.length % </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) != 0) // tupleSize modulus check
			{
				String errorNotice = "illegal number of values (" + newValues.length + ")" +
					" in initialization string, must be multiple of </xsl:text>
					<xsl:value-of select="$tupleSize"/><xsl:text> when declaring new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ")";
				validationResult.append(errorNotice).append("\n");
				throw new InvalidFieldValueException(errorNotice);
			}</xsl:text>
					</xsl:if>
					<xsl:text>
			</xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text> = new </xsl:text>
					<xsl:choose>
						<xsl:when test="contains($javaPrimitiveType,'[')">
							<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$javaPrimitiveType"/>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:text>[newValues.length];  // reset array size to match</xsl:text>
					<xsl:text disable-output-escaping="yes"><![CDATA[
			for (int i = 0; i < newValues.length;i++)
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[i] = Float.parseFloat(newValues[i]); // insert in array
			}</xsl:text>
				</xsl:when>
				<!-- TODO extraneous?? -->
				<xsl:when test="starts-with($fieldName,'MF')">
					<xsl:text> TODO extraneous?? </xsl:text>
				</xsl:when>
			</xsl:choose>
	<xsl:if test="not(contains($fieldName, 'FString')) and not(contains($fieldName, 'FBool'))">
		<xsl:text>
		}
		catch (</xsl:text>
		<xsl:choose>
			<xsl:when test="($fieldName = 'SFBool')">
				<xsl:text>TODO omit</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>NumberFormat</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
			<xsl:text>Exception e)
		{
			String errorNotice = "new </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>Object(" + newValue + ") " + e.getMessage();
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException (errorNotice);
		}</xsl:text>
	</xsl:if>
	<xsl:text>
		return this;
	}
</xsl:text>
		</xsl:if>

		<!-- Source code: constructor method using default SFtype initial value -->
		<xsl:if test="starts-with(@type, 'MF') and ($tupleSize = 1) and not(contains($fieldName, 'FString')) and not(contains($fieldName, 'FBool')) and not(contains($fieldName, 'FImage'))">
			<xsl:text>
	/**
	 * Utility constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> to assign a single </xsl:text>
	<xsl:value-of select="substring-before($javaType,'[]')"/>
	<xsl:text> as new initial array value.
	 * @param newValue is new value to assign
	 */
	public </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> (</xsl:text>
	<xsl:value-of select="substring-before($javaType,'[]')"/>
	<xsl:text> newValue)
	{
		</xsl:text>
		<xsl:text>setValue(new S</xsl:text>
		<xsl:value-of select="substring(@type, 2)"/>
		<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
		<xsl:text>(newValue));
	}

	/**
	 * Utility constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using a corresponding S</xsl:text>
	<xsl:value-of select="substring(@type, 2)"/>
	<xsl:text>Object as new initial value (which must pass parsing validation checks).
	 * @param newValue is new value to assign
	 */
	public </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> (</xsl:text>
	<xsl:text>S</xsl:text>
	<xsl:value-of select="substring(@type, 2)"/>
	<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
	<xsl:text> newValue)
	{
		if (newValue == null)
		{
			</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return;
		}
		</xsl:text>
	<xsl:choose>
		<xsl:when test="contains(@type,'FVec') and ends-with(@type,'d')">
			<xsl:text>setValue(newValue.toDoubleArray()); // create array</xsl:text>
		</xsl:when>
		<xsl:when test="contains(@type,'Color') or contains(@type,'Rotation') or contains(@type,'FVec') or starts-with(@type,'SFMatrix')">
			<xsl:text>setValue(newValue.toFloatArray()); // create array</xsl:text>
		</xsl:when>
		<xsl:when test="starts-with(@type,'MFMatrix') or (@type = 'MFImage')">
			<xsl:text>// TODO matrix initialization</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[ = new ]]></xsl:text>
			<xsl:value-of select="substring-before($javaType,'[]')"/>
			<xsl:text>[1]; // create array
		</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>[0] = newValue.getValue();</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
	}
</xsl:text>
		</xsl:if>
					
					<!-- common field constructor: setValue using another field of same type -->
					<xsl:text><![CDATA[
	/**
	 * Constructor to copy an ]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[ value as initial value for this new field object.
	 * @param newValue The newValue to apply
	 */
	public ]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text>(</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> newValue)
	{
		if (newValue == null)
		{
			</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return;
		}
		</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = newValue.getPrimitiveValue();
	}
]]></xsl:text>
 
		<!-- Source code: constructor method using typed primitive value -->
		<xsl:text>
	/**
	 * Constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using a corresponding Java primitive </xsl:text>
	<xsl:value-of select="$javaType"/>
	<xsl:text> </xsl:text>
	<xsl:if test="contains($javaType,'[')">
		<xsl:text>array </xsl:text>
	</xsl:if>
	<xsl:text disable-output-escaping="yes"><![CDATA[as new initial value.
	 * @param newValue is new value to assign]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * setContainerFieldOverride(containerFieldName); // apply checksConcreteField#getTupleSize(String)
	 */
	public ]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> (</xsl:text>
	<xsl:value-of select="$javaType"/>
	<xsl:text> newValue)
	{</xsl:text>
		<!-- initial value checks -->
		<xsl:choose>
			<xsl:when test="starts-with(@type,'MF') and ends-with($javaType, '[]') and not($tupleSize = '1')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length % </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ != 0) // ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[-tuple check
		{
			String errorNotice = "Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must be multiple of ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
		<xsl:when test="starts-with(@type,'SF') and ends-with($javaType, '[]') and not($tupleSize = '1')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length != </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[)
		{
			String errorNotice = "Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must equal ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="ends-with($javaType, '[]')"><!-- ($tupleSize == 1) -->
			<xsl:text disable-output-escaping="yes"><![CDATA[
		if (newValue == null)
			newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		</xsl:text>
			</xsl:when>
		</xsl:choose>
		<xsl:choose>
			<xsl:when test="(@type='MFString')">
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ = new String[newValue.length];
//		for (int i=0; i < newValue.length; i++)
//			newValue[i] = cleanupUnescapedEnclosingQuotes(newValue[i]); // fill array
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		if ((newValue < 0.0) && (newValue != DEFAULT_VALUE)) // initial value check
		{
			SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return;
		}
		</xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		for (int i = 0; i < newValue.length; i++)
		{
			if ((newValue[i] < 0.0) && (newValue[i] != SFTimeObject.DEFAULT_VALUE)) // initial value check
			{
				newValue[i] = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
			}
		}
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColor')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// initial value checks 
		float   red = newValue[0];
		float green = newValue[1];
		float  blue = newValue[2];
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "Illegal SFColor value (" + red + "," + green + "," + blue +
				"), all values must be in numeric range [0..1]";
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColorRGBA')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// initial value checks 
		float   red = newValue[0];
		float green = newValue[1];
		float  blue = newValue[2];	
		float alpha = newValue[3];	
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
		</xsl:choose>
		<xsl:value-of select="$fieldName"/>
		<xsl:text> = newValue;
	}
</xsl:text>

		<!-- Utility constructors for fields-->
		<xsl:choose>
			<xsl:when test="(@type='MFBool')">
	<xsl:text>
	/**
	 * Constructor for MFBoolObject using a single corresponding Java primitive boolean as new initial value.
	 * @param newValue is new value to assign
	 */
	public MFBoolObject (boolean newValue)
	{
		MFBool = new boolean[1]; // fix array size
		MFBool[0] = newValue;
	}
</xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFTime')">
	<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor for MFTimeObject using a single float as new initial value.
	 * @param newValue is new value to assign
	 */
	public MFTimeObject (float newValue)
	{
		setValue(newValue); // apply checks
	}
	/**
	 * Constructor for MFTimeObject using a float[] array as new initial value.
	 * @param newValue is new value to assign
	 */
	public MFTimeObject (float[] newValue)
	{
		setValue(newValue); // apply checks
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFString')">
				<xsl:text>
	/**
	 * Constructor to parse String as new initial value.
	 * @param newValue is new value to assign
	 */
	public MFString</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (String newValue)
	{
		setValueByString(newValue);
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFFloat')">
				<xsl:text>
	/**
	 * Constructor using double as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFFloat</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (double newValue)
	{
		SFFloat = (float) newValue;
	}
	/**
	 * Constructor using int as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int newValue)
	{
		SFFloat = (float) newValue;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFDouble')">
				<xsl:text><![CDATA[
	/**
	 * Constructor using float as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFDouble]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (float newValue)
	{
		SFDouble = (double) newValue;
	}
	/**
	 * Constructor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ using int as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFDouble]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int newValue)
	{
		SFDouble = (double) newValue;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFTime')">
				<xsl:text>
	/**
	 * Constructor using float as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFTime</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (float newValue)
	{
		SFTime = (double) newValue;
		if ((SFTime < 0.0) && (SFTime != DEFAULT_VALUE)) // initial value check
		{
			SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		}
	}
	/**
	 * Constructor using int as new initial value.
	 * @param newValue is new value to assign
	 */
	public SFTime</xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int newValue)
	{
		SFTime = (double) newValue;
		if ((SFTime < 0.0) && (SFTime != DEFAULT_VALUE)) // initial value check
		{
			SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		}
	}
</xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColor')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor using individual float types as new initial value (which must pass validation checks).
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (float red, float green, float blue)
	{
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "Illegal SFColor value (" + red + "," + green + "," + blue + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColor[0] = red;
		SFColor[1] = green;
		SFColor[2] = blue;
	}
	/**
	 * Constructor using individual double types as new initial value (which must pass validation checks).
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (double red, double green, double blue)
	{
		setValue ((float) red, (float) green, (float) blue);
	}
	/**
	 * Constructor using single HTML-style 0xRRGGBB hex value as new initial value.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int hexColorValue)
	{
		// http://stackoverflow.com/questions/12798611/splitting-a-hex-number

		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;
						 
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "Illegal SFColor value (" + red + "," + green + "," + blue + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColor[0] = red;
		SFColor[1] = green;
		SFColor[2] = blue;
	}
	/**
	 * Public utility method converting single HTML-style 0xRRGGBB hex value to three-tuple float array.
TODO: also MFColor.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return float[3] array containing X3D RGB values, each ranging [0..1]
	 */
	public static float[] toFloatArray (int hexColorValue)
	{
		// http://stackoverflow.com/questions/12798611/splitting-a-hex-number
						 
		float[] newFloatArray = {0.0f, 0.0f, 0.0f};
						 
		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;
						 
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "Illegal SFColor value (" + red + "," + green + "," + blue + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		newFloatArray[0] = red;
		newFloatArray[1] = green;
		newFloatArray[2] = blue;
		return newFloatArray;
	}
	/**
	 * Public utility accessor method setting single HTML-style 0xRRGGBB hex value as new value.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue (int hexColorValue)
	{
		// http://stackoverflow.com/questions/12798611/splitting-a-hex-number
						 
		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;
						 
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "Illegal ;SFColor value (" + red + "," + green + "," + blue + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColor[0] = red;
		SFColor[1] = green;
		SFColor[2] = blue;
		return this;
	}
	/**
	 * Complement all color values in RGB space (i.e. subtract each component from 1).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementRGB ()
	{
		SFColor[0] = 1.0f - SFColor[0];
		SFColor[1] = 1.0f - SFColor[1];
		SFColor[2] = 1.0f - SFColor[2];
		return this;
	}
	/**
	 * Scale all color values in RGB space.
	 * @param scaleFactor nonnegative scaling factor
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ scaleRGB (float scaleFactor)
	{
		if (scaleFactor < 0.0f)
		{
			String errorNotice = "Illegal scaleFactor value (" + scaleFactor + "), must be nonnegative";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColor[0] *= scaleFactor;
		SFColor[1] *= scaleFactor;
		SFColor[2] *= scaleFactor;
		return this;
	}
	/**
	 * Ensure all component color values are within range [0-1] by clipping as necessary.
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalizeClip ()
	{
		if (SFColor[0] < 0.0f) SFColor[0] = 0.0f;
		if (SFColor[1] < 0.0f) SFColor[1] = 0.0f;
		if (SFColor[2] < 0.0f) SFColor[2] = 0.0f;
		if (SFColor[0] > 1.0f) SFColor[0] = 1.0f;
		if (SFColor[1] > 1.0f) SFColor[1] = 1.0f;
		if (SFColor[2] > 1.0f) SFColor[2] = 1.0f;
		return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColorRGBA')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor using individual float types as new initial value (which must pass validation checks).
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[  (float red, float green, float blue, float alpha)
	{
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColorRGBA[0] = red;
		SFColorRGBA[1] = green;
		SFColorRGBA[2] = blue;
		SFColorRGBA[3] = alpha;
	}
	/**
	 * Constructor using individual double types as new initial value (which must pass validation checks).
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[  (double red, double green, double blue, double alpha)
	{
		setValue ((float) red, (float) green, (float) blue, (float) alpha);
	}
	/**
	 * Constructor using single HTML-style 0xRRGGBB hex value as new initial value.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int hexColorValue, float alpha)
	{
		// http://stackoverflow.com/questions/12798611/splitting-a-hex-number
						 
		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;
						 
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "Illegal SFColor value (" + red + "," + green + "," + blue + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColorRGBA[0] = red;
		SFColorRGBA[1] = green;
		SFColorRGBA[2] = blue;
		SFColorRGBA[3] = alpha;
	}
	/**
	 * Public utility accessor method setting single HTML-style 0xRRGGBB hex value as new value.
	 * @param hexColorValue HTML color value (such as 0xAA2288)
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue (int hexColorValue, float alpha)
	{
		// http://stackoverflow.com/questions/12798611/splitting-a-hex-number
						 
		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;
						 
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "Illegal SFColor value (" + red + "," + green + "," + blue + "," + alpha + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColorRGBA[0] = red;
		SFColorRGBA[1] = green;
		SFColorRGBA[2] = blue;
		SFColorRGBA[3] = alpha;
		return this;
	}
	/**
	 * Complement all color values in RGB space (i.e. subtract each component from 1), with no change in alpha.
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementRGB ()
	{
		SFColorRGBA[0] = 1.0f - SFColorRGBA[0];
		SFColorRGBA[1] = 1.0f - SFColorRGBA[1];
		SFColorRGBA[2] = 1.0f - SFColorRGBA[2];
		return this;
	}
	/**
	 * Complement alpha value by subtracting it from 1, note transparency = (1 - alpha).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementAlpha ()
	{
		SFColorRGBA[3] = 1.0f - SFColorRGBA[3];
		return this;
	}
	/**
	 * Ensure all component color values are within range [0-1] by clipping as necessary.
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalizeClip ()
	{
		if (SFColorRGBA[0] < 0.0f) SFColorRGBA[0] = 0.0f;
		if (SFColorRGBA[1] < 0.0f) SFColorRGBA[1] = 0.0f;
		if (SFColorRGBA[2] < 0.0f) SFColorRGBA[2] = 0.0f;
		if (SFColorRGBA[3] < 0.0f) SFColorRGBA[3] = 0.0f;
		if (SFColorRGBA[0] > 1.0f) SFColorRGBA[0] = 1.0f;
		if (SFColorRGBA[1] > 1.0f) SFColorRGBA[1] = 1.0f;
		if (SFColorRGBA[2] > 1.0f) SFColorRGBA[2] = 1.0f;
		if (SFColorRGBA[3] > 1.0f) SFColorRGBA[3] = 1.0f;
		return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFColor')">
				<!-- TODO hex array constructor and accessors -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param index is position of selected value in current array
	 * @param hexColorValue HTML color value (such as 0xAA2288) to apply
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ set1Value(int index, int hexColorValue) throws ArrayIndexOutOfBoundsException
	{
		if (index < 0)
		{
			String errorNotice = "Index value is negative, thus cannot set1Value at index=" + index + ".";
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
		if (index >= MFColor.length / MFColorObject.TUPLE_SIZE) // tupleSize factor
		{
			String errorNotice = "Provided array index=" + index + " (for 3-tuples) must be less than MFColor array length=" + MFColor.length / MFColorObject.TUPLE_SIZE;
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}		
		// http://stackoverflow.com/questions/12798611/splitting-a-hex-number
						 
		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;
						 
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "Illegal SFColor value (" + red + "," + green + "," + blue + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		MFColor[3*index + 0] = red;
		MFColor[3*index + 1] = green;
		MFColor[3*index + 2] = blue;
		return this;
	}
	/**
	 * Complement all color values in RGB space (i.e. subtract each component from 1).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementRGB ()
	{
		for (int index = 0; index+2 < MFColor.length; index = index + 3)
		{
			MFColor[3*index + 0] = 1.0f - MFColor[3*index + 0];
			MFColor[3*index + 1] = 1.0f - MFColor[3*index + 1];
			MFColor[3*index + 2] = 1.0f - MFColor[3*index + 2];
		}
		return this;
	}
	/**
	 * Ensure all component color values are within range [0-1] by clipping as necessary.
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public MFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalizeClip ()
	{
		for (int index = 0; index+2 < MFColor.length; index = index + 3)
		{
			if (MFColor[3*index + 0] < 0.0f) MFColor[3*index + 0] = 0.0f;
			if (MFColor[3*index + 1] < 0.0f) MFColor[3*index + 1] = 0.0f;
			if (MFColor[3*index + 2] < 0.0f) MFColor[3*index + 2] = 0.0f;
			if (MFColor[3*index + 0] > 1.0f) MFColor[3*index + 0] = 1.0f;
			if (MFColor[3*index + 1] > 1.0f) MFColor[3*index + 1] = 1.0f;
			if (MFColor[3*index + 2] > 1.0f) MFColor[3*index + 2] = 1.0f;
		}
		return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFColorRGBA')">
				<!-- TODO hex array constructor and accessors -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param index is position of selected value in current array
	 * @param hexColorValue The HTML color value (such as 0xAA2288) to apply
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ set1Value(int index, int hexColorValue, float alpha) throws ArrayIndexOutOfBoundsException
	{
		if (index < 0)
		{
			String errorNotice = "Index value is negative, thus cannot set1Value at index=" + index + ".";
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
		if (index >= MFColorRGBA.length / MFColorRGBAObject.TUPLE_SIZE) // tupleSize factor
		{
			String errorNotice = "Provided array index=" + index + " (for 4-tuples) must be less than MFColor array length=" + MFColorRGBA.length / MFColorRGBAObject.TUPLE_SIZE;
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
		
		// http://stackoverflow.com/questions/12798611/splitting-a-hex-number
						 
		float   red = ((hexColorValue>>16) & 0xff) / 255.0f;
		float green = ((hexColorValue>> 8) & 0xff) / 255.0f;
		float  blue = ((hexColorValue    ) & 0xff) / 255.0f;
						 
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha +
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		MFColorRGBA[4*index + 0] = red;
		MFColorRGBA[4*index + 1] = green;
		MFColorRGBA[4*index + 2] = blue;
		MFColorRGBA[4*index + 3] = alpha;
		return this;
	}
	/**
	 * Complement all color values of array in RGB space (i.e. subtract each component from 1).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementRGB ()
	{
		for (int index = 0; index+3 < MFColorRGBA.length; index = index + 4)
		{
			MFColorRGBA[4*index + 0] = 1.0f - MFColorRGBA[4*index + 0];
			MFColorRGBA[4*index + 1] = 1.0f - MFColorRGBA[4*index + 1];
			MFColorRGBA[4*index + 2] = 1.0f - MFColorRGBA[4*index + 2];
		}
		return this;
	}
	/**
	 * Complement each alpha value of array by subtracting it from 1, note transparency = (1 - alpha).
	 * @see <a href="https://en.wikipedia.org/wiki/Negative_(photography)">Wikipedia: Negative (photography)</a>
	 * @see <a href="https://en.wikipedia.org/wiki/Complementary_colors">Wikipedia: Complementary colors</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ complementAlpha ()
	{
		for (int index = 0; index+3 < MFColorRGBA.length; index = index + 4)
		{
			MFColorRGBA[4*index + 3] = 1.0f - MFColorRGBA[4*index + 3];
		}
		return this;
	}
	/**
	 * Ensure all component color values are within range [0-1] by clipping as necessary.
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Color" target="_blank">X3D Scene Authoring Hints: Color</a>
	 * @return {@link MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public MFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalizeClip ()
	{
		for (int index = 0; index+3 < MFColorRGBA.length; index = index + 4)
		{
			if (MFColorRGBA[4*index + 0] < 0.0f) MFColorRGBA[4*index + 0] = 0.0f;
			if (MFColorRGBA[4*index + 1] < 0.0f) MFColorRGBA[4*index + 1] = 0.0f;
			if (MFColorRGBA[4*index + 2] < 0.0f) MFColorRGBA[4*index + 2] = 0.0f;
			if (MFColorRGBA[4*index + 3] < 0.0f) MFColorRGBA[4*index + 3] = 0.0f;
			if (MFColorRGBA[4*index + 0] > 1.0f) MFColorRGBA[4*index + 0] = 1.0f;
			if (MFColorRGBA[4*index + 1] > 1.0f) MFColorRGBA[4*index + 1] = 1.0f;
			if (MFColorRGBA[4*index + 2] > 1.0f) MFColorRGBA[4*index + 2] = 1.0f;
			if (MFColorRGBA[4*index + 3] > 1.0f) MFColorRGBA[4*index + 3] = 1.0f;
		}
		return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFRotation')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method converting degrees to radians.
	 * @param angleDegrees value to convert
	 * @return angle value in radians
	 */
	public static float degreesToRadians (float angleDegrees)
	{
		return (float) (angleDegrees * Math.PI / 180.0);
	}
	/**
	 * Utility method converting degrees to radians.
	 * @param angleDegrees value to convert
	 * @return angle value in radians
	 */
	public static float degreesToRadians (int angleDegrees)
	{
		return (float) (angleDegrees * Math.PI / 180.0);
	}
	/**
	 * Utility method converting degrees to radians.
	 * @param angleDegrees value to convert
	 * @return angle value in radians
	 */
	public static float degreesToRadians (double angleDegrees)
	{
		return (float) (angleDegrees * Math.PI / 180.0);
	}
	/**
	 * Utility method converting radians to degrees.
	 * @param angleRadians value to convert
	 * @return angle value in degrees
	 */
	public static float radiansToDegrees (float angleRadians)
	{
		return (float) (angleRadians * 180.0 / Math.PI);
	}
	/**
	 * Utility method converting radians to degrees.
	 * @param angleRadians value to convert
	 * @return angle value in degrees
	 */
	public static float radiansToDegrees (double angleRadians)
	{
		return (float) (angleRadians * 180.0 / Math.PI);
	}
	/**
	 * Constructor using individual float types as new initial axis-angle value.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (float x, float y, float z, float angleRadians)
	{
		if ((x == 0.0f) && (y == 0.0f) && (z == 0.0f))
		{
			String errorNotice = "Illegal SFRotation value (" + x + "," + y + "," + z + "," + angleRadians + 
				") since (x,y,z) axis vector must have a direction and cannot be (0,0,0)";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		if (Math.abs(angleRadians) > 2.0 * Math.PI)
			System.err.println ("SFRotation constructor: questionable |angleRadians| > 2pi");
		SFRotation[0] = x;
		SFRotation[1] = y;
		SFRotation[2] = z;
		SFRotation[3] = angleRadians;
	}
	/**
	 * Constructor using individual double types as new initial axis-angle value.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (double x, double y, double z, double angleRadians)
	{
		if ((x == 0.0) && (y == 0.0) && (z == 0.0))
		{
			String errorNotice = "Illegal SFRotation value (" + x + "," + y + "," + z + "," + angleRadians + 
				") since (x,y,z) axis vector must have a direction and cannot be (0,0,0)";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		if (Math.abs(angleRadians) > 2.0 * Math.PI)
			System.err.println ("SFRotation constructor: questionable |angleRadians| > 2pi");
		SFRotation[0] = (float) x;
		SFRotation[1] = (float) y;
		SFRotation[2] = (float) z;
		SFRotation[3] = (float) angleRadians;
	}
	/**
	 * Constructor using individual integer types as new initial axis, along with float angle value.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ (int x, int y, int z, float angleRadians)
	{
		if ((x == 0) && (y == 0) && (z == 0))
		{
			String errorNotice = "Illegal SFRotation value (" + x + "," + y + "," + z + "," + angleRadians + 
				") since (x,y,z) axis vector must have a direction and cannot be (0,0,0)";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		if (Math.abs(angleRadians) > 2.0 * Math.PI)
			System.err.println ("SFRotation constructor: questionable |angleRadians| > 2pi");
		SFRotation[0] = (float) x;
		SFRotation[1] = (float) y;
		SFRotation[2] = (float) z;
		SFRotation[3] =         angleRadians;
	}
	/**
	 * Utility method to normalize this rotation value: unit length for axis-angle vector, angle in range [0-2pi] radians, rotation with zero-length axis is reset to DEFAULT_VALUE.
	 * @return {@link SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFRotation]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ normalize()
	{
		float length = (float) Math.sqrt(SFRotation[0]*SFRotation[0] + SFRotation[1]*SFRotation[1] + +SFRotation[2]*SFRotation[2]);
		if (length == 0.0f)
		{
			SFRotation = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text disable-output-escaping="yes"><![CDATA[
			System.err.println ("SFRotation.normalize(): zero-length axis encountered, reset entire SFRotation to DEFAULT_VALUE: " + DEFAULT_VALUE);
		}
		else
		{
			SFRotation[0] = SFRotation[0] / length;
			SFRotation[1] = SFRotation[1] / length;
			SFRotation[2] = SFRotation[2] / length;
			while (SFRotation[3] < 0.0f)
				   SFRotation[3] += 2.0f * Math.PI;
			while (SFRotation[3] >= 2.0f * Math.PI)
				   SFRotation[3] -= 2.0f * Math.PI;
		}
		return this;
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="starts-with($fieldName, 'SFVec')"><!-- both float and double types -->
				<xsl:variable name="typePrecision">
					<xsl:choose>
						<xsl:when test="ends-with($fieldName, 'f')">
							<xsl:text>float</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text>double</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
		<xsl:text>
	/**
	 * Utility constructor for </xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$jsaiClassSuffix"/>
	<xsl:text> using individual primitive values.</xsl:text>
				<xsl:choose>
					<xsl:when test="starts-with($fieldName, 'SFVec2')">
						<xsl:text><![CDATA[
	 * @param x first component of axis
	 * @param y second component of axis
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>Object (</xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> x, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> y)
	{
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = x;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = y;
	}
	/**
	 * Utility method to normalize this vector value to unit length, ignore if zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		</xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[1]);
		
		if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
		{
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] / length;
		}
		return this;
	}
</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName, 'SFVec3')">
						<xsl:text><![CDATA[
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>Object (</xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> x, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> y, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> z)
	{
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = x;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = y;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] = z;
	}
	/**
	 * Utility method to normalize this vector value to unit length, ignore if zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		</xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[2]);
		
		if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
		{
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] / length;
		}
		return this;
	}
</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName, 'SFVec4')">
						<xsl:text><![CDATA[
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param w fourth component
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>Object (</xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> x, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> y, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> z, </xsl:text>
	<xsl:value-of select="$typePrecision"/><xsl:text> w)
	{
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = x;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = y;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] = z;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[3] = w;
	}
	/**
	 * Utility method to normalize this vector value to unit length, ignore if zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		</xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] +
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[3]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[3]);
		
		if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
		{
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[2] / length;
			</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[3] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[3] / length;
		}
		return this;
	}
</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="starts-with($fieldName, 'MFVec')"><!-- both float and double types -->
				<xsl:variable name="typePrecision">
					<xsl:choose>
						<xsl:when test="ends-with($fieldName, 'f')">
							<xsl:text>float</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text>double</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:choose>
					<xsl:when test="starts-with($fieldName, 'MFVec2')">
						<xsl:text>
	/**
	 * Utility method to normalize vector values to unit length, ignore vector values with zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		for (int index = 0; index+</xsl:text><xsl:value-of select="$tupleSize"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ < ]]></xsl:text>
					<xsl:value-of select="$fieldName"/><xsl:text>.length; index = index + </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>)
		{
			</xsl:text><xsl:value-of select="$typePrecision"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[index+1]);
		
			if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
			{
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] / length;
			}
		}
		return this;
	}
</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName, 'MFVec3')">
						<xsl:text>
	/**
	 * Utility method to normalize vector values to unit length, ignore vector values with zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		for (int index = 0; index+</xsl:text><xsl:value-of select="$tupleSize"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ < ]]></xsl:text>
					<xsl:value-of select="$fieldName"/><xsl:text>.length; index = index + </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>)
		{
			</xsl:text><xsl:value-of select="$typePrecision"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[index+2]);
		
			if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
			{
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] / length;
			}
		}
		return this;
	}
</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($fieldName, 'MFVec4')">
						<xsl:text>
	/**
	 * Utility method to normalize vector values to unit length, ignore vector values with zero length.
	 * @return {@link </xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> normalize()
	{
		for (int index = 0; index+</xsl:text><xsl:value-of select="$tupleSize"/>
					<xsl:text disable-output-escaping="yes"><![CDATA[ < ]]></xsl:text>
					<xsl:value-of select="$fieldName"/><xsl:text>.length; index = index + </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>)
		{
			</xsl:text><xsl:value-of select="$typePrecision"/><xsl:text> length = </xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>(float)</xsl:text>
		</xsl:if>
		<xsl:text> Math.sqrt(
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] +
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+3]*</xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[[index+3]);
		
			if (length > 0.0]]></xsl:text>
		<xsl:if test="ends-with($fieldName, 'f')">
			<xsl:text>f</xsl:text>
		</xsl:if>
		<xsl:text>)
			{
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+0] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+1] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+2] / length;
				</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+3] = </xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[index+3] / length;
			}
		}
		return this;
	}
</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:when>
		</xsl:choose>
		
		<!-- Alternate utility constructors -->
		<xsl:choose>
			<xsl:when test="($fieldName = 'SFVec2f')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor for SFVec2fObject using double values.
	 * @param x first component
	 * @param y second component
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public SFVec2fObject (double x, double y)
	{
		setValue((float) x, (float) y);
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'SFVec3f')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor for SFVec3fObject using double values.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public SFVec3fObject (double x, double y, double z)
	{
		setValue((float) x, (float) y, (float) z);
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="($fieldName = 'SFVec4f')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility constructor for SFVec4fObject using double values.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param t fourth component
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public SFVec4fObject (double x, double y, double z, double t)
	{
		setValue((float) x, (float) y, (float) z, (float) t);
	}
]]></xsl:text>
			</xsl:when>
		</xsl:choose>
		<!-- Alternate type conversion utility methods -->
		<xsl:choose>
			<xsl:when test="(@type='SFColor')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type SFColor tuple size of <i>3</i>.
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param newValue The replacement value to assign.
	 */
	public void setValue(double[] newValue)
	{
		float[] floatArray = new float[newValue.length];
		for (int i = 0; i < newValue.length; i++)
			floatArray[i] = (float)newValue[i]; // cast each double to float
		setValue(floatArray);
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColorRGBA')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type SFColorRGBA tuple size of <i>4</i>.
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param newValue The replacement value to assign.
	 */
	public void setValue(double[] newValue)
	{
		float[] floatArray = new float[newValue.length];
		for (int i = 0; i < newValue.length; i++)
			floatArray[i] = (float)newValue[i]; // cast each double to float
		setValue(floatArray);
	}
]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFRotation')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 */
	public void setValue(float x, float y, float z, float angleRadians)
	{
		float[] floatArray = new float[4];
		floatArray[0] = x;
		floatArray[1] = y;
		floatArray[2] = z;
		floatArray[3] = angleRadians;
		
		setValue(floatArray);
	}
	/**
	 * Assign a new value to this field.
	 * <i>Warning</i>: angle must be in radians, if necessary use {@link #degreesToRadians(float) }
	 * @param x first component of axis
	 * @param y second component of axis
	 * @param z third component of axis
	 * @param angleRadians fourth component of rotation around axis
	 */
	public void setValue(double x, double y, double z, double angleRadians)
	{
		setValue((float) x, (float) y, (float) z, (float) angleRadians);
	}
	/**
	 * Assign a new value to this field. 
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type SFRotation tuple size of <i>4</i>.
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param newValue The replacement value to assign.
	 */
	public void setValue(double[] newValue)
	{
		float            x = (float) newValue[0];
		float            y = (float) newValue[1];
		float            z = (float) newValue[2];
		float angleRadians = (float) newValue[3];
		
		setValue(x, y, z, angleRadians);
	}
]]></xsl:text>
			</xsl:when>
		</xsl:choose>
		<!-- Alternate primitive constructors-->
		<xsl:choose>
			<xsl:when test="(@type = 'MFFloat') or (@type = 'MFVec2f') or (@type = 'MFVec3f') or (@type = 'MFVec4f') or
							(@type = 'SFColor') or (@type = 'SFColorRGBA') or (@type = 'MFColor') or (@type = 'MFColorRGBA') or 
							(@type = 'SFRotation') or (@type = 'MFRotation')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor for MFVec3fObject using an alternatively typed Java double[] array as new initial value.
	 * @param newValue is new value to assign
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
			<xsl:text>(double[] newValue)
	{
		setValue(newValue); // type conversion, doubles to floats
	}
</xsl:text>
			</xsl:when>
			<xsl:when test="(@type = 'MFDouble') or (@type = 'MFVec2d') or (@type = 'MFVec3d') or (@type = 'MFVec4d')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Constructor for MFVec3fObject using an alternatively typed float[] array as new initial value.
	 * @param newValue is new value to assign
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
			<xsl:text>(float[] newValue)
	{
		setValue(newValue); // type conversion, floats to doubles
	}
</xsl:text>
			</xsl:when>
		</xsl:choose>

		<!-- Source code: parse method -->
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Static utility method to provide String representation of a correctly typed input value.
	 * @param value The value to convert to a String
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>]]></xsl:text>
		<xsl:choose>
			<xsl:when test="(@type='MFFloat') or (@type='SFRotation') or (@type='MFRotation') or 
							contains(@type, 'Color') or 
							((contains(@type,'Vec') or contains(@type,'Matrix')) and ends-with(@type,'f'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see SFFloatObject#stripTrailingZeroes(float)
	 * @return String version of the provided value, with trailing zeroes and decimal points omitted.]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFDouble') or (@type='MFTime') or
							((contains(@type,'Vec') or contains(@type,'Matrix')) and ends-with(@type,'d'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see SFDoubleObject#stripTrailingZeroes(double)
	 * @return String version of the provided value, with trailing zeroes and decimal points omitted.]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFString') or (@type='MFString')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see SFStringObject#toStringX3D
	 * @see MFStringObject#toStringX3D
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/fieldsDef.html#SFStringAndMFString">X3D Abstract Specification: 5.3.14 SFString and MFString</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/EncodingOfFields.html#SFString">X3D XML Encoding: 5.15 SFString and MFString</a>
	 * @see <a href="http://www.web3d.org/x3d/content/X3dTooltips.html#Text">X3D Tooltips: Text</a>
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 * @return XML/X3D-escaped String version of the provided value]]></xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return String version of the provided value]]></xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 */
	public static String toString (]]></xsl:text>
	<xsl:value-of select="$javaType"/>
	<xsl:text> value)
	{</xsl:text>
	<xsl:choose>
		<xsl:when test="not(contains($javaType,'[]'))">
			<xsl:text>
		return String.valueOf(value);</xsl:text>
		</xsl:when>
		<xsl:when test="(@type='MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		String result = new String();
		for (String eachValue : value)
		{
			// http://www.regexplanet.com/advanced/java/index.html
			// https://www.regular-expressions.info/java.html see "backslash-mess"
			// https://docs.oracle.com/javase/tutorial/java/data/characters.html
			// append another quoted SFString value to MFString output
			result += " \"" + eachValue.replaceAll("&","&amp;")      // escape ampersands           in XML attributes
									   .replaceAll("<","&lt;")       // escape    less-than < signs in XML attributes
									   .replaceAll(">","&gt;")       // escape greater-than > signs in XML attributes
									   .replaceAll("'","&apos;")     // escape apostrophes since XML attributes in this output are delimited by apostrophes
									   .replaceAll("\\\\","\\\\")    // escape backslash \ as \\    in XML attributes
									   .replaceAll("\"",  "\\\\\"")  // escape     quote " as \"    in XML attributes
				    + "\"";
		}
		return (result.trim());]]></xsl:text>
		
		</xsl:when>
		<xsl:when test="(@type='MFFloat') or contains(@type,'Rotation') or contains(@type, 'Color') or
						 ends-with(@type,'2f') or ends-with(@type,'3f') or ends-with(@type,'4f')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder result = new StringBuilder();
		for (int i=0; i < value.length; i++)
		{
			if  (ConfigurationProperties.isStripTrailingZeroes())
				 result.append(org.web3d.x3d.jsail.fields.SFFloatObject.stripTrailingZeroes(value[i])).append(" ");
			else result.append(value[i]).append(" ");
		}
		return result.toString().trim();]]></xsl:text>
		</xsl:when>
		<xsl:when test="(@type='MFDouble') or (@type='MFTime') or
						 ends-with(@type,'2d') or ends-with(@type,'3d') or ends-with(@type,'4d')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder result = new StringBuilder();
		for (int i=0; i < value.length; i++)
		{
			if  (ConfigurationProperties.isStripTrailingZeroes())
				 result.append(org.web3d.x3d.jsail.fields.SFDoubleObject.stripTrailingZeroes(value[i])).append(" ");
			else result.append(value[i]).append(" ");
		}
		return result.toString().trim();]]></xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text disable-output-escaping="yes"><![CDATA[
		StringBuilder result = new StringBuilder();
		for (int i=0; i < value.length; i++)
		{
			result.append(value[i]).append(" ");
		}
		return result.toString().trim();]]></xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
	}
</xsl:text>

	<xsl:if test="(@type='SFString')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Static utility method to provide String representation of input String, properly escaped using XML-based X3D syntax.
	 * @param value The value to convert to an escaped String
	 * @see SFStringObject#toStringX3D
	 * @see MFStringObject#toStringX3D
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/fieldsDef.html#SFStringAndMFString">X3D Abstract Specification: 5.3.14 SFString and MFString</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/EncodingOfFields.html#SFString">X3D XML Encoding: 5.15 SFString and MFString</a>
	 * @see <a href="http://www.web3d.org/x3d/content/X3dTooltips.html#Text">X3D Tooltips: Text</a>
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 * @return XML/X3D-escaped String version of the provided value
	 */
	public static String toStringX3D (String value)
	{
		return (new SFStringObject(value)).toString()
				.replaceAll("&","&amp;")	// escape ampersands
				.replaceAll("<","&lt;")		// escape    less-than < signs
				.replaceAll(">","&gt;")		// escape greater-than > signs in XML attributes
				.replaceAll("'","&apos;")	// escape apostrophes since XML attributes in this output are delimited by apostrophes
				.replaceAll("\"","\\\"");	// escape embedded quotation marks
	}

	/**
	 * Provide String representation of this object, properly escaped for XML-based X3D syntax and conforming to X3D Canonical Form.
	 * @see SFStringObject#toStringX3D(String)
	 * @see MFStringObject#toStringX3D
	 * @see X3DObject#FILE_EXTENSION_X3D
	 * @see X3DObject#FILE_EXTENSION_XML
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString">X3D Tooltips: type SFString</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @return XML/X3D-escaped version of this SFString
	 */
	public String toStringX3D ()
	{
		return SFStringObject.toStringX3D(SFString); // apply escaping to member value of this object
	}
]]></xsl:text>
	</xsl:if>
	
	<!-- TODO handle quote marks at the individual string level, before quoted strings produced -->
	<xsl:if test="(@type='MFString')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Provide String representation of this object, properly escaped for XML-based X3D syntax and conforming to X3D Canonical Form.
	 * @see SFStringObject#toStringX3D
	 * @see SFStringObject#toStringX3D(String)
	 * @see X3DObject#FILE_EXTENSION_X3D
	 * @see X3DObject#FILE_EXTENSION_XML
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFString">X3D Tooltips: type MFString</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @return XML/X3D-escaped String version of this object
	 */
	public String toStringX3D ()
	{
		// avoid StringBuilder since it clobbers \"
		String result = new String();
		for (int i = 0; i < MFString.length; i++)
		{
			// MFString[0] // trace
			if (!MFString[i].startsWith("\""))
				result += "\"";
			// avoid SFStringObject.toStringX3D(MFString[i]) due to additional contrary handling of \" and &
			// http://www.regexplanet.com/advanced/java/index.html
			// https://www.regular-expressions.info/java.html see "backslash-mess"
			// https://docs.oracle.com/javase/tutorial/java/data/characters.html
			String escapedValue = MFString[i]
				.replaceAll("&","&amp;")      // escape ampersands           in XML attributes
				.replaceAll("<","&lt;")       // escape    less-than < signs in XML attributes
				.replaceAll(">","&gt;")       // escape greater-than > signs in XML attributes
				.replaceAll("'","&apos;")     // escape apostrophes since XML attributes in this output are delimited by apostrophes
				.replaceAll("\\\\","\\\\")    // escape backslash \ as \\    in XML attributes
			    .replaceAll("\"",  "\\\\\""); // escape     quote " as \"    in XML attributes 

			result += escapedValue;			// apply escaping to each SFString value
			if (!MFString[i].startsWith("\""))
				result += "\"";
			if (i < MFString.length - 1)
				result += " ";
		}
		return result;
	}
]]></xsl:text>
	</xsl:if>
	
	<xsl:choose>
		<xsl:when test="contains($fieldName,'FImage') or contains($fieldName,'FMatrix')">
			<!-- specialty methods defined later instead -->
		</xsl:when>
		<xsl:when test="contains($javaType,'[]')"> <!-- java array; may be SF type -->
<xsl:text><![CDATA[
	/**
	 * Get the current value of this ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text><![CDATA[ by copying it into the valueDestination array, leaving the current object unchanged.
	 * @param valueDestination The array to be filled in with current field values.
	 */
	@Override
	public void getValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ valueDestination)
	{
		valueDestination = ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[;
	}
]]></xsl:text>
		</xsl:when>
		<xsl:otherwise>
<xsl:text><![CDATA[
	/**
	 * Get the current value.
	 * @return current value
	 */
	@Override
	public ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ getValue()
	{
		return ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[;
	}
]]></xsl:text>
		</xsl:otherwise>
	</xsl:choose>

<!-- consistent utility method -->
<xsl:text><![CDATA[
	/**
	 * Provides current value of the field as a Java primitive type.
	 * @return current value
	 */
	public ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ getPrimitiveValue()
	{
		return ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[;
	}]]></xsl:text>

<!-- consistent utility method -->
<xsl:text><![CDATA[
	/**
	 * Provides current value as a String.
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[">X3D Tooltips: type ]]></xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text><![CDATA[</a>]]></xsl:text>
		<xsl:choose>
			<xsl:when test="(@type='MFFloat') or (@type='SFRotation') or (@type='MFRotation') or 
							contains(@type, 'Color') or 
							((contains(@type,'Vec') or contains(@type,'Matrix')) and ends-with(@type,'f'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see org.web3d.x3d.jsail.fields.SFFloatObject#stripTrailingZeroes(float)
	 * @return String version of the provided value, with trailing zeroes and decimal points omitted.]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='MFDouble') or (@type='MFTime') or
							((contains(@type,'Vec') or contains(@type,'Matrix')) and ends-with(@type,'d'))">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see org.web3d.x3d.jsail.fields.SFDoubleObject#stripTrailingZeroes(double)
	 * @return String version of the provided value, with trailing zeroes and decimal points omitted.]]></xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text disable-output-escaping="yes"><![CDATA[
	 * @return String version of the provided value]]></xsl:text>
			</xsl:otherwise>
		</xsl:choose>
<xsl:text><![CDATA[
	 */
	@Override
	public String toString()
	{
		]]></xsl:text>
	<xsl:choose>
		<xsl:when test="(@type = 'SFString')">
			<xsl:text>return </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>;</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'SFBool') or (@type = 'SFInt32') or (@type = 'SFDouble') or (@type = 'SFFloat') or (@type = 'SFTime')">
			<xsl:text>return String.valueOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>);</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[StringBuilder result = new StringBuilder();
		for (int i = 0; i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length; i++)
		{
			if (!</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes">[i].startsWith("\""))
				result.append("\"");
			result.append(String.valueOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes">[i]));
			if (!</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[[i].startsWith("\""))
				result.append("\"");
			if (i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - 1)
				result.append(" ");
		}
		return result.toString();</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFBool') or (@type = 'MFInt32') or (@type = 'MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[StringBuilder result = new StringBuilder();
		for (int i = 0; i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length; i++)
		{
			result.append(String.valueOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[[i]));
			if (i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - 1)
				result.append(" ");
		}
		return result.toString();</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFFloat') or ends-with(@type,'Color') or contains(@type,'Rotation') or
                         ends-with(@type,'2f') or ends-with(@type,'3f') or ends-with(@type,'4f')">
			<xsl:text disable-output-escaping="yes"><![CDATA[StringBuilder result = new StringBuilder();
		for (int i = 0; i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length; i++)
		{
			if  (ConfigurationProperties.isStripTrailingZeroes())
				 result.append(org.web3d.x3d.jsail.fields.SFFloatObject.stripTrailingZeroes(</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>[i]));
			else result.append(</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[[i]);
			if (i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - 1)
				result.append(" ");
		}
		return result.toString();</xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFDouble') or (@type = 'MFTime') or
                         ends-with(@type,'2d') or ends-with(@type,'3d') or ends-with(@type,'4d')">
			<xsl:text disable-output-escaping="yes"><![CDATA[StringBuilder result = new StringBuilder();
		for (int i = 0; i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length; i++)
		{
			if  (ConfigurationProperties.isStripTrailingZeroes())
				 result.append(org.web3d.x3d.jsail.fields.SFDoubleObject.stripTrailingZeroes(</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>[i]));
			else result.append(</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[[i]);
			if (i < ]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - 1)
				result.append(" ");
		}
		return result.toString();</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>return "TODO"; // unimplemented type toString()</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	
	<xsl:text><![CDATA[
	}]]></xsl:text>

   <xsl:if test="not(starts-with(@type,'MF')) and not(@type = 'SFImage') and not(contains(@type,'Matrix'))">
<xsl:text><![CDATA[
	/**
	 * Assign a new value to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param newValue The replacement value to assign.
	 */
	@Override
	public void setValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
	{
]]></xsl:text>		
		<!-- initial value checks -->
		<xsl:choose>
			<xsl:when test="starts-with(@type,'MF') and ends-with($javaType, '[]') and not($tupleSize = '1')">
				<xsl:value-of select="$newValueNullReturnVoid"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length % </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ != 0) // ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[-tuple check
		{
			String errorNotice = "Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must be multiple of ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="starts-with(@type,'SF') and ends-with($javaType, '[]') and not($tupleSize = '1')">
				<xsl:value-of select="$newValueNullReturnVoid"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length != </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[)
		{
			String errorNotice = "Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must equal ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
		<xsl:when test="ends-with($javaType, '[]')"><!-- ($tupleSize == 1) -->
			<xsl:value-of select="$newValueNullReturnVoid"/>
			<xsl:text disable-output-escaping="yes"><![CDATA[
		if (newValue == null)
			newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text disable-output-escaping="yes"><![CDATA[		]]></xsl:text><!-- indent -->
			</xsl:otherwise>
		</xsl:choose>
		<xsl:choose>
			<xsl:when test="(@type = 'SFRotation')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		float            x = newValue[0];
		float            y = newValue[1];
		float            z = newValue[2];
		float angleRadians = newValue[3];
		if ((x == 0.0f) && (y == 0.0f) && (z == 0.0f))
		{
			String errorNotice = "Illegal SFRotation value (" + x + "," + y + "," + z + "," + angleRadians + 
				") since (x,y,z) axis vector must have a direction and cannot be (0,0,0)";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		if (Math.abs(angleRadians) > 2.0 * Math.PI)
			System.err.println ("SFRotation constructor: questionable |angleRadians| > 2pi");
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColor')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// initial value checks
		float   red = newValue[0];
		float green = newValue[1];
		float  blue = newValue[2];
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "Illegal SFColor value (" + red + "," + green + "," + blue + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
			<xsl:when test="(@type='SFColorRGBA')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
		// initial value checks
		float   red = newValue[0];
		float green = newValue[1];
		float  blue = newValue[2];	
		float alpha = newValue[3];	
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
			</xsl:when>
				<xsl:when test="(@type='MFTime')">
					<xsl:text disable-output-escaping="yes"><![CDATA[
		for (int i = 0; i < newValue.length; i++)
		{
			if ((newValue[i] < 0.0) && (newValue[i] != SFTimeObject.DEFAULT_VALUE)) // initial value check
			{
				newValue[i] = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
			}
		}
		]]></xsl:text>
			</xsl:when>
		</xsl:choose>		
	<xsl:if test="not($isSingletonType = 'true')">
		<xsl:text>if (newValue.length != </xsl:text>
		<xsl:value-of select="$tupleSize"/>
		<xsl:text><![CDATA[)
		{
			String errorNotice = "newValue.length=" + newValue.length + " is not equal to ]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ tuple size=" + ]]></xsl:text>
		<xsl:value-of select="$tupleSize"/><xsl:text disable-output-escaping="yes"><![CDATA[;
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
		]]></xsl:text>
	</xsl:if>
	<xsl:value-of select="$fieldName"/>
	<xsl:text><![CDATA[ = newValue;
	}
]]></xsl:text>
   </xsl:if>
					<xsl:if test="starts-with(@type,'MF') and not(@type = 'MFImage') and not(contains(@type, 'FMatrix'))">
						<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* <p>
* Get an individual value from the existing field array.
* </p><p>
* If the index is outside the bounds of the current array of data values, an ArrayIndexOutOfBoundsException is thrown.
* </p>
* @param index is position of selected value in current array]]></xsl:text>
<xsl:choose>
	<xsl:when test="($isSingletonType = 'true')">
		<xsl:text>
* @return The selected value</xsl:text>
	</xsl:when>
	<xsl:otherwise>
		<xsl:text>
* @param destinationValue where to place result for selected value</xsl:text>		
	</xsl:otherwise>
</xsl:choose>
<xsl:text disable-output-escaping="yes"><![CDATA[
* @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
*/
@Override
public ]]></xsl:text>
	<xsl:choose>
		<xsl:when test="($isSingletonType = 'true')">
			<xsl:value-of select="$javaPrimitiveType"/>
			<xsl:text> get1Value(int index)</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>void get1Value(int index, </xsl:text>
			<xsl:value-of select="$javaPrimitiveType"/>
			<xsl:text> destinationValue)</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text disable-output-escaping="yes"><![CDATA[
{
	if (index < 0)
	{
		String errorNotice = "Index value is negative, thus cannot get1Value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ == 0)
	{
		String errorNotice = "Value array is empty, thus cannot get1Value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (index >= ]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:value-of select="$dimensionSuffix"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="$tupleSize"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[) // tupleSize factor
	{
		String errorNotice = "Provided array index=" + index + " must be less than ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ array length=" + ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="$tupleSize"/>
	<xsl:text><![CDATA[;
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	]]></xsl:text>
	<xsl:choose>
		<xsl:when test="($isSingletonType = 'true')">
			<xsl:text>return </xsl:text>
			<xsl:choose>
				<xsl:when test="not(contains($javaPrimitiveType,'['))">
					<xsl:value-of select="$fieldName"/>
					<xsl:text>[index];</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$fieldName"/>
					<xsl:text>;</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>destinationValue = Arrays.copyOfRange(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, index * </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text>, (index * </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text>) + </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text> - 1); // tupleSize factor </xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
}
</xsl:text>
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign an array subset to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
* @param newValue The replacement value array to (potentially) slice and then assign.
*/
@Override
public void setValue(int size, ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ newValue)
{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:value-of select="$newValueSizeCheck"/>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	for (int i = 0; i < newValue.length; i++)
	{
		if ((newValue[i] < 0.0) && (newValue[i] != SFTimeObject.DEFAULT_VALUE)) // initial value check
		{
			newValue[i] = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
		}
	}]]></xsl:text>
	</xsl:if>
	<xsl:text><![CDATA[
	]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ = Arrays.copyOf(newValue, size); // array size slicing
}
]]></xsl:text>

	<xsl:if test="not(contains($javaType,'['))">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a new array value to this field.
* @param newValue is replacement value array to assign
*/
public void setValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[[] newValue)
{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:value-of select="$fieldName"/>
	<xsl:text><![CDATA[ = newValue; // TODO verify
	
}
]]></xsl:text>
	</xsl:if>
	<xsl:if test="(@type = 'MFRotation') or contains(@type,'FVec')">
		<!-- also add methods for square arrays -->
<xsl:text disable-output-escaping="yes"><![CDATA[
  /**
   * Get the current value of this ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text><![CDATA[ by copying it into the valueDestination array, leaving the current object unchanged.
   */
  @Override
  public void getValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[[] valueDestination)
  {
	// TODO square array adjustment //// valueDestination = ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[;
  }

/**
* Assign an array subset to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
* @param newValue The replacement value array to (potentially) slice and then assign.
*/
@Override
public void setValue(int size, ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[[] newValue)
{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:value-of select="$newValueSizeCheck"/>
	<xsl:text><![CDATA[
	// TODO array size slicing, handle double subscripts
}
]]></xsl:text>		
	</xsl:if>
	
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a new ]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ value to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
* <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param newValue is replacement value array to assign
*/	
public void setValue(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ newValue)
{
	if (newValue == null)
		newValue = new ]]></xsl:text>
		<xsl:value-of select="substring-before($javaType,'[]')"/>
		<xsl:text>[0];
	</xsl:text>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	for (int i = 0; i < newValue.length; i++)
	{
		if ((newValue[i] < 0.0) && (newValue[i] != SFTimeObject.DEFAULT_VALUE)) // initial value check
		{
			newValue[i] = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
		}
	}
	]]></xsl:text>
	</xsl:if>
		<xsl:value-of select="$fieldName"/>
		<xsl:text> = new </xsl:text>
		<xsl:choose>
			<xsl:when test="contains($javaPrimitiveType,'[')">
				<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$javaPrimitiveType"/>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>[newValue.length]; // reset array size
	</xsl:text>
	<xsl:choose>
		<xsl:when test="(@type = 'MFString')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
			for (int i=0; i < newValue.length; i++)
			{
				]]></xsl:text><xsl:value-of select="$fieldName"/>
					<xsl:text>[i] = cleanupUnescapedEnclosingQuotes(newValue[i]); // fill array
			}</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = newValue;</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
}
</xsl:text>
	<!-- additional type-conversion utility methods -->
	<xsl:choose>
		<xsl:when test="(@type = 'MFFloat') or (@type = 'MFVec2f') or (@type = 'MFVec3f') or (@type = 'MFVec4f') or
						(@type = 'SFColor') or (@type = 'SFColorRGBA') or (@type = 'MFColor') or (@type = 'MFColorRGBA') or 
						(@type = 'SFRotation') or (@type = 'MFRotation') or (@type = 'MFMatrix3f') or (@type = 'MFMatrix4f')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a double-precision array value to this single-precision field.
* <br ><br >
* <i>Warning:</i> this method casts type of input values from higher precision to lower precision.
* <br ><br >]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param newValue is replacement value array to assign
* @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
*/	
public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> setValue(double[] newValue)
{
	if (newValue == null)
		newValue = new double[0];
	</xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ = new float[newValue.length]; // reset array size
	for (int i = 0; i < newValue.length; i++)
		]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[[i] = (float) newValue[i]; // cast types for new array
	return this;
}]]></xsl:text>
		</xsl:when>
		<xsl:when test="(@type = 'MFDouble') or (@type = 'MFVec2d') or (@type = 'MFVec3d') or (@type = 'MFVec4d') or
						(@type = 'MFMatrix3d') or (@type = 'MFMatrix4d')">
			<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a single-precision floating-point array value to this double-precision field.
* <br ><br >
* <i>Warning:</i> this method casts type of input values from lower precision to higher precision.
* <br ><br >]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param newValue is replacement value array to assign
* @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
*/	
public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text> setValue(float[] newValue)
{
	if (newValue == null)
		newValue = new float[0];
	</xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ = new double[newValue.length]; // reset array size
	for (int i = 0; i < newValue.length; i++)
		]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[[i] = (double) newValue[i]; // cast types for new array
	return this;
}]]></xsl:text>
		</xsl:when>
	</xsl:choose>
	
	<xsl:if test="starts-with(@type, 'MF')">
	
		<xsl:if test="(@type = 'MFBool') or (@type = 'MFInt32') or (@type = 'MFDouble') or (@type = 'MFFloat') or (@type = 'MFTime')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Assign a single ]]></xsl:text><xsl:value-of select="substring-before($javaType,'[]')"/><xsl:text><![CDATA[ value as new array (of length 1).
* @param newValue The replacement value to assign.
*/	
public void setValue(]]></xsl:text><xsl:value-of select="substring-before($javaType,'[]')"/><xsl:text><![CDATA[ newValue)
{
	]]></xsl:text>
	
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	if ((newValue < 0.0) && (newValue != SFTimeObject.DEFAULT_VALUE)) // initial value check
	{
		newValue = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
	}
	]]></xsl:text>
	</xsl:if>
		<xsl:value-of select="$fieldName"/>
		<xsl:text disable-output-escaping="yes"><![CDATA[ = new ]]></xsl:text>
		<xsl:value-of select="substring-before($javaType,'[]')"/>
		<xsl:text>[1]; // create array
	</xsl:text>
		<xsl:value-of select="$fieldName"/>
		<xsl:text>[0] = newValue;
}
</xsl:text>
	</xsl:if>

<xsl:text>
/**
* Assign a single-field S</xsl:text>
	<xsl:value-of select="substring(@type, 2)"/>
	<xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ as new array value.
* @param newValue The replacement value to assign.
* @return {@link ]]></xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
method invocations on the same node object).
*/	
public ]]></xsl:text>
<xsl:value-of select="$fieldName"/>
<xsl:value-of select="$jsaiClassSuffix"/>
<xsl:text> setValue(S</xsl:text><xsl:value-of select="substring(@type, 2)"/><xsl:text><![CDATA[Object newValue)
{
	if (newValue == null)
	{
		]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		return this;
	}
	</xsl:text>
		<xsl:choose>
			<xsl:when test="contains(@type,'FVec') and ends-with(@type,'d')">
				<xsl:text>setValue(newValue.toDoubleArray()); // create array</xsl:text>
			</xsl:when>
			<xsl:when test="contains(@type,'Color') or contains(@type,'Rotation') or contains(@type,'FVec') or starts-with(@type,'SFMatrix')">
				<xsl:text>setValue(newValue.toFloatArray()); // create array
		</xsl:text>
			</xsl:when>
			<xsl:when test="starts-with(@type,'MFMatrix')">
				<xsl:text>// TODO matrix initialization
		</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$fieldName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ = new ]]></xsl:text>
				<xsl:value-of select="substring-before($javaType,'[]')"/>
				<xsl:text>[1]; // create (or else clear) previous contents
	</xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>[0] = newValue.getValue();</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	<xsl:text>
	return this;
}
</xsl:text>
	</xsl:if>

<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Replace a single value at the appropriate location in the existing value array.
* Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param index is position of selected value in current array
* @param newValue provides new value to apply
*/
@Override
public void set1Value(int index, ]]></xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text><![CDATA[ newValue) throws ArrayIndexOutOfBoundsException
{
	if (index < 0)
	{
		String errorNotice = "Index value is negative, thus cannot set1Value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ == 0)
	{
		String errorNotice = "Value array is empty, thus cannot set1Value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}]]></xsl:text>
	<xsl:if test="not($tupleSize = '1')">
		<xsl:text><![CDATA[
		if      (newValue == null)
			     newValue = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		else if (newValue.length != </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[)
		{
			String errorNotice = "Illegal ]]></xsl:text>
				<xsl:value-of select="@type"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ newValue array length=" + newValue.length +
				", must equal ]]></xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[ or else be empty (newValue=" + toString(newValue) + ")";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}]]></xsl:text>
	</xsl:if>
	<xsl:text><![CDATA[
	if (index >= ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="$tupleSize"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[) // tupleSize factor
	{
		String errorNotice = "Provided array index=" + index + " must be less than ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ array length=" + ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/>
	<xsl:text> / </xsl:text>
	<xsl:value-of select="$tupleSize"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[;
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	]]></xsl:text>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	if ((newValue < 0.0) && (newValue != SFTimeObject.DEFAULT_VALUE)) // initial value check
	{
		newValue = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
	}
	]]></xsl:text>
	</xsl:if>
	<xsl:choose>
		<xsl:when test="starts-with(@type, 'MF') and ($tupleSize = 1)">
			<xsl:value-of select="$fieldName"/><xsl:text>[index] = newValue;</xsl:text>
		</xsl:when>
		<xsl:when test="starts-with(@type, 'MF')"><!-- $tupleSize > 1 -->
			<xsl:text>int offset = 0;
	for (</xsl:text><xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/><xsl:text> value : newValue)
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>[index + offset] = value;
		offset++;
	}</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>// TODO copy or insert newValue to index position</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text><![CDATA[
}

/**
* Places new value(s) at the end of the existing value array, increasing the field length accordingly.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
* <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param newValue The newValue to append
*/
@Override
public void append(]]></xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text><![CDATA[ newValue)
{]]></xsl:text>
			<!-- newValue size check -->
			<xsl:choose>
				<xsl:when test="($fieldName = 'MFNode') or ($fieldName = 'MFString')">
					<!-- no size check needed -->
					<xsl:text>
	</xsl:text>
				</xsl:when>
				<xsl:when test="not($fieldName = 'MFDouble') and not($fieldName = 'MFFloat') and not($fieldName = 'MFInt32') and
						  not($fieldName = 'MFBool') and not($fieldName = 'MFTime')">
					<xsl:text>
	if ((newValue.length % </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) != 0) // tupleSize modulus check
	{
		String errorNotice = "illegal number of values (" + newValue.length + ")" +
			" in initialization array, must be multiple of </xsl:text>
					<xsl:value-of select="$tupleSize"/><xsl:text> when declaring new </xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text>Object(" + newValue + ")";
		validationResult.append(errorNotice).append("\n");
		throw new InvalidFieldValueException (errorNotice);
	}
	</xsl:text>
				</xsl:when>
				<xsl:otherwise>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	if ((newValue < 0.0) && (newValue != SFTimeObject.DEFAULT_VALUE)) // initial value check
	{
		newValue = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
	}]]></xsl:text>
	</xsl:if>
					<xsl:text>
	</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="not(not(contains($javaPrimitiveType,'[')) and ($tupleSize = '1'))"> <!-- opposite of below -->
				<xsl:text>int originalLength = </xsl:text>
				<xsl:value-of select="$fieldName"/>
				<xsl:text>.length;
				</xsl:text>
			</xsl:if>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text>
			<xsl:text>Arrays.copyOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length + </xsl:text>
			<xsl:choose>
				<xsl:when test="contains($javaPrimitiveType,'[')">
					<xsl:text>newValue.length</xsl:text><!-- array -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$tupleSize"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>); // increase array size for append
	</xsl:text>
			<xsl:choose>
				<xsl:when test="not(contains($javaPrimitiveType,'[')) and ($tupleSize = '1')">
					<xsl:value-of select="$fieldName"/>
					<xsl:text>[</xsl:text><xsl:value-of select="$fieldName"/><xsl:text><![CDATA[.length-1] = newValue;]]></xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text><![CDATA[for (int i = 0; i < newValue.length; i++)
	{
		]]></xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text>[originalLength + i] = newValue[i];
	}</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>
}
</xsl:text>
			<xsl:if test="($fieldName = 'MFDouble') or ($fieldName = 'MFFloat') or ($fieldName = 'MFInt32') or
						  ($fieldName = 'MFBool')   or ($fieldName = 'MFTime')  or ($fieldName = 'MFNode') or
						  ($fieldName = 'MFString')">
			<xsl:text disable-output-escaping="yes"><![CDATA[/**
* Appends another array at the end of the existing value array, increasing the field length accordingly.
* <i>Warning:</i> newValue array length must correspond to tuple size for base type MFVec4f tuple size of <i>4</i>.
* @see X3DConcreteField#getTupleSize(String)
* @param newValue The newValue to append
*/
public void append(]]></xsl:text><xsl:value-of select="$javaType"/><xsl:text><![CDATA[ newValue)
{
	if ((newValue.length % ]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) != 0) // tupleSize modulus check
	{
		String errorNotice = "illegal number of values (" + newValue.length + ")" +
			" in initialization array, must be multiple of 4 when declaring new MFVec4fObject(" + newValue + ")";
		validationResult.append(errorNotice).append("\n");
		throw new InvalidFieldValueException (errorNotice);
	}
	</xsl:text>
			<xsl:text>int originalLength = </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length;
	</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text>
			<xsl:text>Arrays.copyOf(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length + </xsl:text>
			<xsl:choose>
				<xsl:when test="contains($javaPrimitiveType,'[') or starts-with($fieldName,'MF')">
					<xsl:text>newValue.length</xsl:text><!-- array -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$tupleSize"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text><![CDATA[); // increase array size for append
	for (int i = 0; i < newValue.length; i++)
	{
		]]></xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>[originalLength + i] = newValue[i];
	}
}
</xsl:text>
			</xsl:if>
			
			<xsl:variable name="javaSingletonType">
				<xsl:text>S</xsl:text>
				<xsl:value-of select="substring(@type,2)"/>
			</xsl:variable>
			<xsl:variable name="thisClassName">
				<xsl:value-of select="$fieldName"/>
				<xsl:value-of select="$jsaiClassSuffix"/>
			</xsl:variable>
			<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Appends a new singleton typed value at the end of the existing value array, increasing the field length accordingly.
* <i>Note:</i> this method can be useful for incrementally constructing arrays.
* @param newValue The newValue to append
* @return {@link ]]></xsl:text>
				<xsl:value-of select="$thisClassName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
*/
public ]]></xsl:text>
				<xsl:value-of select="$thisClassName"/><xsl:text> append(</xsl:text><xsl:value-of select="$javaSingletonType"/><xsl:value-of select="$jsaiClassSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
{
	append(newValue.getPrimitiveValue());
	return this;
}
]]></xsl:text>

				<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Appends a new ]]></xsl:text><xsl:value-of select="$thisClassName"/><xsl:text><![CDATA[ to the end of the existing value array, increasing the field length accordingly.
* <i>Note:</i> this method can be useful for constructing long arrays.
* @see X3DConcreteField#getTupleSize(String)
* @param newValue The newValue to append
* @return {@link ]]></xsl:text>
				<xsl:value-of select="$thisClassName"/>
				<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
*/
public ]]></xsl:text>
				<xsl:value-of select="$thisClassName"/><xsl:text> append(</xsl:text><xsl:value-of select="$thisClassName"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
{
	append(newValue.getPrimitiveValue());
	return this;
}
]]></xsl:text>

			<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param index The position for the inserted value in the current array
* @param newValue The newValue to insert
*/
@Override
public void insertValue(int index, ]]></xsl:text><xsl:value-of select="$javaPrimitiveType"/><xsl:text disable-output-escaping="yes"><![CDATA[ newValue)
{
	if (index < 0)
	{
		String errorNotice = "Index value is negative, thus cannot insertValue at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}]]></xsl:text>
			<!-- newValue size check -->
			<xsl:choose>
				<xsl:when test="($fieldName = 'MFNode') or ($fieldName = 'MFString')">
					<!-- no size check needed -->
				</xsl:when>
				<xsl:when test="not($fieldName = 'MFDouble') and not($fieldName = 'MFFloat') and not($fieldName = 'MFInt32') and
						  not($fieldName = 'MFBool') and not($fieldName = 'MFTime')">
					<xsl:text>
	if (newValue.length != </xsl:text><xsl:value-of select="$tupleSize"/><xsl:text>) // array size check, account for tupleSize
	{
		String errorNotice = "illegal number of values (" + newValue.length + ")" +
			" for insertValue newValue array, must equal </xsl:text>
					<xsl:value-of select="$tupleSize"/><xsl:text> for </xsl:text>
					<xsl:value-of select="$fieldName"/>
					<xsl:text>insertValue(" + newValue + ")";
		validationResult.append(errorNotice).append("\n");
		throw new InvalidFieldValueException (errorNotice);
	}
	</xsl:text>
				</xsl:when>
			</xsl:choose>
			<!-- bounds check -->
			<xsl:text><![CDATA[
	if (index >= ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length)
	{
		String errorNotice = "Provided array index=" + index + " must be less than ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ array length=" + ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length;
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	]]></xsl:text>
	<xsl:if test="(@type='MFTime')">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	if ((newValue < 0.0) && (newValue != SFTimeObject.DEFAULT_VALUE)) // initial value check
	{
		newValue = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
	}]]></xsl:text>
	</xsl:if>
	<xsl:text>
	int sliceLength = </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length - index;
	</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text>
			<xsl:text>Arrays.copyOf(</xsl:text><xsl:value-of select="$fieldName"/>
			<xsl:text>, </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>.length + </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text>); // increase array size for insert
	System.arraycopy(</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, index, </xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>, index + </xsl:text>
			<xsl:value-of select="$tupleSize"/>
			<xsl:text>, sliceLength); // move second half of array to right
	</xsl:text>
	<xsl:choose>
		<xsl:when test="starts-with(@type, 'MF') and ($tupleSize = 1)">
			<xsl:value-of select="$fieldName"/><xsl:text>[index] = newValue;</xsl:text>
		</xsl:when>
		<xsl:when test="starts-with(@type, 'MF')"><!-- $tupleSize > 1 -->
			<xsl:text>int offset = 0;
	for (</xsl:text><xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/><xsl:text> value : newValue)
	{
		</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>[index + offset] = value;
		offset++;
	}</xsl:text>
		</xsl:when>
		<xsl:otherwise>
			<xsl:text>// TODO copy or insert newValue to index position</xsl:text>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text>
}
</xsl:text>
	<xsl:if test="(@type = 'MFTime')">
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
* Places a new value at the end of the existing value array, increasing the field length accordingly.
* @param newValue The newValue to append
*/
@Override
public void append(long newValue)
{
	if ((newValue < 0) && ((double)newValue != SFTimeObject.DEFAULT_VALUE)) // initial value check
	{
		 append(SFTimeObject.DEFAULT_VALUE); // unusual occurrence, TODO log it
	}
	else append((double) newValue);
}
	
/**
* Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
* @param index The position for the inserted value in the current array
* @param newValue The newValue to insert
*/
@Override
public void insertValue(int index, long newValue)
{
	if ((newValue < 0) && ((double)newValue != SFTimeObject.DEFAULT_VALUE)) // initial value check
	{
		 insertValue(index, SFTimeObject.DEFAULT_VALUE); // unusual occurrence, TODO log it
	}
	else insertValue(index, (double) newValue);
}
		
/**
* Replace a single value at the appropriate location in the existing value array.
* Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param index is position of selected value in current array
* @param newValue provides new value to apply
*/
@Override
public void set1Value(int index, long newValue) throws ArrayIndexOutOfBoundsException
{
	if ((newValue < 0) && ((double)newValue != SFTimeObject.DEFAULT_VALUE)) // initial value check
	{
		 set1Value(index, SFTimeObject.DEFAULT_VALUE); // unusual occurrence, TODO log it
	}
	else set1Value(index, (double) newValue);
}
		
/**
* Replace values at the appropriate location in the existing value array.
* Size of the current underlying value array does not change.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
* @see X3DConcreteField#getTupleSize(String)
* @param index is position of selected value in current array
* @param newValue provides new value to apply
*/
@Override
public void setValue(int index, long[] newValue) throws ArrayIndexOutOfBoundsException
{
	double[] doubleTimeValues = new double[newValue.length];
	for (int i=0; i < newValue.length; i++)
	{
		if ((newValue[i] < 0) && ((double)newValue[i] != SFTimeObject.DEFAULT_VALUE)) // initial value check
		{
			 doubleTimeValues[i] = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
		}
		else doubleTimeValues[i] = newValue[i];
	}
	setValue(index, doubleTimeValues);
}
]]></xsl:text>
	</xsl:if>
<xsl:text disable-output-escaping="yes"><![CDATA[
/**
 * Get the size of the underlying data array, meaning the number of
 * simple S]]></xsl:text><xsl:value-of select="substring($fieldName,2)"/><xsl:text disable-output-escaping="yes"><![CDATA[ elements for the given data type.
 *
 * @return The number of S]]></xsl:text><xsl:value-of select="substring($fieldName,2)"/><xsl:text disable-output-escaping="yes"><![CDATA[ elements in this field array.
 */
@Override
public int size()
{
	return ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[;
}

/**
 * Removes all values in the field array, changing the array size to zero.
 */
@Override
public void clear()
{
	]]></xsl:text>
	<xsl:value-of select="$fieldName"/>
	<xsl:text disable-output-escaping="yes"><![CDATA[ = new ]]></xsl:text>
	<xsl:choose>
		<xsl:when test="contains($javaPrimitiveType,'[')">
			<xsl:value-of select="substring-before($javaPrimitiveType,'[')"/>
		</xsl:when>
		<xsl:otherwise>
			<xsl:value-of select="$javaPrimitiveType"/>
		</xsl:otherwise>
	</xsl:choose>
	<xsl:text disable-output-escaping="yes"><![CDATA[[0];
}

/**
 * Remove one S]]></xsl:text><xsl:value-of select="substring($fieldName,2)"/><xsl:text disable-output-escaping="yes"><![CDATA[ element of the field array at index position, if found.  Initial element is at index 0.
 * @param index position of element in field array that gets removed
 */
@Override
public void remove(int index)
{
	if (index < 0)
	{
		String errorNotice = "Index value is negative, thus cannot remove() value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$dimensionSuffix"/><xsl:text disable-output-escaping="yes"><![CDATA[ == 0)
	{
		String errorNotice = "Value array is empty, thus cannot remove value at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	if (index >= ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length)
	{
		String errorNotice = "Provided array index=" + index + " must be less than ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ array length=" + ]]></xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length;
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	int offsetLength = ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>.length - (index + 1) * </xsl:text>
		<xsl:value-of select="$tupleSize"/><xsl:text>; // account for tupleSize
	System.arraycopy(</xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>, (index + 1) * </xsl:text>
		<xsl:value-of select="$tupleSize"/><xsl:text>, </xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text>, index * </xsl:text>
		<xsl:value-of select="$tupleSize"/><xsl:text>, offsetLength); // copy over element being removed
	</xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text> = Arrays.copyOfRange(</xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text>, 0, </xsl:text>
	<xsl:value-of select="$fieldName"/><xsl:text>.length - </xsl:text>
	<xsl:value-of select="$tupleSize"/><xsl:text>); // finally reduce overall array size by one tuple
}
</xsl:text>
					</xsl:if>

					<!-- specialized utility methods for field types in Java SAI specification -->
					<xsl:choose>
						<xsl:when test="(@type = 'SFTime')">
<xsl:text><![CDATA[	
/**
*	Get the current value.
* 	@return current value
*/
@Override
public long getJavaValue()
{
	return (long)SFTime;
}	
/**
* Assign a new value, converting seconds from (long) to (double).
* @param newValue The replacement value to assign.
*/
@Override
public void setValue(long newValue)
{
	SFTime = (double)newValue;
	if ((SFTime < 0.0) && (SFTime != DEFAULT_VALUE)) // initial value check
	{
		SFTime = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
	}
}
</xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'MFTime')">
					<xsl:text><![CDATA[
/**
 * <p>
 * Get an individual value from the existing field array.
 * </p><p>
 * If the index is outside the bounds of the current array of data values,
 * an ArrayIndexOutOfBoundsException is thrown.
 * </p>
 * @param index is position of selected value in current array
 * @return The selected value
 * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
 */
@Override
public long get1JavaValue(int index)
{
	if (index < 0)
	{
		String errorNotice = "Index value is negative, thus cannot get1JavaValue at index=" + index + ".";
		validationResult.append(errorNotice).append("\n");
		throw new ArrayIndexOutOfBoundsException(errorNotice);
	}
	return (long)MFTime[index];
}

/**
* Assign a new value array, converting seconds from (long) to (double).
* @param newValue is replacement value array to assign
*/
@Override
public void setValue(long[] newValue)
{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:text><![CDATA[
	// create new array and cast each value
	MFTime = new double[newValue.length];
	for (int i=0; i < newValue.length; i++)
	{
		if ((newValue[i] < 0) && ((double)newValue[i] != SFTimeObject.DEFAULT_VALUE)) // initial value check
		{
			 MFTime[i] = SFTimeObject.DEFAULT_VALUE; // unusual occurrence, TODO log it
		}
		else MFTime[i] = (double)newValue[i];
	}
}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="starts-with(@type,'MFColor')">
							<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	@Override
	public void getValue(float[][] valueDestination)
	{
		// TODO
	}

    /**
     * Assign an array subset to this field.]]></xsl:text>
	 <xsl:if test="not($tupleSize = '1')">
		<xsl:text disable-output-escaping="yes"><![CDATA[
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="@type"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.]]></xsl:text>
	 </xsl:if>
	 <xsl:text disable-output-escaping="yes"><![CDATA[
	 * @see X3DConcreteField#getTupleSize(String)
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */
	@Override
	public void setValue(int size, float[][] newValue)
	{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:value-of select="$newValueSizeCheck"/>
	<xsl:text><![CDATA[
		// TODO
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test = "(@type = 'SFImage')">
							<xsl:text><![CDATA[
    /**
     * Get the width of the image.
     * @throws InvalidFieldValueException Invalid SFImage data found
     * @return The width of the image in pixels
     */
	@Override
	public int getWidth()
	{
		if  ((SFImage == null) || (SFImage.length < 3))
		{
			String errorNotice = "Null array or illegal data length for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}		
		int      width = SFImage[0];
		int     height = getHeight();
		if ((width < 0) || (height < 0))
		{
			String errorNotice = "Illegal negative value: width=" + width + ", height=" + height + 
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}		
		return SFImage[0];
	}

    /**
     * Get the height of the image.
     * @throws InvalidFieldValueException Invalid SFImage data found
     * @return The height of the image in pixels
     */
	@Override
	public int getHeight()
	{
		if  ((SFImage == null) || (SFImage.length < 3))
		{
			String errorNotice = "Null array or illegal data length for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}		
		int      width = getWidth();
		int     height = SFImage[1];
		if ((width < 0) || (height < 0))
		{
			String errorNotice = "Illegal negative value: width=" + width + ", height=" + height + 
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}		
		return SFImage[1];
	}

    /**
     * Get the number of color components in the image. The value will
     * always be between 1 and 4 indicating the number of components of
     * the color specification to be read from the image pixel data.
     * @throws InvalidFieldValueException Invalid SFImage data found
     * @return The number of components
     */
	@Override
	public int getComponents()
	{
		if  ((SFImage == null) || (SFImage.length < 3))
		{
			String errorNotice = "Null array or illegal data length for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}		
		int components = SFImage[2];
		if ((components < 1) || (components > 4))
		{
			String errorNotice = "Illegal value, must be in range [1..4]: number of components=" + components + 
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		return SFImage[2];
	}

    /**
     * Get the image pixel value in the given eventOut.
     * <p>
     * The number of items in the pixels array will be
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     * @param destinationPixels The array to copy pixel values into
     * @throws InvalidFieldValueException Invalid SFImage data found
     */
	@Override
	public void getPixels(int[] destinationPixels)
	{
		if  ((SFImage == null) || (SFImage.length < 3))
		{
			String errorNotice = "Null array or illegal data length for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}		
		int      width = getWidth();
		int     height = getHeight();
		int components = getComponents(); // includes error checks
		destinationPixels = new int[SFImage.length];	
		if ((width == 0) || (height == 0) || (components == 0))
		{
			destinationPixels = new int[0];
		}
		else if (SFImage.length > 3)
		{
			destinationPixels = new int[width * height * components];			// TODO necessary?
			destinationPixels = Arrays.copyOfRange(SFImage, 3, SFImage.length); // TODO verify
		}
		else
		{
			String errorNotice = "Illegal value for SFImage field type, getPixels() cannot get pixel array";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}

    /**
     * Fetch the Java representation of the underlying image from these pixels.
     * This is the same copy that the browser uses to generate texture
     * information from.
     * @return The image reference representing the current state
     */
	@Override
	public java.awt.image.WritableRenderedImage getImage()
	{
		return null; // TODO
	}

    /**
     * Set the image value in the given writable field to the new image defined
     * by a set of pixels.
     * <p>
     * @param image The new image to use as the source
     */
	@Override
	public void setImage(java.awt.image.RenderedImage image)
	{
		// TODO
	}

    /**
	 * Copy a region of the argument RenderedImage to replace a portion of the
	 * current SFimage.
	 * <p>
	 * The sub image set shall not resize the base image representation and
	 * therefore performs an intersection clip of the provided image. The user
	 * provided image shall be of the same format (pixel depth, pixel
	 * representation) as the original image obtained through the getImage()
	 * method.
	 * <p>
	 * RenderedImages are row order from top to bottom. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 0 |********|
	 * 1 |********|
	 * 2 |********|
	 * 3 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * SFImages are row order from bottom to top. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 3 |********|
	 * 2 |********|
	 * 1 |********|
	 * 0 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * <p>
	 * Note: The parameter srcYOffset is referenced to the RenderedImage object
	 * (indexed top to bottom).
	 * <br>
	 * The parameter destYOffset is referenced to the SFImage object
	 * (indexed bottom to top).
	 *
	 * @param image The new image to use as the source
	 * @param sourceWidth The width of the argument sub-image region to copy
	 * @param sourceHeight The height of the argument sub-image region to copy
	 * @param sourceXOffset The initial x dimension (width) offset into the
	 * argument sub-image that begins the region to copy
	 * @param sourceYOffset The initial y dimension (height) offset into the
	 * argument sub-image that begins the region to copy
	 * @param destinationXOffset The initial x dimension (width) offset in the SFimage
	 * object that begins the region to receive the copy
	 * @param destinationYOffset The initial y dimension (height) offset in the SFimage
	 * object that begins the region to receive the copy
	 */
	@Override
	public void setSubImage(java.awt.image.RenderedImage image,
                            int sourceWidth,
                            int sourceHeight,
                            int sourceXOffset,
                            int sourceYOffset,
                            int destinationXOffset,
                            int destinationYOffset)
	{
		// TODO
	}

    /**
     * Set the image value in the given writable field.
     * <p>
     * Image values are specified using a width, height and the number of
     * components. The number of items in the pixels array must be at least
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components. If the integer
     * contains values in bytes that are not used by the number of components
     * for that image, the values are ignored.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     *
     * @param width The width of the image in pixels
     * @param height The height of the image in pixels
     * @param components The number of color components [1-4]
     * @param pixels The array of pixel values as specified above.
     * @exception IllegalArgumentException The number of components or width/
     *    height are illegal values.
     * @exception ArrayIndexOutOfBoundsException The number of pixels provided by the
     *    caller is not enough for the width * height.
     * @throws IllegalArgumentException Invalid parameter(s) provided, no change was made
     */
	@Override
	public void setValue(int width,
                         int height,
                         int components,
                         int[] pixels)
	{
		if ((width < 0) || (height < 0))
		{
			String errorNotice = "Illegal negative value: width=" + width + ", height=" + height + 
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
		if ((components < 1) || (components > 4))
		{
			String errorNotice = "Illegal value, must be in range [1..4]: number of components=" + components + 
				" for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
		if (((width * height * components) > 0) && (pixels.length < (width * height)))
		{
			String errorNotice = "Illegal number of pixels: pixels.length=" + pixels.length +
				", (width * height * components) = " + width + " * " + components + " * " + components + ") = " + 
				(width * height * components) + " for SFImage field type";
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}					
		SFImage = new int[3 + (width * height)];
		SFImage[0] = width;
		SFImage[1] = height;
		SFImage[2] = components;
		System.arraycopy(pixels, 0, SFImage, 3, pixels.length);
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test = "(@type = 'MFImage')">
							<xsl:text><![CDATA[
    /**
     * Get the width of the image array.
     * @param imageIndex the index of the selected image
     * @return The width of the image in pixels
     */
	@Override
	public int getWidth(int imageIndex)
	{
		return 0; // TODO access correct image, return value
	}

    /**
     * Get the height of the image array.
     * @param imageIndex the index of the selected image
     * @return The height of the image in pixels
     */
	@Override
	public int getHeight(int imageIndex)
	{
		return 0; // TODO access correct image, return value
	}

    /**
     * Get the number of color components in the image. The value will
     * always be between 1 and 4 indicating the number of components of
     * the color specification to be read from the image pixel data.
     * @param imageIndex the index of the selected image
     * @return The number of components
     */
	@Override
	public int getComponents(int imageIndex)
	{
		return 0; // TODO access correct image, return value
	}

    /**
     * Get the image pixel value in the given eventOut.
     * <p>
     * The number of items in the pixels array will be
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     * @param imageIndex the index of the selected image
     * @param pixels The array to copy pixel values into
     */
	@Override
	public void getPixels(int imageIndex, int[] pixels)
	{
		// TODO
	}

    /**
     * Fetch the Java representation of the underlying image from these pixels.
     * This is the same copy that the browser uses to generate texture
     * information from.
     * @param imageIndex the index of the selected image
     * @return The image reference representing the current state
     */
	@Override
	public WritableRenderedImage getImage(int imageIndex)
	{
		return null; // TODO
	}

    /**
     * Set the image value in the given writable field to the new image defined
     * by a set of pixels.
     * @param imageIndex the index of the selected image
     * @param image The new image to use as the source
     */
	@Override
	public void setImage(int imageIndex, RenderedImage image)
	{
		// TODO
	}

    /**
	 * Copy a region of the argument RenderedImage to replace a portion of the
	 * current SFimage.
	 * <p>
	 * The sub image set shall not resize the base image representation and
	 * therefore performs an intersection clip of the provided image. The user
	 * provided image shall be of the same format (pixel depth, pixel
	 * representation) as the original image obtained through the getImage()
	 * method.
	 * <p>
	 * RenderedImages are row order from top to bottom. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 0 |********|
	 * 1 |********|
	 * 2 |********|
	 * 3 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * SFImages are row order from bottom to top. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 3 |********|
	 * 2 |********|
	 * 1 |********|
	 * 0 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * <p>
	 * Note: The parameter srcYOffset is referenced to the RenderedImage object
	 * (indexed top to bottom).
	 * <br>
	 * The parameter destYOffset is referenced to the SFImage object
	 * (indexed bottom to top).
	 *
	 * @param imageIndex the index of the selected image
	 * @param image The new image to use as the source
	 * @param sourceWidth The width of the argument sub-image region to copy
	 * @param sourceHeight The height of the argument sub-image region to copy
	 * @param sourceXOffset The initial x dimension (width) offset into the
	 * argument sub-image that begins the region to copy
	 * @param sourceYOffset The initial y dimension (height) offset into the
	 * argument sub-image that begins the region to copy
	 * @param destinationXOffset The initial x dimension (width) offset in the SFimage
	 * object that begins the region to receive the copy
	 * @param destinationYOffset The initial y dimension (height) offset in the SFimage
	 * object that begins the region to receive the copy
	 */
	@Override
	public void setSubImage(int imageIndex,
		RenderedImage image,
		int sourceWidth,
		int sourceHeight,
		int sourceXOffset,
		int sourceYOffset,
		int destinationXOffset,
		int destinationYOffset)
	{
		// TODO
	}

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param imageIndex the index of the selected image
     * @param newValue provides new value to apply
     */
	@Override
	public void set1Value(int imageIndex, int newValue)
	{
		// TODO
	}

	@Override
	public void set1Value(int imageIndex,
		int width,
		int height,
		int components,
		int[] pixels)
	{
		// TODO
	}

    /**
     * Assign a new value array containing imageIndex, width, height, and components count, followed by array of pixels.
     * @param newValue The newValue to set
     */	
	@Override
	public void setValue(int[] newValue)
	{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:text><![CDATA[
		// TODO
	}

	@Override
	public void setImage(RenderedImage[] image)
	{
		// TODO
	}

    /**
     * Places a new SFImage value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	@Override
	public void append(RenderedImage[] newValue)
	{
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:text><![CDATA[
		// TODO
	}

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	@Override
	public void insertValue(int index, RenderedImage newValue)
	{
		if (index < 0)
		{
			String errorNotice = "Index value is negative, thus cannot insertValue at index=" + index + ".";
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
]]></xsl:text>
	<xsl:value-of select="$newValueNullExceptionCheck"/>
	<xsl:text><![CDATA[
		// TODO
	}
	/**
	 * Remove one S]]></xsl:text><xsl:value-of select="substring($fieldName,2)"/><xsl:text disable-output-escaping="yes"><![CDATA[ element of the field array at index position, if found.  Initial element is at index 0.
	 * @param index position of element in field array that gets removed
	 */
	@Override
	public void remove (int index)
	{
		if (index < 0)
		{
			String errorNotice = "Index value is negative, thus cannot remove value at index=" + index + ".";
			validationResult.append(errorNotice).append("\n");
			throw new ArrayIndexOutOfBoundsException(errorNotice);
		}
		// TODO compute offset factor
		if (index >= ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length)
		{
			String errorNotice = "Provided array index=" + index + " must be less than ]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ array length=" + ]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length;
			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
		// TODO remove (int index)
	}
	/**
	 * Removes all values in the field array, changing the array size to zero.
	 */
	@Override
	public void clear()
	{
		]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[ = new ]]></xsl:text><xsl:value-of select="substring-before($javaType,'[')"/><xsl:text disable-output-escaping="yes"><![CDATA[[0];
	}
	/**
	 * Get the size of the underlying data array. The size is the number of
	 * elements for that data type. So for an MFFloat the size would be the
	 * number of float values, but for an MFVec3f, it is the number of vectors
	 * in the returned array (where a vector is 3 consecutive array indexes in
	 * a flat array).
	 *
	 * @return The number of elements in this field array.
	 */
	@Override
	public int size()
	{
		return ]]></xsl:text>
		<xsl:value-of select="$fieldName"/><xsl:text disable-output-escaping="yes"><![CDATA[.length;
	}
]]></xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFMatrix3f') or (@type = 'MFMatrix3f')">
						<xsl:text disable-output-escaping="yes"><![CDATA[
	@Override
	public void setIdentity()
	{
		// TODO
	}

	@Override
	public void set(int row, int column)
	{
		// TODO
	}

	@Override
	public float get(int row, int column)
	{
		return 0.0f; // TODO
	}

	@Override
	public void setTransform(SFVec3f translation,
		SFRotation rotation,
		SFVec3f scale,
		SFRotation scaleOrientation,
		SFVec3f center)
	{
		// TODO
	}

	@Override
	public void getTransform(SFVec3f translation,
		SFRotation rotation,
		SFVec3f scale)
	{
		// TODO
	}

	@Override
	public Matrix3 inverse()
	{
		return null; // TODO
	}

	@Override
	public Matrix3 transpose()
	{
		return null; // TODO
	}

	@Override
	public Matrix3 multiplyLeft (Matrix3 matrix3x3)
	{
		return null; // TODO
	}

	@Override
	public Matrix3 multiplyRight(Matrix3 matrix3x3)
	{
		return null; // TODO
	}
	@Override
	public Matrix3 multiplyRowVector(SFVec3f vector3f) // TODO SFVec4f ?
	{
		return null; // TODO
	}

	@Override
	public Matrix3 multiplyColVector(SFVec3f vector3f) // TODO SFVec4f ?
	{
		return null; // TODO
	}
]]></xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFMatrix3d') or (@type = 'MFMatrix3d')">
						<xsl:text disable-output-escaping="yes"><![CDATA[
	@Override
	public void setIdentity()
	{
		// TODO
	}

	@Override
	public void set(int row, int column)
	{
		// TODO
	}

	@Override
	public float get(int row, int column)
	{
		return 0.0f; // TODO
	}

	@Override
	public void setTransform(SFVec3d translation,
		SFRotation rotation,
		SFVec3d scale,
		SFRotation scaleOrientation,
		SFVec3d center)
	{
		// TODO
	}

	@Override
	public void getTransform(SFVec3d translation,
		SFRotation rotation,
		SFVec3d scale)
	{
		// TODO
	}

	@Override
	public Matrix3 inverse()
	{
		return null; // TODO
	}

	@Override
	public Matrix3 transpose()
	{
		return null; // TODO
	}

	@Override
	public Matrix3 multiplyLeft (Matrix3 matrix3x3)
	{
		return null; // TODO
	}

	@Override
	public Matrix3 multiplyRight(Matrix3 matrix3x3)
	{
		return null; // TODO
	}
	@Override
	public Matrix3 multiplyRowVector(SFVec3d vector3d) // TODO SFVec4d ?
	{
		return null; // TODO
	}

	@Override
	public Matrix3 multiplyColVector(SFVec3d vector3d) // TODO SFVec4d ?
	{
		return null; // TODO
	}
]]></xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFMatrix4f') or (@type = 'MFMatrix4f')">
						<xsl:text disable-output-escaping="yes"><![CDATA[
	@Override
	public void setIdentity()
	{
		// TODO
	}

	@Override
	public void set(int row, int column)
	{
		// TODO
	}

	@Override
	public float get(int row, int column)
	{
		return 0.0f; // TODO
	}

	@Override
	public void setTransform(SFVec3f translation,
		SFRotation rotation,
		SFVec3f scale,
		SFRotation scaleOrientation,
		SFVec3f center)
	{
		// TODO
	}

	@Override
	public void getTransform(SFVec3f translation,
		SFRotation rotation,
		SFVec3f scale)
	{
		// TODO
	}

	@Override
	public Matrix4 inverse()
	{
		return null; // TODO
	}

	@Override
	public Matrix4 transpose()
	{
		return null; // TODO
	}

	@Override
	public Matrix4 multiplyLeft (Matrix4 matrix3x3)
	{
		return null; // TODO
	}

	@Override
	public Matrix4 multiplyRight(Matrix4 matrix3x3)
	{
		return null; // TODO
	}
	@Override
	public Matrix4 multiplyRowVector(SFVec3f vector3f) // TODO SFVec4f ?
	{
		return null; // TODO
	}

	@Override
	public Matrix4 multiplyColVector(SFVec3f vector3f) // TODO SFVec4f ?
	{
		return null; // TODO
	}
]]></xsl:text>
					</xsl:when>
					<xsl:when test="(@type = 'SFMatrix4d') or (@type = 'MFMatrix4d')">
						<xsl:text disable-output-escaping="yes"><![CDATA[
	@Override
	public void setIdentity()
	{
		// TODO
	}

	@Override
	public void set(int row, int column)
	{
		// TODO
	}

	@Override
	public float get(int row, int column)
	{
		return 0.0f; // TODO
	}

	@Override
	public void setTransform(SFVec3d translation,
		SFRotation rotation,
		SFVec3d scale,
		SFRotation scaleOrientation,
		SFVec3d center)
	{
		// TODO
	}

	@Override
	public void getTransform(SFVec3d translation,
		SFRotation rotation,
		SFVec3d scale)
	{
		// TODO
	}

	@Override
	public Matrix4 inverse()
	{
		return null; // TODO
	}

	@Override
	public Matrix4 transpose()
	{
		return null; // TODO
	}

	@Override
	public Matrix4 multiplyLeft (Matrix4 matrix3x3)
	{
		return null; // TODO
	}

	@Override
	public Matrix4 multiplyRight(Matrix4 matrix3x3)
	{
		return null; // TODO
	}
	@Override
	public Matrix4 multiplyRowVector(SFVec3d vector3d) // TODO SFVec4d ?
	{
		return null; // TODO
	}

	@Override
	public Matrix4 multiplyColVector(SFVec3d vector3d) // TODO SFVec4d ?
	{
		return null; // TODO
	}
]]></xsl:text>
					</xsl:when>
					</xsl:choose>
					
					<!-- additional utility methods for field types in jsail -->
					<!-- setValue convenience methods -->
					<xsl:choose>
						<xsl:when test="(@type = 'SFBool')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to negate this boolean value.
	 * @return {@link SFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ negate()
	{
		SFBool = !SFBool; // negate
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'MFBool')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to negate this array of boolean values.
	 * @return {@link MFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public MFBool]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ negate()
	{
		for (int i= 0; i < MFBool.length; i++)
		{
			MFBool[i] = !MFBool[i]; // negate
		}
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFFloat')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Apply a double value to this float field type, note change in precision.
	 * @param newValue The double newValue to apply
	 * @return {@link SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[  setValue(double newValue)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = (float) newValue;
		return this;
	}

	/**
	 * Apply an int value to this float field type, note change in precision.
	 * @param newValue The int newValue to apply
	 * @return {@link SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFFloat]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[  setValue(int newValue)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = (float) newValue;
		return this;
	}

	/**
	 * Utility method to strip trailing fractional zeroes from String representations of the current object's value.
	 * Applicability: first converting an integer (such as 100) to float and then String results in trailing decimal point and zero (such as
100.0).
	 * Functionality can be globally enabled/disabled by {@link ConfigurationProperties#setStripTrailingZeroes(boolean)}.
	 * @see <a href="http://stackoverflow.com/questions/14984664/remove-trailing-zero-in-java">StackOverflow: Remove trailing zero in Java</a>
	 * @see <a href="http://stackoverflow.com/questions/11284938/remove-trailing-zeros-from-double">StackOverflow: Remove trailing zeros from double (String manipulation solution)</a>
	 * @see <a href="http://stackoverflow.com/questions/703396/how-to-nicely-format-floating-numbers-to-string-without-unnecessary-decimal-0">StackOverflow: How to nicely format floating numbers to String without unnecessary decimal 0? (&quot;In short&quot; solution)</a>
	 * @see <a href="https://library.oreilly.com/book/0636920023630/regular-expressions-cookbook-2nd-edition/275.xhtml">Regular Expressions Cookbook, 6.6. Strip Leading Zeros, by Jan Goyvaerts, Steven Levithan</a>
	 * @return string value with trailing zeros and decimal points stripped
	 */
	public String stripTrailingZeroes()
	{
		return stripTrailingZeroes(getValue());
	}

	/**
	 * Utility method to always strip trailing fractional zeroes from String value of any given float.
	 * Applicability: first converting an integer (such as 100) to float and then String results in trailing decimal point and zero (such as 100.0).
	 * <i>Note:</i> not affected by {@link ConfigurationProperties#setStripTrailingZeroes(boolean)}.
	 * @param value a single-precision number
	 * @see #stripTrailingZeroes(float)
	 * @return string value with trailing zeros and decimal points stripped
	 */
	public static String stripTrailingZeroes(float value)
	{
		String stringValue = String.valueOf(value);
		if (stringValue.contains(".") && !stringValue.contains("E") && !stringValue.contains("e"))
			 // regex to strip trailing zeroes, then strip trailing decimal point (if no other fractional part remains)
			 return stringValue.replaceAll("[0]*$", "").replaceAll("\\.$", "");
		else return stringValue; // avoided values with decimal point or exponential scientific notation
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFDouble') or (@type = 'SFTime')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Apply a float value to this double field type, note change in precision.
	 * @param newValue The float newValue to apply
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> setValue(float newValue)
	{
		</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = (double) newValue;
		return this;
	}

	/**
	 * Apply an int value to this double field type, note change in precision.
	 * @param newValue The float newValue to apply
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> setValue(int newValue)
	{
		</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = (double) newValue;
		return this;
	}

	/**
	 * Utility method to strip trailing fractional zeroes from String representations of the current object's value.
	 * Applicability: first converting an integer (such as 100) to double and then String results in trailing decimal point and zero (such as
100.0).
	 * Functionality can be globally enabled/disabled by {@link ConfigurationProperties#setStripTrailingZeroes(boolean)}.
	 * @see <a href="http://stackoverflow.com/questions/14984664/remove-trailing-zero-in-java">StackOverflow: Remove trailing zero in Java</a>
	 * @see <a href="http://stackoverflow.com/questions/11284938/remove-trailing-zeros-from-double">StackOverflow: Remove trailing zeros from double (String manipulation solution)</a>
	 * @see <a href="http://stackoverflow.com/questions/703396/how-to-nicely-format-floating-numbers-to-string-without-unnecessary-decimal-0">StackOverflow: How to nicely format floating numbers to String without unnecessary decimal 0? (&quot;In short&quot; solution)</a>
	 * @see <a href="https://library.oreilly.com/book/0636920023630/regular-expressions-cookbook-2nd-edition/275.xhtml">Regular Expressions Cookbook, 6.6. Strip Leading Zeros, by Jan Goyvaerts, Steven Levithan</a>
	 * @return string value with trailing zeros and decimal points stripped
	 */
	public String stripTrailingZeroes()
	{
		return stripTrailingZeroes(getValue());
	}
	/**
	 * Utility method to always strip trailing fractional zeroes from String value of any given double.
	 * Applicability: first converting an integer (such as 100) to double and then String results in trailing decimal point and zero (such as 100.0).
	 * <i>Note:</i> not affected by {@link ConfigurationProperties#setStripTrailingZeroes(boolean)}.
	 * @param value a double-precision number
	 * @see #stripTrailingZeroes(double)
	 * @return string value with trailing zeros and decimal points stripped
	 */
	public static String stripTrailingZeroes(double value)
	{
		String stringValue = String.valueOf(value);
		if (stringValue.contains(".") && !stringValue.contains("E") && !stringValue.contains("e"))
			 // regex to strip trailing zeroes, then strip trailing decimal point (if no other fractional part remains)
			 return stringValue.replaceAll("[0]*$", "").replaceAll("\\.$", "");
		else return stringValue; // avoided values with decimal point or exponential scientific notation
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'MFTime')">
	<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a single float value as new double array (of length 1).
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float newValue)
	{
		setValue((double) newValue); // apply checks
		return this;
	}
	/**
	 * Assign a float array as new double array.
	 * @param newValue is new value to assign
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float[] newValue)
	{
		if (newValue == null)
		{
			initialize();
		}
		else
		{
			double[] doubleArray = new double[newValue.length]; // fix array size
			for (int i=0; i < newValue.length; i++)
				doubleArray[i] = (double) newValue[i];
			setValue(doubleArray); // apply checks
		}
		return this;
	}
]]></xsl:text>		
						</xsl:when>
						<xsl:when test="(@type = 'SFVec2d')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @return {@link SFVec2d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFVec2d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec3d')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @return {@link SFVec3d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFVec3d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y, double z)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = z;
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec4d')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param t third component
	 * @return {@link SFVec4d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFVec4d]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y, double z, double t)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = z;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[3] = t;
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec2f')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @return {@link SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float x, float y)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		return this;
	}
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @return {@link SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFVec2f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y)
	{
		setValue((float) x, (float) y);
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec3f')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @return {@link SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float x, float y, float z)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = z;
		return this;
	}
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @return {@link SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFVec3f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y, double z)
	{
		
		setValue((float) x, (float) y, (float) z);
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFColor')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float red, float green, float blue)
	{
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f))
		{
			String errorNotice = "Illegal SFColor value (" + red + "," + green + "," + blue + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = red;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = green;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = blue;
		return this;
	}

	/**
	 * Assign a new value to this field.
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @return {@link SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColor]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double red, double green, double blue)
	{
		setValue ((float) red, (float) green, (float) blue);
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFColorRGBA')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float red, float green, float blue, float alpha)
	{
		if ((red < 0.0f) || (red > 1.0f) || (green < 0.0f) || (green > 1.0f) || (blue < 0.0f) || (blue > 1.0f) || (alpha < 0.0f) || (alpha > 1.0f))
		{
			String errorNotice = "Illegal SFColorRGBA value (" + red + "," + green + "," + blue + "," + alpha + 
				"), all values must be in numeric range [0..1]";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = red;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = green;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text disable-output-escaping="yes"><![CDATA[[2] = blue;
		return this;
	}
	/**
	 * Assign a new value to this field.
	 * @param red first component
	 * @param green second component
	 * @param blue third component
	 * @param alpha fourth component for opaqueness (1 - transparency)
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double red, double green, double blue, double alpha)
	{
		setValue ((float) red, (float) green, (float) blue, (float) alpha);
		return this;
	}
	/**
	 * Utility method to modify transparency
	 * @param newTransparency value [0..1]
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setTransparency (float newTransparency)
	{
		if ((newTransparency < 0.0f) || (newTransparency > 1.0f))
		{
			String errorNotice = "Illegal SFColorRGBA transparency value=" + newTransparency + 
												 ", must be within numeric range [0..1] inclusive";
			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
		SFColorRGBA[3] = newTransparency;
		return this;
	}
	/**
	 * Utility method to modify transparency
	 * @param newTransparency value [0..1]
	 * @return {@link SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFColorRGBA]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setTransparency (double newTransparency)
	{
		setTransparency ((float) newTransparency);
		return this;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="(@type = 'SFVec4f')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param t fourth component
	 * @return {@link SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(float x, float y, float z, float t)
	{
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[0] = x;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[1] = y;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[2] = z;
		]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[[3] = t;
		return this;
	}
	/**
	 * Assign a new value to this field.
	 * @param x first component
	 * @param y second component
	 * @param z third component
	 * @param t fourth component
	 * @return {@link SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public SFVec4f]]></xsl:text><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[ setValue(double x, double y, double z, double t)
	{
		setValue((float) x, (float) y, (float) z, (float) t);
		return this;
	}
]]></xsl:text>
						</xsl:when>
					</xsl:choose>
					<!-- primitive array methods -->
					<xsl:choose>
						<xsl:when test="contains(@type,'FVec2f')    or contains(@type,'FVec3f')    or contains(@type,'FVec4f')    or
										contains(@type,'FMatrix2f') or contains(@type,'FMatrix3f') or contains(@type,'FMatrix4f') or
										contains(@type,'MFFloat')   or contains(@type,'FColor')    or contains(@type,'FRotation')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Provide float array for this field type.
	 *
	 * @return Array of floats in this field array.
	 */
	public float[] toFloatArray()
	{
		return ]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[;
	}
]]></xsl:text>
						</xsl:when>
						<xsl:when test="contains(@type,'FVec2d')    or contains(@type,'FVec3d')    or contains(@type,'FVec4d')    or
										contains(@type,'FMatrix2d') or contains(@type,'FMatrix3d') or contains(@type,'FMatrix4d') or
										contains(@type,'MFTime')    or contains(@type,'MFDouble')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Provide double array for this field type.
	 * @return Array of doubles in this field array.
	 */
	public double[] toDoubleArray()
	{
		return ]]></xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[;
	}
]]></xsl:text>
						</xsl:when>
					</xsl:choose>
					
					<!-- common field accessor: setValue using another field of same type -->
					<xsl:text><![CDATA[
	/**
	 * Apply an ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[ value to this field.
	 * @param newValue The newValue to apply
	 * @return {@link ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> setValue(</xsl:text>
							<xsl:value-of select="@type"/>
							<xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
							<xsl:text> newValue)
	{
		if (newValue == null)
		{
			</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text> = </xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
			return this;
		}
		</xsl:text>
							<xsl:value-of select="$fieldName"/>
							<xsl:text><![CDATA[ = newValue.getPrimitiveValue();
		return this;
	}								
]]></xsl:text>
					<!-- additional fieldObject utility classes -->
					<xsl:choose>
						<xsl:when test="($fieldName = 'SFNode')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to clear all contained children including nodes, statements and comments (if any).
	 * @return {@link SFNodeObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public SFNodeObject clearChildren()
	{
		SFNode = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		return this;
	}
</xsl:text>
						</xsl:when>
						<xsl:when test="($fieldName = 'MFNode')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to clear all contained children including nodes, statements and comments (if any).
	 * @return {@link MFNodeObject} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public MFNodeObject clearChildren()
	{
		MFNode = ]]></xsl:text><xsl:value-of select="$defaultValueExpression"/><xsl:text>
		return this;
	}
</xsl:text>
						</xsl:when>
						<xsl:when test="contains($fieldName,'SFVec')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Multiply scaleFactor times all values in this field type.
	 * @param scaleFactor scalar value for vector multiplication
	 * @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> multiply(</xsl:text>
					 <xsl:value-of select="$javaPrimitiveType"/>
					 <xsl:text> scaleFactor)
	{
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[0] *= scaleFactor;
		</xsl:text><xsl:value-of select="$fieldName"/><xsl:text>[1] *= scaleFactor;
		</xsl:text>
		<xsl:choose>
			<xsl:when test="contains($fieldName,'3')">
				<xsl:value-of select="$fieldName"/><xsl:text>[2] *= scaleFactor;
		</xsl:text>
			</xsl:when>
			<xsl:when test="contains($fieldName,'4')">
				<xsl:value-of select="$fieldName"/><xsl:text>[2] *= scaleFactor;
		</xsl:text>
				<xsl:value-of select="$fieldName"/><xsl:text>[3] *= scaleFactor;
		</xsl:text>
			</xsl:when>
		</xsl:choose>
		<xsl:text>
		return this;
	}
</xsl:text>
						<!-- TODO also write type-specific addOffset methods -->
						</xsl:when>
						<xsl:when test="contains($fieldName,'MFVec') or contains($fieldName,'Matrix') or 
												($fieldName = 'MFInt32') or ($fieldName = 'MFFloat') or ($fieldName = 'MFDouble')">
							<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Multiply scaleFactor times all values in this field type.
	 * @param scaleFactor scalar value for vector multiplication
	 * @return {@link ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text disable-output-escaping="yes"><![CDATA[} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:value-of select="$jsaiClassSuffix"/><!-- append to type name -->
					 <xsl:text> multiply(</xsl:text>
					 <xsl:choose>
						 <xsl:when test="contains($javaPrimitiveType,'[]')">
							<xsl:value-of select="substring-before($javaPrimitiveType,'[]')"/>
						 </xsl:when>
						 <xsl:otherwise>
							<xsl:value-of select="$javaPrimitiveType"/>
						 </xsl:otherwise>
					 </xsl:choose>
					 <xsl:text disable-output-escaping="yes"><![CDATA[ scaleFactor)
	{
		for (int i = 0; i < ]]></xsl:text><xsl:value-of select="$fieldName"/><xsl:text>.length; i++)
		{
			</xsl:text>
			<xsl:value-of select="$fieldName"/>
			<xsl:text>[i] *= scaleFactor;
		}
		return this;
	}
</xsl:text>
						<!-- TODO also write type-specific addOffset methods -->
						</xsl:when>
					</xsl:choose>
					
					<!-- class implementation definitions are complete -->
				</xsl:with-param>
			</xsl:call-template>
		
		</xsl:for-each>
		
			<!-- concrete implementation customization classes -->
		
			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:text>X3DConcreteField</xsl:text></xsl:with-param>
				<xsl:with-param name="imports">
					<xsl:text>import java.util.ArrayList;
import org.web3d.x3d.sai.X3DFieldEventListener;
import org.web3d.x3d.jsail.Core.*;</xsl:text>
				</xsl:with-param>
				<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text><!-- TODO X3DConcreteElement --></xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.X3DField</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
				<xsl:with-param name="description">
					<xsl:text>Concrete implementation class corresponding to X3DField.</xsl:text>
				</xsl:with-param>
				<!-- TODO update -->
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock">
					<xsl:value-of select="InterfaceDefinition/@appinfo"/>
				</xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[
	// ==== Member value declarations are encapsulated and private, using preferred Java types for concretes library ====
										
	private boolean readable = true;
						
	private boolean writable = true;
						
	private ArrayList<X3DFieldEventListener> eventListenerList = new ArrayList<>();
		
	/** Results log of local validation. */
	protected static StringBuilder validationResult = new StringBuilder();
				
	/** Get output of results from prior validation, if any
	 * @return validation results (if any)
	 */		
	public String getValidationResult()
	{
		return validationResult.toString();
	}
	/** WARNING not implemented
	 */
	public X3DConcreteFieldDefinition getDefinition()
	{
		return null; // TODO
	}

	/** Check whether field is readable, default /true/
	 * @see org.web3d.x3d.jsail.Core.fieldObject#getAccessType()
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
	 */
	@Override
	public boolean isReadable()
	{
		return readable;
	}

	/** Set whether field is readable
	 * @param newValue new status for readable
	 * @see org.web3d.x3d.jsail.Core.fieldObject#getAccessType()
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
	 */
	public void setReadable(boolean newValue)
	{
		readable = newValue;
	}

	/** Check whether field is writable, default /true/
	 * @see org.web3d.x3d.jsail.Core.fieldObject#getAccessType()
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
	 */
	@Override
	public boolean isWritable()
	{
		return writable;
	}

	/** Set whether field is writable
	 * @param newValue new status for writable
	 * @see org.web3d.x3d.jsail.Core.fieldObject#getAccessType()
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
	 */	
	public void setWritable(boolean newValue)
	{
		writable = newValue;
	}

	/** WARNING not tested */
	@Override
	public void addX3DEventListener(X3DFieldEventListener newListener)
	{
		eventListenerList.add(newListener);
	}

	/** WARNING not tested */
	@Override
	public void removeX3DEventListener(X3DFieldEventListener listener)
	{
		eventListenerList.remove(listener);
	}
						
	/**
	 * Compute tuple size for given type (for example, SFVec3f and MFVec3f have tupleSize of 3).
	 * @param fieldType of interest
	 * @return tuple size
	 */
	public static int getTupleSize(String fieldType)
	{
		if      (fieldType.equals(fieldObject.TYPE_SFBOOL)   || fieldType.equals(fieldObject.TYPE_MFBOOL)   || 
			     fieldType.equals(fieldObject.TYPE_SFINT32)  || fieldType.equals(fieldObject.TYPE_MFINT32)  || 
			     fieldType.equals(fieldObject.TYPE_SFFLOAT)  || fieldType.equals(fieldObject.TYPE_MFFLOAT)  || 
			     fieldType.equals(fieldObject.TYPE_SFDOUBLE) || fieldType.equals(fieldObject.TYPE_MFDOUBLE) || 
			     fieldType.equals(fieldObject.TYPE_SFSTRING) || fieldType.equals(fieldObject.TYPE_MFSTRING) || 
			     fieldType.equals(fieldObject.TYPE_SFTIME)   || fieldType.equals(fieldObject.TYPE_MFTIME)   || 
			     fieldType.equals(fieldObject.TYPE_SFIMAGE)  || fieldType.equals(fieldObject.TYPE_MFIMAGE)  || 
			     fieldType.equals(fieldObject.TYPE_SFNODE)   || fieldType.equals(fieldObject.TYPE_MFNODE))
		{
			return 1;
		}
		else if (fieldType.equals(fieldObject.TYPE_SFVEC2F)  || fieldType.equals(fieldObject.TYPE_MFVEC2F)   || 
			     fieldType.equals(fieldObject.TYPE_SFVEC2D)  || fieldType.equals(fieldObject.TYPE_MFVEC2D))
		{
			return 2;
		}
		else if (fieldType.equals(fieldObject.TYPE_SFCOLOR)  || fieldType.equals(fieldObject.TYPE_MFCOLOR)     || 
			     fieldType.equals(fieldObject.TYPE_SFVEC3F)  || fieldType.equals(fieldObject.TYPE_MFVEC3F)   || 
			     fieldType.equals(fieldObject.TYPE_SFVEC3D)  || fieldType.equals(fieldObject.TYPE_MFVEC3D))
		{
			return 3;
		}
		else if (fieldType.equals(fieldObject.TYPE_SFCOLORRGBA) || fieldType.equals(fieldObject.TYPE_MFCOLORRGBA) || 
			     fieldType.equals(fieldObject.TYPE_SFROTATION)  || fieldType.equals(fieldObject.TYPE_MFROTATION)  || 
			     fieldType.equals(fieldObject.TYPE_SFVEC4F)     || fieldType.equals(fieldObject.TYPE_MFVEC4F)   || 
			     fieldType.equals(fieldObject.TYPE_SFVEC4D)     || fieldType.equals(fieldObject.TYPE_MFVEC4D))
		{
			return 4;
		}
		else if (fieldType.equals(fieldObject.TYPE_SFMATRIX3F)  || fieldType.equals(fieldObject.TYPE_MFMATRIX3F) || 
			     fieldType.equals(fieldObject.TYPE_SFMATRIX3D)  || fieldType.equals(fieldObject.TYPE_MFMATRIX3D))
		{
			return 9;
		}
		else if (fieldType.equals(fieldObject.TYPE_SFMATRIX4F)  || fieldType.equals(fieldObject.TYPE_MFMATRIX4F) || 
			     fieldType.equals(fieldObject.TYPE_SFMATRIX4D)  || fieldType.equals(fieldObject.TYPE_MFMATRIX4D))
		{
			return 16;
		}
		else
		{
			String errorNotice = "Invalid fieldType provided for getTupleSize(" + fieldType + ")";
			throw new InvalidFieldValueException(errorNotice);
		}
	}

	/* Validation is handled by concrete subclasses
	@Override
	public String validate()
	{
		return ""; // TODO
	}
	*/
		
	/** Initialization sets default initial value.
	 */
	abstract public void initialize(); // must be overridden
		
	/** Provides Class corresponding to getValue() results.
	 * @return reflection Class for this field's values
	abstract public Class getReflectionClass(); // must be overridden
	 */

]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>
	
		<!-- ===================================================== -->
		
			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:text>X3DConcreteFieldDefinition</xsl:text></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.X3DFieldDefinition</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
				<xsl:with-param name="description">
					<xsl:text>Concrete implementation class corresponding to X3DField.</xsl:text>
				</xsl:with-param>
				<!-- TODO update -->
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="InterfaceDefinition/@specificationUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock">
					<xsl:text><![CDATA[
 * <p>
 * Representation of a node's field definition.
 * </p>
 * <p>
 * The field definition holds static field information such as the field
 * access type, data type and name of the field.
 * </p>
 * <p>
 * The implementation of the toString() method of this class shall return the
 * full IDL declaration of the field as per the specification, not the UTF8 or
 * XML format. Implementation of <code>.equals()</code> shall return true if
 * the two field definitions share the same access type, data type and name. It
 * shall not include the underlying field's values at that point in time.
 * </p>
 *
 * @author Justin Couch
]]></xsl:text>
					<xsl:value-of select="InterfaceDefinition/@appinfo"/>
				</xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[
	// Member value declarations are encapsulated and private, using preferred Java types for concretes library
										
	private String    name = "";
										
	private int accessType = X3DFieldTypes.INPUT_OUTPUT;
										
	private int  fieldType = X3DFieldTypes.SFSTRING;
					
    /**
     * Get the name of this field. This will be something like "children"
     * or "translation". If the field is an exposed field then the name
     * give will be the base name without any <i>set_</i> or <i>_changed</i>
     * added to the name, regardless of how the initial field was fetched.
     *
     * @return The name of this field
     */
	@Override
	public String getName()
	{
		return name;
	}
						
	public void setName(String newValue)
	{
		if (name.contains(" ")) // TODO other validity checks for name
		name = newValue;
	}
			
    /**
     * Get the access type of the field. This will be one of field,
     * exposedField, eventIn or eventOut constants described in the
     * X3DFieldTypes interface.
     *
     * @see X3DFieldTypes
     * @return The access type of this field
     */			
	@Override
	public int getAccessType()
	{
		return accessType;
	}
    /**
     * Set the access type of the field. This will be one of field,
     * exposedField, eventIn or eventOut constants described in the
     * X3DFieldTypes interface.
     *
     * @see X3DFieldTypes
     * @throws InvalidFieldValueException Illegal value provided, no change made
     * @param newValue The access type of this field
     */
	public void setAccessType(int newValue)
	{
		if ((newValue >= X3DFieldTypes.INPUT_ONLY) && (newValue <= X3DFieldTypes.OUTPUT_ONLY))
			accessType = newValue;
		else
		{
			String errorNotice = "Illegal value " + newValue + " for field type";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}
					
    /**
     * Get the field type. This string represents the field type such as
     * MFNode, SFInt32. The definition of the returned int value is
     * described in the X3DFieldType interface.
     *
     * @return A constant describing the field type
     * @see X3DFieldTypes
     */	
	@Override
	public int getFieldType()
	{
		return fieldType;
	}

    /**
     * Set the field type of the field. This will be one of SFBool,
     * SFInt32, MFString (etc.) constants described in the
     * X3DFieldTypes interface.
     *
     * @see X3DFieldTypes
     * @throws InvalidFieldValueException Illegal value provided, no change made
     * @param newValue The access type of this field
     */
	public void setFieldType(int newValue)
	{
		if ((newValue >= X3DFieldTypes.SFBOOL) && (newValue <= X3DFieldTypes.MFMATRIX4D))
			fieldType = newValue;
		else
		{
			String errorNotice = "Illegal value " + newValue + " for field type";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}

    /**
     * Get the field type. This string represents the field type such as
     * MFNode, SFInt32, etc. A string is used to allow full extensibility.
     *
     * @return A string describing the field type
     */	
	@Override
	public String getFieldTypeString()
	{
		return X3DConcreteFieldTypes.toFieldString(fieldType);
	}
]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>
	
		<!-- ===================================================== -->

			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:text>X3DConcreteFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text>import org.web3d.x3d.jsail.ConfigurationProperties;</xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:text>Methods for constants corresponding to each X3D field type and accessType.</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.11 X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DFieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.2.15 SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIFieldType</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>5.3 Field types</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>fieldsDef.html#FieldTypes</xsl:text></xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[
		/**
		 * Convert accessType value to string
		 * @param accessType the accessType enumeration value to convert
		 * @return string name for accessType value */
		public static String toAccessTypeString (int accessType)
		{
			switch (accessType)
			{
				case INPUT_ONLY:
					return "inputOnly";
				case INITIALIZE_ONLY:
					return "initializeOnly";
				case INPUT_OUTPUT:
					return "inputOutput";
				case OUTPUT_ONLY:
					return "outputOnly";
				default:
					String message = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +" "  + accessType;
					System.err.println ("X3DFieldTypes.toString(" + accessType + ") " + message);
					return message; // TODO throw exception?
			}
		}
		/**
		 * Convert fieldType value to string
		 * @param fieldType the fieldType enumeration value to convert
		 * @return string name for fieldType value */
		public static String toFieldString (int fieldType)
		{
			switch (fieldType)
			{
				case SFBOOL:
					return "SFBool";
				case MFBOOL:
					return "MFBool";
				case SFINT32:
					return "SFInt32";
				case MFINT32:
					return "MFInt32";
				case SFFLOAT:
					return "SFFloat";
				case MFFLOAT:
					return "MFFloat";
				case SFDOUBLE:
					return "SFDouble";
				case MFDOUBLE:
					return "MFDouble";
				case SFTIME:
					return "SFTime";
				case MFTIME:
					return "MFTime";
				case SFNODE:
					return "SFNode";
				case MFNODE:
					return "MFNode";
				case SFVEC2F:
					return "SFVec2f";
				case MFVEC2F:
					return "MFVec2f";
				case SFVEC3F:
					return "SFVec3f";
				case MFVEC3F:
					return "MFVec3f";
				case SFVEC3D:
					return "SFVec3d";
				case MFVEC3D:
					return "MFVec3d";
				case SFROTATION:
					return "SFRotation";
				case MFROTATION:
					return "MFRotation";
				case SFCOLOR:
					return "SFColor";
				case MFCOLOR:
					return "MFColor";
				case SFCOLORRGBA:
					return "SFColorRGBA";
				case MFCOLORRGBA:
					return "MFColorRGBA";
				case SFIMAGE:
					return "SFImage";
				case MFIMAGE:
					return "MFImage";
				case SFSTRING:
					return "SFString";
				case MFSTRING:
					return "MFString";

				// added in v3.3
				case SFVEC2D:
					return "SFVec2d";
				case MFVEC2D:
					return "MFVec2d";
				case SFVEC4F:
					return "SFVec4f";
				case MFVEC4F:
					return "MFVec4f";
				case SFVEC4D:
					return "SFVec4d";
				case MFVEC4D:
					return "MFVec4d";
				case SFMATRIX3D:
					return "SFMatrix3d";
				case MFMATRIX3D:
					return "MFMatrix3d";
				case SFMATRIX3F:
					return "SFMatrix3f";
				case MFMATRIX3F:
					return "MFMatrix3f";
				case SFMATRIX4D:
					return "SFMatrix4d";
				case MFMATRIX4D:
					return "MFMatrix4d";
				case SFMATRIX4F:
					return "SFMatrix4f";
				case MFMATRIX4F:
					return "MFMatrix4f";
				default:
					String message = ConfigurationProperties.ERROR_UNKNOWN_FIELD_TYPE +" "  + fieldType;
					System.err.println ("X3DFieldTypes.toString(" + fieldType + ") " + message);
					return message; // TODO throw exception?
			}
		}
	]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>

    </xsl:template> <!-- FieldDefinitions -->
	
    <!-- ===================================================== -->
	
	<xsl:template name="BaseTypeDefinitions">
		
		<xsl:variable name="subPackage">
			<xsl:if test="($modifySpecificationInterfaces = 'true')">
				<xsl:text>fields</xsl:text>
			</xsl:if>
		</xsl:variable>
		
		<!-- B.4 Field interfaces -->
		<!-- http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2/abstracts.html#FieldInterfaces -->
		<!-- TODO specificaton table bookmark link is incorrect -->
		<!-- Implemented in X3D Object model -->
		
		<!-- TODO get enumeration values and create final int constant values -->
		
		<xsl:for-each select="//FieldTypes/FieldType">
			
			<xsl:variable name="name"                                select="@type"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			
			<xsl:variable name="tupleSize">
				<xsl:call-template name="tupleSize">
					<xsl:with-param name="x3dType" select="@type"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="extends">
				<!-- must have one; also note that each interface can be extended by another interface -->
				<xsl:choose>
					<xsl:when test="contains($name,'Matrix3')">
						<xsl:text>Matrix3</xsl:text>
					</xsl:when>
					<xsl:when test="contains($name,'Matrix4')">
						<xsl:text>Matrix4</xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($name,'SF')">
						<xsl:text>X3DField</xsl:text>
					</xsl:when>
					<xsl:otherwise> <!-- MF -->
						<xsl:text>MField</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			
			<xsl:variable name="imports">
				<xsl:choose>
					<xsl:when test="($name = 'MFImage')">
						<xsl:text>
import java.awt.image.RenderedImage;
import java.awt.image.WritableRenderedImage;</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode') or ($name = 'MFNode')">
						<xsl:text>
import org.web3d.x3d.sai.Core.X3DNode;</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>
			
			<!-- TODO turn into template for reuse -->
			<xsl:variable name="saiJavaSpecificationSection">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool')">
						<xsl:text>B.4.7</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFBool')">
						<xsl:text>B.4.8</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColor')">
						<xsl:text>B.4.9</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColor')">
						<xsl:text>B.4.10</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColorRGBA')">
						<xsl:text>B.4.11</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColorRGBA')">
						<xsl:text>B.4.12</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFDouble')">
						<xsl:text>B.4.13</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFDouble')">
						<xsl:text>B.4.14</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFFloat')">
						<xsl:text>B.4.15</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFFloat')">
						<xsl:text>B.4.16</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFImage')">
						<xsl:text>B.4.17</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFImage')">
						<xsl:text>B.4.18</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFInt32')">
						<xsl:text>B.4.19</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFInt32')">
						<xsl:text>B.4.20</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3d')">
						<xsl:text>B.4.21</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix3d')">
						<xsl:text>B.4.22</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3f')">
						<xsl:text>B.4.23</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix3f')">
						<xsl:text>B.4.24</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4d')">
						<xsl:text>B.4.25</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix4d')">
						<xsl:text>B.4.26</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4f')">
						<xsl:text>B.4.27</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix4f')">
						<xsl:text>B.4.28</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode')">
						<xsl:text>B.4.29</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFNode')">
						<xsl:text>B.4.30</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFRotation')">
						<xsl:text>B.4.31</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFRotation')">
						<xsl:text>B.4.32</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString')">
						<xsl:text>B.4.33</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFString')">
						<xsl:text>B.4.34</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFTime')">
						<xsl:text>B.4.35</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFTime')">
						<xsl:text>B.4.36</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2d')">
						<xsl:text>B.4.37</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2d')">
						<xsl:text>B.4.38</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2f')">
						<xsl:text>B.4.39</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2f')">
						<xsl:text>B.4.40</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec3d')">
						<xsl:text>B.4.41</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec3d')">
						<xsl:text>B.4.42</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec3f')">
						<xsl:text>B.4.43</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec3f')">
						<xsl:text>B.4.44</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec4d')">
						<xsl:text>B.4.45</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec4d')">
						<xsl:text>B.4.46</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec4f')">
						<xsl:text>B.4.47</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec4f')">
						<xsl:text>B.4.48</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>
			
			<!-- TODO turn into template for reuse -->
			<xsl:variable name="saiAbstractSpecificationSection">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool') or ($name = 'MFBool')">
						<xsl:text>5.2.2 SAIBoolean</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString') or ($name = 'MFString')">
						<xsl:text>SAIString</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode') or ($name = 'MFNode')">
						<xsl:text>5.2.22 SAINode</xsl:text>
					</xsl:when>
					<xsl:when test="contains($name, 'Matrix')">
						<xsl:text>5.2.20 SAIMatrix</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>5.2.15 SAIFieldType</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			
			<!-- TODO turn into template for reuse -->
			<xsl:variable name="saiAbstractSpecificationRelativeUrl">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool') or ($name = 'MFBool')">
						<xsl:text>dataRef.html#SAIBoolean</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString') or ($name = 'MFString')">
						<xsl:text>dataRef.html#SAIString</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode') or ($name = 'MFNode')">
						<xsl:text>dataRef.html#SAINode</xsl:text>
					</xsl:when>
					<xsl:when test="contains($name, 'Matrix')">
						<xsl:text>dataRef.html#SAIMatrix</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>dataRef.html#SAIFieldType</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			
			<!-- TODO turn into template for reuse -->
			<xsl:variable name="x3dAbstractSpecificationSection">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool')">
						<xsl:text>5.3.1 SFBool and MFBool</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFBool')">
						<xsl:text>5.3.1 SFBool and MFBool</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColor')">
						<xsl:text>5.3.2 SFColor and MFColor</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColor')">
						<xsl:text>5.3.2 SFColor and MFColor</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColorRGBA')">
						<xsl:text>5.3.3 SFColorRGBA and MFColorRGBA</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColorRGBA')">
						<xsl:text>5.3.3 SFColorRGBA and MFColorRGBA</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFDouble')">
						<xsl:text>5.3.4 SFDouble and MFDouble</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFDouble')">
						<xsl:text>5.3.4 SFDouble and MFDouble</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFFloat')">
						<xsl:text>5.3.5 SFFloat and MFFloat</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFFloat')">
						<xsl:text>5.3.5 SFFloat and MFFloat</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFImage')">
						<xsl:text>5.3.6 SFImage and MFImage</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFImage')">
						<xsl:text>5.3.6 SFImage and MFImage</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFInt32')">
						<xsl:text>5.3.7 SFInt32 and MFInt32</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFInt32')">
						<xsl:text>5.3.7 SFInt32 and MFInt32</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3d')">
						<xsl:text>5.3.8 SFMatrix3d and MFMatrix3d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix3d')">
						<xsl:text>5.3.8 SFMatrix3d and MFMatrix3d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3f')">
						<xsl:text>5.3.9 SFMatrix3f and MFMatrix3f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix3f')">
						<xsl:text>5.3.9 SFMatrix3f and MFMatrix3f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4d')">
						<xsl:text>5.3.10 SFMatrix4d and MFMatrix4d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix4d')">
						<xsl:text>5.3.10 SFMatrix4d and MFMatrix4d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4f')">
						<xsl:text>5.3.11 SFMatrix4f and MFMatrix4f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFMatrix4f')">
						<xsl:text>5.3.11 SFMatrix4f and MFMatrix4f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode')">
						<xsl:text>5.3.12 SFNode and MFNode</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFNode')">
						<xsl:text>5.3.12 SFNode and MFNode</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFRotation')">
						<xsl:text>5.3.13 SFRotation and MFRotation</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFRotation')">
						<xsl:text>5.3.13 SFRotation and MFRotation</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString')">
						<xsl:text>5.3.14 SFString and MFString</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFString')">
						<xsl:text>5.3.14 SFString and MFString</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFTime')">
						<xsl:text>5.3.15 SFTime and MFTime</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFTime')">
						<xsl:text>5.3.15 SFTime and MFTime</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2d')">
						<xsl:text>5.3.16 SFVec2d and MFVec2d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2d')">
						<xsl:text>5.3.16 SFVec2d and MFVec2d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2f')">
						<xsl:text>5.3.17 SFVec2f and MFVec2f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2f')">
						<xsl:text>5.3.17 SFVec2f and MFVec2f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec3d')">
						<xsl:text>5.3.18 SFVec3d and MFVec3d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec3d')">
						<xsl:text>5.3.18 SFVec3d and MFVec3d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec3f')">
						<xsl:text>5.3.19 SFVec3f and MFVec3f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec3f')">
						<xsl:text>5.3.19 SFVec3f and MFVec3f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec4d')">
						<xsl:text>5.3.20 SFVec4d and MFVec4d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec4d')">
						<xsl:text>5.3.20 SFVec4d and MFVec4d</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec4f')">
						<xsl:text>5.3.21 SFVec4f and MFVec4f</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec4f')">
						<xsl:text>5.3.21 SFVec4f and MFVec4f</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>
			
			<xsl:variable name="javadocBlock">
			</xsl:variable>
			<!-- debug
			<xsl:message>
				<xsl:text>*** //FieldTypes/FieldType name=</xsl:text>
				<xsl:value-of select="$name"/>
				<xsl:text>, $javadocBlock=</xsl:text>
				<xsl:value-of select="$javadocBlock"/>
			</xsl:message> -->
			
			<xsl:variable name="interfaceBlock">
				<xsl:choose>
					<xsl:when test="($name = 'SFBool')">
						<xsl:text><![CDATA[
    /**
     *	Get the current value.
     * 	@return current value
     */	
	public boolean getValue();

    /**
     * Assign a new value to this field.
     * @param newValue The newValue to assign
     */	
	public void setValue(boolean newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFBool')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(boolean[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public boolean get1Value(int index);

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, boolean[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, boolean newValue) throws ArrayIndexOutOfBoundsException;

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(boolean newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, boolean newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColor')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param newValue The newValue to set
     */	
	public void setValue(float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="starts-with($name,'MFColor')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param numColors The number of 3-tuple RGB colors in the newValue array
     * @param newValue The newValue to set
     */	
	public void setValue(int numColors, float[] newValue);

    /**
     * Assign a new value to this field.
     * @param numColors The number of 3-tuple RGB colors in the newValue array
     * @param newValue The newValue to set
     */	
	public void setValue(int numColors, float[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float[] newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(float[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFColorRGBA')">
						<xsl:text>
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param newValue The newValue to set
     */	
	public void setValue(float[] newValue);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFColorRGBA')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param numColors The number of 3-tuple RGB colors in the newValue array
     * @param newValue The new value to set
     */	
	public void setValue(int numColors, float[] newValue);

    /**
     * Assign a new value to this field.
     * @param numColors The number of 3-tuple RGB colors in the newValue array
     * @param newValue The new value to set
     */	
	public void setValue(int numColors, float[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float[] newValue);

    /** 
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(float[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float[] newValue);
]]>
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFDouble')">
						<xsl:text>
    /**
     *	Get the current value.
     * 	@return current value
     */	
	public double getValue();

    /**
     * Assign a new value to this field.
     * @param newValue The new value to set
     */	
	public void setValue(double newValue);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFDouble')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public double get1Value(int index) throws ArrayIndexOutOfBoundsException;

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, double[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, double newValue) throws ArrayIndexOutOfBoundsException;

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(double newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, double newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFFloat')">
						<xsl:text><![CDATA[
    /**
     *	Get the current value.
     * 	@return current value
     */	
	public float getValue();

    /**
     * Assign a new value to this field.
     * @param newValue The new value to set
     */	
	public void setValue(float newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFFloat')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public float get1Value(int index) throws ArrayIndexOutOfBoundsException;

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, float[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float newValue) throws ArrayIndexOutOfBoundsException;

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(float newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFImage')">
						<xsl:text><![CDATA[
    /**
     * Get the width of the image.
     * @return The width of the image in pixels
     */
	public int getWidth();

    /**
     * Get the height of the image.
     * @return The height of the image in pixels
     */
	public int getHeight();

    /**
     * Get the number of color components in the image. The value will
     * always be between 1 and 4 indicating the number of components of
     * the color specification to be read from the image pixel data.
     * @return The number of components
     */
	public int getComponents();

    /**
     * Get the image pixel value in the given eventOut.
     * <p>
     * The number of items in the pixels array will be
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     * @param pixels The array to copy pixel values into
     */
	public void getPixels(int[] pixels);

    /**
     * Fetch the Java representation of the underlying image from these pixels.
     * This is the same copy that the browser uses to generate texture
     * information from.
     * @return The image reference representing the current state
     */
	public java.awt.image.WritableRenderedImage getImage();

    /**
     * Set the image value in the given writable field to the new image defined
     * by a set of pixels.
     * <p>
     * @param image The new image to use as the source
     */
	public void setImage(java.awt.image.RenderedImage image);

    /**
	 * Copy a region of the argument RenderedImage to replace a portion of the
	 * current SFimage.
	 * <p>
	 * The sub image set shall not resize the base image representation and
	 * therefore performs an intersection clip of the provided image. The user
	 * provided image shall be of the same format (pixel depth, pixel
	 * representation) as the original image obtained through the getImage()
	 * method.
	 * <p>
	 * RenderedImages are row order from top to bottom. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 0 |********|
	 * 1 |********|
	 * 2 |********|
	 * 3 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * SFImages are row order from bottom to top. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 3 |********|
	 * 2 |********|
	 * 1 |********|
	 * 0 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * <p>
	 * Note: The parameter srcYOffset is referenced to the RenderedImage object
	 * (indexed top to bottom).
	 * <br>
	 * The parameter destYOffset is referenced to the SFImage object
	 * (indexed bottom to top).
	 *
	 * @param image The new image to use as the source
	 * @param sourceWidth The width of the argument sub-image region to copy
	 * @param sourceHeight The height of the argument sub-image region to copy
	 * @param sourceXOffset The initial x dimension (width) offset into the
	 * argument sub-image that begins the region to copy
	 * @param sourceYOffset The initial y dimension (height) offset into the
	 * argument sub-image that begins the region to copy
	 * @param destinationXOffset The initial x dimension (width) offset in the SFimage
	 * object that begins the region to receive the copy
	 * @param destinationYOffset The initial y dimension (height) offset in the SFimage
	 * object that begins the region to receive the copy
	 */
	public void setSubImage(java.awt.image.RenderedImage image,
                            int sourceWidth,
                            int sourceHeight,
                            int sourceXOffset,
                            int sourceYOffset,
                            int destinationXOffset,
                            int destinationYOffset);

    /**
     * Set the image value in the given writable field.
     * <p>
     * Image values are specified using a width, height and the number of
     * components. The number of items in the pixels array must be at least
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components. If the integer
     * contains values in bytes that are not used by the number of components
     * for that image, the values are ignored.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     *
     * @param width The width of the image in pixels
     * @param height The height of the image in pixels
     * @param components The number of color components [1-4]
     * @param pixels The array of pixel values as specified above.
     * @exception IllegalArgumentException The number of components or width/
     *    height are illegal values.
     * @exception ArrayIndexOutOfBoundsException The number of pixels provided by the
     *    caller is not enough for the width * height.
     */
	public void setValue(int width,
                         int height,
                         int components,
                         int[] pixels);

]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFImage')">
						<xsl:text><![CDATA[
    /**
     * Get the width of the image array.
     * @param imageIndex the index of the selected image
     * @return The width of the image in pixels
     */
	public int getWidth(int imageIndex);

    /**
     * Get the height of the image array.
     * @param imageIndex the index of the selected image
     * @return The height of the image in pixels
     */
	public int getHeight(int imageIndex);

    /**
     * Get the number of color components in the image. The value will
     * always be between 1 and 4 indicating the number of components of
     * the color specification to be read from the image pixel data.
     * @param imageIndex the index of the selected image
     * @return The number of components
     */
	public int getComponents(int imageIndex);

    /**
     * Get the image pixel value in the given eventOut.
     * <p>
     * The number of items in the pixels array will be
     * <code>width * height</code>. If there are less items than this an
     * ArrayIndexOutOfBoundsException will be generated. The integer values
     * are represented according to the number of components.
     * <p>
     *  <b>1 Component Images </b> <br>
     * The integer has the intensity value stored in the lowest byte and can be
     * obtained:
     *  <pre>
     *    intensity = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>2 Component Images </b> <br>
     * The integer has the transparency value stored in the lowest byte and the
     * intensity in the next byte:
     *  <pre>
     *    intensity = (pixel[i] &gt;&gt; 8) &amp;0xFF;
     *    alpha     = (pixel[i]     ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>3 Component Images </b> <br>
     * The three color components are stored in the integer array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    blue  = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     *  <b>4 Component Images </b> <br>
     * The integer has the value stored in the array as follows:
     *  <pre>
     *    red   = (pixel[i] &gt;&gt; 24) &amp;0xFF;
     *    green = (pixel[i] &gt;&gt; 16) &amp;0xFF;
     *    blue  = (pixel[i] &gt;&gt;  8) &amp;0xFF;
     *    alpha = (pixel[i]      ) &amp;0xFF;
     *  </pre>
     * <p>
     * The width and height values must be greater than or equal to zero. The
     * number of components is between 1 and 4. Any value outside of these
     * bounds will generate an IllegalArgumentException.
     * @param imageIndex the index of the selected image
     * @param pixels The array to copy pixel values into
     */
	public void getPixels(int imageIndex, int[] pixels);

    /**
     * Fetch the Java representation of the underlying image from these pixels.
     * This is the same copy that the browser uses to generate texture
     * information from.
     * @param imageIndex the index of the selected image
     * @return The image reference representing the current state
     */
	public WritableRenderedImage getImage(int imageIndex);

    /**
     * Set the image value in the given writable field to the new image defined
     * by a set of pixels.
     * @param imageIndex the index of the selected image
     * @param image The new image to use as the source
     */
	public void setImage(int imageIndex, RenderedImage image);

    /**
	 * Copy a region of the argument RenderedImage to replace a portion of the
	 * current SFimage.
	 * <p>
	 * The sub image set shall not resize the base image representation and
	 * therefore performs an intersection clip of the provided image. The user
	 * provided image shall be of the same format (pixel depth, pixel
	 * representation) as the original image obtained through the getImage()
	 * method.
	 * <p>
	 * RenderedImages are row order from top to bottom. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 0 |********|
	 * 1 |********|
	 * 2 |********|
	 * 3 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * SFImages are row order from bottom to top. A
	 * 4x8 RenderImage is indexed as follows:
	 *
	 *  <pre>
	 *
	 * X &gt;01234567
	 *   ----------
	 * 3 |********|
	 * 2 |********|
	 * 1 |********|
	 * 0 |********|
	 * ^ ----------
	 * Y
	 *
	 *  </pre>
	 *
	 * <p>
	 * Note: The parameter srcYOffset is referenced to the RenderedImage object
	 * (indexed top to bottom).
	 * <br>
	 * The parameter destYOffset is referenced to the SFImage object
	 * (indexed bottom to top).
	 *
	 * @param imageIndex the index of the selected image
	 * @param image The new image to use as the source
	 * @param sourceWidth The width of the argument sub-image region to copy
	 * @param sourceHeight The height of the argument sub-image region to copy
	 * @param sourceXOffset The initial x dimension (width) offset into the
	 * argument sub-image that begins the region to copy
	 * @param sourceYOffset The initial y dimension (height) offset into the
	 * argument sub-image that begins the region to copy
	 * @param destinationXOffset The initial x dimension (width) offset in the SFimage
	 * object that begins the region to receive the copy
	 * @param destinationYOffset The initial y dimension (height) offset in the SFimage
	 * object that begins the region to receive the copy
	 */
	public void setSubImage(int imageIndex,
		RenderedImage image,
                            int sourceWidth,
                            int sourceHeight,
                            int sourceXOffset,
                            int sourceYOffset,
                            int destinationXOffset,
                            int destinationYOffset);

	/**
	 * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * @param imageIndex the index of the selected image
	 * @param newValue provides new value to apply
	 */
	public void set1Value(int imageIndex, int newValue);

	public void set1Value(int imageIndex,
                          int width,
                          int height,
                          int components,
                          int[] pixels);

	/**
	 * Assign a new value array containing imageIndex, width, height, and components count, followed by array of pixels.
	 * @param newValue The newValue to set
	 */	
	public void setValue(int[] newValue);

	public void setImage(RenderedImage[] image);

	/**
	 * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * @param newValue The newValue to append
	 */
	public void append(RenderedImage[] newValue);

	/**
	 * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
	 * @param index The position for the inserted value in the current array
	 * @param newValue The newValue to insert
	 */
	public void insertValue(int index, RenderedImage newValue);
]]></xsl:text>
<!-- TODO specification missing closing } -->
					</xsl:when>
					<xsl:when test="($name = 'SFInt32')">
						<xsl:text><![CDATA[
	/**
	 *	Get the current value.
	 * 	@return current value
	 */	
	public int getValue();

	/**
	 * Assign a new value to this field.
	 * @param newValue The new value to set
	 */	
	public void setValue(int newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFInt32')">
						<xsl:text><![CDATA[
	/**
	 * Write out the current value of this field into the external valueDestination array.
	 *
	 * @param valueDestination The array to be filled in with current field values.
	 * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
	 */
	public void getValue(int[] valueDestination);

	/**
	 * <p>
	 * Get an individual value from the existing field array.
	 * </p><p>
	 * If the index is outside the bounds of the current array of data values,
	 * an ArrayIndexOutOfBoundsException is thrown.
	 * </p>
	 * @param index is position of selected value in current array
	 * @return The selected value
	 * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
	 */
	public int get1Value(int index) throws ArrayIndexOutOfBoundsException;

	/**
	 * Assign an array subset to this field.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
	 * @param newValue The replacement value array to (potentially) slice and then assign.
	 */	
	public void setValue(int size, int[] newValue);

	/**
	 * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * @param imageIndex the index of the selected image
	 * @param newValue provides new value to apply
	 */
	public void set1Value(int imageIndex, int newValue) throws ArrayIndexOutOfBoundsException;

	/**
	 * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * @param newValue The newValue to append
	 */
	public void append(int newValue);

	/**
	 * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
	 * @param index The position for the inserted value in the current array
	 * @param newValue The newValue to insert
	 */
	public void insertValue(int index, int newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3d') or ($name = 'MFMatrix3d')">
						<xsl:text>
	public void setTransform(SFVec3d translation,
		SFRotation rotation,
		SFVec3d scale,
		SFRotation scaleOrientation,
		SFVec3d center);

	public void getTransform(SFVec3d translation,
		SFRotation rotation,
		SFVec3d scale);
							
	public Matrix3 multiplyRowVector(SFVec3d vec3d);

	public Matrix3 multiplyColVector(SFVec3d vec3d);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix3f') or ($name = 'MFMatrix3f')">
						<xsl:text>
	public void setTransform(SFVec3f translation,
		SFRotation rotation,
		SFVec3f scale,
		SFRotation scaleOrientation,
		SFVec3f center);

	public void getTransform(SFVec3f translation,
		SFRotation rotation,
		SFVec3f scale);

	public Matrix3 multiplyRowVector(SFVec3f vec3f);

	public Matrix3 multiplyColVector(SFVec3f vec3f);
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4d') or ($name = 'MFMatrix4d')">
						<xsl:text>
	public void setTransform(SFVec3d translation,
		SFRotation rotation,
		SFVec3d scale,
		SFRotation scaleOrientation,
		SFVec3d center);

	public void getTransform(SFVec3d translation,
		SFRotation rotation,
		SFVec3d scale);

	public Matrix4 multiplyRowVector(SFVec3d vec3d); // TODO SFVec4d ?

	public Matrix4 multiplyColVector(SFVec3d vec3d); // TODO SFVec4d ?
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFMatrix4f') or ($name = 'MFMatrix4f')">
						<xsl:text>
	public void setTransform(SFVec3f translation,
		SFRotation rotation,
		SFVec3f scale,
		SFRotation scaleOrientation,
		SFVec3f center);

	public void getTransform(SFVec3f translation,
		SFRotation rotation,
		SFVec3f scale);

	public Matrix4 multiplyRowVector(SFVec3f vec3f); // TODO SFVec4f ?

	public Matrix4 multiplyColVector(SFVec3f vec3f); // TODO SFVec4f ?
</xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFNode')">
						<xsl:text><![CDATA[
	/**
	 *	Get the current value.
	 * 	@return current value
	 */	
	public X3DNode getValue();

	/**
	 * Assign a new value to this field.
	 * @param newValue The new value to set
	 */	
	public void setValue(X3DNode newValue) throws InvalidNodeException;
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFNode')">
						<xsl:text><![CDATA[
	/**
	 * Write the current value of the field out to the provided copiedNodes array.
	 *
	 * @param copiedNodes The array to be filled in with current field values.
	 * @throws ArrayIndexOutOfBoundsException The provided copiedNodes array was too small
	 */
	public void getValue(X3DNode[] copiedNodes);

	/**
	 * <p>
	 * Get an individual value from the existing field array.
	 * </p>
	 * <p>
	 * If the index is outside the bounds of the current array of data values,
	 * an ArrayIndexOutOfBoundsException is thrown.
	 * </p>
	 * @param index is position of selected value in current array
	 * @return The selected value
	 * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
	 */
	public X3DNode get1Value(int index);

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, X3DNode[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param imageIndex the index of the selected image
     * @param newValue provides new value to apply
     */
	public void set1Value(int imageIndex, X3DNode newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(X3DNode newValue);

    /**
     * Insert a new value prior to the imageIndex location in the existing value array, increasing the field length accordingly.
     * @param imageIndex the index of the selected image
     * @param newValue The newValue to insert
     */
	public void insertValue(int imageIndex, X3DNode newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFRotation')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */	
	public void setValue(float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFRotation')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, float[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param numRotations The number of 4-tuple rotations in the newValue array
     * @param newValue The newValue array of 4-tuple rotations to set
     */	
	public void setValue(int numRotations, float[] newValue);

    /**
     * Assign a new value to this field.
     * @param numRotations The number of 4-tuple rotations in the newValue array
     * @param newValue The newValue square array of 4-tuple rotations to set
     */	
	public void setValue(int numRotations, float[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float[] newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(float[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFString')">
						<xsl:text><![CDATA[
    /**
     *	Get the current value.
     * 	@return current value
     */	
	public String getValue();

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */	
	public void setValue(String newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFString')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(String[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public String get1Value(int index);

    /**
     * Assign a new value to this field.
     * @param numStrings The number of strings in the newValue array
     * @param newValue The newValue array of strings to set
     */	
	public void setValue(int numStrings, String[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, String newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(String newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, String newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFTime')">
						<xsl:text><![CDATA[
    /**
     *	Get the current value.
     * 	@return current value
     */	
	public double getValue();

	public long getJavaValue();

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */	
	public void setValue(double newValue);

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */	
	public void setValue(long newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFTime')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
	 * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public double get1Value(int index);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
	 * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @return The selected value
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public long get1JavaValue(int index);

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, double[] newValue);

    /**
     * Assign an array subset to this field.
     * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, long[] newValue);

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */	
	public void setValue(long[] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, double newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
     * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, long newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(double newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
     * @param newValue The newValue to append
     */
	public void append(long newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, long newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, double newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2d') or ($name = 'SFVec3d') or ($name = 'SFVec4d')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[] valueDestination);

    /**
     * Assign a new value to this field.
     * @param newValue is replacement value array to assign
     */	
	public void setValue(double[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2d') or ($name = 'MFVec3d') or ($name = 'MFVec4d')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(double[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, double[] valueDestination);

    /**
     * Assign an array subset to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, double[] newValue);

    /**
     * Assign an array subset to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, double[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, double[] newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(double[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, double[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'SFVec2f') or ($name = 'SFVec3f') or ($name = 'SFVec4f')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * Assign a new value to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue is replacement value array to assign
     */	
	public void setValue(float[] newValue);
]]></xsl:text>
					</xsl:when>
					<xsl:when test="($name = 'MFVec2f') or ($name = 'MFVec3f') or ($name = 'MFVec4f')">
						<xsl:text><![CDATA[
    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[][] valueDestination);

    /**
     * Write out the current value of this field into the external valueDestination array.
     *
     * @param valueDestination The array to be filled in with current field values.
     * @throws ArrayIndexOutOfBoundsException The provided valueDestination array was too small.
     */
	public void getValue(float[] valueDestination);

    /**
     * <p>
     * Get an individual value from the existing field array.
     * </p><p>
     * If the index is outside the bounds of the current array of data values,
     * an ArrayIndexOutOfBoundsException is thrown.
     * </p>
     * @param index is position of selected value in current array
     * @param valueDestination The array to be filled in with the selected current field value.
     * @throws ArrayIndexOutOfBoundsException The index was outside of the bounds of the current array.
     */
	public void get1Value(int index, float[] valueDestination);

    /**
     * Assign an array subset to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, float[] newValue);

    /**
     * Assign an array subset to this field.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param size indicates size of result to copy (i.e. the number of typed singleton values) from beginning of newValue array.
     * @param newValue The replacement value array to (potentially) slice and then assign.
     */	
	public void setValue(int size, float[][] newValue);

    /**
     * Replace a single value at the appropriate location in the existing value array.
	 * Size of the current underlying value array does not change.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index is position of selected value in current array
     * @param newValue provides new value to apply
     */
	public void set1Value(int index, float[] newValue);

    /**
     * Places a new value at the end of the existing value array, increasing the field length accordingly.
	 * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param newValue The newValue to append
     */
	public void append(float[] newValue);

    /**
     * Insert a new value prior to the index location in the existing value array, increasing the field length accordingly.
     * <i>Warning:</i> newValue array length must correspond to tuple size for base type ]]></xsl:text><xsl:value-of select="$name"/><xsl:text><![CDATA[ tuple size of <i>]]></xsl:text><xsl:value-of select="$tupleSize"/><xsl:text><![CDATA[</i>.
	 * @param index The position for the inserted value in the current array
     * @param newValue The newValue to insert
     */
	public void insertValue(int index, float[] newValue);
]]></xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>
			
			<!-- TODO javadoc url links -->
		
			<!-- B.4 Field interfaces -->
			<!-- http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2/abstracts.html#FieldInterfaces -->

			<!-- abstract interfaces -->
			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:value-of select="$imports"/></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
				<!-- update specification prose to include full package -->
				<xsl:with-param name="extends"><xsl:value-of select="$extends"/></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:value-of select="$saiJavaSpecificationSection"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:value-of select="$saiAbstractSpecificationSection"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:value-of select="$saiAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="$x3dAbstractSpecificationSection"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock"><xsl:value-of select="$interfaceBlock"/></xsl:with-param>
			</xsl:call-template>
		
		</xsl:for-each>
		
    </xsl:template>
	
    <!-- ===================================================== -->
	
	<xsl:template name="ServiceInterfaces">
		
		<xsl:variable name="subPackage">
			<xsl:if test="($modifySpecificationInterfaces = 'true')">
				<xsl:text>services</xsl:text>
			</xsl:if>
		</xsl:variable>
		
		<!-- B.5 Service interfaces -->
		<!-- http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2/abstracts.html#ServiceInterfaces -->
		<!-- TODO fix specification designations: some of these service definitions are interfaces, not classes -->
			
		<!-- Note:  BrowserEvent must be a class since it extends java.util.EventObject -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<!-- update specification prose to include full package -->
			<xsl:with-param name="extends"><xsl:text>java.util.EventObject</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Class representing events that happen in the Browser object.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.1 BrowserEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>5.4.1.2 SAI_Browser_Event</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>dataRef.html#SAIBrowserEvent</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implementationBlock"><![CDATA[
    /**
     * The X3D player has completed initial loading of the world. Event is generated
     * just after the scene has been loaded and just before the first event has been sent.
     */
	public static final int INITIALIZED = 0;

    /**
     * The currently loaded world is about to be unloaded. Called just before
     * the scene is about to be unloaded. If another world is going to replace this,
     * then an initialize event will be generated following this one.
     */
	public static final int SHUTDOWN = 1;

    /**
     * An error occurred in loading a scene from a URL call. Origin can be either
     * a createVrmlFromURL call or loadURL.
     */
	public static final int URL_ERROR = 2;

    /**
     * An error has occurred that has caused the connection between the X3D player
     * and the external application to fail. Potential causes include X3D player
     * failure or a lost network connection.
     */
	public static final int CONNECTION_ERROR = 10;

    /**
     * The number of reserved identifier numbers for event conditions. Any
     * value below this is considered to be a general specification-defined event as
     * found in the Java Scene Authoring Interface (SAI) specification. Any values
     * above this value are browser-specific messages.
     */
	public static final int LAST_IDENTIFIER = 100;
		
    /** The identifier of the event that this class instance represents */
    private int id;
	
	/** Error message if incorrect Browser event value encountered.
	 * @see <a href="http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2/abstracts.html#BrowserEvent">X3D Java SAI: B.5.1 BrowserEvent</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/concepts.html#Browser">X3D SAI: 4.4.6 Browser</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/concepts.html#Events">X3D SAI: 4.5 Events</a>
	 */
	public static final String ERROR_UNKNOWN_BROWSER_EVENT_VALUE = "ERROR_UNKNOWN_BROWSER_EVENT_VALUE"; // not defined in X3D Java SAI

	/**
     * Get the type of event that has occurred.
     *
     * @return The type of event as defined by the types
     * @see #INITIALIZED
     * @see #SHUTDOWN
     * @see #URL_ERROR
     * @see #CONNECTION_ERROR
     * @see #LAST_IDENTIFIER
     */
	public int getID()
    {
        return id;
	}

    /**
     * Create a new browser event.
     *
     * @param browser The source of the browser that generated this event
     * @param action The event type to create
     * @exception IllegalArgumentException if the action or browser id are not legal values
     */
	public BrowserEvent(Object browser, int action)
    {
        super(browser);

        if (browser == null)
		{
			String errorNotice = "Null browser reference";
//			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}

        if (action < 0)
		{
            String errorNotice = "Invalid event action type " + action;
//			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}

        id = action;
    }
				
    /**
     * Utility method providing the name of this event value.
     * @param value The BrowserEvent value of interest.
     * @return The name of this BrowserEvent value.
     */
	public String toString (int value)
	{
		switch (value)
		{
			case INITIALIZED:
				return "INITIALIZED";
			case SHUTDOWN:
				return "SHUTDOWN";
			case URL_ERROR:
				return "URL_ERROR";
			case CONNECTION_ERROR:
				return "CONNECTION_ERROR";
			case LAST_IDENTIFIER:
				return "LAST_IDENTIFIER";
			default:
				String message = BrowserEvent.ERROR_UNKNOWN_BROWSER_EVENT_VALUE + " " + value;
				System.err.println ("BrowserEvent.toString(" + value + ") " + message);
				return message; // TODO throw exception?
		}
	}
]]></xsl:with-param>
		</xsl:call-template>
		
		<!-- =========== -->

		<!-- TODO specification may need to define BrowserFactoryImpl X3DComponent and ExternalBrowser -->

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="imports">
import java.applet.Applet;
import java.io.InputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Properties;
import java.util.Map;
</xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Factory class for obtaining references to browser instances.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
<p>
An implementation-independent representation of the class used to access
and create browsers. The model follows that used by java.net.Socket. A
setImpl method is provided for browser writers to provide the internal
implementations of the browser.
</p>
<p>
An alternative way of doing this is through properties. The class,
when it loads first looks for a System property with the key:
</p>
<ul>
<li><code>x3d.sai.factory.class</code></li>
</ul>
<p>
If a non-null value is found for this key, it is used as the name of
the class to load as the default browser implementation. If no matching
System property is found, the initializer looks for the file
<code>x3d.properties</code> in the class path.
(For more information on how this works read
<code>java.lang.ClassLoader.getSystemResourceAsStream()</code>). If found,
and the file contains a non-null value for the <code>x3d.sai.factory.class</code>
key, this value is used as the name of the class to load as the default browser
implementation.
</p>
<p>
In either case (System properties or x3d.properties file), this name must
represent the full package qualified name of the class.
If a System property with the required key does not exist, or an x3d.properties
file does not exist or the x3d.properties file does not contain a property with
the required key for the name of the factory class, then
the default class name <code>org.web3d.x3d.sai.DefaultBrowserImpl</code> is assigned.
</p>
<p>
The class is loaded when a call is made to <code>getBrowser()</code> or
<code>createX3DComponent()</code> using the following method:
</p>

 <pre>
 Class factory_class = Class.forName(factory_class_name);
 factory = (BrowserFactoryImpl)factory_class.newInstance();
 </pre>

<p>
If a class cast exception is raised at the end, then an error is printed
but nothing is done about it. The result would be NullPointerExceptions
later in the code. Also, this may cause some security errors in some
web browsers.
</p>
<p>
To provide a custom implementation of the factory (which all
implementations must do) the user has the choice of the above options
of either setting a System property, making sure that an x3d.properties
file appears in the classpath <xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>before<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text> the sample implementation
that comes with the classes from the X3DC, or by calling setImpl. If
<code>setBrowserFactoryImpl</code> has not been called at the time that
any of the other methods have been, then the class will attempt to load
the implementation defined in the properties file. Attempting to call the
set implementation method after this point shall result in a X3DException
being generated. Otherwise, it shall use the set implementation.
</p>
@author Justin Couch</xsl:with-param>
			<xsl:with-param name="implementationBlock"><xsl:text><![CDATA[
    /** The name of the properties file to read things from */
    private static final String PROPERTIES_FILE_NAME = "x3d.properties";

    /** The name of all the properties that are used by this class */
    private static final String FACTORY_CLASS = "x3d.sai.factory.class";

    /** Properties file location that is Xj3D-specific */
    private static final String XJ3D_PROPERTIES_FILE =
        "config/3.0/spec/" + PROPERTIES_FILE_NAME;

    /** The default values of any properties */
    private static final String DEFAULT_FACTORY_CLASS =
        "org.web3d.x3d.sai.DefaultBrowserImpl";

    /** Null browser factory implementation error message */
    private static final String NULL_BROWSER_FACTORY_IMPL_ERR_MSG =
        "Provided factory is null";

    /** Factory has already been defined error message */
    private static final String FACTORY_ALREADY_DEFINED_ERR_MSG =
        "Factory already defined";

    /** Factory class not found error message */
    private static final String FACTORY_CLASS_NOT_FOUND_ERR_MSG =
        "Unable to find X3D player factory implementation\n";

    /** Unable to instantiate factory error message */
    private static final String UNABLE_TO_INSTANTIATE_FACTORY_ERR_MSG =
        "Error instantiating the X3D player factory\n";

    /** Class not a BrowserFactoryImpl error message */
    private static final String CLASS_NOT_A_BROWSER_FACTORY_IMPL_ERR_MSG =
        "The nominated browser factory is not an instance of ";

    /** BrowserFactoryImpl interface class name */
    private static final String BROWSER_FACTORY_IMPL_INTERFACE_CLASSNAME =
        "org.web3d.x3d.sai.BrowserFactoryImpl";

    /** The reference to the factory implementation used */
    private static BrowserFactoryImpl factory = null;

    /** The list of properties needed by this class */
    private final static Properties vrml_properties;

    /**
     * Static initializer method. Used to load the system properties for
     * this class. If there are none then it sets up the default values
     * that are needed.
     * <p>
     * At this stage it does not load the factory class, just in case the
     * user may set something at a later date.
     */
    static {
        vrml_properties = new Properties();

        // first look in System properties
        String factory_class_name = AccessController.doPrivileged(
                new PrivilegedAction<String>( ) {
                    @Override
                	public String run( ) {
                        return System.getProperty( FACTORY_CLASS );
                    }
                } );

        if ( factory_class_name != null ) {
            vrml_properties.put( FACTORY_CLASS, factory_class_name );
        }
        else {
            // a System property was not defined, look for an x3d.properties file
            InputStream is = null;
            try {
                // fetch the properties file as a stream
                is = AccessController.doPrivileged(
                    new PrivilegedAction<InputStream>() {
                        @Override
                    	public InputStream run() {
                            // privileged code goes here, for example:
                            return ClassLoader.getSystemResourceAsStream(PROPERTIES_FILE_NAME);
                        }
                    });

                // Fallback for WebStart
                if(is == null)
                    is = BrowserFactory.class.getClassLoader().getResourceAsStream(PROPERTIES_FILE_NAME);

                // Now try the Xj3D-internal version location.
                if(is == null) {
                    is = AccessController.doPrivileged(
                        new PrivilegedAction<InputStream>() {
                            @Override
                        	public InputStream run() {
                                // privileged code goes here, for example:
                                return ClassLoader.getSystemResourceAsStream(XJ3D_PROPERTIES_FILE);
                            }
                        });
                }

                // Fallback for WebStart
                if(is == null)
                    is = BrowserFactory.class.getClassLoader().getResourceAsStream(XJ3D_PROPERTIES_FILE);

                // If there is no x3d.properties file, then fill the properties list
                // ourselves so that everything works as advertised later on.
                if(is == null)
                    vrml_properties.put(FACTORY_CLASS, DEFAULT_FACTORY_CLASS);
                else {
                    // from that stream load it into a properties table
                    vrml_properties.load(is);
                }
            } catch(IOException ioe) {
                System.err.println(ioe);
            } finally {
                try {
                    is.close();
                } catch(IOException ioe) { }
            }
        }
    }

    /**
     * Remove the constructor from public calling. Should never instantiate
     * this class.
     */
    private BrowserFactory() {
    }

    /**
     * Set the factory implementation to use. If the parameter value is null
     * an exception will be thrown.
     *
     * @param fac - The new implementation to use
     * @throws SecurityException The environment does not allow a factory
     *   to be set
     * @throws IllegalArgumentException The argument factory instance is null
     * @throws X3DException The factory is already defined.
     */
	public static synchronized void setBrowserFactoryImpl( BrowserFactoryImpl fac )
        throws IllegalArgumentException, X3DException, SecurityException {

        if(fac == null)
		{
			String errorNotice = NULL_BROWSER_FACTORY_IMPL_ERR_MSG ;
//			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}

        if(factory != null)
		{
			String errorNotice =  FACTORY_ALREADY_DEFINED_ERR_MSG ;
//			validationResult.append(errorNotice).append("\n");
			throw new X3DException(errorNotice);
		}

        // Check to see whether we can really set the factory needed.
        SecurityManager security = System.getSecurityManager();
        if(security != null)
            security.checkSetFactory();

        factory = fac;
    }

    /**
     * Create an X3D player that can be used as an AWT component. The component
     * returned is guaranteed to be an instance of X3DComponent.
     *
     * @param params - Parameters to control the look and feel.
     * @return The component browser initialised to be empty.
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D player.
     * @see X3DComponent
     */
	public static X3DComponent createX3DComponent(Map<String, Object> params) throws NotSupportedException
    {
        X3DComponent comp = null;

        try {
            if(factory == null)
                loadFactoryImpl();

            // comp = factory.createComponent(params);  // TODO fix incorrect method signature
        } catch (NotSupportedException nse) {
            System.err.println("Tracing exception for debug:   Factory: " + factory);
            nse.printStackTrace(System.err);
            throw nse;
        }
        return comp;
    }

    /**
     * Get a browser from the given java applet reference as a base in the
     * current HTML page. Used when attempting to access a browser on the current
     * page as this applet and is the first browser on the page. Generically, the
     * same as calling getBrowser(applet, "", 0);
     *
     * @param applet The applet reference to use
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D player
     * @exception NoSuchBrowserException Could not locate an X3D player on the
     *    same page as the applet.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
	public static ExternalBrowser getBrowser(Applet applet)
        throws NotSupportedException, NoSuchBrowserException, ConnectionException {

        if(factory == null)
            loadFactoryImpl();

        // return factory.getBrowser(applet);  // TODO fix incorrect method signature
		return null; // throw NotSupportedException(); // TODO fix incorrect method signature
    }

    /**
     * Get a browser from the given java applet reference one some named page and
     * at some embed location. Used when attempting to access a browser on
     * another HTML page within a multi-framed environment, or if there are a
     * number of X3D player instances located on the same page.
     * <p>
     * If the frame name is a zero length string or null then it is assumed to be
     * located on the same HTML page as the applet. The index is the number of
     * the embed X3D player starting from the top of the page. If there are
     * other non-X3D plugins embedded in the page these are not taken into
     * account in calculating the embed index.
     *
     * @param applet - The applet reference to use
     * @param frameName - The name of the frame to look into for the browser
     * @param index - The embed index of the X3D player in the page
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D player.
     * @exception NoSuchBrowserException Could not locate an X3D player on the
     *    same page as the applet.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
	public static ExternalBrowser getBrowser(Applet applet, String frameName, int index)
        throws NotSupportedException, NoSuchBrowserException, ConnectionException {

        if(factory == null)
            loadFactoryImpl();

        // return factory.getBrowser(applet, frameName, index);  // TODO fix incorrect method signature
		return null;
    }

    /**
     * Get a reference to a browser that is located on a remote machine. This
     * a server application to send scene updates to a number of client browsers
     * located on remote machines. If there are a number of browsers running on
     * a remote machine, they can be differentiated by the port number they are
     * listening on.
     * <p>
     * There is no default port number for X3D players.
     *
     * @param address - The address of the machine to connect to
     * @param port - The port number on that machine to connect to.
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D player.
     * @exception NoSuchBrowserException Could not locate an X3D player on the
     *    same page as the applet.
     * @exception UnknownHostException Could not find the machine named in the
     *    address.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
	public static ExternalBrowser getBrowser(InetAddress address, int port)
        throws NotSupportedException, NoSuchBrowserException, UnknownHostException,
    ConnectionException {

        if(factory == null)
            loadFactoryImpl();

        // return factory.getBrowser(address, port);  // TODO fix incorrect method signature
		return null;
    }

    /**
     * Private method to load the resource file and use the appropriate class
     * defined in the properties file for dealing with the resource management
     * <p>
     * Assumes that the factory reference is currently null as it automatically
     * writes over the top of it.
     */
    private static void loadFactoryImpl( ) {

        try {
            // load the factory class
            String factory_class_name =
            vrml_properties.getProperty( FACTORY_CLASS, DEFAULT_FACTORY_CLASS );

            Class<?> factory_class = Class.forName( factory_class_name );
            factory = (BrowserFactoryImpl)factory_class.newInstance( );

        } catch( ClassNotFoundException cnfe ) {
            System.err.println( FACTORY_CLASS_NOT_FOUND_ERR_MSG );
            //cnfe.printStackTrace(System.err);

        } catch( InstantiationException ie ) {
            System.err.println( UNABLE_TO_INSTANTIATE_FACTORY_ERR_MSG );
            //ie.printStackTrace(System.err);

        } catch( IllegalAccessException iae ) {
            System.err.println( iae );
            //iae.printStackTrace(System.err);

        } catch( ClassCastException cce ) {
            System.err.println( CLASS_NOT_A_BROWSER_FACTORY_IMPL_ERR_MSG +
                BROWSER_FACTORY_IMPL_INTERFACE_CLASSNAME );
            //cce.printStackTrace(System.err);
        }
    }
]]></xsl:text></xsl:with-param>
		</xsl:call-template>

		<!-- TODO not defined in specification but apparently necessary? -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserFactoryImpl</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text><![CDATA[
import java.applet.Applet;
import java.net.UnknownHostException;
import java.net.InetAddress;
import java.util.Map;
]]></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Implementation of factory class for obtaining references to browser instances.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text><![CDATA[
<p>
The factory implementation interface for obtaining references to browser
instances.
</p>
<p>
Any implementation of a X3D browser that wishes to provide their own
customised version of the browser factory should must subclass this class.
In particular this is useful if the implementation needs to stay within the
package defined by the application for other reasons.
</p>
<p>
A default implementation of this class is the DefaultBrowserFactoryImpl which
is package access only.
</p>]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /**
     * Create a X3D browser that can be used as an AWT component. The component
     * returned is guaranteed to be an instance of X3DComponent.
     *
     * @param params Parameters to control the look and feel.
     * @return The component browser initialised to be empty.
     * @exception NotSupportedException The implementation does not support this
     *    type of browser.
     * @see X3DComponent
     */
    X3DComponent createComponent(Map<String, Object> params) throws NotSupportedException;

    /**
     * Get a browser from the given java applet reference as a base in the
     * current HTML page. Used when attempting to access a browser on the current
     * page as this applet and is the first browser on the page. Generically, the
     * same as calling getBrowser(applet, "", 0);
     *
     * @param applet The applet reference to use
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D browser
     * @exception NoSuchBrowserException Could not locate a X3D browser on the
     *    same page as the applet.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
    ExternalBrowser getBrowser(Applet applet) throws NotSupportedException, NoSuchBrowserException, ConnectionException;

    /**
     * Get a browser from the given java applet reference one some named page and
     * at some embed location. Used when attempting to access a browser on
     * another HTML page within a multi-framed environment, or if there are a
     * number of X3D browser instances located on the same page.
     * <p>
     * If the frame name is a zero length string or null then it is assumed to be
     * located on the same HTML page as the applet. The index is the number of
     * the embed X3D browser starting from the top of the page. If there are
     * other non-X3D plugins embedded in the page these are not taken into
     * account in calculating the embed index.
     *
     * @param applet The applet reference to use
     * @param frameName The name of the frame to look into for the browser
     * @param index The embed index of the X3D browser in the page
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D browser.
     * @exception NoSuchBrowserException Could not locate a X3D browser on the
     *    same page as the applet.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
    ExternalBrowser getBrowser(Applet applet,
                               String frameName,
                               int index)
        throws NotSupportedException, NoSuchBrowserException, ConnectionException;

    /**
     * Get a reference to a browser that is located on a remote machine. This
     * a server application to send scene updates to a number of client browsers
     * located on remote machines. If there are a number of browsers running on
     * a remote machine, they can be differentiated by the port number they are
     * listening on.
     * <p>
     * There is no default port number for X3D browsers.
     *
     * @param address The address of the machine to connect to
     * @param port The port number on that machine to connect to.
     * @return A reference to the Browser implementation
     * @exception NotSupportedException The implementation does not support this
     *    type of X3D browser.
     * @exception NoSuchBrowserException Could not locate a X3D browser on the
     *    same page as the applet.
     * @exception UnknownHostException Could not find the machine named in the
     *    address.
     * @exception ConnectionException An error occurred during the connecting
     *    process
     */
    ExternalBrowser getBrowser(InetAddress address, int port)
        throws NotSupportedException, NoSuchBrowserException, UnknownHostException, ConnectionException;
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- TODO not defined in specification but apparently necessary? -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DComponent</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text><![CDATA[
<p>
Provides for implementation of a X3D player than runs as a
component and able to extract a Browser reference from it.
</p>
<p>
Generally this is used to provide a definition of an AWT component with a
VRML/X3D display capability. There is no reason why this can not be used for
other browser representations such as off-screen renderers or file savers.
<p>
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /**
     * Get a browser reference from this component that represents the
     * internals of this browser.
     *
     * @return A reference to the browser object represented by this component.
     */
    ExternalBrowser getBrowser();

    /**
     * Get a reference to the component implementation. For example, if this
     * is an AWT component, it would return an instance of {@link java.awt.Component}.
     * @return a reference to the component implementation
     */
    Object getImplementation();

    /**
     * Shutdown the component because it will no longer be needed. If the
     * component has already had this method called, it will silently ignore
     * any further requests.
     */
    void shutdown();
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<!-- TODO not defined in specification but apparently necessary?? check duplicated inner class above -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>ExternalBrowser</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock"><xsl:text><![CDATA[
<p>
Browser interface that represents the additional abilities an external
application is granted to the X3D browser.
</p>
<p>
A number of the methods in this application can take strings representing URLs.
relative URL strings contained in URL fields of nodes or these method
arguments are interpreted as follows:
</p>
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /**
     * Lock the output from the external interface to the browser as the code
     * is about to begin a series of updates. No events will be passed to the
     * X3D world. They will be buffered pending release due to a subsequent
     * call to endUpdate.
     * <p>
     * This call is a nesting call which means subsequent calls to beginUpdate
     * are kept on a stack. No events will be released to the X3D browser
     * until as many endUpdates have been called as beginUpdate.
     *
     * @exception InvalidBrowserException The dispose method has been called on
     *    this browser reference.
     * @exception ConnectionException An error occurred in the connection to the
     *    browser.
     */
    void beginUpdate() throws InvalidBrowserException;

    /**
     * Release the output of events from the external interface into the
     * X3D browser. All events posted to this point from the last time that
     * beginUpdate was called are released into the X3D browser for
     * processing at the next available opportunity.
     * <p>
     * This call is a nesting call which means subsequent calls to beginUpdate
     * are kept on a stack. No events will be released to the X3D browser
     * until as many endUpdates have been called as beginUpdate.
     * <p>
     * If no beginUpdate has been called before calling this method, it has
     * no effect.
     *
     * @exception InvalidBrowserException The dispose method has been called on
     *    this browser reference.
     * @exception ConnectionException An error occurred in the connection to the
     *    browser.
     */
    void endUpdate() throws InvalidBrowserException;

    /**
     * Add a listener for browser events. Any changes in the browser will be
     * sent to this listener. The order of calling listeners is not guaranteed.
     * Checking is performed on whether the nominated listener is already
     * registered to ensure that multiple registration cannot take place.
     * Therefore it is possible to multiply register the one class
     * instance while only receiving one event.
     *
     * @param l The listener to add.
     * @exception NullPointerException If the provided listener reference is
     *     null
     * @exception InvalidBrowserException The dispose method has been called on
     *    this browser reference.
     * @exception ConnectionException An error occurred in the connection to the
     *    browser.
     */
    void addBrowserListener(BrowserListener l) throws InvalidBrowserException;

    /**
     * Remove a listener for browser events. After calling this method, the
     * listener will no longer receive events from this browser instance. If the
     * listener passed as an argument is not currently registered, the method
     * will silently exit.
     *
     * @param l The listener to remove
     * @exception NullPointerException If the provided listener reference is
     *     null
     * @exception InvalidBrowserException The dispose method has been called on
     *    this browser reference.
     * @exception ConnectionException An error occurred in the connection to the
     *    browser.
     */
    void removeBrowserListener(BrowserListener l) throws InvalidBrowserException;

    /**
     * Dispose the resources that are used by this instance. Should be called
     * just prior to leaving the application.
     */
    void dispose();
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>
		
		<!-- TODO not defined in specification but apparently necessary?? check duplicated inner class above -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserListener</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>java.util.EventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Listener interface for classes wishing to know about changes in the browser</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.5.2 BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserFactory</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="interfaceBlock"><xsl:text><![CDATA[
    /**
     * Process an event that has occurred in the X3D player.
     *
     * @param event The event that caused this method to be called
     */
    void browserChanged(BrowserEvent event);
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>
		
    </xsl:template>
	
    <!-- ===================================================== -->
	
	<xsl:template name="StatementInterfaces">
		
		<xsl:variable name="subPackage">
			<xsl:if test="($modifySpecificationInterfaces = 'true')">
				<xsl:text>statements</xsl:text>
			</xsl:if>
		</xsl:variable>
		
		<!-- B.6 Statement interfaces -->
		<!-- http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2/abstracts.html#StatementInterfaces -->
		
		<!-- TODO: specification  definitions for other statements; add accessor methods for setting values -->

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>ComponentInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.1 ComponentInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#ComponentInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>7.2.5.4 COMPONENT statement</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>components/core.html#COMPONENTStatement</xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
Description of a single component.1188311883
A component description contains useful pieces of information about
the requirements. Of primary importance is the specification component name and level.
Additional information includes title and URL for the component provider.
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[
    /**
     * Get the name of this component.
     * @return name The name of the component
     */
	public String getName();
				
    /**
     * Get the level of the component. A level is always greater than zero.
     * The level information may represent one of two things, depending on
     * how the component info was created. When created as part of a file that
     * is requesting a specific level of support, the level will indicate the
     * requested level, not the maximum available on the system. When this is
     * returned from a query of the system to see what components are available
     * then the level is maximum supported by the implementation.
     *
     * @return The level value for the component
	 */
	public int getLevel();
				
    /**
     * Get the title of this component. This is a long-form version that can
     * be used in a UI. If no title is set, will return null.
     *
     * @return The title string of the component
     */
	public String getTitle();
				
    /**
     * Get the URL of the provider. This is used for user interface information
     * to point an end user at someone who has implemented this bit of
     * functionality. It is not used by the system to download the component
     * or its definition.
     *
     * @return The URL of the provider as a string
     */
	public String getProviderURL();
				
    /**
     * Return a formatted string version of this component that conforms to
     * the X3D specification for X3D file encoding. The string will start
     * with the <code>COMPONENT</code> keyword, as per specification.
     *
     * @return A correctly formatted string.
     */
	public String toX3DString(); // TODO re-check: toStringX3D
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>ProfileInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.2 ProfileInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#ProfileInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>7.2.5.3 PROFILE statement</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>components/core.html#PROFILEStatement</xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
Description of a single profile, which is a collection of components.
A profile defines the player or tool support needed for a particular scene.
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[
    /**
     * Get the name of this component.
     *
     * @return name The name of the component
     */
	public String getName();
				
    /**
     * Get the title of this component. This is a long-form version that can
     * be used in a UI.
     *
     * @return The title string of this component
     */
	public String getTitle();
				
    /**
     * Get the list of defined components for this profile. A profile will
     * always have one or more components.
     *
     * @return An array of ComponentInfo definitions for this profile
     */
	public ComponentInfo[] getComponents();

    /**
     * Return a formatted string version of this component that conforms to
     * the X3D specification for X3D file encoding. The string will start
     * with the <code>PROFILE</code> keyword, as per specification.
     *
     * @return A correctly formatted string
     */
	public String toX3DString(); // TODO re-check: toStringX3D
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>UnitInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.3 UnitInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#UnitInfo</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>7.2.5.5 UNIT statement</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text>components/core.html#UNITStatement</xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
UNIT statements define data conversion factors for a scene that can override default units of measure for angles in radians, length in meters, etc. 
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="interfaceBlock">
				<xsl:text><![CDATA[
    /**
     * Get the name of this UNIT statement.
     *
     * @return The name of the UNIT statement
     */
	public String getName();
					
    /**
     * Get the category (angle | length | force | mass) of this UNIT statement.
     *
     * @return The category of the UNIT statement
     */
	public String getCategory();
					
    /**
     * Get the positive double-precision factor that converts new base unit to default base unit.
     *
     * @return The positive double-precision conversion factor of the UNIT statement
     */
	public double getConversionFactor();

    /**
     * Return a formatted string version of this component that conforms to
     * the X3D specification for X3D file encoding. The string will start
     * with the <code>UNIT</code> keyword, as per specification.
     *
     * @return A correctly formatted string
     */
	public String toX3DString(); // TODO re-check: toStringX3D
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>
		
    </xsl:template>
	
    <!-- ===================================================== -->
	
	<xsl:template name="ExceptionDefinitions">
		
		<xsl:variable name="subPackage">
			<xsl:if test="($modifySpecificationInterfaces = 'true')">
				<xsl:text>exceptions</xsl:text>
			</xsl:if>
		</xsl:variable>
		
		<!-- B.7 Exception definitions -->
		<!-- http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2/abstracts.html#ExceptionDefinitions -->
		
		<!-- TODO fix specification definitions to be interfaces for all of these classes, can't simply define method stubs in class definitions -->
		
		<!-- TODO fix specification TOC bookmark -->
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>RuntimeException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.1 X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The basic exception that is thrown by any X3D method call that needs to
throw an exception.

Based on RuntimeException so that the user has the choice of deciding
whether to catch the exception or not.
]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public X3DException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public X3DException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>BrowserNotSharedException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.2 BrowserNotSharedException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#BrowserNotSharedException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to make method calls
that require this browser to be shared.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public BrowserNotSharedException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public BrowserNotSharedException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>ConnectionException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.3 ConnectionException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#ConnectionException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when an error occurs in the connection between
the external application and the X3D browser. Typically this might be a
network connection stopping or similar problem.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public ConnectionException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public ConnectionException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>ImportedNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.6.4 ImportedNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#ImportedNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to use an IMPORTed node
incorrectly in the scene graph.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public ImportedNodeException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public ImportedNodeException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InsufficientCapabilitiesException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.5 InsufficientCapabilitiesException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InsufficientCapabilitiesException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a node of greater capabilities than
the scene's declared profile and additional components is attempted to be
added to that scene.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InsufficientCapabilitiesException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InsufficientCapabilitiesException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.6 InvalidBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to access a method in
the Browser interface after the reference has had the dispose method called.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidBrowserException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidBrowserException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidDocumentException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.7 InvalidDocumentException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidDocumentException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to import a DOM Document
to make it into an X3DScene and the document is not correctly structured.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidDocumentException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidDocumentException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidExecutionContextException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.8 InvalidExecutionContextException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidExecutionContextException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a reference to an ExecutionContext is
not valid.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidExecutionContextException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidExecutionContextException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidFieldException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.9 InvalidFieldException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidFieldException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
<p>
The exception that is thrown when a reference to any field is not valid.
Generally used as a base class to more specific invalid field methods.
</p>
<p>
A field may be invalid for a number of reasons:
</p>
<ul>
	<li>The user may have typed in the wrong name through a typo.</li>
	<li>The name may not correspond to a field in that node at all.</li>
	<li>The name given refers to a valid field but the field cannot be
     accessed as an outputOnly field.</li>
</ul></xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidFieldException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidFieldException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidFieldValueException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.10 InvalidFieldValueException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidFieldValueException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
This exception may be generated when a node verifies the correctness of a setValue operation.
The exception can occur during the scene-parsing process, or else by the field during
runtime as the user is trying to modify it.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidFieldValueException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidFieldValueException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.11 InvalidNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidNodeException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a reference to a Node is not valid.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidNodeException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidNodeException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidOperationTimingException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.12 InvalidOperationTimingException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidOperationTimingException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the user attempts to use an API call
outside of the predefined times when allowed.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidOperationTimingException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidOperationTimingException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidProtoException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.13 InvalidProtoException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidProtoException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a reference to a ProtoDeclare, ExternProtoDeclare
or ProtoInstance is not valid.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidProtoException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidProtoException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidRouteException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.14 InvalidRouteException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidRouteException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when any reference used by a ROUTE is not valid.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidRouteException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidRouteException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidURLException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text>B.7.15 InvalidURLException</xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidURLException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the ordered list of all URL and URN values are
invalid and cannot be parsed to form a proper URL/URN.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidURLException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidURLException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>InvalidX3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.16 InvalidX3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#InvalidX3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a the string passed to createVrmlFromString
or createX3dFromString method does not contain legal X3D, using either
UTF8 or XML syntax.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public InvalidX3DException()
	{
		// TODO
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public InvalidX3DException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>NodeInUseException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.17 NodeInUseException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#NodeInUseException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when a reference to a Node is already being
used when the user wants to add a new DEF, EXPORT or IMPORT definition.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public NodeInUseException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public NodeInUseException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>NodeUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.18 NodeUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#NodeUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when asking for a Node by name, and the
name is valid but the underlying node reference is not available from the
Inline yet.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public NodeUnavailableException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public NodeUnavailableException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>NoSuchBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.19 NoSuchBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#NoSuchBrowserException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the Browser factory is not able to locate
a browser with the given arguments.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public NoSuchBrowserException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public NoSuchBrowserException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>NotSupportedException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.20 NotSupportedException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#NotSupportedException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when an operation is not supported by an
underlying implementation.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public NotSupportedException()
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public NotSupportedException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>

		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>URLUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:value-of select="$subPackage"/></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text>X3DException</xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.7.21 URLUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#URLUnavailableException</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="javadocBlock">
				<xsl:text><![CDATA[
The exception that is thrown when the URL is not specified for the currently
browser instance or there is some other problem.]]></xsl:text>
			</xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text><![CDATA[
    /**
     * Construct a basic instance of this exception with no error message.
     */
	public URLUnavailableException() 
	{
    }

    /**
     * Constructs a new exception with a specific message report.
     * @param message description for this exception
     */
	public URLUnavailableException (String message)
    {
        super(message);
    }
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>
    </xsl:template>
	
    <!-- ===================================================== -->
	
	<xsl:template name="NodeTypeDefinitions">
		
		<!-- B.2 Node type interfaces definitions -->
		<!-- http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2/abstracts.html#NodeTypeInterfaces -->
		
		<xsl:for-each select="//AbstractNodeTypes/AbstractNodeType">
			
			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="extends"                             select="InterfaceDefinition/Inheritance/@baseType"/>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>
		
			<!-- TODO add specification parameters... -->
			
			<xsl:variable name="additionalInheritances">
				<xsl:for-each select="InterfaceDefinition/AdditionalInheritance">
					<xsl:text>, </xsl:text>
					<xsl:value-of select="@baseType"/>
				</xsl:for-each>
			</xsl:variable>
			
			<xsl:variable name="imports">
				<!-- TODO do not import inherited (extends) interface if in same package -->
				<xsl:variable name="baseType"   select="$extends"/>
				<xsl:variable name="subPackage" select="//*[@name=$baseType]/InterfaceDefinition/componentInfo/@name"/><!-- corresponding subPackage name -->
				<xsl:if test="(string-length($extends) > 0) and (string-length($subPackage) > 0) and (string-length($baseType) > 0) and
                              ($componentName != $subPackage)">
					<xsl:text>import org.web3d.x3d.sai.</xsl:text>
					<xsl:if test="(string-length($subPackage) > 0)">
						<xsl:value-of select="$subPackage"/>
						<xsl:text>.</xsl:text>
					</xsl:if>
					<xsl:value-of select="$baseType"/>
					<xsl:text>;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
					
				<xsl:for-each select="InterfaceDefinition/AdditionalInheritance">
					<xsl:variable   name="baseType" select="@baseType"/>
					<xsl:variable name="subPackage" select="//*[@name=$baseType]/InterfaceDefinition/componentInfo/@name"/><!-- corresponding subPackage name -->
					<!-- avoid imports from same package -->
					<xsl:if test="($componentName != $subPackage)">
						<xsl:text>import org.web3d.x3d.sai.</xsl:text>
						<xsl:if test="(string-length($subPackage) > 0)">
							<xsl:value-of select="$subPackage"/>
							<xsl:text>.</xsl:text>
						</xsl:if>
						<xsl:value-of select="$baseType"/>
						<xsl:text>;</xsl:text>
						<xsl:text>&#10;</xsl:text>
					</xsl:if>
				</xsl:for-each>
			</xsl:variable>
			
			<!-- TODO specification needs to say that abstract node types need to go into subpackage corresponding to component -->
	  
			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:value-of select="$imports"/></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:value-of select="$extends"/><xsl:value-of select="$additionalInheritances"/></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>TODO</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>TODO</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>
			<xsl:variable name="inheritanceName"                       select="InterfaceDefinition/Inheritance/@baseType"/>
			<xsl:variable name="inheritanceComponent"                  select="concat(//AbstractNodeType  [@name = $inheritanceName]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $inheritanceName]/InterfaceDefinition/componentInfo/@name)"/>
				
			<xsl:variable name="additionalInheritanceName1"            select="InterfaceDefinition/AdditionalInheritance[1]/@baseType"/>
			<xsl:variable name="additionalInheritanceComponent1"       select="concat(//AbstractNodeType  [@name = $additionalInheritanceName1]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $additionalInheritanceName1]/InterfaceDefinition/componentInfo/@name)"/>
			<xsl:variable name="additionalInheritanceName2"            select="InterfaceDefinition/AdditionalInheritance[2]/@baseType"/>
			<xsl:variable name="additionalInheritanceComponent2"       select="concat(//AbstractNodeType  [@name = $additionalInheritanceName2]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $additionalInheritanceName2]/InterfaceDefinition/componentInfo/@name)"/>
			<xsl:variable name="extendsInterface">
				<xsl:text>org.web3d.x3d.sai.</xsl:text>
				<xsl:value-of select="$componentName"/>
				<xsl:text>.</xsl:text>
				<xsl:value-of select="$name"/>
				
					<xsl:if test="(count(InterfaceDefinition/Inheritance) > 0) and (string-length($inheritanceComponent) > 0)">
						<xsl:text>,</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>										org.web3d.x3d.jsail.</xsl:text>
						<xsl:value-of select="$inheritanceComponent"/>
						<xsl:text>.</xsl:text>
						<xsl:value-of select="$inheritanceName"/>
						<xsl:value-of select="$jsaiInterfaceSuffix"/>
					</xsl:if>
					<xsl:if test="(count(InterfaceDefinition/AdditionalInheritance) > 0) and (string-length($additionalInheritanceComponent1) > 0)">
						<xsl:text>,</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>										org.web3d.x3d.jsail.</xsl:text>
						<xsl:value-of select="$additionalInheritanceComponent1"/>
						<xsl:text>.</xsl:text>
						<xsl:value-of select="$additionalInheritanceName1"/>
						<xsl:value-of select="$jsaiInterfaceSuffix"/>
					</xsl:if>
					<xsl:if test="(count(InterfaceDefinition/AdditionalInheritance) > 1) and (string-length($additionalInheritanceComponent2) > 0)">
						<xsl:text>,</xsl:text>
						<xsl:text>&#10;</xsl:text>
						<xsl:text>						org.web3d.x3d.jsail.</xsl:text>
						<xsl:value-of select="$additionalInheritanceComponent2"/>
						<xsl:text>.</xsl:text>
						<xsl:value-of select="$additionalInheritanceName2"/>
						<xsl:value-of select="$jsaiInterfaceSuffix"/>
					</xsl:if>
					<!-- debug 
					<xsl:text> // end extendsInheritance</xsl:text>
					-->
			</xsl:variable>

<!-- debug -->
<xsl:if test="($debug = 'true')">
<xsl:message>
<xsl:text>// NodeTypeDefinitions interfaces ($nameInterface=</xsl:text>
<xsl:value-of select="$name"/><xsl:value-of select="$jsaiInterfaceSuffix"/>
<xsl:text>, $inheritanceName=</xsl:text>
<xsl:value-of select="$inheritanceName"/>
<xsl:text>, $inheritanceComponent=</xsl:text>
<xsl:value-of select="$inheritanceComponent"/>
<xsl:text>, $additionalInheritanceName1=</xsl:text>
<xsl:value-of select="$additionalInheritanceName1"/>
<xsl:text>, $additionalInheritanceComponent1=</xsl:text>
<xsl:value-of select="$additionalInheritanceComponent1"/>
<xsl:text>, $additionalInheritanceName2=</xsl:text>
<xsl:value-of select="$additionalInheritanceName2"/>
<xsl:text>, $additionalInheritanceComponent2=</xsl:text>
<xsl:value-of select="$additionalInheritanceComponent2"/>
<xsl:text>)</xsl:text>
</xsl:message>
</xsl:if>
		</xsl:for-each>		
    </xsl:template>
	
    <!-- ===================================================== -->
	
	<xsl:template name="ObjectTypeDefinitions">
		
		<!-- B.3 Auxiliary node type interfaces definitions -->
		<!-- http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2/abstracts.html#AuxiliaryNodeTypeInterfaces -->
		
		<xsl:for-each select="//AbstractObjectTypes/AbstractObjectType">
			
			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="extends"                             select="InterfaceDefinition/Inheritance/@baseType"/>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>
	  
			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:value-of select="$extends"/></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>TODO</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>abstracts.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text>TODO</xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:for-each>		
    </xsl:template>
	
    <!-- ===================================================== -->
	
	<xsl:template name="NodeInterfacesDefinitions">
		
		<!-- B.3 Auxiliary node type interfaces definitions -->
		<!-- http://www.web3d.org/documents/specifications/19777-2/V3.0/Part2/abstracts.html#AuxiliaryNodeTypeInterfaces -->
		
		<xsl:for-each select="//ConcreteNodes/ConcreteNode">
			
			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="extends"                             select="InterfaceDefinition/Inheritance/@baseType"/>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>
				
			<xsl:variable name="additionalInheritances">
				<xsl:for-each select="InterfaceDefinition/AdditionalInheritance">
					<xsl:text>, </xsl:text>
					<xsl:value-of select="@baseType"/>
				</xsl:for-each>
			</xsl:variable>
			
			<xsl:variable name="imports">
				<!-- TODO do not import inherited (extends) interface if in same package -->
				<xsl:variable name="baseType"   select="$extends"/>
				<xsl:variable name="subPackage" select="//*[@name=$baseType]/InterfaceDefinition/componentInfo/@name"/><!-- corresponding subPackage name -->
				<xsl:if test="(string-length($extends) > 0) and (string-length($subPackage) > 0) and (string-length($baseType) > 0) and
                              ($componentName != $subPackage)">
					<xsl:text>&#10;</xsl:text>
					<xsl:text>import org.web3d.x3d.sai.</xsl:text>
					<xsl:if test="(string-length($subPackage) > 0)">
						<xsl:value-of select="$subPackage"/>
						<xsl:text>.</xsl:text>
					</xsl:if>
					<xsl:value-of select="$baseType"/>
					<xsl:text>;</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
					
				<xsl:for-each select="InterfaceDefinition/AdditionalInheritance">
					<xsl:variable   name="baseType" select="@baseType"/>
					<xsl:variable name="subPackage" select="//*[@name=$baseType]/InterfaceDefinition/componentInfo/@name"/><!-- corresponding subPackage name -->
					<!-- avoid imports from same package -->
					<xsl:if test="($componentName != $subPackage)">
						<xsl:text>import org.web3d.x3d.sai.</xsl:text>
						<xsl:if test="(string-length($subPackage) > 0)">
							<xsl:value-of select="$subPackage"/>
							<xsl:text>.</xsl:text>
						</xsl:if>
						<xsl:value-of select="$baseType"/>
						<xsl:text>;</xsl:text>
						<xsl:text>&#10;</xsl:text>
					</xsl:if>
				</xsl:for-each>
			</xsl:variable>
			
			<!-- TODO add variable $x3dAbstractSpecificationSection -->
	  
			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:value-of select="$imports"/></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:value-of select="$extends"/><xsl:value-of select="$additionalInheritances"/></xsl:with-param>
				<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>TODO</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>concretes.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
			</xsl:call-template>
			
		</xsl:for-each>
		
		<!-- create Javadoc package.html files for each subpackage -->
		<xsl:for-each select="//componentInfo[not(@name = preceding::componentInfo/@name)]">
		
			<xsl:variable name="componentName" select="translate(@name,'-','')"/>
			<xsl:variable name="sourceFilePath">
				<xsl:value-of select="$saiPackageDirectorySource"/>
				<xsl:text>/</xsl:text>
				<xsl:value-of select="translate(@name,'-','')"/><!-- no componentName hypens allowed (e.g. H-Anim) -->
				<xsl:text>/</xsl:text>
				<xsl:text>package.html</xsl:text>
			</xsl:variable>
			
			<xsl:variable name="componentDescription" select="//SimpleType[@name='componentNames']/enumeration[translate(@value,'-','') = $componentName]/@appinfo"/>
			
			<!-- debug
			<xsl:message>
				<xsl:text>*** componentName=</xsl:text>
				<xsl:value-of select="$componentName"/>
				<xsl:text>, sourceFilePath=</xsl:text>
				<xsl:value-of select="$sourceFilePath"/>
				<xsl:text>, componentDescription=</xsl:text>
				<xsl:value-of select="$componentDescription"/>
			</xsl:message> 
			-->
			
			<xsl:if test="(string-length($componentDescription) > 0)">
				<!-- create source file -->
				<xsl:result-document href="{$targetPath}{$sourceFilePath}" method="html" omit-xml-declaration="yes" encoding="UTF-8" indent="yes">
					<xsl:element name="html">
						<xsl:element name="body">
							<xsl:element name="p">
								<xsl:text>&#10;</xsl:text>
								<xsl:value-of select="$componentDescription"/>
							</xsl:element>
						</xsl:element>
					</xsl:element>

				</xsl:result-document>
			</xsl:if>			
		</xsl:for-each><!-- finished Javadoc package.html files for each subpackage -->
		
		<!-- root package.html -->
		<xsl:result-document href="{$targetPath}{$saiPackageDirectorySource}/package.html" method="html" omit-xml-declaration="yes" encoding="UTF-8" indent="yes">
			<xsl:element name="html">
				<xsl:element name="body">
					<xsl:element name="p">
						<xsl:text>
	The X3D Java Scene Access Interface (SAI) package is designed to 
	provide access to a browser and its contained scene graph,
	either within an internal X3D Script node or an external HTML script.</xsl:text>
					</xsl:element>
					<xsl:element name="p">
						<xsl:text>
	This package contains specification-defined X3D SAI interfaces and utility classes, 
	used for compiling Java source code to be used by an X3D Script node.
						</xsl:text>
					</xsl:element>
				</xsl:element>
			</xsl:element>
		</xsl:result-document>
		
    </xsl:template>
	
    <!-- ===================================================== -->
	
	<xsl:template name="ConcreteNodeObjectDefinitions">
		
		<!-- TODO X3D Java Language Binding specification section on concrete classes that match X3D Abstract Specification -->
		<!-- http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/nodeIndex.html -->
		
		<!-- Concrete classes for X3D nodes - - - - - - - - - -->
		
		<xsl:for-each select="//ConcreteNodes/ConcreteNode">
			
			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description"                         select="InterfaceDefinition/@appinfo"/>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="interfaceName"                       select="InterfaceDefinition/Inheritance/@baseType"/>
			<xsl:variable name="interfaceComponent"                  select="concat(//AbstractNodeType  [@name = $interfaceName]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $interfaceName]/InterfaceDefinition/componentInfo/@name)"/>
			<xsl:variable name="additionalInterfaceName1"            select="InterfaceDefinition/AdditionalInheritance[1]/@baseType"/>
			<xsl:variable name="additionalInterfaceComponent1"       select="concat(//AbstractNodeType  [@name = $additionalInterfaceName1]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $additionalInterfaceName1]/InterfaceDefinition/componentInfo/@name)"/>
			<xsl:variable name="additionalInterfaceName2"            select="InterfaceDefinition/AdditionalInheritance[2]/@baseType"/>
			<xsl:variable name="additionalInterfaceComponent2"       select="concat(//AbstractNodeType  [@name = $additionalInterfaceName2]/InterfaceDefinition/componentInfo/@name,
                                                                                    //AbstractObjectType[@name = $additionalInterfaceName2]/InterfaceDefinition/componentInfo/@name)"/>
			<xsl:variable name="implements">
				<!-- SAI abstract interface reference -->
				<xsl:text>org.web3d.x3d.sai.</xsl:text>
				<xsl:value-of select="$componentName"/>
				<xsl:text>.</xsl:text>
				<xsl:value-of select="@name"/>
				<!-- TODO: remove concrete-package interface references
				<xsl:text>, </xsl:text>
				<xsl:text>&#10;</xsl:text>
				<xsl:text>										org.web3d.x3d.jsail.</xsl:text>
				<xsl:value-of select="$interfaceComponent"/>
				<xsl:text>.</xsl:text>
				<xsl:value-of select="$interfaceName"/>
				<xsl:value-of select="$jsaiInterfaceSuffix"/>
				<xsl:if test="(count(InterfaceDefinition/AdditionalInheritance) > 0) and (string-length($additionalInterfaceComponent1) > 0)">
					<xsl:text>,</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>										org.web3d.x3d.jsail.</xsl:text>
					<xsl:value-of select="$additionalInterfaceComponent1"/>
					<xsl:text>.</xsl:text>
					<xsl:value-of select="$additionalInterfaceName1"/>
					<xsl:value-of select="$jsaiInterfaceSuffix"/>
				</xsl:if>
				<xsl:if test="(count(InterfaceDefinition/AdditionalInheritance) > 1) and (string-length($additionalInterfaceComponent2) > 0)">
					<xsl:text>,</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:text>						org.web3d.x3d.jsail.</xsl:text>
					<xsl:value-of select="$additionalInterfaceComponent2"/>
					<xsl:text>.</xsl:text>
					<xsl:value-of select="$additionalInterfaceName2"/>
					<xsl:value-of select="$jsaiInterfaceSuffix"/>
				</xsl:if> -->
			</xsl:variable>
				
			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>
			
			<!-- TODO add variable $x3dAbstractSpecificationSection -->
	  
			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<!-- TODO fix next -->
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteNode</xsl:text></xsl:with-param>                             
				<xsl:with-param name="implements"><xsl:value-of select="$implements"/></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<!--
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>TODO</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>concretes.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param> -->

				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock"></xsl:with-param>
				<xsl:with-param name="implementationBlock"></xsl:with-param>
			</xsl:call-template>
			
		</xsl:for-each>
		
		<!-- Concrete classes for X3D statements - - - - - - - - - -->
		
		<xsl:for-each select="//Statements/Statement">
			
			<xsl:variable name="name"                                select="@name"/>
			<xsl:variable name="description">
				<xsl:value-of select="InterfaceDefinition/@appinfo"/> <!-- TODO duplicate -->
				<xsl:text> This concrete class represents an X3D </xsl:text>
				<xsl:if test="not($name = 'X3D')">
					<xsl:value-of select="$name"/>
					<xsl:text> </xsl:text>
				</xsl:if>
				<xsl:text>statement. </xsl:text>
			</xsl:variable>
			<xsl:variable name="x3dAbstractSpecificationRelativeUrl" select="substring-after(InterfaceDefinition/@specificationUrl,'Part01/')"/>
			<xsl:variable name="componentName"                       select="translate(InterfaceDefinition/componentInfo/@name,'-','')"/>
			<xsl:variable name="componentLevel"                      select="InterfaceDefinition/componentInfo/@level"/>
			<xsl:variable name="implements">
				<!-- X3D statements are not defined in specification abstract org.web3d.x3d.sai -->
				<xsl:choose>
					<xsl:when test="($name = 'ROUTE') or ($name = 'IMPORT') or ($name = 'EXPORT') or 
									($name = 'ProtoDeclare') or ($name = 'ExternProtoDeclare') or ($name = 'ProtoInstance')">
						<xsl:text>org.web3d.x3d.sai.Core.X3DChildNode</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="extends">
				<!-- X3D statements are not defined in specification abstract org.web3d.x3d.sai -->
				<!-- created for this library to ensure consistency -->
				<xsl:text>org.web3d.x3d.jsail.X3DConcreteStatement</xsl:text>
			</xsl:variable>
			<xsl:variable name="javadocBlock">
				<!-- anything else? -->
			</xsl:variable>
			
			<!-- debug
			<xsl:message>
				<xsl:text>*** X3D Statement @name=</xsl:text>
				<xsl:value-of select="@name"/>
				<xsl:text>, $componentName=</xsl:text>
				<xsl:value-of select="$componentName"/>
				<xsl:text>, $implements=</xsl:text>
				<xsl:value-of select="$implements"/>
			</xsl:message> 
			-->
			
			<!-- TODO add variable $x3dAbstractSpecificationSection -->
	  
			<xsl:call-template name="generateSourceFile">
				<xsl:with-param name="name"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
				<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
				<xsl:with-param name="subPackage"><xsl:value-of select="$componentName"/></xsl:with-param>
				<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteStatement</xsl:text></xsl:with-param>
				<xsl:with-param name="implements"><xsl:value-of select="$implements"/></xsl:with-param>
				<xsl:with-param name="description"><xsl:value-of select="$description"/></xsl:with-param>
				<!--
				<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>TODO</xsl:text></xsl:with-param>
				<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>concretes.html#</xsl:text><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
				<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param> -->

				<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:value-of select="$name"/></xsl:with-param>
				<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:value-of select="$x3dAbstractSpecificationRelativeUrl"/></xsl:with-param>
				<xsl:with-param name="javadocBlock"><xsl:value-of select="$javadocBlock"/></xsl:with-param>
				<xsl:with-param name="interfaceBlock">
					<xsl:text><![CDATA[]]></xsl:text>
				</xsl:with-param>
				<xsl:with-param name="implementationBlock"></xsl:with-param>
			</xsl:call-template>
			
		</xsl:for-each>
		
		<!-- create Javadoc package.html files for each subpackage -->
		<xsl:for-each select="//componentInfo[not(@name = preceding::componentInfo/@name)]">
		
			<xsl:variable name="componentName" select="translate(@name,'-','')"/>
			<xsl:variable name="sourceFilePath">
				<xsl:value-of select="$concretePackageDirectorySource"/>
				<xsl:text>/</xsl:text>
				<xsl:value-of select="translate(@name,'-','')"/><!-- no componentName hypens allowed (e.g. H-Anim) -->
				<xsl:text>/</xsl:text>
				<xsl:text>package.html</xsl:text>
			</xsl:variable>
			
			<xsl:variable name="componentDescription" select="//SimpleType[@name='componentNames']/enumeration[translate(@value,'-','') = $componentName]/@appinfo"/>
			
			<!-- debug
			<xsl:message>
				<xsl:text>*** componentName=</xsl:text>
				<xsl:value-of select="$componentName"/>
				<xsl:text>, sourceFilePath=</xsl:text>
				<xsl:value-of select="$sourceFilePath"/>
				<xsl:text>, componentDescription=</xsl:text>
				<xsl:value-of select="$componentDescription"/>
			</xsl:message> 
			-->
			
			<xsl:if test="(string-length($componentDescription) > 0)">
				<!-- create source file -->
				<xsl:result-document href="{$targetPath}{$sourceFilePath}" method="html" omit-xml-declaration="yes" encoding="UTF-8" indent="yes">
					<xsl:element name="html">
						<xsl:element name="body">
							<xsl:element name="p">
								<xsl:text>&#10;</xsl:text>
								<xsl:value-of select="$componentDescription"/>
							</xsl:element>
						</xsl:element>
					</xsl:element>

				</xsl:result-document>
			</xsl:if>
			
		</xsl:for-each>
		
		<!-- root package.html -->
		<xsl:result-document href="{$targetPath}{$concretePackageDirectorySource}/package.html" method="html" omit-xml-declaration="yes" encoding="UTF-8" indent="yes">
			<xsl:element name="html">
				<xsl:element name="body">
					<xsl:element name="p">
						<xsl:text>
		The X3D Java Scene Access Interface Library (X3DJSAIL) provides a comprehensive set of
        strongly typed X3D Java interfaces for concrete implementation classes.</xsl:text>
					</xsl:element>
					<xsl:element name="p">
						<xsl:text>
		This package contains utility classes and abstract interfaces that are used for all X3D nodes and statements.</xsl:text>
					</xsl:element>
				</xsl:element>
			</xsl:element>
		</xsl:result-document>
		
    <!-- ===================================================== -->
			
	<!-- Utility concrete classes and interfaces for org.web3d.x3d.jsail package -->
	
	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>CommandLine</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text>
// Desktop and Web browser
import java.awt.Desktop;
import java.net.URI;
import java.net.URISyntaxException;
// File operations
import java.io.*;
import java.io.File;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.DecimalFormat;
import org.web3d.x3d.jsail.Core.*;
import org.web3d.x3d.sai.X3DException;
// import org.web3d.x3d.sai.InvalidFieldValueException;</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isUtilityClass"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><!-- top level --></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Concrete class that provides command-line JAR access to various X3DJSAIL capabilities.</xsl:text>
		</xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
 * Usage: <code>% java -jar X3DJSAIL.3.3.classes.jar -help</code>
 * @see <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html">JAR File Specification</a>
 * @see <a href="https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html">Java Tutorials, Lesson: Packaging Programs in JAR Files</a>
]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
				
// TODO JAR configuration

// ==========================================================================================

	/** Loaded X3D model of interest, useful for initialization and use of CommandLine by other X3D Java programs. */
	private static X3DObject loadedX3dModel;

	/** Set already-loaded X3D model of interest, useful for initialization and use of CommandLine by other X3D Java programs. 
	 * @param newX3dModel already-loaded X3D model of interest
	*/
	public static void setLoadedX3dModel (X3DObject newX3dModel)
	{
		loadedX3dModel = newX3dModel;
	}
				
	/** Reset already-loaded X3D model of interest to empty model */
	public static void clearLoadedX3dModel ()
	{
		loadedX3dModel = new X3DObject();
	}

// ==========================================================================================
	
    /** Initialize this CommandLine instance to default values. */
    public static final void initialize()
    {
        clearLoadedX3dModel ();
    }
    /**
     *                               Usage: <code>java -classpath X3DJSAIL.*.jar [sourceModel.x3d | package.path.ProgramName | -help | -page | -resources | -tooltips] [-tofile [resultFile.*]] [-properties [propertiesFile]] [-validate] [sourceModel.exi -fromEXI] [sourceModel.gz -fromGZIP] [sourceModel.zip -fromZIP] [-toX3D | -toXML | -toHTML | -toMarkdown | -toTidy | -toClassicVrml | -toJava | -toJSON | -toVRML97 | -toX3DOM | -toX_ITE | -toEXI | -toGZIP | -toZIP]</code>
     */
    public  static final String USAGE   = "Usage: java -classpath X3DJSAIL.*.jar [sourceModel.x3d | package.path.ProgramName | -help | -page | -resources | -tooltips]\n       [-tofile [resultFile.*]] [-properties [propertiesFile]] [-validate]\n       [sourceModel.exi -fromEXI] [sourceModel.gz -fromGZIP] [sourceModel.zip -fromZIP]\n       [-toX3D | -toXML | -toHTML | -toMarkdown | -toTidy | -toClassicVrml | -toJava | -toJSON | -toVRML97 | -toX3DOM | -toX_ITE | -toEXI | -toGZIP | -toZIP]";
    private static final String WARNING = "[Warning] ";
    private static final String ERROR   = "[Error] ";
    
    private static boolean convertToVRML97          = false;
    private static boolean convertToClassicVRML     = false;
    private static boolean convertToX3D             = false;
    private static boolean convertToXML             = false;
    private static boolean convertToHTML            = false; // pretty-print documentation
    private static boolean convertToMarkdown        = false; // model meta information
    private static boolean includeSubdirectoryPaths = true;  // model meta information, special switch for ModelExchange
    private static boolean convertToTidy            = false;
    private static boolean convertToJava            = false;
    private static boolean convertToJSON            = false;
    private static boolean convertToJS              = false;
    private static boolean convertToX3DOM           = false;
    private static boolean convertToX_ITE           = false;
    private static boolean convertToEXI             = false;
    private static boolean convertFromEXI           = false;
    private static boolean convertToGZIP            = false;
    private static boolean convertFromGZIP          = false;
    private static boolean convertToZIP             = false;
    private static boolean convertFromZIP           = false;
    private static boolean validateSwitch           = false;
				
	private static String  conversionExtension   = new String();

	/** Reset switch values */
	private static void initializeSwitches()
	{
		convertToVRML97          = false;
		convertToClassicVRML     = false;
		convertToX3D             = false;
		convertToXML             = false;
		convertToHTML            = false;
		convertToMarkdown        = false;
		includeSubdirectoryPaths = true; // special markdown switch
		convertToTidy            = false;
		convertToJava            = false;
		convertToJSON            = false;
		convertToJS              = false;
		convertToX3DOM           = false;
		convertToX_ITE           = false;
		convertToEXI             = false;
		convertFromEXI           = false;
		convertToGZIP            = false;
		convertFromGZIP          = false;
		convertToZIP             = false;
		convertFromZIP           = false;
		validateSwitch           = false;

		conversionExtension  = new String();
	}

    /** @see https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles */
    private static BufferedWriter bufferedWriter;

    /** Default main() method provided for test purposes, invoking run() method.
     * @param args the command line arguments
     * @see #run(String[])
     * @see X3DObject#handleArguments(String[])
     */
    public static void main(String[] args)
    {
		run(args);
	}

    /** Default run() method provided for test purposes, first initializing ConfigurationProperties then reading properties file (if any) and processing arguments.
	 * When invoked without parameters then reports results of validate() self-checks to system output.
     * @param args the command line arguments
     * @see #main(String[])
     * @see ConfigurationProperties
     * @see X3DObject#handleArguments(String[])
     */
    public static void run(String[] args)
    {
        File    sourceFile;
        long    sourceFileLength     = 0;
        String  sourceFileName       = "";
        String  sourceFileNameRoot   = "";
   final String tempFileName         = "temp9876543210.txt";
		File    resultFile           = new File(tempFileName); // overwritten or deleted
        boolean convertToFile        = false;
        boolean loadProperties       = false;
        String     resultFileName    = "";
        String     resultFileNameRoot= "";
        String propertiesFileName    = "";
        String propertiesFileNameRoot= "";
  DecimalFormat formatPrecision2 = new DecimalFormat ("#0.00");
		String  compressionRatio;
				 
		initializeSwitches ();

		if ((args== null) || (args.length < 1))
		{
			System.out.println (USAGE);
			return;
		}
		else
		{
			for (int i=0; i<=args.length-1; i++)
			{
				if  (!args[i].startsWith("-"))
				{
					if (!sourceFileName.isEmpty())
					{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] multiple source file names found, \"" + sourceFileName + "\" and \"" + args[i] + "\"");
						System.out.println(USAGE);
						return;
					}
					else 
					{
						sourceFileName     = args[i];
						sourceFileNameRoot = sourceFileName;
						if (sourceFileName.contains("."))
							sourceFileNameRoot = sourceFileName.substring(0,sourceFileName.lastIndexOf("."));
						sourceFile = new File(sourceFileName);
						if (!sourceFile.exists())
						{
							System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] file not found: " + sourceFileName);
							System.out.println(USAGE);
							return;
						}
						else
						{
							sourceFileLength = sourceFile.length();
							System.out.println ("parameter: source file " + sourceFile.getName() + " filesize " + sourceFileLength + " bytes");
						}
					}
				}
				else if (args[i].equalsIgnoreCase("-tofile")) // followed by resultFileName
				{
					if ((args.length > i + 1) && !(args[i+1] == null) && !args[i+1].isEmpty() && !args[i+1].startsWith("-"))
					{
						 resultFileName     = args[i+1];
						 resultFileNameRoot = resultFileName.substring(0,resultFileName.lastIndexOf("."));
						 System.out.println ("parameter: \"" + args[i] + "\" \"" + args[i+1] + "\" for result file name root " + resultFileNameRoot);
						 i++; // increment index, carefully!
					}
					else System.out.println ("parameter: \"" + args[i] + "\" for result file name root "+ resultFileNameRoot);
					convertToFile = true;
				}
				else if (args[i].equalsIgnoreCase("-properties") || args[i].equalsIgnoreCase("-propertiesFile")) // optionally followed by propertiesFileName
				{
					if ((args.length > i + 1) && !(args[i+1] == null) && !args[i+1].isEmpty() && !args[i+1].startsWith("-"))
					{
						 propertiesFileName     = args[i+1];
						 propertiesFileNameRoot = propertiesFileName.substring(0,propertiesFileName.lastIndexOf("."));
						 System.out.println ("parameter: \"" + args[i] + "\" \"" + args[i+1] + "\" for properties file name root " + propertiesFileNameRoot);
						 i++; // increment index, carefully!
					}
					else System.out.println ("parameter: \"" + args[i] + "\" for properties file name root "+ propertiesFileNameRoot);
					loadProperties = true;
				}
				else if (args[i].equalsIgnoreCase("-x3d") || args[i].equalsIgnoreCase("-tox3d"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToX3D = true;
					conversionExtension = X3DObject.FILE_EXTENSION_X3D;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to X3D encoding");
				}
				else if (args[i].equalsIgnoreCase("-xml") || args[i].equalsIgnoreCase("-toxml"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToXML = true;
					conversionExtension = X3DObject.FILE_EXTENSION_XML;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to XML encoding");
				}
				else if (args[i].equalsIgnoreCase("-html")  || args[i].equalsIgnoreCase("-tohtml")  || args[i].equalsIgnoreCase("-html5") || args[i].equalsIgnoreCase("-tohtml5") ||
						 args[i].equalsIgnoreCase("-xhtml") || args[i].equalsIgnoreCase("-toxhtml") || args[i].equalsIgnoreCase("-prettyprint"))
				{
				    /* pretty-print documentation */
					clearPriorConversionSwitches(args[i]);
					convertToHTML = true;
					if  (args[i].equalsIgnoreCase("-xhtml") || args[i].equalsIgnoreCase("-toxhtml"))
					     conversionExtension = X3DObject.FILE_EXTENSION_XHTML;
					else conversionExtension = X3DObject.FILE_EXTENSION_HTML;
					System.out.println ("parameter: \"" + args[i] + "\" for producing " + conversionExtension + " pretty-print documentation");
				}
				else if (args[i].toLowerCase().contains("markdown") && args[i].toLowerCase().contains("flat")) // special switch
				{
					/* model meta information to markdown, used in ModelExchange.nps.edu */
					clearPriorConversionSwitches(args[i]);
					includeSubdirectoryPaths = false;
					convertToMarkdown   = true;
					conversionExtension = X3DObject.FILE_EXTENSION_MARKDOWN;
					System.out.println ("parameter: \"" + args[i] + "\" for producing " + conversionExtension + " model meta information markdown with flattened (omitted) subdirectories");
				}
				else if (args[i].equalsIgnoreCase("-md")  || args[i].equalsIgnoreCase("-tomd")  || args[i].equalsIgnoreCase("-markdown") || args[i].equalsIgnoreCase("-tomarkdown"))
				{
					/* model meta information to markdown, used in ModelExchange.nps.edu */
					clearPriorConversionSwitches(args[i]);
					includeSubdirectoryPaths = true;
					convertToMarkdown   = true;
					conversionExtension = X3DObject.FILE_EXTENSION_MARKDOWN;
					System.out.println ("parameter: \"" + args[i] + "\" for producing " + conversionExtension + " model meta information markdown");
				}
				else if (args[i].equalsIgnoreCase("-tidy") || args[i].equalsIgnoreCase("-totidy") || args[i].equalsIgnoreCase("-x3dtidy") || args[i].equalsIgnoreCase("-tox3dtidy"))
				{
				    /* X3D-Tidy cleanup */
					clearPriorConversionSwitches(args[i]);
					convertToTidy = true;
					conversionExtension = X3DObject.FILE_EXTENSION_X3D;
					System.out.println ("parameter: \"" + args[i] + "\" for producing X3D-Tidy cleanup of .x3d");
				}
				else if (args[i].equalsIgnoreCase("-x3dv") || args[i].equalsIgnoreCase("-tox3dv") || 
						 args[i].equalsIgnoreCase("-toClassicVRML") || args[i].equalsIgnoreCase("-ClassicVRML"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToClassicVRML = true;
					conversionExtension = X3DObject.FILE_EXTENSION_CLASSICVRML;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to ClassicVRML encoding");
				}
				else  if (args[i].equalsIgnoreCase("-java") || args[i].equalsIgnoreCase("-tojava"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToJava = true;
					conversionExtension = X3DObject.FILE_EXTENSION_JAVA;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to Java source code");
				}
				else  if (args[i].equalsIgnoreCase("-json") || args[i].equalsIgnoreCase("-tojson"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToJSON = true;
					conversionExtension = X3DObject.FILE_EXTENSION_JSON;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to JSON encoding");
				}
 				else  if (args[i].equalsIgnoreCase("-js") || args[i].equalsIgnoreCase("-tojs"))
 				{
 					clearPriorConversionSwitches(args[i]);
 					convertToJS = true;
 					conversionExtension = X3DObject.FILE_EXTENSION_JAVASCRIPT;
 					System.out.println ("parameter: \"" + args[i] + "\" for conversion to X3DJSONLD JavaScript source");
 				}
				else  if (args[i].equalsIgnoreCase(  "-vrml") || args[i].equalsIgnoreCase(  "-vrml97") ||args[i].equalsIgnoreCase( "-wrl") || 
						  args[i].equalsIgnoreCase("-tovrml") || args[i].equalsIgnoreCase("-tovrml97"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToVRML97 = true;
					conversionExtension = X3DObject.FILE_EXTENSION_VRML97;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to VRML97 encoding");
				}
				else  if (args[i].equalsIgnoreCase("-x3dom") || args[i].equalsIgnoreCase("-tox3dom"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToX3DOM = true;
					conversionExtension = X3DObject.FILE_EXTENSION_HTML;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to X3DOM HTML page containing model");
				}
				else  if (args[i].equalsIgnoreCase("-X_ITE") || args[i].equalsIgnoreCase("-toX_ITE"))
				{
					clearPriorConversionSwitches(args[i]);
					convertToX_ITE = true;
					conversionExtension = X3DObject.FILE_EXTENSION_HTML;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to X_ITE HTML page containing model");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-EXIFICIENT"))
				{
					ConfigurationProperties.setExiEngine(ConfigurationProperties.EXI_ENGINE_EXIFICIENT);
					System.out.println ("parameter: \"" + args[i] + "\" invoked  ConfigurationProperties.setExiEngine(" + ConfigurationProperties.EXI_ENGINE_EXIFICIENT + ");");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-OPENEXI") || args[i].equalsIgnoreCase("-NAGASENA"))
				{
					ConfigurationProperties.setExiEngine(ConfigurationProperties.EXI_ENGINE_OPENEXI);
					System.out.println ("parameter: \"" + args[i] + "\" invoked  ConfigurationProperties.setExiEngine(" + ConfigurationProperties.EXI_ENGINE_OPENEXI + ");");
					// TODO
					System.out.println ("  Warning: \"" + ConfigurationProperties.EXI_ENGINE_OPENEXI + "\" option not yet implemented, using " + ConfigurationProperties.EXI_ENGINE_EXIFICIENT + " instead.");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-EXI") || args[i].equalsIgnoreCase("-toEXI"))
				{
					if (sourceFileName.toLowerCase().endsWith(X3DObject.FILE_EXTENSION_EXI))
					{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert an .exi file -toEXI");
						System.out.println(USAGE);
						return;
					}
					clearPriorConversionSwitches(args[i]);
					convertToEXI  = true;
					convertToFile = true;
					conversionExtension = X3DObject.FILE_EXTENSION_EXI;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to compressed EXI containing model");
				}
				else  if ((args[i].equalsIgnoreCase("-EXI") &&  sourceFileName.toLowerCase().endsWith(X3DObject.FILE_EXTENSION_EXI)) || 
						   args[i].equalsIgnoreCase("-fromEXI"))
				{
					if (!sourceFileName.toLowerCase().endsWith(X3DObject.FILE_EXTENSION_EXI))
					{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert a non-exi file -toEXI");
						System.out.println(USAGE);
						return;
					}
					clearPriorConversionSwitches(args[i]);
					convertFromEXI = true;
					conversionExtension = X3DObject.FILE_EXTENSION_X3D;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion from compressed EXI containing model");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-toGZ") || args[i].equalsIgnoreCase("-toGZIP"))
				{
					if (sourceFileName.toLowerCase().endsWith(X3DObject.FILE_EXTENSION_GZIP))
					{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert -toGZIP an already gzip .gz file " + sourceFileName);
						System.out.println(USAGE);
						return;
					}
					clearPriorConversionSwitches(args[i]);
					convertToGZIP = true;
					convertToFile = true;
					conversionExtension = X3DObject.FILE_EXTENSION_GZIP;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to compressed GZIP containing model");
				}
				else  if (args[i].equalsIgnoreCase("-fromGZ") || args[i].equalsIgnoreCase("-fromGZIP"))
				{
					if (!sourceFileName.toLowerCase().endsWith(X3DObject.FILE_EXTENSION_GZIP))
					{
							System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert -fromGZIP an non-gzip file " + sourceFileName);
							System.out.println(USAGE);
							return;
					}
					clearPriorConversionSwitches(args[i]);
					convertFromGZIP = true;
					conversionExtension = X3DObject.FILE_EXTENSION_X3D;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion from compressed GZIP containing model");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-toZIP"))
				{
					if (sourceFileName.toLowerCase().endsWith(X3DObject.FILE_EXTENSION_ZIP))
					{
							System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert -toZIP a non-zip file " + sourceFileName);
							System.out.println(USAGE);
							return;
					}
					clearPriorConversionSwitches(args[i]);
					convertToZIP = true;
					conversionExtension = X3DObject.FILE_EXTENSION_ZIP;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion to compressed ZIP containing model");
				}
				else  if (args[i].equalsIgnoreCase("-fromZIP"))
				{
					if (!sourceFileName.toLowerCase().endsWith(X3DObject.FILE_EXTENSION_ZIP))
					{
							System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot convert -fromZIP a non-zip file " + sourceFileName);
							System.out.println(USAGE);
							return;
					}
					// TODO also handle specification of filename of interest
					clearPriorConversionSwitches(args[i]);
					convertFromZIP = true;
					convertToFile  = true;
					conversionExtension = X3DObject.FILE_EXTENSION_X3D;
					System.out.println ("parameter: \"" + args[i] + "\" for conversion from compressed ZIP containing model");
				}
				// ==========================================
				else  if (args[i].equalsIgnoreCase("-v") || args[i].equalsIgnoreCase("-validate"))
				{
					// usually invoked in isolation, but can coexist (superfluous) with conversions
					validateSwitch = true;
					if (resultFileName.isEmpty())
					{
						 resultFileName = "Validation" + X3DObject.FILE_EXTENSION_TEXT; // be prepared with default name
						 System.out.println ("parameter: \"" + args[i] + "\" for model validation");
					}
					else System.out.println ("parameter: \"" + args[i] + "\" for model validation to result file");
				}
				else  if (args[i].equalsIgnoreCase("-page") || args[i].equalsIgnoreCase("-X3DJSAIL"))
				{
					clearPriorConversionSwitches(args[i]);
					System.out.println(USAGE);
					openX3DJSAILpage();
					return;
				}
				else  if (args[i].equalsIgnoreCase("-resources") || args[i].equalsIgnoreCase("-X3dResources"))
				{
					openX3dResourcesPage();
					return;
				}
				else  if (args[i].equalsIgnoreCase("-tooltips") || args[i].equalsIgnoreCase("-X3dTooltips"))
				{
					openX3dTooltipsPage();
					return;
				}
				else  if (args[i].equalsIgnoreCase("-help"))
				{
					clearPriorConversionSwitches(args[i]);
					System.out.println(USAGE);
					return;
				}
				else // not found
				{
					System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] unrecognized CommandLine option \"" + args[i] + "\"");
					System.out.println(USAGE);
					return;
				}
			}
		}
		// ===================================================================================
		// compute/confirm resultFileName after all command-line switches are read

		if (resultFileName.isEmpty())
		{
			resultFileNameRoot = sourceFileNameRoot;
			resultFileName     = resultFileNameRoot + conversionExtension;
		}
		if ((convertToX3D         &&  !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_X3D))    ||
			(convertToXML         &&  !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_XML))    ||
			(convertToHTML        && (!conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_HTML) &&
                                      !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_XHTML)))   ||
			(convertToMarkdown    &&  !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_MARKDOWN)) ||
			(convertToTidy        &&  !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_X3D))      ||
			(convertToClassicVRML &&  !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_CLASSICVRML)) ||
			(convertToVRML97      &&  !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_VRML97)) ||
			(convertToX3DOM       && (!conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_HTML) &&
                                      !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_XHTML))) ||
			(convertToX_ITE       && (!conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_HTML) &&
                                      !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_XHTML))) ||
			(convertToEXI         &&  !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_EXI))    ||
			(convertToGZIP        &&  !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_GZIP))   ||
			(convertToZIP         &&  !conversionExtension.equalsIgnoreCase(X3DObject.FILE_EXTENSION_ZIP))    )
		{
			System.out.println(WARNING+" [org.web3d.x3d.jsail.CommandLine] mismatched file extension \"" + conversionExtension + "\" for conversion");
		}
		if (loadProperties)
		{
			if (!propertiesFileName.isEmpty())
				ConfigurationProperties.setPropertiesFileName (propertiesFileName);
			ConfigurationProperties.loadProperties();
		}
				
		// ===================================================================================
        if (!sourceFileName.isEmpty()) // fully prepared, now get source file and proceed
        {
			if (convertFromGZIP)
			{
				if (!sourceFileName.toLowerCase().endsWith(X3DObject.FILE_EXTENSION_GZIP))
				{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot -gunzip a non-gzip file " + sourceFileName);
						System.out.println(USAGE);
						return;
				}
				boolean result = loadedX3dModel.fromFileGZIP(sourceFileName);
				System.out.println("load success: " + result);
				return;
			}
			else if (convertFromZIP)
			{
				if (!sourceFileName.toLowerCase().endsWith(X3DObject.FILE_EXTENSION_ZIP))
				{
						System.out.println(ERROR+" [org.web3d.x3d.jsail.CommandLine] cannot -gunzip a non-zip file " + sourceFileName);
						System.out.println(USAGE);
						return;
				}
				// if output resultFileName not specified, pick first available .x3d file
				boolean result = loadedX3dModel.fromFileZIP(sourceFileName,resultFileName); 
				System.out.println("load success: " + result);
				return;
			}
			// otherwise
            X3DLoaderObject x3dLoader = new X3DLoaderObject();
            boolean successfulLoad = x3dLoader.loadModelFromFileX3D(         sourceFileName);
//          boolean successfulLoad = x3dLoader.loadModelFromFileX3D(new File(sourceFileName)); // alternate form, tested OK

            if (successfulLoad && x3dLoader.isLoadSuccessful()) // two equivalent ways to check
            {
				ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version
                resultFile = new File(tempFileName); // unsaved
                try
				{
                    //debug
//                  System.out.println("loadedX3dModel initialization:");
//                  System.out.println(loadedX3dModel.toStringX3D());
                    
                    X3DConcreteElement x3dConcreteElement = x3dLoader.getX3dObjectTree();

                    if (x3dConcreteElement instanceof X3DObject)
                    {
                        loadedX3dModel = (X3DObject)x3dConcreteElement;
                    }
                    else if (x3dConcreteElement == null)
                    {
                        System.out.println(ERROR+"TODO problem with X3dLoader, x3dConcreteElement is null.");
                        return;
                    }
                    else
                    {
                        System.out.println(ERROR+"TODO problem with X3dLoader, result has type " + x3dConcreteElement.getClass().getCanonicalName());
                        return;
                    }

                    if (convertToVRML97)
                    {
                        System.out.println("convert to VRML97:");
                        if (!convertToFile) System.out.println(); 
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileVRML97 (resultFileName);
                        else System.out.println(loadedX3dModel.toStringVRML97());
                    }
                    else if (convertToJSON)
                    {
                        String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                	ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                        System.out.println("convert to JSON:");
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileJSON (resultFileName);
                        else System.out.println(loadedX3dModel.toStringJSON());
                	ConfigurationProperties.setXsltEngine(presetXsltEngine);
                    }
                    else if (convertToJava)
                    {
                        String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                	ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                        System.out.println("convert to Java:");
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileJava (resultFileName);
                        else System.out.println(loadedX3dModel.toStringJava());
                	ConfigurationProperties.setXsltEngine(presetXsltEngine);
                    }
                    else if (convertToJS)
                    {
                        String presetXsltEngine = ConfigurationProperties.getXsltEngine();
                	ConfigurationProperties.setXsltEngine(ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA); // built-in version avoids unwanted line breaks
                        System.out.println("convert to JS JavaScript:");
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileJavaScript (resultFileName);
                        else System.out.println(loadedX3dModel.toStringJavaScript());
                	ConfigurationProperties.setXsltEngine(presetXsltEngine);
                    }
                    else if (convertToClassicVRML)
                    {
                        System.out.println("convert to ClassicVRML:");
                        if (!convertToFile) System.out.println(); 
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileClassicVRML (resultFileName);
                        else System.out.println(loadedX3dModel.toStringClassicVRML());
                    }
                    else if (convertToX3D)
                    {
                        System.out.println("convert to X3D:");
                        if (!convertToFile) System.out.println(); 
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileX3D (resultFileName);
                        else System.out.println(loadedX3dModel.toStringX3D());
                    }
                    else if (convertToXML)
                    {
                        System.out.println("convert to XML:");
                        if (!convertToFile) System.out.println(); 
                        if  (convertToFile)
                             resultFile =       loadedX3dModel.toFileXML (resultFileName);
                        else System.out.println(loadedX3dModel.toStringXML());
                    }
                    else if (convertToHTML) // pretty-print documentation
                    {
                        System.out.println("convert to " + conversionExtension + " pretty-print documentation");
                        if (!convertToFile) System.out.println(); 
                        if  (convertToFile)
                             resultFile =       loadedX3dModel.toFileHtmlDocumentation (resultFileName);
                        else System.out.println(loadedX3dModel.toStringHtmlDocumentation());
                    }
                    else if (convertToMarkdown) // model meta information
                    {
                        System.out.println("convert to " + conversionExtension + " model meta information markdown, include subdirectories in meta links: " + includeSubdirectoryPaths);
                        loadedX3dModel.setIncludeSubdirectoryPaths(includeSubdirectoryPaths);
                        if (!convertToFile) System.out.println(); 
                        if  (convertToFile)
                             resultFile =       loadedX3dModel.toFileModelMetaMarkdown (resultFileName);
                        else System.out.println(loadedX3dModel.toStringModelMetaMarkdown());
                    }
                    else if (convertToTidy)
                    {
                        System.out.println("convert to X3D Tidy cleaned-up version");
                        if (!convertToFile) System.out.println(); 
                        if  (convertToFile)
                             resultFile =       loadedX3dModel.toFileX3dTidy (resultFileName);
                        else System.out.println(loadedX3dModel.toStringX3dTidy());
                    }
                    else if (convertToX3DOM)
                    {
                        System.out.println("convert to X3DOM:");
                        if (!convertToFile) System.out.println(); 
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileX3DOM (resultFileName);
                        else System.out.println(loadedX3dModel.toStringX3DOM());
                    }
                    else if (convertToX_ITE)
                    {
                        System.out.println("convert to X_ITE:");
                        if (!convertToFile) System.out.println(); 
                        if  (convertToFile)
                              resultFile =      loadedX3dModel.toFileX_ITE  (sourceFileName, resultFileName);
                        else System.out.println(loadedX3dModel.toStringX_ITE(sourceFileName));
                    }
                    else if (convertToEXI)
                    {
                        System.out.println("convert to EXI using " + ConfigurationProperties.getExiEngine() + ":");
                        System.out.println("source: " + sourceFileName + " filesize " + sourceFileLength + " bytes");
//						System.out.println("[trace] sourceFileName=" + sourceFileName + ", resultFileName=" + resultFileName);
                        resultFile = loadedX3dModel.toFileEXI (resultFileName);
						compressionRatio = formatPrecision2.format((double)resultFile.length()/(double)sourceFileLength * 100.0);
						System.out.println("result: " + resultFile.getName() + " filesize " + resultFile.length() + " bytes, compression " + compressionRatio + "% of original");
                    }
                    else if (convertToGZIP)
                    {
                        System.out.println("convert to GZIP:");
                        System.out.println("source: " + sourceFileName + " filesize " + sourceFileLength + " bytes");
//						System.out.println("[trace] sourceFileName=" + sourceFileName + ", resultFileName=" + resultFileName);
                        resultFile = loadedX3dModel.toFileGZIP (resultFileName);
						compressionRatio = formatPrecision2.format((double)resultFile.length()/(double)sourceFileLength * 100.0);
						System.out.println("result: " + resultFile.getName() + "  filesize " + resultFile.length() + " bytes, compression " + compressionRatio + "% of original");
                    }
                    else if (convertToZIP)
                    {
                        System.out.println("convert to ZIP:");
                        System.out.println("source: " + sourceFileName + " filesize " + sourceFileLength + " bytes");
//						System.out.println("[trace] sourceFileName=" + sourceFileName + ", resultFileName=" + resultFileName);
                        resultFile = loadedX3dModel.toFileZIP (resultFileName, sourceFileName);
						compressionRatio = formatPrecision2.format((double)resultFile.length()/(double)sourceFileLength * 100.0);
						System.out.println("result: " + resultFile.getName() + " filesize " + resultFile.length() + " bytes, compression " + compressionRatio + "% of original");
                    }
                    else if (validateSwitch && !convertToEXI && !convertToGZIP && !convertToZIP)
                    {
						// note that validation already performed as part of prior conversions
                        String outputValidationText = loadedX3dModel.validate();
                            
                        System.out.println("validate results:");
                        if (!convertToFile)
                        {
                            if  (outputValidationText.isEmpty())
                                 outputValidationText = "success, no problems noted";
                            else System.out.println();
                            System.out.println(outputValidationText);
                            return;
                        }
                        else if (convertToFile && outputValidationText.isEmpty())
                        {
                            outputValidationText = "success, no problems noted, no output file written";
                            System.out.println(outputValidationText);
                            return;
                        }
                        else if (convertToFile)
                        {
                            if (!resultFileName.endsWith(X3DObject.FILE_EXTENSION_TEXT))
                            {
                                resultFileName += X3DObject.FILE_EXTENSION_TEXT;
                            }
                            Path outputFilePath = Paths.get(resultFileName);
                            String  errorNotice = new String();
                            if (ConfigurationProperties.isDebugModeActive()) // debug check, defaults to local directory
                            {
                                errorNotice += "[debug] Output file path=" + outputFilePath.toAbsolutePath() + "\n";
                            }
                            System.out.println (errorNotice);
		
                            // http://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
                            // http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html
                            Charset charset = Charset.forName(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT); // "UTF-8"

                            try // successful validation results in empty file
                            {
                                    bufferedWriter = Files.newBufferedWriter(outputFilePath, charset);
                                    bufferedWriter.write(outputValidationText, 0, outputValidationText.length());
                                    bufferedWriter.close(); // ensure file writing is complete
                                    outputFilePath.toFile(); // success
                            }
                            catch (IOException exception)
                            {
                                    throw new X3DException(ERROR+"IOException for resultFileName " + resultFileName + ", unable to save file: " + exception);
                            }
                        }
                    }
                    if      (convertToEXI || convertToGZIP || convertToZIP)
                    {
							// done
					}
                    else if (convertToFile && resultFile.exists() && !resultFile.getName().equals(tempFileName))
                             System.out.println("file conversion successful: " + resultFile.getName() + " (" + resultFile.length() + " bytes)");
                    else if (convertToFile)
                             System.out.println(ERROR+"file conversion unsuccessful!");
                    else if (validateSwitch)
                             System.out.println("model validation complete.");
                }
                catch (X3DException e)
                {
                    e.printStackTrace();
                    System.out.println(ERROR+"TODO problem handling local exception within CommandLine, exiting");
                //  return;
                }
            }
            else
            {
                System.out.println(ERROR+"Source model file load unsuccessful");
            //  return;
            }
		}
		else if (!loadProperties) // allow testing of properties without file operations
        {
            System.out.println(ERROR+"Source model file name is empty, therefore file loading not possible.");
        //  return;
        }
		if (resultFile.getName().equals(tempFileName))
			resultFile.delete();
    }

    /** Open X3DJSAIL page
     * @see <a href="http://www.web3d.org/specifications/java/X3DJSAIL.html">http://www.web3d.org/specifications/java/X3DJSAIL.html</a>
     */
    public static void openX3DJSAILpage ()
    {
         openX3DJSAILpage (""); // no bookmark
    }

    /** Open X3DJSAIL page at a given bookmark
	 * @param bookmark anchor bookmark of interest for this page
     * @see <a href="http://www.web3d.org/specifications/java/X3DJSAIL.html">http://www.web3d.org/specifications/java/X3DJSAIL.html</a>
     */
    public static void openX3DJSAILpage (String bookmark)
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java
        try {
               if ((bookmark != null) && !bookmark.isEmpty())
                    Desktop.getDesktop().browse(new URI("X3DJSAIL.html" + "#" + bookmark));
               else Desktop.getDesktop().browse(new URI("X3DJSAIL.html"));
        }
        catch (IOException | URISyntaxException e1)
        {
//         System.out.println ("Local url failure: " + e1.getMessage());
           try {
               if ((bookmark != null) && !bookmark.isEmpty())
                    Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DJSAIL + "#" + bookmark));
               else Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DJSAIL));
           }
           catch (IOException | URISyntaxException e2)
           {
               if ((bookmark != null) && !bookmark.isEmpty())
                    System.out.println ("URL_X3DJSAIL: " + ConfigurationProperties.URL_X3DJSAIL + "#" + bookmark);
               else System.out.println ("URL_X3DJSAIL: " + ConfigurationProperties.URL_X3DJSAIL);
               System.out.println ("URL_X3DJSAIL failure: " + e2.getMessage());
           }
        }
    }

    /** Open X3D Resources page
     * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html">http://www.web3d.org/x3d/content/examples/X3dResources.html</a>
     */
    public static void openX3dResourcesPage ()
    {
         openX3dResourcesPage (""); // no bookmark
    }

    /** Open X3D Resources page at a given bookmark
	 * @param bookmark anchor bookmark of interest for this page
     * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html">http://www.web3d.org/x3d/content/examples/X3dResources.html</a>
     */
    public static void openX3dResourcesPage (String bookmark)
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java
        try {
            if ((bookmark != null) && !bookmark.isEmpty())
                 Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DRESOURCES + "#" + bookmark));
            else Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DRESOURCES));
        }
        catch (IOException | URISyntaxException e2)
        {
            if ((bookmark != null) && !bookmark.isEmpty())
                 System.out.println ("URL_X3DJSAIL: " + ConfigurationProperties.URL_X3DRESOURCES + "#" + bookmark);
            else System.out.println ("URL_X3DJSAIL: " + ConfigurationProperties.URL_X3DRESOURCES);

            System.out.println ("URL_X3DJSAIL failure: " + e2.getMessage());
        }
    }

    /** Open X3D Tooltips page
     * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html">X3D Tooltips</a>
     */
    public static void openX3dTooltipsPage ()
    {
         openX3dTooltipsPage (""); // no bookmark
    }

    /** Open X3D Tooltips page at a given bookmark
	 * @param bookmark anchor bookmark of interest for this page
     * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html">X3D Tooltips</a>
     */
    public static void openX3dTooltipsPage (String bookmark)
    {
        // https://stackoverflow.com/questions/5226212/how-to-open-the-default-webbrowser-using-java
        
        try {
            if ((bookmark != null) && !bookmark.isEmpty())
                 Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DTOOLTIPS + "#" + bookmark));
            else Desktop.getDesktop().browse(new URI(ConfigurationProperties.URL_X3DTOOLTIPS));
        }
        catch (IOException | URISyntaxException e2)
        {
            if ((bookmark != null) && !bookmark.isEmpty())
                 System.out.println ("URL_X3DTOOLTIPS: " + ConfigurationProperties.URL_X3DTOOLTIPS + "#" + bookmark);
            else System.out.println ("URL_X3DTOOLTIPS: " + ConfigurationProperties.URL_X3DTOOLTIPS );

            System.out.println ("URL_X3DTOOLTIPS failure: " + e2.getMessage());
        }
    }

    /** 
     * Reset all conversions switches to default (false)
     * @param newCommand provides diagnostic message when prior command gets overridden 
     */
    private static void clearPriorConversionSwitches(String newCommand)
    {
        if (convertToVRML97 || convertToClassicVRML || convertToX3D   || convertToXML || convertToHTML || convertToMarkdown || convertToTidy ||
            convertToJava   || convertToJSON   || convertToJS          || convertToX3DOM || convertToX_ITE)
            System.out.println(WARNING+"Prior conversion flag overridden by " + newCommand);
            
        convertToVRML97          = false;
        convertToClassicVRML     = false;
        convertToX3D             = false;
        convertToXML             = false;
        convertToHTML            = false;
        convertToMarkdown        = false;
        includeSubdirectoryPaths = true;  // model meta information, special switch for ModelExchange
        convertToTidy            = false;
        convertToJava            = false;
        convertToJSON            = false;
        convertToJS              = false;
        convertToX3DOM           = false;
        convertToX_ITE           = false;
    }

]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>
	
	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>ConfigurationProperties</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text>
import org.web3d.x3d.jsail.Core.*;
import org.web3d.x3d.sai.InvalidFieldValueException;

import java.io.*;</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><!-- top level --></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[<p>
Concrete class that enables developers to set custom configuration properties when using X3D Java SAI Library (X3DJSAIL).
</p>
<p>
<a href="../../../../../X3DJSAIL.html#property" target="blank">Utility methods</a>
and 
<a href="../../../../../X3DJSAIL.html#CommandLine" target="blank">command-line support</a>
are available to load Java .property files, such as 
<a href="../../../../../X3DJSAIL.properties.template">X3DJSAIL.properties.template</a>
</p>
<p>Output serialization support is provided for indentation, 
<a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Canonical Form</a>,
and showing default attribute values.</p>
]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[

	// singleton pattern for property values

// ==========================================================================================
	
	/** Default character-count increment for serializing scene output. */
	public static final int indentIncrement_DEFAULT = 2;
				
	private static int indentIncrement = indentIncrement_DEFAULT; // static initialization

	/** Whitespace character for indenting when serializing scene output. */
	public static final char indentCharacter_SPACE = ' ';
				
	/** Alternative whitespace character for indenting when serializing scene output. */
	public static final char indentCharacter_TAB   = '\t';
				
	/** Default character for indenting when serializing scene output, initial value is indentCharacter_SPACE. */
	public static final char indentCharacter_DEFAULT = indentCharacter_SPACE;
				
	private static char indentCharacter = indentCharacter_DEFAULT; // static initialization
				
	/** Default XML document encoding, used in the XML document declaration appearing in the first line of an XML file.
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#X3D">X3D Tooltips: X3D</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Validation" target="_blank">X3D Scene Authoring Hints: Validation of X3D Scenes using DTD and XML Schema</a>
	*/
	public static final String XML_ENCODING_DECLARATION_DEFAULT = "UTF-8"; // this must be exact!
				
	// TODO add additional encoding declarations as string constants, along with mutatable configuration property.
	
	/** Error message if configuration of X3DJSAIL is incorrect: CLASSPATH missing jar, or other error.
	 */
	public static final String ERROR_CONFIGURATION_X3DJSAIL = "ERROR_CONFIGURATION_X3DJSAIL";

	/** Warning message if configuration of X3DJSAIL is incorrect: properties file missing, or other error.
	 */
	public static final String WARNING_CONFIGURATION_X3DJSAIL = "WARNING_CONFIGURATION_X3DJSAIL";

	/** Error message if an illegal value is provided as a method parameter.
	 */
	public static final String ERROR_ILLEGAL_VALUE = "ERROR_ILLEGAL_VALUE";
				
	/** Error message if an element is not currently connected to an existing scene graph object, and necessary checking  for model validation is not possible.
		Example: <i>fieldObject</i> or <i>fieldValueObject</i> creation may fail validation() if the field types cannot be checked in a 
		corresponding <i>ProtoDeclareObject</i> or <i>ExternProtoDeclareObject</i>.
	 */
	public static final String ERROR_NOT_CONNECTED_TO_SCENE_GRAPH = "ERROR_NOT_CONNECTED_TO_SCENE_GRAPH";

	/** Error message if a field is required but no value is found.
	 */
	public static final String ERROR_VALUE_NOT_FOUND = "ERROR_VALUE_NOT_FOUND";
	
	/** Error message if incorrect field accessType value encountered.
	 * @see org.web3d.x3d.jsail.Core.fieldObject#getAccessType()
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType">X3D Tooltips: accessType</a>
	 */
	public static final String ERROR_UNKNOWN_FIELD_ACCESSTYPE = "ERROR_UNKNOWN_FIELD_ACCESSTYPE";
	
	/** Error message if incorrect field type value encountered.
	 * @see org.web3d.x3d.jsail.Core.fieldObject#getType()
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#type">X3D Tooltips: type</a>
	 */
	public static final String ERROR_UNKNOWN_FIELD_TYPE = "ERROR_UNKNOWN_FIELD_TYPE";

	/** Error message if node type of ProtoDeclareObject is not found.
	 * @see ProtoDeclareObject
	 * @see ExternProtoDeclareObject
	 * @see ProtoInstanceObject
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/abstracts.html#InvalidProtoException">X3D SAI: B.7.13 InvalidProtoException</a>
	 */
	public static final String ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE = "ERROR_UNKNOWN_PROTODECLARE_NODE_TYPE"; // not defined in X3D Java SAI

	/** Error message if node type of ExternProtoDeclareObject is not found.
	 * @see ExternProtoDeclareObject
	 * @see ProtoDeclareObject
	 * @see ProtoInstanceObject
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/abstracts.html#InvalidProtoException">X3D SAI: B.7.13 InvalidProtoException</a>
	 */
	public static final String ERROR_UNKNOWN_EXTERNPROTODECLARE_NODE_TYPE = "ERROR_UNKNOWN_EXTERNPROTODECLARE_NODE_TYPE"; // not defined in X3D Java SAI

	/** Error message if node type of ProtoInstanceObject is not found.
	 * @see ProtoInstanceObject
	 * @see ProtoDeclareObject
	 * @see ExternProtoDeclareObject
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/abstracts.html#InvalidProtoException">X3D SAI: B.7.13 InvalidProtoException</a>
	 */
	public static final String ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE = "ERROR_UNKNOWN_PROTOINSTANCE_NODE_TYPE"; // not defined in X3D Java SAI

	/** Warning message if a ProtoInstanceObject corresponding to a given ProtoDeclare or ExternProtoDeclare is not found.
	 * @see ProtoInstanceObject
	 * @see ProtoDeclareObject
	 * @see ExternProtoDeclareObject
	 */
	public static final String WARNING_PROTOINSTANCE_NOT_FOUND = "WARNING_PROTOINSTANCE_NOT_FOUND";

// ==========================================================================================
				
	/** Default mode for debugging results, initial value is false. */
	public static boolean debugModeActive  = false;
				
	/** Whether to show default attribute values when serializing scene output, initial value is <i>false</i>. */
	public  static final boolean showDefaultAttributes_DEFAULT   = false;
				
	private static boolean showDefaultAttributes = showDefaultAttributes_DEFAULT; // static initialization
				
	/** Set whether to allow partial output if validation exception occurs when serializing scene output, initial value is <i>false</i>. */
	public  static final boolean validationExceptionAllowed_DEFAULT   = false;
				
	private static boolean validationExceptionAllowed = validationExceptionAllowed_DEFAULT; // static initialization
				
	/** Set whether to allow partial output if validation exception occurs when creating an object, initial value is <i>true</i>. */
	public  static final boolean creationConnectionValidationExceptionAllowed_DEFAULT   = true;
				
	private static boolean creationConnectionValidationExceptionAllowed = creationConnectionValidationExceptionAllowed_DEFAULT;

	/** Set whether to normalize whitespace in comments, which can aid consistency in canonicalization and security; default value is <i>true</i>. 
	 * @see ConfigurationProperties#setNormalizeCommentWhitespace(boolean)
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
         */
        public  static boolean normalizeCommentWhitespace_DEFAULT   = true;

        private static boolean normalizeCommentWhitespace = normalizeCommentWhitespace_DEFAULT; // static initialization // static initialization

	/** Set whether to allow overwriting previously existing files, initial value is <i>true</i>. */
	public  static final boolean overwriteExistingFiles_DEFAULT   = true;
				
	private static boolean overwriteExistingFiles = overwriteExistingFiles_DEFAULT; // static initialization
				
	// ==========================================================================================
				
	/** X3DJSAIL name
	 * @see <a href="http://www.web3d.org/specifications/java/X3DJSAIL.html">http://www.web3d.org/specifications/java/X3DJSAIL.html</a> */
	public static final String NAME_X3DJSAIL     = "X3D Java Scene Access Interface Library (X3DJSAIL)";
				
	/** X3DJSAIL documentation page
	 * @see <a href="http://www.web3d.org/specifications/java/X3DJSAIL.html">http://www.web3d.org/specifications/java/X3DJSAIL.html</a> */
	public static final String URL_X3DJSAIL     = "http://www.web3d.org/specifications/java/X3DJSAIL.html";
                            
	/** X3D Resources documentation page
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html">http://www.web3d.org/x3d/content/examples/X3dResources.html</a> */
	public static final String URL_X3DRESOURCES = "http://www.web3d.org/x3d/content/examples/X3dResources.html";
                            
	/** X3D Tooltips documentation pages
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html">http://www.web3d.org/x3d/tooltips/X3dTooltips.html</a>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html#Tooltips">X3D Resources: Tooltips (multiple languages)</a> */
	public static final String URL_X3DTOOLTIPS = "http://www.web3d.org/x3d/tooltips/X3dTooltips.html";
				
	/** XSLT stylesheet to create pretty-print HTML documentation page from X3D scene: <i>../lib/stylesheets/X3dToXhtml.xslt</i>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToXhtml.xslt" target="_blank">X3dToXhtml.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.html" target="_blank">examples/HelloWorldProgramOutput.html</a>
	 */
	public static final String STYLESHEET_htmlDocumentation   = "X3dToXhtml.xslt";
				
	/** XSLT stylesheet to create model meta information as markdown: <i>../lib/stylesheets/X3dToXhtml.xslt</i>
	 * @see <a href="../../../../../../lib/stylesheets/X3dModelMetaToMarkdown.xslt" target="_blank">X3dModelMetaToMarkdown.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.md" target="_blank">examples/HelloWorldProgramOutput.md</a>
	 */
	public static final String STYLESHEET_MODEL_META_TO_MARKDOWN   = "X3dModelMetaToMarkdown.xslt";
				
	/** XSLT stylesheet to create X3D-Tidy cleaned-up version of X3D scene: <i>../lib/stylesheets/X3dToXhtml.xslt</i>
	 * @see <a href="http://www.web3d.org/x3d/stylesheets/X3dTidy.html">X3D Tidy for Scene Cleanup, Corrections and Modifications</a>
	 * @see <a href="../../../../../../lib/stylesheets/X3dTidy.xslt" target="_blank">X3dTidy.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutputTidy.x3d" target="_blank">examples/HelloWorldProgramOutputTidy.x3d</a>
	 */
	public static final String STYLESHEET_X3DTIDY   = "X3dTidy.xslt";
				
	/** XSLT stylesheet to create Extrusion node cross sections in SVG from X3D scene: <i>../lib/stylesheets/X3dExtrusionToSvgViaXslt1.1.xslt</i> */
	public static final String STYLESHEET_extrusionCrossSectionSVG   = "X3dExtrusionToSvgViaXslt1.1.xslt";
				
	/** XSLT stylesheet to create X3DOM XHTML page or X3DOM HTML page from X3D scene: <i>../lib/stylesheets/X3dToX3dom.xslt</i>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToX3dom.xslt" target="_blank">X3dToX3dom.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutputX_ITE.html" target="_blank">examples/HelloWorldProgramOutputX3dom.html</a>
	 */
	public static final String STYLESHEET_X3DOM    = "X3dToX3dom.xslt";
				
	/** XSLT stylesheet to create X_ITE XHTML page or X_ITE HTML page from X3D scene: <i>../lib/stylesheets/X3dToX3dom.xslt</i> 
            TODO disambiguation needed?
	 * @see <a href="http://create3000.de/x_ite">X_ITE open-source X3D player</a>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToX3dom.xslt" target="_blank">X3dToX3dom.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutputX_ITE.html" target="_blank">examples/HelloWorldProgramOutputX_ITE.html</a>
	 */
	public static final String STYLESHEET_X_ITE    = "X3dToX3dom.xslt";
				
	/** XSLT stylesheet Cobweb (now X_ITE)
	 * @see <a href="http://create3000.de/x_ite">X_ITE open-source X3D player</a>
	 */
	@Deprecated
	public static final String STYLESHEET_COBWEB   = "X3dToX3dom.xslt";
				
	/** XSLT stylesheet to create Java source code (using X3DJSAIL library) from X3D scene: <i>../lib/stylesheets/X3dToJava.xslt</i>.
	 * TODO: documentation.
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJava.xslt" target="_blank">X3dToJava.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.java" target="_blank">examples/HelloWorldProgramOutput.java</a>
	 */
	public static final String STYLESHEET_JAVA   = "X3dToJava.xslt";
				
	/** XSLT stylesheet to create JSON encoding from X3D scene: <i>../lib/stylesheets/X3dToJson.xslt</i>
	 * @see <a href="http://www.web3d.org/wiki/index.php/X3D_JSON_Encoding">X3D JSON Encoding</a>
	 * @see <a href="http://www.web3d.org/x3d/stylesheets/X3dToJson.html">X3D to JSON Stylesheet Converter</a>
	 * @see <a href="../../../../../../lib/stylesheets/X3dToJson.xslt" target="_blank">X3dToJson.xslt</a>
	 * @see <a href="../../../../../../examples/HelloWorldProgramOutput.json" target="_blank">examples/HelloWorldProgramOutput.json</a>
	 */
	public static final String STYLESHEET_JSON   = "X3dToJson.xslt";
		
	/** List of officially released X3DJSAIL jar files.
	 */
        // https://stackoverflow.com/questions/21696784/how-to-declare-an-arraylist-with-values
        public static final ArrayList<String> X3DJSAIL_JAR_RELEASE_VERSIONS = 
            new ArrayList<>(Arrays.asList("X3DJSAIL.3.3.classes.jar", "X3DJSAIL.3.3.full.jar"));

// ==========================================================================================
				
	/** Whether to delete intermediate files generated as part of various transformations, this property can be helpful for debugging. */
	private static boolean deleteIntermediateFiles_DEFAULT = true;
				
	/** Whether to delete intermediate files generated as part of various transformations, this property can be helpful for debugging. */
	private static boolean deleteIntermediateFiles = deleteIntermediateFiles_DEFAULT;
				
	/** Indicate whether to delete intermediate files generated as part of various transformations, this property method can be helpful can be helpful for debugging.
	 * @return configuration setting whether intermediate files are deleted
	 */
	public static final boolean isDeleteIntermediateFiles()
	{
		return deleteIntermediateFiles;
	}
	/** Set whether to delete intermediate files generated as part of various transformations, this property method can be helpful can be helpful for debugging.
	 * @param newValue is new value to assign
	 */
	public static final void setDeleteIntermediateFiles(boolean newValue)
	{
		deleteIntermediateFiles = newValue;
	}	
// ==========================================================================================
				
	/** Whether to omit trailing zeros from floating-point or double-precision output. */
	private static boolean stripTrailingZeroes_DEFAULT = true;
				
	/** Whether to omit trailing zeros from floating-point or double-precision output. */
	private static boolean stripTrailingZeroes = stripTrailingZeroes_DEFAULT;
				
	/** Indicates whether trailing zeros are omitted from output of floating-point or double-precision values, this property can be helpful for debugging.
	 * @return configuration setting whether trailing zeros are stripped
	 */
	public static final boolean isStripTrailingZeroes()
	{
		return stripTrailingZeroes;
	}
	/** Set whether to omit trailing zeros from floating-point or double-precision output, this property can be helpful for debugging.
	 * @param newValue is new value to assign
	 */
	public static final void setStripTrailingZeroes(boolean newValue)
	{
		stripTrailingZeroes = newValue;
	}

// ==========================================================================================
	 
	/** XSLT transformation engine: SAXON (default).
	 * @see <a href="http://saxon.sourceforge.net/#F9.7HE">Saxon-HE 9.7</a>
	 * @see <a href="https://sourceforge.net/projects/saxon/files">Saxon distribution</a>
	 * @see <a href="http://www.saxonica.com/documentation/index.html#!using-xsl/embedding">Saxonica &gt; Saxon &gt; Using XSLT &gt; Invoking XSLT from an application</a>
	 */
	public static final String XSLT_ENGINE_SAXON = "SAXON9HE";
				
	/** XSLT transformation engine: native Java.
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/xslt/transformingXML.html">Java Tutorials: Transforming XML Data with XSLT</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/jaxp/examples/xslt_samples.zip">Java Tutorials: Transforming XML Data with XSLT, sample files</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a>
	 */
	public static final String XSLT_ENGINE_NATIVE_JAVA = "NATIVE_JAVA";
				
	/** XSLT transformation engine setting: default <i>XSLT_ENGINE_SAXON</i>. */
	private static String xsltEngine = XSLT_ENGINE_SAXON;
				
	/** Get preference for XSLT transformation engine to use: {@link XSLT_ENGINE_SAXON} or {@link XSLT_ENGINE_NATIVE_JAVA}.
	 * @return String constant regarding current configuration: XSLT_ENGINE_SAXON (default) or XSLT_ENGINE_NATIVE_JAVA
	 */
	public static final String getXsltEngine()
	{
		return xsltEngine;
	}
	/** Set preference for XSLT transformation engine to use: {@link XSLT_ENGINE_SAXON} or {@link XSLT_ENGINE_NATIVE_JAVA}.
	 * @param newValue is new value to assign */
	public static final void setXsltEngine(String newValue)
	{
		if (newValue.equals(XSLT_ENGINE_SAXON) || newValue.equals(XSLT_ENGINE_NATIVE_JAVA))
			xsltEngine = newValue;
		else
		{
			String errorNotice = "Invalid setXsltEngine(String newValue) invocation, newValue='" + newValue + 
								 "', legal values are ConfigurationProperties.XSLT_ENGINE_SAXON or ConfigurationProperties.XSLT_ENGINE_NATIVE_JAVA";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}

// ==========================================================================================
	 
	/** EXI transformation engine: OpenEXI Nagasena.
	 * <i>Warning:</i> not yet supported.
	 * @see <a href="http://openexi.sourceforge.net">OpenEXI Nagasena</a>
	 * @see <a href="http://openexi.sourceforge.net/tutorial">Nagasena Tutorial</a>
	 * @see <a href="https://www.youtube.com/watch?v=Rig2z9veUv0">Video: OpenEXI, A Quick Introduction</a>
	 * @see ConfigurationProperties#getExiEngine()
	 * @see ConfigurationProperties#setExiEngine(String)
	 * @see ConfigurationProperties#EXI_ENGINE_EXIFICIENT
	 */
	public static final String EXI_ENGINE_OPENEXI = "OPENEXI";
				
	/** XSLT transformation engine: EXIficient (default).
	 * @see <a href="https://github.com/EXIficient">EXIficient project page</a>
	 * @see <a href="https://github.com/EXIficient/exificient/blob/master/README.md">EXIficient README</a>
	 * @see ConfigurationProperties#getExiEngine()
	 * @see ConfigurationProperties#setExiEngine(String)
	 * @see ConfigurationProperties#EXI_ENGINE_OPENEXI
	 */
	public static final String EXI_ENGINE_EXIFICIENT = "EXIFICIENT";
				
	/** EXI transformation engine setting: default <i>EXI_ENGINE_EXIFICIENT</i>. */
	private static String exiEngine = EXI_ENGINE_EXIFICIENT;
				
	/** Get preference for XSLT transformation engine to use: {@link EXI_ENGINE_EXIFICIENT} or {@link EXI_ENGINE_OPENEXI}.
	 * @return String constant regarding current configuration: EXI_ENGINE_EXIFICIENT} (default) or EXI_ENGINE_OPENEXI
	 * @see ConfigurationProperties#EXI_ENGINE_EXIFICIENT
	 * @see ConfigurationProperties#EXI_ENGINE_OPENEXI
	 * @see ConfigurationProperties#setExiEngine(String)
	 */
	public static final String getExiEngine()
	{
		return exiEngine;
	}
	/** Set preference for EXI transformation engine to use: {@link EXI_ENGINE_EXIFICIENT} or {@link EXI_ENGINE_OPENEXI}.
	 * @param newValue is new value to assign
	 * @see ConfigurationProperties#EXI_ENGINE_EXIFICIENT
	 * @see ConfigurationProperties#EXI_ENGINE_OPENEXI
	 * @see ConfigurationProperties#getExiEngine()
     */
	public static final void setExiEngine(String newValue)
	{
		if (newValue.equals(EXI_ENGINE_EXIFICIENT) || newValue.equals(EXI_ENGINE_OPENEXI))
			xsltEngine = newValue;
		else
		{
			String errorNotice = "Invalid setExiEngine(String newValue) invocation, newValue='" + newValue + 
								 "', legal values are ConfigurationProperties.EXI_ENGINE_EXIFICIENT or ConfigurationProperties.EXI_ENGINE_OPENEXI";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		}
	}

// ==========================================================================================
			
	/** Initialize this ConfigurationProperties instance to default values. */
	public static final void initialize()
	{
		indentIncrement            = indentIncrement_DEFAULT;
		indentCharacter            = indentCharacter_DEFAULT;
		showDefaultAttributes      = showDefaultAttributes_DEFAULT;
		validationExceptionAllowed = validationExceptionAllowed_DEFAULT;
		deleteIntermediateFiles    = deleteIntermediateFiles_DEFAULT;
		stripTrailingZeroes	   = stripTrailingZeroes_DEFAULT;
                normalizeCommentWhitespace = normalizeCommentWhitespace_DEFAULT;
		overwriteExistingFiles     = overwriteExistingFiles_DEFAULT;
		setExiEngine (EXI_ENGINE_EXIFICIENT);
		setXsltEngine(XSLT_ENGINE_SAXON);
	}
		
	/** Default name of properties file.
	 * @see ConfigurationProperties#getPropertiesFileName()
	 * @see ConfigurationProperties#setPropertiesFileName(String)
	 * @see ConfigurationProperties#loadProperties()
	 */
	public static final String PROPERTIES_FILENAME_DEFAULT = "X3DJSAIL.properties";
	
	/** Name of properties file. */
	private static String propertiesFileName = PROPERTIES_FILENAME_DEFAULT;
	
	/** Set name of properties file.
	 * @see ConfigurationProperties#PROPERTIES_FILENAME_DEFAULT
	 * @see ConfigurationProperties#getPropertiesFileName()
	 * @see ConfigurationProperties#loadProperties()
	 * @param fileName new name of properties file to load and parse
	 */
	public static void setPropertiesFileName(String fileName)
	{
		propertiesFileName = fileName;
	}
	
	/** Get name of current properties file.
	 * @see ConfigurationProperties#PROPERTIES_FILENAME_DEFAULT
	 * @see ConfigurationProperties#setPropertiesFileName(String)
	 * @see ConfigurationProperties#loadProperties()
	 * @return name of properties file to load and parse
	 */
	public static String getPropertiesFileName()
	{
		return propertiesFileName;
	}
				
	/** Update settings in this ConfigurationProperties instance using values in property file.
	 * @see ConfigurationProperties#PROPERTIES_FILENAME_DEFAULT
	 * @see ConfigurationProperties#getPropertiesFileName()
	 * @see ConfigurationProperties#setPropertiesFileName(String)
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/environment/properties.html">Java Tutorials: Properties</a>
	 * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html">Javadoc: java.util.Properties</a>
	 */
	public static void loadProperties()
	{
		// create and load default properties
		Properties loadedProperties = new Properties();
		try {
			File propertiesFile = new File(getPropertiesFileName());
			if (!propertiesFile.exists())
			{
				System.out.println (WARNING_CONFIGURATION_X3DJSAIL + ": " + getPropertiesFileName() + " properties file not found");
			}
			FileInputStream in = new FileInputStream(propertiesFile);
			loadedProperties.load(in);
			in.close();
		}
		catch (IOException ioe)
		{
            System.out.println (ERROR_CONFIGURATION_X3DJSAIL + ": " + ioe.getMessage());
            ioe.printStackTrace(); // further diagnosis needed
		}
		System.out.print (getPropertiesFileName() + " includes " + loadedProperties.size());
		if (loadedProperties.size() == 0)
			System.out.println (" properties");
		else if (loadedProperties.size() == 1)
			System.out.println (" property:");
		else
			System.out.println (" properties:");
		loadedProperties.list(System.out);
		
		if (loadedProperties.size() > 0)
		{
			if (loadedProperties.contains("indentIncrement"))
				indentIncrement = Integer.getInteger(loadedProperties.getProperty("indentIncrement"));
			if (loadedProperties.contains("indentCharacter"))
			{
				String indentCharacterProperty = loadedProperties.getProperty("indentCharacter");
				if		(indentCharacterProperty.toUpperCase().contains("SPACE"))
						 indentCharacter = indentCharacter_SPACE;
				else if (indentCharacterProperty.toUpperCase().contains("TAB"))
						 indentCharacter = indentCharacter_SPACE;
				else if (!indentCharacterProperty.isEmpty())
					System.out.println ("Error: unrecognized property indentCharacter='" + indentCharacterProperty + 
						"' (allowed values are SPACE and TAB)");
			}
			if (loadedProperties.contains("showDefaultAttributes"))
				showDefaultAttributes = Boolean.getBoolean(loadedProperties.getProperty("showDefaultAttributes"));
			if (loadedProperties.contains("validationExceptionAllowed"))
		     validationExceptionAllowed = Boolean.getBoolean(loadedProperties.getProperty("validationExceptionAllowed"));
			if (loadedProperties.contains("deleteIntermediateFiles"))
				deleteIntermediateFiles = Boolean.getBoolean(loadedProperties.getProperty("deleteIntermediateFiles"));
			if (loadedProperties.contains("stripTrailingZeroes"))
				stripTrailingZeroes = Boolean.getBoolean(loadedProperties.getProperty("stripTrailingZeroes"));
			if (loadedProperties.contains("normalizeCommentWhitespace"))
				normalizeCommentWhitespace = Boolean.getBoolean(loadedProperties.getProperty("normalizeCommentWhitespace"));
			if (loadedProperties.contains("overwriteExistingFiles"))
				overwriteExistingFiles = Boolean.getBoolean(loadedProperties.getProperty("overwriteExistingFiles"));
				
			if      (loadedProperties.contains("EXI_ENGINE") && loadedProperties.getProperty("EXI_ENGINE").toUpperCase().contains("EXIFICIENT"))
					setExiEngine (EXI_ENGINE_EXIFICIENT);
			else if (loadedProperties.contains("EXI_ENGINE") && loadedProperties.getProperty("EXI_ENGINE").toUpperCase().contains("OPENEXI"))
					setExiEngine (EXI_ENGINE_OPENEXI);
			else if (loadedProperties.contains("EXI_ENGINE"))
					System.out.println ("Error: unrecognized property EXI_ENGINE=" + loadedProperties.getProperty("EXI_ENGINE") + 
						"' (allowed values are EXIFICIENT and OPENEXI)");
				
			if      (loadedProperties.contains("XSLT_ENGINE") && loadedProperties.getProperty("EXI_ENGINE").toUpperCase().contains("SAXON"))
					setXsltEngine(XSLT_ENGINE_SAXON);
			else if (loadedProperties.contains("XSLT_ENGINE") && loadedProperties.getProperty("EXI_ENGINE").toUpperCase().contains("NATIVE_JAVA"))
					setXsltEngine(XSLT_ENGINE_NATIVE_JAVA);
			else if (loadedProperties.contains("XSLT_ENGINE"))
					System.out.println ("Error: unrecognized property XSLT_ENGINE=" + loadedProperties.getProperty("XSLT_ENGINE") + 
						"' (allowed values are SAXON and NATIVE_JAVA)");
		}
		System.out.println ("------------------------");
		System.out.println (getPropertiesFileName() + " loading complete.");
	}

	/**
	 * Get current system CLASSPATH value.  Note that a current version of X3DJSAIL.*.jar is expected to be in the current CLASSPATH.
	 * @see <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/classpath.html">Java documentation: Setting the Class Path</a>
	 * @see <a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">Java Tutorials: PATH and CLASSPATH</a>
	 * @return system CLASSPATH value. */
	public static String getClassPath()
	{
		return System.getProperty("java.class.path");
	}
	/**
	 * Get indentCharacter used when serializing scene output.
	 * @see #setIndentCharacter(char)
	 * @see #setIndentIncrement(int)
	 * @return indentCharacter (either indentCharacter_SPACE or indentCharacter_TAB). */
	public static char getIndentCharacter()
	{
		return indentCharacter;
	}
	/**
	 * Set indentCharacter used when serializing scene output.
	 * @param newIndentCharacter is new indent value (non-negative).
	 * @see #setX3dCanonicalForm() */
	public static void setIndentCharacter (char newIndentCharacter)
	{
		if  ((newIndentCharacter == indentCharacter_SPACE) || (newIndentCharacter == indentCharacter_TAB))
			 indentCharacter = newIndentCharacter;
		else 
		{
			String errorNotice = "Invalid indentCharacter='" + newIndentCharacter + 
								 "' provided to ConfigurationProperties, expected indentCharacter_SPACE or indentCharacter_TAB";
//			validationResult.append(errorNotice).append("\n");
			throw new InvalidFieldValueException(errorNotice);
		} 
	}
	/**
	 * Get number of characters to indent when serializing scene output.
	 * @see #setIndentCharacter(char)
	 * @see #setIndentIncrement(int)
	 * @return number of characters (non-negative). */
	public static int getIndentIncrement()
	{
		return indentIncrement;
	}
	/**
	 * Set number of characters to indent when serializing scene output.
	 * @param newIndentIncrement is new indentIncrement value (non-negative).
	 * @see #setX3dCanonicalForm() */
	public static void setIndentIncrement (int newIndentIncrement)
	{
		if  (newIndentIncrement >= 0)
			 indentIncrement = newIndentIncrement;
		else
		{
			indentIncrement = 0;
			String errorNotice = "Invalid indentIncrement=" + indentIncrement + " provided to ConfigurationProperties";
//			validationResult.append(errorNotice).append("\n");
			throw new IllegalArgumentException(errorNotice);
		}
	}]]></xsl:text><xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Indicate whether X3D Canonical Form is used for toStringX3D() XML output.
	 * @see #setIndentCharacter(char)
	 * @see #setIndentIncrement(int)
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed binary encoding, 4.2.3 X3D canonical form</a>
	 * @see <a href="https://www.w3.org/TR/xml-c14n">Canonical XML</a>
	 * @see <a href="https://www.w3.org/TR/exi-c14n">Canonical EXI</a>
	 * @see <a href="http://santuario.apache.org">Apache Santuario</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Canonical Form</a>
	 * @see <a href="http://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
	 * @return whether X3D Canonical Form is used. */
	public static boolean isX3dCanonicalForm()
	{
		return ((indentIncrement == indentIncrement_DEFAULT) &&
			    (indentCharacter == indentCharacter_DEFAULT));
	}
	/**
	 * Ensure that X3D Canonical Form is used for XML output, resetting default values for indentation.
	 * @see #setIndentIncrement(int)
	 * @see #setIndentCharacter(char)
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed binary encoding, 4.2.3 X3D canonical form</a>
	 * @see <a href="https://www.w3.org/TR/xml-c14n">Canonical XML</a>
	 * @see <a href="https://www.w3.org/TR/exi-c14n">Canonical EXI</a>
	 * @see <a href="http://santuario.apache.org">Apache Santuario</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm" target="blank">X3D Canonical Form</a>
	 * @see <a href="http://www.web3d.org/x3d/tools/canonical/doc/x3dTools.htm">X3D Canonicalization (C14N) Tool</a>
	 */
	public static void setX3dCanonicalForm()
	{
		indentIncrement = indentIncrement_DEFAULT;
		indentCharacter = indentCharacter_DEFAULT;
	}
	/**
	 * Indicate whether debug mode is active.
	 * @return whether debug mode is active. */
	public static boolean isDebugModeActive()
	{
		return debugModeActive;
	}
	/**
	 * Set whether debug mode is active.
	 * @param newDebugModeActive whether debug mode is active. */
	public static void setDebugModeActive(boolean newDebugModeActive)
	{
		debugModeActive = newDebugModeActive;
	}
	/**
	 * Indicate whether default attributes (and their values) are shown when serializing scene output.
	 * @return whether default attributes are shown. */
	public static boolean isShowDefaultAttributes()
	{
		return showDefaultAttributes;
	}
	/**
	 * Set whether default attributes (and their values) are shown when serializing scene output.
	 * @param newShowDefaultAttributes whether default attributes are shown. */
	public static void setShowDefaultAttributes(boolean newShowDefaultAttributes)
	{
		showDefaultAttributes = newShowDefaultAttributes;
	}
	/**
	 * Indicate whether partial results are allowed if validation exception occurs when serializing scene output.
	 * @return whether validation exceptions are allowed (and operation continues) */
	public static boolean isValidationExceptionAllowed()
	{
		return validationExceptionAllowed;
	}
	/**
	 * Set whether partial results are allowed (and operation continues) if validation exception occurs when serializing scene output.
	 * Can be useful technique for debugging, default value is <i>false</i> for strict operation.
	 * <i>Warning:</i> setting value to <i>true</i> permits creation of an invalid scene graph.
	 * @param newValidationExceptionAllowed whether validation exceptions are allowed (and operation continues) */
	public static void setValidationExceptionAllowed(boolean newValidationExceptionAllowed)
	{
		validationExceptionAllowed = newValidationExceptionAllowed;
	}
	/**
	 * Indicate whether continuation is allowed if validation exception occurs when creating an object.
	 * <i>Warning:</i> TODO experimental.
	 * @return whether validation exceptions are allowed (and operation continues) during object creation */
	public static boolean isCreationConnectionValidationExceptionAllowed()
	{
		return creationConnectionValidationExceptionAllowed;
	}
	/**
	 * Set whether partial results are allowed (and operation continues) if validation exception occurs when creating an object.
	 * Can be useful technique for debugging, default value is <i>true</i> for permissive order of object creation.
	 * <i>Warning:</i> be sure to validate() this scene once construction is complete.
	 * <i>Warning:</i> TODO experimental.
	 * @param newCreationConnectionValidationExceptionAllowed whether validation exceptions are allowed (and object creation continues) */
	public static void setCreationConnectionValidationExceptionAllowed(boolean newCreationConnectionValidationExceptionAllowed)
	{
		creationConnectionValidationExceptionAllowed = newCreationConnectionValidationExceptionAllowed;
	}
	/**
	 * Indicate whether to normalize whitespace in comments, which can aid consistency in canonicalization and security.
	 * @see ConfigurationProperties#normalizeCommentWhitespace_DEFAULT
	 * @see ConfigurationProperties#setNormalizeCommentWhitespace(boolean)
	 * @return whether to normalize whitespace in comments */
	public static boolean isNormalizeCommentWhitespace()
	{
		return normalizeCommentWhitespace;
	}
	/**
	 * Set whether to normalize whitespace in comments, which can aid consistency in canonicalization and security.
	 * @see ConfigurationProperties#normalizeCommentWhitespace_DEFAULT
	 * @see ConfigurationProperties#isNormalizeCommentWhitespace()
	 * @param newNormalizeCommentWhitespace whether to normalize whitespace in comments */
	public static void setNormalizeCommentWhitespace(boolean newNormalizeCommentWhitespace)
	{
		normalizeCommentWhitespace = newNormalizeCommentWhitespace;
	}
	/**
	 * Indicate whether to allow overwriting previously existing files.
	 * @see overwriteExistingFiles_DEFAULT
	 * @return whether creation of new files can overwrite prior versions */
	public static boolean isOverwriteExistingFiles()
	{
		return overwriteExistingFiles;
	}
	/**
	 * Set whether to allow overwriting previously existing files.
	 * @see overwriteExistingFiles_DEFAULT
	 * @param newOverwriteExistingFiles whether creation of new files can overwrite prior versions */
	public static void setOverwriteExistingFiles(boolean newOverwriteExistingFiles)
	{
		overwriteExistingFiles = newOverwriteExistingFiles;
	}
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>
	
	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>X3DConcreteElement</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Topmost abstract parent class for concrete X3D nodes and statements, containing common methods and member variables.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
		
	/** Results log of local validation. */
	protected StringBuilder validationResult = new StringBuilder();

	/**
	 * Add comment as String to contained commentsList.
	 * @param newComment initial value
	 * @return <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public abstract X3DConcreteElement addComments (String newComment);

	/**
	 * Add comments as String[] array to contained commentsList.
	 * @param newComments array of comments
	 * @return <i>this</i> same object to allow sequential method pipelining (i.e. consecutive
setAttribute method invocations).
	 */
	public abstract X3DConcreteElement addComments (String[] newComments);

	/**
	 * Add CommentsBlock to element
	 * @param newCommentsBlock block of comments to add
	 * @return <i>this</i> same object to allow sequential method pipelining (i.e. consecutive set method invocations).
	 */
	public abstract X3DConcreteElement addComments (CommentsBlock newCommentsBlock);
				
	/** Get output of results from prior validation, if any
	 * @return validation results (if any)
	 */		
	public String getValidationResult()
	{
		return validationResult.toString();
	}
				
	/**
	 * Recursive method to provide X3D string serialization of this model subgraph, utilizing XML encoding and conforming to X3D Canonical Form.
	 * @see X3DObject#FILE_EXTENSION_X3D
	 * @see X3DObject#FILE_EXTENSION_XML
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @return X3D string
	 */
	public String toStringX3D()
	{
		return toStringX3D(0); // apply next method with initial indentation level 0
	}
	
	/**
	 * Recursive method to provide X3D string serialization of this model subgraph, utilizing XML encoding and conforming to X3D Canonical Form.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3DObject#FILE_EXTENSION_X3D
	 * @see X3DObject#FILE_EXTENSION_XML
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/X3D_XML.html">X3D XML Encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-3/V3.3/Part03/concepts.html#X3DCanonicalForm">X3D Compressed Binary Encoding: X3D Canonical Form</a>
	 * @return X3D string
	 */
	abstract public String toStringX3D(int indentLevel); // must be overridden
				
	/**
	 * Recursive method to provide ClassicVRML string serialization.
	 * @see X3DObject#FILE_EXTENSION_CLASSICVRML
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/X3D_ClassicVRML.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/grammar.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding, Annex A: Grammar</a>
	 * @return ClassicVRML string
	 */
	public String toStringClassicVRML()
	{
		return toStringClassicVRML(0); // apply next method with initial indentation level 0
	}
				
	/**
	 * Recursive method to provide ClassicVRML string serialization.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3DObject#FILE_EXTENSION_CLASSICVRML
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/X3D_ClassicVRML.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/19776-2/V3.3/Part02/grammar.html">Extensible 3D (X3D) encodings Part 2: Classic VRML encoding, Annex A: Grammar</a>
	 * @return ClassicVRML string
	 */
	abstract public String toStringClassicVRML(int indentLevel); // must be overridden
				
	/**
	 * Recursive method to provide VRML97 string serialization.
	 * @see X3DObject#FILE_EXTENSION_VRML97
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/14772/V2.0/index.html">Virtual Reality Modeling Language (VRML) 97 specification</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/14772-1/V2.1/index.html">VRML 97 v2.1 Amendment</a>
	 * @return VRML97 string
	 */
	public String toStringVRML97()
	{
		return toStringVRML97(0); // apply next method with initial indentation level 0
	}
			
	/**
	 * Recursive method to provide VRML97 string serialization.
	 * @param indentLevel number of levels of indentation for this element
	 * @see X3DObject#FILE_EXTENSION_VRML97
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dResources.html#VRML">X3D Resources: Virtual Reality Modeling Language (VRML) 97</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/14772/V2.0/index.html">Virtual Reality Modeling Language (VRML) 97 specification</a>
	 * @see <a href="http://www.web3d.org/documents/specifications/14772-1/V2.1/index.html">VRML 97 v2.1 Amendment</a>
	 * @return VRML97 string
	 */	
	abstract public String toStringVRML97(int indentLevel); // must be overridden

	/**
	 * Recursive method to validate this element plus all contained nodes and statements.
	 * @return validation results (if any)
	 */
	abstract public String validate(); // must be overridden
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>
	
	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>X3DConcreteNode</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteElement</xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Abstract parent class for concrete X3D nodes, containing common methods and member variables.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<!-- TODO include DEF_USE and global (class) attributeGroup entries in X3D Object Model -->
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to indicate whether this element is an X3D Graphics node (implementing X3DConcreteNode), returns <i>true</i>.
	 * <br><br>
	 * @see X3DConcreteNode
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/glossary.html#Node">X3D Abstract Specification, Terms and definitions: node</a>
	 * @return whether this element is an X3D Graphics node: true
	 */
	public static final boolean isNode()
	{
            // (this instanceof org.web3d.x3d.jsail.X3DConcreteNode)
            return true;
	}
	/**
	 * Utility method to indicate whether this element is an X3D Graphics statement (implementing X3DConcreteStatement), returns <i>false</i>.
	 * <br><br>
	 * @see X3DConcreteStatement
	 * @see CommentsBlock
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/components/core.html#AbstractX3DStructure">X3D Abstract Specification: 7.2.5 Abstract X3D structure</a>
	 * @return whether this element is an X3D Graphics statement: false
	 */
	public static final boolean isStatement()
	{
            //  (this instanceof org.web3d.x3d.jsail.X3DConcreteStatement) && 
            // !(this instanceof org.web3d.x3d.jsail.Core.CommentsBlock)
            return false;
	}

	// Member value declarations are encapsulated and protected, using preferred Java types for concretes library

	/** <i>Tooltip:</i> DEF defines a unique ID name for this node, referenceable by other nodes.
	 * <ul>
	 * <li> <i>Hint:</i> descriptive DEF names improve clarity and help document a model. </li>
	 * <li> <i>Hint:</i> well-defined names can simplify design and debugging through improved author understanding. </li>
	 * </ul>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 */
	private String DEF = DEF_DEFAULT_VALUE;

	/** <i>Tooltip:</i> USE means reuse an already DEF-ed node ID, excluding all child nodes and all other attributes (except for containerField, which can have a different value).
	 * <ul>
	 * <li> <i>Hint:</i> USE references to previously defined DEF geometry (instead of duplicating nodes) can improve performance. </li>
	 * <li> <i>Warning:</i> each USE value must match a corresponding DEF value that is defined earlier in the scene. </li>
	 * </ul>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 */
	private String USE = USE_DEFAULT_VALUE;

	/** The class attribute is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * <ul>
	 * <li> <i>Warning:</i> currently the class attribute is only supported in XML encoding of X3D scenes. </li>
	 * </ul>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a> */
	private String cssClass = CLASS_DEFAULT_VALUE;

	// String constants for default field values match X3D Schema definitions

	/** SFString field named <i>DEF</i> has default value equal to an empty string. */
	public static final String DEF_DEFAULT_VALUE = "";

	/** SFString field named <i>USE</i> has default value equal to an empty string. */
	public static final String USE_DEFAULT_VALUE = "";

	/** SFString field named <i>class</i> has default value equal to an empty string. */
	public static final String CLASS_DEFAULT_VALUE = "";

	/** containerFieldOverride describes non-default field relationship of a node to its parent.
	 * Programmer usage is not ordinarily needed when using this API. */
	private String containerFieldOverride = new String();
				
	/** Initialize all member variables to default values. */
	public void initialize()
	{
		setParentObject(null);
		     DEF = DEF_DEFAULT_VALUE;
		     USE = USE_DEFAULT_VALUE;
		cssClass = CLASS_DEFAULT_VALUE;
	}
	/**
	 * Provide String value from inputOutput SFString field named <i>DEF</i>.
	 * <br><br>
	 * <i>Tooltip:</i> DEF defines a unique ID name for this node, referenceable by other nodes.
	 * <ul>
	 * <li> <i>Hint:</i> descriptive DEF names improve clarity and help document a model. </li>
	 * <li> <i>Hint:</i> well-defined names can simplify design and debugging through improved author understanding. </li>
	 * </ul>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @return value of DEF field
	 */
	public String getDEF()
	{
		return DEF;
	}

	/**
	 * Provide String value from inputOutput SFString field named <i>USE</i>.
	 * <br><br>
	 * <i>Tooltip:</i> USE means reuse an already DEF-ed node ID, excluding all child nodes and all other attributes (except for containerField, which can have a different value).
	 * <ul>
	 * <li> <i>Hint:</i> USE references to previously defined DEF geometry (instead of duplicating nodes) can improve performance. </li>
	 * <li> <i>Warning:</i> each USE value must match a corresponding DEF value that is defined earlier in the scene. </li>
	 * </ul>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @return value of USE field
	 */
	public String getUSE()
	{
		return USE;
	}
	/**
	 * Utility method to indicate whether this element is a <i>USE</i> reference to another previously defined element (which means other fields must be empty).
	 * <br><br>
	 * <i>Tooltip:</i> USE means reuse an already DEF-ed node ID, excluding all child nodes and all other attributes (except for containerField, which can have a different value).
	 * <ul>
	 * <li> <i>Hint:</i> USE references to previously defined DEF geometry (instead of duplicating nodes) can improve performance. </li>
	 * <li> <i>Warning:</i> each USE value must match a corresponding DEF value that is defined earlier in the scene. </li>
	 * </ul>
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#NamingConventions" target="_blank">X3D Scene Authoring Hints: Naming Conventions</a>
	 * @return whether this node is a USE reference
	 */
	public boolean isUSE()
	{
		return !USE.isEmpty();
	}
	/**
	 * Provide String value from inputOutput SFString field named <i>class</i>.
	 * <br><br>
	 * <i>Tooltip:</i> The class attribute is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * <ul>
	 * <li> <i>Warning:</i> currently the class attribute is only supported in XML encoding of X3D scenes. </li>
	 * </ul>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @return value of class field
	 */
	public String getCssClass()
	{
		return cssClass;
	}
	
	/** Protected internal superclass method to keep DEF private, scene authors should use method setDEF(newValue) instead.
	 * @param newValue is new value for the DEF field.
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 * @see <a href="http://www.web3d.org/specifications/X3dRegularExpressions.html">X3D Regular Expressions (regexes)</a>
	 */
	protected void setConcreteDEF(String newValue)
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA)
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment
				
		// Check that newValue parameter meets naming requirements before assigning to scene graph
		if (!newValue.isEmpty() && !org.web3d.x3d.jsail.fields.SFStringObject.isNMTOKEN(newValue))
		{
			throw new org.web3d.x3d.sai.InvalidFieldValueException(getElementName() + " DEF=\"" + newValue +
					"\" has an illegal value, must provide a valid NMTOKEN name string.");
		}
		if (!newValue.isEmpty() && !org.web3d.x3d.jsail.fields.SFStringObject.meetsX3dNamingConventions(newValue))
		{
			System.out.println ("Warning: " + getElementName() + " DEF=\"" + newValue +
					"\" does not meet X3D naming conventions.");
		}
		DEF = newValue;
	}
	/** Protected internal superclass method to keep USE private, scene authors should use method setUse(newValue) instead.
	 * @param newValue is new value for the USE field.
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dTooltips.html#NMTOKEN">X3D Tooltips: type NMTOKEN</a>
	 */
	protected final void setConcreteUSE(String newValue)
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA)
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment

		// Check that newValue parameter meets naming requirements before assigning to scene graph
		if (!newValue.isEmpty() && !org.web3d.x3d.jsail.fields.SFStringObject.isNMTOKEN(newValue))
		{
			throw new org.web3d.x3d.sai.InvalidFieldValueException(getElementName() + " USE=\"" + newValue +
					"\" has an illegal value, must provide a valid NMTOKEN name string.");
		}
		if (!newValue.isEmpty() && !org.web3d.x3d.jsail.fields.SFStringObject.meetsX3dNamingConventions(newValue))
		{
			System.out.println ("Warning: " + getElementName() + " USE=\"" + newValue +
					"\" does not meet X3D naming conventions.");
		}
		USE = newValue;
	}
	/** Protected internal superclass method to keep cssClass private, scene authors should use method setCssClass(newValue) instead.
	 * <i>Tooltip:</i> The class attribute is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * <i>Warning:</i> currently the class attribute is only supported in XML encoding of X3D scenes.
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @param newValue is new value for the cssClass field.
	 */
	protected void setConcreteCssClass(String newValue)
	{
		if (newValue == null)
			newValue = new String(); // Principle of Least Astonishment (POLA)
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment
		cssClass = newValue;
	}
	/** Each concrete class must independently override this abstract method to enable object-specific method pipelining.
	 * @param DEFlabel is new value for the DEF field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object). */
	abstract public X3DConcreteNode setDEF(String DEFlabel);

	/** Each concrete class must independently override this abstract method to enable object-specific method pipelining.
	 * <ul>
	 * <li> <i>Warning:</i> note that the <code>setUSE()</code> method on this node resets all other fields to their default values (except for containerField) and also releases all child nodes. </li>
	 * <li> <i>Warning:</i> no other operations can be performed to modify a USE node other than setting an alternate containerField value. </li>
	 * </ul>
	 * @param USEname is new value for the USE field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object). */
	abstract public X3DConcreteNode setUSE(String USEname);

	/** Each concrete class must independently override this abstract method to enable object-specific method pipelining.
	 * <i>Tooltip:</i> The class attribute is a space-separated list of classes, reserved for use by CSS cascading stylesheets.
	 * <ul>
	 * <li> <i>Warning:</i> currently the class attribute is only supported in XML encoding of X3D scenes. </li>
	 * </ul>
	 * @see <a href="https://www.w3.org/Style/CSS">W3C Cascading Style Sheets</a>
	 * @param cssClass is new value for the class field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object). */
	abstract public X3DConcreteNode setCssClass(String cssClass);

	/**
	 * Assign X3DMetadataObject instance (using a properly typed node) to inputOutput SFNode field <i>metadata</i>.
	 * @param newValue is new value for the metadata field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>
	 */
	abstract public X3DConcreteNode setMetadata (X3DMetadataObject newValue);

	/**
	 * Assign X3DMetadataObject instance (using a properly typed ProtoInstanceObject) to inputOutput SFNode field <i>metadata</i>.
	 * @param newValue is new value for the metadata field.
	 * @return {@link X3DConcreteNode} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#Metadata" target="_blank">X3D Scene Authoring Hints: Metadata Nodes</a>
	 */
	abstract public X3DConcreteNode setMetadata (ProtoInstanceObject newValue); // TODO
				
	/**
	 * Assign field named <i>IS</i> for establishing IS/connect field connections between ProtoInterface fields and internal
ProtoBody nodes.
	 * The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
	 * @param newValue is new value for the description field.
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS">X3D Tooltips: IS</a>
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect">X3D Tooltips: connect</a>
	 * @return <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the
same node object).
	 */
	abstract public X3DConcreteNode setIS(ISObject newValue);
				
	/**
	 * Provide field named <i>IS</i> for establishing IS/connect field connections between ProtoInterface fields and internal
ProtoBody nodes.
	 * The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS">X3D Tooltips: IS</a>
	 * @see <a href="http://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect">X3D Tooltips: connect</a>
	 * @return current ISObject, if any
	 */
	abstract public ISObject getIS();
]]></xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/** containerField describes the field relationship of a node to its parent.
	 * Modification of this value is not ordinarily needed when using this API, since alternative values are provided for informational purposes.
	 * Each concrete class must independently override this array.
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 */
	public String[] containerField_ALTERNATE_VALUES = { };
				
	/** containerField describes the field relationship of a node to its parent.
	 * Modification of this value is not ordinarily needed when using this API, since alternative values are provided for informational purposes.
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 * @return array of allowed String values
	 */
	public String[] getContainerFieldAlternateValues()
	{
		return containerField_ALTERNATE_VALUES;
	}

	/** containerField describes current field relationship of a node to its parent.
	 * Usage is not ordinarily needed when using this API.
	 * @return containerFieldOverride value, if any
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 */
	public String getContainerFieldOverride()
	{
		return containerFieldOverride;
	}
	/** containerField describes current field relationship of a node to its parent.
	 * Usage is not ordinarily needed when using this API.
	 * TODO make this unnecessary for ProtoInstance usage
	 * @param value to set containerFieldOverride, must be allowed in containerField_ALTERNATE_VALUES
	 * @see <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#containerField" target="_blank">X3D Scene Authoring Hints: containerField</a>
	 * @return object reference to node
	 */
	public X3DConcreteNode setContainerFieldOverride(String value)
	{
		if ((value == null) || value.isEmpty())
		{
			 containerFieldOverride = new String();
		}
		else if (getElementName().equals("ProtoInstance") ||
				 ((containerField_ALTERNATE_VALUES != null) && Arrays.asList(containerField_ALTERNATE_VALUES).contains(value)))
		{
			 containerFieldOverride = value;
		}
		else
		{
			String errorNotice = "Invalid setContainerFieldOverride() value='" + value + 
				"', legal values for " + getElementName() + " are containerField_ALTERNATE_VALUES='" + 
				new org.web3d.x3d.jsail.fields.MFStringObject(containerField_ALTERNATE_VALUES).toStringX3D() + "'";
			throw new org.web3d.x3d.sai.InvalidFieldValueException(errorNotice);
		}
		return this;
	}
	/** containerField describes current field relationship of a node to its parent.
	 * Usage is not ordinarily needed when using this API. */
	public void resetContainerFieldOverride()
	{
		containerFieldOverride = new String();
	}
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>
	
	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>X3DConcreteStatement</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteElement</xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Abstract parent class for concrete X3D statements, containing common methods and member variables.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/**
	 * Utility method to indicate whether this element is an X3D Graphics node (implementing X3DConcreteNode), returns <i>false</i>.
	 * <br><br>
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/glossary.html#Node">X3D Abstract Specification, Terms and definitions: node</a>
	 * @return whether this element is an X3D Graphics node: false
	 */
	public static final boolean isNode()
	{
            // (this instanceof org.web3d.x3d.jsail.X3DConcreteNode)
            return false;
	}
	/**
	 * Utility method to indicate whether this element is an X3D Graphics statement (implementing X3DConcreteStatement), returns <i>true</i>.  (Does not include CommentsBlock objects.)
	 * <br><br>
	 * @see CommentsBlock
	 * @see <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/components/core.html#AbstractX3DStructure">X3D Abstract Specification: 7.2.5 Abstract X3D structure</a>
	 * @return whether this element is an X3D Graphics statement: true
	 */
	public static final boolean isStatement()
	{
            //  (this instanceof org.web3d.x3d.jsail.X3DConcreteStatement) && 
            // !(this instanceof org.web3d.x3d.jsail.Core.CommentsBlock)
            return true;
	}

	/** Initialize all member variables to default values. */
	public void initialize()
	{
		setParentObject(null);
	}]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>
	
	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>X3DLoader</xsl:text></xsl:with-param>
		<xsl:with-param name="imports"><xsl:text>
import javax.xml.parsers.DocumentBuilder; 
import javax.xml.parsers.DocumentBuilderFactory;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException; 
import org.xml.sax.SAXParseException;
import org.w3c.dom.Document;

import java.io.File;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.reflect.*;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.parsers.ParserConfigurationException;
import org.web3d.x3d.jsail.CADGeometry.*;
import org.web3d.x3d.jsail.Core.*;
import org.web3d.x3d.jsail.CubeMapTexturing.*;
import org.web3d.x3d.jsail.DIS.*;
import org.web3d.x3d.jsail.EnvironmentalEffects.*;
import org.web3d.x3d.jsail.EnvironmentalSensor.*;
import org.web3d.x3d.jsail.EventUtilities.*;
import org.web3d.x3d.jsail.fields.*;
import org.web3d.x3d.jsail.Followers.*;
import org.web3d.x3d.jsail.Geometry2D.*;
import org.web3d.x3d.jsail.Geometry3D.*;
import org.web3d.x3d.jsail.Geospatial.*;
import org.web3d.x3d.jsail.Grouping.*;
import org.web3d.x3d.jsail.HAnim.*;
import org.web3d.x3d.jsail.Interpolation.*;
import org.web3d.x3d.jsail.KeyDeviceSensor.*;
import org.web3d.x3d.jsail.Layering.*;
import org.web3d.x3d.jsail.Layout.*;
import org.web3d.x3d.jsail.Lighting.*;
import org.web3d.x3d.jsail.Navigation.*;
import org.web3d.x3d.jsail.Networking.*;
import org.web3d.x3d.jsail.NURBS.*;
import org.web3d.x3d.jsail.ParticleSystems.*;
import org.web3d.x3d.jsail.Picking.*;
import org.web3d.x3d.jsail.PointingDeviceSensor.*;
import org.web3d.x3d.jsail.Rendering.*;
import org.web3d.x3d.jsail.RigidBodyPhysics.*;
import org.web3d.x3d.jsail.Rendering.*;
import org.web3d.x3d.jsail.Scripting.*;
import org.web3d.x3d.jsail.Shaders.*;
import org.web3d.x3d.jsail.Shape.*;
import org.web3d.x3d.jsail.Sound.*;
import org.web3d.x3d.jsail.Text.*;
import org.web3d.x3d.jsail.Texturing.*;
import org.web3d.x3d.jsail.Texturing3D.*;
import org.web3d.x3d.jsail.Time.*;
import org.web3d.x3d.jsail.VolumeRendering.*;
import org.web3d.x3d.sai.Shaders.*;
import org.web3d.x3d.sai.Core.*;
import org.web3d.x3d.sai.CubeMapTexturing.*;
import org.web3d.x3d.sai.Grouping.*;
import org.web3d.x3d.sai.Rendering.*;
import org.web3d.x3d.sai.Shape.*;
import org.web3d.x3d.sai.Sound.*;
import org.web3d.x3d.sai.Text.*;
import org.web3d.x3d.sai.Texturing.*;
import org.web3d.x3d.sai.X3DException;
			
// fully specified when occurring:
// import org.w3c.dom.DocumentType;
// import org.w3c.dom.NamedNodeMap;
// import org.w3c.dom.Node;
// import org.w3c.dom.NodeList;
</xsl:text></xsl:with-param>
		<xsl:with-param name="inConcretePackage"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="visibility"><xsl:text>public</xsl:text><!-- no modifier means package-private --></xsl:with-param>
		<xsl:with-param name="isAbstract"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="isUtilityClass"><xsl:text>true</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text><!-- top level --></xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Concrete class for loading an X3D graphics string, file or fragment, encoded in XML, using the Document Object Model (DOM).</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	@see <a href="https://docs.oracle.com/javase/tutorial/jaxp/dom/index.html">Java Tutorials: Document Object Model (DOM)</a>
	
	@see <a href="https://docs.oracle.com/javase/tutorial/jaxp/dom/readingXML.html">Java Tutorials: Reading XML Data into a DOM</a>
]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text><!-- unused --></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	private DocumentBuilderFactory documentBuilderFactory;
	private DocumentBuilder        documentBuilder;
	private Document               document;
	private boolean loadSuccess = false;
	private StringBuilder validationResult = new StringBuilder();
				
	/** Default dtdValidate value for documentBuilderFactory */
	public final boolean DEFAULT_DTD_VALIDATE = false;
	/** Default xsdValidate value for documentBuilderFactory */
	public final boolean DEFAULT_XSD_VALIDATE = false;
				
	private boolean dtdValidate = DEFAULT_DTD_VALIDATE;
	private boolean xsdValidate = DEFAULT_XSD_VALIDATE;
//  private String schemaSource = null;
				
	protected String indentLevel = "  ";
	protected int lineBreakWidth = 100;
	private int lineLength = 0;
				
	// persistent object needed for toX3dObjectTree parse process
	private static X3DObject          loadedX3dObjectTree;	// only one at a time; TODO consider passing as recursive parameter
	
	private X3DConcreteElement holdCopyElementObject; // remember elementObject, trying to keep from falling out of scope
				
	private String  currentProtoNameValue = new String(); // remember name attribute for current ProtoDeclare element
	private boolean currentProtoNodeTypeFound = false;
	private Map<String,String> protoNameToNodeTypesHashMap = new HashMap<>();
	private Map<String,String> protoDEFtoNodeTypesHashMap = new HashMap<>();
	private Map<String,String> protoContainerFieldHashMap  = new HashMap<>();
	
	/** Default constructor to initialize X3DLoaderObject */
	public X3DLoaderObject ()
	{
		initialize();
	}

	private void initialize()
	{
		if (documentBuilderFactory == null) // singleton pattern
			documentBuilderFactory = DocumentBuilderFactory.newInstance();
		documentBuilderFactory.setNamespaceAware(true);
		documentBuilderFactory.setValidating(dtdValidate || xsdValidate);
		loadSuccess = false;
	}
				
	/** Load the XML X3D file using DOM, report whether successful.  Fails if file is empty.
	 * @param fileName path and name of .x3d or .xml file (XML encoding)
	 * @return whether successful
	 * @see #loadModelFromFileX3D(File)
	*/	
	public boolean loadModelFromFileX3D (String fileName)
	{
		if (!fileName.endsWith(X3DObject.FILE_EXTENSION_X3D) && !fileName.endsWith(X3DObject.FILE_EXTENSION_XML))
		{
			throw new X3DException("fileName " + fileName + " does not end with extension " +
                            "\"" + X3DObject.FILE_EXTENSION_X3D + "\" or " +
                            "\"" + X3DObject.FILE_EXTENSION_XML + "\"");
		}
		File x3dFile = new File(fileName);
		
		if (!x3dFile.exists())
		{
			throw new X3DException("fileName " + fileName + " does not exist and cannot be loaded, check path and filename.");
		}
		return loadModelFromFileX3D (x3dFile); // handoff
	}

	/** Load the XML X3D file using DOM, report success 
	 * @param x3dFile existing x3d file (XML encoding)
	 * @return whether successful
	 * @see #loadModelFromFileX3D(String)
	*/	
	public boolean loadModelFromFileX3D (File x3dFile)
	{
		try
		{
			documentBuilder = documentBuilderFactory.newDocumentBuilder();
			OutputStreamWriter errorWriter = new OutputStreamWriter(System.err, ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT);
			documentBuilder.setErrorHandler(new MyErrorHandler (new PrintWriter(errorWriter, true)));
			document = documentBuilder.parse(x3dFile);
                        toX3dObjectTree(document);
		}
		catch (ParserConfigurationException parserConfigurationException)
		{
			Logger.getLogger(X3DLoaderObject.class.getName()).log(Level.SEVERE, null, parserConfigurationException);
                        loadSuccess = false;
                        return loadSuccess;
		}
		catch (SAXException saxException)
		{
			Logger.getLogger(X3DLoaderObject.class.getName()).log(Level.SEVERE, null, saxException);
                        loadSuccess = false;
                        return loadSuccess;
		}
		catch (IOException ioException)
		{
			Logger.getLogger(X3DLoaderObject.class.getName()).log(Level.SEVERE, null, ioException);
                        loadSuccess = false;
                        return loadSuccess;
		}
		loadSuccess = (document != null);
		return loadSuccess;
	}
	/**              
	 * Provide DOM document version of externally loaded X3D file
	 * @return the DOM document, if XML-encoded X3D file was successfully loaded
	 */
	public Document getDomDocument()
	{
		return document;
	}
	/**
	 * Convenience method, use DOM to create X3D string from a previously loaded document with default zero indent.
	 * X3D output is XML encoding.
	 * @param node DOM Node to process
	 * @see X3DObject#FILE_EXTENSION_X3D
	 * @see X3DObject#FILE_EXTENSION_XML
	 * @return the loaded X3D document of interest, starting with regular <i>X3D</i> element headers or possibly a scene fragment
	 */
	public String toStringX3D(org.w3c.dom.Node node) {
		return toStringX3D(node, "");
	}

	/**
	 * Recursive method that uses DOM to create an X3D string from loaded document, where X3D output is in XML encoding.
	 * @param node DOM Node to process
	 * @return the previously loaded X3D document of interest, starting either with regular X3D headers or possibly a scene fragment
	 */
	private String toStringX3D(org.w3c.dom.Node node, String indent)
	{
		boolean nodeChildFound = false;
		StringBuilder result = new StringBuilder();

		switch (node.getNodeType())
		{
			case org.w3c.dom.Node.DOCUMENT_NODE:
				result.append("<?xml version=\"1.0\" encoding=\"").append(ConfigurationProperties.XML_ENCODING_DECLARATION_DEFAULT).append("\"?>").append("\n");
				org.w3c.dom.NodeList childNodeList = node.getChildNodes();	// recurse on children
				if (childNodeList != null)
				{
					for (int i = 0; i < childNodeList.getLength(); i++)
					{
						result.append(toStringX3D(childNodeList.item(i), ""));
					}
				}
				break;

			case org.w3c.dom.Node.DOCUMENT_TYPE_NODE:
				org.w3c.dom.DocumentType documentType = (org.w3c.dom.DocumentType) node;

				result.append("<!DOCTYPE ").append(documentType.getName());
				// first set X3D DOCTYPE to specified values
				if (documentType.getName().compareTo("X3D") == 0)
				{
					result.append(" PUBLIC \"ISO//Web3D//DTD X3D 3.3//EN\"");
					result.append(" \"http://www.web3d.org/specifications/x3d-3.3.dtd\"");
				}
				else if ((documentType.getPublicId() != null) && (documentType.getSystemId() != null))
				{
					result.append(" PUBLIC \"").append(documentType.getPublicId()).append("\"");
					result.append("        \"").append(documentType.getSystemId());
				}
				else if ((documentType.getPublicId() == null) && (documentType.getSystemId() != null))
				{
					result.append(" SYSTEM \"").append(documentType.getSystemId());
				}
				childNodeList = node.getChildNodes(); // recurse on children, e.g. CDATA and namespaces
				if (childNodeList != null)
				{
					for (int i = 0; i < childNodeList.getLength(); i++)
					{
						result.append(toStringX3D(childNodeList.item(i), ""));
					}
				}
				if ((documentType.getPublicId() != null) && (documentType.getSystemId() != null))
				{
					result.append(">").append("\n");
				}
				else if ((documentType.getPublicId() == null) && (documentType.getSystemId() != null))
				{
					result.append("\">").append("\n");
				}
				else
				{
					result.append(">").append("\n");
				}
				break;

			case org.w3c.dom.Node.ELEMENT_NODE:
				String name = node.getNodeName();
				result.append(indent).append("<").append(name);
				lineLength = name.length() + 2;
				org.w3c.dom.NamedNodeMap attributes = node.getAttributes(); // print attributes first

				for (int i = 0; i < attributes.getLength(); i++)
				{
					org.w3c.dom.Node current = attributes.item(i);
					String attributeValue = new String();
					if (current.getNodeValue() != null)
						attributeValue = current.getNodeValue();
					// looks like no conversion needed when reading from DOM!
//					if (attributeValue.contains("\\"))
//						attributeValue = attributeValue.replaceAll("\\\\","\\\\"); // replace literal \ with \\
//					if (attributeValue.contains("\""))
//						attributeValue = attributeValue.replaceAll("\"","\\\"");   // replace literal " with \"
//					if (attributeValue.contains("Immel")) // trace
//						System.out.println (attributeValue);
					result.append(" ").append(current.getNodeName()).append("=\'").append(attributeValue).append("\'");
				}

				// determine if any actual element child nodes are present
				org.w3c.dom.NodeList children = node.getChildNodes();
				for (int i = 0; i < children.getLength(); i++)
				{
					if (children.item(i).getNodeType() != org.w3c.dom.Node.TEXT_NODE)
					{
						nodeChildFound = true;
						break;
					}
				}
				// TODO confirm: handle CDATA text in Script (and Shader) nodes
				
				if (nodeChildFound == true) // recurse on each non-attribute child
				{
					result.append(">").append("\n");
				//	result.append ("<!-- iterating over children -->").append("\n"); // debug
					for (int i = 0; i < children.getLength(); i++)
					{
						result.append(toStringX3D(children.item(i), indent + indentLevel));
					}
					result.append(indent).append("</").append(name).append(">").append("\n"); // closing tag
				}
				else
				{
					result.append("/>").append("\n"); // singleton close
				}
				break;

			case org.w3c.dom.Node.TEXT_NODE:
				//	trim() removes leading and trailing whitespace
				result.append(node.getNodeValue().trim());
				break;

			case org.w3c.dom.Node.CDATA_SECTION_NODE:
				result.append(indent).append("<![CDATA[").append(node.getNodeValue()).append(]]></xsl:text>
				<xsl:text>"]</xsl:text><xsl:text>]>").append("\n");</xsl:text><!-- special handling for CDATA delimiter ]]> -->
				<xsl:text disable-output-escaping="yes"><![CDATA[
				break;

			case org.w3c.dom.Node.COMMENT_NODE:
				result.append(indent).append("<!-- ").append(node.getNodeValue().trim()).append(" -->").append("\n");
				break;

			case org.w3c.dom.Node.PROCESSING_INSTRUCTION_NODE:
				// PROCESSING_INSTRUCTION_NODE typically unused; seems to repeat COMMENT_NODE, and so ignored
				// result.append(indent).append("<?").append(node.getNodeName()).append(" ")
				//		 .append(node.getNodeValue()).append("?>").append("\n");
				break;

			case org.w3c.dom.Node.ENTITY_REFERENCE_NODE:
				result.append("&").append(node.getNodeName()).append(";");
				break;
		}
		return result.toString();
	}

	/**
	 * Recursive method that uses DOM to create X3DJSAIL objects from a previously loaded document,
	 * taking advantage of Java Reflection and String-based field accessors with <i>protected</i> access that are not otherwise usable.
	 * @see <a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Java Tutorials: Reflection API</a>
	 * @see <a href="https://www.manning.com/books/java-reflection-in-action">Java Reflection in Action</a>
	 * @param node DOM Node to process
	 * @return the loaded X3D objects of interest, starting with regular X3DObject or possibly a scene fragment
	 */
	public X3DConcreteElement toX3dObjectTree(org.w3c.dom.Node node)
	{
		toX3dObjectTree(node, null); // no parent
		return loadedX3dObjectTree;
	}

	/**
	 * Recursive method that uses DOM to create X3DJSAIL objects from a previously loaded document,
	 * taking advantage of Java Reflection and String-based field accessors with <i>protected</i> access that are not otherwise usable.
	 * @see <a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Java Tutorials: Reflection API</a>
	 * @see <a href="https://www.manning.com/books/java-reflection-in-action">Java Reflection in Action</a>
	 * @param node DOM Node to process
	 * @param parentElement the parent of this scene object, if any
	 * @return the loaded X3D objects of interest, starting with regular X3DObject or possibly a scene fragment
	 */
	public X3DConcreteElement toX3dObjectTree(org.w3c.dom.Node node, X3DConcreteElement parentElement)
	{
		String indent = "  "; // TODO omit when refactored
		boolean   nodeChildFound = false;
		Class<X3DConcreteElement> elementClass; // TODO <X3DConcreteElement> ?
		X3DConcreteElement       elementObject = null;
		String errorNotice;

		switch (node.getNodeType())
		{
			case org.w3c.dom.Node.DOCUMENT_NODE:
				// omit: ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
				org.w3c.dom.NodeList childNodeList = node.getChildNodes();	// recurse on children
				if (childNodeList != null)
				{
					for (int i = 0; i < childNodeList.getLength(); i++)
					{
						// recurse on children having elementObject as parent
						toX3dObjectTree(childNodeList.item(i), elementObject);
						// do not return from here, instead process all top-level nodes to completion
					}
				}
				break;

			case org.w3c.dom.Node.DOCUMENT_TYPE_NODE:
				// omit: org.w3c.dom.Node.DocumentType documentType = (org.w3c.dom.Node.DocumentType) node;
				childNodeList = node.getChildNodes();	// recurse on children, e.g. CDATA and namespaces
				if (childNodeList != null)
				{
					for (int i = 0; i < childNodeList.getLength(); i++)
					{
						// recurse on children having elementObject as parent
						toX3dObjectTree(childNodeList.item(i), elementObject);
						// do not return from here, instead process all top-level nodes to completion
					}
				}
				break;

			case org.w3c.dom.Node.ELEMENT_NODE:
				String                nodeName = node.getNodeName();			// DOM
				String             elementName = node.getNodeName() + "Object"; // X3DJSAIL class name
				String             packageName = X3DConcreteNode.getPackageName(elementName); // X3DJSAIL utility
				String	  elementSetMethodName;
				Method		  elementSetMethod;
					
				// http://stackoverflow.com/questions/7495785/java-how-to-instantiate-a-class-from-stringstring
				
				try // to create X3DObject and related X3DConcreteElement node/statement objects
				{
					elementClass  = (Class<X3DConcreteElement>)Class.forName(packageName); // must be fully qualified packageName
					elementObject = elementClass.newInstance();
					
					if ((elementObject instanceof org.web3d.x3d.jsail.Core.X3DObject) // remember root node of X3D model if found
						|| ((loadedX3dObjectTree == null) && (elementObject instanceof org.web3d.x3d.jsail.X3DConcreteNode))) // found fragment
					{
						loadedX3dObjectTree = (X3DObject) elementObject; // remember X3D root
						// starting a new scene, reset hash maps
						protoNameToNodeTypesHashMap.clear();
						protoDEFtoNodeTypesHashMap.clear();
						protoContainerFieldHashMap.clear();
					}
					if (elementObject instanceof org.web3d.x3d.jsail.Core.ProtoDeclareObject) // remember prototype declarations
					{
						// inspect DOM to find ProtoDeclare name
						currentProtoNameValue = node.getAttributes().getNamedItem("name").getNodeValue();
						currentProtoNodeTypeFound = false;
					}
				}
				catch (ClassNotFoundException cnfe)
				{
					// TODO logging
					errorNotice = "[X3DLoaderObject error] Fully qualified object package not found," +
                                            "\n   " + cnfe + " " + cnfe.getMessage();
                                        if ((cnfe.getCause()!= null) && !cnfe.getCause().getMessage().isEmpty())
                                            errorNotice += "\n   " + cnfe.getCause();
					validationResult.append(errorNotice).append("\n");
					System.err.println(errorNotice);
                                        return null; // draconian parse
				}
				catch (IllegalAccessException iae)
				{
					// TODO logging
					errorNotice = "[X3DLoaderObject error] Visibility of no-parameter constructor inaccessible," +
                                            "\n   " + iae + " " + iae.getMessage();
                                        if ((iae.getCause()!= null) && !iae.getCause().getMessage().isEmpty())
                                            errorNotice += "\n   " + iae.getCause();
					validationResult.append(errorNotice).append("\n");
					System.err.println(errorNotice);
                                        return null; // draconian parse
				}
				catch (InstantiationException ie)
				{
					// TODO logging
					errorNotice = "[X3DLoaderObject error] Failure occurred inside constructor," +
                                            "\n   " + ie + " " + ie.getMessage();
                                        if ((ie.getCause()!= null) && !ie.getCause().getMessage().isEmpty())
                                            errorNotice += "\n   " + ie.getCause();
					validationResult.append(errorNotice).append("\n");
					System.err.println(errorNotice);
                                        return null; // draconian parse
				}
						
				// determine if any actual element child nodes are present
				org.w3c.dom.NodeList children = node.getChildNodes();
				for (int i = 0; i < children.getLength(); i++)
				{
					if (children.item(i).getNodeType() != org.w3c.dom.Node.TEXT_NODE)
					{
						nodeChildFound = true;
						break;
					}
				}
				// recurse on each non-attribute child
				if (nodeChildFound == true)
				{
					// iterating over children, adding each child to current (parent) node using appropriate method.
					// n.b. assumes X3D scene is valid!
					for (int i = 0; i < children.getLength(); i++)
					{
						if ((children.item(i) == null) || (elementObject == null) ||
						    (children.item(i).getNodeType() == org.w3c.dom.Node.TEXT_NODE))
							continue; // break to end of loop, continue with next Node children.item(i)

						// recurse on children having elementObject as parent
						X3DConcreteElement childX3dElement = toX3dObjectTree(children.item(i), elementObject);
						if ((childX3dElement == null) || (childX3dElement.getElementName() == null))
							continue;
						String       childElementName = childX3dElement.getElementName();
						String childProtoInstanceName = new String();
						String childProtoInstanceUSE  = new String();
						String         containerField = new String();
						if (children.item(i).getAttributes().getNamedItem("containerField") != null)
						{
							containerField =
							children.item(i).getAttributes().getNamedItem("containerField").getNodeValue();
							if ((childX3dElement instanceof X3DConcreteNode) && !(containerField == null) && !containerField.isEmpty())
								 ((X3DConcreteNode)childX3dElement).setContainerFieldOverride(containerField);
						}
						String  protoInstanceNodeType = new String();
						String                    DEF = new String();
						
						try // adding this object to scene graph
						{
							// TODO better handling of prototypes is needed
							if      (nodeName.equals("ProtoBody"))
							{
								// remember ProtoDeclare type when found
								if (!currentProtoNodeTypeFound)
								{
									currentProtoNodeTypeFound = true;
									protoNameToNodeTypesHashMap.put(currentProtoNameValue, childElementName);
								}
							}
							else if (childElementName.equals("ProtoInstance"))
							{
								// use DOM to find name for this element
								if (children.item(i).getAttributes().getNamedItem("name") != null)
									childProtoInstanceName = children.item(i).getAttributes().getNamedItem("name").getNodeValue();
						        // containerField already found
								protoInstanceNodeType = protoNameToNodeTypesHashMap.get(currentProtoNameValue);
				
								if (children.item(i).getAttributes().getNamedItem("DEF") != null)			// DOM
								{
									// save node type for this ProtoInstance DEF so that ProtoInstance USE can find it later
									String childProtoInstanceDEF = children.item(i).getAttributes().getNamedItem("DEF").getNodeValue();
									protoDEFtoNodeTypesHashMap.put(childProtoInstanceDEF, protoInstanceNodeType);
									protoContainerFieldHashMap.put(childProtoInstanceDEF, containerField);
								}
								else if (children.item(i).getAttributes().getNamedItem("USE") != null)
								{
									// ProtoInstance USE syntax does not include name, must find it via original DEF
									childProtoInstanceUSE = children.item(i).getAttributes().getNamedItem("USE").getNodeValue();
									protoInstanceNodeType = protoDEFtoNodeTypesHashMap.get(childProtoInstanceUSE); // find it
									       containerField = protoContainerFieldHashMap.get(childProtoInstanceUSE); // find it
								}
								if (!containerField.equals("children"))
									((ProtoInstanceObject) childX3dElement).setContainerField(containerField);
								// diagnostics
								if ((childProtoInstanceUSE != null) && !childProtoInstanceUSE.isEmpty() &&
								    ((protoInstanceNodeType == null) ||  protoInstanceNodeType.isEmpty()))
								{
						
									// TODO logging
									errorNotice = "[X3DLoaderObject error] ProtoInstance " + childProtoInstanceName +
										" found with USE " + childProtoInstanceUSE + " but unable to find original ProtoInstance DEF node type, thus unable to add to scene graph";
									validationResult.append(errorNotice).append("\n");
									System.err.println(errorNotice);
									continue;
								}
								else if (((protoInstanceNodeType == null) || protoInstanceNodeType.isEmpty()) &&
								         ((       containerField == null) ||        containerField.isEmpty()))
								{
									// TODO logging
									errorNotice = "[X3DLoaderObject error] ProtoInstance " + childProtoInstanceName +
										" found but node type is unknown and " +
										"containerField is missing, unable to add to scene graph";
									validationResult.append(errorNotice).append("\n");
									System.err.println(errorNotice);
									continue;
								}
								else if ((protoInstanceNodeType == null) || protoInstanceNodeType.isEmpty())
								{
									// TODO logging
									errorNotice = "[X3DLoaderObject error] ProtoInstance " + childProtoInstanceName +
										" found but node type is unknown and " +
										"containerField is " + containerField + ", unable to add to scene graph";
									validationResult.append(errorNotice).append("\n");
									System.err.println(errorNotice);
									continue;
								}
								else if ((containerField == null) || containerField.isEmpty())
								{
									// TODO logging
									errorNotice = "[X3DLoaderObject error] ProtoInstance " + childProtoInstanceName +
										" found and node type is " + protoInstanceNodeType + " but " +
										"containerField is missing, unable to add to scene graph";
									validationResult.append(errorNotice).append("\n");
									System.err.println(errorNotice);
									continue;
								}
								/* no longer needed, using protoNodeTypeHashMap, wasn't yet connected by parse process anyway
								// must find node type of corresponding prototype in order to add it to current parent element
								ProtoDeclareObject protoDeclare = (ProtoDeclareObject) loadedX3dObjectTree.findElementByNameValue(childProtoInstanceName,ProtoDeclareObject.NAME);
								if (protoDeclare != null)
								{
								    protoInstanceNodeType = protoDeclare.getNodeType();
								}
								else // no protoDeclare found, look for externProtoDeclare
								{
									ExternProtoDeclareObject externProtoDeclare = (ExternProtoDeclareObject) loadedX3dObjectTree.findElementByNameValue(childProtoInstanceName,ExternProtoDeclareObject.NAME);
									if (externProtoDeclare != null)
										protoInstanceNodeType = externProtoDeclare.getNodeType();
								}
								*/
							}

							if      (childElementName.equals("head"))
									((X3DObject)elementObject).setHead ((headObject) childX3dElement);
							else if (childElementName.equals("component"))
									((headObject)elementObject).addComponent ((componentObject) childX3dElement);
							else if (childElementName.equals("meta"))
									((headObject)elementObject).addMeta ((metaObject) childX3dElement);
							else if (childElementName.equals("unit"))
									((headObject)elementObject).addUnit ((unitObject) childX3dElement);
							else if (childElementName.equals("Scene"))
									((X3DObject)elementObject).setScene ((SceneObject) childX3dElement);
							else if (nodeName.equals("Scene") && childElementName.startsWith("Metadata"))
									((SceneObject)elementObject).addMetadata ((X3DMetadataObject) childX3dElement);
							else if (nodeName.equals("Scene") && childElementName.equals("LayerSet"))
									((SceneObject)elementObject).addLayerSet ((LayerSetObject) childX3dElement);
							else if (nodeName.equals("Scene"))
									((SceneObject)elementObject).addChild((X3DChildNode) childX3dElement);
							// CommentsBlock handled by case org.w3c.dom.Node.COMMENT_NODE
					
							// proto and field handling begins here to avoid possible subsequent missteps
							else if (nodeName.equals("ProtoDeclare") && childElementName.equals("ProtoInterface"))
									((ProtoDeclareObject)elementObject).setProtoInterface((ProtoInterfaceObject) childX3dElement);
							else if (nodeName.equals("Script") && childElementName.equals("field"))
									((ScriptObject)elementObject).addField((fieldObject) childX3dElement);
							else if (nodeName.equals("ProtoInterface") && childElementName.equals("field"))
									((ProtoInterfaceObject)elementObject).addField((fieldObject) childX3dElement);
							else if (nodeName.equals("ExternProtoDeclare") && childElementName.equals("field"))
									((ExternProtoDeclareObject)elementObject).addField((fieldObject) childX3dElement);
							else if (nodeName.equals("ProtoBody"))
									((ProtoBodyObject)elementObject).addChildren((X3DNode) childX3dElement); // note looser node type
							else if (childElementName.equals("ProtoBody"))
									((ProtoDeclareObject)elementObject).setProtoBody((ProtoBodyObject) childX3dElement);
							else if (nodeName.equals("field"))
									((fieldObject)elementObject).addChild((X3DNode) childX3dElement);
							else if (nodeName.equals("fieldValue"))
									((fieldValueObject)elementObject).addChild((X3DChildNode) childX3dElement);
							else if (childElementName.equals("fieldValue"))
									((ProtoInstanceObject)elementObject).setFieldValue((fieldValueObject) childX3dElement);
							else if (nodeName.equals("ShaderProgram") && childElementName.equals("field"))
									((ShaderProgramObject)elementObject).addField((fieldObject) childX3dElement);
							else if (nodeName.equals("ComposedShader") && childElementName.equals("field"))
									((ComposedShaderObject)elementObject).addField((fieldObject) childX3dElement);
							else if (nodeName.equals("PackagedShader") && childElementName.equals("field"))
									((PackagedShaderObject)elementObject).addField((fieldObject) childX3dElement);
					
							else if (nodeName.equals("Collision") && (containerField.equals("proxy")))
									((CollisionObject)elementObject).setProxy ((X3DChildNode) childX3dElement);
				// TODO what about ProtoInstance proxy?  unnecessary?
							else if (nodeName.equals("Collision") && (protoInstanceNodeType.equals("proxy")))
									((CollisionObject)elementObject).setProxy ((ProtoInstanceObject) childX3dElement);
							else if (nodeName.equals("MetadataSet") && childElementName.startsWith("Metadata") && (!containerField.equals("metadata")))
									((MetadataSetObject)elementObject).addValue ((X3DMetadataObject) childX3dElement);
							else if (childElementName.startsWith("Metadata"))
									((X3DConcreteNode)elementObject).setMetadata ((X3DMetadataObject) childX3dElement);
							else if (protoInstanceNodeType.equals("Metadata"))
									((X3DConcreteNode)elementObject).setMetadata ((ProtoInstanceObject) childX3dElement);
					
							else if (childElementName.equals("Appearance"))
									((ShapeObject)elementObject).setAppearance ((X3DAppearanceNode) childX3dElement);
							else if (protoInstanceNodeType.equals("Appearance"))
									((ShapeObject)elementObject).setAppearance ((ProtoInstanceObject) childX3dElement);
					
							else if (childElementName.equals("Material"))
									((AppearanceObject)elementObject).setMaterial ((MaterialObject) childX3dElement);
							else if (protoInstanceNodeType.equals("Material"))
									((AppearanceObject)elementObject).setMaterial ((ProtoInstanceObject) childX3dElement);
					
							else if (childElementName.equals("LineProperties"))
									((AppearanceObject)elementObject).setLineProperties ((LinePropertiesObject) childX3dElement);
							else if (protoInstanceNodeType.equals("LineProperties"))
									((AppearanceObject)elementObject).setLineProperties ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("Sound") && (childElementName.equals("AudioClip") || childElementName.equals("MovieTexture")))
									((SoundObject)elementObject).setSource ((X3DSoundSourceNode) childX3dElement);

							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture") && containerField.equals("front"))
									((ComposedCubeMapTextureObject)elementObject).setFront ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && protoInstanceNodeType.equals("Texture") && containerField.equals("front"))
									((ComposedCubeMapTextureObject)elementObject).setFront ((ProtoInstanceObject) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture") && containerField.equals("back"))
									((ComposedCubeMapTextureObject)elementObject).setBack ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && protoInstanceNodeType.equals("Texture") && containerField.equals("back"))
									((ComposedCubeMapTextureObject)elementObject).setBack ((ProtoInstanceObject) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture") && containerField.equals("left"))
									((ComposedCubeMapTextureObject)elementObject).setLeft ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && protoInstanceNodeType.equals("Texture") && containerField.equals("left"))
									((ComposedCubeMapTextureObject)elementObject).setLeft ((ProtoInstanceObject) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture") && containerField.equals("right"))
									((ComposedCubeMapTextureObject)elementObject).setRight ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && protoInstanceNodeType.equals("Texture") && containerField.equals("right"))
									((ComposedCubeMapTextureObject)elementObject).setRight ((ProtoInstanceObject) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture") && containerField.equals("top"))
									((ComposedCubeMapTextureObject)elementObject).setTop ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && protoInstanceNodeType.equals("Texture") && containerField.equals("top"))
									((ComposedCubeMapTextureObject)elementObject).setTop ((ProtoInstanceObject) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture") && containerField.equals("bottom"))
									((ComposedCubeMapTextureObject)elementObject).setBottom ((X3DTexture2DNode) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && protoInstanceNodeType.equals("Texture") && containerField.equals("bottom"))
									((ComposedCubeMapTextureObject)elementObject).setBottom ((ProtoInstanceObject) childX3dElement);
							else if (nodeName.equals("ComposedCubeMapTexture") && childElementName.endsWith("Texture"))
							{
										errorNotice = "[X3DLoaderObject error] parent " + nodeName + " has child " + childElementName + " with invalid containerField='" + containerField + "' (must have value of front, back, left, right, top or bottom)";
										validationResult.append(errorNotice).append("\n");
							}
							else if (nodeName.equals("ComposedCubeMapTexture") && protoInstanceNodeType.equals("Texture"))
							{
										errorNotice = "[X3DLoaderObject error] parent " + nodeName + " has child ProtoInstance with invalid containerField='" + containerField + "' (must have value of front, back, left, right, top or bottom)";
										validationResult.append(errorNotice).append("\n");
							}
					
							else if (childElementName.endsWith("Texture"))
									((AppearanceObject)elementObject).setTexture ((X3DTextureNode) childX3dElement);
							else if (protoInstanceNodeType.equals("Texture"))
									((AppearanceObject)elementObject).setTexture ((ProtoInstanceObject) childX3dElement);

							else if (childElementName.contains("TextureTransform"))
									((AppearanceObject)elementObject).setTextureTransform ((X3DTextureTransformNode) childX3dElement);
							else if (protoInstanceNodeType.equals("TextureTransform"))
									((AppearanceObject)elementObject).setTextureTransform ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("ComposedShader") && childElementName.equals("ShaderPart"))
									((ComposedShaderObject)elementObject).addParts ((ShaderPartObject) childX3dElement);
							
							// TODO ComposedShaderObject design missing utility method to add ProtoInstance to typed array
							else if (nodeName.equals("ComposedShader") && protoInstanceNodeType.equals("ShaderPart")) // TODO is this correct type?
							{
//									((ComposedShaderObject)elementObject).addParts ((ProtoInstanceObject) childX3dElement);
									errorNotice = "[X3DLoaderObject error] parent " + nodeName + " design shortfall, has no addParts(ProtoInstance) utility method";
									validationResult.append(errorNotice).append("\n");
							}
							else if (nodeName.equals("ProgramShader") && childElementName.equals("ShaderProgram"))
									((ProgramShaderObject)elementObject).addPrograms ((ShaderProgramObject) childX3dElement);
							// TODO ProgramShaderObject design missing utility method to add ProtoInstance to typed array
							else if (nodeName.equals("ProgramShader") && protoInstanceNodeType.equals("ShaderProgram")) // TODO is this correct type?
							{
//									((ProgramShaderObject)elementObject).addPrograms ((ProtoInstanceObject) childX3dElement);
									errorNotice = "[X3DLoaderObject error] parent " + nodeName + " design shortfall, has no addParts(ProtoInstance) utility method";
									validationResult.append(errorNotice).append("\n");
							}
					
							else if (childElementName.contains("Shader"))
									((AppearanceObject)elementObject).addShaders ((X3DShaderNode) childX3dElement);
				// TODO		else if (protoInstanceNodeType.equals("Shader"))
				// fix				((AppearanceObject)elementObject).addShaders ((ProtoInstanceObject) childX3dElement);

							else if (childElementName.equals("Box") || childElementName.equals("Cone") || childElementName.equals("Cylinder") ||
									 childElementName.equals("Sphere") || childElementName.equals("Text") || childElementName.equals("IndexedFaceSet") ||
									 childElementName.equals("Arc2d") || childElementName.equals("ArcClose2d") || childElementName.equals("Circle2D") ||
									 childElementName.equals("Disk2D") || childElementName.equals("Polyline2D") || childElementName.equals("Polypoint2D") ||
									 childElementName.equals("Rectangle2D ") || childElementName.equals("TriangleSet2D") ||
									 childElementName.equals("ElevationGrid") || childElementName.equals("Extrusion") || childElementName.equals("GeoElevationGrid") ||
									 childElementName.equals("IndexedLineSet") || childElementName.equals("IndexedPointSet") || childElementName.equals("IndexedQuadSet") ||
									 childElementName.equals("LineSet") || childElementName.equals("PointSet") || childElementName.equals("QuadSet") ||
									 childElementName.equals("IndexedTriangleFanSet") || childElementName.equals("IndexedTriangleSet") || childElementName.equals("IndexedTriangleStripSet") ||
									 childElementName.equals("TriangleFanSet") || childElementName.equals("TriangleSet") || childElementName.equals("TriangleStripSet") ||
									 childElementName.equals("NurbsCurve") || childElementName.equals("NurbsSweptSurface") || childElementName.equals("NurbsSwungSurface")
									)
									((ShapeObject)elementObject).setGeometry ((X3DGeometryNode) childX3dElement);
							else if (protoInstanceNodeType.equals("Box") || protoInstanceNodeType.equals("Cone") || protoInstanceNodeType.equals("Cylinder") ||
									 protoInstanceNodeType.equals("Sphere") || protoInstanceNodeType.equals("Text") || protoInstanceNodeType.equals("IndexedFaceSet") ||
									 protoInstanceNodeType.equals("Arc2d") || protoInstanceNodeType.equals("ArcClose2d") || protoInstanceNodeType.equals("Circle2D") ||
									 protoInstanceNodeType.equals("Disk2D") || protoInstanceNodeType.equals("Polyline2D") || protoInstanceNodeType.equals("Polypoint2D") ||
									 protoInstanceNodeType.equals("Rectangle2D ") || protoInstanceNodeType.equals("TriangleSet2D") ||
									 protoInstanceNodeType.equals("ElevationGrid") || protoInstanceNodeType.equals("Extrusion") || protoInstanceNodeType.equals("GeoElevationGrid") ||
									 protoInstanceNodeType.equals("IndexedLineSet") || protoInstanceNodeType.equals("IndexedPointSet") || protoInstanceNodeType.equals("IndexedQuadSet") ||
									 protoInstanceNodeType.equals("LineSet") || protoInstanceNodeType.equals("PointSet") || protoInstanceNodeType.equals("QuadSet") ||
									 protoInstanceNodeType.equals("IndexedTriangleFanSet") || protoInstanceNodeType.equals("IndexedTriangleSet") || protoInstanceNodeType.equals("IndexedTriangleStripSet") ||
									 protoInstanceNodeType.equals("TriangleFanSet") || protoInstanceNodeType.equals("TriangleSet") || protoInstanceNodeType.equals("TriangleStripSet") ||
									 protoInstanceNodeType.equals("NurbsCurve") || protoInstanceNodeType.equals("NurbsSweptSurface") || protoInstanceNodeType.equals("NurbsSwungSurface")
									)
									((ShapeObject)elementObject).setGeometry ((ProtoInstanceObject) childX3dElement);

							// IndexedFaceSet, TriangleSet, QuadSet etc.
							else if (nodeName.endsWith("Set") && childElementName.equals("Normal"))
									((X3DComposedGeometryNode)elementObject).setNormal((NormalObject) childX3dElement);
							else if (nodeName.endsWith("Set") && protoInstanceNodeType.equals("Normal"))
									((X3DComposedGeometryNode)elementObject).setNormal((ProtoInstanceObject) childX3dElement);
							else if (nodeName.endsWith("Set") && childElementName.contains("TextureCoordinate"))
									((X3DComposedGeometryNode)elementObject).setTexCoord((X3DTextureCoordinateNode) childX3dElement);
							else if (nodeName.endsWith("Set") && protoInstanceNodeType.contains("TextureCoordinate"))
									((X3DComposedGeometryNode)elementObject).setTexCoord((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("ElevationGrid") && childElementName.equals("Normal"))
									((ElevationGridObject)elementObject).setNormal((NormalObject) childX3dElement);
							else if (nodeName.equals("ElevationGrid") && protoInstanceNodeType.equals("Normal"))
									((ElevationGridObject)elementObject).setNormal((ProtoInstanceObject) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && childElementName.equals("Normal"))
									((GeoElevationGridObject)elementObject).setNormal((NormalObject) childX3dElement);
							else if (nodeName.equals("GeoElevationGrid") && protoInstanceNodeType.equals("Normal"))
									((GeoElevationGridObject)elementObject).setNormal((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("IndexedFaceSet") && childElementName.contains("Coordinate"))
									((IndexedFaceSetObject)elementObject).setCoord ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("IndexedFaceSet") && protoInstanceNodeType.contains("Coordinate"))
									((IndexedFaceSetObject)elementObject).setCoord ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("IndexedLineSet") && childElementName.contains("Coordinate"))
									((IndexedLineSetObject)elementObject).setCoord ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("IndexedLineSet") && protoInstanceNodeType.contains("Coordinate"))
									((IndexedLineSetObject)elementObject).setCoord ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("LineSet") && childElementName.contains("Coordinate"))
									((LineSetObject)elementObject).setCoord ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("LineSet") && protoInstanceNodeType.contains("Coordinate"))
									((LineSetObject)elementObject).setCoord ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("PointSet") && childElementName.contains("Coordinate"))
									((PointSetObject)elementObject).setCoord ((X3DCoordinateNode) childX3dElement);
							else if (nodeName.equals("PointSet") && protoInstanceNodeType.contains("Coordinate"))
									((PointSetObject)elementObject).setCoord ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("IndexedFaceSet") && childElementName.contains("Color"))
									((IndexedFaceSetObject)elementObject).setColor ((X3DColorNode) childX3dElement);
							else if (nodeName.equals("IndexedLineSet") && protoInstanceNodeType.contains("Color"))
									((IndexedFaceSetObject)elementObject).setColor ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("PointSet") && childElementName.contains("Color"))
									((PointSetObject)elementObject).setColor ((X3DColorNode) childX3dElement);
							else if (nodeName.equals("PointSet") && protoInstanceNodeType.contains("Color"))
									((PointSetObject)elementObject).setColor ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("IndexedLineSet") && childElementName.contains("Color"))
									((IndexedLineSetObject)elementObject).setColor ((X3DColorNode) childX3dElement);
							else if (nodeName.equals("IndexedLineSet") && protoInstanceNodeType.contains("Color"))
									((IndexedLineSetObject)elementObject).setColor ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("LineSet") && childElementName.contains("Color"))
									((LineSetObject)elementObject).setColor ((X3DColorNode) childX3dElement);
							else if (nodeName.equals("LineSet") && protoInstanceNodeType.contains("Color"))
									((LineSetObject)elementObject).setColor ((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("ViewpointGroup") && childElementName.equals("Viewpoint"))
									((ViewpointGroupObject)elementObject).addChild((ViewpointObject) childX3dElement);
							else if (nodeName.equals("ViewpointGroup") && protoInstanceNodeType.equals("Viewpoint"))
									((ViewpointGroupObject)elementObject).addChild((ProtoInstanceObject) childX3dElement);

							else if (nodeName.equals("Text") && childElementName.equals("FontStyle"))
									((TextObject)elementObject).setFontStyle ((X3DFontStyleNode) childX3dElement);
							else if (nodeName.equals("Text") && protoInstanceNodeType.equals("FontStyle"))
									((TextObject)elementObject).setFontStyle ((ProtoInstanceObject) childX3dElement);

							else if (childElementName.equals("IS"))
									((X3DConcreteNode)elementObject).setIS ((ISObject) childX3dElement);
							// no prototype for IS or connect

							else if (nodeName.equals("IS") && childElementName.equals("connect"))
									((ISObject)elementObject).addConnect ((connectObject) childX3dElement);
							// no prototype for IS or connect

							// TODO more
					
							// default fallback works for majority of parent-child relationships but throws exception otherwise
							else	((X3DGroupingNode)elementObject).addChildren(new X3DNode[] { (X3DNode) childX3dElement } ); // default fallback
							// making it this far without exception means satisfactory parent-child relationship found
						}
						catch (Exception e)
						{
							// TODO logging
							errorNotice = "[X3DLoaderObject error] Incorrectly handled object construction, current elementObject=" + nodeName + 
										  " (" + elementObject.getElementName() + "), child=" + childElementName + ", " + e;
							validationResult.append(errorNotice).append("\n");
							System.err.println(errorNotice);
							e.printStackTrace(); // further diagnosis needed, DOM loader errors are tricky
							continue;
						}
					}
				}
				// properly handle contained CDATA text after child elements handled
				if      (nodeName.equals("Script") && !node.getTextContent().trim().isEmpty())
				{
					((ScriptObject)elementObject).setSourceCode (node.getTextContent().trim());
				}
				else if (nodeName.equals("ShaderProgram") && !node.getTextContent().trim().isEmpty())
				{
					(( ShaderProgramObject)elementObject).setSourceCode (node.getTextContent().trim());
				}
				else if (nodeName.equals("ShaderPart") && !node.getTextContent().trim().isEmpty())
				{
					(( ShaderPartObject)elementObject).setSourceCode (node.getTextContent().trim());
				}

				// handle attributes next, note that DOM includes all attributes (including those with default values)
					
				org.w3c.dom.NamedNodeMap attributes = node.getAttributes();
				for (int i = 0; i < attributes.getLength(); i++)
				{
					String				    fieldObjectTypePrefix;
					String				    fieldObjectName;
					Class<X3DConcreteField> fieldObjectClass; // TODO <X3DConcreteField> ?
					X3DConcreteField	    fieldObject;
					Method			 	    fieldSetMethod;
					String			 	    fieldSetMethodName = "setValueByString";

					org.w3c.dom.Node currentAttributeNode = attributes.item(i);
					String attributeName  = currentAttributeNode.getNodeName();
					String attributeValue = currentAttributeNode.getNodeValue();
					// http://www.regexplanet.com/advanced/java/index.html
					// https://www.regular-expressions.info/java.html see "backslash-mess"
					// https://docs.oracle.com/javase/tutorial/java/data/characters.html
					// looks like no conversion needed when reading from DOM!
//					if (attributeValue.contains("\\"))
//						attributeValue = attributeValue.replaceAll("\\\\","\\\\"); // replace literal \ with \\
//					if (attributeValue.contains("\""))
//						attributeValue = attributeValue.replaceAll("\"","\\\"");   // replace literal " with \"
//					if (attributeValue.contains("Immel")) // trace
//						System.out.println (attributeValue);

					// errorNotice prelude now gets predefined (in case needed later)
					errorNotice = "[X3DLoaderObject error] <" + nodeName + " " + attributeName + "='" + attributeValue + "'/> exception: ";
					
					// ignore unused attributes
					if      (attributeName.equals("containerField"))
					{
						 continue; // containerField not saved, instead handled by scene-graph structure during serialization
					}
					else if (attributeName.startsWith("xmlns:") || attributeName.startsWith("xsd:") || // X3D element
							 attributeName.contains  (":")) // also skip any qualified element name
					{
						// TODO logging, consider warning
						// errorNotice = nodeName + " attribute ignored: " + attributeName;
						// validationResult.append(errorNotice).append("\n");
						// System.err.println(errorNotice);
						continue;
					}
					
					String attributeType  = elementObject.getFieldType(attributeName); // X3DJSAIL utility
					elementSetMethodName  = "set";
					if (attributeName.equals("class"))
						elementSetMethodName += "Css";
					elementSetMethodName += attributeName.substring(0,1).toUpperCase() + 
											attributeName.substring(1); // setCamelCase

					// check for proper handling of SFString/MFString escape characters, particularly backslashed quotes
					String unescapedAttributeValue = attributeValue.replace("\\\\\"", "\\\""); // TODO regex needed for other cases of special character inputss?
					if   (!unescapedAttributeValue.equals(attributeValue))
					{
						// trace statement for debug use
						System.out.println ("*trace of X3DLoaderObject DOM import: attributeValue='" + attributeValue + 
								"', unescapedAttributeValue='" + unescapedAttributeValue + 
								"', attributeName='" + attributeName + 
								"', attributeType='" + attributeType + "'");
						attributeValue = unescapedAttributeValue;
					}
					// now add each attribute to element
					try // to first create corresponding field object, then invoke set method on parent node object
					{
						// first create field object, e.g. org.web3d.x3d.jsail.fields.SFFloatObject
						if   (attributeType.equals(SFStringObject.NAME))
						{
							// SFString attribute values are easy: set value directly on parent object
							elementSetMethod  = elementClass.getMethod(elementSetMethodName, ((Class<String>[])new Class[] { String.class }));
							elementSetMethod.invoke (elementObject, new Object[] { attributeValue });
						}]]></xsl:text>
						<!--
						// not needed: previously problematic case
						else if   (attributeType.equals(SFVec3fObject.NAME))
						{
							// directly create object
							SFVec3fObject sfv3fo = new SFVec3fObject();
							sfv3fo.setValueByString(attributeValue);
							elementSetMethod  = elementClass.getMethod(elementSetMethodName, new Class[] { SFVec3fObject.class });
							elementSetMethod.invoke (elementObject, new Object[] { sfv3fo });
						}
						--><xsl:text disable-output-escaping="yes"><![CDATA[
						else if (attributeType.equals(SFNodeObject.NAME) || attributeType.equals(MFNodeObject.NAME))
						{
							// TODO logging
							errorNotice = "[X3DLoaderObject error] Unexpectedly encountered " + attributeType + " type when parsing attribute" + 
											attributeName + ".";
							validationResult.append(errorNotice).append("\n");
							System.err.println(errorNotice);
							continue;
						}
						else // other SF* or MF* type: build corresponding fieldObject, then invoke set method on element
						{
							fieldObjectTypePrefix = "org.web3d.x3d.jsail.fields.";
							fieldObjectName       = fieldObjectTypePrefix + attributeType + "Object";
							fieldObjectClass      = (Class<X3DConcreteField>)Class.forName(fieldObjectName);
							// Class.newInstance() creates constructor using no parameters
							fieldObject           = fieldObjectClass.newInstance(); // default value
							fieldObject.initialize(); // make sure reset
							
							// Invoke protected fieldObject.setValueByString() to match
							// fieldObjectClass.getDeclaredMethods(); // debug use; must be Declared for protected visibility
							fieldSetMethod = fieldObjectClass.getDeclaredMethod(fieldSetMethodName, ((Class<String>[])new Class[] { String.class }));
							
							// https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AccessibleObject.html
							if (!!Modifier.isPublic(fieldSetMethod.getModifiers()))
							{
								// TODO logging
//								errorNotice = "[X3DLoaderObject error] Java reflection problem, class-protected " + fieldObjectName + "." +
//									fieldSetMethodName + "(\"" + attributeValue + "\") method not publicly accessible";
//								validationResult.append(errorNotice).append("\n");
//								System.err.println(errorNotice);
								// reason for this is not clear, but apparently it is necessary
								fieldSetMethod.setAccessible(true); // class-protected methods must be made accessible
							}
							// set value on org.web3d.x3d.jsail.fields.* fieldObject to reinitialize it
							fieldSetMethod.invoke (fieldObject, new Object[] { attributeValue });
							
							elementSetMethod  = elementClass.getMethod(elementSetMethodName, ((Class<fieldObject>[])new Class[] { fieldObjectClass }));
							elementSetMethod.invoke (elementObject, new Object[] { fieldObject });
							// element now has correct attribute value set  8)
						}
					}
					catch (ClassNotFoundException cnfe)
					{
						// TODO logging
						errorNotice = "[X3DLoaderObject error] Fully qualified object package not found," +
                                                    "\n   " + cnfe + " " + cnfe.getMessage();
						if ((cnfe.getCause()!= null) && !cnfe.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + cnfe.getCause();
						validationResult.append(errorNotice).append("\n");
						System.err.println(errorNotice);
						return null; // draconian parse
					}
					catch (IllegalAccessException iae)
					{
						// TODO logging
						errorNotice = "[X3DLoaderObject error] Visibility of no-parameter constructor inaccessible," +
                                                    "\n   " + iae + " " + iae.getMessage();
						if ((iae.getCause()!= null) && !iae.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + iae.getCause();
						validationResult.append(errorNotice).append("\n");
						System.err.println(errorNotice);
						return null; // draconian parse
					}
					catch (InstantiationException ie)
					{
						// TODO logging
						errorNotice = "[X3DLoaderObject error] Failure occurred inside constructor," +
                                                    "\n   " + ie + " " + ie.getMessage();
						if ((ie.getCause()!= null) && !ie.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + ie.getCause();
						validationResult.append(errorNotice).append("\n");
						System.err.println(errorNotice);
						return null; // draconian parse
					}
					catch (InvocationTargetException ite)
					{
						// TODO logging
						errorNotice = "[X3DLoaderObject error] Invoking " + nodeName + "." + elementSetMethodName + "(" + attributeValue + ") failed (likely due to illegal value)," +
                                                    "\n   " + ite + " " + ite.getMessage();
						if ((ite.getCause()!= null) && !ite.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + ite.getCause();
						validationResult.append(errorNotice).append("\n");
						System.err.println(errorNotice + "\n");
						return null; // draconian parse
					}
					catch (NoSuchMethodException nsme)
					{
						// TODO logging
						errorNotice = "[X3DLoaderObject error] Incorrectly constructed set method name," +
                                                    "\n   " + nsme + " " + nsme.getMessage();
						if ((nsme.getCause()!= null) && !nsme.getCause().getMessage().isEmpty())
                                                    errorNotice += "\n   " + nsme.getCause();
						validationResult.append(errorNotice).append("\n");
						System.err.println(errorNotice);
						return null; // draconian parse
					}
				}	// continue for each attribute until all are set
				
				break;

			case org.w3c.dom.Node.TEXT_NODE:
				//	trim() removes leading and trailing whitespace
				if (node.getNodeValue().trim().isEmpty())
				{
					// TODO logging
					errorNotice = "[X3DLoaderObject error] Unexpected plain text found: " + node.getNodeValue().trim();
					validationResult.append(errorNotice).append("\n");
					System.err.println(errorNotice);
				}
				break;

			case org.w3c.dom.Node.CDATA_SECTION_NODE:
				// CDATA content already handled by parent node (e.g. Script ShaderProgram ShaderPart above)
				break;

			case org.w3c.dom.Node.COMMENT_NODE:
				CommentsBlock commentsBlock = new CommentsBlock(node.getNodeValue());
				if (parentElement == null)
				{
					// TODO logging
					errorNotice = "[X3DLoaderObject error] CommentsBlock found without prior parent being saved; ignored.";
					errorNotice+= "<!-- " + node.getNodeValue() + " -->";
					validationResult.append(errorNotice).append("\n");
					System.err.println(errorNotice);
				}
				// TODO sort out X3D Unified Object Model (X3DUOM) to support
				else parentElement.addComments(commentsBlock);
				break;

			case org.w3c.dom.Node.PROCESSING_INSTRUCTION_NODE:
				// System.out.println(indent + "<?" + node.getNodeName() + " " + node.getNodeValue() + "?>");
				break;

			case org.w3c.dom.Node.ENTITY_REFERENCE_NODE:
				// System.out.print("&" + node.getNodeName() + ";");
				break;
		}
		// TODO what is this block for??
//		for (org.w3c.dom.Nodechild = node.getFirstChild(); child != null; child = child.getNextSibling())
//		{
//			// recurse on children having elementObject as parent
//			toX3dObjectTree(child, elementObject);
//		}
//		if (elementObject != null) // trace
//		{
//			holdCopyElementObject = elementObject; // remember elementObject, trying to keep from falling out of scope
//			System.out.print ("**************************************************\n" + holdCopyElementObject.toStringX3D()); // debug
//		}
		return elementObject; // TODO confirm complete
	}

	/** TODO javadoc */
	private static class MyErrorHandler implements ErrorHandler {
     
		private final PrintWriter out;

		MyErrorHandler(PrintWriter out)
		{
			this.out = out;
		}

		private String getParseExceptionInfo(SAXParseException spe)
		{
			String systemId = spe.getSystemId();
			if (systemId == null)
			{
				systemId = "null";
			}
			String info = "URI=" + systemId + " Line=" + spe.getLineNumber() +
						  ": " + spe.getMessage();
			return info;
		}
		@Override
		public void warning(SAXParseException spe) throws SAXException
		{
			String message = "Warning: " + getParseExceptionInfo(spe);
//			validationResult.append(message).append("\n");
			out.println(message);
		}
		@Override
		public void error(SAXParseException spe) throws SAXException
		{
			String message = "Error: " + getParseExceptionInfo(spe);
//			validationResult.append(message).append("\n");
			throw new SAXException(message);
		}
		@Override
		public void fatalError(SAXParseException spe) throws SAXException
		{
			String message = "Fatal Error: " + getParseExceptionInfo(spe);
//			validationResult.append(message).append("\n");
			throw new SAXException(message);
		}
	}
	/**
	 * Accessor method indicating whether DTD validation is performed when loading an X3D file
	 * @return whether XML DTD validation is performed when loading an X3D file
	 */
	public boolean isDtdValidationPerformed()
	{
		return dtdValidate;
	}
	/**
	 * Accessor method to set whether DTD validation is performed when loading an X3D file, reconfiguring documentBuilderFactory
	 * @param newDtdValidationValue whether DTD validation is performed
	 */
	public void setDtdValidationPerformed(boolean newDtdValidationValue)
	{
		dtdValidate = newDtdValidationValue;
		documentBuilderFactory.setValidating(dtdValidate || xsdValidate);
	}
	/**
	 * Accessor method indicating whether DTD validation is performed when loading an X3D file
	 * @return whether XML Schema validation is performed when loading an X3D file
	 */
	public boolean isXmlSchemaValidationPerformed()
	{
		return xsdValidate;
	}
	/**
	 * Accessor method to set whether XML Schema validation is performed when loading an X3D file, reconfiguring documentBuilderFactory
	 * @param newXmlSchemaValidationValue whether XML Schema validation is performed
	 */
	public void setXmlSchemaValidation(boolean newXmlSchemaValidationValue)
	{
		xsdValidate = newXmlSchemaValidationValue;
		documentBuilderFactory.setValidating(dtdValidate || xsdValidate);
	}
	/**
	 * Provide X3DJSAIL object tree if loading succeeds
	 * @return X3D object tree if loading was successful, null otherwise
	 */
	public X3DConcreteElement getX3dObjectTree()
	{
		return loadedX3dObjectTree;
	}

	/**
	 * Accessor method to indicate whether loading was successful and loaded X3dObjectTree is available
	 * @return whether loading was successful
	 */
	public boolean isLoadSuccessful()
	{
		return loadSuccess && (loadedX3dObjectTree != null);
	}

	/**
	 * Provide detailed log of validation results following loading and serialization
	 * @return validationResult log following loading and serialization
	 */
	public String getValidationResult()
	{
		return validationResult.toString();
	}
]]></xsl:text>
		</xsl:with-param>
	</xsl:call-template>
	
	<xsl:call-template name="generateSourceFile">
		<xsl:with-param name="name"><xsl:text>CommentsBlock</xsl:text></xsl:with-param>
		<xsl:with-param name="imports">
			<xsl:text>
import org.web3d.x3d.sai.Core.X3DMetadataObject;
import org.web3d.x3d.jsail.*;</xsl:text>
		</xsl:with-param>
		<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
		<xsl:with-param name="subPackage"><xsl:text>Core</xsl:text></xsl:with-param>
		<xsl:with-param name="extends"><xsl:text>org.web3d.x3d.jsail.X3DConcreteStatement</xsl:text></xsl:with-param>
		<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.Core.X3DChildNode</xsl:text></xsl:with-param>
		<xsl:with-param name="description"><xsl:text>Utility class to enable adding one or more comment strings as a child node, treated as an X3D statement.</xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
		<xsl:with-param name="javadocBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="interfaceBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[]]></xsl:text>
		</xsl:with-param>
		<xsl:with-param name="implementationBlock">
			<xsl:text disable-output-escaping="yes"><![CDATA[
	/** String constant <i>NAME</i> provides name of this element. */
	@SuppressWarnings("FieldNameHidesFieldInSuperclass")
	protected static final String NAME = "CommentsBlock";
				
	/** Provides name of this element: CommentsBlock.
	 * @return name of this element
	 */
	@Override
	public final String getElementName()
	{
		return NAME;
	}
	/** String constant <i>COMPONENT</i> defines X3D component for comments: <i>Core</i>. */
	public static final String COMPONENT = "Core";

	/** Defines X3D component for comments: <i>Core</i>.
	 * @return X3D component for comments
	 */
	@Override
	public final String getComponent()
	{
		return COMPONENT;
	}

	/** Integer constant <i>LEVEL</i> provides default X3D <i>Core</i> component level for comments: <i>1</i>. */
	public static final int LEVEL = 1;

	/** Provides default X3D component level for comments: <i>1</i>.
	 * @return default X3D component level for comments
	 */
	@Override
	public final int getComponentLevel()
	{
		return LEVEL;
	}

	/** Constructor for CommentsBlock. */
	public CommentsBlock()
	{
	  initialize();
	};

	/** Constructor for CommentsBlock to initialize with initial comment string.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newComment initial comment, with no comment delimiters needed
	 */
	public CommentsBlock(String newComment)
	{
		initialize();
		commentsList.add(newComment);
	};

	/** Constructor for CommentsBlock to initialize with initial comments array.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newComments[] initial comments, with no comment delimiters needed
	 */
	public CommentsBlock(String newComments[])
	{
		initialize();
		if ((newComments != null) && (newComments.length > 0))
			commentsList.addAll(Arrays.asList(newComments));
	};
				
	/** Constructor for CommentsBlock to initialize with initial comments list.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newCommentsList initial comments, with no comment delimiters needed
	 */
	public CommentsBlock(ArrayList<String> newCommentsList)
	{
		initialize();
		commentsList.addAll(newCommentsList);
	};

	/**
	 * Add single comment to this CommentsBlock.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newComment initial value, with no comment delimiters needed
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	@Override
	public CommentsBlock addComments(String newComment)
	{
		commentsList.add(newComment);
		return this;
	}
	/**
	 * Add comments as String[] array to this CommentsBlock.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newComments array of comments, with no comment delimiters needed
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	@Override
	public CommentsBlock addComments(String[] newComments)
	{
		commentsList.addAll(Arrays.asList(newComments));
		return this;
	}
	/**
	 * Add comments array as ArrayList of String values to this CommentsBlock.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newCommentsList list of comments, with no comment delimiters needed
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public CommentsBlock addComments(ArrayList<String> newCommentsList)
	{
		commentsList.addAll(newCommentsList);
		return this;
	}
	/**
	 * Add CommentsBlock to this CommentsBlock.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @param newCommentsBlock block of comments to add, with no comment delimiters needed
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	@Override
	public CommentsBlock addComments(CommentsBlock newCommentsBlock)
	{
		commentsList.addAll(Arrays.asList(newCommentsBlock.toStrings()));
		return this;
	}
	
	/**
	 * Provide CommentsBlock as string array.
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @return all comments
	 */
	public String[] toStrings()
	{
		return (String[]) commentsList.toArray();
	}
	
	/**
	 * Provide CommentsBlock as ArrayList of string(s).
	 * No need to include <code>&lt;!--</code> XML comment delimiters <code>--&gt;</code> around new comments.
	 * @return all comments
	 */
	public ArrayList<String> toStringList()
	{
		return commentsList;
	}
				
	/** Initialize this CommentsBlock instance. */
	@Override
	public final void initialize()
	{
		super.initialize();
		commentsList = new ArrayList<>(); // reset
	}
	/** Clear all comments from this CommentsBlock.
	 * @return {@link CommentsBlock} - namely <i>this</i> same object to allow sequential method pipelining (i.e. consecutive method invocations on the same node object).
	 */
	public CommentsBlock clear()
	{
		initialize();
		return this;
	}
	/** Utility method to adjust XML comment delimiters <code>&lt;!--</code> and <code>--&gt;</code>, also replace invalid &quot;<code>--</code>&quot; characters with &quot;<code>- -</code>&quot;.
	 * Typically only used internally when exporting via toStringX3D() methods to avoid (illegal) nested XML comments.
	 * @param newComment is comment to be cleaned
	 * @return cleaned-up string with no problematic XML comment characters embedded
	 */
	public static String cleanXmlCommentDelimiters (String newComment)
	{
		String result = newComment;
		if (result == null)
			result = new String();
		if (result.contains("--"))
		{
			result = result.replaceAll("--","- -");
			// TODO consider log entry
		}
		return result;
	}
]]></xsl:text>
			
		</xsl:with-param>
	</xsl:call-template>
	
    <!-- ===================================================== -->
	
		<xsl:call-template name="generateSourceFile">
			<xsl:with-param name="name"><xsl:text>X3DConcreteFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="isInterface"><xsl:text>false</xsl:text></xsl:with-param>
			<xsl:with-param name="subPackage"><xsl:text>fields</xsl:text></xsl:with-param>
			<xsl:with-param name="extends"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implements"><xsl:text>org.web3d.x3d.sai.X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="imports"><xsl:text>import org.web3d.x3d.sai.X3DFieldEvent;</xsl:text></xsl:with-param>
			<xsl:with-param name="description"><xsl:text>Listener for events passing values from one X3D field to another.</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationSection"><xsl:text>B.4.3 X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="saiJavaSpecificationRelativeUrl"><xsl:text>types.html#X3DFieldEventListener</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationSection"><xsl:text>6.3.20 registerBrowserInterest</xsl:text></xsl:with-param>
			<xsl:with-param name="saiAbstractSpecificationRelativeUrl"><xsl:text>servRef.html#RegisterBrowserInterest</xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationSection"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="x3dAbstractSpecificationRelativeUrl"><xsl:text></xsl:text></xsl:with-param>
			<xsl:with-param name="implementationBlock">
				<xsl:text disable-output-escaping="yes"><![CDATA[
	@Override
	public void readableFieldChanged(X3DFieldEvent event)
	{
		// TODO;
	}
]]></xsl:text>
			</xsl:with-param>
		</xsl:call-template>
	
    </xsl:template> <!-- end of ConcreteNodeObjectDefinitions -->
	
    <!-- ===================================================== -->
	
<xsl:template name="set-newValue-validity-checks">
    <xsl:param name="elementName"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="canThrowFieldValueException"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="isArrayType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="isArrayListType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="x3dType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="javaReferenceType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="comparisonType"><xsl:text></xsl:text></xsl:param>
    <xsl:param name="debug"><xsl:text>false</xsl:text></xsl:param>
										
	<!-- TODO regular expression checks -->
	
	<xsl:variable name="tupleSize">
		<xsl:call-template name="tupleSize">
			<xsl:with-param name="x3dType" select="@type"/>
		</xsl:call-template>
	</xsl:variable>
	<xsl:variable name="javaType">
		<!-- can include collections, must be escaped -->
		<xsl:call-template name="javaType">
			<xsl:with-param name="x3dType" select="@type"/>
		</xsl:call-template>
	</xsl:variable>
	
	<xsl:variable name="isNMTOKENtype">
		<xsl:value-of select="
			(@name = 'DEF') or (@name = 'USE') or
			($elementName = 'ROUTE') or ($elementName = 'connect') or ($elementName = 'EXPORT') or ($elementName = 'IMPORT') or 
			((@name = 'name') and not($elementName = 'meta') and not(starts-with($elementName,'Metadata')) and not(starts-with($elementName,'CAD')))"/>
	</xsl:variable>

	<!-- debug diagnostic 
        <xsl:if test="($debug = 'true')">
            <xsl:message>	
                    <xsl:text>set-newValue-validity-checks: name=</xsl:text>
                    <xsl:value-of select="@name"/>
                    <xsl:text>, type=</xsl:text>
                    <xsl:value-of select="@type"/>
                    <xsl:text>, isArrayType=</xsl:text>
                    <xsl:value-of select="$isArrayType"/>
                    <xsl:text>, isArrayListType=</xsl:text>
                    <xsl:value-of select="$isArrayListType"/>
                    <xsl:text>, baseType=</xsl:text>
                    <xsl:value-of select="@baseType"/>
                    <xsl:text>, javaReferenceType=</xsl:text>
                    <xsl:value-of select="$javaReferenceType"/>
                    <xsl:text>, comparisonType=</xsl:text>
                    <xsl:value-of select="$comparisonType"/>
                    <xsl:text>, tupleSize=</xsl:text>
                    <xsl:value-of select="$tupleSize"/>
            </xsl:message>
        </xsl:if>
	-->
	<xsl:choose>
		<xsl:when test="($isArrayType='true')">
			<xsl:text>  int i = 0;</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>  for (</xsl:text>
			<xsl:value-of select="$javaReferenceType"/>
			<xsl:text> arrayElement : </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:when>
		<xsl:when test="($isArrayListType = 'true')">
		</xsl:when>
	</xsl:choose>
	<xsl:variable name="newValueReference">
		<xsl:choose>
			<xsl:when test="($isArrayType='true')">
				<xsl:value-of select="$newValue"/>
				<xsl:text>[i]</xsl:text>
			</xsl:when>
			<xsl:when test="($isArrayListType = 'true')">
				<xsl:value-of select="$newValue"/>
				<xsl:text>[i]</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$newValue"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="dimensionSuffix">
		<xsl:choose>
			<xsl:when test="(@baseType = 'boundingBoxSizeType')">
				<xsl:text>.length</xsl:text>
			</xsl:when>
			<xsl:when test="(($isArrayListType = 'true') and ($comparisonType = 'complex'))">
				<xsl:text>.size()</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>.length</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	
	<!-- TODO tupleSize modulus checks for MF types -->
	<xsl:choose>
		<xsl:when test="(($isArrayType = 'false') or ($isArrayListType = 'true')) and (number($tupleSize) > 1)">
			<xsl:text>		if (newValue == null)
			newValue = new </xsl:text>
		<xsl:value-of select="substring-before($javaType,'[]')"/>
		<xsl:text>[0];
		// Check that newValue parameter has legal size before assigning to scene graph</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		if (newValue</xsl:text>
			<xsl:value-of select="$dimensionSuffix"/>
			<xsl:choose>
				<xsl:when test="starts-with(@type,'SF')">
					<xsl:text> != </xsl:text>
					<xsl:value-of select="$tupleSize"/>
					<xsl:text>) // </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes">-tuple check
		{</xsl:text>
				</xsl:when>
				<xsl:otherwise><!-- MF type -->
					<xsl:text> % </xsl:text>
					<xsl:value-of select="$tupleSize"/>
					<xsl:text> != 0) // </xsl:text>
				<xsl:value-of select="$tupleSize"/>
				<xsl:text disable-output-escaping="yes">-tuple check
		{</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="contains($dimensionSuffix, 'size')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
					<xsl:text> + "</xsl:text>
					<xsl:text> has size=" + </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:value-of select="$dimensionSuffix"/>
					<xsl:text> + "</xsl:text>
					<xsl:choose>
						<xsl:when test="starts-with(@type,'SF')">
							<xsl:text> instead of required length </xsl:text>
							<xsl:value-of select="$tupleSize"/>
						</xsl:when>
						<xsl:otherwise><!-- MF type -->
							<xsl:text>, must be a multiple of </xsl:text>
							<xsl:value-of select="$tupleSize"/>
						</xsl:otherwise>
					</xsl:choose>					
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>) + "</xsl:text>
					<xsl:text> has length=" + </xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:value-of select="$dimensionSuffix"/>
					<xsl:text> + "</xsl:text>
					<xsl:choose>
						<xsl:when test="starts-with(@type,'SF')">
							<xsl:text> instead of required length </xsl:text>
							<xsl:value-of select="$tupleSize"/>
						</xsl:when>
						<xsl:otherwise><!-- MF type -->
							<xsl:text>, must be a multiple of </xsl:text>
							<xsl:value-of select="$tupleSize"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:when>
	</xsl:choose>
	<xsl:choose>
		<xsl:when test="not($isArrayType = 'true')">
			<xsl:if test="($canThrowFieldValueException) and 
                  ((@type='SFInt32') or (@type='SFFloat') or (@type='SFDouble') or (@type='SFTime') or
                   (@type='SFVec2f') or (@type='SFVec2d') or (@type='SFVec3f')  or (@type='SFVec3d') or
                   (@type='SFVec4f') or (@type='SFVec4d') or (@baseType='boundingBoxSizeType') or
                   (((@type='SFString') or (@type='MFString')) and (enumeration) and not(@additionalEnumerationValuesAllowed='true')))">
				
		<xsl:if test="(string-length(@minExclusive) > 0) or (string-length(@minInclusive) > 0) or (string-length(@maxExclusive) > 0) or (string-length(@maxInclusive) > 0)">
			<xsl:text>            </xsl:text>
			<xsl:text>// Check that newValue parameter has legal value(s) before assigning to scene graph</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:variable name="typeSuffix">
			<xsl:if test="(@type='SFFloat') or ends-with(@type,'f')">
				<xsl:text>f</xsl:text><!-- float-to-float comparison to avoid float-to-double roundoff discrepancies -->
			</xsl:if>
		</xsl:variable>
		<xsl:if test="(string-length(@minExclusive) > 0)">
			<xsl:text>            </xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:choose>
				<xsl:when test="(@type='SFInt32') or (@type='SFFloat') or (@type='SFDouble') or (@type='SFTime')">
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes"> &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
				</xsl:when>
				<xsl:when test="(@type='SFVec2f') or (@type='SFVec2d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="(@type='SFVec3f') or (@type='SFVec3d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="(@type='SFVec4f') or (@type='SFVec4d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[3] &lt;= </xsl:text>
					<xsl:value-of select="@minExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:message><xsl:text>*** set-newValue-validity-checks code-generation error</xsl:text></xsl:message>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>                throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with(@type,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$newValue"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has component value less than (or equal to) restriction minExclusive=</xsl:text>
			<xsl:value-of select="@minExclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>            </xsl:text>
			<xsl:text>}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="(string-length(@minInclusive) > 0)">
			<xsl:text>            </xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:choose>
				<xsl:when test="(@type='SFInt32') or (@type='SFFloat') or (@type='SFDouble') or (@type='SFTime')">
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes"> &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
				</xsl:when>
				<xsl:when test="(@type='SFVec2f') or (@type='SFVec2d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="(@type='SFVec3f') or (@type='SFVec3d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="(@type='SFVec4f') or (@type='SFVec4d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[3] &lt; </xsl:text>
					<xsl:value-of select="@minInclusive"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>            </xsl:text>
			<xsl:text>    throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with(@type,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$newValue"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has component value less than restriction minInclusive=</xsl:text>
			<xsl:value-of select="@minInclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>            </xsl:text>
			<xsl:text>}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="(string-length(@maxExclusive) > 0)">
			<xsl:text>            </xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:choose>
				<xsl:when test="(@type='SFInt32') or (@type='SFFloat') or (@type='SFDouble') or (@type='SFTime')">
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes"> &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
				</xsl:when>
				<xsl:when test="(@type='SFVec2f') or (@type='SFVec2d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="(@type='SFVec3f') or (@type='SFVec3d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="(@type='SFVec4f') or (@type='SFVec4d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[3] &gt;= </xsl:text>
					<xsl:value-of select="@maxExclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>            </xsl:text>
			<xsl:text>    throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with(@type,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has component value greater than (or equal to) restriction maxExclusive=</xsl:text>
			<xsl:value-of select="@maxExclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>            </xsl:text>
			<xsl:text>}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="(string-length(@maxInclusive) > 0)">
			<xsl:text>            </xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:choose>
				<xsl:when test="(@type='SFInt32') or (@type='SFFloat') or (@type='SFDouble') or (@type='SFTime')">
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes"> &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
				</xsl:when>
				<xsl:when test="(@type='SFVec2f') or (@type='SFVec2d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="(@type='SFVec3f') or (@type='SFVec3d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:when test="(@type='SFVec4f') or (@type='SFVec4d')">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[0] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[1] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[2] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>) || (</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text disable-output-escaping="yes">[3] &gt; </xsl:text>
					<xsl:value-of select="@maxInclusive"/>
					<xsl:value-of select="$typeSuffix"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>            </xsl:text>
			<xsl:text>    throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with(@type,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has component value greater than (or equal to) restriction maxInclusive=</xsl:text>
			<xsl:value-of select="@maxInclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>            </xsl:text>
			<xsl:text>}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="(@baseType='boundingBoxSizeType')">
			<xsl:text>		// Check legal value for bounding box bboxSize</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		</xsl:text>
			<xsl:text>if (</xsl:text>
			<xsl:text>(</xsl:text>
			<xsl:text>(</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[0] &lt; 0) || (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[1] &lt; 0) || (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[2] &lt; 0)</xsl:text>
			<xsl:text disable-output-escaping="yes">) &amp;&amp; !((</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[0] == -1) &amp;&amp; (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[1] == -1) &amp;&amp; (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text disable-output-escaping="yes">[2] == -1))</xsl:text>
			<xsl:text>) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=" + </xsl:text>
			<xsl:choose>
				<xsl:when test="starts-with(@type,'MF')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$x3dType"/>
					<xsl:value-of select="$jsaiClassSuffix"/>
					<xsl:text>.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "</xsl:text>
			<xsl:text> has negative value but is not equal to sentinel {-1,-1,-1} value.</xsl:text>
			<xsl:value-of select="@maxInclusive"/>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
		<xsl:if test="((@type='SFString') or (@type='MFString'))"><!-- TODO are there any other types with restricted values? -->
			<xsl:choose>
				<xsl:when test="(@type='SFString')">
					<xsl:text>		if (</xsl:text><xsl:value-of select="$newValue"/><xsl:text> == null)
			</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text> = new String(); // null string check</xsl:text>
					<xsl:text>&#10;</xsl:text>
					<xsl:variable name="isEnumerationType" select="(count(enumeration) > 0)"/>
					<xsl:if test="(@type='SFString') and $isEnumerationType">
						<xsl:text>		else </xsl:text>
						<xsl:value-of select="$newValue"/>
						<xsl:text> = MFStringObject.cleanupUnescapedEnclosingQuotes(</xsl:text>
						<xsl:value-of select="$newValue"/>
						<xsl:text>); // enumeration value</xsl:text>
						<xsl:text>&#10;</xsl:text>
					</xsl:if>
				</xsl:when>
				<!-- TODO multiple methods? works for String but not ArrayList<String>
				<xsl:when test="(@type='MFString')">
					<xsl:text>String[0]</xsl:text>
				</xsl:when>
				-->
			</xsl:choose>
			<xsl:text>		// Check that newValue parameter has one of the allowed legal values before assigning to scene graph</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		</xsl:text>
			<xsl:text>if (!(</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:if test="(@type='SFString')">
				<xsl:text>			</xsl:text>
				<xsl:value-of select="$newValue"/>
				<xsl:text>.isEmpty() ||</xsl:text>
				<xsl:text>&#10;</xsl:text>
			</xsl:if>
			<xsl:for-each select="enumeration">
				<xsl:if test="position() > 1">
					<xsl:text> ||</xsl:text>
					<xsl:text>&#10;</xsl:text>
				</xsl:if>
				<xsl:text>			</xsl:text>
				<xsl:choose>
					<xsl:when test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
						<xsl:text>Arrays.asList(</xsl:text>
						<xsl:value-of select="$newValue"/>
						<xsl:text>)</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$newValue"/>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:text>.equals(</xsl:text>
				<xsl:value-of select="upper-case(../@name)"/>
				<xsl:text>_</xsl:text>
				<!-- enumeration name: omit " character, others become _ underscore -->
				<xsl:value-of select="upper-case(translate(@value,' .-&quot;','___'))"/>
				<xsl:text>)</xsl:text>
			</xsl:for-each>
			<xsl:text>)) {</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=\"" + </xsl:text>
			<xsl:choose>
				<xsl:when test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$newValue"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "\"</xsl:text>
			<xsl:text> has illegal value, must use a valid enumeration string.</xsl:text>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
	</xsl:if>
		</xsl:when>
		<xsl:otherwise>
			<!-- TODO ArrayList comparisons -->
		</xsl:otherwise>
	</xsl:choose>
	<!-- SFString initialization and special tests -->
	<xsl:choose>
		<!-- NMTOKEN checks required for all name fields except meta (which matches HTML), CAD* and Metadata* -->
		<xsl:when test="($isNMTOKENtype = 'true')">
			<xsl:text>		if (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> == null)
			</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> = new String();
		// Check that newValue parameter meets naming requirements before assigning to </xsl:text>
			<xsl:value-of select="$elementName"/>
			<xsl:text>
		if (</xsl:text>
			<xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'AS')) or
						   not(@use='required')">
				<!-- attribute is not #REQUIRED and so can be empty -->
				<xsl:text disable-output-escaping="yes"><![CDATA[!newValue.isEmpty() && ]]></xsl:text>
			</xsl:if>
			<xsl:text>!org.web3d.x3d.jsail.fields.SFStringObject.isNMTOKEN(newValue))</xsl:text>
				<xsl:text>&#10;</xsl:text>
			<xsl:text>		{</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>			throw new org.web3d.x3d.sai.InvalidFieldValueException</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>='" + </xsl:text>
			<xsl:choose>
				<xsl:when test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$newValue"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "'"</xsl:text>
			<xsl:if test="InterfaceDefinition/field[@name = 'DEF']">
				<xsl:text> + " DEF='" + getDEF() + "'"</xsl:text>
			</xsl:if>
			<xsl:text> + </xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>				" has illegal name value, cannot be empty and must be defined with valid NMTOKEN name string"</xsl:text>
			<xsl:text> + </xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>				" (with legal characters and no embedded whitespace).</xsl:text>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		}</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>
		if (</xsl:text>
			<xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'AS')) or
						   not(@use='required')">
				<!-- attribute is not #REQUIRED and so can be empty -->
				<xsl:text disable-output-escaping="yes"><![CDATA[!newValue.isEmpty() && ]]></xsl:text>
			</xsl:if>
			<xsl:text>!org.web3d.x3d.jsail.fields.SFStringObject.meetsX3dNamingConventions(newValue))</xsl:text>
				<xsl:text>&#10;</xsl:text>
			<xsl:text>		{</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>			System.out.println</xsl:text>
			<xsl:text>("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>='" + </xsl:text>
			<xsl:choose>
				<xsl:when test="($isArrayListType = 'true') and ($comparisonType = 'simple')">
					<xsl:text>Arrays.toString(</xsl:text>
					<xsl:value-of select="$newValue"/>
					<xsl:text>)</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$newValue"/>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:text> + "'"</xsl:text>
			<xsl:if test="InterfaceDefinition/field[@name = 'DEF']">
				<xsl:text> + " DEF='" + getDEF() + "'"</xsl:text>
			</xsl:if>
			<xsl:text> + </xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>				" has name value that does not meet X3D naming conventions.</xsl:text>
			<xsl:text>");</xsl:text>
			<xsl:text>&#10;</xsl:text>
			<xsl:text>		}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:when>
		<xsl:when test="(@type='SFString')">
			<xsl:text>		if (</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> == null)
			</xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text> = new String(); // Principle of Least Astonishment (POLA)
			// https://en.wikipedia.org/wiki/Principle_of_least_astonishment
</xsl:text>
			<xsl:if test="($isNMTOKENtype = 'true')">
				<xsl:text>
		// Check that newValue parameter meets naming requirements before assigning to </xsl:text>
			<xsl:value-of select="$elementName"/>
			<xsl:text>
		if (</xsl:text>
			<xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'AS')) or
						   not(@use='required')">
				<!-- attribute is not #REQUIRED and so can be empty -->
				<xsl:text disable-output-escaping="yes"><![CDATA[!newValue.isEmpty() && ]]></xsl:text>
			</xsl:if>
				<xsl:text>!org.web3d.x3d.jsail.fields.SFStringObject.isNMTOKEN(newValue))
		{
			throw new org.web3d.x3d.sai.InvalidFieldValueException("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=\"" + </xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[newValue +
					"\" has illegal value, must use a valid string meeting NMTOKEN requirements.");
		}
		else if (]]></xsl:text>
			<xsl:if test="((@name = 'DEF') or (@name = 'USE') or (@name = 'AS')) or
						   not(@use='required')">
				<!-- attribute is not #REQUIRED and so can be empty -->
				<xsl:text disable-output-escaping="yes"><![CDATA[!newValue.isEmpty() && ]]></xsl:text>
			</xsl:if>
				<xsl:text>!org.web3d.x3d.jsail.fields.SFStringObject.meetsX3dNamingConventions(newValue))
		{
			System.out.println ("Warning: ";
			throw new org.web3d.x3d.sai.InvalidFieldValueException("</xsl:text>
			<xsl:value-of select="ancestor::*[string-length(@name) > 0]/@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="$newValue"/>
			<xsl:text>=\"" + </xsl:text>
			<xsl:text disable-output-escaping="yes"><![CDATA[newValue +
					"\" does not meet X3D naming conventions.");
		}
]]></xsl:text>
			</xsl:if>
		</xsl:when>
	</xsl:choose>
	<xsl:choose>
		<xsl:when test="($isArrayType='true')">
			<xsl:text>	}</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:when>
		<xsl:when test="($isArrayListType = 'true')">
		</xsl:when>
	</xsl:choose>
</xsl:template>
	
    <!-- ===================================================== -->
	
<!-- from BuildSpecificationLanguageBindingJava.xslt adapted for X3D Object Model-->
<xsl:template name="list-restrictions">
    <xsl:variable name="originalType" select="@type"/>
    <xsl:variable name="isEnumerationType" select="(count(enumeration) > 0)"/>
    <xsl:variable name="enumerationValues">
		<xsl:if test="enumeration">
			<xsl:text>[</xsl:text>
			<xsl:for-each select="enumeration">
				<xsl:text>'</xsl:text><!-- MFString enumeration values are quoted -->
				<xsl:value-of select="@value"/>
				<xsl:text>'</xsl:text>
				<xsl:if test="not(position() = last())">
					<xsl:text>|</xsl:text>
				</xsl:if>
			</xsl:for-each>
			<xsl:if test="(@additionalEnumerationValuesAllowed='true')">
				<xsl:choose>
					<xsl:when test="(@type='SFString')">
						<xsl:text>|'etc.'</xsl:text>
					</xsl:when>
					<xsl:when test="(@type='MFString')">
						<xsl:text>|'"etc."'</xsl:text>
					</xsl:when>
				</xsl:choose>
			</xsl:if>
			<xsl:text>]</xsl:text>
		</xsl:if>
    </xsl:variable>
    <xsl:choose>
        <xsl:when test="(@type='SFBool') or (@type='MFBool') or (@type='featurePointNames') or (@type='jointNames') or (@type='segmentNames') or (@type='siteNames')">
            <!-- no restriction-->
        </xsl:when>
        <xsl:when test="(@name = 'bboxSize')">
            <xsl:text>within allowed range of </xsl:text>
            <xsl:text>[0,infinity), or default value [-1 -1 -1], </xsl:text>
        </xsl:when>
        <xsl:when test="contains(@type,'RGBA')">
            <xsl:text>using RGBA values [0..1] </xsl:text>
        </xsl:when>
        <xsl:when test="contains(@type,'Color') or contains(@name,'Color') or contains(@name,'color')">
            <xsl:text>using RGB values [0..1] </xsl:text>
        </xsl:when>
        <xsl:when test="(@name = 'objectType')">
            <xsl:text>with quoted value(s) </xsl:text>
            <xsl:text>["ALL","NONE","TERRAIN",...] </xsl:text>
        </xsl:when>
        <xsl:when test="(@name = 'type') and (ancestor::*[@name='NavigationInfo'])">
            <xsl:text>with quoted value(s) </xsl:text>
            <xsl:text>["ANY","WALK","EXAMINE","FLY","LOOKAT","NONE","EXPLORE",...] </xsl:text>
        </xsl:when>
        <xsl:when test="(@name = 'transitionType') and (ancestor::*[@name='NavigationInfo'])">
            <xsl:text>with quoted value(s) </xsl:text>
            <xsl:text>["TELEPORT","LINEAR","ANIMATE",...] </xsl:text>
        </xsl:when>
        <xsl:when test="(@name = 'GeoOrigin') or (@name = 'geoOrigin')">
            <!-- http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/deprecation/deprecation.html -->
            <xsl:text>(deprecated node, optional) </xsl:text>
        </xsl:when>
        <xsl:when test="((@type='SFString') or (@type='MFString')) and (string-length(xs:annotation/xs:documentation) > 0)">
            <xsl:value-of select="normalize-space(xs:annotation/xs:documentation)"/>
            <xsl:text> </xsl:text>
        </xsl:when>
        <xsl:when test="(string-length($enumerationValues) > 0)">
            <xsl:value-of select="$enumerationValues"/>
            <xsl:text> </xsl:text>
        </xsl:when>
        <xsl:when test="((@type='SFString') or (@type='MFString')) and (string-length(xs:simpleType/xs:restriction/@base) > 0)">
            <xsl:value-of select="xs:simpleType/xs:restriction/@base"/>
            <xsl:text> </xsl:text>
        </xsl:when>
        <xsl:when test="(@type='SFString') or (@type='MFString')">
            <!-- no restriction-->
        </xsl:when>
        <xsl:when test="(string-length(@minInclusive) > 0) or (string-length(@minExclusive) > 0) or (string-length(@maxInclusive) > 0) or (string-length(@maxExclusive) > 0)">
            <xsl:text>within allowed range of </xsl:text>
            <xsl:choose>
                <xsl:when test="(string-length(@minInclusive) > 0)">
                    <xsl:text>[</xsl:text>
                    <xsl:value-of select="@minInclusive"/>
                </xsl:when>
                <xsl:when test="(string-length(@minExclusive) > 0)">
                    <xsl:text>(</xsl:text>
                    <xsl:value-of select="@minExclusive"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>(-infinity</xsl:text> <!-- &#8734; &infin; infinity symbol -->
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text>,</xsl:text>
            <xsl:choose>
                <xsl:when test="(string-length(@maxInclusive) > 0)">
                    <xsl:value-of select="@maxInclusive"/>
                    <xsl:text>]</xsl:text>
                </xsl:when>
                <xsl:when test="(string-length(@maxExclusive) > 0)">
                    <xsl:value-of select="@maxExclusive"/>
                    <xsl:text>)</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>infinity)</xsl:text> <!-- &#8734; &infin; infinity symbol -->
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text> </xsl:text>
        </xsl:when>
        <!-- retrieve range for specially defined simpleTypes, e.g. intensityType -->
        <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction">
			<xsl:text>within allowed range of </xsl:text>
            <xsl:choose>
                <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:minInclusive">
                    <xsl:text>[</xsl:text>
                    <xsl:value-of select="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:minInclusive/@value"/>
                </xsl:when>
                <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:minExclusive">
                    <xsl:text>(</xsl:text>
                    <xsl:value-of select="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:minExclusive/@value"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>(-infinity</xsl:text> <!-- &infin; infinity symbol -->
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text>,</xsl:text>
            <xsl:choose>
                <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:maxInclusive">
                    <xsl:value-of select="/xs:schema/maxInclusive/@value"/>
                    <xsl:text>]</xsl:text>
                </xsl:when>
                <xsl:when test="/xs:schema/xs:simpleType[@name=$originalType]/xs:restriction/xs:maxExclusive">
                    <xsl:value-of select="/xs:schema/maxExclusive/@value"/>
                    <xsl:text>)</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>infinity)</xsl:text> <!-- &infin; infinity symbol -->
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text> </xsl:text>
        </xsl:when>
        <xsl:when test="((@type='SFNode') or (@type='MFNode')) and (string-length(@acceptableNodeTypes) > 0) and (contains(@acceptableNodeTypes,'|'))">
            <xsl:text>with acceptable node types limited to </xsl:text>
			<xsl:value-of select="@acceptableNodeTypes"/>
            <xsl:text>, </xsl:text>
        </xsl:when>
    </xsl:choose>
</xsl:template>

<!-- from BuildSpecificationLanguageBindingJava.xslt -->

<xsl:template name="escape-quotes-recurse">
  <xsl:param name="inputString"><xsl:text></xsl:text></xsl:param>
  <xsl:param name="indent"><xsl:text></xsl:text></xsl:param>
  <xsl:choose>
    <xsl:when test="not(contains($inputString,'&quot;'))">
      <xsl:value-of select="$inputString"/>
    </xsl:when>
    <!-- has quote, or has quote before \" -->
    <xsl:when test="not(contains($inputString,'\&quot;')) or (string-length(substring-before($inputString,'&quot;')) &lt; string-length(substring-before($inputString,'\&quot;')))">
      <xsl:value-of select="substring-before($inputString,'&quot;')"/>
      <xsl:text>\&quot;</xsl:text>
      <xsl:call-template name="escape-quotes-recurse">
        <xsl:with-param name="inputString" select="substring-after($inputString,'&quot;')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="substring-before($inputString,'\&quot;')"/>
      <xsl:text>\&quot;</xsl:text>
      <xsl:call-template name="escape-quotes-recurse">
        <xsl:with-param name="inputString" select="substring-after($inputString,'\&quot;')"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="append-f-to-float-values-recurse">
  <xsl:param name="inputString"><xsl:text></xsl:text></xsl:param>
  <xsl:param name="indent"><xsl:text></xsl:text></xsl:param>
  <xsl:choose>
    <xsl:when test="not(string-length(normalize-space($inputString)) > 0)">
      <!-- empty value -->
    </xsl:when>
      <!-- singleton value -->
    <xsl:when test="not(contains($inputString,' ')) and not(contains($inputString,','))">
      <xsl:value-of select="$inputString"/>
      <xsl:text>f</xsl:text>
    </xsl:when>
    <!-- space, or space precedes comma (if comma is present) -->
    <xsl:when test="contains($inputString,' ') and 
                   (not(contains($inputString,',')) or 
                       (string-length(substring-before($inputString,',')) > string-length(substring-before($inputString,' '))))">
     <xsl:value-of select="substring-before($inputString,' ')"/>
      <xsl:text>f,</xsl:text>
      <xsl:call-template name="append-f-to-float-values-recurse">
        <xsl:with-param name="inputString" select="normalize-space(substring-after($inputString,' '))"/>
      </xsl:call-template>
    </xsl:when>
    <!-- comma precedes space -->
    <xsl:otherwise>
      <xsl:value-of select="substring-before($inputString,',')"/>
      <xsl:text>f,</xsl:text>
      <xsl:call-template name="append-f-to-float-values-recurse">
        <xsl:with-param name="inputString" select="normalize-space(substring-after($inputString,','))"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="append-zero-to-double-values-recurse">
  <!-- boxing of generics requires that double values be in double form, e.g. 0.0 vice 0 -->
  <xsl:param name="inputString"><xsl:text></xsl:text></xsl:param>
  <xsl:param name="indent"><xsl:text></xsl:text></xsl:param>
  <xsl:choose>
    <xsl:when test="not(string-length(normalize-space($inputString)) > 0)">
      <!-- empty value -->
    </xsl:when>
      <!-- singleton value -->
    <xsl:when test="not(contains($inputString,' ')) and not(contains($inputString,','))">
      <xsl:value-of select="$inputString"/>
	  <xsl:if test="not(contains($inputString,'.'))">
		  <xsl:text>.0</xsl:text>
	  </xsl:if>
    </xsl:when>
    <!-- space, or space precedes comma (if comma is present) -->
    <xsl:when test="contains($inputString,' ') and 
                   (not(contains($inputString,',')) or 
                       (string-length(substring-before($inputString,',')) > string-length(substring-before($inputString,' '))))">
      <xsl:variable name="element">
		  <xsl:value-of select="substring-before($inputString,' ')"/>
	  </xsl:variable>
	  <xsl:value-of select="$element"/>
	  <xsl:if test="not(contains($element,'.'))">
		  <xsl:text>.0</xsl:text>
	  </xsl:if>
	  <xsl:text>,</xsl:text>
      <xsl:call-template name="append-zero-to-double-values-recurse">
        <xsl:with-param name="inputString" select="normalize-space(substring-after($inputString,' '))"/>
      </xsl:call-template>
    </xsl:when>
    <!-- comma precedes space -->
    <xsl:otherwise>
      <xsl:variable name="element">
		  <xsl:value-of select="substring-before($inputString,',')"/>
	  </xsl:variable>
	  <xsl:value-of select="$element"/>
	  <xsl:if test="not(contains($element,'.'))">
		  <xsl:text>.0</xsl:text>
	  </xsl:if>
	  <xsl:text>,</xsl:text>
      <xsl:call-template name="append-zero-to-double-values-recurse">
        <xsl:with-param name="inputString" select="normalize-space(substring-after($inputString,','))"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="insert-javadoc-line-breaks-recurse">
  <!-- boxing of generics requires that double values be in double form, e.g. 0.0 vice 0 -->
  <xsl:param name="inputString"><xsl:text></xsl:text></xsl:param>
  <xsl:param name="breakText1"><xsl:text></xsl:text></xsl:param>
  <xsl:param name="breakText2"><xsl:text></xsl:text></xsl:param>
  <xsl:choose>
    <xsl:when test="not(string-length(normalize-space($inputString)) > 0)">
      <!-- empty string -->
    </xsl:when>
    <xsl:when test="not(string-length(normalize-space($breakText1)) > 0)">
		<!-- no breakText1 to break on -->
		<xsl:value-of select="$inputString" disable-output-escaping="yes"/>
    </xsl:when>
    <xsl:when test="not(string-length(normalize-space($breakText2)) > 0)">
		<!-- no breakText2 to break on -->
		<xsl:value-of select="$inputString" disable-output-escaping="yes"/>
    </xsl:when>
    <xsl:when test="not(contains($inputString,$breakText1)) and not(contains($inputString,$breakText2))">
		<!-- no breakText found so all done -->
		<xsl:value-of select="$inputString" disable-output-escaping="yes"/>
    </xsl:when>
    <xsl:when test="starts-with(normalize-space($inputString),$breakText1)">
		<!-- starts with Hint: -->
		<!-- insert javadoc line break -->
		<xsl:text>&#10;</xsl:text>
		<xsl:text> * </xsl:text>	
		<xsl:text disable-output-escaping="yes"> &lt;li&gt; </xsl:text>
		<!-- skip initial Hint: or Warning: and determine what is next -->
		<xsl:variable name="preambleHint"    select="normalize-space(substring-before(substring-after($inputString,$breakText1),'Hint:'))"/>
		<xsl:variable name="preambleWarning" select="normalize-space(substring-before(substring-after($inputString,$breakText1),'Warning:'))"/>
		<xsl:choose>
			<xsl:when test="(string-length($preambleHint) = 0) and (string-length($preambleWarning) = 0)">
				<!-- this is last substring, no preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="substring-before($inputString,':')" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes">:&lt;/i&gt; </xsl:text>
				<xsl:value-of select="substring-after($inputString,':')" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
			</xsl:when>
			<xsl:when test="(string-length($preambleHint) > 0) and 
							 ((string-length($preambleWarning) = 0) or (string-length($preambleWarning) > string-length($preambleHint)))">
				<!-- Hint next follows this preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="$breakText1"/>
				<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$preambleHint" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
				<xsl:call-template name="insert-javadoc-line-breaks-recurse">
				  <xsl:with-param name="inputString" select="normalize-space(substring-after($inputString,$preambleHint))"/>
				  <xsl:with-param name="breakText1"  select="$breakText1"/>
				  <xsl:with-param name="breakText2"  select="$breakText2"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<!-- Warning next follows this preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="$breakText1"/>
				<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$preambleWarning" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
				<xsl:call-template name="insert-javadoc-line-breaks-recurse">
				  <xsl:with-param name="inputString" select="normalize-space(substring-after($inputString,$preambleWarning))"/>
				  <xsl:with-param name="breakText1"  select="$breakText1"/>
				  <xsl:with-param name="breakText2"  select="$breakText2"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
    </xsl:when>
	<xsl:otherwise>
		<!-- starts with Warning: -->
		<!-- insert javadoc line break -->
		<xsl:text>&#10;</xsl:text>
		<xsl:text> * </xsl:text>
		<xsl:text disable-output-escaping="yes"> &lt;li&gt; </xsl:text>
		<!-- skip initial Hint: or Warning: and determine what is next -->
		<xsl:variable name="preambleHint"    select="normalize-space(substring-before(substring-after($inputString,$breakText2),'Hint:'))"/>
		<xsl:variable name="preambleWarning" select="normalize-space(substring-before(substring-after($inputString,$breakText2),'Warning:'))"/>
		<xsl:choose>
			<xsl:when test="(string-length($preambleHint) = 0) and (string-length($preambleWarning) = 0)">
				<!-- this is last substring, no preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="substring-before($inputString,':')" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes">:&lt;/i&gt; </xsl:text>
				<xsl:value-of select="substring-after($inputString,':')" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
			</xsl:when>
			<xsl:when test="(string-length($preambleHint) > 0) and 
							 ((string-length($preambleWarning) = 0) or (string-length($preambleWarning) > string-length($preambleHint)))">
				<!-- Hint next follows this preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="$breakText2"/>
				<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$preambleHint" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
				<xsl:call-template name="insert-javadoc-line-breaks-recurse">
				  <xsl:with-param name="inputString" select="normalize-space(substring-after($inputString,$preambleHint))"/>
				  <xsl:with-param name="breakText1"   select="$breakText1"/>
				  <xsl:with-param name="breakText2"   select="$breakText2"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<!-- Warning next follows this preamble -->
				<xsl:text disable-output-escaping="yes">&lt;i&gt;</xsl:text>
				<xsl:value-of select="$breakText2"/>
				<xsl:text disable-output-escaping="yes">&lt;/i&gt;</xsl:text>
				<xsl:text> </xsl:text>
				<xsl:value-of select="$preambleWarning" disable-output-escaping="yes"/>
				<xsl:text disable-output-escaping="yes"> &lt;/li&gt; </xsl:text>
				<xsl:call-template name="insert-javadoc-line-breaks-recurse">
				  <xsl:with-param name="inputString" select="normalize-space(substring-after($inputString,$preambleWarning))"/>
				  <xsl:with-param name="breakText1"   select="$breakText1"/>
				  <xsl:with-param name="breakText2"   select="$breakText2"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:otherwise>
  </xsl:choose>
</xsl:template>
    
    <xsl:template name="wrap-hyperlinks">
		<!-- further adapted from X3dTooltipConversions.xslt -->
        <!-- Search and replace urls in text:  adapted (with thanks) from 
            http://www.dpawson.co.uk/xsl/rev2/regex2.html#d15961e67 by Jeni Tennison using url regex (http://[^ ]+) -->
        <!-- Justin Saunders http://regexlib.com/REDetails.aspx?regexp_id=37 url regex ((mailto:|(news|(ht|f)tp(s?))://){1}\S+) -->
        <xsl:param name="string" select="string(.)"/>
        <!-- wrap html text string with spaces to ensure no mismatches occur -->
        <xsl:variable name="spacedString">
            <xsl:text> </xsl:text>
            <xsl:value-of select="$string" disable-output-escaping="yes"/>
            <xsl:text> </xsl:text>
        </xsl:variable>
        <!-- debug diagnostic 
        <xsl:if test="contains($spacedString,'http')">
            <xsl:message>
                <xsl:text>*** wrap-hyperlinks diagnostic: $spacedString=</xsl:text>
                <xsl:value-of select="normalize-space($spacedString)" disable-output-escaping="yes"/>
            </xsl:message>
        </xsl:if>
        -->
        <!-- First: find and link url values.  Avoid matching encompassing quote marks. -->
        <xsl:analyze-string select="$spacedString" regex='(")?(mailto:|((news|http|https|sftp)://)[a-zA-Z0-9._%+-/#()]+)(")?'>
            <xsl:matching-substring>
				<xsl:variable name="urlValue">
					<xsl:choose>
						<xsl:when test="starts-with(.,'&quot;') and ends-with(.,'&quot;')">
							<xsl:value-of select="substring(.,2,string-length(.)-2)" disable-output-escaping="no"/>
						</xsl:when>
						<xsl:when test="starts-with(.,'&quot;')">
							<xsl:value-of select="substring(.,2)" disable-output-escaping="no"/>
						</xsl:when>
						<xsl:when test="ends-with(.,'&quot;')">
							<xsl:value-of select="substring(.,1,string-length(.)-2)" disable-output-escaping="no"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="." disable-output-escaping="no"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
                <!-- diagnostic
					<xsl:message>
						<xsl:text>*** regex match success (</xsl:text>
						<xsl:value-of select="."/>
						<xsl:text>) (</xsl:text>
						<xsl:value-of select="$urlValue"/>
						<xsl:text>) </xsl:text>
					</xsl:message>
                -->
				<!-- originally no <br> inserted in javadoc since encompassing quotes didn't break across lines evenly -->
				<xsl:text disable-output-escaping="no"> &lt;br&gt; </xsl:text>
				<xsl:if test="starts-with(.,'&quot;')">
					<xsl:text>&quot;</xsl:text>
				</xsl:if>
				<xsl:text disable-output-escaping="no">&lt;a href="</xsl:text>
				<xsl:value-of select="$urlValue"/>
				<xsl:if test="(contains(.,'youtube.com') or contains(.,'youtu.be')) and not(contains(.,'rel='))">
					<!-- prevent advertising other YouTube videos when complete -->
					<xsl:text disable-output-escaping="yes">&amp;rel=0</xsl:text>
				</xsl:if>
				<xsl:text disable-output-escaping="no">" target="_blank"&gt;</xsl:text>
					<xsl:value-of select="$urlValue"/>
				<xsl:text disable-output-escaping="no">&lt;/a&gt;</xsl:text>
				<xsl:if test="ends-with(.,'&quot;')">
					<xsl:text>&quot;</xsl:text>
				</xsl:if>
				<!-- alternate form doesn't work because text is being produced, not elements
				<xsl:element name="a">
					<xsl:attribute name="href">
						<xsl:value-of select="."/>
					</xsl:attribute>
					<xsl:attribute name="target">
						<xsl:text>_blank</xsl:text>
					</xsl:attribute>
					<xsl:value-of select="."/>
				</xsl:element>
				-->
            </xsl:matching-substring>
            <xsl:non-matching-substring>
                <!-- diagnostic
                <xsl:if test="(string-length(normalize-space(.)) > 0)">
                    <xsl:message>
                        <xsl:text>**regex match failure (</xsl:text>
                        <xsl:copy-of select="."/>
                        <xsl:text>)**</xsl:text>
                    </xsl:message>
                </xsl:if>
                -->
                <!-- avoid returning excess whitespace -->
                <xsl:choose>
                    <xsl:when test="(string-length(.) > 0) and (string-length(normalize-space(.)) = 0)">
                        <xsl:text> </xsl:text>
                    </xsl:when>
                    <xsl:when test="string-length(normalize-space(.)) > 0">
						<!-- xsl:text> escape-javadoc-characters3 </xsl:text -->
						<xsl:call-template name="escape-javadoc-characters">
							<xsl:with-param name="inputString">
								<xsl:value-of select="." disable-output-escaping="yes"/>
							</xsl:with-param>
						</xsl:call-template>
                    </xsl:when>
                </xsl:choose>
            </xsl:non-matching-substring>
        </xsl:analyze-string>
    </xsl:template>

    <xsl:template name="escape-javadoc-characters">
        <xsl:param name="inputString"><xsl:text></xsl:text><!-- default value is empty --></xsl:param>
		<!-- don't escape apostrophes, that makes javadoc unhappy -->
		<xsl:call-template name="escape-greaterthan-characters">
			<xsl:with-param name="inputString">
				<xsl:call-template name="escape-lessthan-characters">
					<xsl:with-param name="inputString">
						<!-- do not escape-quote-characters!
						<xsl:call-template name="escape-quote-characters">
								<xsl:with-param name="inputString">
								</xsl:with-param>
						</xsl:call-template>
						-->
									<!-- NOTE keep escape-ampersand-characters innermost so it doesn't get overzealous about escaped apostrophes or less-than characters -->
									<xsl:call-template name="escape-ampersand-characters">
										<xsl:with-param name="inputString" select="$inputString"/>
									</xsl:call-template>
					</xsl:with-param>
				</xsl:call-template>
			</xsl:with-param>
		</xsl:call-template>
    </xsl:template>

    <xsl:template name="escape-lessthan-characters">
        <xsl:param name="inputString"><xsl:text></xsl:text><!-- default value is empty --></xsl:param>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:message><xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/></xsl:message> -->
        <xsl:choose>
            <!-- &#60; is &lt; -->
            <xsl:when test="contains($inputString,'&#60;')">
				<xsl:value-of select="substring-before($inputString,'&#60;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="no">&amp;</xsl:text>
                <xsl:text disable-output-escaping="no">lt;</xsl:text>
                <xsl:call-template name="escape-lessthan-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputString" select="substring-after($inputString,'&#60;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="escape-greaterthan-characters">
        <xsl:param name="inputString"><xsl:text></xsl:text><!-- default value is empty --></xsl:param>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:message><xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/></xsl:message> -->
        <xsl:choose>
            <!-- &#62; is &gt; -->
            <xsl:when test="contains($inputString,'&#62;')">
                <xsl:value-of select="substring-before($inputString,'&#62;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="no">&amp;</xsl:text>
                <xsl:text disable-output-escaping="no">gt;</xsl:text>
                <xsl:call-template name="escape-greaterthan-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputString" select="substring-after($inputString,'&#62;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="escape-quote-characters">
        <xsl:param name="inputString"><xsl:text></xsl:text><!-- default value is empty --></xsl:param>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:message><xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/></xsl:message> -->
        <xsl:choose>
            <!-- &#62; is &gt; -->
            <xsl:when test="contains($inputString,'&#34;')">
                <xsl:value-of select="substring-before($inputString,'&#34;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="no">&amp;</xsl:text>
                <xsl:text disable-output-escaping="no">#34;</xsl:text>
                <xsl:call-template name="escape-quote-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputString" select="substring-after($inputString,'&#34;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="escape-ampersand-characters">
        <xsl:param name="inputString"><xsl:text></xsl:text><!-- default value is empty --></xsl:param>
        <!-- debug:  <xsl:text>//######&#10;</xsl:text> -->
        <!-- debug:  <xsl:text>### inputString received: </xsl:text><xsl:value-of select="$inputString"/><xsl:text>&#10;</xsl:text> -->
        <xsl:choose>
            <!-- probably do not have to worry about solo cases with stray ampersands, because they are badly formed XML and will not parse: 
                 and (starts-with(substring-after($inputString,'&amp;'),' ') or substring-after($inputString,''))-->
            <!-- first pass through escaped ampersand character, but only if other ampersand codes do not precede it -->
            <xsl:when test="contains($inputString,'&amp;amp;') and not(contains(substring-before($inputString,'&amp;amp;'),'&amp;'))">
                <xsl:value-of select="substring-before($inputString,'&amp;amp;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="yes">&amp;</xsl:text>
                <xsl:text disable-output-escaping="yes">amp;</xsl:text>
               <!-- <xsl:text disable-output-escaping="yes">amp;</xsl:text>-->
                <xsl:call-template name="escape-ampersand-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputString" select="substring-after($inputString,'&amp;amp;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="contains($inputString,'&amp;')">
                <xsl:value-of select="substring-before($inputString,'&amp;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="yes">&amp;</xsl:text>
                <xsl:text disable-output-escaping="yes">amp;</xsl:text> 
                <xsl:call-template name="escape-ampersand-characters"> <!-- tail recursion -->
                    <xsl:with-param name="inputString" select="substring-after($inputString,'&amp;')"/>
                </xsl:call-template>
            </xsl:when>
			<!-- enable to support debugging
            <xsl:when test="true()">
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:when>
			-->
			<!-- buggy and no longer needed apparently
            <xsl:when test="contains($inputString,'&amp;#38;') and not(contains(substring-before($inputString,'&amp;#38;'),'&amp;'))">
                <xsl:value-of select="substring-before($inputString,'&amp;amp;')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="yes">&amp;</xsl:text>
                <xsl:text disable-output-escaping="yes">#38;</xsl:text>
                <xsl:call-template name="escape-ampersand-characters">
                    <xsl:with-param name="inputString" select="substring-after($inputString,'&amp;amp;')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="contains($inputString,'&amp;#') and not(contains(substring-before($inputString,'&amp;#'),'&amp;'))">
                <xsl:value-of select="substring-before($inputString,'&amp;#')" disable-output-escaping="yes"/>
                <xsl:text disable-output-escaping="yes">&amp;</xsl:text>
                <xsl:text disable-output-escaping="yes">amp;#</xsl:text>
                <xsl:call-template name="escape-ampersand-characters">
                    <xsl:with-param name="inputString" select="substring-after($inputString,'&amp;#')"/>
                </xsl:call-template>
            </xsl:when> -->
            <xsl:otherwise>
                <xsl:value-of select="$inputString" disable-output-escaping="yes"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="bulletize-hints-warnings">
        <xsl:param name="tooltipText"><xsl:text></xsl:text><!-- default value is empty --></xsl:param>
		
		<xsl:variable name="containsHintWarning" select="contains($tooltipText,'Hint:') or contains($tooltipText,'Warning:')"/>
		<xsl:if test="(string-length($tooltipText) > 0)">
			<xsl:choose>
				<xsl:when test="$containsHintWarning">
					<xsl:variable name="preambleHint"    select="normalize-space(substring-before($tooltipText,'Hint:'))"/>
					<xsl:variable name="preambleWarning" select="normalize-space(substring-before($tooltipText,'Warning:'))"/>
					<xsl:choose>
						<xsl:when test="(string-length($preambleHint) > 0) and 
										 ((string-length($preambleWarning) = 0) or (string-length($preambleWarning) > string-length($preambleHint)))">
							<xsl:value-of select="$preambleHint" disable-output-escaping="yes"/>
							<xsl:text>&#10;</xsl:text>
							<xsl:text> * </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;ul&gt;</xsl:text>
							<xsl:call-template name="insert-javadoc-line-breaks-recurse">
								<xsl:with-param name="inputString">
									<xsl:value-of select="substring-after(normalize-space($tooltipText),$preambleHint)" disable-output-escaping="yes"/>
								</xsl:with-param>
								<xsl:with-param name="breakText1"><xsl:text>Hint:</xsl:text></xsl:with-param>
								<xsl:with-param name="breakText2"><xsl:text>Warning:</xsl:text></xsl:with-param>
							</xsl:call-template>
							<xsl:text>&#10;</xsl:text>
							<xsl:text> * </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;/ul&gt;</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$preambleWarning" disable-output-escaping="yes"/>
							<xsl:text>&#10;</xsl:text>
							<xsl:text> * </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;ul&gt;</xsl:text>
							<xsl:call-template name="insert-javadoc-line-breaks-recurse">
								<xsl:with-param name="inputString">
									<xsl:value-of select="substring-after(normalize-space($tooltipText),$preambleWarning)" disable-output-escaping="yes"/>
								</xsl:with-param>
								<xsl:with-param name="breakText1"><xsl:text>Hint:</xsl:text></xsl:with-param>
								<xsl:with-param name="breakText2"><xsl:text>Warning:</xsl:text></xsl:with-param>
							</xsl:call-template>
							<xsl:text>&#10;</xsl:text>
							<xsl:text> * </xsl:text>
							<xsl:text disable-output-escaping="yes">&lt;/ul&gt;</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:otherwise>
					<!-- xsl:text> escape-javadoc-characters4 </xsl:text -->
					<xsl:call-template name="escape-javadoc-characters">
						<xsl:with-param name="inputString">
							<xsl:value-of select="$tooltipText" disable-output-escaping="yes"/>
						</xsl:with-param>
					</xsl:call-template>
				</xsl:otherwise>
			</xsl:choose>
			<!--
			<xsl:text>&#10;</xsl:text>
			<xsl:text> * </xsl:text>
			<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!- - line break - ->
			<xsl:text>&#10;</xsl:text>
			-->
			<xsl:if test="not($containsHintWarning)">
				<xsl:text> * </xsl:text>
				<xsl:text disable-output-escaping="yes">&lt;br&gt;</xsl:text><!-- line break -->
				<xsl:text>&#10;</xsl:text>
			</xsl:if>				
		</xsl:if>
    </xsl:template>

</xsl:stylesheet>
